
serial.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00028aac  08000190  08000190  00001190  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000b300  08028c3c  08028c3c  00029c3c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08033f3c  08033f3c  00035184  2**0
                  CONTENTS, READONLY
  4 .ARM          00000008  08033f3c  08033f3c  00034f3c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  08033f44  08033f44  00035184  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08033f44  08033f44  00034f44  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  08033f48  08033f48  00034f48  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         00000184  20000000  08033f4c  00035000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .ccmram       00000000  10000000  10000000  00035184  2**0
                  CONTENTS
 10 .bss          000044bc  20000184  20000184  00035184  2**2
                  ALLOC
 11 ._user_heap_stack 00000800  20004640  20004640  00035184  2**0
                  ALLOC
 12 .ARM.attributes 00000030  00000000  00000000  00035184  2**0
                  CONTENTS, READONLY
 13 .debug_info   000971fa  00000000  00000000  000351b4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 00008752  00000000  00000000  000cc3ae  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 00006bd0  00000000  00000000  000d4b00  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_rnglists 000058a4  00000000  00000000  000db6d0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  0003662c  00000000  00000000  000e0f74  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   0006a901  00000000  00000000  001175a0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    00113f73  00000000  00000000  00181ea1  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .comment      00000043  00000000  00000000  00295e14  2**0
                  CONTENTS, READONLY
 21 .debug_frame  0001ee74  00000000  00000000  00295e58  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_line_str 00000059  00000000  00000000  002b4ccc  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000190 <__do_global_dtors_aux>:
 8000190:	b510      	push	{r4, lr}
 8000192:	4c05      	ldr	r4, [pc, #20]	@ (80001a8 <__do_global_dtors_aux+0x18>)
 8000194:	7823      	ldrb	r3, [r4, #0]
 8000196:	b933      	cbnz	r3, 80001a6 <__do_global_dtors_aux+0x16>
 8000198:	4b04      	ldr	r3, [pc, #16]	@ (80001ac <__do_global_dtors_aux+0x1c>)
 800019a:	b113      	cbz	r3, 80001a2 <__do_global_dtors_aux+0x12>
 800019c:	4804      	ldr	r0, [pc, #16]	@ (80001b0 <__do_global_dtors_aux+0x20>)
 800019e:	f3af 8000 	nop.w
 80001a2:	2301      	movs	r3, #1
 80001a4:	7023      	strb	r3, [r4, #0]
 80001a6:	bd10      	pop	{r4, pc}
 80001a8:	20000184 	.word	0x20000184
 80001ac:	00000000 	.word	0x00000000
 80001b0:	08028c24 	.word	0x08028c24

080001b4 <frame_dummy>:
 80001b4:	b508      	push	{r3, lr}
 80001b6:	4b03      	ldr	r3, [pc, #12]	@ (80001c4 <frame_dummy+0x10>)
 80001b8:	b11b      	cbz	r3, 80001c2 <frame_dummy+0xe>
 80001ba:	4903      	ldr	r1, [pc, #12]	@ (80001c8 <frame_dummy+0x14>)
 80001bc:	4803      	ldr	r0, [pc, #12]	@ (80001cc <frame_dummy+0x18>)
 80001be:	f3af 8000 	nop.w
 80001c2:	bd08      	pop	{r3, pc}
 80001c4:	00000000 	.word	0x00000000
 80001c8:	20000188 	.word	0x20000188
 80001cc:	08028c24 	.word	0x08028c24

080001d0 <strcmp>:
 80001d0:	f810 2b01 	ldrb.w	r2, [r0], #1
 80001d4:	f811 3b01 	ldrb.w	r3, [r1], #1
 80001d8:	2a01      	cmp	r2, #1
 80001da:	bf28      	it	cs
 80001dc:	429a      	cmpcs	r2, r3
 80001de:	d0f7      	beq.n	80001d0 <strcmp>
 80001e0:	1ad0      	subs	r0, r2, r3
 80001e2:	4770      	bx	lr

080001e4 <strlen>:
 80001e4:	4603      	mov	r3, r0
 80001e6:	f813 2b01 	ldrb.w	r2, [r3], #1
 80001ea:	2a00      	cmp	r2, #0
 80001ec:	d1fb      	bne.n	80001e6 <strlen+0x2>
 80001ee:	1a18      	subs	r0, r3, r0
 80001f0:	3801      	subs	r0, #1
 80001f2:	4770      	bx	lr
	...

08000200 <memchr>:
 8000200:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
 8000204:	2a10      	cmp	r2, #16
 8000206:	db2b      	blt.n	8000260 <memchr+0x60>
 8000208:	f010 0f07 	tst.w	r0, #7
 800020c:	d008      	beq.n	8000220 <memchr+0x20>
 800020e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000212:	3a01      	subs	r2, #1
 8000214:	428b      	cmp	r3, r1
 8000216:	d02d      	beq.n	8000274 <memchr+0x74>
 8000218:	f010 0f07 	tst.w	r0, #7
 800021c:	b342      	cbz	r2, 8000270 <memchr+0x70>
 800021e:	d1f6      	bne.n	800020e <memchr+0xe>
 8000220:	b4f0      	push	{r4, r5, r6, r7}
 8000222:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8000226:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800022a:	f022 0407 	bic.w	r4, r2, #7
 800022e:	f07f 0700 	mvns.w	r7, #0
 8000232:	2300      	movs	r3, #0
 8000234:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000238:	3c08      	subs	r4, #8
 800023a:	ea85 0501 	eor.w	r5, r5, r1
 800023e:	ea86 0601 	eor.w	r6, r6, r1
 8000242:	fa85 f547 	uadd8	r5, r5, r7
 8000246:	faa3 f587 	sel	r5, r3, r7
 800024a:	fa86 f647 	uadd8	r6, r6, r7
 800024e:	faa5 f687 	sel	r6, r5, r7
 8000252:	b98e      	cbnz	r6, 8000278 <memchr+0x78>
 8000254:	d1ee      	bne.n	8000234 <memchr+0x34>
 8000256:	bcf0      	pop	{r4, r5, r6, r7}
 8000258:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
 800025c:	f002 0207 	and.w	r2, r2, #7
 8000260:	b132      	cbz	r2, 8000270 <memchr+0x70>
 8000262:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000266:	3a01      	subs	r2, #1
 8000268:	ea83 0301 	eor.w	r3, r3, r1
 800026c:	b113      	cbz	r3, 8000274 <memchr+0x74>
 800026e:	d1f8      	bne.n	8000262 <memchr+0x62>
 8000270:	2000      	movs	r0, #0
 8000272:	4770      	bx	lr
 8000274:	3801      	subs	r0, #1
 8000276:	4770      	bx	lr
 8000278:	2d00      	cmp	r5, #0
 800027a:	bf06      	itte	eq
 800027c:	4635      	moveq	r5, r6
 800027e:	3803      	subeq	r0, #3
 8000280:	3807      	subne	r0, #7
 8000282:	f015 0f01 	tst.w	r5, #1
 8000286:	d107      	bne.n	8000298 <memchr+0x98>
 8000288:	3001      	adds	r0, #1
 800028a:	f415 7f80 	tst.w	r5, #256	@ 0x100
 800028e:	bf02      	ittt	eq
 8000290:	3001      	addeq	r0, #1
 8000292:	f415 3fc0 	tsteq.w	r5, #98304	@ 0x18000
 8000296:	3001      	addeq	r0, #1
 8000298:	bcf0      	pop	{r4, r5, r6, r7}
 800029a:	3801      	subs	r0, #1
 800029c:	4770      	bx	lr
 800029e:	bf00      	nop

080002a0 <__aeabi_uldivmod>:
 80002a0:	b953      	cbnz	r3, 80002b8 <__aeabi_uldivmod+0x18>
 80002a2:	b94a      	cbnz	r2, 80002b8 <__aeabi_uldivmod+0x18>
 80002a4:	2900      	cmp	r1, #0
 80002a6:	bf08      	it	eq
 80002a8:	2800      	cmpeq	r0, #0
 80002aa:	bf1c      	itt	ne
 80002ac:	f04f 31ff 	movne.w	r1, #4294967295	@ 0xffffffff
 80002b0:	f04f 30ff 	movne.w	r0, #4294967295	@ 0xffffffff
 80002b4:	f000 b988 	b.w	80005c8 <__aeabi_idiv0>
 80002b8:	f1ad 0c08 	sub.w	ip, sp, #8
 80002bc:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80002c0:	f000 f806 	bl	80002d0 <__udivmoddi4>
 80002c4:	f8dd e004 	ldr.w	lr, [sp, #4]
 80002c8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80002cc:	b004      	add	sp, #16
 80002ce:	4770      	bx	lr

080002d0 <__udivmoddi4>:
 80002d0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80002d4:	9d08      	ldr	r5, [sp, #32]
 80002d6:	468e      	mov	lr, r1
 80002d8:	4604      	mov	r4, r0
 80002da:	4688      	mov	r8, r1
 80002dc:	2b00      	cmp	r3, #0
 80002de:	d14a      	bne.n	8000376 <__udivmoddi4+0xa6>
 80002e0:	428a      	cmp	r2, r1
 80002e2:	4617      	mov	r7, r2
 80002e4:	d962      	bls.n	80003ac <__udivmoddi4+0xdc>
 80002e6:	fab2 f682 	clz	r6, r2
 80002ea:	b14e      	cbz	r6, 8000300 <__udivmoddi4+0x30>
 80002ec:	f1c6 0320 	rsb	r3, r6, #32
 80002f0:	fa01 f806 	lsl.w	r8, r1, r6
 80002f4:	fa20 f303 	lsr.w	r3, r0, r3
 80002f8:	40b7      	lsls	r7, r6
 80002fa:	ea43 0808 	orr.w	r8, r3, r8
 80002fe:	40b4      	lsls	r4, r6
 8000300:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8000304:	fa1f fc87 	uxth.w	ip, r7
 8000308:	fbb8 f1fe 	udiv	r1, r8, lr
 800030c:	0c23      	lsrs	r3, r4, #16
 800030e:	fb0e 8811 	mls	r8, lr, r1, r8
 8000312:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 8000316:	fb01 f20c 	mul.w	r2, r1, ip
 800031a:	429a      	cmp	r2, r3
 800031c:	d909      	bls.n	8000332 <__udivmoddi4+0x62>
 800031e:	18fb      	adds	r3, r7, r3
 8000320:	f101 30ff 	add.w	r0, r1, #4294967295	@ 0xffffffff
 8000324:	f080 80ea 	bcs.w	80004fc <__udivmoddi4+0x22c>
 8000328:	429a      	cmp	r2, r3
 800032a:	f240 80e7 	bls.w	80004fc <__udivmoddi4+0x22c>
 800032e:	3902      	subs	r1, #2
 8000330:	443b      	add	r3, r7
 8000332:	1a9a      	subs	r2, r3, r2
 8000334:	b2a3      	uxth	r3, r4
 8000336:	fbb2 f0fe 	udiv	r0, r2, lr
 800033a:	fb0e 2210 	mls	r2, lr, r0, r2
 800033e:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8000342:	fb00 fc0c 	mul.w	ip, r0, ip
 8000346:	459c      	cmp	ip, r3
 8000348:	d909      	bls.n	800035e <__udivmoddi4+0x8e>
 800034a:	18fb      	adds	r3, r7, r3
 800034c:	f100 32ff 	add.w	r2, r0, #4294967295	@ 0xffffffff
 8000350:	f080 80d6 	bcs.w	8000500 <__udivmoddi4+0x230>
 8000354:	459c      	cmp	ip, r3
 8000356:	f240 80d3 	bls.w	8000500 <__udivmoddi4+0x230>
 800035a:	443b      	add	r3, r7
 800035c:	3802      	subs	r0, #2
 800035e:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
 8000362:	eba3 030c 	sub.w	r3, r3, ip
 8000366:	2100      	movs	r1, #0
 8000368:	b11d      	cbz	r5, 8000372 <__udivmoddi4+0xa2>
 800036a:	40f3      	lsrs	r3, r6
 800036c:	2200      	movs	r2, #0
 800036e:	e9c5 3200 	strd	r3, r2, [r5]
 8000372:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000376:	428b      	cmp	r3, r1
 8000378:	d905      	bls.n	8000386 <__udivmoddi4+0xb6>
 800037a:	b10d      	cbz	r5, 8000380 <__udivmoddi4+0xb0>
 800037c:	e9c5 0100 	strd	r0, r1, [r5]
 8000380:	2100      	movs	r1, #0
 8000382:	4608      	mov	r0, r1
 8000384:	e7f5      	b.n	8000372 <__udivmoddi4+0xa2>
 8000386:	fab3 f183 	clz	r1, r3
 800038a:	2900      	cmp	r1, #0
 800038c:	d146      	bne.n	800041c <__udivmoddi4+0x14c>
 800038e:	4573      	cmp	r3, lr
 8000390:	d302      	bcc.n	8000398 <__udivmoddi4+0xc8>
 8000392:	4282      	cmp	r2, r0
 8000394:	f200 8105 	bhi.w	80005a2 <__udivmoddi4+0x2d2>
 8000398:	1a84      	subs	r4, r0, r2
 800039a:	eb6e 0203 	sbc.w	r2, lr, r3
 800039e:	2001      	movs	r0, #1
 80003a0:	4690      	mov	r8, r2
 80003a2:	2d00      	cmp	r5, #0
 80003a4:	d0e5      	beq.n	8000372 <__udivmoddi4+0xa2>
 80003a6:	e9c5 4800 	strd	r4, r8, [r5]
 80003aa:	e7e2      	b.n	8000372 <__udivmoddi4+0xa2>
 80003ac:	2a00      	cmp	r2, #0
 80003ae:	f000 8090 	beq.w	80004d2 <__udivmoddi4+0x202>
 80003b2:	fab2 f682 	clz	r6, r2
 80003b6:	2e00      	cmp	r6, #0
 80003b8:	f040 80a4 	bne.w	8000504 <__udivmoddi4+0x234>
 80003bc:	1a8a      	subs	r2, r1, r2
 80003be:	0c03      	lsrs	r3, r0, #16
 80003c0:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 80003c4:	b280      	uxth	r0, r0
 80003c6:	b2bc      	uxth	r4, r7
 80003c8:	2101      	movs	r1, #1
 80003ca:	fbb2 fcfe 	udiv	ip, r2, lr
 80003ce:	fb0e 221c 	mls	r2, lr, ip, r2
 80003d2:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 80003d6:	fb04 f20c 	mul.w	r2, r4, ip
 80003da:	429a      	cmp	r2, r3
 80003dc:	d907      	bls.n	80003ee <__udivmoddi4+0x11e>
 80003de:	18fb      	adds	r3, r7, r3
 80003e0:	f10c 38ff 	add.w	r8, ip, #4294967295	@ 0xffffffff
 80003e4:	d202      	bcs.n	80003ec <__udivmoddi4+0x11c>
 80003e6:	429a      	cmp	r2, r3
 80003e8:	f200 80e0 	bhi.w	80005ac <__udivmoddi4+0x2dc>
 80003ec:	46c4      	mov	ip, r8
 80003ee:	1a9b      	subs	r3, r3, r2
 80003f0:	fbb3 f2fe 	udiv	r2, r3, lr
 80003f4:	fb0e 3312 	mls	r3, lr, r2, r3
 80003f8:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
 80003fc:	fb02 f404 	mul.w	r4, r2, r4
 8000400:	429c      	cmp	r4, r3
 8000402:	d907      	bls.n	8000414 <__udivmoddi4+0x144>
 8000404:	18fb      	adds	r3, r7, r3
 8000406:	f102 30ff 	add.w	r0, r2, #4294967295	@ 0xffffffff
 800040a:	d202      	bcs.n	8000412 <__udivmoddi4+0x142>
 800040c:	429c      	cmp	r4, r3
 800040e:	f200 80ca 	bhi.w	80005a6 <__udivmoddi4+0x2d6>
 8000412:	4602      	mov	r2, r0
 8000414:	1b1b      	subs	r3, r3, r4
 8000416:	ea42 400c 	orr.w	r0, r2, ip, lsl #16
 800041a:	e7a5      	b.n	8000368 <__udivmoddi4+0x98>
 800041c:	f1c1 0620 	rsb	r6, r1, #32
 8000420:	408b      	lsls	r3, r1
 8000422:	fa22 f706 	lsr.w	r7, r2, r6
 8000426:	431f      	orrs	r7, r3
 8000428:	fa0e f401 	lsl.w	r4, lr, r1
 800042c:	fa20 f306 	lsr.w	r3, r0, r6
 8000430:	fa2e fe06 	lsr.w	lr, lr, r6
 8000434:	ea4f 4917 	mov.w	r9, r7, lsr #16
 8000438:	4323      	orrs	r3, r4
 800043a:	fa00 f801 	lsl.w	r8, r0, r1
 800043e:	fa1f fc87 	uxth.w	ip, r7
 8000442:	fbbe f0f9 	udiv	r0, lr, r9
 8000446:	0c1c      	lsrs	r4, r3, #16
 8000448:	fb09 ee10 	mls	lr, r9, r0, lr
 800044c:	ea44 440e 	orr.w	r4, r4, lr, lsl #16
 8000450:	fb00 fe0c 	mul.w	lr, r0, ip
 8000454:	45a6      	cmp	lr, r4
 8000456:	fa02 f201 	lsl.w	r2, r2, r1
 800045a:	d909      	bls.n	8000470 <__udivmoddi4+0x1a0>
 800045c:	193c      	adds	r4, r7, r4
 800045e:	f100 3aff 	add.w	sl, r0, #4294967295	@ 0xffffffff
 8000462:	f080 809c 	bcs.w	800059e <__udivmoddi4+0x2ce>
 8000466:	45a6      	cmp	lr, r4
 8000468:	f240 8099 	bls.w	800059e <__udivmoddi4+0x2ce>
 800046c:	3802      	subs	r0, #2
 800046e:	443c      	add	r4, r7
 8000470:	eba4 040e 	sub.w	r4, r4, lr
 8000474:	fa1f fe83 	uxth.w	lr, r3
 8000478:	fbb4 f3f9 	udiv	r3, r4, r9
 800047c:	fb09 4413 	mls	r4, r9, r3, r4
 8000480:	ea4e 4404 	orr.w	r4, lr, r4, lsl #16
 8000484:	fb03 fc0c 	mul.w	ip, r3, ip
 8000488:	45a4      	cmp	ip, r4
 800048a:	d908      	bls.n	800049e <__udivmoddi4+0x1ce>
 800048c:	193c      	adds	r4, r7, r4
 800048e:	f103 3eff 	add.w	lr, r3, #4294967295	@ 0xffffffff
 8000492:	f080 8082 	bcs.w	800059a <__udivmoddi4+0x2ca>
 8000496:	45a4      	cmp	ip, r4
 8000498:	d97f      	bls.n	800059a <__udivmoddi4+0x2ca>
 800049a:	3b02      	subs	r3, #2
 800049c:	443c      	add	r4, r7
 800049e:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 80004a2:	eba4 040c 	sub.w	r4, r4, ip
 80004a6:	fba0 ec02 	umull	lr, ip, r0, r2
 80004aa:	4564      	cmp	r4, ip
 80004ac:	4673      	mov	r3, lr
 80004ae:	46e1      	mov	r9, ip
 80004b0:	d362      	bcc.n	8000578 <__udivmoddi4+0x2a8>
 80004b2:	d05f      	beq.n	8000574 <__udivmoddi4+0x2a4>
 80004b4:	b15d      	cbz	r5, 80004ce <__udivmoddi4+0x1fe>
 80004b6:	ebb8 0203 	subs.w	r2, r8, r3
 80004ba:	eb64 0409 	sbc.w	r4, r4, r9
 80004be:	fa04 f606 	lsl.w	r6, r4, r6
 80004c2:	fa22 f301 	lsr.w	r3, r2, r1
 80004c6:	431e      	orrs	r6, r3
 80004c8:	40cc      	lsrs	r4, r1
 80004ca:	e9c5 6400 	strd	r6, r4, [r5]
 80004ce:	2100      	movs	r1, #0
 80004d0:	e74f      	b.n	8000372 <__udivmoddi4+0xa2>
 80004d2:	fbb1 fcf2 	udiv	ip, r1, r2
 80004d6:	0c01      	lsrs	r1, r0, #16
 80004d8:	ea41 410e 	orr.w	r1, r1, lr, lsl #16
 80004dc:	b280      	uxth	r0, r0
 80004de:	ea40 4201 	orr.w	r2, r0, r1, lsl #16
 80004e2:	463b      	mov	r3, r7
 80004e4:	4638      	mov	r0, r7
 80004e6:	463c      	mov	r4, r7
 80004e8:	46b8      	mov	r8, r7
 80004ea:	46be      	mov	lr, r7
 80004ec:	2620      	movs	r6, #32
 80004ee:	fbb1 f1f7 	udiv	r1, r1, r7
 80004f2:	eba2 0208 	sub.w	r2, r2, r8
 80004f6:	ea41 410c 	orr.w	r1, r1, ip, lsl #16
 80004fa:	e766      	b.n	80003ca <__udivmoddi4+0xfa>
 80004fc:	4601      	mov	r1, r0
 80004fe:	e718      	b.n	8000332 <__udivmoddi4+0x62>
 8000500:	4610      	mov	r0, r2
 8000502:	e72c      	b.n	800035e <__udivmoddi4+0x8e>
 8000504:	f1c6 0220 	rsb	r2, r6, #32
 8000508:	fa2e f302 	lsr.w	r3, lr, r2
 800050c:	40b7      	lsls	r7, r6
 800050e:	40b1      	lsls	r1, r6
 8000510:	fa20 f202 	lsr.w	r2, r0, r2
 8000514:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8000518:	430a      	orrs	r2, r1
 800051a:	fbb3 f8fe 	udiv	r8, r3, lr
 800051e:	b2bc      	uxth	r4, r7
 8000520:	fb0e 3318 	mls	r3, lr, r8, r3
 8000524:	0c11      	lsrs	r1, r2, #16
 8000526:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 800052a:	fb08 f904 	mul.w	r9, r8, r4
 800052e:	40b0      	lsls	r0, r6
 8000530:	4589      	cmp	r9, r1
 8000532:	ea4f 4310 	mov.w	r3, r0, lsr #16
 8000536:	b280      	uxth	r0, r0
 8000538:	d93e      	bls.n	80005b8 <__udivmoddi4+0x2e8>
 800053a:	1879      	adds	r1, r7, r1
 800053c:	f108 3cff 	add.w	ip, r8, #4294967295	@ 0xffffffff
 8000540:	d201      	bcs.n	8000546 <__udivmoddi4+0x276>
 8000542:	4589      	cmp	r9, r1
 8000544:	d81f      	bhi.n	8000586 <__udivmoddi4+0x2b6>
 8000546:	eba1 0109 	sub.w	r1, r1, r9
 800054a:	fbb1 f9fe 	udiv	r9, r1, lr
 800054e:	fb09 f804 	mul.w	r8, r9, r4
 8000552:	fb0e 1119 	mls	r1, lr, r9, r1
 8000556:	b292      	uxth	r2, r2
 8000558:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 800055c:	4542      	cmp	r2, r8
 800055e:	d229      	bcs.n	80005b4 <__udivmoddi4+0x2e4>
 8000560:	18ba      	adds	r2, r7, r2
 8000562:	f109 31ff 	add.w	r1, r9, #4294967295	@ 0xffffffff
 8000566:	d2c4      	bcs.n	80004f2 <__udivmoddi4+0x222>
 8000568:	4542      	cmp	r2, r8
 800056a:	d2c2      	bcs.n	80004f2 <__udivmoddi4+0x222>
 800056c:	f1a9 0102 	sub.w	r1, r9, #2
 8000570:	443a      	add	r2, r7
 8000572:	e7be      	b.n	80004f2 <__udivmoddi4+0x222>
 8000574:	45f0      	cmp	r8, lr
 8000576:	d29d      	bcs.n	80004b4 <__udivmoddi4+0x1e4>
 8000578:	ebbe 0302 	subs.w	r3, lr, r2
 800057c:	eb6c 0c07 	sbc.w	ip, ip, r7
 8000580:	3801      	subs	r0, #1
 8000582:	46e1      	mov	r9, ip
 8000584:	e796      	b.n	80004b4 <__udivmoddi4+0x1e4>
 8000586:	eba7 0909 	sub.w	r9, r7, r9
 800058a:	4449      	add	r1, r9
 800058c:	f1a8 0c02 	sub.w	ip, r8, #2
 8000590:	fbb1 f9fe 	udiv	r9, r1, lr
 8000594:	fb09 f804 	mul.w	r8, r9, r4
 8000598:	e7db      	b.n	8000552 <__udivmoddi4+0x282>
 800059a:	4673      	mov	r3, lr
 800059c:	e77f      	b.n	800049e <__udivmoddi4+0x1ce>
 800059e:	4650      	mov	r0, sl
 80005a0:	e766      	b.n	8000470 <__udivmoddi4+0x1a0>
 80005a2:	4608      	mov	r0, r1
 80005a4:	e6fd      	b.n	80003a2 <__udivmoddi4+0xd2>
 80005a6:	443b      	add	r3, r7
 80005a8:	3a02      	subs	r2, #2
 80005aa:	e733      	b.n	8000414 <__udivmoddi4+0x144>
 80005ac:	f1ac 0c02 	sub.w	ip, ip, #2
 80005b0:	443b      	add	r3, r7
 80005b2:	e71c      	b.n	80003ee <__udivmoddi4+0x11e>
 80005b4:	4649      	mov	r1, r9
 80005b6:	e79c      	b.n	80004f2 <__udivmoddi4+0x222>
 80005b8:	eba1 0109 	sub.w	r1, r1, r9
 80005bc:	46c4      	mov	ip, r8
 80005be:	fbb1 f9fe 	udiv	r9, r1, lr
 80005c2:	fb09 f804 	mul.w	r8, r9, r4
 80005c6:	e7c4      	b.n	8000552 <__udivmoddi4+0x282>

080005c8 <__aeabi_idiv0>:
 80005c8:	4770      	bx	lr
 80005ca:	bf00      	nop

080005cc <firstMessageHandler>:
	thirdMessage = (MessageThree){{0},{0},{0},{0},{0},{0},{0}};
	fourthMessage = (MessageFour){{0},{0},{0},{0},{0}};
	fifthMessage = (MessageFive){{0},{0},{0},{0},{0}};
	sixthMessage = (MessageSix){{0},{0},{0},{0},{0},{0}};
}*/
void firstMessageHandler(uint8_t* receivedChars) {
 80005cc:	b580      	push	{r7, lr}
 80005ce:	b084      	sub	sp, #16
 80005d0:	af00      	add	r7, sp, #0
 80005d2:	6078      	str	r0, [r7, #4]
	for (int i = 0; i < 4; i++) {
 80005d4:	2300      	movs	r3, #0
 80005d6:	60fb      	str	r3, [r7, #12]
 80005d8:	e00b      	b.n	80005f2 <firstMessageHandler+0x26>
		firstMessage.initChars[i] = receivedChars[i];
 80005da:	68fb      	ldr	r3, [r7, #12]
 80005dc:	687a      	ldr	r2, [r7, #4]
 80005de:	4413      	add	r3, r2
 80005e0:	7819      	ldrb	r1, [r3, #0]
 80005e2:	4a0c      	ldr	r2, [pc, #48]	@ (8000614 <firstMessageHandler+0x48>)
 80005e4:	68fb      	ldr	r3, [r7, #12]
 80005e6:	4413      	add	r3, r2
 80005e8:	460a      	mov	r2, r1
 80005ea:	701a      	strb	r2, [r3, #0]
	for (int i = 0; i < 4; i++) {
 80005ec:	68fb      	ldr	r3, [r7, #12]
 80005ee:	3301      	adds	r3, #1
 80005f0:	60fb      	str	r3, [r7, #12]
 80005f2:	68fb      	ldr	r3, [r7, #12]
 80005f4:	2b03      	cmp	r3, #3
 80005f6:	ddf0      	ble.n	80005da <firstMessageHandler+0xe>
	}
	// skontroluj ci sme v prvej sprave dostali uvodne znaky 'H' 'e' 'l' 'o'.
	// treba dorobit odpoved v pripade ze sme nedostali taketo znaky.
	// v podstate celemu projektu treba dorobit vratenie chyboveho kodu v pripade ze nieco zlyha.
	if(memcmp(firstMessage.initChars, secondMessage.replyChars, sizeof(secondMessage.replyChars)) == 0) {
 80005f8:	2204      	movs	r2, #4
 80005fa:	4907      	ldr	r1, [pc, #28]	@ (8000618 <firstMessageHandler+0x4c>)
 80005fc:	4805      	ldr	r0, [pc, #20]	@ (8000614 <firstMessageHandler+0x48>)
 80005fe:	f027 ff39 	bl	8028474 <memcmp>
 8000602:	4603      	mov	r3, r0
 8000604:	2b00      	cmp	r3, #0
 8000606:	d101      	bne.n	800060c <firstMessageHandler+0x40>
		secondMessageSender();
 8000608:	f000 f808 	bl	800061c <secondMessageSender>
	}
}
 800060c:	bf00      	nop
 800060e:	3710      	adds	r7, #16
 8000610:	46bd      	mov	sp, r7
 8000612:	bd80      	pop	{r7, pc}
 8000614:	20000000 	.word	0x20000000
 8000618:	20000004 	.word	0x20000004

0800061c <secondMessageSender>:

void secondMessageSender() {
 800061c:	b580      	push	{r7, lr}
 800061e:	b086      	sub	sp, #24
 8000620:	af00      	add	r7, sp, #0
	// vrat device ID co je rozdelene do troch 32bit hodnot
	uint32_t uid_one = HAL_GetUIDw0();
 8000622:	f001 fbcb 	bl	8001dbc <HAL_GetUIDw0>
 8000626:	6138      	str	r0, [r7, #16]
	uint32_t uid_two = HAL_GetUIDw1();
 8000628:	f001 fbd4 	bl	8001dd4 <HAL_GetUIDw1>
 800062c:	60f8      	str	r0, [r7, #12]
	uint32_t uid_three = HAL_GetUIDw2();
 800062e:	f001 fbdd 	bl	8001dec <HAL_GetUIDw2>
 8000632:	60b8      	str	r0, [r7, #8]

	// vsetko nasekaj do sendBuffera
	memcpy(sendBuffer, secondMessage.replyChars, 4);
 8000634:	4b49      	ldr	r3, [pc, #292]	@ (800075c <secondMessageSender+0x140>)
 8000636:	681b      	ldr	r3, [r3, #0]
 8000638:	4a49      	ldr	r2, [pc, #292]	@ (8000760 <secondMessageSender+0x144>)
 800063a:	6013      	str	r3, [r2, #0]
	sendCounter += 4;
 800063c:	4b49      	ldr	r3, [pc, #292]	@ (8000764 <secondMessageSender+0x148>)
 800063e:	881b      	ldrh	r3, [r3, #0]
 8000640:	3304      	adds	r3, #4
 8000642:	b29a      	uxth	r2, r3
 8000644:	4b47      	ldr	r3, [pc, #284]	@ (8000764 <secondMessageSender+0x148>)
 8000646:	801a      	strh	r2, [r3, #0]
	for (size_t i = 0; i < 3; i++)
 8000648:	2300      	movs	r3, #0
 800064a:	617b      	str	r3, [r7, #20]
 800064c:	e04d      	b.n	80006ea <secondMessageSender+0xce>
	{
		uint8_t UIDsplit[4];
		if (i == 0) {
 800064e:	697b      	ldr	r3, [r7, #20]
 8000650:	2b00      	cmp	r3, #0
 8000652:	d112      	bne.n	800067a <secondMessageSender+0x5e>
			UIDsplit[0] = (uid_one & 0x000000ff);
 8000654:	693b      	ldr	r3, [r7, #16]
 8000656:	b2db      	uxtb	r3, r3
 8000658:	713b      	strb	r3, [r7, #4]
			UIDsplit[1] = (uid_one & 0x0000ff00) >> 8;
 800065a:	693b      	ldr	r3, [r7, #16]
 800065c:	0a1b      	lsrs	r3, r3, #8
 800065e:	b2db      	uxtb	r3, r3
 8000660:	717b      	strb	r3, [r7, #5]
			UIDsplit[2] = (uid_one & 0x00ff0000) >> 16;
 8000662:	693b      	ldr	r3, [r7, #16]
 8000664:	0c1b      	lsrs	r3, r3, #16
 8000666:	b2db      	uxtb	r3, r3
 8000668:	71bb      	strb	r3, [r7, #6]
			UIDsplit[3] = (uid_one & 0xff000000) >> 24;
 800066a:	693b      	ldr	r3, [r7, #16]
 800066c:	0e1b      	lsrs	r3, r3, #24
 800066e:	b2db      	uxtb	r3, r3
 8000670:	71fb      	strb	r3, [r7, #7]
			memcpy(secondMessage.Tid_one, UIDsplit, 4);
 8000672:	687b      	ldr	r3, [r7, #4]
 8000674:	4a39      	ldr	r2, [pc, #228]	@ (800075c <secondMessageSender+0x140>)
 8000676:	6053      	str	r3, [r2, #4]
 8000678:	e027      	b.n	80006ca <secondMessageSender+0xae>
		} else if (i == 1) {
 800067a:	697b      	ldr	r3, [r7, #20]
 800067c:	2b01      	cmp	r3, #1
 800067e:	d112      	bne.n	80006a6 <secondMessageSender+0x8a>
			UIDsplit[0] = (uid_two & 0x000000ff);
 8000680:	68fb      	ldr	r3, [r7, #12]
 8000682:	b2db      	uxtb	r3, r3
 8000684:	713b      	strb	r3, [r7, #4]
			UIDsplit[1] = (uid_two & 0x0000ff00) >> 8;
 8000686:	68fb      	ldr	r3, [r7, #12]
 8000688:	0a1b      	lsrs	r3, r3, #8
 800068a:	b2db      	uxtb	r3, r3
 800068c:	717b      	strb	r3, [r7, #5]
			UIDsplit[2] = (uid_two & 0x00ff0000) >> 16;
 800068e:	68fb      	ldr	r3, [r7, #12]
 8000690:	0c1b      	lsrs	r3, r3, #16
 8000692:	b2db      	uxtb	r3, r3
 8000694:	71bb      	strb	r3, [r7, #6]
			UIDsplit[3] = (uid_two & 0xff000000) >> 24;
 8000696:	68fb      	ldr	r3, [r7, #12]
 8000698:	0e1b      	lsrs	r3, r3, #24
 800069a:	b2db      	uxtb	r3, r3
 800069c:	71fb      	strb	r3, [r7, #7]
			memcpy(secondMessage.Tid_two, UIDsplit, 4);
 800069e:	687b      	ldr	r3, [r7, #4]
 80006a0:	4a2e      	ldr	r2, [pc, #184]	@ (800075c <secondMessageSender+0x140>)
 80006a2:	6093      	str	r3, [r2, #8]
 80006a4:	e011      	b.n	80006ca <secondMessageSender+0xae>
		} else {
			UIDsplit[0] = (uid_three & 0x000000ff);
 80006a6:	68bb      	ldr	r3, [r7, #8]
 80006a8:	b2db      	uxtb	r3, r3
 80006aa:	713b      	strb	r3, [r7, #4]
			UIDsplit[1] = (uid_three & 0x0000ff00) >> 8;
 80006ac:	68bb      	ldr	r3, [r7, #8]
 80006ae:	0a1b      	lsrs	r3, r3, #8
 80006b0:	b2db      	uxtb	r3, r3
 80006b2:	717b      	strb	r3, [r7, #5]
			UIDsplit[2] = (uid_three & 0x00ff0000) >> 16;
 80006b4:	68bb      	ldr	r3, [r7, #8]
 80006b6:	0c1b      	lsrs	r3, r3, #16
 80006b8:	b2db      	uxtb	r3, r3
 80006ba:	71bb      	strb	r3, [r7, #6]
			UIDsplit[3] = (uid_three & 0xff000000) >> 24;
 80006bc:	68bb      	ldr	r3, [r7, #8]
 80006be:	0e1b      	lsrs	r3, r3, #24
 80006c0:	b2db      	uxtb	r3, r3
 80006c2:	71fb      	strb	r3, [r7, #7]
			memcpy(secondMessage.Tid_three, UIDsplit, 4);
 80006c4:	687b      	ldr	r3, [r7, #4]
 80006c6:	4a25      	ldr	r2, [pc, #148]	@ (800075c <secondMessageSender+0x140>)
 80006c8:	60d3      	str	r3, [r2, #12]
		}
		memcpy(sendBuffer + sendCounter, UIDsplit, 4);
 80006ca:	4b26      	ldr	r3, [pc, #152]	@ (8000764 <secondMessageSender+0x148>)
 80006cc:	881b      	ldrh	r3, [r3, #0]
 80006ce:	461a      	mov	r2, r3
 80006d0:	4b23      	ldr	r3, [pc, #140]	@ (8000760 <secondMessageSender+0x144>)
 80006d2:	4413      	add	r3, r2
 80006d4:	687a      	ldr	r2, [r7, #4]
 80006d6:	601a      	str	r2, [r3, #0]
		sendCounter += 4;
 80006d8:	4b22      	ldr	r3, [pc, #136]	@ (8000764 <secondMessageSender+0x148>)
 80006da:	881b      	ldrh	r3, [r3, #0]
 80006dc:	3304      	adds	r3, #4
 80006de:	b29a      	uxth	r2, r3
 80006e0:	4b20      	ldr	r3, [pc, #128]	@ (8000764 <secondMessageSender+0x148>)
 80006e2:	801a      	strh	r2, [r3, #0]
	for (size_t i = 0; i < 3; i++)
 80006e4:	697b      	ldr	r3, [r7, #20]
 80006e6:	3301      	adds	r3, #1
 80006e8:	617b      	str	r3, [r7, #20]
 80006ea:	697b      	ldr	r3, [r7, #20]
 80006ec:	2b02      	cmp	r3, #2
 80006ee:	d9ae      	bls.n	800064e <secondMessageSender+0x32>
	}

	// treba este vlozit velkost certifikatu tokenu pred samotny certifikat
	// velkost je ale vyssia ako 256, treba ju splitnut na uint8_t
	sendBuffer[sendCounter] = (tokenCertLen >> 8) & 0xFF;
 80006f0:	4b1d      	ldr	r3, [pc, #116]	@ (8000768 <secondMessageSender+0x14c>)
 80006f2:	881b      	ldrh	r3, [r3, #0]
 80006f4:	0a1b      	lsrs	r3, r3, #8
 80006f6:	b299      	uxth	r1, r3
 80006f8:	4b1a      	ldr	r3, [pc, #104]	@ (8000764 <secondMessageSender+0x148>)
 80006fa:	881b      	ldrh	r3, [r3, #0]
 80006fc:	461a      	mov	r2, r3
 80006fe:	b2c9      	uxtb	r1, r1
 8000700:	4b17      	ldr	r3, [pc, #92]	@ (8000760 <secondMessageSender+0x144>)
 8000702:	5499      	strb	r1, [r3, r2]
	sendCounter++;
 8000704:	4b17      	ldr	r3, [pc, #92]	@ (8000764 <secondMessageSender+0x148>)
 8000706:	881b      	ldrh	r3, [r3, #0]
 8000708:	3301      	adds	r3, #1
 800070a:	b29a      	uxth	r2, r3
 800070c:	4b15      	ldr	r3, [pc, #84]	@ (8000764 <secondMessageSender+0x148>)
 800070e:	801a      	strh	r2, [r3, #0]
	sendBuffer[sendCounter] = tokenCertLen  & 0xFF;
 8000710:	4b15      	ldr	r3, [pc, #84]	@ (8000768 <secondMessageSender+0x14c>)
 8000712:	8819      	ldrh	r1, [r3, #0]
 8000714:	4b13      	ldr	r3, [pc, #76]	@ (8000764 <secondMessageSender+0x148>)
 8000716:	881b      	ldrh	r3, [r3, #0]
 8000718:	461a      	mov	r2, r3
 800071a:	b2c9      	uxtb	r1, r1
 800071c:	4b10      	ldr	r3, [pc, #64]	@ (8000760 <secondMessageSender+0x144>)
 800071e:	5499      	strb	r1, [r3, r2]
	sendCounter++;
 8000720:	4b10      	ldr	r3, [pc, #64]	@ (8000764 <secondMessageSender+0x148>)
 8000722:	881b      	ldrh	r3, [r3, #0]
 8000724:	3301      	adds	r3, #1
 8000726:	b29a      	uxth	r2, r3
 8000728:	4b0e      	ldr	r3, [pc, #56]	@ (8000764 <secondMessageSender+0x148>)
 800072a:	801a      	strh	r2, [r3, #0]
	// vkladam uz certifikat tokenu
	memcpy(sendBuffer + sendCounter, tokenCert, tokenCertLen);
 800072c:	4b0d      	ldr	r3, [pc, #52]	@ (8000764 <secondMessageSender+0x148>)
 800072e:	881b      	ldrh	r3, [r3, #0]
 8000730:	461a      	mov	r2, r3
 8000732:	4b0b      	ldr	r3, [pc, #44]	@ (8000760 <secondMessageSender+0x144>)
 8000734:	4413      	add	r3, r2
 8000736:	4a0c      	ldr	r2, [pc, #48]	@ (8000768 <secondMessageSender+0x14c>)
 8000738:	8812      	ldrh	r2, [r2, #0]
 800073a:	490c      	ldr	r1, [pc, #48]	@ (800076c <secondMessageSender+0x150>)
 800073c:	4618      	mov	r0, r3
 800073e:	f027 ff2d 	bl	802859c <memcpy>
	sendCounter += tokenCertLen;
 8000742:	4b08      	ldr	r3, [pc, #32]	@ (8000764 <secondMessageSender+0x148>)
 8000744:	881a      	ldrh	r2, [r3, #0]
 8000746:	4b08      	ldr	r3, [pc, #32]	@ (8000768 <secondMessageSender+0x14c>)
 8000748:	881b      	ldrh	r3, [r3, #0]
 800074a:	4413      	add	r3, r2
 800074c:	b29a      	uxth	r2, r3
 800074e:	4b05      	ldr	r3, [pc, #20]	@ (8000764 <secondMessageSender+0x148>)
 8000750:	801a      	strh	r2, [r3, #0]
	return;
 8000752:	bf00      	nop
}
 8000754:	3718      	adds	r7, #24
 8000756:	46bd      	mov	sp, r7
 8000758:	bd80      	pop	{r7, pc}
 800075a:	bf00      	nop
 800075c:	20000004 	.word	0x20000004
 8000760:	20001ed4 	.word	0x20001ed4
 8000764:	20002898 	.word	0x20002898
 8000768:	080303e4 	.word	0x080303e4
 800076c:	0802ff98 	.word	0x0802ff98

08000770 <thirdMessageHandler>:

void thirdMessageHandler(uint8_t* encryptedKey, uint8_t* encryptedIV, uint8_t* payload, uint8_t* deviceCertBuffer, uint16_t deviceCertLen) {
 8000770:	b590      	push	{r4, r7, lr}
 8000772:	f5ad 5dde 	sub.w	sp, sp, #7104	@ 0x1bc0
 8000776:	b085      	sub	sp, #20
 8000778:	af02      	add	r7, sp, #8
 800077a:	f607 34c8 	addw	r4, r7, #3016	@ 0xbc8
 800077e:	f6a4 34bc 	subw	r4, r4, #3004	@ 0xbbc
 8000782:	6020      	str	r0, [r4, #0]
 8000784:	f607 30c8 	addw	r0, r7, #3016	@ 0xbc8
 8000788:	f5a0 603c 	sub.w	r0, r0, #3008	@ 0xbc0
 800078c:	6001      	str	r1, [r0, #0]
 800078e:	f607 31c8 	addw	r1, r7, #3016	@ 0xbc8
 8000792:	f6a1 31c4 	subw	r1, r1, #3012	@ 0xbc4
 8000796:	600a      	str	r2, [r1, #0]
 8000798:	f607 32c8 	addw	r2, r7, #3016	@ 0xbc8
 800079c:	f6a2 32c8 	subw	r2, r2, #3016	@ 0xbc8
 80007a0:	6013      	str	r3, [r2, #0]
	// over certifikat zariadenia ci je podpisany CA
	WOLFSSL_CTX* ctx = wolfSSL_CTX_new(wolfTLSv1_2_client_method());
 80007a2:	f00e fef1 	bl	800f588 <wolfTLSv1_2_client_method>
 80007a6:	4603      	mov	r3, r0
 80007a8:	4618      	mov	r0, r3
 80007aa:	f00b fcd3 	bl	800c154 <wolfSSL_CTX_new>
 80007ae:	f507 53de 	add.w	r3, r7, #7104	@ 0x1bc0
 80007b2:	f103 0304 	add.w	r3, r3, #4
 80007b6:	6018      	str	r0, [r3, #0]
    if (wolfSSL_CTX_load_verify_buffer(ctx, CACert, CACertLen, WOLFSSL_FILETYPE_ASN1) != SSL_SUCCESS) {
 80007b8:	4b7d      	ldr	r3, [pc, #500]	@ (80009b0 <thirdMessageHandler+0x240>)
 80007ba:	881b      	ldrh	r3, [r3, #0]
 80007bc:	461a      	mov	r2, r3
 80007be:	2302      	movs	r3, #2
 80007c0:	497c      	ldr	r1, [pc, #496]	@ (80009b4 <thirdMessageHandler+0x244>)
 80007c2:	f507 50de 	add.w	r0, r7, #7104	@ 0x1bc0
 80007c6:	f100 0004 	add.w	r0, r0, #4
 80007ca:	6800      	ldr	r0, [r0, #0]
 80007cc:	f00d f8b4 	bl	800d938 <wolfSSL_CTX_load_verify_buffer>
 80007d0:	4603      	mov	r3, r0
 80007d2:	2b01      	cmp	r3, #1
 80007d4:	f040 8204 	bne.w	8000be0 <thirdMessageHandler+0x470>
        return;
    }
    WOLFSSL_CERT_MANAGER* cm = wolfSSL_CTX_GetCertManager(ctx);
 80007d8:	f507 53de 	add.w	r3, r7, #7104	@ 0x1bc0
 80007dc:	f103 0304 	add.w	r3, r3, #4
 80007e0:	6818      	ldr	r0, [r3, #0]
 80007e2:	f00b fd07 	bl	800c1f4 <wolfSSL_CTX_GetCertManager>
 80007e6:	f507 53de 	add.w	r3, r7, #7104	@ 0x1bc0
 80007ea:	6018      	str	r0, [r3, #0]
    if (!cm) {
 80007ec:	f507 53de 	add.w	r3, r7, #7104	@ 0x1bc0
 80007f0:	681b      	ldr	r3, [r3, #0]
 80007f2:	2b00      	cmp	r3, #0
 80007f4:	f000 81f6 	beq.w	8000be4 <thirdMessageHandler+0x474>
        return;
    }
    int ret = wolfSSL_CertManagerVerifyBuffer(cm, deviceCertBuffer, deviceCertLen, WOLFSSL_FILETYPE_ASN1);
 80007f8:	f507 53de 	add.w	r3, r7, #7104	@ 0x1bc0
 80007fc:	f103 0318 	add.w	r3, r3, #24
 8000800:	881a      	ldrh	r2, [r3, #0]
 8000802:	f607 33c8 	addw	r3, r7, #3016	@ 0xbc8
 8000806:	f6a3 31c8 	subw	r1, r3, #3016	@ 0xbc8
 800080a:	2302      	movs	r3, #2
 800080c:	6809      	ldr	r1, [r1, #0]
 800080e:	f507 50de 	add.w	r0, r7, #7104	@ 0x1bc0
 8000812:	6800      	ldr	r0, [r0, #0]
 8000814:	f00a ffc8 	bl	800b7a8 <wolfSSL_CertManagerVerifyBuffer>
 8000818:	f507 53dd 	add.w	r3, r7, #7072	@ 0x1ba0
 800081c:	f103 031c 	add.w	r3, r3, #28
 8000820:	6018      	str	r0, [r3, #0]
    if (ret != SSL_SUCCESS) {
 8000822:	f507 53dd 	add.w	r3, r7, #7072	@ 0x1ba0
 8000826:	f103 031c 	add.w	r3, r3, #28
 800082a:	681b      	ldr	r3, [r3, #0]
 800082c:	2b01      	cmp	r3, #1
 800082e:	f040 81db 	bne.w	8000be8 <thirdMessageHandler+0x478>
        return;
    }

    // ak ano, tak extrahuj z neho verejny kluc
    wc_InitRsaKey(&pubKey, NULL);
 8000832:	2100      	movs	r1, #0
 8000834:	4860      	ldr	r0, [pc, #384]	@ (80009b8 <thirdMessageHandler+0x248>)
 8000836:	f01f fb9b 	bl	801ff70 <wc_InitRsaKey>
    DecodedCert extractedPCCert;
    InitDecodedCert(&extractedPCCert, (byte*)deviceCertBuffer, deviceCertLen, NULL);
 800083a:	f507 53de 	add.w	r3, r7, #7104	@ 0x1bc0
 800083e:	f103 0318 	add.w	r3, r3, #24
 8000842:	881a      	ldrh	r2, [r3, #0]
 8000844:	f607 33c8 	addw	r3, r7, #3016	@ 0xbc8
 8000848:	f6a3 31c8 	subw	r1, r3, #3016	@ 0xbc8
 800084c:	f507 50b7 	add.w	r0, r7, #5856	@ 0x16e0
 8000850:	f100 0010 	add.w	r0, r0, #16
 8000854:	2300      	movs	r3, #0
 8000856:	6809      	ldr	r1, [r1, #0]
 8000858:	f014 fc43 	bl	80150e2 <InitDecodedCert>
    ret = ParseCert(&extractedPCCert, CERT_TYPE, NO_VERIFY, NULL);
 800085c:	f507 50b7 	add.w	r0, r7, #5856	@ 0x16e0
 8000860:	f100 0010 	add.w	r0, r0, #16
 8000864:	2300      	movs	r3, #0
 8000866:	2200      	movs	r2, #0
 8000868:	2100      	movs	r1, #0
 800086a:	f017 ff02 	bl	8018672 <ParseCert>
 800086e:	f507 53dd 	add.w	r3, r7, #7072	@ 0x1ba0
 8000872:	f103 031c 	add.w	r3, r3, #28
 8000876:	6018      	str	r0, [r3, #0]
    word32 idx = 0;
 8000878:	f507 53de 	add.w	r3, r7, #7104	@ 0x1bc0
 800087c:	f103 0308 	add.w	r3, r3, #8
 8000880:	f2a3 43dc 	subw	r3, r3, #1244	@ 0x4dc
 8000884:	2200      	movs	r2, #0
 8000886:	601a      	str	r2, [r3, #0]
    ret = wc_RsaPublicKeyDecode(extractedPCCert.publicKey, &idx, &pubKey, extractedPCCert.pubKeySize);
 8000888:	f507 53de 	add.w	r3, r7, #7104	@ 0x1bc0
 800088c:	f103 0308 	add.w	r3, r3, #8
 8000890:	f5a3 639b 	sub.w	r3, r3, #1240	@ 0x4d8
 8000894:	6818      	ldr	r0, [r3, #0]
 8000896:	f507 53de 	add.w	r3, r7, #7104	@ 0x1bc0
 800089a:	f103 0308 	add.w	r3, r3, #8
 800089e:	f5a3 639b 	sub.w	r3, r3, #1240	@ 0x4d8
 80008a2:	685b      	ldr	r3, [r3, #4]
 80008a4:	f507 51b7 	add.w	r1, r7, #5856	@ 0x16e0
 80008a8:	f101 010c 	add.w	r1, r1, #12
 80008ac:	4a42      	ldr	r2, [pc, #264]	@ (80009b8 <thirdMessageHandler+0x248>)
 80008ae:	f014 fbdf 	bl	8015070 <wc_RsaPublicKeyDecode>
 80008b2:	f507 53dd 	add.w	r3, r7, #7072	@ 0x1ba0
 80008b6:	f103 031c 	add.w	r3, r3, #28
 80008ba:	6018      	str	r0, [r3, #0]
    if (ret != 0) {
 80008bc:	f507 53dd 	add.w	r3, r7, #7072	@ 0x1ba0
 80008c0:	f103 031c 	add.w	r3, r3, #28
 80008c4:	681b      	ldr	r3, [r3, #0]
 80008c6:	2b00      	cmp	r3, #0
 80008c8:	d00c      	beq.n	80008e4 <thirdMessageHandler+0x174>
        wolfSSL_CertManagerFree(cm);
 80008ca:	f507 53de 	add.w	r3, r7, #7104	@ 0x1bc0
 80008ce:	6818      	ldr	r0, [r3, #0]
 80008d0:	f00a fe81 	bl	800b5d6 <wolfSSL_CertManagerFree>
        wolfSSL_CTX_free(ctx);
 80008d4:	f507 53de 	add.w	r3, r7, #7104	@ 0x1bc0
 80008d8:	f103 0304 	add.w	r3, r3, #4
 80008dc:	6818      	ldr	r0, [r3, #0]
 80008de:	f00b fc46 	bl	800c16e <wolfSSL_CTX_free>
        return;
 80008e2:	e18a      	b.n	8000bfa <thirdMessageHandler+0x48a>
    }
    wolfSSL_CertManagerFree(cm);
 80008e4:	f507 53de 	add.w	r3, r7, #7104	@ 0x1bc0
 80008e8:	6818      	ldr	r0, [r3, #0]
 80008ea:	f00a fe74 	bl	800b5d6 <wolfSSL_CertManagerFree>
    wolfSSL_CTX_free(ctx);
 80008ee:	f507 53de 	add.w	r3, r7, #7104	@ 0x1bc0
 80008f2:	f103 0304 	add.w	r3, r3, #4
 80008f6:	6818      	ldr	r0, [r3, #0]
 80008f8:	f00b fc39 	bl	800c16e <wolfSSL_CTX_free>

    // ak ano tak mozeme desifrovat prijate data. zober sukromny kluc tokenu
    RsaKey rsaKey;
    WC_RNG rng;
    int rsaRet = wc_InitRsaKey(&rsaKey, NULL);
 80008fc:	f507 63b1 	add.w	r3, r7, #1416	@ 0x588
 8000900:	3b18      	subs	r3, #24
 8000902:	2100      	movs	r1, #0
 8000904:	4618      	mov	r0, r3
 8000906:	f01f fb33 	bl	801ff70 <wc_InitRsaKey>
 800090a:	f507 53dd 	add.w	r3, r7, #7072	@ 0x1ba0
 800090e:	f103 0318 	add.w	r3, r3, #24
 8000912:	6018      	str	r0, [r3, #0]
    if (rsaRet != 0) {
 8000914:	f507 53dd 	add.w	r3, r7, #7072	@ 0x1ba0
 8000918:	f103 0318 	add.w	r3, r3, #24
 800091c:	681b      	ldr	r3, [r3, #0]
 800091e:	2b00      	cmp	r3, #0
 8000920:	f040 8164 	bne.w	8000bec <thirdMessageHandler+0x47c>
        return;
    }
    rsaRet = wc_InitRng(&rng);
 8000924:	f507 63ad 	add.w	r3, r7, #1384	@ 0x568
 8000928:	3b08      	subs	r3, #8
 800092a:	4618      	mov	r0, r3
 800092c:	f01e fe21 	bl	801f572 <wc_InitRng>
 8000930:	f507 53dd 	add.w	r3, r7, #7072	@ 0x1ba0
 8000934:	f103 0318 	add.w	r3, r3, #24
 8000938:	6018      	str	r0, [r3, #0]
    if (rsaRet != 0) {
 800093a:	f507 53dd 	add.w	r3, r7, #7072	@ 0x1ba0
 800093e:	f103 0318 	add.w	r3, r3, #24
 8000942:	681b      	ldr	r3, [r3, #0]
 8000944:	2b00      	cmp	r3, #0
 8000946:	d006      	beq.n	8000956 <thirdMessageHandler+0x1e6>
        wc_FreeRsaKey(&rsaKey);
 8000948:	f507 63b1 	add.w	r3, r7, #1416	@ 0x588
 800094c:	3b18      	subs	r3, #24
 800094e:	4618      	mov	r0, r3
 8000950:	f01f fb1e 	bl	801ff90 <wc_FreeRsaKey>
        return;
 8000954:	e151      	b.n	8000bfa <thirdMessageHandler+0x48a>
    }
    idx = 0;
 8000956:	f507 53de 	add.w	r3, r7, #7104	@ 0x1bc0
 800095a:	f103 0308 	add.w	r3, r3, #8
 800095e:	f2a3 43dc 	subw	r3, r3, #1244	@ 0x4dc
 8000962:	2200      	movs	r2, #0
 8000964:	601a      	str	r2, [r3, #0]
    rsaRet = wc_RsaPrivateKeyDecode(tokenPrivKey, &idx, &rsaKey, tokenPrivKeyLen);
 8000966:	4b15      	ldr	r3, [pc, #84]	@ (80009bc <thirdMessageHandler+0x24c>)
 8000968:	881b      	ldrh	r3, [r3, #0]
 800096a:	f507 62b1 	add.w	r2, r7, #1416	@ 0x588
 800096e:	3a18      	subs	r2, #24
 8000970:	f507 51b7 	add.w	r1, r7, #5856	@ 0x16e0
 8000974:	f101 010c 	add.w	r1, r1, #12
 8000978:	4811      	ldr	r0, [pc, #68]	@ (80009c0 <thirdMessageHandler+0x250>)
 800097a:	f014 f943 	bl	8014c04 <wc_RsaPrivateKeyDecode>
 800097e:	f507 53dd 	add.w	r3, r7, #7072	@ 0x1ba0
 8000982:	f103 0318 	add.w	r3, r3, #24
 8000986:	6018      	str	r0, [r3, #0]
    if (rsaRet != 0) {
 8000988:	f507 53dd 	add.w	r3, r7, #7072	@ 0x1ba0
 800098c:	f103 0318 	add.w	r3, r3, #24
 8000990:	681b      	ldr	r3, [r3, #0]
 8000992:	2b00      	cmp	r3, #0
 8000994:	d016      	beq.n	80009c4 <thirdMessageHandler+0x254>
        wc_FreeRsaKey(&rsaKey);
 8000996:	f507 63b1 	add.w	r3, r7, #1416	@ 0x588
 800099a:	3b18      	subs	r3, #24
 800099c:	4618      	mov	r0, r3
 800099e:	f01f faf7 	bl	801ff90 <wc_FreeRsaKey>
        wc_FreeRng(&rng);
 80009a2:	f507 63ad 	add.w	r3, r7, #1384	@ 0x568
 80009a6:	3b08      	subs	r3, #8
 80009a8:	4618      	mov	r0, r3
 80009aa:	f01e fe95 	bl	801f6d8 <wc_FreeRng>
        return;
 80009ae:	e124      	b.n	8000bfa <thirdMessageHandler+0x48a>
 80009b0:	08030cc2 	.word	0x08030cc2
 80009b4:	08030894 	.word	0x08030894
 80009b8:	200001a0 	.word	0x200001a0
 80009bc:	08030890 	.word	0x08030890
 80009c0:	080303e8 	.word	0x080303e8
    }
    wc_RsaSetRNG(&rsaKey, &rng);
 80009c4:	f507 62ad 	add.w	r2, r7, #1384	@ 0x568
 80009c8:	3a08      	subs	r2, #8
 80009ca:	f507 63b1 	add.w	r3, r7, #1416	@ 0x588
 80009ce:	3b18      	subs	r3, #24
 80009d0:	4611      	mov	r1, r2
 80009d2:	4618      	mov	r0, r3
 80009d4:	f020 fd1a 	bl	802140c <wc_RsaSetRNG>

    // desifrujeme
    uint8_t decryptedKey[256] = {0};
 80009d8:	f607 33c8 	addw	r3, r7, #3016	@ 0xbc8
 80009dc:	f5a3 63ed 	sub.w	r3, r3, #1896	@ 0x768
 80009e0:	4618      	mov	r0, r3
 80009e2:	f44f 7380 	mov.w	r3, #256	@ 0x100
 80009e6:	461a      	mov	r2, r3
 80009e8:	2100      	movs	r1, #0
 80009ea:	f027 fd6d 	bl	80284c8 <memset>
    word32 decryptedKeyLen = sizeof(decryptedKey);
 80009ee:	f44f 7380 	mov.w	r3, #256	@ 0x100
 80009f2:	f507 52dd 	add.w	r2, r7, #7072	@ 0x1ba0
 80009f6:	f102 0214 	add.w	r2, r2, #20
 80009fa:	6013      	str	r3, [r2, #0]
    uint8_t decryptedIV[256] = {0};
 80009fc:	f607 33c8 	addw	r3, r7, #3016	@ 0xbc8
 8000a00:	f6a3 0368 	subw	r3, r3, #2152	@ 0x868
 8000a04:	4618      	mov	r0, r3
 8000a06:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8000a0a:	461a      	mov	r2, r3
 8000a0c:	2100      	movs	r1, #0
 8000a0e:	f027 fd5b 	bl	80284c8 <memset>
    word32 decryptedIVLen = sizeof(decryptedIV);
 8000a12:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8000a16:	f507 52dd 	add.w	r2, r7, #7072	@ 0x1ba0
 8000a1a:	f102 0210 	add.w	r2, r2, #16
 8000a1e:	6013      	str	r3, [r2, #0]
    word32 inputSize = 256;
 8000a20:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8000a24:	f507 52dd 	add.w	r2, r7, #7072	@ 0x1ba0
 8000a28:	f102 020c 	add.w	r2, r2, #12
 8000a2c:	6013      	str	r3, [r2, #0]
    // najprv kluc od celej spravy, sukromnym klucom tokenu
    rsaRet = wc_RsaPrivateDecrypt(encryptedKey, inputSize, decryptedKey, decryptedKeyLen, &rsaKey);
 8000a2e:	f507 628d 	add.w	r2, r7, #1128	@ 0x468
 8000a32:	3a08      	subs	r2, #8
 8000a34:	f607 33c8 	addw	r3, r7, #3016	@ 0xbc8
 8000a38:	f6a3 30bc 	subw	r0, r3, #3004	@ 0xbbc
 8000a3c:	f507 63b1 	add.w	r3, r7, #1416	@ 0x588
 8000a40:	3b18      	subs	r3, #24
 8000a42:	9300      	str	r3, [sp, #0]
 8000a44:	f507 53dd 	add.w	r3, r7, #7072	@ 0x1ba0
 8000a48:	f103 0314 	add.w	r3, r3, #20
 8000a4c:	681b      	ldr	r3, [r3, #0]
 8000a4e:	f507 51dd 	add.w	r1, r7, #7072	@ 0x1ba0
 8000a52:	f101 010c 	add.w	r1, r1, #12
 8000a56:	6809      	ldr	r1, [r1, #0]
 8000a58:	6800      	ldr	r0, [r0, #0]
 8000a5a:	f020 fb9f 	bl	802119c <wc_RsaPrivateDecrypt>
 8000a5e:	f507 53dd 	add.w	r3, r7, #7072	@ 0x1ba0
 8000a62:	f103 0318 	add.w	r3, r3, #24
 8000a66:	6018      	str	r0, [r3, #0]
    // potom inicializacny vektor, sukromnym klucom tokenu
    rsaRet = wc_RsaPrivateDecrypt(encryptedIV, inputSize, decryptedIV, decryptedIVLen, &rsaKey);
 8000a68:	f507 725a 	add.w	r2, r7, #872	@ 0x368
 8000a6c:	3a08      	subs	r2, #8
 8000a6e:	f607 33c8 	addw	r3, r7, #3016	@ 0xbc8
 8000a72:	f5a3 603c 	sub.w	r0, r3, #3008	@ 0xbc0
 8000a76:	f507 63b1 	add.w	r3, r7, #1416	@ 0x588
 8000a7a:	3b18      	subs	r3, #24
 8000a7c:	9300      	str	r3, [sp, #0]
 8000a7e:	f507 53dd 	add.w	r3, r7, #7072	@ 0x1ba0
 8000a82:	f103 0310 	add.w	r3, r3, #16
 8000a86:	681b      	ldr	r3, [r3, #0]
 8000a88:	f507 51dd 	add.w	r1, r7, #7072	@ 0x1ba0
 8000a8c:	f101 010c 	add.w	r1, r1, #12
 8000a90:	6809      	ldr	r1, [r1, #0]
 8000a92:	6800      	ldr	r0, [r0, #0]
 8000a94:	f020 fb82 	bl	802119c <wc_RsaPrivateDecrypt>
 8000a98:	f507 53dd 	add.w	r3, r7, #7072	@ 0x1ba0
 8000a9c:	f103 0318 	add.w	r3, r3, #24
 8000aa0:	6018      	str	r0, [r3, #0]
    // a nakoniec celu spravu (payload)
    Aes aes;
    int aesRet = wc_AesSetKey(&aes, decryptedKey, 16, decryptedIV, AES_DECRYPTION);
 8000aa2:	f507 735a 	add.w	r3, r7, #872	@ 0x368
 8000aa6:	3b08      	subs	r3, #8
 8000aa8:	f507 618d 	add.w	r1, r7, #1128	@ 0x468
 8000aac:	3908      	subs	r1, #8
 8000aae:	f507 700a 	add.w	r0, r7, #552	@ 0x228
 8000ab2:	3814      	subs	r0, #20
 8000ab4:	2201      	movs	r2, #1
 8000ab6:	9200      	str	r2, [sp, #0]
 8000ab8:	2210      	movs	r2, #16
 8000aba:	f011 fcd3 	bl	8012464 <wc_AesSetKey>
 8000abe:	f507 53dd 	add.w	r3, r7, #7072	@ 0x1ba0
 8000ac2:	f103 0308 	add.w	r3, r3, #8
 8000ac6:	6018      	str	r0, [r3, #0]
    if (aesRet != 0) {
 8000ac8:	f507 53dd 	add.w	r3, r7, #7072	@ 0x1ba0
 8000acc:	f103 0308 	add.w	r3, r3, #8
 8000ad0:	681b      	ldr	r3, [r3, #0]
 8000ad2:	2b00      	cmp	r3, #0
 8000ad4:	f040 808c 	bne.w	8000bf0 <thirdMessageHandler+0x480>
        return;
    }
    uint8_t decryptedPayload[512];
    aesRet = wc_AesCbcDecrypt(&aes, decryptedPayload, payload, 512);
 8000ad8:	f607 33c8 	addw	r3, r7, #3016	@ 0xbc8
 8000adc:	f6a3 32c4 	subw	r2, r3, #3012	@ 0xbc4
 8000ae0:	f107 0128 	add.w	r1, r7, #40	@ 0x28
 8000ae4:	3914      	subs	r1, #20
 8000ae6:	f507 700a 	add.w	r0, r7, #552	@ 0x228
 8000aea:	3814      	subs	r0, #20
 8000aec:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8000af0:	6812      	ldr	r2, [r2, #0]
 8000af2:	f011 fd46 	bl	8012582 <wc_AesCbcDecrypt>
 8000af6:	f507 53dd 	add.w	r3, r7, #7072	@ 0x1ba0
 8000afa:	f103 0308 	add.w	r3, r3, #8
 8000afe:	6018      	str	r0, [r3, #0]
    if (aesRet != 0) {
 8000b00:	f507 53dd 	add.w	r3, r7, #7072	@ 0x1ba0
 8000b04:	f103 0308 	add.w	r3, r3, #8
 8000b08:	681b      	ldr	r3, [r3, #0]
 8000b0a:	2b00      	cmp	r3, #0
 8000b0c:	d172      	bne.n	8000bf4 <thirdMessageHandler+0x484>
        return;
    }

    // ukladanie dat do struktury
    memcpy(thirdMessage.timestamp, &decryptedPayload[0], 4);
 8000b0e:	f607 33c8 	addw	r3, r7, #3016	@ 0xbc8
 8000b12:	f6a3 33b4 	subw	r3, r3, #2996	@ 0xbb4
 8000b16:	681b      	ldr	r3, [r3, #0]
 8000b18:	4a3a      	ldr	r2, [pc, #232]	@ (8000c04 <thirdMessageHandler+0x494>)
 8000b1a:	6013      	str	r3, [r2, #0]
    memcpy(thirdMessage.session_key, &decryptedPayload[4], 16);
 8000b1c:	4a39      	ldr	r2, [pc, #228]	@ (8000c04 <thirdMessageHandler+0x494>)
 8000b1e:	f607 33c8 	addw	r3, r7, #3016	@ 0xbc8
 8000b22:	f6a3 33b4 	subw	r3, r3, #2996	@ 0xbb4
 8000b26:	1d14      	adds	r4, r2, #4
 8000b28:	3304      	adds	r3, #4
 8000b2a:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8000b2c:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    memcpy(thirdMessage.session_IV, &decryptedPayload[20], 16);
 8000b30:	4a34      	ldr	r2, [pc, #208]	@ (8000c04 <thirdMessageHandler+0x494>)
 8000b32:	f607 33c8 	addw	r3, r7, #3016	@ 0xbc8
 8000b36:	f6a3 33b4 	subw	r3, r3, #2996	@ 0xbb4
 8000b3a:	f102 0414 	add.w	r4, r2, #20
 8000b3e:	3314      	adds	r3, #20
 8000b40:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8000b42:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    memcpy(thirdMessage.Tid_one, &decryptedPayload[36], 4);
 8000b46:	f607 33c8 	addw	r3, r7, #3016	@ 0xbc8
 8000b4a:	f6a3 33b4 	subw	r3, r3, #2996	@ 0xbb4
 8000b4e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8000b50:	4a2c      	ldr	r2, [pc, #176]	@ (8000c04 <thirdMessageHandler+0x494>)
 8000b52:	6253      	str	r3, [r2, #36]	@ 0x24
    memcpy(thirdMessage.Tid_two, &decryptedPayload[40], 4);
 8000b54:	f607 33c8 	addw	r3, r7, #3016	@ 0xbc8
 8000b58:	f6a3 33b4 	subw	r3, r3, #2996	@ 0xbb4
 8000b5c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8000b5e:	4a29      	ldr	r2, [pc, #164]	@ (8000c04 <thirdMessageHandler+0x494>)
 8000b60:	6293      	str	r3, [r2, #40]	@ 0x28
    memcpy(thirdMessage.Tid_three, &decryptedPayload[44], 4);
 8000b62:	f607 33c8 	addw	r3, r7, #3016	@ 0xbc8
 8000b66:	f6a3 33b4 	subw	r3, r3, #2996	@ 0xbb4
 8000b6a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8000b6c:	4a25      	ldr	r2, [pc, #148]	@ (8000c04 <thirdMessageHandler+0x494>)
 8000b6e:	62d3      	str	r3, [r2, #44]	@ 0x2c
    memcpy(thirdMessage.PC_id, &decryptedPayload[48], 8);
 8000b70:	4b24      	ldr	r3, [pc, #144]	@ (8000c04 <thirdMessageHandler+0x494>)
 8000b72:	f607 32c8 	addw	r2, r7, #3016	@ 0xbc8
 8000b76:	f6a2 32b4 	subw	r2, r2, #2996	@ 0xbb4
 8000b7a:	3330      	adds	r3, #48	@ 0x30
 8000b7c:	3230      	adds	r2, #48	@ 0x30
 8000b7e:	e892 0003 	ldmia.w	r2, {r0, r1}
 8000b82:	e883 0003 	stmia.w	r3, {r0, r1}
    wc_FreeRsaKey(&rsaKey);
 8000b86:	f507 63b1 	add.w	r3, r7, #1416	@ 0x588
 8000b8a:	3b18      	subs	r3, #24
 8000b8c:	4618      	mov	r0, r3
 8000b8e:	f01f f9ff 	bl	801ff90 <wc_FreeRsaKey>
    wc_FreeRng(&rng);
 8000b92:	f507 63ad 	add.w	r3, r7, #1384	@ 0x568
 8000b96:	3b08      	subs	r3, #8
 8000b98:	4618      	mov	r0, r3
 8000b9a:	f01e fd9d 	bl	801f6d8 <wc_FreeRng>
    wc_AesFree(&aes);
 8000b9e:	f507 730a 	add.w	r3, r7, #552	@ 0x228
 8000ba2:	3b14      	subs	r3, #20
 8000ba4:	4618      	mov	r0, r3
 8000ba6:	f011 fd63 	bl	8012670 <wc_AesFree>

    // skontrolujme este ci prijaty token ID suladi s tym co sme odoslali v druhej sprave
    if(memcmp(secondMessage.Tid_one, thirdMessage.Tid_one, sizeof(secondMessage.Tid_one)) != 0 ||
 8000baa:	2204      	movs	r2, #4
 8000bac:	4916      	ldr	r1, [pc, #88]	@ (8000c08 <thirdMessageHandler+0x498>)
 8000bae:	4817      	ldr	r0, [pc, #92]	@ (8000c0c <thirdMessageHandler+0x49c>)
 8000bb0:	f027 fc60 	bl	8028474 <memcmp>
 8000bb4:	4603      	mov	r3, r0
 8000bb6:	2b00      	cmp	r3, #0
 8000bb8:	d11e      	bne.n	8000bf8 <thirdMessageHandler+0x488>
    		memcmp(secondMessage.Tid_two, thirdMessage.Tid_two, sizeof(secondMessage.Tid_two)) != 0 ||
 8000bba:	2204      	movs	r2, #4
 8000bbc:	4914      	ldr	r1, [pc, #80]	@ (8000c10 <thirdMessageHandler+0x4a0>)
 8000bbe:	4815      	ldr	r0, [pc, #84]	@ (8000c14 <thirdMessageHandler+0x4a4>)
 8000bc0:	f027 fc58 	bl	8028474 <memcmp>
 8000bc4:	4603      	mov	r3, r0
    if(memcmp(secondMessage.Tid_one, thirdMessage.Tid_one, sizeof(secondMessage.Tid_one)) != 0 ||
 8000bc6:	2b00      	cmp	r3, #0
 8000bc8:	d116      	bne.n	8000bf8 <thirdMessageHandler+0x488>
    				memcmp(secondMessage.Tid_three, thirdMessage.Tid_three, sizeof(secondMessage.Tid_three)) != 0) {
 8000bca:	2204      	movs	r2, #4
 8000bcc:	4912      	ldr	r1, [pc, #72]	@ (8000c18 <thirdMessageHandler+0x4a8>)
 8000bce:	4813      	ldr	r0, [pc, #76]	@ (8000c1c <thirdMessageHandler+0x4ac>)
 8000bd0:	f027 fc50 	bl	8028474 <memcmp>
 8000bd4:	4603      	mov	r3, r0
    		memcmp(secondMessage.Tid_two, thirdMessage.Tid_two, sizeof(secondMessage.Tid_two)) != 0 ||
 8000bd6:	2b00      	cmp	r3, #0
 8000bd8:	d10e      	bne.n	8000bf8 <thirdMessageHandler+0x488>
    	return;
    }
	fourthMessageSender();
 8000bda:	f000 f821 	bl	8000c20 <fourthMessageSender>
 8000bde:	e00c      	b.n	8000bfa <thirdMessageHandler+0x48a>
        return;
 8000be0:	bf00      	nop
 8000be2:	e00a      	b.n	8000bfa <thirdMessageHandler+0x48a>
        return;
 8000be4:	bf00      	nop
 8000be6:	e008      	b.n	8000bfa <thirdMessageHandler+0x48a>
        return;
 8000be8:	bf00      	nop
 8000bea:	e006      	b.n	8000bfa <thirdMessageHandler+0x48a>
        return;
 8000bec:	bf00      	nop
 8000bee:	e004      	b.n	8000bfa <thirdMessageHandler+0x48a>
        return;
 8000bf0:	bf00      	nop
 8000bf2:	e002      	b.n	8000bfa <thirdMessageHandler+0x48a>
        return;
 8000bf4:	bf00      	nop
 8000bf6:	e000      	b.n	8000bfa <thirdMessageHandler+0x48a>
    	return;
 8000bf8:	bf00      	nop
}
 8000bfa:	f507 57de 	add.w	r7, r7, #7104	@ 0x1bc0
 8000bfe:	370c      	adds	r7, #12
 8000c00:	46bd      	mov	sp, r7
 8000c02:	bd90      	pop	{r4, r7, pc}
 8000c04:	2000131c 	.word	0x2000131c
 8000c08:	20001340 	.word	0x20001340
 8000c0c:	20000008 	.word	0x20000008
 8000c10:	20001344 	.word	0x20001344
 8000c14:	2000000c 	.word	0x2000000c
 8000c18:	20001348 	.word	0x20001348
 8000c1c:	20000010 	.word	0x20000010

08000c20 <fourthMessageSender>:

void fourthMessageSender() {
 8000c20:	b5b0      	push	{r4, r5, r7, lr}
 8000c22:	f5ad 6db0 	sub.w	sp, sp, #1408	@ 0x580
 8000c26:	af02      	add	r7, sp, #8
	// inkrementujme timestamp o 1
	uint32_t timestamp = (thirdMessage.timestamp[3] << 24) | (thirdMessage.timestamp[2] << 16) |
 8000c28:	4b5e      	ldr	r3, [pc, #376]	@ (8000da4 <fourthMessageSender+0x184>)
 8000c2a:	78db      	ldrb	r3, [r3, #3]
 8000c2c:	061a      	lsls	r2, r3, #24
 8000c2e:	4b5d      	ldr	r3, [pc, #372]	@ (8000da4 <fourthMessageSender+0x184>)
 8000c30:	789b      	ldrb	r3, [r3, #2]
 8000c32:	041b      	lsls	r3, r3, #16
 8000c34:	431a      	orrs	r2, r3
	     ( thirdMessage.timestamp[1] << 8 ) | (thirdMessage.timestamp[0]);
 8000c36:	4b5b      	ldr	r3, [pc, #364]	@ (8000da4 <fourthMessageSender+0x184>)
 8000c38:	785b      	ldrb	r3, [r3, #1]
 8000c3a:	021b      	lsls	r3, r3, #8
	uint32_t timestamp = (thirdMessage.timestamp[3] << 24) | (thirdMessage.timestamp[2] << 16) |
 8000c3c:	4313      	orrs	r3, r2
	     ( thirdMessage.timestamp[1] << 8 ) | (thirdMessage.timestamp[0]);
 8000c3e:	4a59      	ldr	r2, [pc, #356]	@ (8000da4 <fourthMessageSender+0x184>)
 8000c40:	7812      	ldrb	r2, [r2, #0]
 8000c42:	4313      	orrs	r3, r2
	uint32_t timestamp = (thirdMessage.timestamp[3] << 24) | (thirdMessage.timestamp[2] << 16) |
 8000c44:	f8c7 3574 	str.w	r3, [r7, #1396]	@ 0x574
	timestamp += 1;
 8000c48:	f8d7 3574 	ldr.w	r3, [r7, #1396]	@ 0x574
 8000c4c:	3301      	adds	r3, #1
 8000c4e:	f8c7 3574 	str.w	r3, [r7, #1396]	@ 0x574

	// pripravme si  takmer celu stvrtu spravu podla struktury MessageFour
	fourthMessage.timestamp[0] = (timestamp & 0x000000ff);
 8000c52:	f8d7 3574 	ldr.w	r3, [r7, #1396]	@ 0x574
 8000c56:	b2da      	uxtb	r2, r3
 8000c58:	4b53      	ldr	r3, [pc, #332]	@ (8000da8 <fourthMessageSender+0x188>)
 8000c5a:	701a      	strb	r2, [r3, #0]
	fourthMessage.timestamp[1] = (timestamp & 0x0000ff00) >> 8;
 8000c5c:	f8d7 3574 	ldr.w	r3, [r7, #1396]	@ 0x574
 8000c60:	0a1b      	lsrs	r3, r3, #8
 8000c62:	b2da      	uxtb	r2, r3
 8000c64:	4b50      	ldr	r3, [pc, #320]	@ (8000da8 <fourthMessageSender+0x188>)
 8000c66:	705a      	strb	r2, [r3, #1]
	fourthMessage.timestamp[2] = (timestamp & 0x00ff0000) >> 16;
 8000c68:	f8d7 3574 	ldr.w	r3, [r7, #1396]	@ 0x574
 8000c6c:	0c1b      	lsrs	r3, r3, #16
 8000c6e:	b2da      	uxtb	r2, r3
 8000c70:	4b4d      	ldr	r3, [pc, #308]	@ (8000da8 <fourthMessageSender+0x188>)
 8000c72:	709a      	strb	r2, [r3, #2]
	fourthMessage.timestamp[3] = (timestamp & 0xff000000) >> 24;
 8000c74:	f8d7 3574 	ldr.w	r3, [r7, #1396]	@ 0x574
 8000c78:	0e1b      	lsrs	r3, r3, #24
 8000c7a:	b2da      	uxtb	r2, r3
 8000c7c:	4b4a      	ldr	r3, [pc, #296]	@ (8000da8 <fourthMessageSender+0x188>)
 8000c7e:	70da      	strb	r2, [r3, #3]
	memcpy(fourthMessage.Tid_one, thirdMessage.Tid_one, 4);
 8000c80:	4b48      	ldr	r3, [pc, #288]	@ (8000da4 <fourthMessageSender+0x184>)
 8000c82:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8000c84:	4a48      	ldr	r2, [pc, #288]	@ (8000da8 <fourthMessageSender+0x188>)
 8000c86:	6053      	str	r3, [r2, #4]
	memcpy(fourthMessage.Tid_two, thirdMessage.Tid_two, 4);
 8000c88:	4b46      	ldr	r3, [pc, #280]	@ (8000da4 <fourthMessageSender+0x184>)
 8000c8a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8000c8c:	4a46      	ldr	r2, [pc, #280]	@ (8000da8 <fourthMessageSender+0x188>)
 8000c8e:	6093      	str	r3, [r2, #8]
	memcpy(fourthMessage.Tid_three, thirdMessage.Tid_three, 4);
 8000c90:	4b44      	ldr	r3, [pc, #272]	@ (8000da4 <fourthMessageSender+0x184>)
 8000c92:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8000c94:	4a44      	ldr	r2, [pc, #272]	@ (8000da8 <fourthMessageSender+0x188>)
 8000c96:	60d3      	str	r3, [r2, #12]
	memcpy(fourthMessage.PC_id, thirdMessage.PC_id, 8);
 8000c98:	4b43      	ldr	r3, [pc, #268]	@ (8000da8 <fourthMessageSender+0x188>)
 8000c9a:	4a42      	ldr	r2, [pc, #264]	@ (8000da4 <fourthMessageSender+0x184>)
 8000c9c:	3310      	adds	r3, #16
 8000c9e:	3230      	adds	r2, #48	@ 0x30
 8000ca0:	e892 0003 	ldmia.w	r2, {r0, r1}
 8000ca4:	e883 0003 	stmia.w	r3, {r0, r1}

	// este vygenerujme nonce
	uint8_t randomBytes[16];
	WC_RNG rng;
	if (wc_InitRng(&rng) != 0) {
 8000ca8:	f507 63aa 	add.w	r3, r7, #1360	@ 0x550
 8000cac:	4618      	mov	r0, r3
 8000cae:	f01e fc60 	bl	801f572 <wc_InitRng>
 8000cb2:	4603      	mov	r3, r0
 8000cb4:	2b00      	cmp	r3, #0
 8000cb6:	d16b      	bne.n	8000d90 <fourthMessageSender+0x170>
	    return;
	}
	if (wc_RNG_GenerateBlock(&rng, randomBytes, sizeof(randomBytes)) != 0) {
 8000cb8:	f507 61ac 	add.w	r1, r7, #1376	@ 0x560
 8000cbc:	f507 63aa 	add.w	r3, r7, #1360	@ 0x550
 8000cc0:	2210      	movs	r2, #16
 8000cc2:	4618      	mov	r0, r3
 8000cc4:	f01e fc67 	bl	801f596 <wc_RNG_GenerateBlock>
 8000cc8:	4603      	mov	r3, r0
 8000cca:	2b00      	cmp	r3, #0
 8000ccc:	d005      	beq.n	8000cda <fourthMessageSender+0xba>
	    wc_FreeRng(&rng);
 8000cce:	f507 63aa 	add.w	r3, r7, #1360	@ 0x550
 8000cd2:	4618      	mov	r0, r3
 8000cd4:	f01e fd00 	bl	801f6d8 <wc_FreeRng>
	    return;
 8000cd8:	e05f      	b.n	8000d9a <fourthMessageSender+0x17a>
	}
	wc_FreeRng(&rng);
 8000cda:	f507 63aa 	add.w	r3, r7, #1360	@ 0x550
 8000cde:	4618      	mov	r0, r3
 8000ce0:	f01e fcfa 	bl	801f6d8 <wc_FreeRng>
	memcpy(fourthMessage.T_nonce, randomBytes, 16);
 8000ce4:	4b30      	ldr	r3, [pc, #192]	@ (8000da8 <fourthMessageSender+0x188>)
 8000ce6:	f103 0418 	add.w	r4, r3, #24
 8000cea:	f507 63ac 	add.w	r3, r7, #1376	@ 0x560
 8000cee:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8000cf0:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}

	// nasledne zasifrujme spravu cez sessionKey
	unsigned char paddedPlaintext[512] = {0};
 8000cf4:	f507 63af 	add.w	r3, r7, #1400	@ 0x578
 8000cf8:	f5a3 730a 	sub.w	r3, r3, #552	@ 0x228
 8000cfc:	4618      	mov	r0, r3
 8000cfe:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8000d02:	461a      	mov	r2, r3
 8000d04:	2100      	movs	r1, #0
 8000d06:	f027 fbdf 	bl	80284c8 <memset>
	memcpy(paddedPlaintext, &fourthMessage, sizeof(fourthMessage));
 8000d0a:	f507 63af 	add.w	r3, r7, #1400	@ 0x578
 8000d0e:	f5a3 730a 	sub.w	r3, r3, #552	@ 0x228
 8000d12:	4a25      	ldr	r2, [pc, #148]	@ (8000da8 <fourthMessageSender+0x188>)
 8000d14:	461c      	mov	r4, r3
 8000d16:	4615      	mov	r5, r2
 8000d18:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000d1a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8000d1c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000d1e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8000d20:	e895 0003 	ldmia.w	r5, {r0, r1}
 8000d24:	e884 0003 	stmia.w	r4, {r0, r1}
	Aes aes;
	int aesRet = wc_AesSetKey(&aes, thirdMessage.session_key, 16, thirdMessage.session_IV, AES_ENCRYPTION);
 8000d28:	f507 7001 	add.w	r0, r7, #516	@ 0x204
 8000d2c:	2300      	movs	r3, #0
 8000d2e:	9300      	str	r3, [sp, #0]
 8000d30:	4b1e      	ldr	r3, [pc, #120]	@ (8000dac <fourthMessageSender+0x18c>)
 8000d32:	2210      	movs	r2, #16
 8000d34:	491e      	ldr	r1, [pc, #120]	@ (8000db0 <fourthMessageSender+0x190>)
 8000d36:	f011 fb95 	bl	8012464 <wc_AesSetKey>
 8000d3a:	f8c7 0570 	str.w	r0, [r7, #1392]	@ 0x570
	if (aesRet != 0) {
 8000d3e:	f8d7 3570 	ldr.w	r3, [r7, #1392]	@ 0x570
 8000d42:	2b00      	cmp	r3, #0
 8000d44:	d126      	bne.n	8000d94 <fourthMessageSender+0x174>
	    return;
	}
	uint8_t encryptedPayload[512];
	aesRet = wc_AesCbcEncrypt(&aes, encryptedPayload, paddedPlaintext, 512);
 8000d46:	f507 7254 	add.w	r2, r7, #848	@ 0x350
 8000d4a:	1d39      	adds	r1, r7, #4
 8000d4c:	f507 7001 	add.w	r0, r7, #516	@ 0x204
 8000d50:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8000d54:	f011 fbca 	bl	80124ec <wc_AesCbcEncrypt>
 8000d58:	f8c7 0570 	str.w	r0, [r7, #1392]	@ 0x570
	if (aesRet != 0) {
 8000d5c:	f8d7 3570 	ldr.w	r3, [r7, #1392]	@ 0x570
 8000d60:	2b00      	cmp	r3, #0
 8000d62:	d119      	bne.n	8000d98 <fourthMessageSender+0x178>
	    return;
	}

	// a potom vlozme ju do sendBuffer na odoslanie
	memcpy(sendBuffer, encryptedPayload, 512);
 8000d64:	4a13      	ldr	r2, [pc, #76]	@ (8000db4 <fourthMessageSender+0x194>)
 8000d66:	f507 63af 	add.w	r3, r7, #1400	@ 0x578
 8000d6a:	f2a3 5374 	subw	r3, r3, #1396	@ 0x574
 8000d6e:	4610      	mov	r0, r2
 8000d70:	4619      	mov	r1, r3
 8000d72:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8000d76:	461a      	mov	r2, r3
 8000d78:	f027 fc10 	bl	802859c <memcpy>
	sendCounter = 512;
 8000d7c:	4b0e      	ldr	r3, [pc, #56]	@ (8000db8 <fourthMessageSender+0x198>)
 8000d7e:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8000d82:	801a      	strh	r2, [r3, #0]
	wc_AesFree(&aes);
 8000d84:	f507 7301 	add.w	r3, r7, #516	@ 0x204
 8000d88:	4618      	mov	r0, r3
 8000d8a:	f011 fc71 	bl	8012670 <wc_AesFree>
	return;
 8000d8e:	e004      	b.n	8000d9a <fourthMessageSender+0x17a>
	    return;
 8000d90:	bf00      	nop
 8000d92:	e002      	b.n	8000d9a <fourthMessageSender+0x17a>
	    return;
 8000d94:	bf00      	nop
 8000d96:	e000      	b.n	8000d9a <fourthMessageSender+0x17a>
	    return;
 8000d98:	bf00      	nop
}
 8000d9a:	f507 67af 	add.w	r7, r7, #1400	@ 0x578
 8000d9e:	46bd      	mov	sp, r7
 8000da0:	bdb0      	pop	{r4, r5, r7, pc}
 8000da2:	bf00      	nop
 8000da4:	2000131c 	.word	0x2000131c
 8000da8:	20001354 	.word	0x20001354
 8000dac:	20001330 	.word	0x20001330
 8000db0:	20001320 	.word	0x20001320
 8000db4:	20001ed4 	.word	0x20001ed4
 8000db8:	20002898 	.word	0x20002898

08000dbc <fifthMessageHandler>:

void fifthMessageHandler(uint8_t* payload, uint8_t* sigHash) {
 8000dbc:	b590      	push	{r4, r7, lr}
 8000dbe:	f2ad 4d04 	subw	sp, sp, #1028	@ 0x404
 8000dc2:	af04      	add	r7, sp, #16
 8000dc4:	f507 737c 	add.w	r3, r7, #1008	@ 0x3f0
 8000dc8:	f5a3 737b 	sub.w	r3, r3, #1004	@ 0x3ec
 8000dcc:	6018      	str	r0, [r3, #0]
 8000dce:	f507 737c 	add.w	r3, r7, #1008	@ 0x3f0
 8000dd2:	f5a3 737c 	sub.w	r3, r3, #1008	@ 0x3f0
 8000dd6:	6019      	str	r1, [r3, #0]
	// AES desifrovanie payload a ulozenie do struktury
	Aes aes;
	int aesRet = wc_AesSetKey(&aes, thirdMessage.session_key, 16, thirdMessage.session_IV, AES_DECRYPTION);
 8000dd8:	f507 7027 	add.w	r0, r7, #668	@ 0x29c
 8000ddc:	2301      	movs	r3, #1
 8000dde:	9300      	str	r3, [sp, #0]
 8000de0:	4b62      	ldr	r3, [pc, #392]	@ (8000f6c <fifthMessageHandler+0x1b0>)
 8000de2:	2210      	movs	r2, #16
 8000de4:	4962      	ldr	r1, [pc, #392]	@ (8000f70 <fifthMessageHandler+0x1b4>)
 8000de6:	f011 fb3d 	bl	8012464 <wc_AesSetKey>
 8000dea:	f8c7 03ec 	str.w	r0, [r7, #1004]	@ 0x3ec
	if (aesRet != 0) {
 8000dee:	f8d7 33ec 	ldr.w	r3, [r7, #1004]	@ 0x3ec
 8000df2:	2b00      	cmp	r3, #0
 8000df4:	f040 80ac 	bne.w	8000f50 <fifthMessageHandler+0x194>
	    return;
	}
	uint8_t decryptedPayload[512];
	aesRet = wc_AesCbcDecrypt(&aes, decryptedPayload, payload, 512);
 8000df8:	f507 737c 	add.w	r3, r7, #1008	@ 0x3f0
 8000dfc:	f5a3 727b 	sub.w	r2, r3, #1004	@ 0x3ec
 8000e00:	f107 019c 	add.w	r1, r7, #156	@ 0x9c
 8000e04:	f507 7027 	add.w	r0, r7, #668	@ 0x29c
 8000e08:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8000e0c:	6812      	ldr	r2, [r2, #0]
 8000e0e:	f011 fbb8 	bl	8012582 <wc_AesCbcDecrypt>
 8000e12:	f8c7 03ec 	str.w	r0, [r7, #1004]	@ 0x3ec
	if (aesRet != 0) {
 8000e16:	f8d7 33ec 	ldr.w	r3, [r7, #1004]	@ 0x3ec
 8000e1a:	2b00      	cmp	r3, #0
 8000e1c:	f040 809a 	bne.w	8000f54 <fifthMessageHandler+0x198>
	    return;
	}
	memcpy(fifthMessage.timestamp, &decryptedPayload[0], 4);
 8000e20:	f507 737c 	add.w	r3, r7, #1008	@ 0x3f0
 8000e24:	f5a3 7355 	sub.w	r3, r3, #852	@ 0x354
 8000e28:	681b      	ldr	r3, [r3, #0]
 8000e2a:	4a52      	ldr	r2, [pc, #328]	@ (8000f74 <fifthMessageHandler+0x1b8>)
 8000e2c:	6013      	str	r3, [r2, #0]
	memcpy(fifthMessage.Tid_one, &decryptedPayload[4], 4);
 8000e2e:	f507 737c 	add.w	r3, r7, #1008	@ 0x3f0
 8000e32:	f5a3 7355 	sub.w	r3, r3, #852	@ 0x354
 8000e36:	685b      	ldr	r3, [r3, #4]
 8000e38:	4a4e      	ldr	r2, [pc, #312]	@ (8000f74 <fifthMessageHandler+0x1b8>)
 8000e3a:	6053      	str	r3, [r2, #4]
	memcpy(fifthMessage.Tid_two, &decryptedPayload[8], 4);
 8000e3c:	f507 737c 	add.w	r3, r7, #1008	@ 0x3f0
 8000e40:	f5a3 7355 	sub.w	r3, r3, #852	@ 0x354
 8000e44:	689b      	ldr	r3, [r3, #8]
 8000e46:	4a4b      	ldr	r2, [pc, #300]	@ (8000f74 <fifthMessageHandler+0x1b8>)
 8000e48:	6093      	str	r3, [r2, #8]
	memcpy(fifthMessage.Tid_three, &decryptedPayload[12], 4);
 8000e4a:	f507 737c 	add.w	r3, r7, #1008	@ 0x3f0
 8000e4e:	f5a3 7355 	sub.w	r3, r3, #852	@ 0x354
 8000e52:	68db      	ldr	r3, [r3, #12]
 8000e54:	4a47      	ldr	r2, [pc, #284]	@ (8000f74 <fifthMessageHandler+0x1b8>)
 8000e56:	60d3      	str	r3, [r2, #12]
	memcpy(fifthMessage.PC_id, &decryptedPayload[16], 8);
 8000e58:	4946      	ldr	r1, [pc, #280]	@ (8000f74 <fifthMessageHandler+0x1b8>)
 8000e5a:	f507 737c 	add.w	r3, r7, #1008	@ 0x3f0
 8000e5e:	f5a3 7255 	sub.w	r2, r3, #852	@ 0x354
 8000e62:	f101 0310 	add.w	r3, r1, #16
 8000e66:	3210      	adds	r2, #16
 8000e68:	e892 0003 	ldmia.w	r2, {r0, r1}
 8000e6c:	e883 0003 	stmia.w	r3, {r0, r1}
	memcpy(fifthMessage.T_nonce, &decryptedPayload[24], 16);
 8000e70:	4a40      	ldr	r2, [pc, #256]	@ (8000f74 <fifthMessageHandler+0x1b8>)
 8000e72:	f507 737c 	add.w	r3, r7, #1008	@ 0x3f0
 8000e76:	f5a3 7355 	sub.w	r3, r3, #852	@ 0x354
 8000e7a:	f102 0418 	add.w	r4, r2, #24
 8000e7e:	3318      	adds	r3, #24
 8000e80:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8000e82:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	wc_AesFree(&aes);
 8000e86:	f507 7327 	add.w	r3, r7, #668	@ 0x29c
 8000e8a:	4618      	mov	r0, r3
 8000e8c:	f011 fbf0 	bl	8012670 <wc_AesFree>

	// teraz vytvorme SHA256 hash z prijatej piatej spravy
	Sha256 sha;
	uint8_t genHash[SHA256_DIGEST_SIZE];
	int hashRet = wc_InitSha256(&sha);
 8000e90:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
 8000e94:	4618      	mov	r0, r3
 8000e96:	f021 f8a7 	bl	8021fe8 <wc_InitSha256>
 8000e9a:	f8c7 03e8 	str.w	r0, [r7, #1000]	@ 0x3e8
	hashRet = wc_Sha256Update(&sha, (const uint8_t*)&fifthMessage, sizeof(MessageFive));
 8000e9e:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
 8000ea2:	2228      	movs	r2, #40	@ 0x28
 8000ea4:	4933      	ldr	r1, [pc, #204]	@ (8000f74 <fifthMessageHandler+0x1b8>)
 8000ea6:	4618      	mov	r0, r3
 8000ea8:	f020 ffd5 	bl	8021e56 <wc_Sha256Update>
 8000eac:	f8c7 03e8 	str.w	r0, [r7, #1000]	@ 0x3e8
	hashRet = wc_Sha256Final(&sha, genHash);
 8000eb0:	f107 020c 	add.w	r2, r7, #12
 8000eb4:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
 8000eb8:	4611      	mov	r1, r2
 8000eba:	4618      	mov	r0, r3
 8000ebc:	f021 f869 	bl	8021f92 <wc_Sha256Final>
 8000ec0:	f8c7 03e8 	str.w	r0, [r7, #1000]	@ 0x3e8

	// kontrolujme token id, PC id a nonce ci su rovnake
	if(memcmp(fifthMessage.Tid_one, fourthMessage.Tid_one, sizeof(fourthMessage.Tid_one)) != 0 ||
 8000ec4:	2204      	movs	r2, #4
 8000ec6:	492c      	ldr	r1, [pc, #176]	@ (8000f78 <fifthMessageHandler+0x1bc>)
 8000ec8:	482c      	ldr	r0, [pc, #176]	@ (8000f7c <fifthMessageHandler+0x1c0>)
 8000eca:	f027 fad3 	bl	8028474 <memcmp>
 8000ece:	4603      	mov	r3, r0
 8000ed0:	2b00      	cmp	r3, #0
 8000ed2:	d141      	bne.n	8000f58 <fifthMessageHandler+0x19c>
			memcmp(fifthMessage.Tid_two, fourthMessage.Tid_two, sizeof(fourthMessage.Tid_two)) != 0 ||
 8000ed4:	2204      	movs	r2, #4
 8000ed6:	492a      	ldr	r1, [pc, #168]	@ (8000f80 <fifthMessageHandler+0x1c4>)
 8000ed8:	482a      	ldr	r0, [pc, #168]	@ (8000f84 <fifthMessageHandler+0x1c8>)
 8000eda:	f027 facb 	bl	8028474 <memcmp>
 8000ede:	4603      	mov	r3, r0
	if(memcmp(fifthMessage.Tid_one, fourthMessage.Tid_one, sizeof(fourthMessage.Tid_one)) != 0 ||
 8000ee0:	2b00      	cmp	r3, #0
 8000ee2:	d139      	bne.n	8000f58 <fifthMessageHandler+0x19c>
					memcmp(fifthMessage.Tid_three, fourthMessage.Tid_three, sizeof(fourthMessage.Tid_three)) != 0) {
 8000ee4:	2204      	movs	r2, #4
 8000ee6:	4928      	ldr	r1, [pc, #160]	@ (8000f88 <fifthMessageHandler+0x1cc>)
 8000ee8:	4828      	ldr	r0, [pc, #160]	@ (8000f8c <fifthMessageHandler+0x1d0>)
 8000eea:	f027 fac3 	bl	8028474 <memcmp>
 8000eee:	4603      	mov	r3, r0
			memcmp(fifthMessage.Tid_two, fourthMessage.Tid_two, sizeof(fourthMessage.Tid_two)) != 0 ||
 8000ef0:	2b00      	cmp	r3, #0
 8000ef2:	d131      	bne.n	8000f58 <fifthMessageHandler+0x19c>
		return;
	}
	if(memcmp(fifthMessage.PC_id, fourthMessage.PC_id, sizeof(fourthMessage.PC_id)) != 0) {
 8000ef4:	2208      	movs	r2, #8
 8000ef6:	4926      	ldr	r1, [pc, #152]	@ (8000f90 <fifthMessageHandler+0x1d4>)
 8000ef8:	4826      	ldr	r0, [pc, #152]	@ (8000f94 <fifthMessageHandler+0x1d8>)
 8000efa:	f027 fabb 	bl	8028474 <memcmp>
 8000efe:	4603      	mov	r3, r0
 8000f00:	2b00      	cmp	r3, #0
 8000f02:	d12b      	bne.n	8000f5c <fifthMessageHandler+0x1a0>
	    return;
	}
	if(memcmp(fifthMessage.T_nonce, fourthMessage.T_nonce, sizeof(fourthMessage.T_nonce)) != 0) {
 8000f04:	2210      	movs	r2, #16
 8000f06:	4924      	ldr	r1, [pc, #144]	@ (8000f98 <fifthMessageHandler+0x1dc>)
 8000f08:	4824      	ldr	r0, [pc, #144]	@ (8000f9c <fifthMessageHandler+0x1e0>)
 8000f0a:	f027 fab3 	bl	8028474 <memcmp>
 8000f0e:	4603      	mov	r3, r0
 8000f10:	2b00      	cmp	r3, #0
 8000f12:	d125      	bne.n	8000f60 <fifthMessageHandler+0x1a4>
		    return;
	}

	// ak ano, tak overme este, ci prijaty podpisany hash je podpisany vypoctovym zariadenim
	// teda pouzije sa vygenerovany hash a verejny kluc zariadenia na porovnanie s prijatym podpisanym hashom
	hashRet = wc_SignatureVerifyHash(
 8000f14:	f107 020c 	add.w	r2, r7, #12
 8000f18:	f241 137c 	movw	r3, #4476	@ 0x117c
 8000f1c:	9303      	str	r3, [sp, #12]
 8000f1e:	4b20      	ldr	r3, [pc, #128]	@ (8000fa0 <fifthMessageHandler+0x1e4>)
 8000f20:	9302      	str	r3, [sp, #8]
 8000f22:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8000f26:	9301      	str	r3, [sp, #4]
 8000f28:	f507 737c 	add.w	r3, r7, #1008	@ 0x3f0
 8000f2c:	f5a3 737c 	sub.w	r3, r3, #1008	@ 0x3f0
 8000f30:	681b      	ldr	r3, [r3, #0]
 8000f32:	9300      	str	r3, [sp, #0]
 8000f34:	2320      	movs	r3, #32
 8000f36:	2102      	movs	r1, #2
 8000f38:	2006      	movs	r0, #6
 8000f3a:	f021 f8a8 	bl	802208e <wc_SignatureVerifyHash>
 8000f3e:	f8c7 03e8 	str.w	r0, [r7, #1000]	@ 0x3e8
			WC_SIGNATURE_TYPE_RSA, 		// typ podpisu RSA
			genHash, 32, 				// hash vytvoreny z prijatych dat
			sigHash, 256, 				// hash co podpisalo zariadenie
			&pubKey, sizeof(RsaKey)		// verejny kluc zariadenia
				);
	if(hashRet == 0) {
 8000f42:	f8d7 33e8 	ldr.w	r3, [r7, #1000]	@ 0x3e8
 8000f46:	2b00      	cmp	r3, #0
 8000f48:	d10b      	bne.n	8000f62 <fifthMessageHandler+0x1a6>
		sixthMessageSender();
 8000f4a:	f000 f82b 	bl	8000fa4 <sixthMessageSender>
 8000f4e:	e008      	b.n	8000f62 <fifthMessageHandler+0x1a6>
	    return;
 8000f50:	bf00      	nop
 8000f52:	e006      	b.n	8000f62 <fifthMessageHandler+0x1a6>
	    return;
 8000f54:	bf00      	nop
 8000f56:	e004      	b.n	8000f62 <fifthMessageHandler+0x1a6>
		return;
 8000f58:	bf00      	nop
 8000f5a:	e002      	b.n	8000f62 <fifthMessageHandler+0x1a6>
	    return;
 8000f5c:	bf00      	nop
 8000f5e:	e000      	b.n	8000f62 <fifthMessageHandler+0x1a6>
		    return;
 8000f60:	bf00      	nop
	}
}
 8000f62:	f507 777d 	add.w	r7, r7, #1012	@ 0x3f4
 8000f66:	46bd      	mov	sp, r7
 8000f68:	bd90      	pop	{r4, r7, pc}
 8000f6a:	bf00      	nop
 8000f6c:	20001330 	.word	0x20001330
 8000f70:	20001320 	.word	0x20001320
 8000f74:	2000137c 	.word	0x2000137c
 8000f78:	20001358 	.word	0x20001358
 8000f7c:	20001380 	.word	0x20001380
 8000f80:	2000135c 	.word	0x2000135c
 8000f84:	20001384 	.word	0x20001384
 8000f88:	20001360 	.word	0x20001360
 8000f8c:	20001388 	.word	0x20001388
 8000f90:	20001364 	.word	0x20001364
 8000f94:	2000138c 	.word	0x2000138c
 8000f98:	2000136c 	.word	0x2000136c
 8000f9c:	20001394 	.word	0x20001394
 8000fa0:	200001a0 	.word	0x200001a0

08000fa4 <sixthMessageSender>:

void sixthMessageSender() {
 8000fa4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000fa6:	f2ad 5d8c 	subw	sp, sp, #1420	@ 0x58c
 8000faa:	af02      	add	r7, sp, #8
	// inkrementujme timestamp o 1
	uint32_t timestamp = (fifthMessage.timestamp[3] << 24) | (fifthMessage.timestamp[2] << 16) |
 8000fac:	4b76      	ldr	r3, [pc, #472]	@ (8001188 <sixthMessageSender+0x1e4>)
 8000fae:	78db      	ldrb	r3, [r3, #3]
 8000fb0:	061a      	lsls	r2, r3, #24
 8000fb2:	4b75      	ldr	r3, [pc, #468]	@ (8001188 <sixthMessageSender+0x1e4>)
 8000fb4:	789b      	ldrb	r3, [r3, #2]
 8000fb6:	041b      	lsls	r3, r3, #16
 8000fb8:	431a      	orrs	r2, r3
		     ( fifthMessage.timestamp[1] << 8 ) | (fifthMessage.timestamp[0]);
 8000fba:	4b73      	ldr	r3, [pc, #460]	@ (8001188 <sixthMessageSender+0x1e4>)
 8000fbc:	785b      	ldrb	r3, [r3, #1]
 8000fbe:	021b      	lsls	r3, r3, #8
	uint32_t timestamp = (fifthMessage.timestamp[3] << 24) | (fifthMessage.timestamp[2] << 16) |
 8000fc0:	4313      	orrs	r3, r2
		     ( fifthMessage.timestamp[1] << 8 ) | (fifthMessage.timestamp[0]);
 8000fc2:	4a71      	ldr	r2, [pc, #452]	@ (8001188 <sixthMessageSender+0x1e4>)
 8000fc4:	7812      	ldrb	r2, [r2, #0]
 8000fc6:	4313      	orrs	r3, r2
	uint32_t timestamp = (fifthMessage.timestamp[3] << 24) | (fifthMessage.timestamp[2] << 16) |
 8000fc8:	f8c7 357c 	str.w	r3, [r7, #1404]	@ 0x57c
	timestamp += 1;
 8000fcc:	f8d7 357c 	ldr.w	r3, [r7, #1404]	@ 0x57c
 8000fd0:	3301      	adds	r3, #1
 8000fd2:	f8c7 357c 	str.w	r3, [r7, #1404]	@ 0x57c

	// pripravme si takmer celu siestu spravu podla struktury MessageSix
	sixthMessage.timestamp[0] = (timestamp & 0x000000ff);
 8000fd6:	f8d7 357c 	ldr.w	r3, [r7, #1404]	@ 0x57c
 8000fda:	b2da      	uxtb	r2, r3
 8000fdc:	4b6b      	ldr	r3, [pc, #428]	@ (800118c <sixthMessageSender+0x1e8>)
 8000fde:	701a      	strb	r2, [r3, #0]
	sixthMessage.timestamp[1] = (timestamp & 0x0000ff00) >> 8;
 8000fe0:	f8d7 357c 	ldr.w	r3, [r7, #1404]	@ 0x57c
 8000fe4:	0a1b      	lsrs	r3, r3, #8
 8000fe6:	b2da      	uxtb	r2, r3
 8000fe8:	4b68      	ldr	r3, [pc, #416]	@ (800118c <sixthMessageSender+0x1e8>)
 8000fea:	705a      	strb	r2, [r3, #1]
	sixthMessage.timestamp[2] = (timestamp & 0x00ff0000) >> 16;
 8000fec:	f8d7 357c 	ldr.w	r3, [r7, #1404]	@ 0x57c
 8000ff0:	0c1b      	lsrs	r3, r3, #16
 8000ff2:	b2da      	uxtb	r2, r3
 8000ff4:	4b65      	ldr	r3, [pc, #404]	@ (800118c <sixthMessageSender+0x1e8>)
 8000ff6:	709a      	strb	r2, [r3, #2]
	sixthMessage.timestamp[3] = (timestamp & 0xff000000) >> 24;
 8000ff8:	f8d7 357c 	ldr.w	r3, [r7, #1404]	@ 0x57c
 8000ffc:	0e1b      	lsrs	r3, r3, #24
 8000ffe:	b2da      	uxtb	r2, r3
 8001000:	4b62      	ldr	r3, [pc, #392]	@ (800118c <sixthMessageSender+0x1e8>)
 8001002:	70da      	strb	r2, [r3, #3]
	memcpy(sixthMessage.Tid_one, fifthMessage.Tid_one, 4);
 8001004:	4b60      	ldr	r3, [pc, #384]	@ (8001188 <sixthMessageSender+0x1e4>)
 8001006:	685b      	ldr	r3, [r3, #4]
 8001008:	4a60      	ldr	r2, [pc, #384]	@ (800118c <sixthMessageSender+0x1e8>)
 800100a:	6053      	str	r3, [r2, #4]
	memcpy(sixthMessage.Tid_two, fifthMessage.Tid_two, 4);
 800100c:	4b5e      	ldr	r3, [pc, #376]	@ (8001188 <sixthMessageSender+0x1e4>)
 800100e:	689b      	ldr	r3, [r3, #8]
 8001010:	4a5e      	ldr	r2, [pc, #376]	@ (800118c <sixthMessageSender+0x1e8>)
 8001012:	6093      	str	r3, [r2, #8]
	memcpy(sixthMessage.Tid_three, fifthMessage.Tid_three, 4);
 8001014:	4b5c      	ldr	r3, [pc, #368]	@ (8001188 <sixthMessageSender+0x1e4>)
 8001016:	68db      	ldr	r3, [r3, #12]
 8001018:	4a5c      	ldr	r2, [pc, #368]	@ (800118c <sixthMessageSender+0x1e8>)
 800101a:	60d3      	str	r3, [r2, #12]
	memcpy(sixthMessage.PC_id, fifthMessage.PC_id, 8);
 800101c:	4b5b      	ldr	r3, [pc, #364]	@ (800118c <sixthMessageSender+0x1e8>)
 800101e:	4a5a      	ldr	r2, [pc, #360]	@ (8001188 <sixthMessageSender+0x1e4>)
 8001020:	3310      	adds	r3, #16
 8001022:	3210      	adds	r2, #16
 8001024:	e892 0003 	ldmia.w	r2, {r0, r1}
 8001028:	e883 0003 	stmia.w	r3, {r0, r1}

	// treba este vlozit druhu cast hlavneho kluca, na tu vsak potrebujeme interakciu s tlacidlom na tokene
	GPIO_InitTypeDef gpioLed = {0};
 800102c:	f507 63ac 	add.w	r3, r7, #1376	@ 0x560
 8001030:	2200      	movs	r2, #0
 8001032:	601a      	str	r2, [r3, #0]
 8001034:	605a      	str	r2, [r3, #4]
 8001036:	609a      	str	r2, [r3, #8]
 8001038:	60da      	str	r2, [r3, #12]
 800103a:	611a      	str	r2, [r3, #16]
	gpioLed.Pin = GPIO_PIN_12;
 800103c:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8001040:	f8c7 3560 	str.w	r3, [r7, #1376]	@ 0x560
	gpioLed.Mode = GPIO_MODE_OUTPUT_PP;
 8001044:	2301      	movs	r3, #1
 8001046:	f8c7 3564 	str.w	r3, [r7, #1380]	@ 0x564
	gpioLed.Pull = GPIO_NOPULL;
 800104a:	2300      	movs	r3, #0
 800104c:	f8c7 3568 	str.w	r3, [r7, #1384]	@ 0x568
	gpioLed.Speed = GPIO_SPEED_FREQ_LOW;
 8001050:	2300      	movs	r3, #0
 8001052:	f8c7 356c 	str.w	r3, [r7, #1388]	@ 0x56c
	HAL_GPIO_Init(GPIOD, &gpioLed);
 8001056:	f507 63ac 	add.w	r3, r7, #1376	@ 0x560
 800105a:	4619      	mov	r1, r3
 800105c:	484c      	ldr	r0, [pc, #304]	@ (8001190 <sixthMessageSender+0x1ec>)
 800105e:	f000 ffff 	bl	8002060 <HAL_GPIO_Init>

	GPIO_InitTypeDef gpioBtn = {0};
 8001062:	f207 534c 	addw	r3, r7, #1356	@ 0x54c
 8001066:	2200      	movs	r2, #0
 8001068:	601a      	str	r2, [r3, #0]
 800106a:	605a      	str	r2, [r3, #4]
 800106c:	609a      	str	r2, [r3, #8]
 800106e:	60da      	str	r2, [r3, #12]
 8001070:	611a      	str	r2, [r3, #16]
	gpioBtn.Pin = GPIO_PIN_0;
 8001072:	2301      	movs	r3, #1
 8001074:	f8c7 354c 	str.w	r3, [r7, #1356]	@ 0x54c
	gpioBtn.Mode = GPIO_MODE_INPUT;
 8001078:	2300      	movs	r3, #0
 800107a:	f8c7 3550 	str.w	r3, [r7, #1360]	@ 0x550
	gpioBtn.Pull = GPIO_NOPULL;
 800107e:	2300      	movs	r3, #0
 8001080:	f8c7 3554 	str.w	r3, [r7, #1364]	@ 0x554
	HAL_GPIO_Init(GPIOA, &gpioBtn);
 8001084:	f207 534c 	addw	r3, r7, #1356	@ 0x54c
 8001088:	4619      	mov	r1, r3
 800108a:	4842      	ldr	r0, [pc, #264]	@ (8001194 <sixthMessageSender+0x1f0>)
 800108c:	f000 ffe8 	bl	8002060 <HAL_GPIO_Init>

	HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_SET);
 8001090:	2201      	movs	r2, #1
 8001092:	f44f 5180 	mov.w	r1, #4096	@ 0x1000
 8001096:	483e      	ldr	r0, [pc, #248]	@ (8001190 <sixthMessageSender+0x1ec>)
 8001098:	f001 f996 	bl	80023c8 <HAL_GPIO_WritePin>
	while (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) == GPIO_PIN_RESET) {
 800109c:	bf00      	nop
 800109e:	2101      	movs	r1, #1
 80010a0:	483c      	ldr	r0, [pc, #240]	@ (8001194 <sixthMessageSender+0x1f0>)
 80010a2:	f001 f979 	bl	8002398 <HAL_GPIO_ReadPin>
 80010a6:	4603      	mov	r3, r0
 80010a8:	2b00      	cmp	r3, #0
 80010aa:	d0f8      	beq.n	800109e <sixthMessageSender+0xfa>
	    // cakame kym sa stlaci tlacidlo
	}
	const char *predefinedHash = "3d9cf246585e2e116a9a4407ebd7d8dffea0dfa934a515dbe5cd6657aac7c222";
 80010ac:	4b3a      	ldr	r3, [pc, #232]	@ (8001198 <sixthMessageSender+0x1f4>)
 80010ae:	f8c7 3578 	str.w	r3, [r7, #1400]	@ 0x578
	memcpy(sixthMessage.key, predefinedHash, 64);
 80010b2:	4b36      	ldr	r3, [pc, #216]	@ (800118c <sixthMessageSender+0x1e8>)
 80010b4:	f8d7 2578 	ldr.w	r2, [r7, #1400]	@ 0x578
 80010b8:	4614      	mov	r4, r2
 80010ba:	f103 0618 	add.w	r6, r3, #24
 80010be:	f104 0c40 	add.w	ip, r4, #64	@ 0x40
 80010c2:	4635      	mov	r5, r6
 80010c4:	4623      	mov	r3, r4
 80010c6:	6818      	ldr	r0, [r3, #0]
 80010c8:	6859      	ldr	r1, [r3, #4]
 80010ca:	689a      	ldr	r2, [r3, #8]
 80010cc:	68db      	ldr	r3, [r3, #12]
 80010ce:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80010d0:	3410      	adds	r4, #16
 80010d2:	3610      	adds	r6, #16
 80010d4:	4564      	cmp	r4, ip
 80010d6:	d1f4      	bne.n	80010c2 <sixthMessageSender+0x11e>
	HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_RESET);
 80010d8:	2200      	movs	r2, #0
 80010da:	f44f 5180 	mov.w	r1, #4096	@ 0x1000
 80010de:	482c      	ldr	r0, [pc, #176]	@ (8001190 <sixthMessageSender+0x1ec>)
 80010e0:	f001 f972 	bl	80023c8 <HAL_GPIO_WritePin>

	// nasledne zasifrujme celu spravu cez sessionKey
	unsigned char paddedPlaintext[512] = {0};
 80010e4:	f507 63b0 	add.w	r3, r7, #1408	@ 0x580
 80010e8:	f5a3 730d 	sub.w	r3, r3, #564	@ 0x234
 80010ec:	4618      	mov	r0, r3
 80010ee:	f44f 7300 	mov.w	r3, #512	@ 0x200
 80010f2:	461a      	mov	r2, r3
 80010f4:	2100      	movs	r1, #0
 80010f6:	f027 f9e7 	bl	80284c8 <memset>
	memcpy(paddedPlaintext, &sixthMessage, sizeof(sixthMessage));
 80010fa:	f507 63b0 	add.w	r3, r7, #1408	@ 0x580
 80010fe:	f5a3 730d 	sub.w	r3, r3, #564	@ 0x234
 8001102:	4a22      	ldr	r2, [pc, #136]	@ (800118c <sixthMessageSender+0x1e8>)
 8001104:	4618      	mov	r0, r3
 8001106:	4611      	mov	r1, r2
 8001108:	2358      	movs	r3, #88	@ 0x58
 800110a:	461a      	mov	r2, r3
 800110c:	f027 fa46 	bl	802859c <memcpy>
	Aes aes;
	int aesRet = wc_AesSetKey(&aes, thirdMessage.session_key, 16, thirdMessage.session_IV, AES_ENCRYPTION);
 8001110:	f507 7000 	add.w	r0, r7, #512	@ 0x200
 8001114:	2300      	movs	r3, #0
 8001116:	9300      	str	r3, [sp, #0]
 8001118:	4b20      	ldr	r3, [pc, #128]	@ (800119c <sixthMessageSender+0x1f8>)
 800111a:	2210      	movs	r2, #16
 800111c:	4920      	ldr	r1, [pc, #128]	@ (80011a0 <sixthMessageSender+0x1fc>)
 800111e:	f011 f9a1 	bl	8012464 <wc_AesSetKey>
 8001122:	f8c7 0574 	str.w	r0, [r7, #1396]	@ 0x574
	if (aesRet != 0) {
 8001126:	f8d7 3574 	ldr.w	r3, [r7, #1396]	@ 0x574
 800112a:	2b00      	cmp	r3, #0
 800112c:	d124      	bne.n	8001178 <sixthMessageSender+0x1d4>
		return;
	}
	uint8_t encryptedPayload[512];
	aesRet = wc_AesCbcEncrypt(&aes, encryptedPayload, paddedPlaintext, 512);
 800112e:	f507 7253 	add.w	r2, r7, #844	@ 0x34c
 8001132:	4639      	mov	r1, r7
 8001134:	f507 7000 	add.w	r0, r7, #512	@ 0x200
 8001138:	f44f 7300 	mov.w	r3, #512	@ 0x200
 800113c:	f011 f9d6 	bl	80124ec <wc_AesCbcEncrypt>
 8001140:	f8c7 0574 	str.w	r0, [r7, #1396]	@ 0x574
	if (aesRet != 0) {
 8001144:	f8d7 3574 	ldr.w	r3, [r7, #1396]	@ 0x574
 8001148:	2b00      	cmp	r3, #0
 800114a:	d117      	bne.n	800117c <sixthMessageSender+0x1d8>
		return;
	}

	// a potom vlozme ju do sendBuffer na odoslanie
	memcpy(sendBuffer, encryptedPayload, 512);
 800114c:	4a15      	ldr	r2, [pc, #84]	@ (80011a4 <sixthMessageSender+0x200>)
 800114e:	f507 63b0 	add.w	r3, r7, #1408	@ 0x580
 8001152:	f5a3 63b0 	sub.w	r3, r3, #1408	@ 0x580
 8001156:	4610      	mov	r0, r2
 8001158:	4619      	mov	r1, r3
 800115a:	f44f 7300 	mov.w	r3, #512	@ 0x200
 800115e:	461a      	mov	r2, r3
 8001160:	f027 fa1c 	bl	802859c <memcpy>
	sendCounter = 512;
 8001164:	4b10      	ldr	r3, [pc, #64]	@ (80011a8 <sixthMessageSender+0x204>)
 8001166:	f44f 7200 	mov.w	r2, #512	@ 0x200
 800116a:	801a      	strh	r2, [r3, #0]
	wc_AesFree(&aes);
 800116c:	f507 7300 	add.w	r3, r7, #512	@ 0x200
 8001170:	4618      	mov	r0, r3
 8001172:	f011 fa7d 	bl	8012670 <wc_AesFree>
	return;
 8001176:	e002      	b.n	800117e <sixthMessageSender+0x1da>
		return;
 8001178:	bf00      	nop
 800117a:	e000      	b.n	800117e <sixthMessageSender+0x1da>
		return;
 800117c:	bf00      	nop
}
 800117e:	f207 5784 	addw	r7, r7, #1412	@ 0x584
 8001182:	46bd      	mov	sp, r7
 8001184:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001186:	bf00      	nop
 8001188:	2000137c 	.word	0x2000137c
 800118c:	200013a4 	.word	0x200013a4
 8001190:	40020c00 	.word	0x40020c00
 8001194:	40020000 	.word	0x40020000
 8001198:	08028c3c 	.word	0x08028c3c
 800119c:	20001330 	.word	0x20001330
 80011a0:	20001320 	.word	0x20001320
 80011a4:	20001ed4 	.word	0x20001ed4
 80011a8:	20002898 	.word	0x20002898

080011ac <transmitBuffer>:
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

void transmitBuffer(uint8_t *data, uint16_t length) {
 80011ac:	b580      	push	{r7, lr}
 80011ae:	b084      	sub	sp, #16
 80011b0:	af00      	add	r7, sp, #0
 80011b2:	6078      	str	r0, [r7, #4]
 80011b4:	460b      	mov	r3, r1
 80011b6:	807b      	strh	r3, [r7, #2]
	// cely sendBuffer sa rozkuskuje na 64 bytove pakety ktore CDC_Transmit_FS vie preniest seriovo
	// Middlewares/ST/STM32_USB_Device_Library/Core/Inc/usbd_def.h
	// riadok 156 - #define USB_FS_MAX_PACKET_SIZE 64U - paket ma max velkost 64 bytov na transmit
    uint16_t sent = 0;
 80011b8:	2300      	movs	r3, #0
 80011ba:	81fb      	strh	r3, [r7, #14]
    while (sent < length) {
 80011bc:	e016      	b.n	80011ec <transmitBuffer+0x40>
    	uint16_t chunk = (length - sent > 64) ? 64 : (length - sent);
 80011be:	887a      	ldrh	r2, [r7, #2]
 80011c0:	89fb      	ldrh	r3, [r7, #14]
 80011c2:	1ad3      	subs	r3, r2, r3
 80011c4:	2b40      	cmp	r3, #64	@ 0x40
 80011c6:	bfa8      	it	ge
 80011c8:	2340      	movge	r3, #64	@ 0x40
 80011ca:	81bb      	strh	r3, [r7, #12]
    	while (CDC_Transmit_FS(data + sent, chunk) == USBD_BUSY) {
 80011cc:	bf00      	nop
 80011ce:	89fb      	ldrh	r3, [r7, #14]
 80011d0:	687a      	ldr	r2, [r7, #4]
 80011d2:	4413      	add	r3, r2
 80011d4:	89ba      	ldrh	r2, [r7, #12]
 80011d6:	4611      	mov	r1, r2
 80011d8:	4618      	mov	r0, r3
 80011da:	f026 fbbf 	bl	802795c <CDC_Transmit_FS>
 80011de:	4603      	mov	r3, r0
 80011e0:	2b01      	cmp	r3, #1
 80011e2:	d0f4      	beq.n	80011ce <transmitBuffer+0x22>
    		// cakame kym sa skonci prenos paketu
    	}
    	sent += chunk;
 80011e4:	89fa      	ldrh	r2, [r7, #14]
 80011e6:	89bb      	ldrh	r3, [r7, #12]
 80011e8:	4413      	add	r3, r2
 80011ea:	81fb      	strh	r3, [r7, #14]
    while (sent < length) {
 80011ec:	89fa      	ldrh	r2, [r7, #14]
 80011ee:	887b      	ldrh	r3, [r7, #2]
 80011f0:	429a      	cmp	r2, r3
 80011f2:	d3e4      	bcc.n	80011be <transmitBuffer+0x12>
    }
}
 80011f4:	bf00      	nop
 80011f6:	bf00      	nop
 80011f8:	3710      	adds	r7, #16
 80011fa:	46bd      	mov	sp, r7
 80011fc:	bd80      	pop	{r7, pc}
	...

08001200 <USBReceiveHandler>:

void USBReceiveHandler() {
 8001200:	b580      	push	{r7, lr}
 8001202:	b08a      	sub	sp, #40	@ 0x28
 8001204:	af02      	add	r7, sp, #8
	if (messageCounter == 1) {
 8001206:	4b54      	ldr	r3, [pc, #336]	@ (8001358 <USBReceiveHandler+0x158>)
 8001208:	781b      	ldrb	r3, [r3, #0]
 800120a:	2b01      	cmp	r3, #1
 800120c:	d112      	bne.n	8001234 <USBReceiveHandler+0x34>
		uint8_t* receivedChars = malloc(4);
 800120e:	2004      	movs	r0, #4
 8001210:	f027 f80e 	bl	8028230 <malloc>
 8001214:	4603      	mov	r3, r0
 8001216:	603b      	str	r3, [r7, #0]
		memcpy(receivedChars, &receiveBuffer[0], 4);
 8001218:	4b50      	ldr	r3, [pc, #320]	@ (800135c <USBReceiveHandler+0x15c>)
 800121a:	681a      	ldr	r2, [r3, #0]
 800121c:	683b      	ldr	r3, [r7, #0]
 800121e:	601a      	str	r2, [r3, #0]
		firstMessageHandler(receivedChars);
 8001220:	6838      	ldr	r0, [r7, #0]
 8001222:	f7ff f9d3 	bl	80005cc <firstMessageHandler>
		free(receivedChars);
 8001226:	6838      	ldr	r0, [r7, #0]
 8001228:	f027 f80a 	bl	8028240 <free>
		messageCounter = 3;
 800122c:	4b4a      	ldr	r3, [pc, #296]	@ (8001358 <USBReceiveHandler+0x158>)
 800122e:	2203      	movs	r2, #3
 8001230:	701a      	strb	r2, [r3, #0]
 8001232:	e075      	b.n	8001320 <USBReceiveHandler+0x120>
	} else if (messageCounter == 3) {
 8001234:	4b48      	ldr	r3, [pc, #288]	@ (8001358 <USBReceiveHandler+0x158>)
 8001236:	781b      	ldrb	r3, [r3, #0]
 8001238:	2b03      	cmp	r3, #3
 800123a:	d14c      	bne.n	80012d6 <USBReceiveHandler+0xd6>
		uint8_t* encryptedKey = malloc(256);
 800123c:	f44f 7080 	mov.w	r0, #256	@ 0x100
 8001240:	f026 fff6 	bl	8028230 <malloc>
 8001244:	4603      	mov	r3, r0
 8001246:	617b      	str	r3, [r7, #20]
		uint8_t* encryptedIV = malloc(256);
 8001248:	f44f 7080 	mov.w	r0, #256	@ 0x100
 800124c:	f026 fff0 	bl	8028230 <malloc>
 8001250:	4603      	mov	r3, r0
 8001252:	613b      	str	r3, [r7, #16]
		uint8_t* payload = malloc(512);
 8001254:	f44f 7000 	mov.w	r0, #512	@ 0x200
 8001258:	f026 ffea 	bl	8028230 <malloc>
 800125c:	4603      	mov	r3, r0
 800125e:	60fb      	str	r3, [r7, #12]
		uint16_t deviceCertLen = receiveCounter - 1024;
 8001260:	4b3f      	ldr	r3, [pc, #252]	@ (8001360 <USBReceiveHandler+0x160>)
 8001262:	881b      	ldrh	r3, [r3, #0]
 8001264:	f5a3 6380 	sub.w	r3, r3, #1024	@ 0x400
 8001268:	817b      	strh	r3, [r7, #10]
		uint8_t* deviceCertBuffer = malloc(deviceCertLen);
 800126a:	897b      	ldrh	r3, [r7, #10]
 800126c:	4618      	mov	r0, r3
 800126e:	f026 ffdf 	bl	8028230 <malloc>
 8001272:	4603      	mov	r3, r0
 8001274:	607b      	str	r3, [r7, #4]
		memcpy(encryptedKey, &receiveBuffer[0], 256);
 8001276:	f44f 7280 	mov.w	r2, #256	@ 0x100
 800127a:	4938      	ldr	r1, [pc, #224]	@ (800135c <USBReceiveHandler+0x15c>)
 800127c:	6978      	ldr	r0, [r7, #20]
 800127e:	f027 f98d 	bl	802859c <memcpy>
		memcpy(encryptedIV, &receiveBuffer[256], 256);
 8001282:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8001286:	4937      	ldr	r1, [pc, #220]	@ (8001364 <USBReceiveHandler+0x164>)
 8001288:	6938      	ldr	r0, [r7, #16]
 800128a:	f027 f987 	bl	802859c <memcpy>
		memcpy(payload, &receiveBuffer[512], 512);
 800128e:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8001292:	4935      	ldr	r1, [pc, #212]	@ (8001368 <USBReceiveHandler+0x168>)
 8001294:	68f8      	ldr	r0, [r7, #12]
 8001296:	f027 f981 	bl	802859c <memcpy>
		memcpy(deviceCertBuffer, &receiveBuffer[1024], deviceCertLen);
 800129a:	897b      	ldrh	r3, [r7, #10]
 800129c:	461a      	mov	r2, r3
 800129e:	4933      	ldr	r1, [pc, #204]	@ (800136c <USBReceiveHandler+0x16c>)
 80012a0:	6878      	ldr	r0, [r7, #4]
 80012a2:	f027 f97b 	bl	802859c <memcpy>
		thirdMessageHandler(encryptedKey, encryptedIV, payload, deviceCertBuffer, deviceCertLen);
 80012a6:	897b      	ldrh	r3, [r7, #10]
 80012a8:	9300      	str	r3, [sp, #0]
 80012aa:	687b      	ldr	r3, [r7, #4]
 80012ac:	68fa      	ldr	r2, [r7, #12]
 80012ae:	6939      	ldr	r1, [r7, #16]
 80012b0:	6978      	ldr	r0, [r7, #20]
 80012b2:	f7ff fa5d 	bl	8000770 <thirdMessageHandler>
		free(encryptedKey);
 80012b6:	6978      	ldr	r0, [r7, #20]
 80012b8:	f026 ffc2 	bl	8028240 <free>
		free(encryptedIV);
 80012bc:	6938      	ldr	r0, [r7, #16]
 80012be:	f026 ffbf 	bl	8028240 <free>
		free(payload);
 80012c2:	68f8      	ldr	r0, [r7, #12]
 80012c4:	f026 ffbc 	bl	8028240 <free>
		free(deviceCertBuffer);
 80012c8:	6878      	ldr	r0, [r7, #4]
 80012ca:	f026 ffb9 	bl	8028240 <free>
		messageCounter = 5;
 80012ce:	4b22      	ldr	r3, [pc, #136]	@ (8001358 <USBReceiveHandler+0x158>)
 80012d0:	2205      	movs	r2, #5
 80012d2:	701a      	strb	r2, [r3, #0]
 80012d4:	e024      	b.n	8001320 <USBReceiveHandler+0x120>
	} else {
		uint8_t* payload = malloc(512);
 80012d6:	f44f 7000 	mov.w	r0, #512	@ 0x200
 80012da:	f026 ffa9 	bl	8028230 <malloc>
 80012de:	4603      	mov	r3, r0
 80012e0:	61fb      	str	r3, [r7, #28]
		uint8_t* sigHash = malloc(256);
 80012e2:	f44f 7080 	mov.w	r0, #256	@ 0x100
 80012e6:	f026 ffa3 	bl	8028230 <malloc>
 80012ea:	4603      	mov	r3, r0
 80012ec:	61bb      	str	r3, [r7, #24]
		memcpy(payload, &receiveBuffer[0], 512);
 80012ee:	f44f 7200 	mov.w	r2, #512	@ 0x200
 80012f2:	491a      	ldr	r1, [pc, #104]	@ (800135c <USBReceiveHandler+0x15c>)
 80012f4:	69f8      	ldr	r0, [r7, #28]
 80012f6:	f027 f951 	bl	802859c <memcpy>
		memcpy(sigHash, &receiveBuffer[512], 256);
 80012fa:	f44f 7280 	mov.w	r2, #256	@ 0x100
 80012fe:	491a      	ldr	r1, [pc, #104]	@ (8001368 <USBReceiveHandler+0x168>)
 8001300:	69b8      	ldr	r0, [r7, #24]
 8001302:	f027 f94b 	bl	802859c <memcpy>
		fifthMessageHandler(payload, sigHash);
 8001306:	69b9      	ldr	r1, [r7, #24]
 8001308:	69f8      	ldr	r0, [r7, #28]
 800130a:	f7ff fd57 	bl	8000dbc <fifthMessageHandler>
		free(payload);
 800130e:	69f8      	ldr	r0, [r7, #28]
 8001310:	f026 ff96 	bl	8028240 <free>
		free(sigHash);
 8001314:	69b8      	ldr	r0, [r7, #24]
 8001316:	f026 ff93 	bl	8028240 <free>
		messageCounter = 1;
 800131a:	4b0f      	ldr	r3, [pc, #60]	@ (8001358 <USBReceiveHandler+0x158>)
 800131c:	2201      	movs	r2, #1
 800131e:	701a      	strb	r2, [r3, #0]
	}
	receiveCounter = 0;
 8001320:	4b0f      	ldr	r3, [pc, #60]	@ (8001360 <USBReceiveHandler+0x160>)
 8001322:	2200      	movs	r2, #0
 8001324:	801a      	strh	r2, [r3, #0]
	memset(&receiveBuffer, 0, sizeof(receiveBuffer));
 8001326:	f640 12c4 	movw	r2, #2500	@ 0x9c4
 800132a:	2100      	movs	r1, #0
 800132c:	480b      	ldr	r0, [pc, #44]	@ (800135c <USBReceiveHandler+0x15c>)
 800132e:	f027 f8cb 	bl	80284c8 <memset>
	transmitBuffer(sendBuffer, sendCounter);
 8001332:	4b0f      	ldr	r3, [pc, #60]	@ (8001370 <USBReceiveHandler+0x170>)
 8001334:	881b      	ldrh	r3, [r3, #0]
 8001336:	4619      	mov	r1, r3
 8001338:	480e      	ldr	r0, [pc, #56]	@ (8001374 <USBReceiveHandler+0x174>)
 800133a:	f7ff ff37 	bl	80011ac <transmitBuffer>
	sendCounter = 0;
 800133e:	4b0c      	ldr	r3, [pc, #48]	@ (8001370 <USBReceiveHandler+0x170>)
 8001340:	2200      	movs	r2, #0
 8001342:	801a      	strh	r2, [r3, #0]
	memset(&sendBuffer, 0, sizeof(sendBuffer));
 8001344:	f640 12c4 	movw	r2, #2500	@ 0x9c4
 8001348:	2100      	movs	r1, #0
 800134a:	480a      	ldr	r0, [pc, #40]	@ (8001374 <USBReceiveHandler+0x174>)
 800134c:	f027 f8bc 	bl	80284c8 <memset>
}
 8001350:	bf00      	nop
 8001352:	3720      	adds	r7, #32
 8001354:	46bd      	mov	sp, r7
 8001356:	bd80      	pop	{r7, pc}
 8001358:	20000014 	.word	0x20000014
 800135c:	2000150c 	.word	0x2000150c
 8001360:	20001ed0 	.word	0x20001ed0
 8001364:	2000160c 	.word	0x2000160c
 8001368:	2000170c 	.word	0x2000170c
 800136c:	2000190c 	.word	0x2000190c
 8001370:	20002898 	.word	0x20002898
 8001374:	20001ed4 	.word	0x20001ed4

08001378 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 8001378:	b580      	push	{r7, lr}
 800137a:	af00      	add	r7, sp, #0
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 800137c:	f000 fc88 	bl	8001c90 <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 8001380:	f000 f81a 	bl	80013b8 <SystemClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 8001384:	f000 f93e 	bl	8001604 <MX_GPIO_Init>
  MX_I2C1_Init();
 8001388:	f000 f894 	bl	80014b4 <MX_I2C1_Init>
  MX_I2S3_Init();
 800138c:	f000 f8c0 	bl	8001510 <MX_I2S3_Init>
  MX_SPI1_Init();
 8001390:	f000 f902 	bl	8001598 <MX_SPI1_Init>
  MX_USB_DEVICE_Init();
 8001394:	f026 f99e 	bl	80276d4 <MX_USB_DEVICE_Init>
  MX_CRC_Init();
 8001398:	f000 f878 	bl	800148c <MX_CRC_Init>
  MX_RNG_Init();
 800139c:	f000 f8e8 	bl	8001570 <MX_RNG_Init>

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
	  if (dataReceivedFlag == 1) {
 80013a0:	4b04      	ldr	r3, [pc, #16]	@ (80013b4 <main+0x3c>)
 80013a2:	781b      	ldrb	r3, [r3, #0]
 80013a4:	2b01      	cmp	r3, #1
 80013a6:	d1fb      	bne.n	80013a0 <main+0x28>
		  USBReceiveHandler();
 80013a8:	f7ff ff2a 	bl	8001200 <USBReceiveHandler>
		  dataReceivedFlag = 0;
 80013ac:	4b01      	ldr	r3, [pc, #4]	@ (80013b4 <main+0x3c>)
 80013ae:	2200      	movs	r2, #0
 80013b0:	701a      	strb	r2, [r3, #0]
	  if (dataReceivedFlag == 1) {
 80013b2:	e7f5      	b.n	80013a0 <main+0x28>
 80013b4:	20001508 	.word	0x20001508

080013b8 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 80013b8:	b580      	push	{r7, lr}
 80013ba:	b094      	sub	sp, #80	@ 0x50
 80013bc:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 80013be:	f107 0320 	add.w	r3, r7, #32
 80013c2:	2230      	movs	r2, #48	@ 0x30
 80013c4:	2100      	movs	r1, #0
 80013c6:	4618      	mov	r0, r3
 80013c8:	f027 f87e 	bl	80284c8 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 80013cc:	f107 030c 	add.w	r3, r7, #12
 80013d0:	2200      	movs	r2, #0
 80013d2:	601a      	str	r2, [r3, #0]
 80013d4:	605a      	str	r2, [r3, #4]
 80013d6:	609a      	str	r2, [r3, #8]
 80013d8:	60da      	str	r2, [r3, #12]
 80013da:	611a      	str	r2, [r3, #16]

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
 80013dc:	2300      	movs	r3, #0
 80013de:	60bb      	str	r3, [r7, #8]
 80013e0:	4b28      	ldr	r3, [pc, #160]	@ (8001484 <SystemClock_Config+0xcc>)
 80013e2:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80013e4:	4a27      	ldr	r2, [pc, #156]	@ (8001484 <SystemClock_Config+0xcc>)
 80013e6:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 80013ea:	6413      	str	r3, [r2, #64]	@ 0x40
 80013ec:	4b25      	ldr	r3, [pc, #148]	@ (8001484 <SystemClock_Config+0xcc>)
 80013ee:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80013f0:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 80013f4:	60bb      	str	r3, [r7, #8]
 80013f6:	68bb      	ldr	r3, [r7, #8]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 80013f8:	2300      	movs	r3, #0
 80013fa:	607b      	str	r3, [r7, #4]
 80013fc:	4b22      	ldr	r3, [pc, #136]	@ (8001488 <SystemClock_Config+0xd0>)
 80013fe:	681b      	ldr	r3, [r3, #0]
 8001400:	4a21      	ldr	r2, [pc, #132]	@ (8001488 <SystemClock_Config+0xd0>)
 8001402:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 8001406:	6013      	str	r3, [r2, #0]
 8001408:	4b1f      	ldr	r3, [pc, #124]	@ (8001488 <SystemClock_Config+0xd0>)
 800140a:	681b      	ldr	r3, [r3, #0]
 800140c:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 8001410:	607b      	str	r3, [r7, #4]
 8001412:	687b      	ldr	r3, [r7, #4]

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8001414:	2301      	movs	r3, #1
 8001416:	623b      	str	r3, [r7, #32]
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8001418:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 800141c:	627b      	str	r3, [r7, #36]	@ 0x24
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 800141e:	2302      	movs	r3, #2
 8001420:	63bb      	str	r3, [r7, #56]	@ 0x38
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8001422:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
 8001426:	63fb      	str	r3, [r7, #60]	@ 0x3c
  RCC_OscInitStruct.PLL.PLLM = 8;
 8001428:	2308      	movs	r3, #8
 800142a:	643b      	str	r3, [r7, #64]	@ 0x40
  RCC_OscInitStruct.PLL.PLLN = 336;
 800142c:	f44f 73a8 	mov.w	r3, #336	@ 0x150
 8001430:	647b      	str	r3, [r7, #68]	@ 0x44
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 8001432:	2302      	movs	r3, #2
 8001434:	64bb      	str	r3, [r7, #72]	@ 0x48
  RCC_OscInitStruct.PLL.PLLQ = 7;
 8001436:	2307      	movs	r3, #7
 8001438:	64fb      	str	r3, [r7, #76]	@ 0x4c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800143a:	f107 0320 	add.w	r3, r7, #32
 800143e:	4618      	mov	r0, r3
 8001440:	f003 f812 	bl	8004468 <HAL_RCC_OscConfig>
 8001444:	4603      	mov	r3, r0
 8001446:	2b00      	cmp	r3, #0
 8001448:	d001      	beq.n	800144e <SystemClock_Config+0x96>
  {
    Error_Handler();
 800144a:	f000 f9d9 	bl	8001800 <Error_Handler>
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 800144e:	230f      	movs	r3, #15
 8001450:	60fb      	str	r3, [r7, #12]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8001452:	2302      	movs	r3, #2
 8001454:	613b      	str	r3, [r7, #16]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8001456:	2300      	movs	r3, #0
 8001458:	617b      	str	r3, [r7, #20]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 800145a:	f44f 53a0 	mov.w	r3, #5120	@ 0x1400
 800145e:	61bb      	str	r3, [r7, #24]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 8001460:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8001464:	61fb      	str	r3, [r7, #28]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 8001466:	f107 030c 	add.w	r3, r7, #12
 800146a:	2105      	movs	r1, #5
 800146c:	4618      	mov	r0, r3
 800146e:	f003 fa73 	bl	8004958 <HAL_RCC_ClockConfig>
 8001472:	4603      	mov	r3, r0
 8001474:	2b00      	cmp	r3, #0
 8001476:	d001      	beq.n	800147c <SystemClock_Config+0xc4>
  {
    Error_Handler();
 8001478:	f000 f9c2 	bl	8001800 <Error_Handler>
  }
}
 800147c:	bf00      	nop
 800147e:	3750      	adds	r7, #80	@ 0x50
 8001480:	46bd      	mov	sp, r7
 8001482:	bd80      	pop	{r7, pc}
 8001484:	40023800 	.word	0x40023800
 8001488:	40007000 	.word	0x40007000

0800148c <MX_CRC_Init>:
  * @brief CRC Initialization Function
  * @param None
  * @retval None
  */
static void MX_CRC_Init(void)
{
 800148c:	b580      	push	{r7, lr}
 800148e:	af00      	add	r7, sp, #0
  /* USER CODE END CRC_Init 0 */

  /* USER CODE BEGIN CRC_Init 1 */

  /* USER CODE END CRC_Init 1 */
  hcrc.Instance = CRC;
 8001490:	4b06      	ldr	r3, [pc, #24]	@ (80014ac <MX_CRC_Init+0x20>)
 8001492:	4a07      	ldr	r2, [pc, #28]	@ (80014b0 <MX_CRC_Init+0x24>)
 8001494:	601a      	str	r2, [r3, #0]
  if (HAL_CRC_Init(&hcrc) != HAL_OK)
 8001496:	4805      	ldr	r0, [pc, #20]	@ (80014ac <MX_CRC_Init+0x20>)
 8001498:	f000 fdc5 	bl	8002026 <HAL_CRC_Init>
 800149c:	4603      	mov	r3, r0
 800149e:	2b00      	cmp	r3, #0
 80014a0:	d001      	beq.n	80014a6 <MX_CRC_Init+0x1a>
  {
    Error_Handler();
 80014a2:	f000 f9ad 	bl	8001800 <Error_Handler>
  }
  /* USER CODE BEGIN CRC_Init 2 */

  /* USER CODE END CRC_Init 2 */

}
 80014a6:	bf00      	nop
 80014a8:	bd80      	pop	{r7, pc}
 80014aa:	bf00      	nop
 80014ac:	200013fc 	.word	0x200013fc
 80014b0:	40023000 	.word	0x40023000

080014b4 <MX_I2C1_Init>:
  * @brief I2C1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C1_Init(void)
{
 80014b4:	b580      	push	{r7, lr}
 80014b6:	af00      	add	r7, sp, #0
  /* USER CODE END I2C1_Init 0 */

  /* USER CODE BEGIN I2C1_Init 1 */

  /* USER CODE END I2C1_Init 1 */
  hi2c1.Instance = I2C1;
 80014b8:	4b12      	ldr	r3, [pc, #72]	@ (8001504 <MX_I2C1_Init+0x50>)
 80014ba:	4a13      	ldr	r2, [pc, #76]	@ (8001508 <MX_I2C1_Init+0x54>)
 80014bc:	601a      	str	r2, [r3, #0]
  hi2c1.Init.ClockSpeed = 100000;
 80014be:	4b11      	ldr	r3, [pc, #68]	@ (8001504 <MX_I2C1_Init+0x50>)
 80014c0:	4a12      	ldr	r2, [pc, #72]	@ (800150c <MX_I2C1_Init+0x58>)
 80014c2:	605a      	str	r2, [r3, #4]
  hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
 80014c4:	4b0f      	ldr	r3, [pc, #60]	@ (8001504 <MX_I2C1_Init+0x50>)
 80014c6:	2200      	movs	r2, #0
 80014c8:	609a      	str	r2, [r3, #8]
  hi2c1.Init.OwnAddress1 = 0;
 80014ca:	4b0e      	ldr	r3, [pc, #56]	@ (8001504 <MX_I2C1_Init+0x50>)
 80014cc:	2200      	movs	r2, #0
 80014ce:	60da      	str	r2, [r3, #12]
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 80014d0:	4b0c      	ldr	r3, [pc, #48]	@ (8001504 <MX_I2C1_Init+0x50>)
 80014d2:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
 80014d6:	611a      	str	r2, [r3, #16]
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 80014d8:	4b0a      	ldr	r3, [pc, #40]	@ (8001504 <MX_I2C1_Init+0x50>)
 80014da:	2200      	movs	r2, #0
 80014dc:	615a      	str	r2, [r3, #20]
  hi2c1.Init.OwnAddress2 = 0;
 80014de:	4b09      	ldr	r3, [pc, #36]	@ (8001504 <MX_I2C1_Init+0x50>)
 80014e0:	2200      	movs	r2, #0
 80014e2:	619a      	str	r2, [r3, #24]
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 80014e4:	4b07      	ldr	r3, [pc, #28]	@ (8001504 <MX_I2C1_Init+0x50>)
 80014e6:	2200      	movs	r2, #0
 80014e8:	61da      	str	r2, [r3, #28]
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 80014ea:	4b06      	ldr	r3, [pc, #24]	@ (8001504 <MX_I2C1_Init+0x50>)
 80014ec:	2200      	movs	r2, #0
 80014ee:	621a      	str	r2, [r3, #32]
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
 80014f0:	4804      	ldr	r0, [pc, #16]	@ (8001504 <MX_I2C1_Init+0x50>)
 80014f2:	f000 ff83 	bl	80023fc <HAL_I2C_Init>
 80014f6:	4603      	mov	r3, r0
 80014f8:	2b00      	cmp	r3, #0
 80014fa:	d001      	beq.n	8001500 <MX_I2C1_Init+0x4c>
  {
    Error_Handler();
 80014fc:	f000 f980 	bl	8001800 <Error_Handler>
  }
  /* USER CODE BEGIN I2C1_Init 2 */

  /* USER CODE END I2C1_Init 2 */

}
 8001500:	bf00      	nop
 8001502:	bd80      	pop	{r7, pc}
 8001504:	20001404 	.word	0x20001404
 8001508:	40005400 	.word	0x40005400
 800150c:	000186a0 	.word	0x000186a0

08001510 <MX_I2S3_Init>:
  * @brief I2S3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2S3_Init(void)
{
 8001510:	b580      	push	{r7, lr}
 8001512:	af00      	add	r7, sp, #0
  /* USER CODE END I2S3_Init 0 */

  /* USER CODE BEGIN I2S3_Init 1 */

  /* USER CODE END I2S3_Init 1 */
  hi2s3.Instance = SPI3;
 8001514:	4b13      	ldr	r3, [pc, #76]	@ (8001564 <MX_I2S3_Init+0x54>)
 8001516:	4a14      	ldr	r2, [pc, #80]	@ (8001568 <MX_I2S3_Init+0x58>)
 8001518:	601a      	str	r2, [r3, #0]
  hi2s3.Init.Mode = I2S_MODE_MASTER_TX;
 800151a:	4b12      	ldr	r3, [pc, #72]	@ (8001564 <MX_I2S3_Init+0x54>)
 800151c:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8001520:	605a      	str	r2, [r3, #4]
  hi2s3.Init.Standard = I2S_STANDARD_PHILIPS;
 8001522:	4b10      	ldr	r3, [pc, #64]	@ (8001564 <MX_I2S3_Init+0x54>)
 8001524:	2200      	movs	r2, #0
 8001526:	609a      	str	r2, [r3, #8]
  hi2s3.Init.DataFormat = I2S_DATAFORMAT_16B;
 8001528:	4b0e      	ldr	r3, [pc, #56]	@ (8001564 <MX_I2S3_Init+0x54>)
 800152a:	2200      	movs	r2, #0
 800152c:	60da      	str	r2, [r3, #12]
  hi2s3.Init.MCLKOutput = I2S_MCLKOUTPUT_ENABLE;
 800152e:	4b0d      	ldr	r3, [pc, #52]	@ (8001564 <MX_I2S3_Init+0x54>)
 8001530:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8001534:	611a      	str	r2, [r3, #16]
  hi2s3.Init.AudioFreq = I2S_AUDIOFREQ_96K;
 8001536:	4b0b      	ldr	r3, [pc, #44]	@ (8001564 <MX_I2S3_Init+0x54>)
 8001538:	4a0c      	ldr	r2, [pc, #48]	@ (800156c <MX_I2S3_Init+0x5c>)
 800153a:	615a      	str	r2, [r3, #20]
  hi2s3.Init.CPOL = I2S_CPOL_LOW;
 800153c:	4b09      	ldr	r3, [pc, #36]	@ (8001564 <MX_I2S3_Init+0x54>)
 800153e:	2200      	movs	r2, #0
 8001540:	619a      	str	r2, [r3, #24]
  hi2s3.Init.ClockSource = I2S_CLOCK_PLL;
 8001542:	4b08      	ldr	r3, [pc, #32]	@ (8001564 <MX_I2S3_Init+0x54>)
 8001544:	2200      	movs	r2, #0
 8001546:	61da      	str	r2, [r3, #28]
  hi2s3.Init.FullDuplexMode = I2S_FULLDUPLEXMODE_DISABLE;
 8001548:	4b06      	ldr	r3, [pc, #24]	@ (8001564 <MX_I2S3_Init+0x54>)
 800154a:	2200      	movs	r2, #0
 800154c:	621a      	str	r2, [r3, #32]
  if (HAL_I2S_Init(&hi2s3) != HAL_OK)
 800154e:	4805      	ldr	r0, [pc, #20]	@ (8001564 <MX_I2S3_Init+0x54>)
 8001550:	f001 f898 	bl	8002684 <HAL_I2S_Init>
 8001554:	4603      	mov	r3, r0
 8001556:	2b00      	cmp	r3, #0
 8001558:	d001      	beq.n	800155e <MX_I2S3_Init+0x4e>
  {
    Error_Handler();
 800155a:	f000 f951 	bl	8001800 <Error_Handler>
  }
  /* USER CODE BEGIN I2S3_Init 2 */

  /* USER CODE END I2S3_Init 2 */

}
 800155e:	bf00      	nop
 8001560:	bd80      	pop	{r7, pc}
 8001562:	bf00      	nop
 8001564:	20001458 	.word	0x20001458
 8001568:	40003c00 	.word	0x40003c00
 800156c:	00017700 	.word	0x00017700

08001570 <MX_RNG_Init>:
  * @brief RNG Initialization Function
  * @param None
  * @retval None
  */
static void MX_RNG_Init(void)
{
 8001570:	b580      	push	{r7, lr}
 8001572:	af00      	add	r7, sp, #0
  /* USER CODE END RNG_Init 0 */

  /* USER CODE BEGIN RNG_Init 1 */

  /* USER CODE END RNG_Init 1 */
  hrng.Instance = RNG;
 8001574:	4b06      	ldr	r3, [pc, #24]	@ (8001590 <MX_RNG_Init+0x20>)
 8001576:	4a07      	ldr	r2, [pc, #28]	@ (8001594 <MX_RNG_Init+0x24>)
 8001578:	601a      	str	r2, [r3, #0]
  if (HAL_RNG_Init(&hrng) != HAL_OK)
 800157a:	4805      	ldr	r0, [pc, #20]	@ (8001590 <MX_RNG_Init+0x20>)
 800157c:	f003 fd3a 	bl	8004ff4 <HAL_RNG_Init>
 8001580:	4603      	mov	r3, r0
 8001582:	2b00      	cmp	r3, #0
 8001584:	d001      	beq.n	800158a <MX_RNG_Init+0x1a>
  {
    Error_Handler();
 8001586:	f000 f93b 	bl	8001800 <Error_Handler>
  }
  /* USER CODE BEGIN RNG_Init 2 */

  /* USER CODE END RNG_Init 2 */

}
 800158a:	bf00      	nop
 800158c:	bd80      	pop	{r7, pc}
 800158e:	bf00      	nop
 8001590:	200014a0 	.word	0x200014a0
 8001594:	50060800 	.word	0x50060800

08001598 <MX_SPI1_Init>:
  * @brief SPI1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_SPI1_Init(void)
{
 8001598:	b580      	push	{r7, lr}
 800159a:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN SPI1_Init 1 */

  /* USER CODE END SPI1_Init 1 */
  /* SPI1 parameter configuration*/
  hspi1.Instance = SPI1;
 800159c:	4b17      	ldr	r3, [pc, #92]	@ (80015fc <MX_SPI1_Init+0x64>)
 800159e:	4a18      	ldr	r2, [pc, #96]	@ (8001600 <MX_SPI1_Init+0x68>)
 80015a0:	601a      	str	r2, [r3, #0]
  hspi1.Init.Mode = SPI_MODE_MASTER;
 80015a2:	4b16      	ldr	r3, [pc, #88]	@ (80015fc <MX_SPI1_Init+0x64>)
 80015a4:	f44f 7282 	mov.w	r2, #260	@ 0x104
 80015a8:	605a      	str	r2, [r3, #4]
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
 80015aa:	4b14      	ldr	r3, [pc, #80]	@ (80015fc <MX_SPI1_Init+0x64>)
 80015ac:	2200      	movs	r2, #0
 80015ae:	609a      	str	r2, [r3, #8]
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
 80015b0:	4b12      	ldr	r3, [pc, #72]	@ (80015fc <MX_SPI1_Init+0x64>)
 80015b2:	2200      	movs	r2, #0
 80015b4:	60da      	str	r2, [r3, #12]
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
 80015b6:	4b11      	ldr	r3, [pc, #68]	@ (80015fc <MX_SPI1_Init+0x64>)
 80015b8:	2200      	movs	r2, #0
 80015ba:	611a      	str	r2, [r3, #16]
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
 80015bc:	4b0f      	ldr	r3, [pc, #60]	@ (80015fc <MX_SPI1_Init+0x64>)
 80015be:	2200      	movs	r2, #0
 80015c0:	615a      	str	r2, [r3, #20]
  hspi1.Init.NSS = SPI_NSS_SOFT;
 80015c2:	4b0e      	ldr	r3, [pc, #56]	@ (80015fc <MX_SPI1_Init+0x64>)
 80015c4:	f44f 7200 	mov.w	r2, #512	@ 0x200
 80015c8:	619a      	str	r2, [r3, #24]
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 80015ca:	4b0c      	ldr	r3, [pc, #48]	@ (80015fc <MX_SPI1_Init+0x64>)
 80015cc:	2200      	movs	r2, #0
 80015ce:	61da      	str	r2, [r3, #28]
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
 80015d0:	4b0a      	ldr	r3, [pc, #40]	@ (80015fc <MX_SPI1_Init+0x64>)
 80015d2:	2200      	movs	r2, #0
 80015d4:	621a      	str	r2, [r3, #32]
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
 80015d6:	4b09      	ldr	r3, [pc, #36]	@ (80015fc <MX_SPI1_Init+0x64>)
 80015d8:	2200      	movs	r2, #0
 80015da:	625a      	str	r2, [r3, #36]	@ 0x24
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 80015dc:	4b07      	ldr	r3, [pc, #28]	@ (80015fc <MX_SPI1_Init+0x64>)
 80015de:	2200      	movs	r2, #0
 80015e0:	629a      	str	r2, [r3, #40]	@ 0x28
  hspi1.Init.CRCPolynomial = 10;
 80015e2:	4b06      	ldr	r3, [pc, #24]	@ (80015fc <MX_SPI1_Init+0x64>)
 80015e4:	220a      	movs	r2, #10
 80015e6:	62da      	str	r2, [r3, #44]	@ 0x2c
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
 80015e8:	4804      	ldr	r0, [pc, #16]	@ (80015fc <MX_SPI1_Init+0x64>)
 80015ea:	f003 fdad 	bl	8005148 <HAL_SPI_Init>
 80015ee:	4603      	mov	r3, r0
 80015f0:	2b00      	cmp	r3, #0
 80015f2:	d001      	beq.n	80015f8 <MX_SPI1_Init+0x60>
  {
    Error_Handler();
 80015f4:	f000 f904 	bl	8001800 <Error_Handler>
  }
  /* USER CODE BEGIN SPI1_Init 2 */

  /* USER CODE END SPI1_Init 2 */

}
 80015f8:	bf00      	nop
 80015fa:	bd80      	pop	{r7, pc}
 80015fc:	200014b0 	.word	0x200014b0
 8001600:	40013000 	.word	0x40013000

08001604 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 8001604:	b580      	push	{r7, lr}
 8001606:	b08c      	sub	sp, #48	@ 0x30
 8001608:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800160a:	f107 031c 	add.w	r3, r7, #28
 800160e:	2200      	movs	r2, #0
 8001610:	601a      	str	r2, [r3, #0]
 8001612:	605a      	str	r2, [r3, #4]
 8001614:	609a      	str	r2, [r3, #8]
 8001616:	60da      	str	r2, [r3, #12]
 8001618:	611a      	str	r2, [r3, #16]
  /* USER CODE BEGIN MX_GPIO_Init_1 */

  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
 800161a:	2300      	movs	r3, #0
 800161c:	61bb      	str	r3, [r7, #24]
 800161e:	4b72      	ldr	r3, [pc, #456]	@ (80017e8 <MX_GPIO_Init+0x1e4>)
 8001620:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001622:	4a71      	ldr	r2, [pc, #452]	@ (80017e8 <MX_GPIO_Init+0x1e4>)
 8001624:	f043 0310 	orr.w	r3, r3, #16
 8001628:	6313      	str	r3, [r2, #48]	@ 0x30
 800162a:	4b6f      	ldr	r3, [pc, #444]	@ (80017e8 <MX_GPIO_Init+0x1e4>)
 800162c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800162e:	f003 0310 	and.w	r3, r3, #16
 8001632:	61bb      	str	r3, [r7, #24]
 8001634:	69bb      	ldr	r3, [r7, #24]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8001636:	2300      	movs	r3, #0
 8001638:	617b      	str	r3, [r7, #20]
 800163a:	4b6b      	ldr	r3, [pc, #428]	@ (80017e8 <MX_GPIO_Init+0x1e4>)
 800163c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800163e:	4a6a      	ldr	r2, [pc, #424]	@ (80017e8 <MX_GPIO_Init+0x1e4>)
 8001640:	f043 0304 	orr.w	r3, r3, #4
 8001644:	6313      	str	r3, [r2, #48]	@ 0x30
 8001646:	4b68      	ldr	r3, [pc, #416]	@ (80017e8 <MX_GPIO_Init+0x1e4>)
 8001648:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800164a:	f003 0304 	and.w	r3, r3, #4
 800164e:	617b      	str	r3, [r7, #20]
 8001650:	697b      	ldr	r3, [r7, #20]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 8001652:	2300      	movs	r3, #0
 8001654:	613b      	str	r3, [r7, #16]
 8001656:	4b64      	ldr	r3, [pc, #400]	@ (80017e8 <MX_GPIO_Init+0x1e4>)
 8001658:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800165a:	4a63      	ldr	r2, [pc, #396]	@ (80017e8 <MX_GPIO_Init+0x1e4>)
 800165c:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8001660:	6313      	str	r3, [r2, #48]	@ 0x30
 8001662:	4b61      	ldr	r3, [pc, #388]	@ (80017e8 <MX_GPIO_Init+0x1e4>)
 8001664:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001666:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800166a:	613b      	str	r3, [r7, #16]
 800166c:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 800166e:	2300      	movs	r3, #0
 8001670:	60fb      	str	r3, [r7, #12]
 8001672:	4b5d      	ldr	r3, [pc, #372]	@ (80017e8 <MX_GPIO_Init+0x1e4>)
 8001674:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001676:	4a5c      	ldr	r2, [pc, #368]	@ (80017e8 <MX_GPIO_Init+0x1e4>)
 8001678:	f043 0301 	orr.w	r3, r3, #1
 800167c:	6313      	str	r3, [r2, #48]	@ 0x30
 800167e:	4b5a      	ldr	r3, [pc, #360]	@ (80017e8 <MX_GPIO_Init+0x1e4>)
 8001680:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001682:	f003 0301 	and.w	r3, r3, #1
 8001686:	60fb      	str	r3, [r7, #12]
 8001688:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 800168a:	2300      	movs	r3, #0
 800168c:	60bb      	str	r3, [r7, #8]
 800168e:	4b56      	ldr	r3, [pc, #344]	@ (80017e8 <MX_GPIO_Init+0x1e4>)
 8001690:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001692:	4a55      	ldr	r2, [pc, #340]	@ (80017e8 <MX_GPIO_Init+0x1e4>)
 8001694:	f043 0302 	orr.w	r3, r3, #2
 8001698:	6313      	str	r3, [r2, #48]	@ 0x30
 800169a:	4b53      	ldr	r3, [pc, #332]	@ (80017e8 <MX_GPIO_Init+0x1e4>)
 800169c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800169e:	f003 0302 	and.w	r3, r3, #2
 80016a2:	60bb      	str	r3, [r7, #8]
 80016a4:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 80016a6:	2300      	movs	r3, #0
 80016a8:	607b      	str	r3, [r7, #4]
 80016aa:	4b4f      	ldr	r3, [pc, #316]	@ (80017e8 <MX_GPIO_Init+0x1e4>)
 80016ac:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80016ae:	4a4e      	ldr	r2, [pc, #312]	@ (80017e8 <MX_GPIO_Init+0x1e4>)
 80016b0:	f043 0308 	orr.w	r3, r3, #8
 80016b4:	6313      	str	r3, [r2, #48]	@ 0x30
 80016b6:	4b4c      	ldr	r3, [pc, #304]	@ (80017e8 <MX_GPIO_Init+0x1e4>)
 80016b8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80016ba:	f003 0308 	and.w	r3, r3, #8
 80016be:	607b      	str	r3, [r7, #4]
 80016c0:	687b      	ldr	r3, [r7, #4]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(CS_I2C_SPI_GPIO_Port, CS_I2C_SPI_Pin, GPIO_PIN_RESET);
 80016c2:	2200      	movs	r2, #0
 80016c4:	2108      	movs	r1, #8
 80016c6:	4849      	ldr	r0, [pc, #292]	@ (80017ec <MX_GPIO_Init+0x1e8>)
 80016c8:	f000 fe7e 	bl	80023c8 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(OTG_FS_PowerSwitchOn_GPIO_Port, OTG_FS_PowerSwitchOn_Pin, GPIO_PIN_SET);
 80016cc:	2201      	movs	r2, #1
 80016ce:	2101      	movs	r1, #1
 80016d0:	4847      	ldr	r0, [pc, #284]	@ (80017f0 <MX_GPIO_Init+0x1ec>)
 80016d2:	f000 fe79 	bl	80023c8 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOD, LD4_Pin|LD3_Pin|LD5_Pin|LD6_Pin
 80016d6:	2200      	movs	r2, #0
 80016d8:	f24f 0110 	movw	r1, #61456	@ 0xf010
 80016dc:	4845      	ldr	r0, [pc, #276]	@ (80017f4 <MX_GPIO_Init+0x1f0>)
 80016de:	f000 fe73 	bl	80023c8 <HAL_GPIO_WritePin>
                          |Audio_RST_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin : CS_I2C_SPI_Pin */
  GPIO_InitStruct.Pin = CS_I2C_SPI_Pin;
 80016e2:	2308      	movs	r3, #8
 80016e4:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80016e6:	2301      	movs	r3, #1
 80016e8:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80016ea:	2300      	movs	r3, #0
 80016ec:	627b      	str	r3, [r7, #36]	@ 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80016ee:	2300      	movs	r3, #0
 80016f0:	62bb      	str	r3, [r7, #40]	@ 0x28
  HAL_GPIO_Init(CS_I2C_SPI_GPIO_Port, &GPIO_InitStruct);
 80016f2:	f107 031c 	add.w	r3, r7, #28
 80016f6:	4619      	mov	r1, r3
 80016f8:	483c      	ldr	r0, [pc, #240]	@ (80017ec <MX_GPIO_Init+0x1e8>)
 80016fa:	f000 fcb1 	bl	8002060 <HAL_GPIO_Init>

  /*Configure GPIO pin : OTG_FS_PowerSwitchOn_Pin */
  GPIO_InitStruct.Pin = OTG_FS_PowerSwitchOn_Pin;
 80016fe:	2301      	movs	r3, #1
 8001700:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8001702:	2301      	movs	r3, #1
 8001704:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001706:	2300      	movs	r3, #0
 8001708:	627b      	str	r3, [r7, #36]	@ 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800170a:	2300      	movs	r3, #0
 800170c:	62bb      	str	r3, [r7, #40]	@ 0x28
  HAL_GPIO_Init(OTG_FS_PowerSwitchOn_GPIO_Port, &GPIO_InitStruct);
 800170e:	f107 031c 	add.w	r3, r7, #28
 8001712:	4619      	mov	r1, r3
 8001714:	4836      	ldr	r0, [pc, #216]	@ (80017f0 <MX_GPIO_Init+0x1ec>)
 8001716:	f000 fca3 	bl	8002060 <HAL_GPIO_Init>

  /*Configure GPIO pin : PDM_OUT_Pin */
  GPIO_InitStruct.Pin = PDM_OUT_Pin;
 800171a:	2308      	movs	r3, #8
 800171c:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800171e:	2302      	movs	r3, #2
 8001720:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001722:	2300      	movs	r3, #0
 8001724:	627b      	str	r3, [r7, #36]	@ 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001726:	2300      	movs	r3, #0
 8001728:	62bb      	str	r3, [r7, #40]	@ 0x28
  GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 800172a:	2305      	movs	r3, #5
 800172c:	62fb      	str	r3, [r7, #44]	@ 0x2c
  HAL_GPIO_Init(PDM_OUT_GPIO_Port, &GPIO_InitStruct);
 800172e:	f107 031c 	add.w	r3, r7, #28
 8001732:	4619      	mov	r1, r3
 8001734:	482e      	ldr	r0, [pc, #184]	@ (80017f0 <MX_GPIO_Init+0x1ec>)
 8001736:	f000 fc93 	bl	8002060 <HAL_GPIO_Init>

  /*Configure GPIO pin : B1_Pin */
  GPIO_InitStruct.Pin = B1_Pin;
 800173a:	2301      	movs	r3, #1
 800173c:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
 800173e:	f44f 1390 	mov.w	r3, #1179648	@ 0x120000
 8001742:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001744:	2300      	movs	r3, #0
 8001746:	627b      	str	r3, [r7, #36]	@ 0x24
  HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
 8001748:	f107 031c 	add.w	r3, r7, #28
 800174c:	4619      	mov	r1, r3
 800174e:	482a      	ldr	r0, [pc, #168]	@ (80017f8 <MX_GPIO_Init+0x1f4>)
 8001750:	f000 fc86 	bl	8002060 <HAL_GPIO_Init>

  /*Configure GPIO pin : BOOT1_Pin */
  GPIO_InitStruct.Pin = BOOT1_Pin;
 8001754:	2304      	movs	r3, #4
 8001756:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8001758:	2300      	movs	r3, #0
 800175a:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800175c:	2300      	movs	r3, #0
 800175e:	627b      	str	r3, [r7, #36]	@ 0x24
  HAL_GPIO_Init(BOOT1_GPIO_Port, &GPIO_InitStruct);
 8001760:	f107 031c 	add.w	r3, r7, #28
 8001764:	4619      	mov	r1, r3
 8001766:	4825      	ldr	r0, [pc, #148]	@ (80017fc <MX_GPIO_Init+0x1f8>)
 8001768:	f000 fc7a 	bl	8002060 <HAL_GPIO_Init>

  /*Configure GPIO pin : CLK_IN_Pin */
  GPIO_InitStruct.Pin = CLK_IN_Pin;
 800176c:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8001770:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001772:	2302      	movs	r3, #2
 8001774:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001776:	2300      	movs	r3, #0
 8001778:	627b      	str	r3, [r7, #36]	@ 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800177a:	2300      	movs	r3, #0
 800177c:	62bb      	str	r3, [r7, #40]	@ 0x28
  GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 800177e:	2305      	movs	r3, #5
 8001780:	62fb      	str	r3, [r7, #44]	@ 0x2c
  HAL_GPIO_Init(CLK_IN_GPIO_Port, &GPIO_InitStruct);
 8001782:	f107 031c 	add.w	r3, r7, #28
 8001786:	4619      	mov	r1, r3
 8001788:	481c      	ldr	r0, [pc, #112]	@ (80017fc <MX_GPIO_Init+0x1f8>)
 800178a:	f000 fc69 	bl	8002060 <HAL_GPIO_Init>

  /*Configure GPIO pins : LD4_Pin LD3_Pin LD5_Pin LD6_Pin
                           Audio_RST_Pin */
  GPIO_InitStruct.Pin = LD4_Pin|LD3_Pin|LD5_Pin|LD6_Pin
 800178e:	f24f 0310 	movw	r3, #61456	@ 0xf010
 8001792:	61fb      	str	r3, [r7, #28]
                          |Audio_RST_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8001794:	2301      	movs	r3, #1
 8001796:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001798:	2300      	movs	r3, #0
 800179a:	627b      	str	r3, [r7, #36]	@ 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800179c:	2300      	movs	r3, #0
 800179e:	62bb      	str	r3, [r7, #40]	@ 0x28
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80017a0:	f107 031c 	add.w	r3, r7, #28
 80017a4:	4619      	mov	r1, r3
 80017a6:	4813      	ldr	r0, [pc, #76]	@ (80017f4 <MX_GPIO_Init+0x1f0>)
 80017a8:	f000 fc5a 	bl	8002060 <HAL_GPIO_Init>

  /*Configure GPIO pin : OTG_FS_OverCurrent_Pin */
  GPIO_InitStruct.Pin = OTG_FS_OverCurrent_Pin;
 80017ac:	2320      	movs	r3, #32
 80017ae:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 80017b0:	2300      	movs	r3, #0
 80017b2:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80017b4:	2300      	movs	r3, #0
 80017b6:	627b      	str	r3, [r7, #36]	@ 0x24
  HAL_GPIO_Init(OTG_FS_OverCurrent_GPIO_Port, &GPIO_InitStruct);
 80017b8:	f107 031c 	add.w	r3, r7, #28
 80017bc:	4619      	mov	r1, r3
 80017be:	480d      	ldr	r0, [pc, #52]	@ (80017f4 <MX_GPIO_Init+0x1f0>)
 80017c0:	f000 fc4e 	bl	8002060 <HAL_GPIO_Init>

  /*Configure GPIO pin : MEMS_INT2_Pin */
  GPIO_InitStruct.Pin = MEMS_INT2_Pin;
 80017c4:	2302      	movs	r3, #2
 80017c6:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
 80017c8:	f44f 1390 	mov.w	r3, #1179648	@ 0x120000
 80017cc:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80017ce:	2300      	movs	r3, #0
 80017d0:	627b      	str	r3, [r7, #36]	@ 0x24
  HAL_GPIO_Init(MEMS_INT2_GPIO_Port, &GPIO_InitStruct);
 80017d2:	f107 031c 	add.w	r3, r7, #28
 80017d6:	4619      	mov	r1, r3
 80017d8:	4804      	ldr	r0, [pc, #16]	@ (80017ec <MX_GPIO_Init+0x1e8>)
 80017da:	f000 fc41 	bl	8002060 <HAL_GPIO_Init>

  /* USER CODE BEGIN MX_GPIO_Init_2 */

  /* USER CODE END MX_GPIO_Init_2 */
}
 80017de:	bf00      	nop
 80017e0:	3730      	adds	r7, #48	@ 0x30
 80017e2:	46bd      	mov	sp, r7
 80017e4:	bd80      	pop	{r7, pc}
 80017e6:	bf00      	nop
 80017e8:	40023800 	.word	0x40023800
 80017ec:	40021000 	.word	0x40021000
 80017f0:	40020800 	.word	0x40020800
 80017f4:	40020c00 	.word	0x40020c00
 80017f8:	40020000 	.word	0x40020000
 80017fc:	40020400 	.word	0x40020400

08001800 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 8001800:	b480      	push	{r7}
 8001802:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting special-purpose register PRIMASK.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001804:	b672      	cpsid	i
}
 8001806:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 8001808:	bf00      	nop
 800180a:	e7fd      	b.n	8001808 <Error_Handler+0x8>

0800180c <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 800180c:	b580      	push	{r7, lr}
 800180e:	b082      	sub	sp, #8
 8001810:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001812:	2300      	movs	r3, #0
 8001814:	607b      	str	r3, [r7, #4]
 8001816:	4b10      	ldr	r3, [pc, #64]	@ (8001858 <HAL_MspInit+0x4c>)
 8001818:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800181a:	4a0f      	ldr	r2, [pc, #60]	@ (8001858 <HAL_MspInit+0x4c>)
 800181c:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 8001820:	6453      	str	r3, [r2, #68]	@ 0x44
 8001822:	4b0d      	ldr	r3, [pc, #52]	@ (8001858 <HAL_MspInit+0x4c>)
 8001824:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8001826:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 800182a:	607b      	str	r3, [r7, #4]
 800182c:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_PWR_CLK_ENABLE();
 800182e:	2300      	movs	r3, #0
 8001830:	603b      	str	r3, [r7, #0]
 8001832:	4b09      	ldr	r3, [pc, #36]	@ (8001858 <HAL_MspInit+0x4c>)
 8001834:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8001836:	4a08      	ldr	r2, [pc, #32]	@ (8001858 <HAL_MspInit+0x4c>)
 8001838:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 800183c:	6413      	str	r3, [r2, #64]	@ 0x40
 800183e:	4b06      	ldr	r3, [pc, #24]	@ (8001858 <HAL_MspInit+0x4c>)
 8001840:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8001842:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8001846:	603b      	str	r3, [r7, #0]
 8001848:	683b      	ldr	r3, [r7, #0]

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_0);
 800184a:	2007      	movs	r0, #7
 800184c:	f000 fbaa 	bl	8001fa4 <HAL_NVIC_SetPriorityGrouping>
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8001850:	bf00      	nop
 8001852:	3708      	adds	r7, #8
 8001854:	46bd      	mov	sp, r7
 8001856:	bd80      	pop	{r7, pc}
 8001858:	40023800 	.word	0x40023800

0800185c <HAL_CRC_MspInit>:
  * This function configures the hardware resources used in this example
  * @param hcrc: CRC handle pointer
  * @retval None
  */
void HAL_CRC_MspInit(CRC_HandleTypeDef* hcrc)
{
 800185c:	b480      	push	{r7}
 800185e:	b085      	sub	sp, #20
 8001860:	af00      	add	r7, sp, #0
 8001862:	6078      	str	r0, [r7, #4]
  if(hcrc->Instance==CRC)
 8001864:	687b      	ldr	r3, [r7, #4]
 8001866:	681b      	ldr	r3, [r3, #0]
 8001868:	4a0b      	ldr	r2, [pc, #44]	@ (8001898 <HAL_CRC_MspInit+0x3c>)
 800186a:	4293      	cmp	r3, r2
 800186c:	d10d      	bne.n	800188a <HAL_CRC_MspInit+0x2e>
  {
    /* USER CODE BEGIN CRC_MspInit 0 */

    /* USER CODE END CRC_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_CRC_CLK_ENABLE();
 800186e:	2300      	movs	r3, #0
 8001870:	60fb      	str	r3, [r7, #12]
 8001872:	4b0a      	ldr	r3, [pc, #40]	@ (800189c <HAL_CRC_MspInit+0x40>)
 8001874:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001876:	4a09      	ldr	r2, [pc, #36]	@ (800189c <HAL_CRC_MspInit+0x40>)
 8001878:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 800187c:	6313      	str	r3, [r2, #48]	@ 0x30
 800187e:	4b07      	ldr	r3, [pc, #28]	@ (800189c <HAL_CRC_MspInit+0x40>)
 8001880:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001882:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 8001886:	60fb      	str	r3, [r7, #12]
 8001888:	68fb      	ldr	r3, [r7, #12]

    /* USER CODE END CRC_MspInit 1 */

  }

}
 800188a:	bf00      	nop
 800188c:	3714      	adds	r7, #20
 800188e:	46bd      	mov	sp, r7
 8001890:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001894:	4770      	bx	lr
 8001896:	bf00      	nop
 8001898:	40023000 	.word	0x40023000
 800189c:	40023800 	.word	0x40023800

080018a0 <HAL_I2C_MspInit>:
  * This function configures the hardware resources used in this example
  * @param hi2c: I2C handle pointer
  * @retval None
  */
void HAL_I2C_MspInit(I2C_HandleTypeDef* hi2c)
{
 80018a0:	b580      	push	{r7, lr}
 80018a2:	b08a      	sub	sp, #40	@ 0x28
 80018a4:	af00      	add	r7, sp, #0
 80018a6:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80018a8:	f107 0314 	add.w	r3, r7, #20
 80018ac:	2200      	movs	r2, #0
 80018ae:	601a      	str	r2, [r3, #0]
 80018b0:	605a      	str	r2, [r3, #4]
 80018b2:	609a      	str	r2, [r3, #8]
 80018b4:	60da      	str	r2, [r3, #12]
 80018b6:	611a      	str	r2, [r3, #16]
  if(hi2c->Instance==I2C1)
 80018b8:	687b      	ldr	r3, [r7, #4]
 80018ba:	681b      	ldr	r3, [r3, #0]
 80018bc:	4a19      	ldr	r2, [pc, #100]	@ (8001924 <HAL_I2C_MspInit+0x84>)
 80018be:	4293      	cmp	r3, r2
 80018c0:	d12c      	bne.n	800191c <HAL_I2C_MspInit+0x7c>
  {
    /* USER CODE BEGIN I2C1_MspInit 0 */

    /* USER CODE END I2C1_MspInit 0 */

    __HAL_RCC_GPIOB_CLK_ENABLE();
 80018c2:	2300      	movs	r3, #0
 80018c4:	613b      	str	r3, [r7, #16]
 80018c6:	4b18      	ldr	r3, [pc, #96]	@ (8001928 <HAL_I2C_MspInit+0x88>)
 80018c8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80018ca:	4a17      	ldr	r2, [pc, #92]	@ (8001928 <HAL_I2C_MspInit+0x88>)
 80018cc:	f043 0302 	orr.w	r3, r3, #2
 80018d0:	6313      	str	r3, [r2, #48]	@ 0x30
 80018d2:	4b15      	ldr	r3, [pc, #84]	@ (8001928 <HAL_I2C_MspInit+0x88>)
 80018d4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80018d6:	f003 0302 	and.w	r3, r3, #2
 80018da:	613b      	str	r3, [r7, #16]
 80018dc:	693b      	ldr	r3, [r7, #16]
    /**I2C1 GPIO Configuration
    PB6     ------> I2C1_SCL
    PB9     ------> I2C1_SDA
    */
    GPIO_InitStruct.Pin = Audio_SCL_Pin|Audio_SDA_Pin;
 80018de:	f44f 7310 	mov.w	r3, #576	@ 0x240
 80018e2:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 80018e4:	2312      	movs	r3, #18
 80018e6:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 80018e8:	2301      	movs	r3, #1
 80018ea:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80018ec:	2300      	movs	r3, #0
 80018ee:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
 80018f0:	2304      	movs	r3, #4
 80018f2:	627b      	str	r3, [r7, #36]	@ 0x24
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80018f4:	f107 0314 	add.w	r3, r7, #20
 80018f8:	4619      	mov	r1, r3
 80018fa:	480c      	ldr	r0, [pc, #48]	@ (800192c <HAL_I2C_MspInit+0x8c>)
 80018fc:	f000 fbb0 	bl	8002060 <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_I2C1_CLK_ENABLE();
 8001900:	2300      	movs	r3, #0
 8001902:	60fb      	str	r3, [r7, #12]
 8001904:	4b08      	ldr	r3, [pc, #32]	@ (8001928 <HAL_I2C_MspInit+0x88>)
 8001906:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8001908:	4a07      	ldr	r2, [pc, #28]	@ (8001928 <HAL_I2C_MspInit+0x88>)
 800190a:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 800190e:	6413      	str	r3, [r2, #64]	@ 0x40
 8001910:	4b05      	ldr	r3, [pc, #20]	@ (8001928 <HAL_I2C_MspInit+0x88>)
 8001912:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8001914:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 8001918:	60fb      	str	r3, [r7, #12]
 800191a:	68fb      	ldr	r3, [r7, #12]

    /* USER CODE END I2C1_MspInit 1 */

  }

}
 800191c:	bf00      	nop
 800191e:	3728      	adds	r7, #40	@ 0x28
 8001920:	46bd      	mov	sp, r7
 8001922:	bd80      	pop	{r7, pc}
 8001924:	40005400 	.word	0x40005400
 8001928:	40023800 	.word	0x40023800
 800192c:	40020400 	.word	0x40020400

08001930 <HAL_I2S_MspInit>:
  * This function configures the hardware resources used in this example
  * @param hi2s: I2S handle pointer
  * @retval None
  */
void HAL_I2S_MspInit(I2S_HandleTypeDef* hi2s)
{
 8001930:	b580      	push	{r7, lr}
 8001932:	b08e      	sub	sp, #56	@ 0x38
 8001934:	af00      	add	r7, sp, #0
 8001936:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001938:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 800193c:	2200      	movs	r2, #0
 800193e:	601a      	str	r2, [r3, #0]
 8001940:	605a      	str	r2, [r3, #4]
 8001942:	609a      	str	r2, [r3, #8]
 8001944:	60da      	str	r2, [r3, #12]
 8001946:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8001948:	f107 0314 	add.w	r3, r7, #20
 800194c:	2200      	movs	r2, #0
 800194e:	601a      	str	r2, [r3, #0]
 8001950:	605a      	str	r2, [r3, #4]
 8001952:	609a      	str	r2, [r3, #8]
 8001954:	60da      	str	r2, [r3, #12]
  if(hi2s->Instance==SPI3)
 8001956:	687b      	ldr	r3, [r7, #4]
 8001958:	681b      	ldr	r3, [r3, #0]
 800195a:	4a31      	ldr	r2, [pc, #196]	@ (8001a20 <HAL_I2S_MspInit+0xf0>)
 800195c:	4293      	cmp	r3, r2
 800195e:	d15a      	bne.n	8001a16 <HAL_I2S_MspInit+0xe6>

    /* USER CODE END SPI3_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_I2S;
 8001960:	2301      	movs	r3, #1
 8001962:	617b      	str	r3, [r7, #20]
    PeriphClkInitStruct.PLLI2S.PLLI2SN = 192;
 8001964:	23c0      	movs	r3, #192	@ 0xc0
 8001966:	61bb      	str	r3, [r7, #24]
    PeriphClkInitStruct.PLLI2S.PLLI2SR = 2;
 8001968:	2302      	movs	r3, #2
 800196a:	61fb      	str	r3, [r7, #28]
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 800196c:	f107 0314 	add.w	r3, r7, #20
 8001970:	4618      	mov	r0, r3
 8001972:	f003 f9fd 	bl	8004d70 <HAL_RCCEx_PeriphCLKConfig>
 8001976:	4603      	mov	r3, r0
 8001978:	2b00      	cmp	r3, #0
 800197a:	d001      	beq.n	8001980 <HAL_I2S_MspInit+0x50>
    {
      Error_Handler();
 800197c:	f7ff ff40 	bl	8001800 <Error_Handler>
    }

    /* Peripheral clock enable */
    __HAL_RCC_SPI3_CLK_ENABLE();
 8001980:	2300      	movs	r3, #0
 8001982:	613b      	str	r3, [r7, #16]
 8001984:	4b27      	ldr	r3, [pc, #156]	@ (8001a24 <HAL_I2S_MspInit+0xf4>)
 8001986:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8001988:	4a26      	ldr	r2, [pc, #152]	@ (8001a24 <HAL_I2S_MspInit+0xf4>)
 800198a:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 800198e:	6413      	str	r3, [r2, #64]	@ 0x40
 8001990:	4b24      	ldr	r3, [pc, #144]	@ (8001a24 <HAL_I2S_MspInit+0xf4>)
 8001992:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8001994:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 8001998:	613b      	str	r3, [r7, #16]
 800199a:	693b      	ldr	r3, [r7, #16]

    __HAL_RCC_GPIOA_CLK_ENABLE();
 800199c:	2300      	movs	r3, #0
 800199e:	60fb      	str	r3, [r7, #12]
 80019a0:	4b20      	ldr	r3, [pc, #128]	@ (8001a24 <HAL_I2S_MspInit+0xf4>)
 80019a2:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80019a4:	4a1f      	ldr	r2, [pc, #124]	@ (8001a24 <HAL_I2S_MspInit+0xf4>)
 80019a6:	f043 0301 	orr.w	r3, r3, #1
 80019aa:	6313      	str	r3, [r2, #48]	@ 0x30
 80019ac:	4b1d      	ldr	r3, [pc, #116]	@ (8001a24 <HAL_I2S_MspInit+0xf4>)
 80019ae:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80019b0:	f003 0301 	and.w	r3, r3, #1
 80019b4:	60fb      	str	r3, [r7, #12]
 80019b6:	68fb      	ldr	r3, [r7, #12]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 80019b8:	2300      	movs	r3, #0
 80019ba:	60bb      	str	r3, [r7, #8]
 80019bc:	4b19      	ldr	r3, [pc, #100]	@ (8001a24 <HAL_I2S_MspInit+0xf4>)
 80019be:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80019c0:	4a18      	ldr	r2, [pc, #96]	@ (8001a24 <HAL_I2S_MspInit+0xf4>)
 80019c2:	f043 0304 	orr.w	r3, r3, #4
 80019c6:	6313      	str	r3, [r2, #48]	@ 0x30
 80019c8:	4b16      	ldr	r3, [pc, #88]	@ (8001a24 <HAL_I2S_MspInit+0xf4>)
 80019ca:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80019cc:	f003 0304 	and.w	r3, r3, #4
 80019d0:	60bb      	str	r3, [r7, #8]
 80019d2:	68bb      	ldr	r3, [r7, #8]
    PA4     ------> I2S3_WS
    PC7     ------> I2S3_MCK
    PC10     ------> I2S3_CK
    PC12     ------> I2S3_SD
    */
    GPIO_InitStruct.Pin = I2S3_WS_Pin;
 80019d4:	2310      	movs	r3, #16
 80019d6:	627b      	str	r3, [r7, #36]	@ 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80019d8:	2302      	movs	r3, #2
 80019da:	62bb      	str	r3, [r7, #40]	@ 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80019dc:	2300      	movs	r3, #0
 80019de:	62fb      	str	r3, [r7, #44]	@ 0x2c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80019e0:	2300      	movs	r3, #0
 80019e2:	633b      	str	r3, [r7, #48]	@ 0x30
    GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
 80019e4:	2306      	movs	r3, #6
 80019e6:	637b      	str	r3, [r7, #52]	@ 0x34
    HAL_GPIO_Init(I2S3_WS_GPIO_Port, &GPIO_InitStruct);
 80019e8:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 80019ec:	4619      	mov	r1, r3
 80019ee:	480e      	ldr	r0, [pc, #56]	@ (8001a28 <HAL_I2S_MspInit+0xf8>)
 80019f0:	f000 fb36 	bl	8002060 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = I2S3_MCK_Pin|I2S3_SCK_Pin|I2S3_SD_Pin;
 80019f4:	f44f 53a4 	mov.w	r3, #5248	@ 0x1480
 80019f8:	627b      	str	r3, [r7, #36]	@ 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80019fa:	2302      	movs	r3, #2
 80019fc:	62bb      	str	r3, [r7, #40]	@ 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80019fe:	2300      	movs	r3, #0
 8001a00:	62fb      	str	r3, [r7, #44]	@ 0x2c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001a02:	2300      	movs	r3, #0
 8001a04:	633b      	str	r3, [r7, #48]	@ 0x30
    GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
 8001a06:	2306      	movs	r3, #6
 8001a08:	637b      	str	r3, [r7, #52]	@ 0x34
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8001a0a:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 8001a0e:	4619      	mov	r1, r3
 8001a10:	4806      	ldr	r0, [pc, #24]	@ (8001a2c <HAL_I2S_MspInit+0xfc>)
 8001a12:	f000 fb25 	bl	8002060 <HAL_GPIO_Init>

    /* USER CODE END SPI3_MspInit 1 */

  }

}
 8001a16:	bf00      	nop
 8001a18:	3738      	adds	r7, #56	@ 0x38
 8001a1a:	46bd      	mov	sp, r7
 8001a1c:	bd80      	pop	{r7, pc}
 8001a1e:	bf00      	nop
 8001a20:	40003c00 	.word	0x40003c00
 8001a24:	40023800 	.word	0x40023800
 8001a28:	40020000 	.word	0x40020000
 8001a2c:	40020800 	.word	0x40020800

08001a30 <HAL_RNG_MspInit>:
  * This function configures the hardware resources used in this example
  * @param hrng: RNG handle pointer
  * @retval None
  */
void HAL_RNG_MspInit(RNG_HandleTypeDef* hrng)
{
 8001a30:	b480      	push	{r7}
 8001a32:	b085      	sub	sp, #20
 8001a34:	af00      	add	r7, sp, #0
 8001a36:	6078      	str	r0, [r7, #4]
  if(hrng->Instance==RNG)
 8001a38:	687b      	ldr	r3, [r7, #4]
 8001a3a:	681b      	ldr	r3, [r3, #0]
 8001a3c:	4a0b      	ldr	r2, [pc, #44]	@ (8001a6c <HAL_RNG_MspInit+0x3c>)
 8001a3e:	4293      	cmp	r3, r2
 8001a40:	d10d      	bne.n	8001a5e <HAL_RNG_MspInit+0x2e>
  {
    /* USER CODE BEGIN RNG_MspInit 0 */

    /* USER CODE END RNG_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_RNG_CLK_ENABLE();
 8001a42:	2300      	movs	r3, #0
 8001a44:	60fb      	str	r3, [r7, #12]
 8001a46:	4b0a      	ldr	r3, [pc, #40]	@ (8001a70 <HAL_RNG_MspInit+0x40>)
 8001a48:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8001a4a:	4a09      	ldr	r2, [pc, #36]	@ (8001a70 <HAL_RNG_MspInit+0x40>)
 8001a4c:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8001a50:	6353      	str	r3, [r2, #52]	@ 0x34
 8001a52:	4b07      	ldr	r3, [pc, #28]	@ (8001a70 <HAL_RNG_MspInit+0x40>)
 8001a54:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8001a56:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8001a5a:	60fb      	str	r3, [r7, #12]
 8001a5c:	68fb      	ldr	r3, [r7, #12]

    /* USER CODE END RNG_MspInit 1 */

  }

}
 8001a5e:	bf00      	nop
 8001a60:	3714      	adds	r7, #20
 8001a62:	46bd      	mov	sp, r7
 8001a64:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001a68:	4770      	bx	lr
 8001a6a:	bf00      	nop
 8001a6c:	50060800 	.word	0x50060800
 8001a70:	40023800 	.word	0x40023800

08001a74 <HAL_RNG_MspDeInit>:
  * This function freeze the hardware resources used in this example
  * @param hrng: RNG handle pointer
  * @retval None
  */
void HAL_RNG_MspDeInit(RNG_HandleTypeDef* hrng)
{
 8001a74:	b480      	push	{r7}
 8001a76:	b083      	sub	sp, #12
 8001a78:	af00      	add	r7, sp, #0
 8001a7a:	6078      	str	r0, [r7, #4]
  if(hrng->Instance==RNG)
 8001a7c:	687b      	ldr	r3, [r7, #4]
 8001a7e:	681b      	ldr	r3, [r3, #0]
 8001a80:	4a07      	ldr	r2, [pc, #28]	@ (8001aa0 <HAL_RNG_MspDeInit+0x2c>)
 8001a82:	4293      	cmp	r3, r2
 8001a84:	d105      	bne.n	8001a92 <HAL_RNG_MspDeInit+0x1e>
  {
    /* USER CODE BEGIN RNG_MspDeInit 0 */

    /* USER CODE END RNG_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_RNG_CLK_DISABLE();
 8001a86:	4b07      	ldr	r3, [pc, #28]	@ (8001aa4 <HAL_RNG_MspDeInit+0x30>)
 8001a88:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8001a8a:	4a06      	ldr	r2, [pc, #24]	@ (8001aa4 <HAL_RNG_MspDeInit+0x30>)
 8001a8c:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 8001a90:	6353      	str	r3, [r2, #52]	@ 0x34
    /* USER CODE BEGIN RNG_MspDeInit 1 */

    /* USER CODE END RNG_MspDeInit 1 */
  }

}
 8001a92:	bf00      	nop
 8001a94:	370c      	adds	r7, #12
 8001a96:	46bd      	mov	sp, r7
 8001a98:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001a9c:	4770      	bx	lr
 8001a9e:	bf00      	nop
 8001aa0:	50060800 	.word	0x50060800
 8001aa4:	40023800 	.word	0x40023800

08001aa8 <HAL_SPI_MspInit>:
  * This function configures the hardware resources used in this example
  * @param hspi: SPI handle pointer
  * @retval None
  */
void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
 8001aa8:	b580      	push	{r7, lr}
 8001aaa:	b08a      	sub	sp, #40	@ 0x28
 8001aac:	af00      	add	r7, sp, #0
 8001aae:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001ab0:	f107 0314 	add.w	r3, r7, #20
 8001ab4:	2200      	movs	r2, #0
 8001ab6:	601a      	str	r2, [r3, #0]
 8001ab8:	605a      	str	r2, [r3, #4]
 8001aba:	609a      	str	r2, [r3, #8]
 8001abc:	60da      	str	r2, [r3, #12]
 8001abe:	611a      	str	r2, [r3, #16]
  if(hspi->Instance==SPI1)
 8001ac0:	687b      	ldr	r3, [r7, #4]
 8001ac2:	681b      	ldr	r3, [r3, #0]
 8001ac4:	4a19      	ldr	r2, [pc, #100]	@ (8001b2c <HAL_SPI_MspInit+0x84>)
 8001ac6:	4293      	cmp	r3, r2
 8001ac8:	d12b      	bne.n	8001b22 <HAL_SPI_MspInit+0x7a>
  {
    /* USER CODE BEGIN SPI1_MspInit 0 */

    /* USER CODE END SPI1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_SPI1_CLK_ENABLE();
 8001aca:	2300      	movs	r3, #0
 8001acc:	613b      	str	r3, [r7, #16]
 8001ace:	4b18      	ldr	r3, [pc, #96]	@ (8001b30 <HAL_SPI_MspInit+0x88>)
 8001ad0:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8001ad2:	4a17      	ldr	r2, [pc, #92]	@ (8001b30 <HAL_SPI_MspInit+0x88>)
 8001ad4:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 8001ad8:	6453      	str	r3, [r2, #68]	@ 0x44
 8001ada:	4b15      	ldr	r3, [pc, #84]	@ (8001b30 <HAL_SPI_MspInit+0x88>)
 8001adc:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8001ade:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 8001ae2:	613b      	str	r3, [r7, #16]
 8001ae4:	693b      	ldr	r3, [r7, #16]

    __HAL_RCC_GPIOA_CLK_ENABLE();
 8001ae6:	2300      	movs	r3, #0
 8001ae8:	60fb      	str	r3, [r7, #12]
 8001aea:	4b11      	ldr	r3, [pc, #68]	@ (8001b30 <HAL_SPI_MspInit+0x88>)
 8001aec:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001aee:	4a10      	ldr	r2, [pc, #64]	@ (8001b30 <HAL_SPI_MspInit+0x88>)
 8001af0:	f043 0301 	orr.w	r3, r3, #1
 8001af4:	6313      	str	r3, [r2, #48]	@ 0x30
 8001af6:	4b0e      	ldr	r3, [pc, #56]	@ (8001b30 <HAL_SPI_MspInit+0x88>)
 8001af8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001afa:	f003 0301 	and.w	r3, r3, #1
 8001afe:	60fb      	str	r3, [r7, #12]
 8001b00:	68fb      	ldr	r3, [r7, #12]
    /**SPI1 GPIO Configuration
    PA5     ------> SPI1_SCK
    PA6     ------> SPI1_MISO
    PA7     ------> SPI1_MOSI
    */
    GPIO_InitStruct.Pin = SPI1_SCK_Pin|SPI1_MISO_Pin|SPI1_MOSI_Pin;
 8001b02:	23e0      	movs	r3, #224	@ 0xe0
 8001b04:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001b06:	2302      	movs	r3, #2
 8001b08:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001b0a:	2300      	movs	r3, #0
 8001b0c:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001b0e:	2300      	movs	r3, #0
 8001b10:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
 8001b12:	2305      	movs	r3, #5
 8001b14:	627b      	str	r3, [r7, #36]	@ 0x24
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001b16:	f107 0314 	add.w	r3, r7, #20
 8001b1a:	4619      	mov	r1, r3
 8001b1c:	4805      	ldr	r0, [pc, #20]	@ (8001b34 <HAL_SPI_MspInit+0x8c>)
 8001b1e:	f000 fa9f 	bl	8002060 <HAL_GPIO_Init>

    /* USER CODE END SPI1_MspInit 1 */

  }

}
 8001b22:	bf00      	nop
 8001b24:	3728      	adds	r7, #40	@ 0x28
 8001b26:	46bd      	mov	sp, r7
 8001b28:	bd80      	pop	{r7, pc}
 8001b2a:	bf00      	nop
 8001b2c:	40013000 	.word	0x40013000
 8001b30:	40023800 	.word	0x40023800
 8001b34:	40020000 	.word	0x40020000

08001b38 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 8001b38:	b480      	push	{r7}
 8001b3a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
 8001b3c:	bf00      	nop
 8001b3e:	e7fd      	b.n	8001b3c <NMI_Handler+0x4>

08001b40 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8001b40:	b480      	push	{r7}
 8001b42:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8001b44:	bf00      	nop
 8001b46:	e7fd      	b.n	8001b44 <HardFault_Handler+0x4>

08001b48 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8001b48:	b480      	push	{r7}
 8001b4a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8001b4c:	bf00      	nop
 8001b4e:	e7fd      	b.n	8001b4c <MemManage_Handler+0x4>

08001b50 <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 8001b50:	b480      	push	{r7}
 8001b52:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 8001b54:	bf00      	nop
 8001b56:	e7fd      	b.n	8001b54 <BusFault_Handler+0x4>

08001b58 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 8001b58:	b480      	push	{r7}
 8001b5a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8001b5c:	bf00      	nop
 8001b5e:	e7fd      	b.n	8001b5c <UsageFault_Handler+0x4>

08001b60 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 8001b60:	b480      	push	{r7}
 8001b62:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 8001b64:	bf00      	nop
 8001b66:	46bd      	mov	sp, r7
 8001b68:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001b6c:	4770      	bx	lr

08001b6e <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 8001b6e:	b480      	push	{r7}
 8001b70:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 8001b72:	bf00      	nop
 8001b74:	46bd      	mov	sp, r7
 8001b76:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001b7a:	4770      	bx	lr

08001b7c <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 8001b7c:	b480      	push	{r7}
 8001b7e:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 8001b80:	bf00      	nop
 8001b82:	46bd      	mov	sp, r7
 8001b84:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001b88:	4770      	bx	lr

08001b8a <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 8001b8a:	b580      	push	{r7, lr}
 8001b8c:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8001b8e:	f000 f8d1 	bl	8001d34 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 8001b92:	bf00      	nop
 8001b94:	bd80      	pop	{r7, pc}
	...

08001b98 <OTG_FS_IRQHandler>:

/**
  * @brief This function handles USB On The Go FS global interrupt.
  */
void OTG_FS_IRQHandler(void)
{
 8001b98:	b580      	push	{r7, lr}
 8001b9a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN OTG_FS_IRQn 0 */

  /* USER CODE END OTG_FS_IRQn 0 */
  HAL_PCD_IRQHandler(&hpcd_USB_OTG_FS);
 8001b9c:	4802      	ldr	r0, [pc, #8]	@ (8001ba8 <OTG_FS_IRQHandler+0x10>)
 8001b9e:	f001 fb55 	bl	800324c <HAL_PCD_IRQHandler>
  /* USER CODE BEGIN OTG_FS_IRQn 1 */

  /* USER CODE END OTG_FS_IRQn 1 */
}
 8001ba2:	bf00      	nop
 8001ba4:	bd80      	pop	{r7, pc}
 8001ba6:	bf00      	nop
 8001ba8:	20003df4 	.word	0x20003df4

08001bac <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 8001bac:	b580      	push	{r7, lr}
 8001bae:	b086      	sub	sp, #24
 8001bb0:	af00      	add	r7, sp, #0
 8001bb2:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8001bb4:	4a14      	ldr	r2, [pc, #80]	@ (8001c08 <_sbrk+0x5c>)
 8001bb6:	4b15      	ldr	r3, [pc, #84]	@ (8001c0c <_sbrk+0x60>)
 8001bb8:	1ad3      	subs	r3, r2, r3
 8001bba:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
 8001bbc:	697b      	ldr	r3, [r7, #20]
 8001bbe:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 8001bc0:	4b13      	ldr	r3, [pc, #76]	@ (8001c10 <_sbrk+0x64>)
 8001bc2:	681b      	ldr	r3, [r3, #0]
 8001bc4:	2b00      	cmp	r3, #0
 8001bc6:	d102      	bne.n	8001bce <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
 8001bc8:	4b11      	ldr	r3, [pc, #68]	@ (8001c10 <_sbrk+0x64>)
 8001bca:	4a12      	ldr	r2, [pc, #72]	@ (8001c14 <_sbrk+0x68>)
 8001bcc:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 8001bce:	4b10      	ldr	r3, [pc, #64]	@ (8001c10 <_sbrk+0x64>)
 8001bd0:	681a      	ldr	r2, [r3, #0]
 8001bd2:	687b      	ldr	r3, [r7, #4]
 8001bd4:	4413      	add	r3, r2
 8001bd6:	693a      	ldr	r2, [r7, #16]
 8001bd8:	429a      	cmp	r2, r3
 8001bda:	d207      	bcs.n	8001bec <_sbrk+0x40>
  {
    errno = ENOMEM;
 8001bdc:	f026 fcb2 	bl	8028544 <__errno>
 8001be0:	4603      	mov	r3, r0
 8001be2:	220c      	movs	r2, #12
 8001be4:	601a      	str	r2, [r3, #0]
    return (void *)-1;
 8001be6:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8001bea:	e009      	b.n	8001c00 <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
 8001bec:	4b08      	ldr	r3, [pc, #32]	@ (8001c10 <_sbrk+0x64>)
 8001bee:	681b      	ldr	r3, [r3, #0]
 8001bf0:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
 8001bf2:	4b07      	ldr	r3, [pc, #28]	@ (8001c10 <_sbrk+0x64>)
 8001bf4:	681a      	ldr	r2, [r3, #0]
 8001bf6:	687b      	ldr	r3, [r7, #4]
 8001bf8:	4413      	add	r3, r2
 8001bfa:	4a05      	ldr	r2, [pc, #20]	@ (8001c10 <_sbrk+0x64>)
 8001bfc:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
 8001bfe:	68fb      	ldr	r3, [r7, #12]
}
 8001c00:	4618      	mov	r0, r3
 8001c02:	3718      	adds	r7, #24
 8001c04:	46bd      	mov	sp, r7
 8001c06:	bd80      	pop	{r7, pc}
 8001c08:	20020000 	.word	0x20020000
 8001c0c:	00000400 	.word	0x00000400
 8001c10:	2000289c 	.word	0x2000289c
 8001c14:	20004640 	.word	0x20004640

08001c18 <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 8001c18:	b480      	push	{r7}
 8001c1a:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8001c1c:	4b06      	ldr	r3, [pc, #24]	@ (8001c38 <SystemInit+0x20>)
 8001c1e:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8001c22:	4a05      	ldr	r2, [pc, #20]	@ (8001c38 <SystemInit+0x20>)
 8001c24:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 8001c28:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#endif /* USER_VECT_TAB_ADDRESS */
}
 8001c2c:	bf00      	nop
 8001c2e:	46bd      	mov	sp, r7
 8001c30:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001c34:	4770      	bx	lr
 8001c36:	bf00      	nop
 8001c38:	e000ed00 	.word	0xe000ed00

08001c3c <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack     /* set stack pointer */
 8001c3c:	f8df d034 	ldr.w	sp, [pc, #52]	@ 8001c74 <LoopFillZerobss+0xe>
  
/* Call the clock system initialization function.*/
  bl  SystemInit  
 8001c40:	f7ff ffea 	bl	8001c18 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */  
  ldr r0, =_sdata
 8001c44:	480c      	ldr	r0, [pc, #48]	@ (8001c78 <LoopFillZerobss+0x12>)
  ldr r1, =_edata
 8001c46:	490d      	ldr	r1, [pc, #52]	@ (8001c7c <LoopFillZerobss+0x16>)
  ldr r2, =_sidata
 8001c48:	4a0d      	ldr	r2, [pc, #52]	@ (8001c80 <LoopFillZerobss+0x1a>)
  movs r3, #0
 8001c4a:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8001c4c:	e002      	b.n	8001c54 <LoopCopyDataInit>

08001c4e <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8001c4e:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8001c50:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8001c52:	3304      	adds	r3, #4

08001c54 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8001c54:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8001c56:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8001c58:	d3f9      	bcc.n	8001c4e <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8001c5a:	4a0a      	ldr	r2, [pc, #40]	@ (8001c84 <LoopFillZerobss+0x1e>)
  ldr r4, =_ebss
 8001c5c:	4c0a      	ldr	r4, [pc, #40]	@ (8001c88 <LoopFillZerobss+0x22>)
  movs r3, #0
 8001c5e:	2300      	movs	r3, #0
  b LoopFillZerobss
 8001c60:	e001      	b.n	8001c66 <LoopFillZerobss>

08001c62 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8001c62:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8001c64:	3204      	adds	r2, #4

08001c66 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8001c66:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8001c68:	d3fb      	bcc.n	8001c62 <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
 8001c6a:	f026 fc71 	bl	8028550 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8001c6e:	f7ff fb83 	bl	8001378 <main>
  bx  lr    
 8001c72:	4770      	bx	lr
  ldr   sp, =_estack     /* set stack pointer */
 8001c74:	20020000 	.word	0x20020000
  ldr r0, =_sdata
 8001c78:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8001c7c:	20000184 	.word	0x20000184
  ldr r2, =_sidata
 8001c80:	08033f4c 	.word	0x08033f4c
  ldr r2, =_sbss
 8001c84:	20000184 	.word	0x20000184
  ldr r4, =_ebss
 8001c88:	20004640 	.word	0x20004640

08001c8c <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8001c8c:	e7fe      	b.n	8001c8c <ADC_IRQHandler>
	...

08001c90 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8001c90:	b580      	push	{r7, lr}
 8001c92:	af00      	add	r7, sp, #0
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
  __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 8001c94:	4b0e      	ldr	r3, [pc, #56]	@ (8001cd0 <HAL_Init+0x40>)
 8001c96:	681b      	ldr	r3, [r3, #0]
 8001c98:	4a0d      	ldr	r2, [pc, #52]	@ (8001cd0 <HAL_Init+0x40>)
 8001c9a:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 8001c9e:	6013      	str	r3, [r2, #0]
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
  __HAL_FLASH_DATA_CACHE_ENABLE();
 8001ca0:	4b0b      	ldr	r3, [pc, #44]	@ (8001cd0 <HAL_Init+0x40>)
 8001ca2:	681b      	ldr	r3, [r3, #0]
 8001ca4:	4a0a      	ldr	r2, [pc, #40]	@ (8001cd0 <HAL_Init+0x40>)
 8001ca6:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 8001caa:	6013      	str	r3, [r2, #0]
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8001cac:	4b08      	ldr	r3, [pc, #32]	@ (8001cd0 <HAL_Init+0x40>)
 8001cae:	681b      	ldr	r3, [r3, #0]
 8001cb0:	4a07      	ldr	r2, [pc, #28]	@ (8001cd0 <HAL_Init+0x40>)
 8001cb2:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8001cb6:	6013      	str	r3, [r2, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8001cb8:	2003      	movs	r0, #3
 8001cba:	f000 f973 	bl	8001fa4 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 8001cbe:	2000      	movs	r0, #0
 8001cc0:	f000 f808 	bl	8001cd4 <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 8001cc4:	f7ff fda2 	bl	800180c <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
 8001cc8:	2300      	movs	r3, #0
}
 8001cca:	4618      	mov	r0, r3
 8001ccc:	bd80      	pop	{r7, pc}
 8001cce:	bf00      	nop
 8001cd0:	40023c00 	.word	0x40023c00

08001cd4 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8001cd4:	b580      	push	{r7, lr}
 8001cd6:	b082      	sub	sp, #8
 8001cd8:	af00      	add	r7, sp, #0
 8001cda:	6078      	str	r0, [r7, #4]
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8001cdc:	4b12      	ldr	r3, [pc, #72]	@ (8001d28 <HAL_InitTick+0x54>)
 8001cde:	681a      	ldr	r2, [r3, #0]
 8001ce0:	4b12      	ldr	r3, [pc, #72]	@ (8001d2c <HAL_InitTick+0x58>)
 8001ce2:	781b      	ldrb	r3, [r3, #0]
 8001ce4:	4619      	mov	r1, r3
 8001ce6:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 8001cea:	fbb3 f3f1 	udiv	r3, r3, r1
 8001cee:	fbb2 f3f3 	udiv	r3, r2, r3
 8001cf2:	4618      	mov	r0, r3
 8001cf4:	f000 f98b 	bl	800200e <HAL_SYSTICK_Config>
 8001cf8:	4603      	mov	r3, r0
 8001cfa:	2b00      	cmp	r3, #0
 8001cfc:	d001      	beq.n	8001d02 <HAL_InitTick+0x2e>
  {
    return HAL_ERROR;
 8001cfe:	2301      	movs	r3, #1
 8001d00:	e00e      	b.n	8001d20 <HAL_InitTick+0x4c>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8001d02:	687b      	ldr	r3, [r7, #4]
 8001d04:	2b0f      	cmp	r3, #15
 8001d06:	d80a      	bhi.n	8001d1e <HAL_InitTick+0x4a>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8001d08:	2200      	movs	r2, #0
 8001d0a:	6879      	ldr	r1, [r7, #4]
 8001d0c:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8001d10:	f000 f953 	bl	8001fba <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 8001d14:	4a06      	ldr	r2, [pc, #24]	@ (8001d30 <HAL_InitTick+0x5c>)
 8001d16:	687b      	ldr	r3, [r7, #4]
 8001d18:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
 8001d1a:	2300      	movs	r3, #0
 8001d1c:	e000      	b.n	8001d20 <HAL_InitTick+0x4c>
    return HAL_ERROR;
 8001d1e:	2301      	movs	r3, #1
}
 8001d20:	4618      	mov	r0, r3
 8001d22:	3708      	adds	r7, #8
 8001d24:	46bd      	mov	sp, r7
 8001d26:	bd80      	pop	{r7, pc}
 8001d28:	20000018 	.word	0x20000018
 8001d2c:	20000020 	.word	0x20000020
 8001d30:	2000001c 	.word	0x2000001c

08001d34 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other 
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 8001d34:	b480      	push	{r7}
 8001d36:	af00      	add	r7, sp, #0
  uwTick += uwTickFreq;
 8001d38:	4b06      	ldr	r3, [pc, #24]	@ (8001d54 <HAL_IncTick+0x20>)
 8001d3a:	781b      	ldrb	r3, [r3, #0]
 8001d3c:	461a      	mov	r2, r3
 8001d3e:	4b06      	ldr	r3, [pc, #24]	@ (8001d58 <HAL_IncTick+0x24>)
 8001d40:	681b      	ldr	r3, [r3, #0]
 8001d42:	4413      	add	r3, r2
 8001d44:	4a04      	ldr	r2, [pc, #16]	@ (8001d58 <HAL_IncTick+0x24>)
 8001d46:	6013      	str	r3, [r2, #0]
}
 8001d48:	bf00      	nop
 8001d4a:	46bd      	mov	sp, r7
 8001d4c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001d50:	4770      	bx	lr
 8001d52:	bf00      	nop
 8001d54:	20000020 	.word	0x20000020
 8001d58:	200028a0 	.word	0x200028a0

08001d5c <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other 
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 8001d5c:	b480      	push	{r7}
 8001d5e:	af00      	add	r7, sp, #0
  return uwTick;
 8001d60:	4b03      	ldr	r3, [pc, #12]	@ (8001d70 <HAL_GetTick+0x14>)
 8001d62:	681b      	ldr	r3, [r3, #0]
}
 8001d64:	4618      	mov	r0, r3
 8001d66:	46bd      	mov	sp, r7
 8001d68:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001d6c:	4770      	bx	lr
 8001d6e:	bf00      	nop
 8001d70:	200028a0 	.word	0x200028a0

08001d74 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8001d74:	b580      	push	{r7, lr}
 8001d76:	b084      	sub	sp, #16
 8001d78:	af00      	add	r7, sp, #0
 8001d7a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
 8001d7c:	f7ff ffee 	bl	8001d5c <HAL_GetTick>
 8001d80:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
 8001d82:	687b      	ldr	r3, [r7, #4]
 8001d84:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 8001d86:	68fb      	ldr	r3, [r7, #12]
 8001d88:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8001d8c:	d005      	beq.n	8001d9a <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
 8001d8e:	4b0a      	ldr	r3, [pc, #40]	@ (8001db8 <HAL_Delay+0x44>)
 8001d90:	781b      	ldrb	r3, [r3, #0]
 8001d92:	461a      	mov	r2, r3
 8001d94:	68fb      	ldr	r3, [r7, #12]
 8001d96:	4413      	add	r3, r2
 8001d98:	60fb      	str	r3, [r7, #12]
  }

  while((HAL_GetTick() - tickstart) < wait)
 8001d9a:	bf00      	nop
 8001d9c:	f7ff ffde 	bl	8001d5c <HAL_GetTick>
 8001da0:	4602      	mov	r2, r0
 8001da2:	68bb      	ldr	r3, [r7, #8]
 8001da4:	1ad3      	subs	r3, r2, r3
 8001da6:	68fa      	ldr	r2, [r7, #12]
 8001da8:	429a      	cmp	r2, r3
 8001daa:	d8f7      	bhi.n	8001d9c <HAL_Delay+0x28>
  {
  }
}
 8001dac:	bf00      	nop
 8001dae:	bf00      	nop
 8001db0:	3710      	adds	r7, #16
 8001db2:	46bd      	mov	sp, r7
 8001db4:	bd80      	pop	{r7, pc}
 8001db6:	bf00      	nop
 8001db8:	20000020 	.word	0x20000020

08001dbc <HAL_GetUIDw0>:
/**
  * @brief  Returns first word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw0(void)
{
 8001dbc:	b480      	push	{r7}
 8001dbe:	af00      	add	r7, sp, #0
  return (READ_REG(*((uint32_t *)UID_BASE)));
 8001dc0:	4b03      	ldr	r3, [pc, #12]	@ (8001dd0 <HAL_GetUIDw0+0x14>)
 8001dc2:	681b      	ldr	r3, [r3, #0]
}
 8001dc4:	4618      	mov	r0, r3
 8001dc6:	46bd      	mov	sp, r7
 8001dc8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001dcc:	4770      	bx	lr
 8001dce:	bf00      	nop
 8001dd0:	1fff7a10 	.word	0x1fff7a10

08001dd4 <HAL_GetUIDw1>:
/**
  * @brief  Returns second word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw1(void)
{
 8001dd4:	b480      	push	{r7}
 8001dd6:	af00      	add	r7, sp, #0
  return (READ_REG(*((uint32_t *)(UID_BASE + 4U))));
 8001dd8:	4b03      	ldr	r3, [pc, #12]	@ (8001de8 <HAL_GetUIDw1+0x14>)
 8001dda:	681b      	ldr	r3, [r3, #0]
}
 8001ddc:	4618      	mov	r0, r3
 8001dde:	46bd      	mov	sp, r7
 8001de0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001de4:	4770      	bx	lr
 8001de6:	bf00      	nop
 8001de8:	1fff7a14 	.word	0x1fff7a14

08001dec <HAL_GetUIDw2>:
/**
  * @brief  Returns third word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw2(void)
{
 8001dec:	b480      	push	{r7}
 8001dee:	af00      	add	r7, sp, #0
  return (READ_REG(*((uint32_t *)(UID_BASE + 8U))));
 8001df0:	4b03      	ldr	r3, [pc, #12]	@ (8001e00 <HAL_GetUIDw2+0x14>)
 8001df2:	681b      	ldr	r3, [r3, #0]
}
 8001df4:	4618      	mov	r0, r3
 8001df6:	46bd      	mov	sp, r7
 8001df8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001dfc:	4770      	bx	lr
 8001dfe:	bf00      	nop
 8001e00:	1fff7a18 	.word	0x1fff7a18

08001e04 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8001e04:	b480      	push	{r7}
 8001e06:	b085      	sub	sp, #20
 8001e08:	af00      	add	r7, sp, #0
 8001e0a:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8001e0c:	687b      	ldr	r3, [r7, #4]
 8001e0e:	f003 0307 	and.w	r3, r3, #7
 8001e12:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8001e14:	4b0c      	ldr	r3, [pc, #48]	@ (8001e48 <__NVIC_SetPriorityGrouping+0x44>)
 8001e16:	68db      	ldr	r3, [r3, #12]
 8001e18:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8001e1a:	68ba      	ldr	r2, [r7, #8]
 8001e1c:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
 8001e20:	4013      	ands	r3, r2
 8001e22:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8001e24:	68fb      	ldr	r3, [r7, #12]
 8001e26:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8001e28:	68bb      	ldr	r3, [r7, #8]
 8001e2a:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8001e2c:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 8001e30:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8001e34:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 8001e36:	4a04      	ldr	r2, [pc, #16]	@ (8001e48 <__NVIC_SetPriorityGrouping+0x44>)
 8001e38:	68bb      	ldr	r3, [r7, #8]
 8001e3a:	60d3      	str	r3, [r2, #12]
}
 8001e3c:	bf00      	nop
 8001e3e:	3714      	adds	r7, #20
 8001e40:	46bd      	mov	sp, r7
 8001e42:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001e46:	4770      	bx	lr
 8001e48:	e000ed00 	.word	0xe000ed00

08001e4c <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 8001e4c:	b480      	push	{r7}
 8001e4e:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8001e50:	4b04      	ldr	r3, [pc, #16]	@ (8001e64 <__NVIC_GetPriorityGrouping+0x18>)
 8001e52:	68db      	ldr	r3, [r3, #12]
 8001e54:	0a1b      	lsrs	r3, r3, #8
 8001e56:	f003 0307 	and.w	r3, r3, #7
}
 8001e5a:	4618      	mov	r0, r3
 8001e5c:	46bd      	mov	sp, r7
 8001e5e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001e62:	4770      	bx	lr
 8001e64:	e000ed00 	.word	0xe000ed00

08001e68 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8001e68:	b480      	push	{r7}
 8001e6a:	b083      	sub	sp, #12
 8001e6c:	af00      	add	r7, sp, #0
 8001e6e:	4603      	mov	r3, r0
 8001e70:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8001e72:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001e76:	2b00      	cmp	r3, #0
 8001e78:	db0b      	blt.n	8001e92 <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8001e7a:	79fb      	ldrb	r3, [r7, #7]
 8001e7c:	f003 021f 	and.w	r2, r3, #31
 8001e80:	4907      	ldr	r1, [pc, #28]	@ (8001ea0 <__NVIC_EnableIRQ+0x38>)
 8001e82:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001e86:	095b      	lsrs	r3, r3, #5
 8001e88:	2001      	movs	r0, #1
 8001e8a:	fa00 f202 	lsl.w	r2, r0, r2
 8001e8e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
 8001e92:	bf00      	nop
 8001e94:	370c      	adds	r7, #12
 8001e96:	46bd      	mov	sp, r7
 8001e98:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001e9c:	4770      	bx	lr
 8001e9e:	bf00      	nop
 8001ea0:	e000e100 	.word	0xe000e100

08001ea4 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8001ea4:	b480      	push	{r7}
 8001ea6:	b083      	sub	sp, #12
 8001ea8:	af00      	add	r7, sp, #0
 8001eaa:	4603      	mov	r3, r0
 8001eac:	6039      	str	r1, [r7, #0]
 8001eae:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8001eb0:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001eb4:	2b00      	cmp	r3, #0
 8001eb6:	db0a      	blt.n	8001ece <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001eb8:	683b      	ldr	r3, [r7, #0]
 8001eba:	b2da      	uxtb	r2, r3
 8001ebc:	490c      	ldr	r1, [pc, #48]	@ (8001ef0 <__NVIC_SetPriority+0x4c>)
 8001ebe:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001ec2:	0112      	lsls	r2, r2, #4
 8001ec4:	b2d2      	uxtb	r2, r2
 8001ec6:	440b      	add	r3, r1
 8001ec8:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 8001ecc:	e00a      	b.n	8001ee4 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001ece:	683b      	ldr	r3, [r7, #0]
 8001ed0:	b2da      	uxtb	r2, r3
 8001ed2:	4908      	ldr	r1, [pc, #32]	@ (8001ef4 <__NVIC_SetPriority+0x50>)
 8001ed4:	79fb      	ldrb	r3, [r7, #7]
 8001ed6:	f003 030f 	and.w	r3, r3, #15
 8001eda:	3b04      	subs	r3, #4
 8001edc:	0112      	lsls	r2, r2, #4
 8001ede:	b2d2      	uxtb	r2, r2
 8001ee0:	440b      	add	r3, r1
 8001ee2:	761a      	strb	r2, [r3, #24]
}
 8001ee4:	bf00      	nop
 8001ee6:	370c      	adds	r7, #12
 8001ee8:	46bd      	mov	sp, r7
 8001eea:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001eee:	4770      	bx	lr
 8001ef0:	e000e100 	.word	0xe000e100
 8001ef4:	e000ed00 	.word	0xe000ed00

08001ef8 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8001ef8:	b480      	push	{r7}
 8001efa:	b089      	sub	sp, #36	@ 0x24
 8001efc:	af00      	add	r7, sp, #0
 8001efe:	60f8      	str	r0, [r7, #12]
 8001f00:	60b9      	str	r1, [r7, #8]
 8001f02:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8001f04:	68fb      	ldr	r3, [r7, #12]
 8001f06:	f003 0307 	and.w	r3, r3, #7
 8001f0a:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8001f0c:	69fb      	ldr	r3, [r7, #28]
 8001f0e:	f1c3 0307 	rsb	r3, r3, #7
 8001f12:	2b04      	cmp	r3, #4
 8001f14:	bf28      	it	cs
 8001f16:	2304      	movcs	r3, #4
 8001f18:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001f1a:	69fb      	ldr	r3, [r7, #28]
 8001f1c:	3304      	adds	r3, #4
 8001f1e:	2b06      	cmp	r3, #6
 8001f20:	d902      	bls.n	8001f28 <NVIC_EncodePriority+0x30>
 8001f22:	69fb      	ldr	r3, [r7, #28]
 8001f24:	3b03      	subs	r3, #3
 8001f26:	e000      	b.n	8001f2a <NVIC_EncodePriority+0x32>
 8001f28:	2300      	movs	r3, #0
 8001f2a:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001f2c:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8001f30:	69bb      	ldr	r3, [r7, #24]
 8001f32:	fa02 f303 	lsl.w	r3, r2, r3
 8001f36:	43da      	mvns	r2, r3
 8001f38:	68bb      	ldr	r3, [r7, #8]
 8001f3a:	401a      	ands	r2, r3
 8001f3c:	697b      	ldr	r3, [r7, #20]
 8001f3e:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8001f40:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
 8001f44:	697b      	ldr	r3, [r7, #20]
 8001f46:	fa01 f303 	lsl.w	r3, r1, r3
 8001f4a:	43d9      	mvns	r1, r3
 8001f4c:	687b      	ldr	r3, [r7, #4]
 8001f4e:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001f50:	4313      	orrs	r3, r2
         );
}
 8001f52:	4618      	mov	r0, r3
 8001f54:	3724      	adds	r7, #36	@ 0x24
 8001f56:	46bd      	mov	sp, r7
 8001f58:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001f5c:	4770      	bx	lr
	...

08001f60 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 8001f60:	b580      	push	{r7, lr}
 8001f62:	b082      	sub	sp, #8
 8001f64:	af00      	add	r7, sp, #0
 8001f66:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8001f68:	687b      	ldr	r3, [r7, #4]
 8001f6a:	3b01      	subs	r3, #1
 8001f6c:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 8001f70:	d301      	bcc.n	8001f76 <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 8001f72:	2301      	movs	r3, #1
 8001f74:	e00f      	b.n	8001f96 <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8001f76:	4a0a      	ldr	r2, [pc, #40]	@ (8001fa0 <SysTick_Config+0x40>)
 8001f78:	687b      	ldr	r3, [r7, #4]
 8001f7a:	3b01      	subs	r3, #1
 8001f7c:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 8001f7e:	210f      	movs	r1, #15
 8001f80:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8001f84:	f7ff ff8e 	bl	8001ea4 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8001f88:	4b05      	ldr	r3, [pc, #20]	@ (8001fa0 <SysTick_Config+0x40>)
 8001f8a:	2200      	movs	r2, #0
 8001f8c:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8001f8e:	4b04      	ldr	r3, [pc, #16]	@ (8001fa0 <SysTick_Config+0x40>)
 8001f90:	2207      	movs	r2, #7
 8001f92:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8001f94:	2300      	movs	r3, #0
}
 8001f96:	4618      	mov	r0, r3
 8001f98:	3708      	adds	r7, #8
 8001f9a:	46bd      	mov	sp, r7
 8001f9c:	bd80      	pop	{r7, pc}
 8001f9e:	bf00      	nop
 8001fa0:	e000e010 	.word	0xe000e010

08001fa4 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8001fa4:	b580      	push	{r7, lr}
 8001fa6:	b082      	sub	sp, #8
 8001fa8:	af00      	add	r7, sp, #0
 8001faa:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 8001fac:	6878      	ldr	r0, [r7, #4]
 8001fae:	f7ff ff29 	bl	8001e04 <__NVIC_SetPriorityGrouping>
}
 8001fb2:	bf00      	nop
 8001fb4:	3708      	adds	r7, #8
 8001fb6:	46bd      	mov	sp, r7
 8001fb8:	bd80      	pop	{r7, pc}

08001fba <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8001fba:	b580      	push	{r7, lr}
 8001fbc:	b086      	sub	sp, #24
 8001fbe:	af00      	add	r7, sp, #0
 8001fc0:	4603      	mov	r3, r0
 8001fc2:	60b9      	str	r1, [r7, #8]
 8001fc4:	607a      	str	r2, [r7, #4]
 8001fc6:	73fb      	strb	r3, [r7, #15]
  uint32_t prioritygroup = 0x00U;
 8001fc8:	2300      	movs	r3, #0
 8001fca:	617b      	str	r3, [r7, #20]
  
  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
 8001fcc:	f7ff ff3e 	bl	8001e4c <__NVIC_GetPriorityGrouping>
 8001fd0:	6178      	str	r0, [r7, #20]
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 8001fd2:	687a      	ldr	r2, [r7, #4]
 8001fd4:	68b9      	ldr	r1, [r7, #8]
 8001fd6:	6978      	ldr	r0, [r7, #20]
 8001fd8:	f7ff ff8e 	bl	8001ef8 <NVIC_EncodePriority>
 8001fdc:	4602      	mov	r2, r0
 8001fde:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8001fe2:	4611      	mov	r1, r2
 8001fe4:	4618      	mov	r0, r3
 8001fe6:	f7ff ff5d 	bl	8001ea4 <__NVIC_SetPriority>
}
 8001fea:	bf00      	nop
 8001fec:	3718      	adds	r7, #24
 8001fee:	46bd      	mov	sp, r7
 8001ff0:	bd80      	pop	{r7, pc}

08001ff2 <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f4xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8001ff2:	b580      	push	{r7, lr}
 8001ff4:	b082      	sub	sp, #8
 8001ff6:	af00      	add	r7, sp, #0
 8001ff8:	4603      	mov	r3, r0
 8001ffa:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 8001ffc:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8002000:	4618      	mov	r0, r3
 8002002:	f7ff ff31 	bl	8001e68 <__NVIC_EnableIRQ>
}
 8002006:	bf00      	nop
 8002008:	3708      	adds	r7, #8
 800200a:	46bd      	mov	sp, r7
 800200c:	bd80      	pop	{r7, pc}

0800200e <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 800200e:	b580      	push	{r7, lr}
 8002010:	b082      	sub	sp, #8
 8002012:	af00      	add	r7, sp, #0
 8002014:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 8002016:	6878      	ldr	r0, [r7, #4]
 8002018:	f7ff ffa2 	bl	8001f60 <SysTick_Config>
 800201c:	4603      	mov	r3, r0
}
 800201e:	4618      	mov	r0, r3
 8002020:	3708      	adds	r7, #8
 8002022:	46bd      	mov	sp, r7
 8002024:	bd80      	pop	{r7, pc}

08002026 <HAL_CRC_Init>:
  *         parameters in the CRC_InitTypeDef and create the associated handle.
  * @param  hcrc CRC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CRC_Init(CRC_HandleTypeDef *hcrc)
{
 8002026:	b580      	push	{r7, lr}
 8002028:	b082      	sub	sp, #8
 800202a:	af00      	add	r7, sp, #0
 800202c:	6078      	str	r0, [r7, #4]
  /* Check the CRC handle allocation */
  if (hcrc == NULL)
 800202e:	687b      	ldr	r3, [r7, #4]
 8002030:	2b00      	cmp	r3, #0
 8002032:	d101      	bne.n	8002038 <HAL_CRC_Init+0x12>
  {
    return HAL_ERROR;
 8002034:	2301      	movs	r3, #1
 8002036:	e00e      	b.n	8002056 <HAL_CRC_Init+0x30>
  }

  /* Check the parameters */
  assert_param(IS_CRC_ALL_INSTANCE(hcrc->Instance));

  if (hcrc->State == HAL_CRC_STATE_RESET)
 8002038:	687b      	ldr	r3, [r7, #4]
 800203a:	795b      	ldrb	r3, [r3, #5]
 800203c:	b2db      	uxtb	r3, r3
 800203e:	2b00      	cmp	r3, #0
 8002040:	d105      	bne.n	800204e <HAL_CRC_Init+0x28>
  {
    /* Allocate lock resource and initialize it */
    hcrc->Lock = HAL_UNLOCKED;
 8002042:	687b      	ldr	r3, [r7, #4]
 8002044:	2200      	movs	r2, #0
 8002046:	711a      	strb	r2, [r3, #4]
    /* Init the low level hardware */
    HAL_CRC_MspInit(hcrc);
 8002048:	6878      	ldr	r0, [r7, #4]
 800204a:	f7ff fc07 	bl	800185c <HAL_CRC_MspInit>
  }

  /* Change CRC peripheral state */
  hcrc->State = HAL_CRC_STATE_READY;
 800204e:	687b      	ldr	r3, [r7, #4]
 8002050:	2201      	movs	r2, #1
 8002052:	715a      	strb	r2, [r3, #5]

  /* Return function status */
  return HAL_OK;
 8002054:	2300      	movs	r3, #0
}
 8002056:	4618      	mov	r0, r3
 8002058:	3708      	adds	r7, #8
 800205a:	46bd      	mov	sp, r7
 800205c:	bd80      	pop	{r7, pc}
	...

08002060 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8002060:	b480      	push	{r7}
 8002062:	b089      	sub	sp, #36	@ 0x24
 8002064:	af00      	add	r7, sp, #0
 8002066:	6078      	str	r0, [r7, #4]
 8002068:	6039      	str	r1, [r7, #0]
  uint32_t position;
  uint32_t ioposition = 0x00U;
 800206a:	2300      	movs	r3, #0
 800206c:	617b      	str	r3, [r7, #20]
  uint32_t iocurrent = 0x00U;
 800206e:	2300      	movs	r3, #0
 8002070:	613b      	str	r3, [r7, #16]
  uint32_t temp = 0x00U;
 8002072:	2300      	movs	r3, #0
 8002074:	61bb      	str	r3, [r7, #24]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 8002076:	2300      	movs	r3, #0
 8002078:	61fb      	str	r3, [r7, #28]
 800207a:	e16b      	b.n	8002354 <HAL_GPIO_Init+0x2f4>
  {
    /* Get the IO position */
    ioposition = 0x01U << position;
 800207c:	2201      	movs	r2, #1
 800207e:	69fb      	ldr	r3, [r7, #28]
 8002080:	fa02 f303 	lsl.w	r3, r2, r3
 8002084:	617b      	str	r3, [r7, #20]
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8002086:	683b      	ldr	r3, [r7, #0]
 8002088:	681b      	ldr	r3, [r3, #0]
 800208a:	697a      	ldr	r2, [r7, #20]
 800208c:	4013      	ands	r3, r2
 800208e:	613b      	str	r3, [r7, #16]

    if(iocurrent == ioposition)
 8002090:	693a      	ldr	r2, [r7, #16]
 8002092:	697b      	ldr	r3, [r7, #20]
 8002094:	429a      	cmp	r2, r3
 8002096:	f040 815a 	bne.w	800234e <HAL_GPIO_Init+0x2ee>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || \
 800209a:	683b      	ldr	r3, [r7, #0]
 800209c:	685b      	ldr	r3, [r3, #4]
 800209e:	f003 0303 	and.w	r3, r3, #3
 80020a2:	2b01      	cmp	r3, #1
 80020a4:	d005      	beq.n	80020b2 <HAL_GPIO_Init+0x52>
          (GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 80020a6:	683b      	ldr	r3, [r7, #0]
 80020a8:	685b      	ldr	r3, [r3, #4]
 80020aa:	f003 0303 	and.w	r3, r3, #3
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || \
 80020ae:	2b02      	cmp	r3, #2
 80020b0:	d130      	bne.n	8002114 <HAL_GPIO_Init+0xb4>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
 80020b2:	687b      	ldr	r3, [r7, #4]
 80020b4:	689b      	ldr	r3, [r3, #8]
 80020b6:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 80020b8:	69fb      	ldr	r3, [r7, #28]
 80020ba:	005b      	lsls	r3, r3, #1
 80020bc:	2203      	movs	r2, #3
 80020be:	fa02 f303 	lsl.w	r3, r2, r3
 80020c2:	43db      	mvns	r3, r3
 80020c4:	69ba      	ldr	r2, [r7, #24]
 80020c6:	4013      	ands	r3, r2
 80020c8:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_Init->Speed << (position * 2U));
 80020ca:	683b      	ldr	r3, [r7, #0]
 80020cc:	68da      	ldr	r2, [r3, #12]
 80020ce:	69fb      	ldr	r3, [r7, #28]
 80020d0:	005b      	lsls	r3, r3, #1
 80020d2:	fa02 f303 	lsl.w	r3, r2, r3
 80020d6:	69ba      	ldr	r2, [r7, #24]
 80020d8:	4313      	orrs	r3, r2
 80020da:	61bb      	str	r3, [r7, #24]
        GPIOx->OSPEEDR = temp;
 80020dc:	687b      	ldr	r3, [r7, #4]
 80020de:	69ba      	ldr	r2, [r7, #24]
 80020e0:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 80020e2:	687b      	ldr	r3, [r7, #4]
 80020e4:	685b      	ldr	r3, [r3, #4]
 80020e6:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 80020e8:	2201      	movs	r2, #1
 80020ea:	69fb      	ldr	r3, [r7, #28]
 80020ec:	fa02 f303 	lsl.w	r3, r2, r3
 80020f0:	43db      	mvns	r3, r3
 80020f2:	69ba      	ldr	r2, [r7, #24]
 80020f4:	4013      	ands	r3, r2
 80020f6:	61bb      	str	r3, [r7, #24]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 80020f8:	683b      	ldr	r3, [r7, #0]
 80020fa:	685b      	ldr	r3, [r3, #4]
 80020fc:	091b      	lsrs	r3, r3, #4
 80020fe:	f003 0201 	and.w	r2, r3, #1
 8002102:	69fb      	ldr	r3, [r7, #28]
 8002104:	fa02 f303 	lsl.w	r3, r2, r3
 8002108:	69ba      	ldr	r2, [r7, #24]
 800210a:	4313      	orrs	r3, r2
 800210c:	61bb      	str	r3, [r7, #24]
        GPIOx->OTYPER = temp;
 800210e:	687b      	ldr	r3, [r7, #4]
 8002110:	69ba      	ldr	r2, [r7, #24]
 8002112:	605a      	str	r2, [r3, #4]
       }

      if((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 8002114:	683b      	ldr	r3, [r7, #0]
 8002116:	685b      	ldr	r3, [r3, #4]
 8002118:	f003 0303 	and.w	r3, r3, #3
 800211c:	2b03      	cmp	r3, #3
 800211e:	d017      	beq.n	8002150 <HAL_GPIO_Init+0xf0>
      {
        /* Check the parameters */
        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
        
        /* Activate the Pull-up or Pull down resistor for the current IO */
        temp = GPIOx->PUPDR;
 8002120:	687b      	ldr	r3, [r7, #4]
 8002122:	68db      	ldr	r3, [r3, #12]
 8002124:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 8002126:	69fb      	ldr	r3, [r7, #28]
 8002128:	005b      	lsls	r3, r3, #1
 800212a:	2203      	movs	r2, #3
 800212c:	fa02 f303 	lsl.w	r3, r2, r3
 8002130:	43db      	mvns	r3, r3
 8002132:	69ba      	ldr	r2, [r7, #24]
 8002134:	4013      	ands	r3, r2
 8002136:	61bb      	str	r3, [r7, #24]
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 8002138:	683b      	ldr	r3, [r7, #0]
 800213a:	689a      	ldr	r2, [r3, #8]
 800213c:	69fb      	ldr	r3, [r7, #28]
 800213e:	005b      	lsls	r3, r3, #1
 8002140:	fa02 f303 	lsl.w	r3, r2, r3
 8002144:	69ba      	ldr	r2, [r7, #24]
 8002146:	4313      	orrs	r3, r2
 8002148:	61bb      	str	r3, [r7, #24]
        GPIOx->PUPDR = temp;
 800214a:	687b      	ldr	r3, [r7, #4]
 800214c:	69ba      	ldr	r2, [r7, #24]
 800214e:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8002150:	683b      	ldr	r3, [r7, #0]
 8002152:	685b      	ldr	r3, [r3, #4]
 8002154:	f003 0303 	and.w	r3, r3, #3
 8002158:	2b02      	cmp	r3, #2
 800215a:	d123      	bne.n	80021a4 <HAL_GPIO_Init+0x144>
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 800215c:	69fb      	ldr	r3, [r7, #28]
 800215e:	08da      	lsrs	r2, r3, #3
 8002160:	687b      	ldr	r3, [r7, #4]
 8002162:	3208      	adds	r2, #8
 8002164:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8002168:	61bb      	str	r3, [r7, #24]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 800216a:	69fb      	ldr	r3, [r7, #28]
 800216c:	f003 0307 	and.w	r3, r3, #7
 8002170:	009b      	lsls	r3, r3, #2
 8002172:	220f      	movs	r2, #15
 8002174:	fa02 f303 	lsl.w	r3, r2, r3
 8002178:	43db      	mvns	r3, r3
 800217a:	69ba      	ldr	r2, [r7, #24]
 800217c:	4013      	ands	r3, r2
 800217e:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 8002180:	683b      	ldr	r3, [r7, #0]
 8002182:	691a      	ldr	r2, [r3, #16]
 8002184:	69fb      	ldr	r3, [r7, #28]
 8002186:	f003 0307 	and.w	r3, r3, #7
 800218a:	009b      	lsls	r3, r3, #2
 800218c:	fa02 f303 	lsl.w	r3, r2, r3
 8002190:	69ba      	ldr	r2, [r7, #24]
 8002192:	4313      	orrs	r3, r2
 8002194:	61bb      	str	r3, [r7, #24]
        GPIOx->AFR[position >> 3U] = temp;
 8002196:	69fb      	ldr	r3, [r7, #28]
 8002198:	08da      	lsrs	r2, r3, #3
 800219a:	687b      	ldr	r3, [r7, #4]
 800219c:	3208      	adds	r2, #8
 800219e:	69b9      	ldr	r1, [r7, #24]
 80021a0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 80021a4:	687b      	ldr	r3, [r7, #4]
 80021a6:	681b      	ldr	r3, [r3, #0]
 80021a8:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 80021aa:	69fb      	ldr	r3, [r7, #28]
 80021ac:	005b      	lsls	r3, r3, #1
 80021ae:	2203      	movs	r2, #3
 80021b0:	fa02 f303 	lsl.w	r3, r2, r3
 80021b4:	43db      	mvns	r3, r3
 80021b6:	69ba      	ldr	r2, [r7, #24]
 80021b8:	4013      	ands	r3, r2
 80021ba:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 80021bc:	683b      	ldr	r3, [r7, #0]
 80021be:	685b      	ldr	r3, [r3, #4]
 80021c0:	f003 0203 	and.w	r2, r3, #3
 80021c4:	69fb      	ldr	r3, [r7, #28]
 80021c6:	005b      	lsls	r3, r3, #1
 80021c8:	fa02 f303 	lsl.w	r3, r2, r3
 80021cc:	69ba      	ldr	r2, [r7, #24]
 80021ce:	4313      	orrs	r3, r2
 80021d0:	61bb      	str	r3, [r7, #24]
      GPIOx->MODER = temp;
 80021d2:	687b      	ldr	r3, [r7, #4]
 80021d4:	69ba      	ldr	r2, [r7, #24]
 80021d6:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 80021d8:	683b      	ldr	r3, [r7, #0]
 80021da:	685b      	ldr	r3, [r3, #4]
 80021dc:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
 80021e0:	2b00      	cmp	r3, #0
 80021e2:	f000 80b4 	beq.w	800234e <HAL_GPIO_Init+0x2ee>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80021e6:	2300      	movs	r3, #0
 80021e8:	60fb      	str	r3, [r7, #12]
 80021ea:	4b60      	ldr	r3, [pc, #384]	@ (800236c <HAL_GPIO_Init+0x30c>)
 80021ec:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80021ee:	4a5f      	ldr	r2, [pc, #380]	@ (800236c <HAL_GPIO_Init+0x30c>)
 80021f0:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 80021f4:	6453      	str	r3, [r2, #68]	@ 0x44
 80021f6:	4b5d      	ldr	r3, [pc, #372]	@ (800236c <HAL_GPIO_Init+0x30c>)
 80021f8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80021fa:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 80021fe:	60fb      	str	r3, [r7, #12]
 8002200:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
 8002202:	4a5b      	ldr	r2, [pc, #364]	@ (8002370 <HAL_GPIO_Init+0x310>)
 8002204:	69fb      	ldr	r3, [r7, #28]
 8002206:	089b      	lsrs	r3, r3, #2
 8002208:	3302      	adds	r3, #2
 800220a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800220e:	61bb      	str	r3, [r7, #24]
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 8002210:	69fb      	ldr	r3, [r7, #28]
 8002212:	f003 0303 	and.w	r3, r3, #3
 8002216:	009b      	lsls	r3, r3, #2
 8002218:	220f      	movs	r2, #15
 800221a:	fa02 f303 	lsl.w	r3, r2, r3
 800221e:	43db      	mvns	r3, r3
 8002220:	69ba      	ldr	r2, [r7, #24]
 8002222:	4013      	ands	r3, r2
 8002224:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8002226:	687b      	ldr	r3, [r7, #4]
 8002228:	4a52      	ldr	r2, [pc, #328]	@ (8002374 <HAL_GPIO_Init+0x314>)
 800222a:	4293      	cmp	r3, r2
 800222c:	d02b      	beq.n	8002286 <HAL_GPIO_Init+0x226>
 800222e:	687b      	ldr	r3, [r7, #4]
 8002230:	4a51      	ldr	r2, [pc, #324]	@ (8002378 <HAL_GPIO_Init+0x318>)
 8002232:	4293      	cmp	r3, r2
 8002234:	d025      	beq.n	8002282 <HAL_GPIO_Init+0x222>
 8002236:	687b      	ldr	r3, [r7, #4]
 8002238:	4a50      	ldr	r2, [pc, #320]	@ (800237c <HAL_GPIO_Init+0x31c>)
 800223a:	4293      	cmp	r3, r2
 800223c:	d01f      	beq.n	800227e <HAL_GPIO_Init+0x21e>
 800223e:	687b      	ldr	r3, [r7, #4]
 8002240:	4a4f      	ldr	r2, [pc, #316]	@ (8002380 <HAL_GPIO_Init+0x320>)
 8002242:	4293      	cmp	r3, r2
 8002244:	d019      	beq.n	800227a <HAL_GPIO_Init+0x21a>
 8002246:	687b      	ldr	r3, [r7, #4]
 8002248:	4a4e      	ldr	r2, [pc, #312]	@ (8002384 <HAL_GPIO_Init+0x324>)
 800224a:	4293      	cmp	r3, r2
 800224c:	d013      	beq.n	8002276 <HAL_GPIO_Init+0x216>
 800224e:	687b      	ldr	r3, [r7, #4]
 8002250:	4a4d      	ldr	r2, [pc, #308]	@ (8002388 <HAL_GPIO_Init+0x328>)
 8002252:	4293      	cmp	r3, r2
 8002254:	d00d      	beq.n	8002272 <HAL_GPIO_Init+0x212>
 8002256:	687b      	ldr	r3, [r7, #4]
 8002258:	4a4c      	ldr	r2, [pc, #304]	@ (800238c <HAL_GPIO_Init+0x32c>)
 800225a:	4293      	cmp	r3, r2
 800225c:	d007      	beq.n	800226e <HAL_GPIO_Init+0x20e>
 800225e:	687b      	ldr	r3, [r7, #4]
 8002260:	4a4b      	ldr	r2, [pc, #300]	@ (8002390 <HAL_GPIO_Init+0x330>)
 8002262:	4293      	cmp	r3, r2
 8002264:	d101      	bne.n	800226a <HAL_GPIO_Init+0x20a>
 8002266:	2307      	movs	r3, #7
 8002268:	e00e      	b.n	8002288 <HAL_GPIO_Init+0x228>
 800226a:	2308      	movs	r3, #8
 800226c:	e00c      	b.n	8002288 <HAL_GPIO_Init+0x228>
 800226e:	2306      	movs	r3, #6
 8002270:	e00a      	b.n	8002288 <HAL_GPIO_Init+0x228>
 8002272:	2305      	movs	r3, #5
 8002274:	e008      	b.n	8002288 <HAL_GPIO_Init+0x228>
 8002276:	2304      	movs	r3, #4
 8002278:	e006      	b.n	8002288 <HAL_GPIO_Init+0x228>
 800227a:	2303      	movs	r3, #3
 800227c:	e004      	b.n	8002288 <HAL_GPIO_Init+0x228>
 800227e:	2302      	movs	r3, #2
 8002280:	e002      	b.n	8002288 <HAL_GPIO_Init+0x228>
 8002282:	2301      	movs	r3, #1
 8002284:	e000      	b.n	8002288 <HAL_GPIO_Init+0x228>
 8002286:	2300      	movs	r3, #0
 8002288:	69fa      	ldr	r2, [r7, #28]
 800228a:	f002 0203 	and.w	r2, r2, #3
 800228e:	0092      	lsls	r2, r2, #2
 8002290:	4093      	lsls	r3, r2
 8002292:	69ba      	ldr	r2, [r7, #24]
 8002294:	4313      	orrs	r3, r2
 8002296:	61bb      	str	r3, [r7, #24]
        SYSCFG->EXTICR[position >> 2U] = temp;
 8002298:	4935      	ldr	r1, [pc, #212]	@ (8002370 <HAL_GPIO_Init+0x310>)
 800229a:	69fb      	ldr	r3, [r7, #28]
 800229c:	089b      	lsrs	r3, r3, #2
 800229e:	3302      	adds	r3, #2
 80022a0:	69ba      	ldr	r2, [r7, #24]
 80022a2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 80022a6:	4b3b      	ldr	r3, [pc, #236]	@ (8002394 <HAL_GPIO_Init+0x334>)
 80022a8:	689b      	ldr	r3, [r3, #8]
 80022aa:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 80022ac:	693b      	ldr	r3, [r7, #16]
 80022ae:	43db      	mvns	r3, r3
 80022b0:	69ba      	ldr	r2, [r7, #24]
 80022b2:	4013      	ands	r3, r2
 80022b4:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
 80022b6:	683b      	ldr	r3, [r7, #0]
 80022b8:	685b      	ldr	r3, [r3, #4]
 80022ba:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 80022be:	2b00      	cmp	r3, #0
 80022c0:	d003      	beq.n	80022ca <HAL_GPIO_Init+0x26a>
        {
          temp |= iocurrent;
 80022c2:	69ba      	ldr	r2, [r7, #24]
 80022c4:	693b      	ldr	r3, [r7, #16]
 80022c6:	4313      	orrs	r3, r2
 80022c8:	61bb      	str	r3, [r7, #24]
        }
        EXTI->RTSR = temp;
 80022ca:	4a32      	ldr	r2, [pc, #200]	@ (8002394 <HAL_GPIO_Init+0x334>)
 80022cc:	69bb      	ldr	r3, [r7, #24]
 80022ce:	6093      	str	r3, [r2, #8]

        temp = EXTI->FTSR;
 80022d0:	4b30      	ldr	r3, [pc, #192]	@ (8002394 <HAL_GPIO_Init+0x334>)
 80022d2:	68db      	ldr	r3, [r3, #12]
 80022d4:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 80022d6:	693b      	ldr	r3, [r7, #16]
 80022d8:	43db      	mvns	r3, r3
 80022da:	69ba      	ldr	r2, [r7, #24]
 80022dc:	4013      	ands	r3, r2
 80022de:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
 80022e0:	683b      	ldr	r3, [r7, #0]
 80022e2:	685b      	ldr	r3, [r3, #4]
 80022e4:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 80022e8:	2b00      	cmp	r3, #0
 80022ea:	d003      	beq.n	80022f4 <HAL_GPIO_Init+0x294>
        {
          temp |= iocurrent;
 80022ec:	69ba      	ldr	r2, [r7, #24]
 80022ee:	693b      	ldr	r3, [r7, #16]
 80022f0:	4313      	orrs	r3, r2
 80022f2:	61bb      	str	r3, [r7, #24]
        }
        EXTI->FTSR = temp;
 80022f4:	4a27      	ldr	r2, [pc, #156]	@ (8002394 <HAL_GPIO_Init+0x334>)
 80022f6:	69bb      	ldr	r3, [r7, #24]
 80022f8:	60d3      	str	r3, [r2, #12]

        temp = EXTI->EMR;
 80022fa:	4b26      	ldr	r3, [pc, #152]	@ (8002394 <HAL_GPIO_Init+0x334>)
 80022fc:	685b      	ldr	r3, [r3, #4]
 80022fe:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 8002300:	693b      	ldr	r3, [r7, #16]
 8002302:	43db      	mvns	r3, r3
 8002304:	69ba      	ldr	r2, [r7, #24]
 8002306:	4013      	ands	r3, r2
 8002308:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
 800230a:	683b      	ldr	r3, [r7, #0]
 800230c:	685b      	ldr	r3, [r3, #4]
 800230e:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8002312:	2b00      	cmp	r3, #0
 8002314:	d003      	beq.n	800231e <HAL_GPIO_Init+0x2be>
        {
          temp |= iocurrent;
 8002316:	69ba      	ldr	r2, [r7, #24]
 8002318:	693b      	ldr	r3, [r7, #16]
 800231a:	4313      	orrs	r3, r2
 800231c:	61bb      	str	r3, [r7, #24]
        }
        EXTI->EMR = temp;
 800231e:	4a1d      	ldr	r2, [pc, #116]	@ (8002394 <HAL_GPIO_Init+0x334>)
 8002320:	69bb      	ldr	r3, [r7, #24]
 8002322:	6053      	str	r3, [r2, #4]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8002324:	4b1b      	ldr	r3, [pc, #108]	@ (8002394 <HAL_GPIO_Init+0x334>)
 8002326:	681b      	ldr	r3, [r3, #0]
 8002328:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 800232a:	693b      	ldr	r3, [r7, #16]
 800232c:	43db      	mvns	r3, r3
 800232e:	69ba      	ldr	r2, [r7, #24]
 8002330:	4013      	ands	r3, r2
 8002332:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & EXTI_IT) != 0x00U)
 8002334:	683b      	ldr	r3, [r7, #0]
 8002336:	685b      	ldr	r3, [r3, #4]
 8002338:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 800233c:	2b00      	cmp	r3, #0
 800233e:	d003      	beq.n	8002348 <HAL_GPIO_Init+0x2e8>
        {
          temp |= iocurrent;
 8002340:	69ba      	ldr	r2, [r7, #24]
 8002342:	693b      	ldr	r3, [r7, #16]
 8002344:	4313      	orrs	r3, r2
 8002346:	61bb      	str	r3, [r7, #24]
        }
        EXTI->IMR = temp;
 8002348:	4a12      	ldr	r2, [pc, #72]	@ (8002394 <HAL_GPIO_Init+0x334>)
 800234a:	69bb      	ldr	r3, [r7, #24]
 800234c:	6013      	str	r3, [r2, #0]
  for(position = 0U; position < GPIO_NUMBER; position++)
 800234e:	69fb      	ldr	r3, [r7, #28]
 8002350:	3301      	adds	r3, #1
 8002352:	61fb      	str	r3, [r7, #28]
 8002354:	69fb      	ldr	r3, [r7, #28]
 8002356:	2b0f      	cmp	r3, #15
 8002358:	f67f ae90 	bls.w	800207c <HAL_GPIO_Init+0x1c>
      }
    }
  }
}
 800235c:	bf00      	nop
 800235e:	bf00      	nop
 8002360:	3724      	adds	r7, #36	@ 0x24
 8002362:	46bd      	mov	sp, r7
 8002364:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002368:	4770      	bx	lr
 800236a:	bf00      	nop
 800236c:	40023800 	.word	0x40023800
 8002370:	40013800 	.word	0x40013800
 8002374:	40020000 	.word	0x40020000
 8002378:	40020400 	.word	0x40020400
 800237c:	40020800 	.word	0x40020800
 8002380:	40020c00 	.word	0x40020c00
 8002384:	40021000 	.word	0x40021000
 8002388:	40021400 	.word	0x40021400
 800238c:	40021800 	.word	0x40021800
 8002390:	40021c00 	.word	0x40021c00
 8002394:	40013c00 	.word	0x40013c00

08002398 <HAL_GPIO_ReadPin>:
  * @param  GPIO_Pin specifies the port bit to read.
  *         This parameter can be GPIO_PIN_x where x can be (0..15).
  * @retval The input port pin value.
  */
GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8002398:	b480      	push	{r7}
 800239a:	b085      	sub	sp, #20
 800239c:	af00      	add	r7, sp, #0
 800239e:	6078      	str	r0, [r7, #4]
 80023a0:	460b      	mov	r3, r1
 80023a2:	807b      	strh	r3, [r7, #2]
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
 80023a4:	687b      	ldr	r3, [r7, #4]
 80023a6:	691a      	ldr	r2, [r3, #16]
 80023a8:	887b      	ldrh	r3, [r7, #2]
 80023aa:	4013      	ands	r3, r2
 80023ac:	2b00      	cmp	r3, #0
 80023ae:	d002      	beq.n	80023b6 <HAL_GPIO_ReadPin+0x1e>
  {
    bitstatus = GPIO_PIN_SET;
 80023b0:	2301      	movs	r3, #1
 80023b2:	73fb      	strb	r3, [r7, #15]
 80023b4:	e001      	b.n	80023ba <HAL_GPIO_ReadPin+0x22>
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
 80023b6:	2300      	movs	r3, #0
 80023b8:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 80023ba:	7bfb      	ldrb	r3, [r7, #15]
}
 80023bc:	4618      	mov	r0, r3
 80023be:	3714      	adds	r7, #20
 80023c0:	46bd      	mov	sp, r7
 80023c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80023c6:	4770      	bx	lr

080023c8 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 80023c8:	b480      	push	{r7}
 80023ca:	b083      	sub	sp, #12
 80023cc:	af00      	add	r7, sp, #0
 80023ce:	6078      	str	r0, [r7, #4]
 80023d0:	460b      	mov	r3, r1
 80023d2:	807b      	strh	r3, [r7, #2]
 80023d4:	4613      	mov	r3, r2
 80023d6:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 80023d8:	787b      	ldrb	r3, [r7, #1]
 80023da:	2b00      	cmp	r3, #0
 80023dc:	d003      	beq.n	80023e6 <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
 80023de:	887a      	ldrh	r2, [r7, #2]
 80023e0:	687b      	ldr	r3, [r7, #4]
 80023e2:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
  }
}
 80023e4:	e003      	b.n	80023ee <HAL_GPIO_WritePin+0x26>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
 80023e6:	887b      	ldrh	r3, [r7, #2]
 80023e8:	041a      	lsls	r2, r3, #16
 80023ea:	687b      	ldr	r3, [r7, #4]
 80023ec:	619a      	str	r2, [r3, #24]
}
 80023ee:	bf00      	nop
 80023f0:	370c      	adds	r7, #12
 80023f2:	46bd      	mov	sp, r7
 80023f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80023f8:	4770      	bx	lr
	...

080023fc <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
 80023fc:	b580      	push	{r7, lr}
 80023fe:	b084      	sub	sp, #16
 8002400:	af00      	add	r7, sp, #0
 8002402:	6078      	str	r0, [r7, #4]
  uint32_t freqrange;
  uint32_t pclk1;

  /* Check the I2C handle allocation */
  if (hi2c == NULL)
 8002404:	687b      	ldr	r3, [r7, #4]
 8002406:	2b00      	cmp	r3, #0
 8002408:	d101      	bne.n	800240e <HAL_I2C_Init+0x12>
  {
    return HAL_ERROR;
 800240a:	2301      	movs	r3, #1
 800240c:	e12b      	b.n	8002666 <HAL_I2C_Init+0x26a>
  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if (hi2c->State == HAL_I2C_STATE_RESET)
 800240e:	687b      	ldr	r3, [r7, #4]
 8002410:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 8002414:	b2db      	uxtb	r3, r3
 8002416:	2b00      	cmp	r3, #0
 8002418:	d106      	bne.n	8002428 <HAL_I2C_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
 800241a:	687b      	ldr	r3, [r7, #4]
 800241c:	2200      	movs	r2, #0
 800241e:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    hi2c->MspInitCallback(hi2c);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_I2C_MspInit(hi2c);
 8002422:	6878      	ldr	r0, [r7, #4]
 8002424:	f7ff fa3c 	bl	80018a0 <HAL_I2C_MspInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
 8002428:	687b      	ldr	r3, [r7, #4]
 800242a:	2224      	movs	r2, #36	@ 0x24
 800242c:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
 8002430:	687b      	ldr	r3, [r7, #4]
 8002432:	681b      	ldr	r3, [r3, #0]
 8002434:	681a      	ldr	r2, [r3, #0]
 8002436:	687b      	ldr	r3, [r7, #4]
 8002438:	681b      	ldr	r3, [r3, #0]
 800243a:	f022 0201 	bic.w	r2, r2, #1
 800243e:	601a      	str	r2, [r3, #0]

  /*Reset I2C*/
  hi2c->Instance->CR1 |= I2C_CR1_SWRST;
 8002440:	687b      	ldr	r3, [r7, #4]
 8002442:	681b      	ldr	r3, [r3, #0]
 8002444:	681a      	ldr	r2, [r3, #0]
 8002446:	687b      	ldr	r3, [r7, #4]
 8002448:	681b      	ldr	r3, [r3, #0]
 800244a:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
 800244e:	601a      	str	r2, [r3, #0]
  hi2c->Instance->CR1 &= ~I2C_CR1_SWRST;
 8002450:	687b      	ldr	r3, [r7, #4]
 8002452:	681b      	ldr	r3, [r3, #0]
 8002454:	681a      	ldr	r2, [r3, #0]
 8002456:	687b      	ldr	r3, [r7, #4]
 8002458:	681b      	ldr	r3, [r3, #0]
 800245a:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
 800245e:	601a      	str	r2, [r3, #0]

  /* Get PCLK1 frequency */
  pclk1 = HAL_RCC_GetPCLK1Freq();
 8002460:	f002 fc72 	bl	8004d48 <HAL_RCC_GetPCLK1Freq>
 8002464:	60f8      	str	r0, [r7, #12]

  /* Check the minimum allowed PCLK1 frequency */
  if (I2C_MIN_PCLK_FREQ(pclk1, hi2c->Init.ClockSpeed) == 1U)
 8002466:	687b      	ldr	r3, [r7, #4]
 8002468:	685b      	ldr	r3, [r3, #4]
 800246a:	4a81      	ldr	r2, [pc, #516]	@ (8002670 <HAL_I2C_Init+0x274>)
 800246c:	4293      	cmp	r3, r2
 800246e:	d807      	bhi.n	8002480 <HAL_I2C_Init+0x84>
 8002470:	68fb      	ldr	r3, [r7, #12]
 8002472:	4a80      	ldr	r2, [pc, #512]	@ (8002674 <HAL_I2C_Init+0x278>)
 8002474:	4293      	cmp	r3, r2
 8002476:	bf94      	ite	ls
 8002478:	2301      	movls	r3, #1
 800247a:	2300      	movhi	r3, #0
 800247c:	b2db      	uxtb	r3, r3
 800247e:	e006      	b.n	800248e <HAL_I2C_Init+0x92>
 8002480:	68fb      	ldr	r3, [r7, #12]
 8002482:	4a7d      	ldr	r2, [pc, #500]	@ (8002678 <HAL_I2C_Init+0x27c>)
 8002484:	4293      	cmp	r3, r2
 8002486:	bf94      	ite	ls
 8002488:	2301      	movls	r3, #1
 800248a:	2300      	movhi	r3, #0
 800248c:	b2db      	uxtb	r3, r3
 800248e:	2b00      	cmp	r3, #0
 8002490:	d001      	beq.n	8002496 <HAL_I2C_Init+0x9a>
  {
    return HAL_ERROR;
 8002492:	2301      	movs	r3, #1
 8002494:	e0e7      	b.n	8002666 <HAL_I2C_Init+0x26a>
  }

  /* Calculate frequency range */
  freqrange = I2C_FREQRANGE(pclk1);
 8002496:	68fb      	ldr	r3, [r7, #12]
 8002498:	4a78      	ldr	r2, [pc, #480]	@ (800267c <HAL_I2C_Init+0x280>)
 800249a:	fba2 2303 	umull	r2, r3, r2, r3
 800249e:	0c9b      	lsrs	r3, r3, #18
 80024a0:	60bb      	str	r3, [r7, #8]

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Frequency range */
  MODIFY_REG(hi2c->Instance->CR2, I2C_CR2_FREQ, freqrange);
 80024a2:	687b      	ldr	r3, [r7, #4]
 80024a4:	681b      	ldr	r3, [r3, #0]
 80024a6:	685b      	ldr	r3, [r3, #4]
 80024a8:	f023 013f 	bic.w	r1, r3, #63	@ 0x3f
 80024ac:	687b      	ldr	r3, [r7, #4]
 80024ae:	681b      	ldr	r3, [r3, #0]
 80024b0:	68ba      	ldr	r2, [r7, #8]
 80024b2:	430a      	orrs	r2, r1
 80024b4:	605a      	str	r2, [r3, #4]

  /*---------------------------- I2Cx TRISE Configuration --------------------*/
  /* Configure I2Cx: Rise Time */
  MODIFY_REG(hi2c->Instance->TRISE, I2C_TRISE_TRISE, I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed));
 80024b6:	687b      	ldr	r3, [r7, #4]
 80024b8:	681b      	ldr	r3, [r3, #0]
 80024ba:	6a1b      	ldr	r3, [r3, #32]
 80024bc:	f023 013f 	bic.w	r1, r3, #63	@ 0x3f
 80024c0:	687b      	ldr	r3, [r7, #4]
 80024c2:	685b      	ldr	r3, [r3, #4]
 80024c4:	4a6a      	ldr	r2, [pc, #424]	@ (8002670 <HAL_I2C_Init+0x274>)
 80024c6:	4293      	cmp	r3, r2
 80024c8:	d802      	bhi.n	80024d0 <HAL_I2C_Init+0xd4>
 80024ca:	68bb      	ldr	r3, [r7, #8]
 80024cc:	3301      	adds	r3, #1
 80024ce:	e009      	b.n	80024e4 <HAL_I2C_Init+0xe8>
 80024d0:	68bb      	ldr	r3, [r7, #8]
 80024d2:	f44f 7296 	mov.w	r2, #300	@ 0x12c
 80024d6:	fb02 f303 	mul.w	r3, r2, r3
 80024da:	4a69      	ldr	r2, [pc, #420]	@ (8002680 <HAL_I2C_Init+0x284>)
 80024dc:	fba2 2303 	umull	r2, r3, r2, r3
 80024e0:	099b      	lsrs	r3, r3, #6
 80024e2:	3301      	adds	r3, #1
 80024e4:	687a      	ldr	r2, [r7, #4]
 80024e6:	6812      	ldr	r2, [r2, #0]
 80024e8:	430b      	orrs	r3, r1
 80024ea:	6213      	str	r3, [r2, #32]

  /*---------------------------- I2Cx CCR Configuration ----------------------*/
  /* Configure I2Cx: Speed */
  MODIFY_REG(hi2c->Instance->CCR, (I2C_CCR_FS | I2C_CCR_DUTY | I2C_CCR_CCR), I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle));
 80024ec:	687b      	ldr	r3, [r7, #4]
 80024ee:	681b      	ldr	r3, [r3, #0]
 80024f0:	69db      	ldr	r3, [r3, #28]
 80024f2:	f423 424f 	bic.w	r2, r3, #52992	@ 0xcf00
 80024f6:	f022 02ff 	bic.w	r2, r2, #255	@ 0xff
 80024fa:	687b      	ldr	r3, [r7, #4]
 80024fc:	685b      	ldr	r3, [r3, #4]
 80024fe:	495c      	ldr	r1, [pc, #368]	@ (8002670 <HAL_I2C_Init+0x274>)
 8002500:	428b      	cmp	r3, r1
 8002502:	d819      	bhi.n	8002538 <HAL_I2C_Init+0x13c>
 8002504:	68fb      	ldr	r3, [r7, #12]
 8002506:	1e59      	subs	r1, r3, #1
 8002508:	687b      	ldr	r3, [r7, #4]
 800250a:	685b      	ldr	r3, [r3, #4]
 800250c:	005b      	lsls	r3, r3, #1
 800250e:	fbb1 f3f3 	udiv	r3, r1, r3
 8002512:	1c59      	adds	r1, r3, #1
 8002514:	f640 73fc 	movw	r3, #4092	@ 0xffc
 8002518:	400b      	ands	r3, r1
 800251a:	2b00      	cmp	r3, #0
 800251c:	d00a      	beq.n	8002534 <HAL_I2C_Init+0x138>
 800251e:	68fb      	ldr	r3, [r7, #12]
 8002520:	1e59      	subs	r1, r3, #1
 8002522:	687b      	ldr	r3, [r7, #4]
 8002524:	685b      	ldr	r3, [r3, #4]
 8002526:	005b      	lsls	r3, r3, #1
 8002528:	fbb1 f3f3 	udiv	r3, r1, r3
 800252c:	3301      	adds	r3, #1
 800252e:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8002532:	e051      	b.n	80025d8 <HAL_I2C_Init+0x1dc>
 8002534:	2304      	movs	r3, #4
 8002536:	e04f      	b.n	80025d8 <HAL_I2C_Init+0x1dc>
 8002538:	687b      	ldr	r3, [r7, #4]
 800253a:	689b      	ldr	r3, [r3, #8]
 800253c:	2b00      	cmp	r3, #0
 800253e:	d111      	bne.n	8002564 <HAL_I2C_Init+0x168>
 8002540:	68fb      	ldr	r3, [r7, #12]
 8002542:	1e58      	subs	r0, r3, #1
 8002544:	687b      	ldr	r3, [r7, #4]
 8002546:	6859      	ldr	r1, [r3, #4]
 8002548:	460b      	mov	r3, r1
 800254a:	005b      	lsls	r3, r3, #1
 800254c:	440b      	add	r3, r1
 800254e:	fbb0 f3f3 	udiv	r3, r0, r3
 8002552:	3301      	adds	r3, #1
 8002554:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8002558:	2b00      	cmp	r3, #0
 800255a:	bf0c      	ite	eq
 800255c:	2301      	moveq	r3, #1
 800255e:	2300      	movne	r3, #0
 8002560:	b2db      	uxtb	r3, r3
 8002562:	e012      	b.n	800258a <HAL_I2C_Init+0x18e>
 8002564:	68fb      	ldr	r3, [r7, #12]
 8002566:	1e58      	subs	r0, r3, #1
 8002568:	687b      	ldr	r3, [r7, #4]
 800256a:	6859      	ldr	r1, [r3, #4]
 800256c:	460b      	mov	r3, r1
 800256e:	009b      	lsls	r3, r3, #2
 8002570:	440b      	add	r3, r1
 8002572:	0099      	lsls	r1, r3, #2
 8002574:	440b      	add	r3, r1
 8002576:	fbb0 f3f3 	udiv	r3, r0, r3
 800257a:	3301      	adds	r3, #1
 800257c:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8002580:	2b00      	cmp	r3, #0
 8002582:	bf0c      	ite	eq
 8002584:	2301      	moveq	r3, #1
 8002586:	2300      	movne	r3, #0
 8002588:	b2db      	uxtb	r3, r3
 800258a:	2b00      	cmp	r3, #0
 800258c:	d001      	beq.n	8002592 <HAL_I2C_Init+0x196>
 800258e:	2301      	movs	r3, #1
 8002590:	e022      	b.n	80025d8 <HAL_I2C_Init+0x1dc>
 8002592:	687b      	ldr	r3, [r7, #4]
 8002594:	689b      	ldr	r3, [r3, #8]
 8002596:	2b00      	cmp	r3, #0
 8002598:	d10e      	bne.n	80025b8 <HAL_I2C_Init+0x1bc>
 800259a:	68fb      	ldr	r3, [r7, #12]
 800259c:	1e58      	subs	r0, r3, #1
 800259e:	687b      	ldr	r3, [r7, #4]
 80025a0:	6859      	ldr	r1, [r3, #4]
 80025a2:	460b      	mov	r3, r1
 80025a4:	005b      	lsls	r3, r3, #1
 80025a6:	440b      	add	r3, r1
 80025a8:	fbb0 f3f3 	udiv	r3, r0, r3
 80025ac:	3301      	adds	r3, #1
 80025ae:	f3c3 030b 	ubfx	r3, r3, #0, #12
 80025b2:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 80025b6:	e00f      	b.n	80025d8 <HAL_I2C_Init+0x1dc>
 80025b8:	68fb      	ldr	r3, [r7, #12]
 80025ba:	1e58      	subs	r0, r3, #1
 80025bc:	687b      	ldr	r3, [r7, #4]
 80025be:	6859      	ldr	r1, [r3, #4]
 80025c0:	460b      	mov	r3, r1
 80025c2:	009b      	lsls	r3, r3, #2
 80025c4:	440b      	add	r3, r1
 80025c6:	0099      	lsls	r1, r3, #2
 80025c8:	440b      	add	r3, r1
 80025ca:	fbb0 f3f3 	udiv	r3, r0, r3
 80025ce:	3301      	adds	r3, #1
 80025d0:	f3c3 030b 	ubfx	r3, r3, #0, #12
 80025d4:	f443 4340 	orr.w	r3, r3, #49152	@ 0xc000
 80025d8:	6879      	ldr	r1, [r7, #4]
 80025da:	6809      	ldr	r1, [r1, #0]
 80025dc:	4313      	orrs	r3, r2
 80025de:	61cb      	str	r3, [r1, #28]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  MODIFY_REG(hi2c->Instance->CR1, (I2C_CR1_ENGC | I2C_CR1_NOSTRETCH), (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode));
 80025e0:	687b      	ldr	r3, [r7, #4]
 80025e2:	681b      	ldr	r3, [r3, #0]
 80025e4:	681b      	ldr	r3, [r3, #0]
 80025e6:	f023 01c0 	bic.w	r1, r3, #192	@ 0xc0
 80025ea:	687b      	ldr	r3, [r7, #4]
 80025ec:	69da      	ldr	r2, [r3, #28]
 80025ee:	687b      	ldr	r3, [r7, #4]
 80025f0:	6a1b      	ldr	r3, [r3, #32]
 80025f2:	431a      	orrs	r2, r3
 80025f4:	687b      	ldr	r3, [r7, #4]
 80025f6:	681b      	ldr	r3, [r3, #0]
 80025f8:	430a      	orrs	r2, r1
 80025fa:	601a      	str	r2, [r3, #0]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Configure I2Cx: Own Address1 and addressing mode */
  MODIFY_REG(hi2c->Instance->OAR1, (I2C_OAR1_ADDMODE | I2C_OAR1_ADD8_9 | I2C_OAR1_ADD1_7 | I2C_OAR1_ADD0), (hi2c->Init.AddressingMode | hi2c->Init.OwnAddress1));
 80025fc:	687b      	ldr	r3, [r7, #4]
 80025fe:	681b      	ldr	r3, [r3, #0]
 8002600:	689b      	ldr	r3, [r3, #8]
 8002602:	f423 4303 	bic.w	r3, r3, #33536	@ 0x8300
 8002606:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
 800260a:	687a      	ldr	r2, [r7, #4]
 800260c:	6911      	ldr	r1, [r2, #16]
 800260e:	687a      	ldr	r2, [r7, #4]
 8002610:	68d2      	ldr	r2, [r2, #12]
 8002612:	4311      	orrs	r1, r2
 8002614:	687a      	ldr	r2, [r7, #4]
 8002616:	6812      	ldr	r2, [r2, #0]
 8002618:	430b      	orrs	r3, r1
 800261a:	6093      	str	r3, [r2, #8]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Configure I2Cx: Dual mode and Own Address2 */
  MODIFY_REG(hi2c->Instance->OAR2, (I2C_OAR2_ENDUAL | I2C_OAR2_ADD2), (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2));
 800261c:	687b      	ldr	r3, [r7, #4]
 800261e:	681b      	ldr	r3, [r3, #0]
 8002620:	68db      	ldr	r3, [r3, #12]
 8002622:	f023 01ff 	bic.w	r1, r3, #255	@ 0xff
 8002626:	687b      	ldr	r3, [r7, #4]
 8002628:	695a      	ldr	r2, [r3, #20]
 800262a:	687b      	ldr	r3, [r7, #4]
 800262c:	699b      	ldr	r3, [r3, #24]
 800262e:	431a      	orrs	r2, r3
 8002630:	687b      	ldr	r3, [r7, #4]
 8002632:	681b      	ldr	r3, [r3, #0]
 8002634:	430a      	orrs	r2, r1
 8002636:	60da      	str	r2, [r3, #12]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
 8002638:	687b      	ldr	r3, [r7, #4]
 800263a:	681b      	ldr	r3, [r3, #0]
 800263c:	681a      	ldr	r2, [r3, #0]
 800263e:	687b      	ldr	r3, [r7, #4]
 8002640:	681b      	ldr	r3, [r3, #0]
 8002642:	f042 0201 	orr.w	r2, r2, #1
 8002646:	601a      	str	r2, [r3, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8002648:	687b      	ldr	r3, [r7, #4]
 800264a:	2200      	movs	r2, #0
 800264c:	641a      	str	r2, [r3, #64]	@ 0x40
  hi2c->State = HAL_I2C_STATE_READY;
 800264e:	687b      	ldr	r3, [r7, #4]
 8002650:	2220      	movs	r2, #32
 8002652:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
  hi2c->PreviousState = I2C_STATE_NONE;
 8002656:	687b      	ldr	r3, [r7, #4]
 8002658:	2200      	movs	r2, #0
 800265a:	631a      	str	r2, [r3, #48]	@ 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 800265c:	687b      	ldr	r3, [r7, #4]
 800265e:	2200      	movs	r2, #0
 8002660:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e

  return HAL_OK;
 8002664:	2300      	movs	r3, #0
}
 8002666:	4618      	mov	r0, r3
 8002668:	3710      	adds	r7, #16
 800266a:	46bd      	mov	sp, r7
 800266c:	bd80      	pop	{r7, pc}
 800266e:	bf00      	nop
 8002670:	000186a0 	.word	0x000186a0
 8002674:	001e847f 	.word	0x001e847f
 8002678:	003d08ff 	.word	0x003d08ff
 800267c:	431bde83 	.word	0x431bde83
 8002680:	10624dd3 	.word	0x10624dd3

08002684 <HAL_I2S_Init>:
  * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2S_Init(I2S_HandleTypeDef *hi2s)
{
 8002684:	b580      	push	{r7, lr}
 8002686:	b088      	sub	sp, #32
 8002688:	af00      	add	r7, sp, #0
 800268a:	6078      	str	r0, [r7, #4]
#if defined (SPI_I2S_FULLDUPLEX_SUPPORT)
  uint16_t tmpreg;
#endif

  /* Check the I2S handle allocation */
  if (hi2s == NULL)
 800268c:	687b      	ldr	r3, [r7, #4]
 800268e:	2b00      	cmp	r3, #0
 8002690:	d101      	bne.n	8002696 <HAL_I2S_Init+0x12>
  {
    return HAL_ERROR;
 8002692:	2301      	movs	r3, #1
 8002694:	e128      	b.n	80028e8 <HAL_I2S_Init+0x264>
  assert_param(IS_I2S_MCLK_OUTPUT(hi2s->Init.MCLKOutput));
  assert_param(IS_I2S_AUDIO_FREQ(hi2s->Init.AudioFreq));
  assert_param(IS_I2S_CPOL(hi2s->Init.CPOL));
  assert_param(IS_I2S_CLOCKSOURCE(hi2s->Init.ClockSource));

  if (hi2s->State == HAL_I2S_STATE_RESET)
 8002696:	687b      	ldr	r3, [r7, #4]
 8002698:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 800269c:	b2db      	uxtb	r3, r3
 800269e:	2b00      	cmp	r3, #0
 80026a0:	d109      	bne.n	80026b6 <HAL_I2S_Init+0x32>
  {
    /* Allocate lock resource and initialize it */
    hi2s->Lock = HAL_UNLOCKED;
 80026a2:	687b      	ldr	r3, [r7, #4]
 80026a4:	2200      	movs	r2, #0
 80026a6:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Initialize Default I2S IrqHandler ISR */
    hi2s->IrqHandlerISR = I2S_IRQHandler;
 80026aa:	687b      	ldr	r3, [r7, #4]
 80026ac:	4a90      	ldr	r2, [pc, #576]	@ (80028f0 <HAL_I2S_Init+0x26c>)
 80026ae:	635a      	str	r2, [r3, #52]	@ 0x34

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    hi2s->MspInitCallback(hi2s);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2S_MspInit(hi2s);
 80026b0:	6878      	ldr	r0, [r7, #4]
 80026b2:	f7ff f93d 	bl	8001930 <HAL_I2S_MspInit>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
  }

  hi2s->State = HAL_I2S_STATE_BUSY;
 80026b6:	687b      	ldr	r3, [r7, #4]
 80026b8:	2202      	movs	r2, #2
 80026ba:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

  /*----------------------- SPIx I2SCFGR & I2SPR Configuration ----------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  CLEAR_BIT(hi2s->Instance->I2SCFGR, (SPI_I2SCFGR_CHLEN | SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CKPOL | \
 80026be:	687b      	ldr	r3, [r7, #4]
 80026c0:	681b      	ldr	r3, [r3, #0]
 80026c2:	69db      	ldr	r3, [r3, #28]
 80026c4:	687a      	ldr	r2, [r7, #4]
 80026c6:	6812      	ldr	r2, [r2, #0]
 80026c8:	f423 637b 	bic.w	r3, r3, #4016	@ 0xfb0
 80026cc:	f023 030f 	bic.w	r3, r3, #15
 80026d0:	61d3      	str	r3, [r2, #28]
                                      SPI_I2SCFGR_I2SSTD | SPI_I2SCFGR_PCMSYNC | SPI_I2SCFGR_I2SCFG | \
                                      SPI_I2SCFGR_I2SE | SPI_I2SCFGR_I2SMOD));
  hi2s->Instance->I2SPR = 0x0002U;
 80026d2:	687b      	ldr	r3, [r7, #4]
 80026d4:	681b      	ldr	r3, [r3, #0]
 80026d6:	2202      	movs	r2, #2
 80026d8:	621a      	str	r2, [r3, #32]

  /*----------------------- I2SPR: I2SDIV and ODD Calculation -----------------*/
  /* If the requested audio frequency is not the default, compute the prescaler */
  if (hi2s->Init.AudioFreq != I2S_AUDIOFREQ_DEFAULT)
 80026da:	687b      	ldr	r3, [r7, #4]
 80026dc:	695b      	ldr	r3, [r3, #20]
 80026de:	2b02      	cmp	r3, #2
 80026e0:	d060      	beq.n	80027a4 <HAL_I2S_Init+0x120>
  {
    /* Check the frame length (For the Prescaler computing) ********************/
    if (hi2s->Init.DataFormat == I2S_DATAFORMAT_16B)
 80026e2:	687b      	ldr	r3, [r7, #4]
 80026e4:	68db      	ldr	r3, [r3, #12]
 80026e6:	2b00      	cmp	r3, #0
 80026e8:	d102      	bne.n	80026f0 <HAL_I2S_Init+0x6c>
    {
      /* Packet length is 16 bits */
      packetlength = 16U;
 80026ea:	2310      	movs	r3, #16
 80026ec:	617b      	str	r3, [r7, #20]
 80026ee:	e001      	b.n	80026f4 <HAL_I2S_Init+0x70>
    }
    else
    {
      /* Packet length is 32 bits */
      packetlength = 32U;
 80026f0:	2320      	movs	r3, #32
 80026f2:	617b      	str	r3, [r7, #20]
    }

    /* I2S standard */
    if (hi2s->Init.Standard <= I2S_STANDARD_LSB)
 80026f4:	687b      	ldr	r3, [r7, #4]
 80026f6:	689b      	ldr	r3, [r3, #8]
 80026f8:	2b20      	cmp	r3, #32
 80026fa:	d802      	bhi.n	8002702 <HAL_I2S_Init+0x7e>
    {
      /* In I2S standard packet length is multiplied by 2 */
      packetlength = packetlength * 2U;
 80026fc:	697b      	ldr	r3, [r7, #20]
 80026fe:	005b      	lsls	r3, r3, #1
 8002700:	617b      	str	r3, [r7, #20]
    else
    {
      i2sclk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_I2S_APB2);
    }
#else
    i2sclk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_I2S);
 8002702:	2001      	movs	r0, #1
 8002704:	f002 fc16 	bl	8004f34 <HAL_RCCEx_GetPeriphCLKFreq>
 8002708:	60f8      	str	r0, [r7, #12]
#endif /* I2S_APB1_APB2_FEATURE */

    /* Compute the Real divider depending on the MCLK output state, with a floating point */
    if (hi2s->Init.MCLKOutput == I2S_MCLKOUTPUT_ENABLE)
 800270a:	687b      	ldr	r3, [r7, #4]
 800270c:	691b      	ldr	r3, [r3, #16]
 800270e:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8002712:	d125      	bne.n	8002760 <HAL_I2S_Init+0xdc>
    {
      /* MCLK output is enabled */
      if (hi2s->Init.DataFormat != I2S_DATAFORMAT_16B)
 8002714:	687b      	ldr	r3, [r7, #4]
 8002716:	68db      	ldr	r3, [r3, #12]
 8002718:	2b00      	cmp	r3, #0
 800271a:	d010      	beq.n	800273e <HAL_I2S_Init+0xba>
      {
        tmp = (uint32_t)(((((i2sclk / (packetlength * 4U)) * 10U) / hi2s->Init.AudioFreq)) + 5U);
 800271c:	697b      	ldr	r3, [r7, #20]
 800271e:	009b      	lsls	r3, r3, #2
 8002720:	68fa      	ldr	r2, [r7, #12]
 8002722:	fbb2 f2f3 	udiv	r2, r2, r3
 8002726:	4613      	mov	r3, r2
 8002728:	009b      	lsls	r3, r3, #2
 800272a:	4413      	add	r3, r2
 800272c:	005b      	lsls	r3, r3, #1
 800272e:	461a      	mov	r2, r3
 8002730:	687b      	ldr	r3, [r7, #4]
 8002732:	695b      	ldr	r3, [r3, #20]
 8002734:	fbb2 f3f3 	udiv	r3, r2, r3
 8002738:	3305      	adds	r3, #5
 800273a:	613b      	str	r3, [r7, #16]
 800273c:	e01f      	b.n	800277e <HAL_I2S_Init+0xfa>
      }
      else
      {
        tmp = (uint32_t)(((((i2sclk / (packetlength * 8U)) * 10U) / hi2s->Init.AudioFreq)) + 5U);
 800273e:	697b      	ldr	r3, [r7, #20]
 8002740:	00db      	lsls	r3, r3, #3
 8002742:	68fa      	ldr	r2, [r7, #12]
 8002744:	fbb2 f2f3 	udiv	r2, r2, r3
 8002748:	4613      	mov	r3, r2
 800274a:	009b      	lsls	r3, r3, #2
 800274c:	4413      	add	r3, r2
 800274e:	005b      	lsls	r3, r3, #1
 8002750:	461a      	mov	r2, r3
 8002752:	687b      	ldr	r3, [r7, #4]
 8002754:	695b      	ldr	r3, [r3, #20]
 8002756:	fbb2 f3f3 	udiv	r3, r2, r3
 800275a:	3305      	adds	r3, #5
 800275c:	613b      	str	r3, [r7, #16]
 800275e:	e00e      	b.n	800277e <HAL_I2S_Init+0xfa>
      }
    }
    else
    {
      /* MCLK output is disabled */
      tmp = (uint32_t)(((((i2sclk / packetlength) * 10U) / hi2s->Init.AudioFreq)) + 5U);
 8002760:	68fa      	ldr	r2, [r7, #12]
 8002762:	697b      	ldr	r3, [r7, #20]
 8002764:	fbb2 f2f3 	udiv	r2, r2, r3
 8002768:	4613      	mov	r3, r2
 800276a:	009b      	lsls	r3, r3, #2
 800276c:	4413      	add	r3, r2
 800276e:	005b      	lsls	r3, r3, #1
 8002770:	461a      	mov	r2, r3
 8002772:	687b      	ldr	r3, [r7, #4]
 8002774:	695b      	ldr	r3, [r3, #20]
 8002776:	fbb2 f3f3 	udiv	r3, r2, r3
 800277a:	3305      	adds	r3, #5
 800277c:	613b      	str	r3, [r7, #16]
    }

    /* Remove the flatting point */
    tmp = tmp / 10U;
 800277e:	693b      	ldr	r3, [r7, #16]
 8002780:	4a5c      	ldr	r2, [pc, #368]	@ (80028f4 <HAL_I2S_Init+0x270>)
 8002782:	fba2 2303 	umull	r2, r3, r2, r3
 8002786:	08db      	lsrs	r3, r3, #3
 8002788:	613b      	str	r3, [r7, #16]

    /* Check the parity of the divider */
    i2sodd = (uint32_t)(tmp & (uint32_t)1U);
 800278a:	693b      	ldr	r3, [r7, #16]
 800278c:	f003 0301 	and.w	r3, r3, #1
 8002790:	61bb      	str	r3, [r7, #24]

    /* Compute the i2sdiv prescaler */
    i2sdiv = (uint32_t)((tmp - i2sodd) / 2U);
 8002792:	693a      	ldr	r2, [r7, #16]
 8002794:	69bb      	ldr	r3, [r7, #24]
 8002796:	1ad3      	subs	r3, r2, r3
 8002798:	085b      	lsrs	r3, r3, #1
 800279a:	61fb      	str	r3, [r7, #28]

    /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    i2sodd = (uint32_t)(i2sodd << 8U);
 800279c:	69bb      	ldr	r3, [r7, #24]
 800279e:	021b      	lsls	r3, r3, #8
 80027a0:	61bb      	str	r3, [r7, #24]
 80027a2:	e003      	b.n	80027ac <HAL_I2S_Init+0x128>
  }
  else
  {
    /* Set the default values */
    i2sdiv = 2U;
 80027a4:	2302      	movs	r3, #2
 80027a6:	61fb      	str	r3, [r7, #28]
    i2sodd = 0U;
 80027a8:	2300      	movs	r3, #0
 80027aa:	61bb      	str	r3, [r7, #24]
  }

  /* Test if the divider is 1 or 0 or greater than 0xFF */
  if ((i2sdiv < 2U) || (i2sdiv > 0xFFU))
 80027ac:	69fb      	ldr	r3, [r7, #28]
 80027ae:	2b01      	cmp	r3, #1
 80027b0:	d902      	bls.n	80027b8 <HAL_I2S_Init+0x134>
 80027b2:	69fb      	ldr	r3, [r7, #28]
 80027b4:	2bff      	cmp	r3, #255	@ 0xff
 80027b6:	d907      	bls.n	80027c8 <HAL_I2S_Init+0x144>
  {
    /* Set the error code and execute error callback*/
    SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_PRESCALER);
 80027b8:	687b      	ldr	r3, [r7, #4]
 80027ba:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80027bc:	f043 0210 	orr.w	r2, r3, #16
 80027c0:	687b      	ldr	r3, [r7, #4]
 80027c2:	645a      	str	r2, [r3, #68]	@ 0x44
    return  HAL_ERROR;
 80027c4:	2301      	movs	r3, #1
 80027c6:	e08f      	b.n	80028e8 <HAL_I2S_Init+0x264>
  }

  /*----------------------- SPIx I2SCFGR & I2SPR Configuration ----------------*/

  /* Write to SPIx I2SPR register the computed value */
  hi2s->Instance->I2SPR = (uint32_t)((uint32_t)i2sdiv | (uint32_t)(i2sodd | (uint32_t)hi2s->Init.MCLKOutput));
 80027c8:	687b      	ldr	r3, [r7, #4]
 80027ca:	691a      	ldr	r2, [r3, #16]
 80027cc:	69bb      	ldr	r3, [r7, #24]
 80027ce:	ea42 0103 	orr.w	r1, r2, r3
 80027d2:	687b      	ldr	r3, [r7, #4]
 80027d4:	681b      	ldr	r3, [r3, #0]
 80027d6:	69fa      	ldr	r2, [r7, #28]
 80027d8:	430a      	orrs	r2, r1
 80027da:	621a      	str	r2, [r3, #32]

  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  /* And configure the I2S with the I2S_InitStruct values                      */
  MODIFY_REG(hi2s->Instance->I2SCFGR, (SPI_I2SCFGR_CHLEN | SPI_I2SCFGR_DATLEN | \
 80027dc:	687b      	ldr	r3, [r7, #4]
 80027de:	681b      	ldr	r3, [r3, #0]
 80027e0:	69db      	ldr	r3, [r3, #28]
 80027e2:	f423 637b 	bic.w	r3, r3, #4016	@ 0xfb0
 80027e6:	f023 030f 	bic.w	r3, r3, #15
 80027ea:	687a      	ldr	r2, [r7, #4]
 80027ec:	6851      	ldr	r1, [r2, #4]
 80027ee:	687a      	ldr	r2, [r7, #4]
 80027f0:	6892      	ldr	r2, [r2, #8]
 80027f2:	4311      	orrs	r1, r2
 80027f4:	687a      	ldr	r2, [r7, #4]
 80027f6:	68d2      	ldr	r2, [r2, #12]
 80027f8:	4311      	orrs	r1, r2
 80027fa:	687a      	ldr	r2, [r7, #4]
 80027fc:	6992      	ldr	r2, [r2, #24]
 80027fe:	430a      	orrs	r2, r1
 8002800:	431a      	orrs	r2, r3
 8002802:	687b      	ldr	r3, [r7, #4]
 8002804:	681b      	ldr	r3, [r3, #0]
 8002806:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 800280a:	61da      	str	r2, [r3, #28]
#if defined (SPI_I2S_FULLDUPLEX_SUPPORT)

  /* Configure the I2S extended if the full duplex mode is enabled */
  assert_param(IS_I2S_FULLDUPLEX_MODE(hi2s->Init.FullDuplexMode));

  if (hi2s->Init.FullDuplexMode == I2S_FULLDUPLEXMODE_ENABLE)
 800280c:	687b      	ldr	r3, [r7, #4]
 800280e:	6a1b      	ldr	r3, [r3, #32]
 8002810:	2b01      	cmp	r3, #1
 8002812:	d161      	bne.n	80028d8 <HAL_I2S_Init+0x254>
  {
    /* Set FullDuplex I2S IrqHandler ISR if FULLDUPLEXMODE is enabled */
    hi2s->IrqHandlerISR = HAL_I2SEx_FullDuplex_IRQHandler;
 8002814:	687b      	ldr	r3, [r7, #4]
 8002816:	4a38      	ldr	r2, [pc, #224]	@ (80028f8 <HAL_I2S_Init+0x274>)
 8002818:	635a      	str	r2, [r3, #52]	@ 0x34

    /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
    CLEAR_BIT(I2SxEXT(hi2s->Instance)->I2SCFGR, (SPI_I2SCFGR_CHLEN | SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CKPOL | \
 800281a:	687b      	ldr	r3, [r7, #4]
 800281c:	681b      	ldr	r3, [r3, #0]
 800281e:	4a37      	ldr	r2, [pc, #220]	@ (80028fc <HAL_I2S_Init+0x278>)
 8002820:	4293      	cmp	r3, r2
 8002822:	d101      	bne.n	8002828 <HAL_I2S_Init+0x1a4>
 8002824:	4b36      	ldr	r3, [pc, #216]	@ (8002900 <HAL_I2S_Init+0x27c>)
 8002826:	e001      	b.n	800282c <HAL_I2S_Init+0x1a8>
 8002828:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 800282c:	69db      	ldr	r3, [r3, #28]
 800282e:	687a      	ldr	r2, [r7, #4]
 8002830:	6812      	ldr	r2, [r2, #0]
 8002832:	4932      	ldr	r1, [pc, #200]	@ (80028fc <HAL_I2S_Init+0x278>)
 8002834:	428a      	cmp	r2, r1
 8002836:	d101      	bne.n	800283c <HAL_I2S_Init+0x1b8>
 8002838:	4a31      	ldr	r2, [pc, #196]	@ (8002900 <HAL_I2S_Init+0x27c>)
 800283a:	e001      	b.n	8002840 <HAL_I2S_Init+0x1bc>
 800283c:	f04f 2240 	mov.w	r2, #1073758208	@ 0x40004000
 8002840:	f423 637b 	bic.w	r3, r3, #4016	@ 0xfb0
 8002844:	f023 030f 	bic.w	r3, r3, #15
 8002848:	61d3      	str	r3, [r2, #28]
                                                 SPI_I2SCFGR_I2SSTD | SPI_I2SCFGR_PCMSYNC | SPI_I2SCFGR_I2SCFG | \
                                                 SPI_I2SCFGR_I2SE | SPI_I2SCFGR_I2SMOD));
    I2SxEXT(hi2s->Instance)->I2SPR = 2U;
 800284a:	687b      	ldr	r3, [r7, #4]
 800284c:	681b      	ldr	r3, [r3, #0]
 800284e:	4a2b      	ldr	r2, [pc, #172]	@ (80028fc <HAL_I2S_Init+0x278>)
 8002850:	4293      	cmp	r3, r2
 8002852:	d101      	bne.n	8002858 <HAL_I2S_Init+0x1d4>
 8002854:	4b2a      	ldr	r3, [pc, #168]	@ (8002900 <HAL_I2S_Init+0x27c>)
 8002856:	e001      	b.n	800285c <HAL_I2S_Init+0x1d8>
 8002858:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 800285c:	2202      	movs	r2, #2
 800285e:	621a      	str	r2, [r3, #32]

    /* Get the I2SCFGR register value */
    tmpreg = I2SxEXT(hi2s->Instance)->I2SCFGR;
 8002860:	687b      	ldr	r3, [r7, #4]
 8002862:	681b      	ldr	r3, [r3, #0]
 8002864:	4a25      	ldr	r2, [pc, #148]	@ (80028fc <HAL_I2S_Init+0x278>)
 8002866:	4293      	cmp	r3, r2
 8002868:	d101      	bne.n	800286e <HAL_I2S_Init+0x1ea>
 800286a:	4b25      	ldr	r3, [pc, #148]	@ (8002900 <HAL_I2S_Init+0x27c>)
 800286c:	e001      	b.n	8002872 <HAL_I2S_Init+0x1ee>
 800286e:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002872:	69db      	ldr	r3, [r3, #28]
 8002874:	817b      	strh	r3, [r7, #10]

    /* Get the mode to be configured for the extended I2S */
    if ((hi2s->Init.Mode == I2S_MODE_MASTER_TX) || (hi2s->Init.Mode == I2S_MODE_SLAVE_TX))
 8002876:	687b      	ldr	r3, [r7, #4]
 8002878:	685b      	ldr	r3, [r3, #4]
 800287a:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800287e:	d003      	beq.n	8002888 <HAL_I2S_Init+0x204>
 8002880:	687b      	ldr	r3, [r7, #4]
 8002882:	685b      	ldr	r3, [r3, #4]
 8002884:	2b00      	cmp	r3, #0
 8002886:	d103      	bne.n	8002890 <HAL_I2S_Init+0x20c>
    {
      tmp = I2S_MODE_SLAVE_RX;
 8002888:	f44f 7380 	mov.w	r3, #256	@ 0x100
 800288c:	613b      	str	r3, [r7, #16]
 800288e:	e001      	b.n	8002894 <HAL_I2S_Init+0x210>
    }
    else /* I2S_MODE_MASTER_RX ||  I2S_MODE_SLAVE_RX */
    {
      tmp = I2S_MODE_SLAVE_TX;
 8002890:	2300      	movs	r3, #0
 8002892:	613b      	str	r3, [r7, #16]
    }

    /* Configure the I2S Slave with the I2S Master parameter values */
    tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD    | \
                         (uint16_t)tmp                   | \
 8002894:	693b      	ldr	r3, [r7, #16]
 8002896:	b29a      	uxth	r2, r3
                         (uint16_t)hi2s->Init.Standard   | \
 8002898:	687b      	ldr	r3, [r7, #4]
 800289a:	689b      	ldr	r3, [r3, #8]
 800289c:	b29b      	uxth	r3, r3
    tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD    | \
 800289e:	4313      	orrs	r3, r2
 80028a0:	b29a      	uxth	r2, r3
                         (uint16_t)hi2s->Init.DataFormat | \
 80028a2:	687b      	ldr	r3, [r7, #4]
 80028a4:	68db      	ldr	r3, [r3, #12]
 80028a6:	b29b      	uxth	r3, r3
    tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD    | \
 80028a8:	4313      	orrs	r3, r2
 80028aa:	b29a      	uxth	r2, r3
                         (uint16_t)hi2s->Init.CPOL);
 80028ac:	687b      	ldr	r3, [r7, #4]
 80028ae:	699b      	ldr	r3, [r3, #24]
 80028b0:	b29b      	uxth	r3, r3
    tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD    | \
 80028b2:	4313      	orrs	r3, r2
 80028b4:	b29a      	uxth	r2, r3
 80028b6:	897b      	ldrh	r3, [r7, #10]
 80028b8:	4313      	orrs	r3, r2
 80028ba:	b29b      	uxth	r3, r3
 80028bc:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
 80028c0:	817b      	strh	r3, [r7, #10]

    /* Write to SPIx I2SCFGR */
    WRITE_REG(I2SxEXT(hi2s->Instance)->I2SCFGR, tmpreg);
 80028c2:	687b      	ldr	r3, [r7, #4]
 80028c4:	681b      	ldr	r3, [r3, #0]
 80028c6:	4a0d      	ldr	r2, [pc, #52]	@ (80028fc <HAL_I2S_Init+0x278>)
 80028c8:	4293      	cmp	r3, r2
 80028ca:	d101      	bne.n	80028d0 <HAL_I2S_Init+0x24c>
 80028cc:	4b0c      	ldr	r3, [pc, #48]	@ (8002900 <HAL_I2S_Init+0x27c>)
 80028ce:	e001      	b.n	80028d4 <HAL_I2S_Init+0x250>
 80028d0:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 80028d4:	897a      	ldrh	r2, [r7, #10]
 80028d6:	61da      	str	r2, [r3, #28]
  }
#endif /* SPI_I2S_FULLDUPLEX_SUPPORT */

  hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
 80028d8:	687b      	ldr	r3, [r7, #4]
 80028da:	2200      	movs	r2, #0
 80028dc:	645a      	str	r2, [r3, #68]	@ 0x44
  hi2s->State     = HAL_I2S_STATE_READY;
 80028de:	687b      	ldr	r3, [r7, #4]
 80028e0:	2201      	movs	r2, #1
 80028e2:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

  return HAL_OK;
 80028e6:	2300      	movs	r3, #0
}
 80028e8:	4618      	mov	r0, r3
 80028ea:	3720      	adds	r7, #32
 80028ec:	46bd      	mov	sp, r7
 80028ee:	bd80      	pop	{r7, pc}
 80028f0:	080029fb 	.word	0x080029fb
 80028f4:	cccccccd 	.word	0xcccccccd
 80028f8:	08002b11 	.word	0x08002b11
 80028fc:	40003800 	.word	0x40003800
 8002900:	40003400 	.word	0x40003400

08002904 <HAL_I2S_TxCpltCallback>:
  * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
__weak void HAL_I2S_TxCpltCallback(I2S_HandleTypeDef *hi2s)
{
 8002904:	b480      	push	{r7}
 8002906:	b083      	sub	sp, #12
 8002908:	af00      	add	r7, sp, #0
 800290a:	6078      	str	r0, [r7, #4]
  UNUSED(hi2s);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_I2S_TxCpltCallback could be implemented in the user file
   */
}
 800290c:	bf00      	nop
 800290e:	370c      	adds	r7, #12
 8002910:	46bd      	mov	sp, r7
 8002912:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002916:	4770      	bx	lr

08002918 <HAL_I2S_RxCpltCallback>:
  * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
__weak void HAL_I2S_RxCpltCallback(I2S_HandleTypeDef *hi2s)
{
 8002918:	b480      	push	{r7}
 800291a:	b083      	sub	sp, #12
 800291c:	af00      	add	r7, sp, #0
 800291e:	6078      	str	r0, [r7, #4]
  UNUSED(hi2s);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_I2S_RxCpltCallback could be implemented in the user file
   */
}
 8002920:	bf00      	nop
 8002922:	370c      	adds	r7, #12
 8002924:	46bd      	mov	sp, r7
 8002926:	f85d 7b04 	ldr.w	r7, [sp], #4
 800292a:	4770      	bx	lr

0800292c <HAL_I2S_ErrorCallback>:
  * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
__weak void HAL_I2S_ErrorCallback(I2S_HandleTypeDef *hi2s)
{
 800292c:	b480      	push	{r7}
 800292e:	b083      	sub	sp, #12
 8002930:	af00      	add	r7, sp, #0
 8002932:	6078      	str	r0, [r7, #4]
  UNUSED(hi2s);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_I2S_ErrorCallback could be implemented in the user file
   */
}
 8002934:	bf00      	nop
 8002936:	370c      	adds	r7, #12
 8002938:	46bd      	mov	sp, r7
 800293a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800293e:	4770      	bx	lr

08002940 <I2S_Transmit_IT>:
  * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
static void I2S_Transmit_IT(I2S_HandleTypeDef *hi2s)
{
 8002940:	b580      	push	{r7, lr}
 8002942:	b082      	sub	sp, #8
 8002944:	af00      	add	r7, sp, #0
 8002946:	6078      	str	r0, [r7, #4]
  /* Transmit data */
  hi2s->Instance->DR = (*hi2s->pTxBuffPtr);
 8002948:	687b      	ldr	r3, [r7, #4]
 800294a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800294c:	881a      	ldrh	r2, [r3, #0]
 800294e:	687b      	ldr	r3, [r7, #4]
 8002950:	681b      	ldr	r3, [r3, #0]
 8002952:	60da      	str	r2, [r3, #12]
  hi2s->pTxBuffPtr++;
 8002954:	687b      	ldr	r3, [r7, #4]
 8002956:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8002958:	1c9a      	adds	r2, r3, #2
 800295a:	687b      	ldr	r3, [r7, #4]
 800295c:	625a      	str	r2, [r3, #36]	@ 0x24
  hi2s->TxXferCount--;
 800295e:	687b      	ldr	r3, [r7, #4]
 8002960:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8002962:	b29b      	uxth	r3, r3
 8002964:	3b01      	subs	r3, #1
 8002966:	b29a      	uxth	r2, r3
 8002968:	687b      	ldr	r3, [r7, #4]
 800296a:	855a      	strh	r2, [r3, #42]	@ 0x2a

  if (hi2s->TxXferCount == 0U)
 800296c:	687b      	ldr	r3, [r7, #4]
 800296e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8002970:	b29b      	uxth	r3, r3
 8002972:	2b00      	cmp	r3, #0
 8002974:	d10e      	bne.n	8002994 <I2S_Transmit_IT+0x54>
  {
    /* Disable TXE and ERR interrupt */
    __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 8002976:	687b      	ldr	r3, [r7, #4]
 8002978:	681b      	ldr	r3, [r3, #0]
 800297a:	685a      	ldr	r2, [r3, #4]
 800297c:	687b      	ldr	r3, [r7, #4]
 800297e:	681b      	ldr	r3, [r3, #0]
 8002980:	f022 02a0 	bic.w	r2, r2, #160	@ 0xa0
 8002984:	605a      	str	r2, [r3, #4]

    hi2s->State = HAL_I2S_STATE_READY;
 8002986:	687b      	ldr	r3, [r7, #4]
 8002988:	2201      	movs	r2, #1
 800298a:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    /* Call user Tx complete callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
    hi2s->TxCpltCallback(hi2s);
#else
    HAL_I2S_TxCpltCallback(hi2s);
 800298e:	6878      	ldr	r0, [r7, #4]
 8002990:	f7ff ffb8 	bl	8002904 <HAL_I2S_TxCpltCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
  }
}
 8002994:	bf00      	nop
 8002996:	3708      	adds	r7, #8
 8002998:	46bd      	mov	sp, r7
 800299a:	bd80      	pop	{r7, pc}

0800299c <I2S_Receive_IT>:
  * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
static void I2S_Receive_IT(I2S_HandleTypeDef *hi2s)
{
 800299c:	b580      	push	{r7, lr}
 800299e:	b082      	sub	sp, #8
 80029a0:	af00      	add	r7, sp, #0
 80029a2:	6078      	str	r0, [r7, #4]
  /* Receive data */
  (*hi2s->pRxBuffPtr) = (uint16_t)hi2s->Instance->DR;
 80029a4:	687b      	ldr	r3, [r7, #4]
 80029a6:	681b      	ldr	r3, [r3, #0]
 80029a8:	68da      	ldr	r2, [r3, #12]
 80029aa:	687b      	ldr	r3, [r7, #4]
 80029ac:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80029ae:	b292      	uxth	r2, r2
 80029b0:	801a      	strh	r2, [r3, #0]
  hi2s->pRxBuffPtr++;
 80029b2:	687b      	ldr	r3, [r7, #4]
 80029b4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80029b6:	1c9a      	adds	r2, r3, #2
 80029b8:	687b      	ldr	r3, [r7, #4]
 80029ba:	62da      	str	r2, [r3, #44]	@ 0x2c
  hi2s->RxXferCount--;
 80029bc:	687b      	ldr	r3, [r7, #4]
 80029be:	8e5b      	ldrh	r3, [r3, #50]	@ 0x32
 80029c0:	b29b      	uxth	r3, r3
 80029c2:	3b01      	subs	r3, #1
 80029c4:	b29a      	uxth	r2, r3
 80029c6:	687b      	ldr	r3, [r7, #4]
 80029c8:	865a      	strh	r2, [r3, #50]	@ 0x32

  if (hi2s->RxXferCount == 0U)
 80029ca:	687b      	ldr	r3, [r7, #4]
 80029cc:	8e5b      	ldrh	r3, [r3, #50]	@ 0x32
 80029ce:	b29b      	uxth	r3, r3
 80029d0:	2b00      	cmp	r3, #0
 80029d2:	d10e      	bne.n	80029f2 <I2S_Receive_IT+0x56>
  {
    /* Disable RXNE and ERR interrupt */
    __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 80029d4:	687b      	ldr	r3, [r7, #4]
 80029d6:	681b      	ldr	r3, [r3, #0]
 80029d8:	685a      	ldr	r2, [r3, #4]
 80029da:	687b      	ldr	r3, [r7, #4]
 80029dc:	681b      	ldr	r3, [r3, #0]
 80029de:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 80029e2:	605a      	str	r2, [r3, #4]

    hi2s->State = HAL_I2S_STATE_READY;
 80029e4:	687b      	ldr	r3, [r7, #4]
 80029e6:	2201      	movs	r2, #1
 80029e8:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    /* Call user Rx complete callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
    hi2s->RxCpltCallback(hi2s);
#else
    HAL_I2S_RxCpltCallback(hi2s);
 80029ec:	6878      	ldr	r0, [r7, #4]
 80029ee:	f7ff ff93 	bl	8002918 <HAL_I2S_RxCpltCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
  }
}
 80029f2:	bf00      	nop
 80029f4:	3708      	adds	r7, #8
 80029f6:	46bd      	mov	sp, r7
 80029f8:	bd80      	pop	{r7, pc}

080029fa <I2S_IRQHandler>:
  * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
static void I2S_IRQHandler(I2S_HandleTypeDef *hi2s)
{
 80029fa:	b580      	push	{r7, lr}
 80029fc:	b086      	sub	sp, #24
 80029fe:	af00      	add	r7, sp, #0
 8002a00:	6078      	str	r0, [r7, #4]
  __IO uint32_t i2ssr = hi2s->Instance->SR;
 8002a02:	687b      	ldr	r3, [r7, #4]
 8002a04:	681b      	ldr	r3, [r3, #0]
 8002a06:	689b      	ldr	r3, [r3, #8]
 8002a08:	617b      	str	r3, [r7, #20]

  if (hi2s->State == HAL_I2S_STATE_BUSY_RX)
 8002a0a:	687b      	ldr	r3, [r7, #4]
 8002a0c:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8002a10:	b2db      	uxtb	r3, r3
 8002a12:	2b04      	cmp	r3, #4
 8002a14:	d13a      	bne.n	8002a8c <I2S_IRQHandler+0x92>
  {
    /* I2S in mode Receiver ------------------------------------------------*/
    if (((i2ssr & I2S_FLAG_RXNE) == I2S_FLAG_RXNE) && (__HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_RXNE) != RESET))
 8002a16:	697b      	ldr	r3, [r7, #20]
 8002a18:	f003 0301 	and.w	r3, r3, #1
 8002a1c:	2b01      	cmp	r3, #1
 8002a1e:	d109      	bne.n	8002a34 <I2S_IRQHandler+0x3a>
 8002a20:	687b      	ldr	r3, [r7, #4]
 8002a22:	681b      	ldr	r3, [r3, #0]
 8002a24:	685b      	ldr	r3, [r3, #4]
 8002a26:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8002a2a:	2b40      	cmp	r3, #64	@ 0x40
 8002a2c:	d102      	bne.n	8002a34 <I2S_IRQHandler+0x3a>
    {
      I2S_Receive_IT(hi2s);
 8002a2e:	6878      	ldr	r0, [r7, #4]
 8002a30:	f7ff ffb4 	bl	800299c <I2S_Receive_IT>
    }

    /* I2S Overrun error interrupt occurred -------------------------------------*/
    if (((i2ssr & I2S_FLAG_OVR) == I2S_FLAG_OVR) && (__HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_ERR) != RESET))
 8002a34:	697b      	ldr	r3, [r7, #20]
 8002a36:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8002a3a:	2b40      	cmp	r3, #64	@ 0x40
 8002a3c:	d126      	bne.n	8002a8c <I2S_IRQHandler+0x92>
 8002a3e:	687b      	ldr	r3, [r7, #4]
 8002a40:	681b      	ldr	r3, [r3, #0]
 8002a42:	685b      	ldr	r3, [r3, #4]
 8002a44:	f003 0320 	and.w	r3, r3, #32
 8002a48:	2b20      	cmp	r3, #32
 8002a4a:	d11f      	bne.n	8002a8c <I2S_IRQHandler+0x92>
    {
      /* Disable RXNE and ERR interrupt */
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 8002a4c:	687b      	ldr	r3, [r7, #4]
 8002a4e:	681b      	ldr	r3, [r3, #0]
 8002a50:	685a      	ldr	r2, [r3, #4]
 8002a52:	687b      	ldr	r3, [r7, #4]
 8002a54:	681b      	ldr	r3, [r3, #0]
 8002a56:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 8002a5a:	605a      	str	r2, [r3, #4]

      /* Clear Overrun flag */
      __HAL_I2S_CLEAR_OVRFLAG(hi2s);
 8002a5c:	2300      	movs	r3, #0
 8002a5e:	613b      	str	r3, [r7, #16]
 8002a60:	687b      	ldr	r3, [r7, #4]
 8002a62:	681b      	ldr	r3, [r3, #0]
 8002a64:	68db      	ldr	r3, [r3, #12]
 8002a66:	613b      	str	r3, [r7, #16]
 8002a68:	687b      	ldr	r3, [r7, #4]
 8002a6a:	681b      	ldr	r3, [r3, #0]
 8002a6c:	689b      	ldr	r3, [r3, #8]
 8002a6e:	613b      	str	r3, [r7, #16]
 8002a70:	693b      	ldr	r3, [r7, #16]

      /* Set the I2S State ready */
      hi2s->State = HAL_I2S_STATE_READY;
 8002a72:	687b      	ldr	r3, [r7, #4]
 8002a74:	2201      	movs	r2, #1
 8002a76:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41


      /* Set the error code and execute error callback*/
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_OVR);
 8002a7a:	687b      	ldr	r3, [r7, #4]
 8002a7c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8002a7e:	f043 0202 	orr.w	r2, r3, #2
 8002a82:	687b      	ldr	r3, [r7, #4]
 8002a84:	645a      	str	r2, [r3, #68]	@ 0x44
      /* Call user error callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->ErrorCallback(hi2s);
#else
      HAL_I2S_ErrorCallback(hi2s);
 8002a86:	6878      	ldr	r0, [r7, #4]
 8002a88:	f7ff ff50 	bl	800292c <HAL_I2S_ErrorCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }
  }

  if (hi2s->State == HAL_I2S_STATE_BUSY_TX)
 8002a8c:	687b      	ldr	r3, [r7, #4]
 8002a8e:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8002a92:	b2db      	uxtb	r3, r3
 8002a94:	2b03      	cmp	r3, #3
 8002a96:	d136      	bne.n	8002b06 <I2S_IRQHandler+0x10c>
  {
    /* I2S in mode Transmitter -----------------------------------------------*/
    if (((i2ssr & I2S_FLAG_TXE) == I2S_FLAG_TXE) && (__HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_TXE) != RESET))
 8002a98:	697b      	ldr	r3, [r7, #20]
 8002a9a:	f003 0302 	and.w	r3, r3, #2
 8002a9e:	2b02      	cmp	r3, #2
 8002aa0:	d109      	bne.n	8002ab6 <I2S_IRQHandler+0xbc>
 8002aa2:	687b      	ldr	r3, [r7, #4]
 8002aa4:	681b      	ldr	r3, [r3, #0]
 8002aa6:	685b      	ldr	r3, [r3, #4]
 8002aa8:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8002aac:	2b80      	cmp	r3, #128	@ 0x80
 8002aae:	d102      	bne.n	8002ab6 <I2S_IRQHandler+0xbc>
    {
      I2S_Transmit_IT(hi2s);
 8002ab0:	6878      	ldr	r0, [r7, #4]
 8002ab2:	f7ff ff45 	bl	8002940 <I2S_Transmit_IT>
    }

    /* I2S Underrun error interrupt occurred --------------------------------*/
    if (((i2ssr & I2S_FLAG_UDR) == I2S_FLAG_UDR) && (__HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_ERR) != RESET))
 8002ab6:	697b      	ldr	r3, [r7, #20]
 8002ab8:	f003 0308 	and.w	r3, r3, #8
 8002abc:	2b08      	cmp	r3, #8
 8002abe:	d122      	bne.n	8002b06 <I2S_IRQHandler+0x10c>
 8002ac0:	687b      	ldr	r3, [r7, #4]
 8002ac2:	681b      	ldr	r3, [r3, #0]
 8002ac4:	685b      	ldr	r3, [r3, #4]
 8002ac6:	f003 0320 	and.w	r3, r3, #32
 8002aca:	2b20      	cmp	r3, #32
 8002acc:	d11b      	bne.n	8002b06 <I2S_IRQHandler+0x10c>
    {
      /* Disable TXE and ERR interrupt */
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 8002ace:	687b      	ldr	r3, [r7, #4]
 8002ad0:	681b      	ldr	r3, [r3, #0]
 8002ad2:	685a      	ldr	r2, [r3, #4]
 8002ad4:	687b      	ldr	r3, [r7, #4]
 8002ad6:	681b      	ldr	r3, [r3, #0]
 8002ad8:	f022 02a0 	bic.w	r2, r2, #160	@ 0xa0
 8002adc:	605a      	str	r2, [r3, #4]

      /* Clear Underrun flag */
      __HAL_I2S_CLEAR_UDRFLAG(hi2s);
 8002ade:	2300      	movs	r3, #0
 8002ae0:	60fb      	str	r3, [r7, #12]
 8002ae2:	687b      	ldr	r3, [r7, #4]
 8002ae4:	681b      	ldr	r3, [r3, #0]
 8002ae6:	689b      	ldr	r3, [r3, #8]
 8002ae8:	60fb      	str	r3, [r7, #12]
 8002aea:	68fb      	ldr	r3, [r7, #12]

      /* Set the I2S State ready */
      hi2s->State = HAL_I2S_STATE_READY;
 8002aec:	687b      	ldr	r3, [r7, #4]
 8002aee:	2201      	movs	r2, #1
 8002af0:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

      /* Set the error code and execute error callback*/
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_UDR);
 8002af4:	687b      	ldr	r3, [r7, #4]
 8002af6:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8002af8:	f043 0204 	orr.w	r2, r3, #4
 8002afc:	687b      	ldr	r3, [r7, #4]
 8002afe:	645a      	str	r2, [r3, #68]	@ 0x44
      /* Call user error callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->ErrorCallback(hi2s);
#else
      HAL_I2S_ErrorCallback(hi2s);
 8002b00:	6878      	ldr	r0, [r7, #4]
 8002b02:	f7ff ff13 	bl	800292c <HAL_I2S_ErrorCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }
  }
}
 8002b06:	bf00      	nop
 8002b08:	3718      	adds	r7, #24
 8002b0a:	46bd      	mov	sp, r7
 8002b0c:	bd80      	pop	{r7, pc}
	...

08002b10 <HAL_I2SEx_FullDuplex_IRQHandler>:
  * @brief  This function handles I2S/I2Sext interrupt requests in full-duplex mode.
  * @param  hi2s I2S handle
  * @retval HAL status
  */
void HAL_I2SEx_FullDuplex_IRQHandler(I2S_HandleTypeDef *hi2s)
{
 8002b10:	b580      	push	{r7, lr}
 8002b12:	b088      	sub	sp, #32
 8002b14:	af00      	add	r7, sp, #0
 8002b16:	6078      	str	r0, [r7, #4]
  __IO uint32_t i2ssr     = hi2s->Instance->SR;
 8002b18:	687b      	ldr	r3, [r7, #4]
 8002b1a:	681b      	ldr	r3, [r3, #0]
 8002b1c:	689b      	ldr	r3, [r3, #8]
 8002b1e:	61fb      	str	r3, [r7, #28]
  __IO uint32_t i2sextsr  = I2SxEXT(hi2s->Instance)->SR;
 8002b20:	687b      	ldr	r3, [r7, #4]
 8002b22:	681b      	ldr	r3, [r3, #0]
 8002b24:	4a92      	ldr	r2, [pc, #584]	@ (8002d70 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 8002b26:	4293      	cmp	r3, r2
 8002b28:	d101      	bne.n	8002b2e <HAL_I2SEx_FullDuplex_IRQHandler+0x1e>
 8002b2a:	4b92      	ldr	r3, [pc, #584]	@ (8002d74 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 8002b2c:	e001      	b.n	8002b32 <HAL_I2SEx_FullDuplex_IRQHandler+0x22>
 8002b2e:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002b32:	689b      	ldr	r3, [r3, #8]
 8002b34:	61bb      	str	r3, [r7, #24]
  __IO uint32_t i2scr2    = hi2s->Instance->CR2;
 8002b36:	687b      	ldr	r3, [r7, #4]
 8002b38:	681b      	ldr	r3, [r3, #0]
 8002b3a:	685b      	ldr	r3, [r3, #4]
 8002b3c:	617b      	str	r3, [r7, #20]
  __IO uint32_t i2sextcr2 = I2SxEXT(hi2s->Instance)->CR2;
 8002b3e:	687b      	ldr	r3, [r7, #4]
 8002b40:	681b      	ldr	r3, [r3, #0]
 8002b42:	4a8b      	ldr	r2, [pc, #556]	@ (8002d70 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 8002b44:	4293      	cmp	r3, r2
 8002b46:	d101      	bne.n	8002b4c <HAL_I2SEx_FullDuplex_IRQHandler+0x3c>
 8002b48:	4b8a      	ldr	r3, [pc, #552]	@ (8002d74 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 8002b4a:	e001      	b.n	8002b50 <HAL_I2SEx_FullDuplex_IRQHandler+0x40>
 8002b4c:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002b50:	685b      	ldr	r3, [r3, #4]
 8002b52:	613b      	str	r3, [r7, #16]

  /* Check if the I2S_MODE_MASTER_TX or I2S_MODE_SLAVE_TX Mode is selected */
  if ((hi2s->Init.Mode == I2S_MODE_MASTER_TX) || (hi2s->Init.Mode == I2S_MODE_SLAVE_TX))
 8002b54:	687b      	ldr	r3, [r7, #4]
 8002b56:	685b      	ldr	r3, [r3, #4]
 8002b58:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8002b5c:	d004      	beq.n	8002b68 <HAL_I2SEx_FullDuplex_IRQHandler+0x58>
 8002b5e:	687b      	ldr	r3, [r7, #4]
 8002b60:	685b      	ldr	r3, [r3, #4]
 8002b62:	2b00      	cmp	r3, #0
 8002b64:	f040 8099 	bne.w	8002c9a <HAL_I2SEx_FullDuplex_IRQHandler+0x18a>
  {
    /* I2S in mode Transmitter -------------------------------------------------*/
    if (((i2ssr & I2S_FLAG_TXE) == I2S_FLAG_TXE) && ((i2scr2 & I2S_IT_TXE) != RESET))
 8002b68:	69fb      	ldr	r3, [r7, #28]
 8002b6a:	f003 0302 	and.w	r3, r3, #2
 8002b6e:	2b02      	cmp	r3, #2
 8002b70:	d107      	bne.n	8002b82 <HAL_I2SEx_FullDuplex_IRQHandler+0x72>
 8002b72:	697b      	ldr	r3, [r7, #20]
 8002b74:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8002b78:	2b00      	cmp	r3, #0
 8002b7a:	d002      	beq.n	8002b82 <HAL_I2SEx_FullDuplex_IRQHandler+0x72>
    {
      /* When the I2S mode is configured as I2S_MODE_MASTER_TX or I2S_MODE_SLAVE_TX,
      the I2S TXE interrupt will be generated to manage the full-duplex transmit phase. */
      I2SEx_TxISR_I2S(hi2s);
 8002b7c:	6878      	ldr	r0, [r7, #4]
 8002b7e:	f000 f925 	bl	8002dcc <I2SEx_TxISR_I2S>
    }

    /* I2Sext in mode Receiver -----------------------------------------------*/
    if (((i2sextsr & I2S_FLAG_RXNE) == I2S_FLAG_RXNE) && ((i2sextcr2 & I2S_IT_RXNE) != RESET))
 8002b82:	69bb      	ldr	r3, [r7, #24]
 8002b84:	f003 0301 	and.w	r3, r3, #1
 8002b88:	2b01      	cmp	r3, #1
 8002b8a:	d107      	bne.n	8002b9c <HAL_I2SEx_FullDuplex_IRQHandler+0x8c>
 8002b8c:	693b      	ldr	r3, [r7, #16]
 8002b8e:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8002b92:	2b00      	cmp	r3, #0
 8002b94:	d002      	beq.n	8002b9c <HAL_I2SEx_FullDuplex_IRQHandler+0x8c>
    {
      /* When the I2S mode is configured as I2S_MODE_MASTER_TX or I2S_MODE_SLAVE_TX,
      the I2Sext RXNE interrupt will be generated to manage the full-duplex receive phase. */
      I2SEx_RxISR_I2SExt(hi2s);
 8002b96:	6878      	ldr	r0, [r7, #4]
 8002b98:	f000 f9c8 	bl	8002f2c <I2SEx_RxISR_I2SExt>
    }

    /* I2Sext Overrun error interrupt occurred --------------------------------*/
    if (((i2sextsr & I2S_FLAG_OVR) == I2S_FLAG_OVR) && ((i2sextcr2 & I2S_IT_ERR) != RESET))
 8002b9c:	69bb      	ldr	r3, [r7, #24]
 8002b9e:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8002ba2:	2b40      	cmp	r3, #64	@ 0x40
 8002ba4:	d13a      	bne.n	8002c1c <HAL_I2SEx_FullDuplex_IRQHandler+0x10c>
 8002ba6:	693b      	ldr	r3, [r7, #16]
 8002ba8:	f003 0320 	and.w	r3, r3, #32
 8002bac:	2b00      	cmp	r3, #0
 8002bae:	d035      	beq.n	8002c1c <HAL_I2SEx_FullDuplex_IRQHandler+0x10c>
    {
      /* Disable RXNE and ERR interrupt */
      __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 8002bb0:	687b      	ldr	r3, [r7, #4]
 8002bb2:	681b      	ldr	r3, [r3, #0]
 8002bb4:	4a6e      	ldr	r2, [pc, #440]	@ (8002d70 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 8002bb6:	4293      	cmp	r3, r2
 8002bb8:	d101      	bne.n	8002bbe <HAL_I2SEx_FullDuplex_IRQHandler+0xae>
 8002bba:	4b6e      	ldr	r3, [pc, #440]	@ (8002d74 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 8002bbc:	e001      	b.n	8002bc2 <HAL_I2SEx_FullDuplex_IRQHandler+0xb2>
 8002bbe:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002bc2:	685a      	ldr	r2, [r3, #4]
 8002bc4:	687b      	ldr	r3, [r7, #4]
 8002bc6:	681b      	ldr	r3, [r3, #0]
 8002bc8:	4969      	ldr	r1, [pc, #420]	@ (8002d70 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 8002bca:	428b      	cmp	r3, r1
 8002bcc:	d101      	bne.n	8002bd2 <HAL_I2SEx_FullDuplex_IRQHandler+0xc2>
 8002bce:	4b69      	ldr	r3, [pc, #420]	@ (8002d74 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 8002bd0:	e001      	b.n	8002bd6 <HAL_I2SEx_FullDuplex_IRQHandler+0xc6>
 8002bd2:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002bd6:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 8002bda:	605a      	str	r2, [r3, #4]

      /* Disable TXE and ERR interrupt */
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 8002bdc:	687b      	ldr	r3, [r7, #4]
 8002bde:	681b      	ldr	r3, [r3, #0]
 8002be0:	685a      	ldr	r2, [r3, #4]
 8002be2:	687b      	ldr	r3, [r7, #4]
 8002be4:	681b      	ldr	r3, [r3, #0]
 8002be6:	f022 02a0 	bic.w	r2, r2, #160	@ 0xa0
 8002bea:	605a      	str	r2, [r3, #4]

      /* Clear Overrun flag */
      __HAL_I2S_CLEAR_OVRFLAG(hi2s);
 8002bec:	2300      	movs	r3, #0
 8002bee:	60fb      	str	r3, [r7, #12]
 8002bf0:	687b      	ldr	r3, [r7, #4]
 8002bf2:	681b      	ldr	r3, [r3, #0]
 8002bf4:	68db      	ldr	r3, [r3, #12]
 8002bf6:	60fb      	str	r3, [r7, #12]
 8002bf8:	687b      	ldr	r3, [r7, #4]
 8002bfa:	681b      	ldr	r3, [r3, #0]
 8002bfc:	689b      	ldr	r3, [r3, #8]
 8002bfe:	60fb      	str	r3, [r7, #12]
 8002c00:	68fb      	ldr	r3, [r7, #12]

      /* Set the I2S State ready */
      hi2s->State = HAL_I2S_STATE_READY;
 8002c02:	687b      	ldr	r3, [r7, #4]
 8002c04:	2201      	movs	r2, #1
 8002c06:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

      /* Set the error code and execute error callback*/
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_OVR);
 8002c0a:	687b      	ldr	r3, [r7, #4]
 8002c0c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8002c0e:	f043 0202 	orr.w	r2, r3, #2
 8002c12:	687b      	ldr	r3, [r7, #4]
 8002c14:	645a      	str	r2, [r3, #68]	@ 0x44
      /* Call user error callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->ErrorCallback(hi2s);
#else
      HAL_I2S_ErrorCallback(hi2s);
 8002c16:	6878      	ldr	r0, [r7, #4]
 8002c18:	f7ff fe88 	bl	800292c <HAL_I2S_ErrorCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }

    /* I2S Underrun error interrupt occurred ----------------------------------*/
    if (((i2ssr & I2S_FLAG_UDR) == I2S_FLAG_UDR) && ((i2scr2 & I2S_IT_ERR) != RESET))
 8002c1c:	69fb      	ldr	r3, [r7, #28]
 8002c1e:	f003 0308 	and.w	r3, r3, #8
 8002c22:	2b08      	cmp	r3, #8
 8002c24:	f040 80c3 	bne.w	8002dae <HAL_I2SEx_FullDuplex_IRQHandler+0x29e>
 8002c28:	697b      	ldr	r3, [r7, #20]
 8002c2a:	f003 0320 	and.w	r3, r3, #32
 8002c2e:	2b00      	cmp	r3, #0
 8002c30:	f000 80bd 	beq.w	8002dae <HAL_I2SEx_FullDuplex_IRQHandler+0x29e>
    {
      /* Disable TXE and ERR interrupt */
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 8002c34:	687b      	ldr	r3, [r7, #4]
 8002c36:	681b      	ldr	r3, [r3, #0]
 8002c38:	685a      	ldr	r2, [r3, #4]
 8002c3a:	687b      	ldr	r3, [r7, #4]
 8002c3c:	681b      	ldr	r3, [r3, #0]
 8002c3e:	f022 02a0 	bic.w	r2, r2, #160	@ 0xa0
 8002c42:	605a      	str	r2, [r3, #4]

      /* Disable RXNE and ERR interrupt */
      __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 8002c44:	687b      	ldr	r3, [r7, #4]
 8002c46:	681b      	ldr	r3, [r3, #0]
 8002c48:	4a49      	ldr	r2, [pc, #292]	@ (8002d70 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 8002c4a:	4293      	cmp	r3, r2
 8002c4c:	d101      	bne.n	8002c52 <HAL_I2SEx_FullDuplex_IRQHandler+0x142>
 8002c4e:	4b49      	ldr	r3, [pc, #292]	@ (8002d74 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 8002c50:	e001      	b.n	8002c56 <HAL_I2SEx_FullDuplex_IRQHandler+0x146>
 8002c52:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002c56:	685a      	ldr	r2, [r3, #4]
 8002c58:	687b      	ldr	r3, [r7, #4]
 8002c5a:	681b      	ldr	r3, [r3, #0]
 8002c5c:	4944      	ldr	r1, [pc, #272]	@ (8002d70 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 8002c5e:	428b      	cmp	r3, r1
 8002c60:	d101      	bne.n	8002c66 <HAL_I2SEx_FullDuplex_IRQHandler+0x156>
 8002c62:	4b44      	ldr	r3, [pc, #272]	@ (8002d74 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 8002c64:	e001      	b.n	8002c6a <HAL_I2SEx_FullDuplex_IRQHandler+0x15a>
 8002c66:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002c6a:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 8002c6e:	605a      	str	r2, [r3, #4]

      /* Clear underrun flag */
      __HAL_I2S_CLEAR_UDRFLAG(hi2s);
 8002c70:	2300      	movs	r3, #0
 8002c72:	60bb      	str	r3, [r7, #8]
 8002c74:	687b      	ldr	r3, [r7, #4]
 8002c76:	681b      	ldr	r3, [r3, #0]
 8002c78:	689b      	ldr	r3, [r3, #8]
 8002c7a:	60bb      	str	r3, [r7, #8]
 8002c7c:	68bb      	ldr	r3, [r7, #8]

      /* Set the I2S State ready */
      hi2s->State = HAL_I2S_STATE_READY;
 8002c7e:	687b      	ldr	r3, [r7, #4]
 8002c80:	2201      	movs	r2, #1
 8002c82:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

      /* Set the error code and execute error callback*/
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_UDR);
 8002c86:	687b      	ldr	r3, [r7, #4]
 8002c88:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8002c8a:	f043 0204 	orr.w	r2, r3, #4
 8002c8e:	687b      	ldr	r3, [r7, #4]
 8002c90:	645a      	str	r2, [r3, #68]	@ 0x44
      /* Call user error callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->ErrorCallback(hi2s);
#else
      HAL_I2S_ErrorCallback(hi2s);
 8002c92:	6878      	ldr	r0, [r7, #4]
 8002c94:	f7ff fe4a 	bl	800292c <HAL_I2S_ErrorCallback>
    if (((i2ssr & I2S_FLAG_UDR) == I2S_FLAG_UDR) && ((i2scr2 & I2S_IT_ERR) != RESET))
 8002c98:	e089      	b.n	8002dae <HAL_I2SEx_FullDuplex_IRQHandler+0x29e>
  }
  /* The I2S_MODE_MASTER_RX or I2S_MODE_SLAVE_RX Mode is selected */
  else
  {
    /* I2Sext in mode Transmitter ----------------------------------------------*/
    if (((i2sextsr & I2S_FLAG_TXE) == I2S_FLAG_TXE) && ((i2sextcr2 & I2S_IT_TXE) != RESET))
 8002c9a:	69bb      	ldr	r3, [r7, #24]
 8002c9c:	f003 0302 	and.w	r3, r3, #2
 8002ca0:	2b02      	cmp	r3, #2
 8002ca2:	d107      	bne.n	8002cb4 <HAL_I2SEx_FullDuplex_IRQHandler+0x1a4>
 8002ca4:	693b      	ldr	r3, [r7, #16]
 8002ca6:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8002caa:	2b00      	cmp	r3, #0
 8002cac:	d002      	beq.n	8002cb4 <HAL_I2SEx_FullDuplex_IRQHandler+0x1a4>
    {
      /* When the I2S mode is configured as I2S_MODE_MASTER_RX or I2S_MODE_SLAVE_RX,
      the I2Sext TXE interrupt will be generated to manage the full-duplex transmit phase. */
      I2SEx_TxISR_I2SExt(hi2s);
 8002cae:	6878      	ldr	r0, [r7, #4]
 8002cb0:	f000 f8be 	bl	8002e30 <I2SEx_TxISR_I2SExt>
    }

    /* I2S in mode Receiver --------------------------------------------------*/
    if (((i2ssr & I2S_FLAG_RXNE) == I2S_FLAG_RXNE) && ((i2scr2 & I2S_IT_RXNE) != RESET))
 8002cb4:	69fb      	ldr	r3, [r7, #28]
 8002cb6:	f003 0301 	and.w	r3, r3, #1
 8002cba:	2b01      	cmp	r3, #1
 8002cbc:	d107      	bne.n	8002cce <HAL_I2SEx_FullDuplex_IRQHandler+0x1be>
 8002cbe:	697b      	ldr	r3, [r7, #20]
 8002cc0:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8002cc4:	2b00      	cmp	r3, #0
 8002cc6:	d002      	beq.n	8002cce <HAL_I2SEx_FullDuplex_IRQHandler+0x1be>
    {
      /* When the I2S mode is configured as I2S_MODE_MASTER_RX or I2S_MODE_SLAVE_RX,
      the I2S RXNE interrupt will be generated to manage the full-duplex receive phase. */
      I2SEx_RxISR_I2S(hi2s);
 8002cc8:	6878      	ldr	r0, [r7, #4]
 8002cca:	f000 f8fd 	bl	8002ec8 <I2SEx_RxISR_I2S>
    }

    /* I2S Overrun error interrupt occurred -------------------------------------*/
    if (((i2ssr & I2S_FLAG_OVR) == I2S_FLAG_OVR) && ((i2scr2 & I2S_IT_ERR) != RESET))
 8002cce:	69fb      	ldr	r3, [r7, #28]
 8002cd0:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8002cd4:	2b40      	cmp	r3, #64	@ 0x40
 8002cd6:	d12f      	bne.n	8002d38 <HAL_I2SEx_FullDuplex_IRQHandler+0x228>
 8002cd8:	697b      	ldr	r3, [r7, #20]
 8002cda:	f003 0320 	and.w	r3, r3, #32
 8002cde:	2b00      	cmp	r3, #0
 8002ce0:	d02a      	beq.n	8002d38 <HAL_I2SEx_FullDuplex_IRQHandler+0x228>
    {
      /* Disable RXNE and ERR interrupt */
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 8002ce2:	687b      	ldr	r3, [r7, #4]
 8002ce4:	681b      	ldr	r3, [r3, #0]
 8002ce6:	685a      	ldr	r2, [r3, #4]
 8002ce8:	687b      	ldr	r3, [r7, #4]
 8002cea:	681b      	ldr	r3, [r3, #0]
 8002cec:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 8002cf0:	605a      	str	r2, [r3, #4]

      /* Disable TXE and ERR interrupt */
      __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 8002cf2:	687b      	ldr	r3, [r7, #4]
 8002cf4:	681b      	ldr	r3, [r3, #0]
 8002cf6:	4a1e      	ldr	r2, [pc, #120]	@ (8002d70 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 8002cf8:	4293      	cmp	r3, r2
 8002cfa:	d101      	bne.n	8002d00 <HAL_I2SEx_FullDuplex_IRQHandler+0x1f0>
 8002cfc:	4b1d      	ldr	r3, [pc, #116]	@ (8002d74 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 8002cfe:	e001      	b.n	8002d04 <HAL_I2SEx_FullDuplex_IRQHandler+0x1f4>
 8002d00:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002d04:	685a      	ldr	r2, [r3, #4]
 8002d06:	687b      	ldr	r3, [r7, #4]
 8002d08:	681b      	ldr	r3, [r3, #0]
 8002d0a:	4919      	ldr	r1, [pc, #100]	@ (8002d70 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 8002d0c:	428b      	cmp	r3, r1
 8002d0e:	d101      	bne.n	8002d14 <HAL_I2SEx_FullDuplex_IRQHandler+0x204>
 8002d10:	4b18      	ldr	r3, [pc, #96]	@ (8002d74 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 8002d12:	e001      	b.n	8002d18 <HAL_I2SEx_FullDuplex_IRQHandler+0x208>
 8002d14:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002d18:	f022 02a0 	bic.w	r2, r2, #160	@ 0xa0
 8002d1c:	605a      	str	r2, [r3, #4]

      /* Set the I2S State ready */
      hi2s->State = HAL_I2S_STATE_READY;
 8002d1e:	687b      	ldr	r3, [r7, #4]
 8002d20:	2201      	movs	r2, #1
 8002d22:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

      /* Set the error code and execute error callback*/
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_OVR);
 8002d26:	687b      	ldr	r3, [r7, #4]
 8002d28:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8002d2a:	f043 0202 	orr.w	r2, r3, #2
 8002d2e:	687b      	ldr	r3, [r7, #4]
 8002d30:	645a      	str	r2, [r3, #68]	@ 0x44
      /* Call user error callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->ErrorCallback(hi2s);
#else
      HAL_I2S_ErrorCallback(hi2s);
 8002d32:	6878      	ldr	r0, [r7, #4]
 8002d34:	f7ff fdfa 	bl	800292c <HAL_I2S_ErrorCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }

    /* I2Sext Underrun error interrupt occurred -------------------------------*/
    if (((i2sextsr & I2S_FLAG_UDR) == I2S_FLAG_UDR) && ((i2sextcr2 & I2S_IT_ERR) != RESET))
 8002d38:	69bb      	ldr	r3, [r7, #24]
 8002d3a:	f003 0308 	and.w	r3, r3, #8
 8002d3e:	2b08      	cmp	r3, #8
 8002d40:	d136      	bne.n	8002db0 <HAL_I2SEx_FullDuplex_IRQHandler+0x2a0>
 8002d42:	693b      	ldr	r3, [r7, #16]
 8002d44:	f003 0320 	and.w	r3, r3, #32
 8002d48:	2b00      	cmp	r3, #0
 8002d4a:	d031      	beq.n	8002db0 <HAL_I2SEx_FullDuplex_IRQHandler+0x2a0>
    {
      /* Disable TXE and ERR interrupt */
      __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 8002d4c:	687b      	ldr	r3, [r7, #4]
 8002d4e:	681b      	ldr	r3, [r3, #0]
 8002d50:	4a07      	ldr	r2, [pc, #28]	@ (8002d70 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 8002d52:	4293      	cmp	r3, r2
 8002d54:	d101      	bne.n	8002d5a <HAL_I2SEx_FullDuplex_IRQHandler+0x24a>
 8002d56:	4b07      	ldr	r3, [pc, #28]	@ (8002d74 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 8002d58:	e001      	b.n	8002d5e <HAL_I2SEx_FullDuplex_IRQHandler+0x24e>
 8002d5a:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002d5e:	685a      	ldr	r2, [r3, #4]
 8002d60:	687b      	ldr	r3, [r7, #4]
 8002d62:	681b      	ldr	r3, [r3, #0]
 8002d64:	4902      	ldr	r1, [pc, #8]	@ (8002d70 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 8002d66:	428b      	cmp	r3, r1
 8002d68:	d106      	bne.n	8002d78 <HAL_I2SEx_FullDuplex_IRQHandler+0x268>
 8002d6a:	4b02      	ldr	r3, [pc, #8]	@ (8002d74 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 8002d6c:	e006      	b.n	8002d7c <HAL_I2SEx_FullDuplex_IRQHandler+0x26c>
 8002d6e:	bf00      	nop
 8002d70:	40003800 	.word	0x40003800
 8002d74:	40003400 	.word	0x40003400
 8002d78:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002d7c:	f022 02a0 	bic.w	r2, r2, #160	@ 0xa0
 8002d80:	605a      	str	r2, [r3, #4]

      /* Disable RXNE and ERR interrupt */
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 8002d82:	687b      	ldr	r3, [r7, #4]
 8002d84:	681b      	ldr	r3, [r3, #0]
 8002d86:	685a      	ldr	r2, [r3, #4]
 8002d88:	687b      	ldr	r3, [r7, #4]
 8002d8a:	681b      	ldr	r3, [r3, #0]
 8002d8c:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 8002d90:	605a      	str	r2, [r3, #4]

      /* Set the I2S State ready */
      hi2s->State = HAL_I2S_STATE_READY;
 8002d92:	687b      	ldr	r3, [r7, #4]
 8002d94:	2201      	movs	r2, #1
 8002d96:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

      /* Set the error code and execute error callback*/
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_UDR);
 8002d9a:	687b      	ldr	r3, [r7, #4]
 8002d9c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8002d9e:	f043 0204 	orr.w	r2, r3, #4
 8002da2:	687b      	ldr	r3, [r7, #4]
 8002da4:	645a      	str	r2, [r3, #68]	@ 0x44
      /* Call user error callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->ErrorCallback(hi2s);
#else
      HAL_I2S_ErrorCallback(hi2s);
 8002da6:	6878      	ldr	r0, [r7, #4]
 8002da8:	f7ff fdc0 	bl	800292c <HAL_I2S_ErrorCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }
  }
}
 8002dac:	e000      	b.n	8002db0 <HAL_I2SEx_FullDuplex_IRQHandler+0x2a0>
    if (((i2ssr & I2S_FLAG_UDR) == I2S_FLAG_UDR) && ((i2scr2 & I2S_IT_ERR) != RESET))
 8002dae:	bf00      	nop
}
 8002db0:	bf00      	nop
 8002db2:	3720      	adds	r7, #32
 8002db4:	46bd      	mov	sp, r7
 8002db6:	bd80      	pop	{r7, pc}

08002db8 <HAL_I2SEx_TxRxCpltCallback>:
  * @brief  Tx and Rx Transfer completed callback
  * @param  hi2s I2S handle
  * @retval None
  */
__weak void HAL_I2SEx_TxRxCpltCallback(I2S_HandleTypeDef *hi2s)
{
 8002db8:	b480      	push	{r7}
 8002dba:	b083      	sub	sp, #12
 8002dbc:	af00      	add	r7, sp, #0
 8002dbe:	6078      	str	r0, [r7, #4]
  UNUSED(hi2s);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2SEx_TxRxCpltCallback could be implemented in the user file
   */
}
 8002dc0:	bf00      	nop
 8002dc2:	370c      	adds	r7, #12
 8002dc4:	46bd      	mov	sp, r7
 8002dc6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002dca:	4770      	bx	lr

08002dcc <I2SEx_TxISR_I2S>:
  * @brief  I2S Full-Duplex IT handler transmit function
  * @param  hi2s I2S handle
  * @retval None
  */
static void I2SEx_TxISR_I2S(I2S_HandleTypeDef *hi2s)
{
 8002dcc:	b580      	push	{r7, lr}
 8002dce:	b082      	sub	sp, #8
 8002dd0:	af00      	add	r7, sp, #0
 8002dd2:	6078      	str	r0, [r7, #4]
  /* Write Data on DR register */
  hi2s->Instance->DR = (*hi2s->pTxBuffPtr++);
 8002dd4:	687b      	ldr	r3, [r7, #4]
 8002dd6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8002dd8:	1c99      	adds	r1, r3, #2
 8002dda:	687a      	ldr	r2, [r7, #4]
 8002ddc:	6251      	str	r1, [r2, #36]	@ 0x24
 8002dde:	881a      	ldrh	r2, [r3, #0]
 8002de0:	687b      	ldr	r3, [r7, #4]
 8002de2:	681b      	ldr	r3, [r3, #0]
 8002de4:	60da      	str	r2, [r3, #12]
  hi2s->TxXferCount--;
 8002de6:	687b      	ldr	r3, [r7, #4]
 8002de8:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8002dea:	b29b      	uxth	r3, r3
 8002dec:	3b01      	subs	r3, #1
 8002dee:	b29a      	uxth	r2, r3
 8002df0:	687b      	ldr	r3, [r7, #4]
 8002df2:	855a      	strh	r2, [r3, #42]	@ 0x2a

  if (hi2s->TxXferCount == 0U)
 8002df4:	687b      	ldr	r3, [r7, #4]
 8002df6:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8002df8:	b29b      	uxth	r3, r3
 8002dfa:	2b00      	cmp	r3, #0
 8002dfc:	d113      	bne.n	8002e26 <I2SEx_TxISR_I2S+0x5a>
  {
    /* Disable TXE and ERR interrupt */
    __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 8002dfe:	687b      	ldr	r3, [r7, #4]
 8002e00:	681b      	ldr	r3, [r3, #0]
 8002e02:	685a      	ldr	r2, [r3, #4]
 8002e04:	687b      	ldr	r3, [r7, #4]
 8002e06:	681b      	ldr	r3, [r3, #0]
 8002e08:	f022 02a0 	bic.w	r2, r2, #160	@ 0xa0
 8002e0c:	605a      	str	r2, [r3, #4]

    if (hi2s->RxXferCount == 0U)
 8002e0e:	687b      	ldr	r3, [r7, #4]
 8002e10:	8e5b      	ldrh	r3, [r3, #50]	@ 0x32
 8002e12:	b29b      	uxth	r3, r3
 8002e14:	2b00      	cmp	r3, #0
 8002e16:	d106      	bne.n	8002e26 <I2SEx_TxISR_I2S+0x5a>
    {
      hi2s->State = HAL_I2S_STATE_READY;
 8002e18:	687b      	ldr	r3, [r7, #4]
 8002e1a:	2201      	movs	r2, #1
 8002e1c:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
      /* Call user TxRx complete callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->TxRxCpltCallback(hi2s);
#else
      HAL_I2SEx_TxRxCpltCallback(hi2s);
 8002e20:	6878      	ldr	r0, [r7, #4]
 8002e22:	f7ff ffc9 	bl	8002db8 <HAL_I2SEx_TxRxCpltCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }
  }
}
 8002e26:	bf00      	nop
 8002e28:	3708      	adds	r7, #8
 8002e2a:	46bd      	mov	sp, r7
 8002e2c:	bd80      	pop	{r7, pc}
	...

08002e30 <I2SEx_TxISR_I2SExt>:
  * @brief  I2SExt Full-Duplex IT handler transmit function
  * @param  hi2s I2S handle
  * @retval None
  */
static void I2SEx_TxISR_I2SExt(I2S_HandleTypeDef *hi2s)
{
 8002e30:	b580      	push	{r7, lr}
 8002e32:	b082      	sub	sp, #8
 8002e34:	af00      	add	r7, sp, #0
 8002e36:	6078      	str	r0, [r7, #4]
  /* Write Data on DR register */
  I2SxEXT(hi2s->Instance)->DR = (*hi2s->pTxBuffPtr++);
 8002e38:	687b      	ldr	r3, [r7, #4]
 8002e3a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8002e3c:	1c99      	adds	r1, r3, #2
 8002e3e:	687a      	ldr	r2, [r7, #4]
 8002e40:	6251      	str	r1, [r2, #36]	@ 0x24
 8002e42:	8819      	ldrh	r1, [r3, #0]
 8002e44:	687b      	ldr	r3, [r7, #4]
 8002e46:	681b      	ldr	r3, [r3, #0]
 8002e48:	4a1d      	ldr	r2, [pc, #116]	@ (8002ec0 <I2SEx_TxISR_I2SExt+0x90>)
 8002e4a:	4293      	cmp	r3, r2
 8002e4c:	d101      	bne.n	8002e52 <I2SEx_TxISR_I2SExt+0x22>
 8002e4e:	4b1d      	ldr	r3, [pc, #116]	@ (8002ec4 <I2SEx_TxISR_I2SExt+0x94>)
 8002e50:	e001      	b.n	8002e56 <I2SEx_TxISR_I2SExt+0x26>
 8002e52:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002e56:	460a      	mov	r2, r1
 8002e58:	60da      	str	r2, [r3, #12]
  hi2s->TxXferCount--;
 8002e5a:	687b      	ldr	r3, [r7, #4]
 8002e5c:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8002e5e:	b29b      	uxth	r3, r3
 8002e60:	3b01      	subs	r3, #1
 8002e62:	b29a      	uxth	r2, r3
 8002e64:	687b      	ldr	r3, [r7, #4]
 8002e66:	855a      	strh	r2, [r3, #42]	@ 0x2a

  if (hi2s->TxXferCount == 0U)
 8002e68:	687b      	ldr	r3, [r7, #4]
 8002e6a:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8002e6c:	b29b      	uxth	r3, r3
 8002e6e:	2b00      	cmp	r3, #0
 8002e70:	d121      	bne.n	8002eb6 <I2SEx_TxISR_I2SExt+0x86>
  {
    /* Disable I2Sext TXE and ERR interrupt */
    __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 8002e72:	687b      	ldr	r3, [r7, #4]
 8002e74:	681b      	ldr	r3, [r3, #0]
 8002e76:	4a12      	ldr	r2, [pc, #72]	@ (8002ec0 <I2SEx_TxISR_I2SExt+0x90>)
 8002e78:	4293      	cmp	r3, r2
 8002e7a:	d101      	bne.n	8002e80 <I2SEx_TxISR_I2SExt+0x50>
 8002e7c:	4b11      	ldr	r3, [pc, #68]	@ (8002ec4 <I2SEx_TxISR_I2SExt+0x94>)
 8002e7e:	e001      	b.n	8002e84 <I2SEx_TxISR_I2SExt+0x54>
 8002e80:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002e84:	685a      	ldr	r2, [r3, #4]
 8002e86:	687b      	ldr	r3, [r7, #4]
 8002e88:	681b      	ldr	r3, [r3, #0]
 8002e8a:	490d      	ldr	r1, [pc, #52]	@ (8002ec0 <I2SEx_TxISR_I2SExt+0x90>)
 8002e8c:	428b      	cmp	r3, r1
 8002e8e:	d101      	bne.n	8002e94 <I2SEx_TxISR_I2SExt+0x64>
 8002e90:	4b0c      	ldr	r3, [pc, #48]	@ (8002ec4 <I2SEx_TxISR_I2SExt+0x94>)
 8002e92:	e001      	b.n	8002e98 <I2SEx_TxISR_I2SExt+0x68>
 8002e94:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002e98:	f022 02a0 	bic.w	r2, r2, #160	@ 0xa0
 8002e9c:	605a      	str	r2, [r3, #4]

    if (hi2s->RxXferCount == 0U)
 8002e9e:	687b      	ldr	r3, [r7, #4]
 8002ea0:	8e5b      	ldrh	r3, [r3, #50]	@ 0x32
 8002ea2:	b29b      	uxth	r3, r3
 8002ea4:	2b00      	cmp	r3, #0
 8002ea6:	d106      	bne.n	8002eb6 <I2SEx_TxISR_I2SExt+0x86>
    {
      hi2s->State = HAL_I2S_STATE_READY;
 8002ea8:	687b      	ldr	r3, [r7, #4]
 8002eaa:	2201      	movs	r2, #1
 8002eac:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
      /* Call user TxRx complete callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->TxRxCpltCallback(hi2s);
#else
      HAL_I2SEx_TxRxCpltCallback(hi2s);
 8002eb0:	6878      	ldr	r0, [r7, #4]
 8002eb2:	f7ff ff81 	bl	8002db8 <HAL_I2SEx_TxRxCpltCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }
  }
}
 8002eb6:	bf00      	nop
 8002eb8:	3708      	adds	r7, #8
 8002eba:	46bd      	mov	sp, r7
 8002ebc:	bd80      	pop	{r7, pc}
 8002ebe:	bf00      	nop
 8002ec0:	40003800 	.word	0x40003800
 8002ec4:	40003400 	.word	0x40003400

08002ec8 <I2SEx_RxISR_I2S>:
  * @brief  I2S Full-Duplex IT handler receive function
  * @param  hi2s I2S handle
  * @retval None
  */
static void I2SEx_RxISR_I2S(I2S_HandleTypeDef *hi2s)
{
 8002ec8:	b580      	push	{r7, lr}
 8002eca:	b082      	sub	sp, #8
 8002ecc:	af00      	add	r7, sp, #0
 8002ece:	6078      	str	r0, [r7, #4]
  /* Read Data from DR register */
  (*hi2s->pRxBuffPtr++) = hi2s->Instance->DR;
 8002ed0:	687b      	ldr	r3, [r7, #4]
 8002ed2:	681b      	ldr	r3, [r3, #0]
 8002ed4:	68d8      	ldr	r0, [r3, #12]
 8002ed6:	687b      	ldr	r3, [r7, #4]
 8002ed8:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8002eda:	1c99      	adds	r1, r3, #2
 8002edc:	687a      	ldr	r2, [r7, #4]
 8002ede:	62d1      	str	r1, [r2, #44]	@ 0x2c
 8002ee0:	b282      	uxth	r2, r0
 8002ee2:	801a      	strh	r2, [r3, #0]
  hi2s->RxXferCount--;
 8002ee4:	687b      	ldr	r3, [r7, #4]
 8002ee6:	8e5b      	ldrh	r3, [r3, #50]	@ 0x32
 8002ee8:	b29b      	uxth	r3, r3
 8002eea:	3b01      	subs	r3, #1
 8002eec:	b29a      	uxth	r2, r3
 8002eee:	687b      	ldr	r3, [r7, #4]
 8002ef0:	865a      	strh	r2, [r3, #50]	@ 0x32

  if (hi2s->RxXferCount == 0U)
 8002ef2:	687b      	ldr	r3, [r7, #4]
 8002ef4:	8e5b      	ldrh	r3, [r3, #50]	@ 0x32
 8002ef6:	b29b      	uxth	r3, r3
 8002ef8:	2b00      	cmp	r3, #0
 8002efa:	d113      	bne.n	8002f24 <I2SEx_RxISR_I2S+0x5c>
  {
    /* Disable RXNE and ERR interrupt */
    __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 8002efc:	687b      	ldr	r3, [r7, #4]
 8002efe:	681b      	ldr	r3, [r3, #0]
 8002f00:	685a      	ldr	r2, [r3, #4]
 8002f02:	687b      	ldr	r3, [r7, #4]
 8002f04:	681b      	ldr	r3, [r3, #0]
 8002f06:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 8002f0a:	605a      	str	r2, [r3, #4]

    if (hi2s->TxXferCount == 0U)
 8002f0c:	687b      	ldr	r3, [r7, #4]
 8002f0e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8002f10:	b29b      	uxth	r3, r3
 8002f12:	2b00      	cmp	r3, #0
 8002f14:	d106      	bne.n	8002f24 <I2SEx_RxISR_I2S+0x5c>
    {
      hi2s->State = HAL_I2S_STATE_READY;
 8002f16:	687b      	ldr	r3, [r7, #4]
 8002f18:	2201      	movs	r2, #1
 8002f1a:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
      /* Call user TxRx complete callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->TxRxCpltCallback(hi2s);
#else
      HAL_I2SEx_TxRxCpltCallback(hi2s);
 8002f1e:	6878      	ldr	r0, [r7, #4]
 8002f20:	f7ff ff4a 	bl	8002db8 <HAL_I2SEx_TxRxCpltCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }
  }
}
 8002f24:	bf00      	nop
 8002f26:	3708      	adds	r7, #8
 8002f28:	46bd      	mov	sp, r7
 8002f2a:	bd80      	pop	{r7, pc}

08002f2c <I2SEx_RxISR_I2SExt>:
  * @brief  I2SExt Full-Duplex IT handler receive function
  * @param  hi2s I2S handle
  * @retval None
  */
static void I2SEx_RxISR_I2SExt(I2S_HandleTypeDef *hi2s)
{
 8002f2c:	b580      	push	{r7, lr}
 8002f2e:	b082      	sub	sp, #8
 8002f30:	af00      	add	r7, sp, #0
 8002f32:	6078      	str	r0, [r7, #4]
  /* Read Data from DR register */
  (*hi2s->pRxBuffPtr++) = I2SxEXT(hi2s->Instance)->DR;
 8002f34:	687b      	ldr	r3, [r7, #4]
 8002f36:	681b      	ldr	r3, [r3, #0]
 8002f38:	4a20      	ldr	r2, [pc, #128]	@ (8002fbc <I2SEx_RxISR_I2SExt+0x90>)
 8002f3a:	4293      	cmp	r3, r2
 8002f3c:	d101      	bne.n	8002f42 <I2SEx_RxISR_I2SExt+0x16>
 8002f3e:	4b20      	ldr	r3, [pc, #128]	@ (8002fc0 <I2SEx_RxISR_I2SExt+0x94>)
 8002f40:	e001      	b.n	8002f46 <I2SEx_RxISR_I2SExt+0x1a>
 8002f42:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002f46:	68d8      	ldr	r0, [r3, #12]
 8002f48:	687b      	ldr	r3, [r7, #4]
 8002f4a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8002f4c:	1c99      	adds	r1, r3, #2
 8002f4e:	687a      	ldr	r2, [r7, #4]
 8002f50:	62d1      	str	r1, [r2, #44]	@ 0x2c
 8002f52:	b282      	uxth	r2, r0
 8002f54:	801a      	strh	r2, [r3, #0]
  hi2s->RxXferCount--;
 8002f56:	687b      	ldr	r3, [r7, #4]
 8002f58:	8e5b      	ldrh	r3, [r3, #50]	@ 0x32
 8002f5a:	b29b      	uxth	r3, r3
 8002f5c:	3b01      	subs	r3, #1
 8002f5e:	b29a      	uxth	r2, r3
 8002f60:	687b      	ldr	r3, [r7, #4]
 8002f62:	865a      	strh	r2, [r3, #50]	@ 0x32

  if (hi2s->RxXferCount == 0U)
 8002f64:	687b      	ldr	r3, [r7, #4]
 8002f66:	8e5b      	ldrh	r3, [r3, #50]	@ 0x32
 8002f68:	b29b      	uxth	r3, r3
 8002f6a:	2b00      	cmp	r3, #0
 8002f6c:	d121      	bne.n	8002fb2 <I2SEx_RxISR_I2SExt+0x86>
  {
    /* Disable I2Sext RXNE and ERR interrupt */
    __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 8002f6e:	687b      	ldr	r3, [r7, #4]
 8002f70:	681b      	ldr	r3, [r3, #0]
 8002f72:	4a12      	ldr	r2, [pc, #72]	@ (8002fbc <I2SEx_RxISR_I2SExt+0x90>)
 8002f74:	4293      	cmp	r3, r2
 8002f76:	d101      	bne.n	8002f7c <I2SEx_RxISR_I2SExt+0x50>
 8002f78:	4b11      	ldr	r3, [pc, #68]	@ (8002fc0 <I2SEx_RxISR_I2SExt+0x94>)
 8002f7a:	e001      	b.n	8002f80 <I2SEx_RxISR_I2SExt+0x54>
 8002f7c:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002f80:	685a      	ldr	r2, [r3, #4]
 8002f82:	687b      	ldr	r3, [r7, #4]
 8002f84:	681b      	ldr	r3, [r3, #0]
 8002f86:	490d      	ldr	r1, [pc, #52]	@ (8002fbc <I2SEx_RxISR_I2SExt+0x90>)
 8002f88:	428b      	cmp	r3, r1
 8002f8a:	d101      	bne.n	8002f90 <I2SEx_RxISR_I2SExt+0x64>
 8002f8c:	4b0c      	ldr	r3, [pc, #48]	@ (8002fc0 <I2SEx_RxISR_I2SExt+0x94>)
 8002f8e:	e001      	b.n	8002f94 <I2SEx_RxISR_I2SExt+0x68>
 8002f90:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002f94:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 8002f98:	605a      	str	r2, [r3, #4]

    if (hi2s->TxXferCount == 0U)
 8002f9a:	687b      	ldr	r3, [r7, #4]
 8002f9c:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8002f9e:	b29b      	uxth	r3, r3
 8002fa0:	2b00      	cmp	r3, #0
 8002fa2:	d106      	bne.n	8002fb2 <I2SEx_RxISR_I2SExt+0x86>
    {
      hi2s->State = HAL_I2S_STATE_READY;
 8002fa4:	687b      	ldr	r3, [r7, #4]
 8002fa6:	2201      	movs	r2, #1
 8002fa8:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
      /* Call user TxRx complete callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->TxRxCpltCallback(hi2s);
#else
      HAL_I2SEx_TxRxCpltCallback(hi2s);
 8002fac:	6878      	ldr	r0, [r7, #4]
 8002fae:	f7ff ff03 	bl	8002db8 <HAL_I2SEx_TxRxCpltCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }
  }
}
 8002fb2:	bf00      	nop
 8002fb4:	3708      	adds	r7, #8
 8002fb6:	46bd      	mov	sp, r7
 8002fb8:	bd80      	pop	{r7, pc}
 8002fba:	bf00      	nop
 8002fbc:	40003800 	.word	0x40003800
 8002fc0:	40003400 	.word	0x40003400

08002fc4 <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{
 8002fc4:	b580      	push	{r7, lr}
 8002fc6:	b086      	sub	sp, #24
 8002fc8:	af02      	add	r7, sp, #8
 8002fca:	6078      	str	r0, [r7, #4]
  const USB_OTG_GlobalTypeDef *USBx;
#endif /* defined (USB_OTG_FS) */
  uint8_t i;

  /* Check the PCD handle allocation */
  if (hpcd == NULL)
 8002fcc:	687b      	ldr	r3, [r7, #4]
 8002fce:	2b00      	cmp	r3, #0
 8002fd0:	d101      	bne.n	8002fd6 <HAL_PCD_Init+0x12>
  {
    return HAL_ERROR;
 8002fd2:	2301      	movs	r3, #1
 8002fd4:	e101      	b.n	80031da <HAL_PCD_Init+0x216>

  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

#if defined (USB_OTG_FS)
  USBx = hpcd->Instance;
 8002fd6:	687b      	ldr	r3, [r7, #4]
 8002fd8:	681b      	ldr	r3, [r3, #0]
 8002fda:	60bb      	str	r3, [r7, #8]
#endif /* defined (USB_OTG_FS) */

  if (hpcd->State == HAL_PCD_STATE_RESET)
 8002fdc:	687b      	ldr	r3, [r7, #4]
 8002fde:	f893 3495 	ldrb.w	r3, [r3, #1173]	@ 0x495
 8002fe2:	b2db      	uxtb	r3, r3
 8002fe4:	2b00      	cmp	r3, #0
 8002fe6:	d106      	bne.n	8002ff6 <HAL_PCD_Init+0x32>
  {
    /* Allocate lock resource and initialize it */
    hpcd->Lock = HAL_UNLOCKED;
 8002fe8:	687b      	ldr	r3, [r7, #4]
 8002fea:	2200      	movs	r2, #0
 8002fec:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

    /* Init the low level hardware */
    hpcd->MspInitCallback(hpcd);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_PCD_MspInit(hpcd);
 8002ff0:	6878      	ldr	r0, [r7, #4]
 8002ff2:	f024 fdfb 	bl	8027bec <HAL_PCD_MspInit>
#endif /* (USE_HAL_PCD_REGISTER_CALLBACKS) */
  }

  hpcd->State = HAL_PCD_STATE_BUSY;
 8002ff6:	687b      	ldr	r3, [r7, #4]
 8002ff8:	2203      	movs	r2, #3
 8002ffa:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495

#if defined (USB_OTG_FS)
  /* Disable DMA mode for FS instance */
  if (USBx == USB_OTG_FS)
 8002ffe:	68bb      	ldr	r3, [r7, #8]
 8003000:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 8003004:	d102      	bne.n	800300c <HAL_PCD_Init+0x48>
  {
    hpcd->Init.dma_enable = 0U;
 8003006:	687b      	ldr	r3, [r7, #4]
 8003008:	2200      	movs	r2, #0
 800300a:	719a      	strb	r2, [r3, #6]
  }
#endif /* defined (USB_OTG_FS) */

  /* Disable the Interrupts */
  __HAL_PCD_DISABLE(hpcd);
 800300c:	687b      	ldr	r3, [r7, #4]
 800300e:	681b      	ldr	r3, [r3, #0]
 8003010:	4618      	mov	r0, r3
 8003012:	f002 fa3a 	bl	800548a <USB_DisableGlobalInt>

  /*Init the Core (common init.) */
  if (USB_CoreInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 8003016:	687b      	ldr	r3, [r7, #4]
 8003018:	6818      	ldr	r0, [r3, #0]
 800301a:	687b      	ldr	r3, [r7, #4]
 800301c:	7c1a      	ldrb	r2, [r3, #16]
 800301e:	f88d 2000 	strb.w	r2, [sp]
 8003022:	3304      	adds	r3, #4
 8003024:	cb0e      	ldmia	r3, {r1, r2, r3}
 8003026:	f002 f918 	bl	800525a <USB_CoreInit>
 800302a:	4603      	mov	r3, r0
 800302c:	2b00      	cmp	r3, #0
 800302e:	d005      	beq.n	800303c <HAL_PCD_Init+0x78>
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
 8003030:	687b      	ldr	r3, [r7, #4]
 8003032:	2202      	movs	r2, #2
 8003034:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495
    return HAL_ERROR;
 8003038:	2301      	movs	r3, #1
 800303a:	e0ce      	b.n	80031da <HAL_PCD_Init+0x216>
  }

  /* Force Device Mode */
  if (USB_SetCurrentMode(hpcd->Instance, USB_DEVICE_MODE) != HAL_OK)
 800303c:	687b      	ldr	r3, [r7, #4]
 800303e:	681b      	ldr	r3, [r3, #0]
 8003040:	2100      	movs	r1, #0
 8003042:	4618      	mov	r0, r3
 8003044:	f002 fa32 	bl	80054ac <USB_SetCurrentMode>
 8003048:	4603      	mov	r3, r0
 800304a:	2b00      	cmp	r3, #0
 800304c:	d005      	beq.n	800305a <HAL_PCD_Init+0x96>
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
 800304e:	687b      	ldr	r3, [r7, #4]
 8003050:	2202      	movs	r2, #2
 8003052:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495
    return HAL_ERROR;
 8003056:	2301      	movs	r3, #1
 8003058:	e0bf      	b.n	80031da <HAL_PCD_Init+0x216>
  }

  /* Init endpoints structures */
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800305a:	2300      	movs	r3, #0
 800305c:	73fb      	strb	r3, [r7, #15]
 800305e:	e04a      	b.n	80030f6 <HAL_PCD_Init+0x132>
  {
    /* Init ep structure */
    hpcd->IN_ep[i].is_in = 1U;
 8003060:	7bfa      	ldrb	r2, [r7, #15]
 8003062:	6879      	ldr	r1, [r7, #4]
 8003064:	4613      	mov	r3, r2
 8003066:	00db      	lsls	r3, r3, #3
 8003068:	4413      	add	r3, r2
 800306a:	009b      	lsls	r3, r3, #2
 800306c:	440b      	add	r3, r1
 800306e:	3315      	adds	r3, #21
 8003070:	2201      	movs	r2, #1
 8003072:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].num = i;
 8003074:	7bfa      	ldrb	r2, [r7, #15]
 8003076:	6879      	ldr	r1, [r7, #4]
 8003078:	4613      	mov	r3, r2
 800307a:	00db      	lsls	r3, r3, #3
 800307c:	4413      	add	r3, r2
 800307e:	009b      	lsls	r3, r3, #2
 8003080:	440b      	add	r3, r1
 8003082:	3314      	adds	r3, #20
 8003084:	7bfa      	ldrb	r2, [r7, #15]
 8003086:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].tx_fifo_num = i;
 8003088:	7bfa      	ldrb	r2, [r7, #15]
 800308a:	7bfb      	ldrb	r3, [r7, #15]
 800308c:	b298      	uxth	r0, r3
 800308e:	6879      	ldr	r1, [r7, #4]
 8003090:	4613      	mov	r3, r2
 8003092:	00db      	lsls	r3, r3, #3
 8003094:	4413      	add	r3, r2
 8003096:	009b      	lsls	r3, r3, #2
 8003098:	440b      	add	r3, r1
 800309a:	332e      	adds	r3, #46	@ 0x2e
 800309c:	4602      	mov	r2, r0
 800309e:	801a      	strh	r2, [r3, #0]
    /* Control until ep is activated */
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 80030a0:	7bfa      	ldrb	r2, [r7, #15]
 80030a2:	6879      	ldr	r1, [r7, #4]
 80030a4:	4613      	mov	r3, r2
 80030a6:	00db      	lsls	r3, r3, #3
 80030a8:	4413      	add	r3, r2
 80030aa:	009b      	lsls	r3, r3, #2
 80030ac:	440b      	add	r3, r1
 80030ae:	3318      	adds	r3, #24
 80030b0:	2200      	movs	r2, #0
 80030b2:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].maxpacket = 0U;
 80030b4:	7bfa      	ldrb	r2, [r7, #15]
 80030b6:	6879      	ldr	r1, [r7, #4]
 80030b8:	4613      	mov	r3, r2
 80030ba:	00db      	lsls	r3, r3, #3
 80030bc:	4413      	add	r3, r2
 80030be:	009b      	lsls	r3, r3, #2
 80030c0:	440b      	add	r3, r1
 80030c2:	331c      	adds	r3, #28
 80030c4:	2200      	movs	r2, #0
 80030c6:	601a      	str	r2, [r3, #0]
    hpcd->IN_ep[i].xfer_buff = 0U;
 80030c8:	7bfa      	ldrb	r2, [r7, #15]
 80030ca:	6879      	ldr	r1, [r7, #4]
 80030cc:	4613      	mov	r3, r2
 80030ce:	00db      	lsls	r3, r3, #3
 80030d0:	4413      	add	r3, r2
 80030d2:	009b      	lsls	r3, r3, #2
 80030d4:	440b      	add	r3, r1
 80030d6:	3320      	adds	r3, #32
 80030d8:	2200      	movs	r2, #0
 80030da:	601a      	str	r2, [r3, #0]
    hpcd->IN_ep[i].xfer_len = 0U;
 80030dc:	7bfa      	ldrb	r2, [r7, #15]
 80030de:	6879      	ldr	r1, [r7, #4]
 80030e0:	4613      	mov	r3, r2
 80030e2:	00db      	lsls	r3, r3, #3
 80030e4:	4413      	add	r3, r2
 80030e6:	009b      	lsls	r3, r3, #2
 80030e8:	440b      	add	r3, r1
 80030ea:	3324      	adds	r3, #36	@ 0x24
 80030ec:	2200      	movs	r2, #0
 80030ee:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80030f0:	7bfb      	ldrb	r3, [r7, #15]
 80030f2:	3301      	adds	r3, #1
 80030f4:	73fb      	strb	r3, [r7, #15]
 80030f6:	687b      	ldr	r3, [r7, #4]
 80030f8:	791b      	ldrb	r3, [r3, #4]
 80030fa:	7bfa      	ldrb	r2, [r7, #15]
 80030fc:	429a      	cmp	r2, r3
 80030fe:	d3af      	bcc.n	8003060 <HAL_PCD_Init+0x9c>
  }

  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8003100:	2300      	movs	r3, #0
 8003102:	73fb      	strb	r3, [r7, #15]
 8003104:	e044      	b.n	8003190 <HAL_PCD_Init+0x1cc>
  {
    hpcd->OUT_ep[i].is_in = 0U;
 8003106:	7bfa      	ldrb	r2, [r7, #15]
 8003108:	6879      	ldr	r1, [r7, #4]
 800310a:	4613      	mov	r3, r2
 800310c:	00db      	lsls	r3, r3, #3
 800310e:	4413      	add	r3, r2
 8003110:	009b      	lsls	r3, r3, #2
 8003112:	440b      	add	r3, r1
 8003114:	f203 2355 	addw	r3, r3, #597	@ 0x255
 8003118:	2200      	movs	r2, #0
 800311a:	701a      	strb	r2, [r3, #0]
    hpcd->OUT_ep[i].num = i;
 800311c:	7bfa      	ldrb	r2, [r7, #15]
 800311e:	6879      	ldr	r1, [r7, #4]
 8003120:	4613      	mov	r3, r2
 8003122:	00db      	lsls	r3, r3, #3
 8003124:	4413      	add	r3, r2
 8003126:	009b      	lsls	r3, r3, #2
 8003128:	440b      	add	r3, r1
 800312a:	f503 7315 	add.w	r3, r3, #596	@ 0x254
 800312e:	7bfa      	ldrb	r2, [r7, #15]
 8003130:	701a      	strb	r2, [r3, #0]
    /* Control until ep is activated */
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 8003132:	7bfa      	ldrb	r2, [r7, #15]
 8003134:	6879      	ldr	r1, [r7, #4]
 8003136:	4613      	mov	r3, r2
 8003138:	00db      	lsls	r3, r3, #3
 800313a:	4413      	add	r3, r2
 800313c:	009b      	lsls	r3, r3, #2
 800313e:	440b      	add	r3, r1
 8003140:	f503 7316 	add.w	r3, r3, #600	@ 0x258
 8003144:	2200      	movs	r2, #0
 8003146:	701a      	strb	r2, [r3, #0]
    hpcd->OUT_ep[i].maxpacket = 0U;
 8003148:	7bfa      	ldrb	r2, [r7, #15]
 800314a:	6879      	ldr	r1, [r7, #4]
 800314c:	4613      	mov	r3, r2
 800314e:	00db      	lsls	r3, r3, #3
 8003150:	4413      	add	r3, r2
 8003152:	009b      	lsls	r3, r3, #2
 8003154:	440b      	add	r3, r1
 8003156:	f503 7317 	add.w	r3, r3, #604	@ 0x25c
 800315a:	2200      	movs	r2, #0
 800315c:	601a      	str	r2, [r3, #0]
    hpcd->OUT_ep[i].xfer_buff = 0U;
 800315e:	7bfa      	ldrb	r2, [r7, #15]
 8003160:	6879      	ldr	r1, [r7, #4]
 8003162:	4613      	mov	r3, r2
 8003164:	00db      	lsls	r3, r3, #3
 8003166:	4413      	add	r3, r2
 8003168:	009b      	lsls	r3, r3, #2
 800316a:	440b      	add	r3, r1
 800316c:	f503 7318 	add.w	r3, r3, #608	@ 0x260
 8003170:	2200      	movs	r2, #0
 8003172:	601a      	str	r2, [r3, #0]
    hpcd->OUT_ep[i].xfer_len = 0U;
 8003174:	7bfa      	ldrb	r2, [r7, #15]
 8003176:	6879      	ldr	r1, [r7, #4]
 8003178:	4613      	mov	r3, r2
 800317a:	00db      	lsls	r3, r3, #3
 800317c:	4413      	add	r3, r2
 800317e:	009b      	lsls	r3, r3, #2
 8003180:	440b      	add	r3, r1
 8003182:	f503 7319 	add.w	r3, r3, #612	@ 0x264
 8003186:	2200      	movs	r2, #0
 8003188:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800318a:	7bfb      	ldrb	r3, [r7, #15]
 800318c:	3301      	adds	r3, #1
 800318e:	73fb      	strb	r3, [r7, #15]
 8003190:	687b      	ldr	r3, [r7, #4]
 8003192:	791b      	ldrb	r3, [r3, #4]
 8003194:	7bfa      	ldrb	r2, [r7, #15]
 8003196:	429a      	cmp	r2, r3
 8003198:	d3b5      	bcc.n	8003106 <HAL_PCD_Init+0x142>
  }

  /* Init Device */
  if (USB_DevInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 800319a:	687b      	ldr	r3, [r7, #4]
 800319c:	6818      	ldr	r0, [r3, #0]
 800319e:	687b      	ldr	r3, [r7, #4]
 80031a0:	7c1a      	ldrb	r2, [r3, #16]
 80031a2:	f88d 2000 	strb.w	r2, [sp]
 80031a6:	3304      	adds	r3, #4
 80031a8:	cb0e      	ldmia	r3, {r1, r2, r3}
 80031aa:	f002 f9cb 	bl	8005544 <USB_DevInit>
 80031ae:	4603      	mov	r3, r0
 80031b0:	2b00      	cmp	r3, #0
 80031b2:	d005      	beq.n	80031c0 <HAL_PCD_Init+0x1fc>
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
 80031b4:	687b      	ldr	r3, [r7, #4]
 80031b6:	2202      	movs	r2, #2
 80031b8:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495
    return HAL_ERROR;
 80031bc:	2301      	movs	r3, #1
 80031be:	e00c      	b.n	80031da <HAL_PCD_Init+0x216>
  }

  hpcd->USB_Address = 0U;
 80031c0:	687b      	ldr	r3, [r7, #4]
 80031c2:	2200      	movs	r2, #0
 80031c4:	745a      	strb	r2, [r3, #17]
  hpcd->State = HAL_PCD_STATE_READY;
 80031c6:	687b      	ldr	r3, [r7, #4]
 80031c8:	2201      	movs	r2, #1
 80031ca:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495
    (void)HAL_PCDEx_ActivateLPM(hpcd);
  }
#endif /* defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) ||
          defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) ||
          defined(STM32F423xx) */
  (void)USB_DevDisconnect(hpcd->Instance);
 80031ce:	687b      	ldr	r3, [r7, #4]
 80031d0:	681b      	ldr	r3, [r3, #0]
 80031d2:	4618      	mov	r0, r3
 80031d4:	f003 fa15 	bl	8006602 <USB_DevDisconnect>

  return HAL_OK;
 80031d8:	2300      	movs	r3, #0
}
 80031da:	4618      	mov	r0, r3
 80031dc:	3710      	adds	r7, #16
 80031de:	46bd      	mov	sp, r7
 80031e0:	bd80      	pop	{r7, pc}

080031e2 <HAL_PCD_Start>:
  * @brief  Start the USB device
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{
 80031e2:	b580      	push	{r7, lr}
 80031e4:	b084      	sub	sp, #16
 80031e6:	af00      	add	r7, sp, #0
 80031e8:	6078      	str	r0, [r7, #4]
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 80031ea:	687b      	ldr	r3, [r7, #4]
 80031ec:	681b      	ldr	r3, [r3, #0]
 80031ee:	60fb      	str	r3, [r7, #12]

  __HAL_LOCK(hpcd);
 80031f0:	687b      	ldr	r3, [r7, #4]
 80031f2:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
 80031f6:	2b01      	cmp	r3, #1
 80031f8:	d101      	bne.n	80031fe <HAL_PCD_Start+0x1c>
 80031fa:	2302      	movs	r3, #2
 80031fc:	e022      	b.n	8003244 <HAL_PCD_Start+0x62>
 80031fe:	687b      	ldr	r3, [r7, #4]
 8003200:	2201      	movs	r2, #1
 8003202:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  if (((USBx->GUSBCFG & USB_OTG_GUSBCFG_PHYSEL) != 0U) &&
 8003206:	68fb      	ldr	r3, [r7, #12]
 8003208:	68db      	ldr	r3, [r3, #12]
 800320a:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 800320e:	2b00      	cmp	r3, #0
 8003210:	d009      	beq.n	8003226 <HAL_PCD_Start+0x44>
      (hpcd->Init.battery_charging_enable == 1U))
 8003212:	687b      	ldr	r3, [r7, #4]
 8003214:	7b5b      	ldrb	r3, [r3, #13]
  if (((USBx->GUSBCFG & USB_OTG_GUSBCFG_PHYSEL) != 0U) &&
 8003216:	2b01      	cmp	r3, #1
 8003218:	d105      	bne.n	8003226 <HAL_PCD_Start+0x44>
  {
    /* Enable USB Transceiver */
    USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 800321a:	68fb      	ldr	r3, [r7, #12]
 800321c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800321e:	f443 3280 	orr.w	r2, r3, #65536	@ 0x10000
 8003222:	68fb      	ldr	r3, [r7, #12]
 8003224:	639a      	str	r2, [r3, #56]	@ 0x38
  }

  __HAL_PCD_ENABLE(hpcd);
 8003226:	687b      	ldr	r3, [r7, #4]
 8003228:	681b      	ldr	r3, [r3, #0]
 800322a:	4618      	mov	r0, r3
 800322c:	f002 f91c 	bl	8005468 <USB_EnableGlobalInt>
  (void)USB_DevConnect(hpcd->Instance);
 8003230:	687b      	ldr	r3, [r7, #4]
 8003232:	681b      	ldr	r3, [r3, #0]
 8003234:	4618      	mov	r0, r3
 8003236:	f003 f9c3 	bl	80065c0 <USB_DevConnect>
  __HAL_UNLOCK(hpcd);
 800323a:	687b      	ldr	r3, [r7, #4]
 800323c:	2200      	movs	r2, #0
 800323e:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return HAL_OK;
 8003242:	2300      	movs	r3, #0
}
 8003244:	4618      	mov	r0, r3
 8003246:	3710      	adds	r7, #16
 8003248:	46bd      	mov	sp, r7
 800324a:	bd80      	pop	{r7, pc}

0800324c <HAL_PCD_IRQHandler>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
 800324c:	b590      	push	{r4, r7, lr}
 800324e:	b08d      	sub	sp, #52	@ 0x34
 8003250:	af00      	add	r7, sp, #0
 8003252:	6078      	str	r0, [r7, #4]
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8003254:	687b      	ldr	r3, [r7, #4]
 8003256:	681b      	ldr	r3, [r3, #0]
 8003258:	623b      	str	r3, [r7, #32]
  uint32_t USBx_BASE = (uint32_t)USBx;
 800325a:	6a3b      	ldr	r3, [r7, #32]
 800325c:	61fb      	str	r3, [r7, #28]
  uint32_t epnum;
  uint32_t fifoemptymsk;
  uint32_t RegVal;

  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
 800325e:	687b      	ldr	r3, [r7, #4]
 8003260:	681b      	ldr	r3, [r3, #0]
 8003262:	4618      	mov	r0, r3
 8003264:	f003 fa81 	bl	800676a <USB_GetMode>
 8003268:	4603      	mov	r3, r0
 800326a:	2b00      	cmp	r3, #0
 800326c:	f040 848c 	bne.w	8003b88 <HAL_PCD_IRQHandler+0x93c>
  {
    /* avoid spurious interrupt */
    if (__HAL_PCD_IS_INVALID_INTERRUPT(hpcd))
 8003270:	687b      	ldr	r3, [r7, #4]
 8003272:	681b      	ldr	r3, [r3, #0]
 8003274:	4618      	mov	r0, r3
 8003276:	f003 f9e5 	bl	8006644 <USB_ReadInterrupts>
 800327a:	4603      	mov	r3, r0
 800327c:	2b00      	cmp	r3, #0
 800327e:	f000 8482 	beq.w	8003b86 <HAL_PCD_IRQHandler+0x93a>
    {
      return;
    }

    /* store current frame number */
    hpcd->FrameNumber = (USBx_DEVICE->DSTS & USB_OTG_DSTS_FNSOF_Msk) >> USB_OTG_DSTS_FNSOF_Pos;
 8003282:	69fb      	ldr	r3, [r7, #28]
 8003284:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8003288:	689b      	ldr	r3, [r3, #8]
 800328a:	0a1b      	lsrs	r3, r3, #8
 800328c:	f3c3 020d 	ubfx	r2, r3, #0, #14
 8003290:	687b      	ldr	r3, [r7, #4]
 8003292:	f8c3 24d4 	str.w	r2, [r3, #1236]	@ 0x4d4

    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
 8003296:	687b      	ldr	r3, [r7, #4]
 8003298:	681b      	ldr	r3, [r3, #0]
 800329a:	4618      	mov	r0, r3
 800329c:	f003 f9d2 	bl	8006644 <USB_ReadInterrupts>
 80032a0:	4603      	mov	r3, r0
 80032a2:	f003 0302 	and.w	r3, r3, #2
 80032a6:	2b02      	cmp	r3, #2
 80032a8:	d107      	bne.n	80032ba <HAL_PCD_IRQHandler+0x6e>
    {
      /* incorrect mode, acknowledge the interrupt */
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 80032aa:	687b      	ldr	r3, [r7, #4]
 80032ac:	681b      	ldr	r3, [r3, #0]
 80032ae:	695a      	ldr	r2, [r3, #20]
 80032b0:	687b      	ldr	r3, [r7, #4]
 80032b2:	681b      	ldr	r3, [r3, #0]
 80032b4:	f002 0202 	and.w	r2, r2, #2
 80032b8:	615a      	str	r2, [r3, #20]
    }

    /* Handle RxQLevel Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 80032ba:	687b      	ldr	r3, [r7, #4]
 80032bc:	681b      	ldr	r3, [r3, #0]
 80032be:	4618      	mov	r0, r3
 80032c0:	f003 f9c0 	bl	8006644 <USB_ReadInterrupts>
 80032c4:	4603      	mov	r3, r0
 80032c6:	f003 0310 	and.w	r3, r3, #16
 80032ca:	2b10      	cmp	r3, #16
 80032cc:	d161      	bne.n	8003392 <HAL_PCD_IRQHandler+0x146>
    {
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 80032ce:	687b      	ldr	r3, [r7, #4]
 80032d0:	681b      	ldr	r3, [r3, #0]
 80032d2:	699a      	ldr	r2, [r3, #24]
 80032d4:	687b      	ldr	r3, [r7, #4]
 80032d6:	681b      	ldr	r3, [r3, #0]
 80032d8:	f022 0210 	bic.w	r2, r2, #16
 80032dc:	619a      	str	r2, [r3, #24]

      RegVal = USBx->GRXSTSP;
 80032de:	6a3b      	ldr	r3, [r7, #32]
 80032e0:	6a1b      	ldr	r3, [r3, #32]
 80032e2:	61bb      	str	r3, [r7, #24]

      ep = &hpcd->OUT_ep[RegVal & USB_OTG_GRXSTSP_EPNUM];
 80032e4:	69bb      	ldr	r3, [r7, #24]
 80032e6:	f003 020f 	and.w	r2, r3, #15
 80032ea:	4613      	mov	r3, r2
 80032ec:	00db      	lsls	r3, r3, #3
 80032ee:	4413      	add	r3, r2
 80032f0:	009b      	lsls	r3, r3, #2
 80032f2:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 80032f6:	687a      	ldr	r2, [r7, #4]
 80032f8:	4413      	add	r3, r2
 80032fa:	3304      	adds	r3, #4
 80032fc:	617b      	str	r3, [r7, #20]

      if (((RegVal & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
 80032fe:	69bb      	ldr	r3, [r7, #24]
 8003300:	f403 13f0 	and.w	r3, r3, #1966080	@ 0x1e0000
 8003304:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 8003308:	d124      	bne.n	8003354 <HAL_PCD_IRQHandler+0x108>
      {
        if ((RegVal & USB_OTG_GRXSTSP_BCNT) != 0U)
 800330a:	69ba      	ldr	r2, [r7, #24]
 800330c:	f647 73f0 	movw	r3, #32752	@ 0x7ff0
 8003310:	4013      	ands	r3, r2
 8003312:	2b00      	cmp	r3, #0
 8003314:	d035      	beq.n	8003382 <HAL_PCD_IRQHandler+0x136>
        {
          (void)USB_ReadPacket(USBx, ep->xfer_buff,
 8003316:	697b      	ldr	r3, [r7, #20]
 8003318:	68d9      	ldr	r1, [r3, #12]
                               (uint16_t)((RegVal & USB_OTG_GRXSTSP_BCNT) >> 4));
 800331a:	69bb      	ldr	r3, [r7, #24]
 800331c:	091b      	lsrs	r3, r3, #4
 800331e:	b29b      	uxth	r3, r3
          (void)USB_ReadPacket(USBx, ep->xfer_buff,
 8003320:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8003324:	b29b      	uxth	r3, r3
 8003326:	461a      	mov	r2, r3
 8003328:	6a38      	ldr	r0, [r7, #32]
 800332a:	f002 fff7 	bl	800631c <USB_ReadPacket>

          ep->xfer_buff += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 800332e:	697b      	ldr	r3, [r7, #20]
 8003330:	68da      	ldr	r2, [r3, #12]
 8003332:	69bb      	ldr	r3, [r7, #24]
 8003334:	091b      	lsrs	r3, r3, #4
 8003336:	f3c3 030a 	ubfx	r3, r3, #0, #11
 800333a:	441a      	add	r2, r3
 800333c:	697b      	ldr	r3, [r7, #20]
 800333e:	60da      	str	r2, [r3, #12]
          ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 8003340:	697b      	ldr	r3, [r7, #20]
 8003342:	695a      	ldr	r2, [r3, #20]
 8003344:	69bb      	ldr	r3, [r7, #24]
 8003346:	091b      	lsrs	r3, r3, #4
 8003348:	f3c3 030a 	ubfx	r3, r3, #0, #11
 800334c:	441a      	add	r2, r3
 800334e:	697b      	ldr	r3, [r7, #20]
 8003350:	615a      	str	r2, [r3, #20]
 8003352:	e016      	b.n	8003382 <HAL_PCD_IRQHandler+0x136>
        }
      }
      else if (((RegVal & USB_OTG_GRXSTSP_PKTSTS) >> 17) == STS_SETUP_UPDT)
 8003354:	69bb      	ldr	r3, [r7, #24]
 8003356:	f403 13f0 	and.w	r3, r3, #1966080	@ 0x1e0000
 800335a:	f5b3 2f40 	cmp.w	r3, #786432	@ 0xc0000
 800335e:	d110      	bne.n	8003382 <HAL_PCD_IRQHandler+0x136>
      {
        (void)USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
 8003360:	687b      	ldr	r3, [r7, #4]
 8003362:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 8003366:	2208      	movs	r2, #8
 8003368:	4619      	mov	r1, r3
 800336a:	6a38      	ldr	r0, [r7, #32]
 800336c:	f002 ffd6 	bl	800631c <USB_ReadPacket>
        ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 8003370:	697b      	ldr	r3, [r7, #20]
 8003372:	695a      	ldr	r2, [r3, #20]
 8003374:	69bb      	ldr	r3, [r7, #24]
 8003376:	091b      	lsrs	r3, r3, #4
 8003378:	f3c3 030a 	ubfx	r3, r3, #0, #11
 800337c:	441a      	add	r2, r3
 800337e:	697b      	ldr	r3, [r7, #20]
 8003380:	615a      	str	r2, [r3, #20]
      else
      {
        /* ... */
      }

      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8003382:	687b      	ldr	r3, [r7, #4]
 8003384:	681b      	ldr	r3, [r3, #0]
 8003386:	699a      	ldr	r2, [r3, #24]
 8003388:	687b      	ldr	r3, [r7, #4]
 800338a:	681b      	ldr	r3, [r3, #0]
 800338c:	f042 0210 	orr.w	r2, r2, #16
 8003390:	619a      	str	r2, [r3, #24]
    }

    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 8003392:	687b      	ldr	r3, [r7, #4]
 8003394:	681b      	ldr	r3, [r3, #0]
 8003396:	4618      	mov	r0, r3
 8003398:	f003 f954 	bl	8006644 <USB_ReadInterrupts>
 800339c:	4603      	mov	r3, r0
 800339e:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
 80033a2:	f5b3 2f00 	cmp.w	r3, #524288	@ 0x80000
 80033a6:	f040 80a7 	bne.w	80034f8 <HAL_PCD_IRQHandler+0x2ac>
    {
      epnum = 0U;
 80033aa:	2300      	movs	r3, #0
 80033ac:	627b      	str	r3, [r7, #36]	@ 0x24

      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
 80033ae:	687b      	ldr	r3, [r7, #4]
 80033b0:	681b      	ldr	r3, [r3, #0]
 80033b2:	4618      	mov	r0, r3
 80033b4:	f003 f959 	bl	800666a <USB_ReadDevAllOutEpInterrupt>
 80033b8:	62b8      	str	r0, [r7, #40]	@ 0x28

      while (ep_intr != 0U)
 80033ba:	e099      	b.n	80034f0 <HAL_PCD_IRQHandler+0x2a4>
      {
        if ((ep_intr & 0x1U) != 0U)
 80033bc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80033be:	f003 0301 	and.w	r3, r3, #1
 80033c2:	2b00      	cmp	r3, #0
 80033c4:	f000 808e 	beq.w	80034e4 <HAL_PCD_IRQHandler+0x298>
        {
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 80033c8:	687b      	ldr	r3, [r7, #4]
 80033ca:	681b      	ldr	r3, [r3, #0]
 80033cc:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80033ce:	b2d2      	uxtb	r2, r2
 80033d0:	4611      	mov	r1, r2
 80033d2:	4618      	mov	r0, r3
 80033d4:	f003 f97d 	bl	80066d2 <USB_ReadDevOutEPInterrupt>
 80033d8:	6138      	str	r0, [r7, #16]

          if ((epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 80033da:	693b      	ldr	r3, [r7, #16]
 80033dc:	f003 0301 	and.w	r3, r3, #1
 80033e0:	2b00      	cmp	r3, #0
 80033e2:	d00c      	beq.n	80033fe <HAL_PCD_IRQHandler+0x1b2>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 80033e4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80033e6:	015a      	lsls	r2, r3, #5
 80033e8:	69fb      	ldr	r3, [r7, #28]
 80033ea:	4413      	add	r3, r2
 80033ec:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80033f0:	461a      	mov	r2, r3
 80033f2:	2301      	movs	r3, #1
 80033f4:	6093      	str	r3, [r2, #8]
            (void)PCD_EP_OutXfrComplete_int(hpcd, epnum);
 80033f6:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 80033f8:	6878      	ldr	r0, [r7, #4]
 80033fa:	f000 fea3 	bl	8004144 <PCD_EP_OutXfrComplete_int>
          }

          if ((epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
 80033fe:	693b      	ldr	r3, [r7, #16]
 8003400:	f003 0308 	and.w	r3, r3, #8
 8003404:	2b00      	cmp	r3, #0
 8003406:	d00c      	beq.n	8003422 <HAL_PCD_IRQHandler+0x1d6>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
 8003408:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800340a:	015a      	lsls	r2, r3, #5
 800340c:	69fb      	ldr	r3, [r7, #28]
 800340e:	4413      	add	r3, r2
 8003410:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8003414:	461a      	mov	r2, r3
 8003416:	2308      	movs	r3, #8
 8003418:	6093      	str	r3, [r2, #8]
            /* Class B setup phase done for previous decoded setup */
            (void)PCD_EP_OutSetupPacket_int(hpcd, epnum);
 800341a:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 800341c:	6878      	ldr	r0, [r7, #4]
 800341e:	f000 ff79 	bl	8004314 <PCD_EP_OutSetupPacket_int>
          }

          if ((epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
 8003422:	693b      	ldr	r3, [r7, #16]
 8003424:	f003 0310 	and.w	r3, r3, #16
 8003428:	2b00      	cmp	r3, #0
 800342a:	d008      	beq.n	800343e <HAL_PCD_IRQHandler+0x1f2>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
 800342c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800342e:	015a      	lsls	r2, r3, #5
 8003430:	69fb      	ldr	r3, [r7, #28]
 8003432:	4413      	add	r3, r2
 8003434:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8003438:	461a      	mov	r2, r3
 800343a:	2310      	movs	r3, #16
 800343c:	6093      	str	r3, [r2, #8]
          }

          /* Clear OUT Endpoint disable interrupt */
          if ((epint & USB_OTG_DOEPINT_EPDISD) == USB_OTG_DOEPINT_EPDISD)
 800343e:	693b      	ldr	r3, [r7, #16]
 8003440:	f003 0302 	and.w	r3, r3, #2
 8003444:	2b00      	cmp	r3, #0
 8003446:	d030      	beq.n	80034aa <HAL_PCD_IRQHandler+0x25e>
          {
            if ((USBx->GINTSTS & USB_OTG_GINTSTS_BOUTNAKEFF) == USB_OTG_GINTSTS_BOUTNAKEFF)
 8003448:	6a3b      	ldr	r3, [r7, #32]
 800344a:	695b      	ldr	r3, [r3, #20]
 800344c:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8003450:	2b80      	cmp	r3, #128	@ 0x80
 8003452:	d109      	bne.n	8003468 <HAL_PCD_IRQHandler+0x21c>
            {
              USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGONAK;
 8003454:	69fb      	ldr	r3, [r7, #28]
 8003456:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800345a:	685b      	ldr	r3, [r3, #4]
 800345c:	69fa      	ldr	r2, [r7, #28]
 800345e:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8003462:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 8003466:	6053      	str	r3, [r2, #4]
            }

            ep = &hpcd->OUT_ep[epnum];
 8003468:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800346a:	4613      	mov	r3, r2
 800346c:	00db      	lsls	r3, r3, #3
 800346e:	4413      	add	r3, r2
 8003470:	009b      	lsls	r3, r3, #2
 8003472:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 8003476:	687a      	ldr	r2, [r7, #4]
 8003478:	4413      	add	r3, r2
 800347a:	3304      	adds	r3, #4
 800347c:	617b      	str	r3, [r7, #20]

            if (ep->is_iso_incomplete == 1U)
 800347e:	697b      	ldr	r3, [r7, #20]
 8003480:	78db      	ldrb	r3, [r3, #3]
 8003482:	2b01      	cmp	r3, #1
 8003484:	d108      	bne.n	8003498 <HAL_PCD_IRQHandler+0x24c>
            {
              ep->is_iso_incomplete = 0U;
 8003486:	697b      	ldr	r3, [r7, #20]
 8003488:	2200      	movs	r2, #0
 800348a:	70da      	strb	r2, [r3, #3]

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
              hpcd->ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
#else
              HAL_PCD_ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
 800348c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800348e:	b2db      	uxtb	r3, r3
 8003490:	4619      	mov	r1, r3
 8003492:	6878      	ldr	r0, [r7, #4]
 8003494:	f024 fcbe 	bl	8027e14 <HAL_PCD_ISOOUTIncompleteCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
            }

            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_EPDISD);
 8003498:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800349a:	015a      	lsls	r2, r3, #5
 800349c:	69fb      	ldr	r3, [r7, #28]
 800349e:	4413      	add	r3, r2
 80034a0:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80034a4:	461a      	mov	r2, r3
 80034a6:	2302      	movs	r3, #2
 80034a8:	6093      	str	r3, [r2, #8]
          }

          /* Clear Status Phase Received interrupt */
          if ((epint & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
 80034aa:	693b      	ldr	r3, [r7, #16]
 80034ac:	f003 0320 	and.w	r3, r3, #32
 80034b0:	2b00      	cmp	r3, #0
 80034b2:	d008      	beq.n	80034c6 <HAL_PCD_IRQHandler+0x27a>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 80034b4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80034b6:	015a      	lsls	r2, r3, #5
 80034b8:	69fb      	ldr	r3, [r7, #28]
 80034ba:	4413      	add	r3, r2
 80034bc:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80034c0:	461a      	mov	r2, r3
 80034c2:	2320      	movs	r3, #32
 80034c4:	6093      	str	r3, [r2, #8]
          }

          /* Clear OUT NAK interrupt */
          if ((epint & USB_OTG_DOEPINT_NAK) == USB_OTG_DOEPINT_NAK)
 80034c6:	693b      	ldr	r3, [r7, #16]
 80034c8:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 80034cc:	2b00      	cmp	r3, #0
 80034ce:	d009      	beq.n	80034e4 <HAL_PCD_IRQHandler+0x298>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_NAK);
 80034d0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80034d2:	015a      	lsls	r2, r3, #5
 80034d4:	69fb      	ldr	r3, [r7, #28]
 80034d6:	4413      	add	r3, r2
 80034d8:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80034dc:	461a      	mov	r2, r3
 80034de:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
 80034e2:	6093      	str	r3, [r2, #8]
          }
        }
        epnum++;
 80034e4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80034e6:	3301      	adds	r3, #1
 80034e8:	627b      	str	r3, [r7, #36]	@ 0x24
        ep_intr >>= 1U;
 80034ea:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80034ec:	085b      	lsrs	r3, r3, #1
 80034ee:	62bb      	str	r3, [r7, #40]	@ 0x28
      while (ep_intr != 0U)
 80034f0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80034f2:	2b00      	cmp	r3, #0
 80034f4:	f47f af62 	bne.w	80033bc <HAL_PCD_IRQHandler+0x170>
      }
    }

    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
 80034f8:	687b      	ldr	r3, [r7, #4]
 80034fa:	681b      	ldr	r3, [r3, #0]
 80034fc:	4618      	mov	r0, r3
 80034fe:	f003 f8a1 	bl	8006644 <USB_ReadInterrupts>
 8003502:	4603      	mov	r3, r0
 8003504:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 8003508:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 800350c:	f040 80db 	bne.w	80036c6 <HAL_PCD_IRQHandler+0x47a>
    {
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
 8003510:	687b      	ldr	r3, [r7, #4]
 8003512:	681b      	ldr	r3, [r3, #0]
 8003514:	4618      	mov	r0, r3
 8003516:	f003 f8c2 	bl	800669e <USB_ReadDevAllInEpInterrupt>
 800351a:	62b8      	str	r0, [r7, #40]	@ 0x28

      epnum = 0U;
 800351c:	2300      	movs	r3, #0
 800351e:	627b      	str	r3, [r7, #36]	@ 0x24

      while (ep_intr != 0U)
 8003520:	e0cd      	b.n	80036be <HAL_PCD_IRQHandler+0x472>
      {
        if ((ep_intr & 0x1U) != 0U) /* In ITR */
 8003522:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8003524:	f003 0301 	and.w	r3, r3, #1
 8003528:	2b00      	cmp	r3, #0
 800352a:	f000 80c2 	beq.w	80036b2 <HAL_PCD_IRQHandler+0x466>
        {
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 800352e:	687b      	ldr	r3, [r7, #4]
 8003530:	681b      	ldr	r3, [r3, #0]
 8003532:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8003534:	b2d2      	uxtb	r2, r2
 8003536:	4611      	mov	r1, r2
 8003538:	4618      	mov	r0, r3
 800353a:	f003 f8e8 	bl	800670e <USB_ReadDevInEPInterrupt>
 800353e:	6138      	str	r0, [r7, #16]

          if ((epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 8003540:	693b      	ldr	r3, [r7, #16]
 8003542:	f003 0301 	and.w	r3, r3, #1
 8003546:	2b00      	cmp	r3, #0
 8003548:	d057      	beq.n	80035fa <HAL_PCD_IRQHandler+0x3ae>
          {
            fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 800354a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800354c:	f003 030f 	and.w	r3, r3, #15
 8003550:	2201      	movs	r2, #1
 8003552:	fa02 f303 	lsl.w	r3, r2, r3
 8003556:	60fb      	str	r3, [r7, #12]
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8003558:	69fb      	ldr	r3, [r7, #28]
 800355a:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800355e:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8003560:	68fb      	ldr	r3, [r7, #12]
 8003562:	43db      	mvns	r3, r3
 8003564:	69f9      	ldr	r1, [r7, #28]
 8003566:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 800356a:	4013      	ands	r3, r2
 800356c:	634b      	str	r3, [r1, #52]	@ 0x34

            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
 800356e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003570:	015a      	lsls	r2, r3, #5
 8003572:	69fb      	ldr	r3, [r7, #28]
 8003574:	4413      	add	r3, r2
 8003576:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800357a:	461a      	mov	r2, r3
 800357c:	2301      	movs	r3, #1
 800357e:	6093      	str	r3, [r2, #8]

            if (hpcd->Init.dma_enable == 1U)
 8003580:	687b      	ldr	r3, [r7, #4]
 8003582:	799b      	ldrb	r3, [r3, #6]
 8003584:	2b01      	cmp	r3, #1
 8003586:	d132      	bne.n	80035ee <HAL_PCD_IRQHandler+0x3a2>
            {
              hpcd->IN_ep[epnum].xfer_buff += hpcd->IN_ep[epnum].maxpacket;
 8003588:	6879      	ldr	r1, [r7, #4]
 800358a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800358c:	4613      	mov	r3, r2
 800358e:	00db      	lsls	r3, r3, #3
 8003590:	4413      	add	r3, r2
 8003592:	009b      	lsls	r3, r3, #2
 8003594:	440b      	add	r3, r1
 8003596:	3320      	adds	r3, #32
 8003598:	6819      	ldr	r1, [r3, #0]
 800359a:	6878      	ldr	r0, [r7, #4]
 800359c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800359e:	4613      	mov	r3, r2
 80035a0:	00db      	lsls	r3, r3, #3
 80035a2:	4413      	add	r3, r2
 80035a4:	009b      	lsls	r3, r3, #2
 80035a6:	4403      	add	r3, r0
 80035a8:	331c      	adds	r3, #28
 80035aa:	681b      	ldr	r3, [r3, #0]
 80035ac:	4419      	add	r1, r3
 80035ae:	6878      	ldr	r0, [r7, #4]
 80035b0:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80035b2:	4613      	mov	r3, r2
 80035b4:	00db      	lsls	r3, r3, #3
 80035b6:	4413      	add	r3, r2
 80035b8:	009b      	lsls	r3, r3, #2
 80035ba:	4403      	add	r3, r0
 80035bc:	3320      	adds	r3, #32
 80035be:	6019      	str	r1, [r3, #0]

              /* this is ZLP, so prepare EP0 for next setup */
              if ((epnum == 0U) && (hpcd->IN_ep[epnum].xfer_len == 0U))
 80035c0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80035c2:	2b00      	cmp	r3, #0
 80035c4:	d113      	bne.n	80035ee <HAL_PCD_IRQHandler+0x3a2>
 80035c6:	6879      	ldr	r1, [r7, #4]
 80035c8:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80035ca:	4613      	mov	r3, r2
 80035cc:	00db      	lsls	r3, r3, #3
 80035ce:	4413      	add	r3, r2
 80035d0:	009b      	lsls	r3, r3, #2
 80035d2:	440b      	add	r3, r1
 80035d4:	3324      	adds	r3, #36	@ 0x24
 80035d6:	681b      	ldr	r3, [r3, #0]
 80035d8:	2b00      	cmp	r3, #0
 80035da:	d108      	bne.n	80035ee <HAL_PCD_IRQHandler+0x3a2>
              {
                /* prepare to rx more setup packets */
                (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 80035dc:	687b      	ldr	r3, [r7, #4]
 80035de:	6818      	ldr	r0, [r3, #0]
 80035e0:	687b      	ldr	r3, [r7, #4]
 80035e2:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 80035e6:	461a      	mov	r2, r3
 80035e8:	2101      	movs	r1, #1
 80035ea:	f003 f8ef 	bl	80067cc <USB_EP0_OutStart>
            }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
            hpcd->DataInStageCallback(hpcd, (uint8_t)epnum);
#else
            HAL_PCD_DataInStageCallback(hpcd, (uint8_t)epnum);
 80035ee:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80035f0:	b2db      	uxtb	r3, r3
 80035f2:	4619      	mov	r1, r3
 80035f4:	6878      	ldr	r0, [r7, #4]
 80035f6:	f024 fb88 	bl	8027d0a <HAL_PCD_DataInStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
          }
          if ((epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)
 80035fa:	693b      	ldr	r3, [r7, #16]
 80035fc:	f003 0308 	and.w	r3, r3, #8
 8003600:	2b00      	cmp	r3, #0
 8003602:	d008      	beq.n	8003616 <HAL_PCD_IRQHandler+0x3ca>
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
 8003604:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003606:	015a      	lsls	r2, r3, #5
 8003608:	69fb      	ldr	r3, [r7, #28]
 800360a:	4413      	add	r3, r2
 800360c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8003610:	461a      	mov	r2, r3
 8003612:	2308      	movs	r3, #8
 8003614:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)
 8003616:	693b      	ldr	r3, [r7, #16]
 8003618:	f003 0310 	and.w	r3, r3, #16
 800361c:	2b00      	cmp	r3, #0
 800361e:	d008      	beq.n	8003632 <HAL_PCD_IRQHandler+0x3e6>
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
 8003620:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003622:	015a      	lsls	r2, r3, #5
 8003624:	69fb      	ldr	r3, [r7, #28]
 8003626:	4413      	add	r3, r2
 8003628:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800362c:	461a      	mov	r2, r3
 800362e:	2310      	movs	r3, #16
 8003630:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
 8003632:	693b      	ldr	r3, [r7, #16]
 8003634:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8003638:	2b00      	cmp	r3, #0
 800363a:	d008      	beq.n	800364e <HAL_PCD_IRQHandler+0x402>
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
 800363c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800363e:	015a      	lsls	r2, r3, #5
 8003640:	69fb      	ldr	r3, [r7, #28]
 8003642:	4413      	add	r3, r2
 8003644:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8003648:	461a      	mov	r2, r3
 800364a:	2340      	movs	r3, #64	@ 0x40
 800364c:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)
 800364e:	693b      	ldr	r3, [r7, #16]
 8003650:	f003 0302 	and.w	r3, r3, #2
 8003654:	2b00      	cmp	r3, #0
 8003656:	d023      	beq.n	80036a0 <HAL_PCD_IRQHandler+0x454>
          {
            (void)USB_FlushTxFifo(USBx, epnum);
 8003658:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 800365a:	6a38      	ldr	r0, [r7, #32]
 800365c:	f002 f8d6 	bl	800580c <USB_FlushTxFifo>

            ep = &hpcd->IN_ep[epnum];
 8003660:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8003662:	4613      	mov	r3, r2
 8003664:	00db      	lsls	r3, r3, #3
 8003666:	4413      	add	r3, r2
 8003668:	009b      	lsls	r3, r3, #2
 800366a:	3310      	adds	r3, #16
 800366c:	687a      	ldr	r2, [r7, #4]
 800366e:	4413      	add	r3, r2
 8003670:	3304      	adds	r3, #4
 8003672:	617b      	str	r3, [r7, #20]

            if (ep->is_iso_incomplete == 1U)
 8003674:	697b      	ldr	r3, [r7, #20]
 8003676:	78db      	ldrb	r3, [r3, #3]
 8003678:	2b01      	cmp	r3, #1
 800367a:	d108      	bne.n	800368e <HAL_PCD_IRQHandler+0x442>
            {
              ep->is_iso_incomplete = 0U;
 800367c:	697b      	ldr	r3, [r7, #20]
 800367e:	2200      	movs	r2, #0
 8003680:	70da      	strb	r2, [r3, #3]

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
              hpcd->ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
#else
              HAL_PCD_ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
 8003682:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003684:	b2db      	uxtb	r3, r3
 8003686:	4619      	mov	r1, r3
 8003688:	6878      	ldr	r0, [r7, #4]
 800368a:	f024 fbd5 	bl	8027e38 <HAL_PCD_ISOINIncompleteCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
            }

            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
 800368e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003690:	015a      	lsls	r2, r3, #5
 8003692:	69fb      	ldr	r3, [r7, #28]
 8003694:	4413      	add	r3, r2
 8003696:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800369a:	461a      	mov	r2, r3
 800369c:	2302      	movs	r3, #2
 800369e:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
 80036a0:	693b      	ldr	r3, [r7, #16]
 80036a2:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 80036a6:	2b00      	cmp	r3, #0
 80036a8:	d003      	beq.n	80036b2 <HAL_PCD_IRQHandler+0x466>
          {
            (void)PCD_WriteEmptyTxFifo(hpcd, epnum);
 80036aa:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 80036ac:	6878      	ldr	r0, [r7, #4]
 80036ae:	f000 fcbd 	bl	800402c <PCD_WriteEmptyTxFifo>
          }
        }
        epnum++;
 80036b2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80036b4:	3301      	adds	r3, #1
 80036b6:	627b      	str	r3, [r7, #36]	@ 0x24
        ep_intr >>= 1U;
 80036b8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80036ba:	085b      	lsrs	r3, r3, #1
 80036bc:	62bb      	str	r3, [r7, #40]	@ 0x28
      while (ep_intr != 0U)
 80036be:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80036c0:	2b00      	cmp	r3, #0
 80036c2:	f47f af2e 	bne.w	8003522 <HAL_PCD_IRQHandler+0x2d6>
      }
    }

    /* Handle Resume Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 80036c6:	687b      	ldr	r3, [r7, #4]
 80036c8:	681b      	ldr	r3, [r3, #0]
 80036ca:	4618      	mov	r0, r3
 80036cc:	f002 ffba 	bl	8006644 <USB_ReadInterrupts>
 80036d0:	4603      	mov	r3, r0
 80036d2:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 80036d6:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 80036da:	d122      	bne.n	8003722 <HAL_PCD_IRQHandler+0x4d6>
    {
      /* Clear the Remote Wake-up Signaling */
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 80036dc:	69fb      	ldr	r3, [r7, #28]
 80036de:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80036e2:	685b      	ldr	r3, [r3, #4]
 80036e4:	69fa      	ldr	r2, [r7, #28]
 80036e6:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 80036ea:	f023 0301 	bic.w	r3, r3, #1
 80036ee:	6053      	str	r3, [r2, #4]

      if (hpcd->LPM_State == LPM_L1)
 80036f0:	687b      	ldr	r3, [r7, #4]
 80036f2:	f893 34cc 	ldrb.w	r3, [r3, #1228]	@ 0x4cc
 80036f6:	2b01      	cmp	r3, #1
 80036f8:	d108      	bne.n	800370c <HAL_PCD_IRQHandler+0x4c0>
      {
        hpcd->LPM_State = LPM_L0;
 80036fa:	687b      	ldr	r3, [r7, #4]
 80036fc:	2200      	movs	r2, #0
 80036fe:	f883 24cc 	strb.w	r2, [r3, #1228]	@ 0x4cc

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->LPMCallback(hpcd, PCD_LPM_L0_ACTIVE);
#else
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
 8003702:	2100      	movs	r1, #0
 8003704:	6878      	ldr	r0, [r7, #4]
 8003706:	f000 fea3 	bl	8004450 <HAL_PCDEx_LPM_Callback>
 800370a:	e002      	b.n	8003712 <HAL_PCD_IRQHandler+0x4c6>
      else
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->ResumeCallback(hpcd);
#else
        HAL_PCD_ResumeCallback(hpcd);
 800370c:	6878      	ldr	r0, [r7, #4]
 800370e:	f024 fb73 	bl	8027df8 <HAL_PCD_ResumeCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
 8003712:	687b      	ldr	r3, [r7, #4]
 8003714:	681b      	ldr	r3, [r3, #0]
 8003716:	695a      	ldr	r2, [r3, #20]
 8003718:	687b      	ldr	r3, [r7, #4]
 800371a:	681b      	ldr	r3, [r3, #0]
 800371c:	f002 4200 	and.w	r2, r2, #2147483648	@ 0x80000000
 8003720:	615a      	str	r2, [r3, #20]
    }

    /* Handle Suspend Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))
 8003722:	687b      	ldr	r3, [r7, #4]
 8003724:	681b      	ldr	r3, [r3, #0]
 8003726:	4618      	mov	r0, r3
 8003728:	f002 ff8c 	bl	8006644 <USB_ReadInterrupts>
 800372c:	4603      	mov	r3, r0
 800372e:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 8003732:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 8003736:	d112      	bne.n	800375e <HAL_PCD_IRQHandler+0x512>
    {
      if ((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
 8003738:	69fb      	ldr	r3, [r7, #28]
 800373a:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800373e:	689b      	ldr	r3, [r3, #8]
 8003740:	f003 0301 	and.w	r3, r3, #1
 8003744:	2b01      	cmp	r3, #1
 8003746:	d102      	bne.n	800374e <HAL_PCD_IRQHandler+0x502>
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->SuspendCallback(hpcd);
#else
        HAL_PCD_SuspendCallback(hpcd);
 8003748:	6878      	ldr	r0, [r7, #4]
 800374a:	f024 fb2f 	bl	8027dac <HAL_PCD_SuspendCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
 800374e:	687b      	ldr	r3, [r7, #4]
 8003750:	681b      	ldr	r3, [r3, #0]
 8003752:	695a      	ldr	r2, [r3, #20]
 8003754:	687b      	ldr	r3, [r7, #4]
 8003756:	681b      	ldr	r3, [r3, #0]
 8003758:	f402 6200 	and.w	r2, r2, #2048	@ 0x800
 800375c:	615a      	str	r2, [r3, #20]
    }
#endif /* defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) ||
          defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) ||
          defined(STM32F423xx) */
    /* Handle Reset Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
 800375e:	687b      	ldr	r3, [r7, #4]
 8003760:	681b      	ldr	r3, [r3, #0]
 8003762:	4618      	mov	r0, r3
 8003764:	f002 ff6e 	bl	8006644 <USB_ReadInterrupts>
 8003768:	4603      	mov	r3, r0
 800376a:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 800376e:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8003772:	f040 80b7 	bne.w	80038e4 <HAL_PCD_IRQHandler+0x698>
    {
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 8003776:	69fb      	ldr	r3, [r7, #28]
 8003778:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800377c:	685b      	ldr	r3, [r3, #4]
 800377e:	69fa      	ldr	r2, [r7, #28]
 8003780:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8003784:	f023 0301 	bic.w	r3, r3, #1
 8003788:	6053      	str	r3, [r2, #4]
      (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);
 800378a:	687b      	ldr	r3, [r7, #4]
 800378c:	681b      	ldr	r3, [r3, #0]
 800378e:	2110      	movs	r1, #16
 8003790:	4618      	mov	r0, r3
 8003792:	f002 f83b 	bl	800580c <USB_FlushTxFifo>

      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8003796:	2300      	movs	r3, #0
 8003798:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800379a:	e046      	b.n	800382a <HAL_PCD_IRQHandler+0x5de>
      {
        USBx_INEP(i)->DIEPINT = 0xFB7FU;
 800379c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800379e:	015a      	lsls	r2, r3, #5
 80037a0:	69fb      	ldr	r3, [r7, #28]
 80037a2:	4413      	add	r3, r2
 80037a4:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80037a8:	461a      	mov	r2, r3
 80037aa:	f64f 337f 	movw	r3, #64383	@ 0xfb7f
 80037ae:	6093      	str	r3, [r2, #8]
        USBx_INEP(i)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 80037b0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80037b2:	015a      	lsls	r2, r3, #5
 80037b4:	69fb      	ldr	r3, [r7, #28]
 80037b6:	4413      	add	r3, r2
 80037b8:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80037bc:	681b      	ldr	r3, [r3, #0]
 80037be:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80037c0:	0151      	lsls	r1, r2, #5
 80037c2:	69fa      	ldr	r2, [r7, #28]
 80037c4:	440a      	add	r2, r1
 80037c6:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 80037ca:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
 80037ce:	6013      	str	r3, [r2, #0]
        USBx_OUTEP(i)->DOEPINT = 0xFB7FU;
 80037d0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80037d2:	015a      	lsls	r2, r3, #5
 80037d4:	69fb      	ldr	r3, [r7, #28]
 80037d6:	4413      	add	r3, r2
 80037d8:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80037dc:	461a      	mov	r2, r3
 80037de:	f64f 337f 	movw	r3, #64383	@ 0xfb7f
 80037e2:	6093      	str	r3, [r2, #8]
        USBx_OUTEP(i)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 80037e4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80037e6:	015a      	lsls	r2, r3, #5
 80037e8:	69fb      	ldr	r3, [r7, #28]
 80037ea:	4413      	add	r3, r2
 80037ec:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80037f0:	681b      	ldr	r3, [r3, #0]
 80037f2:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80037f4:	0151      	lsls	r1, r2, #5
 80037f6:	69fa      	ldr	r2, [r7, #28]
 80037f8:	440a      	add	r2, r1
 80037fa:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 80037fe:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
 8003802:	6013      	str	r3, [r2, #0]
        USBx_OUTEP(i)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
 8003804:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8003806:	015a      	lsls	r2, r3, #5
 8003808:	69fb      	ldr	r3, [r7, #28]
 800380a:	4413      	add	r3, r2
 800380c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8003810:	681b      	ldr	r3, [r3, #0]
 8003812:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8003814:	0151      	lsls	r1, r2, #5
 8003816:	69fa      	ldr	r2, [r7, #28]
 8003818:	440a      	add	r2, r1
 800381a:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 800381e:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 8003822:	6013      	str	r3, [r2, #0]
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8003824:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8003826:	3301      	adds	r3, #1
 8003828:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800382a:	687b      	ldr	r3, [r7, #4]
 800382c:	791b      	ldrb	r3, [r3, #4]
 800382e:	461a      	mov	r2, r3
 8003830:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8003832:	4293      	cmp	r3, r2
 8003834:	d3b2      	bcc.n	800379c <HAL_PCD_IRQHandler+0x550>
      }
      USBx_DEVICE->DAINTMSK |= 0x10001U;
 8003836:	69fb      	ldr	r3, [r7, #28]
 8003838:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800383c:	69db      	ldr	r3, [r3, #28]
 800383e:	69fa      	ldr	r2, [r7, #28]
 8003840:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8003844:	f043 1301 	orr.w	r3, r3, #65537	@ 0x10001
 8003848:	61d3      	str	r3, [r2, #28]

      if (hpcd->Init.use_dedicated_ep1 != 0U)
 800384a:	687b      	ldr	r3, [r7, #4]
 800384c:	7bdb      	ldrb	r3, [r3, #15]
 800384e:	2b00      	cmp	r3, #0
 8003850:	d016      	beq.n	8003880 <HAL_PCD_IRQHandler+0x634>
      {
        USBx_DEVICE->DOUTEP1MSK |= USB_OTG_DOEPMSK_STUPM |
 8003852:	69fb      	ldr	r3, [r7, #28]
 8003854:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8003858:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800385c:	69fa      	ldr	r2, [r7, #28]
 800385e:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8003862:	f043 030b 	orr.w	r3, r3, #11
 8003866:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84
                                   USB_OTG_DOEPMSK_XFRCM |
                                   USB_OTG_DOEPMSK_EPDM;

        USBx_DEVICE->DINEP1MSK |= USB_OTG_DIEPMSK_TOM |
 800386a:	69fb      	ldr	r3, [r7, #28]
 800386c:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8003870:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8003872:	69fa      	ldr	r2, [r7, #28]
 8003874:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8003878:	f043 030b 	orr.w	r3, r3, #11
 800387c:	6453      	str	r3, [r2, #68]	@ 0x44
 800387e:	e015      	b.n	80038ac <HAL_PCD_IRQHandler+0x660>
                                  USB_OTG_DIEPMSK_XFRCM |
                                  USB_OTG_DIEPMSK_EPDM;
      }
      else
      {
        USBx_DEVICE->DOEPMSK |= USB_OTG_DOEPMSK_STUPM |
 8003880:	69fb      	ldr	r3, [r7, #28]
 8003882:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8003886:	695b      	ldr	r3, [r3, #20]
 8003888:	69fa      	ldr	r2, [r7, #28]
 800388a:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 800388e:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 8003892:	f043 032b 	orr.w	r3, r3, #43	@ 0x2b
 8003896:	6153      	str	r3, [r2, #20]
                                USB_OTG_DOEPMSK_XFRCM |
                                USB_OTG_DOEPMSK_EPDM |
                                USB_OTG_DOEPMSK_OTEPSPRM |
                                USB_OTG_DOEPMSK_NAKM;

        USBx_DEVICE->DIEPMSK |= USB_OTG_DIEPMSK_TOM |
 8003898:	69fb      	ldr	r3, [r7, #28]
 800389a:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800389e:	691b      	ldr	r3, [r3, #16]
 80038a0:	69fa      	ldr	r2, [r7, #28]
 80038a2:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 80038a6:	f043 030b 	orr.w	r3, r3, #11
 80038aa:	6113      	str	r3, [r2, #16]
                                USB_OTG_DIEPMSK_XFRCM |
                                USB_OTG_DIEPMSK_EPDM;
      }

      /* Set Default Address to 0 */
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 80038ac:	69fb      	ldr	r3, [r7, #28]
 80038ae:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80038b2:	681b      	ldr	r3, [r3, #0]
 80038b4:	69fa      	ldr	r2, [r7, #28]
 80038b6:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 80038ba:	f423 63fe 	bic.w	r3, r3, #2032	@ 0x7f0
 80038be:	6013      	str	r3, [r2, #0]

      /* setup EP0 to receive SETUP packets */
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable,
 80038c0:	687b      	ldr	r3, [r7, #4]
 80038c2:	6818      	ldr	r0, [r3, #0]
 80038c4:	687b      	ldr	r3, [r7, #4]
 80038c6:	7999      	ldrb	r1, [r3, #6]
                             (uint8_t *)hpcd->Setup);
 80038c8:	687b      	ldr	r3, [r7, #4]
 80038ca:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable,
 80038ce:	461a      	mov	r2, r3
 80038d0:	f002 ff7c 	bl	80067cc <USB_EP0_OutStart>

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
 80038d4:	687b      	ldr	r3, [r7, #4]
 80038d6:	681b      	ldr	r3, [r3, #0]
 80038d8:	695a      	ldr	r2, [r3, #20]
 80038da:	687b      	ldr	r3, [r7, #4]
 80038dc:	681b      	ldr	r3, [r3, #0]
 80038de:	f402 5280 	and.w	r2, r2, #4096	@ 0x1000
 80038e2:	615a      	str	r2, [r3, #20]
    }

    /* Handle Enumeration done Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
 80038e4:	687b      	ldr	r3, [r7, #4]
 80038e6:	681b      	ldr	r3, [r3, #0]
 80038e8:	4618      	mov	r0, r3
 80038ea:	f002 feab 	bl	8006644 <USB_ReadInterrupts>
 80038ee:	4603      	mov	r3, r0
 80038f0:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 80038f4:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 80038f8:	d123      	bne.n	8003942 <HAL_PCD_IRQHandler+0x6f6>
    {
      (void)USB_ActivateSetup(hpcd->Instance);
 80038fa:	687b      	ldr	r3, [r7, #4]
 80038fc:	681b      	ldr	r3, [r3, #0]
 80038fe:	4618      	mov	r0, r3
 8003900:	f002 ff41 	bl	8006786 <USB_ActivateSetup>
      hpcd->Init.speed = USB_GetDevSpeed(hpcd->Instance);
 8003904:	687b      	ldr	r3, [r7, #4]
 8003906:	681b      	ldr	r3, [r3, #0]
 8003908:	4618      	mov	r0, r3
 800390a:	f001 fff8 	bl	80058fe <USB_GetDevSpeed>
 800390e:	4603      	mov	r3, r0
 8003910:	461a      	mov	r2, r3
 8003912:	687b      	ldr	r3, [r7, #4]
 8003914:	71da      	strb	r2, [r3, #7]

      /* Set USB Turnaround time */
      (void)USB_SetTurnaroundTime(hpcd->Instance,
 8003916:	687b      	ldr	r3, [r7, #4]
 8003918:	681c      	ldr	r4, [r3, #0]
 800391a:	f001 fa09 	bl	8004d30 <HAL_RCC_GetHCLKFreq>
 800391e:	4601      	mov	r1, r0
                                  HAL_RCC_GetHCLKFreq(),
                                  (uint8_t)hpcd->Init.speed);
 8003920:	687b      	ldr	r3, [r7, #4]
 8003922:	79db      	ldrb	r3, [r3, #7]
      (void)USB_SetTurnaroundTime(hpcd->Instance,
 8003924:	461a      	mov	r2, r3
 8003926:	4620      	mov	r0, r4
 8003928:	f001 fcfc 	bl	8005324 <USB_SetTurnaroundTime>

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->ResetCallback(hpcd);
#else
      HAL_PCD_ResetCallback(hpcd);
 800392c:	6878      	ldr	r0, [r7, #4]
 800392e:	f024 fa14 	bl	8027d5a <HAL_PCD_ResetCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
 8003932:	687b      	ldr	r3, [r7, #4]
 8003934:	681b      	ldr	r3, [r3, #0]
 8003936:	695a      	ldr	r2, [r3, #20]
 8003938:	687b      	ldr	r3, [r7, #4]
 800393a:	681b      	ldr	r3, [r3, #0]
 800393c:	f402 5200 	and.w	r2, r2, #8192	@ 0x2000
 8003940:	615a      	str	r2, [r3, #20]
    }

    /* Handle SOF Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))
 8003942:	687b      	ldr	r3, [r7, #4]
 8003944:	681b      	ldr	r3, [r3, #0]
 8003946:	4618      	mov	r0, r3
 8003948:	f002 fe7c 	bl	8006644 <USB_ReadInterrupts>
 800394c:	4603      	mov	r3, r0
 800394e:	f003 0308 	and.w	r3, r3, #8
 8003952:	2b08      	cmp	r3, #8
 8003954:	d10a      	bne.n	800396c <HAL_PCD_IRQHandler+0x720>
    {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->SOFCallback(hpcd);
#else
      HAL_PCD_SOFCallback(hpcd);
 8003956:	6878      	ldr	r0, [r7, #4]
 8003958:	f024 f9f1 	bl	8027d3e <HAL_PCD_SOFCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
 800395c:	687b      	ldr	r3, [r7, #4]
 800395e:	681b      	ldr	r3, [r3, #0]
 8003960:	695a      	ldr	r2, [r3, #20]
 8003962:	687b      	ldr	r3, [r7, #4]
 8003964:	681b      	ldr	r3, [r3, #0]
 8003966:	f002 0208 	and.w	r2, r2, #8
 800396a:	615a      	str	r2, [r3, #20]
    }

    /* Handle Global OUT NAK effective Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_BOUTNAKEFF))
 800396c:	687b      	ldr	r3, [r7, #4]
 800396e:	681b      	ldr	r3, [r3, #0]
 8003970:	4618      	mov	r0, r3
 8003972:	f002 fe67 	bl	8006644 <USB_ReadInterrupts>
 8003976:	4603      	mov	r3, r0
 8003978:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800397c:	2b80      	cmp	r3, #128	@ 0x80
 800397e:	d123      	bne.n	80039c8 <HAL_PCD_IRQHandler+0x77c>
    {
      USBx->GINTMSK &= ~USB_OTG_GINTMSK_GONAKEFFM;
 8003980:	6a3b      	ldr	r3, [r7, #32]
 8003982:	699b      	ldr	r3, [r3, #24]
 8003984:	f023 0280 	bic.w	r2, r3, #128	@ 0x80
 8003988:	6a3b      	ldr	r3, [r7, #32]
 800398a:	619a      	str	r2, [r3, #24]

      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800398c:	2301      	movs	r3, #1
 800398e:	627b      	str	r3, [r7, #36]	@ 0x24
 8003990:	e014      	b.n	80039bc <HAL_PCD_IRQHandler+0x770>
      {
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 8003992:	6879      	ldr	r1, [r7, #4]
 8003994:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8003996:	4613      	mov	r3, r2
 8003998:	00db      	lsls	r3, r3, #3
 800399a:	4413      	add	r3, r2
 800399c:	009b      	lsls	r3, r3, #2
 800399e:	440b      	add	r3, r1
 80039a0:	f203 2357 	addw	r3, r3, #599	@ 0x257
 80039a4:	781b      	ldrb	r3, [r3, #0]
 80039a6:	2b01      	cmp	r3, #1
 80039a8:	d105      	bne.n	80039b6 <HAL_PCD_IRQHandler+0x76a>
        {
          /* Abort current transaction and disable the EP */
          (void)HAL_PCD_EP_Abort(hpcd, (uint8_t)epnum);
 80039aa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80039ac:	b2db      	uxtb	r3, r3
 80039ae:	4619      	mov	r1, r3
 80039b0:	6878      	ldr	r0, [r7, #4]
 80039b2:	f000 fb0a 	bl	8003fca <HAL_PCD_EP_Abort>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 80039b6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80039b8:	3301      	adds	r3, #1
 80039ba:	627b      	str	r3, [r7, #36]	@ 0x24
 80039bc:	687b      	ldr	r3, [r7, #4]
 80039be:	791b      	ldrb	r3, [r3, #4]
 80039c0:	461a      	mov	r2, r3
 80039c2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80039c4:	4293      	cmp	r3, r2
 80039c6:	d3e4      	bcc.n	8003992 <HAL_PCD_IRQHandler+0x746>
        }
      }
    }

    /* Handle Incomplete ISO IN Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))
 80039c8:	687b      	ldr	r3, [r7, #4]
 80039ca:	681b      	ldr	r3, [r3, #0]
 80039cc:	4618      	mov	r0, r3
 80039ce:	f002 fe39 	bl	8006644 <USB_ReadInterrupts>
 80039d2:	4603      	mov	r3, r0
 80039d4:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 80039d8:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 80039dc:	d13c      	bne.n	8003a58 <HAL_PCD_IRQHandler+0x80c>
    {
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 80039de:	2301      	movs	r3, #1
 80039e0:	627b      	str	r3, [r7, #36]	@ 0x24
 80039e2:	e02b      	b.n	8003a3c <HAL_PCD_IRQHandler+0x7f0>
      {
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 80039e4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80039e6:	015a      	lsls	r2, r3, #5
 80039e8:	69fb      	ldr	r3, [r7, #28]
 80039ea:	4413      	add	r3, r2
 80039ec:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80039f0:	681b      	ldr	r3, [r3, #0]
 80039f2:	61bb      	str	r3, [r7, #24]

        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 80039f4:	6879      	ldr	r1, [r7, #4]
 80039f6:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80039f8:	4613      	mov	r3, r2
 80039fa:	00db      	lsls	r3, r3, #3
 80039fc:	4413      	add	r3, r2
 80039fe:	009b      	lsls	r3, r3, #2
 8003a00:	440b      	add	r3, r1
 8003a02:	3318      	adds	r3, #24
 8003a04:	781b      	ldrb	r3, [r3, #0]
 8003a06:	2b01      	cmp	r3, #1
 8003a08:	d115      	bne.n	8003a36 <HAL_PCD_IRQHandler+0x7ea>
            ((RegVal & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA))
 8003a0a:	69bb      	ldr	r3, [r7, #24]
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8003a0c:	2b00      	cmp	r3, #0
 8003a0e:	da12      	bge.n	8003a36 <HAL_PCD_IRQHandler+0x7ea>
        {
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 8003a10:	6879      	ldr	r1, [r7, #4]
 8003a12:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8003a14:	4613      	mov	r3, r2
 8003a16:	00db      	lsls	r3, r3, #3
 8003a18:	4413      	add	r3, r2
 8003a1a:	009b      	lsls	r3, r3, #2
 8003a1c:	440b      	add	r3, r1
 8003a1e:	3317      	adds	r3, #23
 8003a20:	2201      	movs	r2, #1
 8003a22:	701a      	strb	r2, [r3, #0]

          /* Abort current transaction and disable the EP */
          (void)HAL_PCD_EP_Abort(hpcd, (uint8_t)(epnum | 0x80U));
 8003a24:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003a26:	b2db      	uxtb	r3, r3
 8003a28:	f063 037f 	orn	r3, r3, #127	@ 0x7f
 8003a2c:	b2db      	uxtb	r3, r3
 8003a2e:	4619      	mov	r1, r3
 8003a30:	6878      	ldr	r0, [r7, #4]
 8003a32:	f000 faca 	bl	8003fca <HAL_PCD_EP_Abort>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8003a36:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003a38:	3301      	adds	r3, #1
 8003a3a:	627b      	str	r3, [r7, #36]	@ 0x24
 8003a3c:	687b      	ldr	r3, [r7, #4]
 8003a3e:	791b      	ldrb	r3, [r3, #4]
 8003a40:	461a      	mov	r2, r3
 8003a42:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003a44:	4293      	cmp	r3, r2
 8003a46:	d3cd      	bcc.n	80039e4 <HAL_PCD_IRQHandler+0x798>
        }
      }

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
 8003a48:	687b      	ldr	r3, [r7, #4]
 8003a4a:	681b      	ldr	r3, [r3, #0]
 8003a4c:	695a      	ldr	r2, [r3, #20]
 8003a4e:	687b      	ldr	r3, [r7, #4]
 8003a50:	681b      	ldr	r3, [r3, #0]
 8003a52:	f402 1280 	and.w	r2, r2, #1048576	@ 0x100000
 8003a56:	615a      	str	r2, [r3, #20]
    }

    /* Handle Incomplete ISO OUT Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 8003a58:	687b      	ldr	r3, [r7, #4]
 8003a5a:	681b      	ldr	r3, [r3, #0]
 8003a5c:	4618      	mov	r0, r3
 8003a5e:	f002 fdf1 	bl	8006644 <USB_ReadInterrupts>
 8003a62:	4603      	mov	r3, r0
 8003a64:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 8003a68:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 8003a6c:	d156      	bne.n	8003b1c <HAL_PCD_IRQHandler+0x8d0>
    {
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8003a6e:	2301      	movs	r3, #1
 8003a70:	627b      	str	r3, [r7, #36]	@ 0x24
 8003a72:	e045      	b.n	8003b00 <HAL_PCD_IRQHandler+0x8b4>
      {
        RegVal = USBx_OUTEP(epnum)->DOEPCTL;
 8003a74:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003a76:	015a      	lsls	r2, r3, #5
 8003a78:	69fb      	ldr	r3, [r7, #28]
 8003a7a:	4413      	add	r3, r2
 8003a7c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8003a80:	681b      	ldr	r3, [r3, #0]
 8003a82:	61bb      	str	r3, [r7, #24]

        if ((hpcd->OUT_ep[epnum].type == EP_TYPE_ISOC) &&
 8003a84:	6879      	ldr	r1, [r7, #4]
 8003a86:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8003a88:	4613      	mov	r3, r2
 8003a8a:	00db      	lsls	r3, r3, #3
 8003a8c:	4413      	add	r3, r2
 8003a8e:	009b      	lsls	r3, r3, #2
 8003a90:	440b      	add	r3, r1
 8003a92:	f503 7316 	add.w	r3, r3, #600	@ 0x258
 8003a96:	781b      	ldrb	r3, [r3, #0]
 8003a98:	2b01      	cmp	r3, #1
 8003a9a:	d12e      	bne.n	8003afa <HAL_PCD_IRQHandler+0x8ae>
            ((RegVal & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA) &&
 8003a9c:	69bb      	ldr	r3, [r7, #24]
        if ((hpcd->OUT_ep[epnum].type == EP_TYPE_ISOC) &&
 8003a9e:	2b00      	cmp	r3, #0
 8003aa0:	da2b      	bge.n	8003afa <HAL_PCD_IRQHandler+0x8ae>
            ((RegVal & (0x1U << 16)) == (hpcd->FrameNumber & 0x1U)))
 8003aa2:	69bb      	ldr	r3, [r7, #24]
 8003aa4:	f403 3280 	and.w	r2, r3, #65536	@ 0x10000
 8003aa8:	687b      	ldr	r3, [r7, #4]
 8003aaa:	f8d3 34d4 	ldr.w	r3, [r3, #1236]	@ 0x4d4
 8003aae:	f003 0301 	and.w	r3, r3, #1
            ((RegVal & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA) &&
 8003ab2:	429a      	cmp	r2, r3
 8003ab4:	d121      	bne.n	8003afa <HAL_PCD_IRQHandler+0x8ae>
        {
          hpcd->OUT_ep[epnum].is_iso_incomplete = 1U;
 8003ab6:	6879      	ldr	r1, [r7, #4]
 8003ab8:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8003aba:	4613      	mov	r3, r2
 8003abc:	00db      	lsls	r3, r3, #3
 8003abe:	4413      	add	r3, r2
 8003ac0:	009b      	lsls	r3, r3, #2
 8003ac2:	440b      	add	r3, r1
 8003ac4:	f203 2357 	addw	r3, r3, #599	@ 0x257
 8003ac8:	2201      	movs	r2, #1
 8003aca:	701a      	strb	r2, [r3, #0]

          USBx->GINTMSK |= USB_OTG_GINTMSK_GONAKEFFM;
 8003acc:	6a3b      	ldr	r3, [r7, #32]
 8003ace:	699b      	ldr	r3, [r3, #24]
 8003ad0:	f043 0280 	orr.w	r2, r3, #128	@ 0x80
 8003ad4:	6a3b      	ldr	r3, [r7, #32]
 8003ad6:	619a      	str	r2, [r3, #24]

          if ((USBx->GINTSTS & USB_OTG_GINTSTS_BOUTNAKEFF) == 0U)
 8003ad8:	6a3b      	ldr	r3, [r7, #32]
 8003ada:	695b      	ldr	r3, [r3, #20]
 8003adc:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8003ae0:	2b00      	cmp	r3, #0
 8003ae2:	d10a      	bne.n	8003afa <HAL_PCD_IRQHandler+0x8ae>
          {
            USBx_DEVICE->DCTL |= USB_OTG_DCTL_SGONAK;
 8003ae4:	69fb      	ldr	r3, [r7, #28]
 8003ae6:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8003aea:	685b      	ldr	r3, [r3, #4]
 8003aec:	69fa      	ldr	r2, [r7, #28]
 8003aee:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8003af2:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 8003af6:	6053      	str	r3, [r2, #4]
            break;
 8003af8:	e008      	b.n	8003b0c <HAL_PCD_IRQHandler+0x8c0>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8003afa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003afc:	3301      	adds	r3, #1
 8003afe:	627b      	str	r3, [r7, #36]	@ 0x24
 8003b00:	687b      	ldr	r3, [r7, #4]
 8003b02:	791b      	ldrb	r3, [r3, #4]
 8003b04:	461a      	mov	r2, r3
 8003b06:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003b08:	4293      	cmp	r3, r2
 8003b0a:	d3b3      	bcc.n	8003a74 <HAL_PCD_IRQHandler+0x828>
          }
        }
      }

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 8003b0c:	687b      	ldr	r3, [r7, #4]
 8003b0e:	681b      	ldr	r3, [r3, #0]
 8003b10:	695a      	ldr	r2, [r3, #20]
 8003b12:	687b      	ldr	r3, [r7, #4]
 8003b14:	681b      	ldr	r3, [r3, #0]
 8003b16:	f402 1200 	and.w	r2, r2, #2097152	@ 0x200000
 8003b1a:	615a      	str	r2, [r3, #20]
    }

    /* Handle Connection event Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))
 8003b1c:	687b      	ldr	r3, [r7, #4]
 8003b1e:	681b      	ldr	r3, [r3, #0]
 8003b20:	4618      	mov	r0, r3
 8003b22:	f002 fd8f 	bl	8006644 <USB_ReadInterrupts>
 8003b26:	4603      	mov	r3, r0
 8003b28:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
 8003b2c:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8003b30:	d10a      	bne.n	8003b48 <HAL_PCD_IRQHandler+0x8fc>
    {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->ConnectCallback(hpcd);
#else
      HAL_PCD_ConnectCallback(hpcd);
 8003b32:	6878      	ldr	r0, [r7, #4]
 8003b34:	f024 f992 	bl	8027e5c <HAL_PCD_ConnectCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
 8003b38:	687b      	ldr	r3, [r7, #4]
 8003b3a:	681b      	ldr	r3, [r3, #0]
 8003b3c:	695a      	ldr	r2, [r3, #20]
 8003b3e:	687b      	ldr	r3, [r7, #4]
 8003b40:	681b      	ldr	r3, [r3, #0]
 8003b42:	f002 4280 	and.w	r2, r2, #1073741824	@ 0x40000000
 8003b46:	615a      	str	r2, [r3, #20]
    }

    /* Handle Disconnection event Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))
 8003b48:	687b      	ldr	r3, [r7, #4]
 8003b4a:	681b      	ldr	r3, [r3, #0]
 8003b4c:	4618      	mov	r0, r3
 8003b4e:	f002 fd79 	bl	8006644 <USB_ReadInterrupts>
 8003b52:	4603      	mov	r3, r0
 8003b54:	f003 0304 	and.w	r3, r3, #4
 8003b58:	2b04      	cmp	r3, #4
 8003b5a:	d115      	bne.n	8003b88 <HAL_PCD_IRQHandler+0x93c>
    {
      RegVal = hpcd->Instance->GOTGINT;
 8003b5c:	687b      	ldr	r3, [r7, #4]
 8003b5e:	681b      	ldr	r3, [r3, #0]
 8003b60:	685b      	ldr	r3, [r3, #4]
 8003b62:	61bb      	str	r3, [r7, #24]

      if ((RegVal & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
 8003b64:	69bb      	ldr	r3, [r7, #24]
 8003b66:	f003 0304 	and.w	r3, r3, #4
 8003b6a:	2b00      	cmp	r3, #0
 8003b6c:	d002      	beq.n	8003b74 <HAL_PCD_IRQHandler+0x928>
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->DisconnectCallback(hpcd);
#else
        HAL_PCD_DisconnectCallback(hpcd);
 8003b6e:	6878      	ldr	r0, [r7, #4]
 8003b70:	f024 f982 	bl	8027e78 <HAL_PCD_DisconnectCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
      hpcd->Instance->GOTGINT |= RegVal;
 8003b74:	687b      	ldr	r3, [r7, #4]
 8003b76:	681b      	ldr	r3, [r3, #0]
 8003b78:	6859      	ldr	r1, [r3, #4]
 8003b7a:	687b      	ldr	r3, [r7, #4]
 8003b7c:	681b      	ldr	r3, [r3, #0]
 8003b7e:	69ba      	ldr	r2, [r7, #24]
 8003b80:	430a      	orrs	r2, r1
 8003b82:	605a      	str	r2, [r3, #4]
 8003b84:	e000      	b.n	8003b88 <HAL_PCD_IRQHandler+0x93c>
      return;
 8003b86:	bf00      	nop
    }
  }
}
 8003b88:	3734      	adds	r7, #52	@ 0x34
 8003b8a:	46bd      	mov	sp, r7
 8003b8c:	bd90      	pop	{r4, r7, pc}

08003b8e <HAL_PCD_SetAddress>:
  * @param  hpcd PCD handle
  * @param  address new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
 8003b8e:	b580      	push	{r7, lr}
 8003b90:	b082      	sub	sp, #8
 8003b92:	af00      	add	r7, sp, #0
 8003b94:	6078      	str	r0, [r7, #4]
 8003b96:	460b      	mov	r3, r1
 8003b98:	70fb      	strb	r3, [r7, #3]
  __HAL_LOCK(hpcd);
 8003b9a:	687b      	ldr	r3, [r7, #4]
 8003b9c:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
 8003ba0:	2b01      	cmp	r3, #1
 8003ba2:	d101      	bne.n	8003ba8 <HAL_PCD_SetAddress+0x1a>
 8003ba4:	2302      	movs	r3, #2
 8003ba6:	e012      	b.n	8003bce <HAL_PCD_SetAddress+0x40>
 8003ba8:	687b      	ldr	r3, [r7, #4]
 8003baa:	2201      	movs	r2, #1
 8003bac:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  hpcd->USB_Address = address;
 8003bb0:	687b      	ldr	r3, [r7, #4]
 8003bb2:	78fa      	ldrb	r2, [r7, #3]
 8003bb4:	745a      	strb	r2, [r3, #17]
  (void)USB_SetDevAddress(hpcd->Instance, address);
 8003bb6:	687b      	ldr	r3, [r7, #4]
 8003bb8:	681b      	ldr	r3, [r3, #0]
 8003bba:	78fa      	ldrb	r2, [r7, #3]
 8003bbc:	4611      	mov	r1, r2
 8003bbe:	4618      	mov	r0, r3
 8003bc0:	f002 fcd8 	bl	8006574 <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);
 8003bc4:	687b      	ldr	r3, [r7, #4]
 8003bc6:	2200      	movs	r2, #0
 8003bc8:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return HAL_OK;
 8003bcc:	2300      	movs	r3, #0
}
 8003bce:	4618      	mov	r0, r3
 8003bd0:	3708      	adds	r7, #8
 8003bd2:	46bd      	mov	sp, r7
 8003bd4:	bd80      	pop	{r7, pc}

08003bd6 <HAL_PCD_EP_Open>:
  * @param  ep_type endpoint type
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr,
                                  uint16_t ep_mps, uint8_t ep_type)
{
 8003bd6:	b580      	push	{r7, lr}
 8003bd8:	b084      	sub	sp, #16
 8003bda:	af00      	add	r7, sp, #0
 8003bdc:	6078      	str	r0, [r7, #4]
 8003bde:	4608      	mov	r0, r1
 8003be0:	4611      	mov	r1, r2
 8003be2:	461a      	mov	r2, r3
 8003be4:	4603      	mov	r3, r0
 8003be6:	70fb      	strb	r3, [r7, #3]
 8003be8:	460b      	mov	r3, r1
 8003bea:	803b      	strh	r3, [r7, #0]
 8003bec:	4613      	mov	r3, r2
 8003bee:	70bb      	strb	r3, [r7, #2]
  HAL_StatusTypeDef ret = HAL_OK;
 8003bf0:	2300      	movs	r3, #0
 8003bf2:	72fb      	strb	r3, [r7, #11]
  PCD_EPTypeDef *ep;

  if ((ep_addr & 0x80U) == 0x80U)
 8003bf4:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8003bf8:	2b00      	cmp	r3, #0
 8003bfa:	da0f      	bge.n	8003c1c <HAL_PCD_EP_Open+0x46>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8003bfc:	78fb      	ldrb	r3, [r7, #3]
 8003bfe:	f003 020f 	and.w	r2, r3, #15
 8003c02:	4613      	mov	r3, r2
 8003c04:	00db      	lsls	r3, r3, #3
 8003c06:	4413      	add	r3, r2
 8003c08:	009b      	lsls	r3, r3, #2
 8003c0a:	3310      	adds	r3, #16
 8003c0c:	687a      	ldr	r2, [r7, #4]
 8003c0e:	4413      	add	r3, r2
 8003c10:	3304      	adds	r3, #4
 8003c12:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 8003c14:	68fb      	ldr	r3, [r7, #12]
 8003c16:	2201      	movs	r2, #1
 8003c18:	705a      	strb	r2, [r3, #1]
 8003c1a:	e00f      	b.n	8003c3c <HAL_PCD_EP_Open+0x66>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8003c1c:	78fb      	ldrb	r3, [r7, #3]
 8003c1e:	f003 020f 	and.w	r2, r3, #15
 8003c22:	4613      	mov	r3, r2
 8003c24:	00db      	lsls	r3, r3, #3
 8003c26:	4413      	add	r3, r2
 8003c28:	009b      	lsls	r3, r3, #2
 8003c2a:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 8003c2e:	687a      	ldr	r2, [r7, #4]
 8003c30:	4413      	add	r3, r2
 8003c32:	3304      	adds	r3, #4
 8003c34:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 8003c36:	68fb      	ldr	r3, [r7, #12]
 8003c38:	2200      	movs	r2, #0
 8003c3a:	705a      	strb	r2, [r3, #1]
  }

  ep->num = ep_addr & EP_ADDR_MSK;
 8003c3c:	78fb      	ldrb	r3, [r7, #3]
 8003c3e:	f003 030f 	and.w	r3, r3, #15
 8003c42:	b2da      	uxtb	r2, r3
 8003c44:	68fb      	ldr	r3, [r7, #12]
 8003c46:	701a      	strb	r2, [r3, #0]
  ep->maxpacket = (uint32_t)ep_mps & 0x7FFU;
 8003c48:	883b      	ldrh	r3, [r7, #0]
 8003c4a:	f3c3 020a 	ubfx	r2, r3, #0, #11
 8003c4e:	68fb      	ldr	r3, [r7, #12]
 8003c50:	609a      	str	r2, [r3, #8]
  ep->type = ep_type;
 8003c52:	68fb      	ldr	r3, [r7, #12]
 8003c54:	78ba      	ldrb	r2, [r7, #2]
 8003c56:	711a      	strb	r2, [r3, #4]

  if (ep->is_in != 0U)
 8003c58:	68fb      	ldr	r3, [r7, #12]
 8003c5a:	785b      	ldrb	r3, [r3, #1]
 8003c5c:	2b00      	cmp	r3, #0
 8003c5e:	d004      	beq.n	8003c6a <HAL_PCD_EP_Open+0x94>
  {
    /* Assign a Tx FIFO */
    ep->tx_fifo_num = ep->num;
 8003c60:	68fb      	ldr	r3, [r7, #12]
 8003c62:	781b      	ldrb	r3, [r3, #0]
 8003c64:	461a      	mov	r2, r3
 8003c66:	68fb      	ldr	r3, [r7, #12]
 8003c68:	835a      	strh	r2, [r3, #26]
  }

  /* Set initial data PID. */
  if (ep_type == EP_TYPE_BULK)
 8003c6a:	78bb      	ldrb	r3, [r7, #2]
 8003c6c:	2b02      	cmp	r3, #2
 8003c6e:	d102      	bne.n	8003c76 <HAL_PCD_EP_Open+0xa0>
  {
    ep->data_pid_start = 0U;
 8003c70:	68fb      	ldr	r3, [r7, #12]
 8003c72:	2200      	movs	r2, #0
 8003c74:	715a      	strb	r2, [r3, #5]
  }

  __HAL_LOCK(hpcd);
 8003c76:	687b      	ldr	r3, [r7, #4]
 8003c78:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
 8003c7c:	2b01      	cmp	r3, #1
 8003c7e:	d101      	bne.n	8003c84 <HAL_PCD_EP_Open+0xae>
 8003c80:	2302      	movs	r3, #2
 8003c82:	e00e      	b.n	8003ca2 <HAL_PCD_EP_Open+0xcc>
 8003c84:	687b      	ldr	r3, [r7, #4]
 8003c86:	2201      	movs	r2, #1
 8003c88:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  (void)USB_ActivateEndpoint(hpcd->Instance, ep);
 8003c8c:	687b      	ldr	r3, [r7, #4]
 8003c8e:	681b      	ldr	r3, [r3, #0]
 8003c90:	68f9      	ldr	r1, [r7, #12]
 8003c92:	4618      	mov	r0, r3
 8003c94:	f001 fe58 	bl	8005948 <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);
 8003c98:	687b      	ldr	r3, [r7, #4]
 8003c9a:	2200      	movs	r2, #0
 8003c9c:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return ret;
 8003ca0:	7afb      	ldrb	r3, [r7, #11]
}
 8003ca2:	4618      	mov	r0, r3
 8003ca4:	3710      	adds	r7, #16
 8003ca6:	46bd      	mov	sp, r7
 8003ca8:	bd80      	pop	{r7, pc}

08003caa <HAL_PCD_EP_Close>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8003caa:	b580      	push	{r7, lr}
 8003cac:	b084      	sub	sp, #16
 8003cae:	af00      	add	r7, sp, #0
 8003cb0:	6078      	str	r0, [r7, #4]
 8003cb2:	460b      	mov	r3, r1
 8003cb4:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;

  if ((ep_addr & 0x80U) == 0x80U)
 8003cb6:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8003cba:	2b00      	cmp	r3, #0
 8003cbc:	da0f      	bge.n	8003cde <HAL_PCD_EP_Close+0x34>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8003cbe:	78fb      	ldrb	r3, [r7, #3]
 8003cc0:	f003 020f 	and.w	r2, r3, #15
 8003cc4:	4613      	mov	r3, r2
 8003cc6:	00db      	lsls	r3, r3, #3
 8003cc8:	4413      	add	r3, r2
 8003cca:	009b      	lsls	r3, r3, #2
 8003ccc:	3310      	adds	r3, #16
 8003cce:	687a      	ldr	r2, [r7, #4]
 8003cd0:	4413      	add	r3, r2
 8003cd2:	3304      	adds	r3, #4
 8003cd4:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 8003cd6:	68fb      	ldr	r3, [r7, #12]
 8003cd8:	2201      	movs	r2, #1
 8003cda:	705a      	strb	r2, [r3, #1]
 8003cdc:	e00f      	b.n	8003cfe <HAL_PCD_EP_Close+0x54>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8003cde:	78fb      	ldrb	r3, [r7, #3]
 8003ce0:	f003 020f 	and.w	r2, r3, #15
 8003ce4:	4613      	mov	r3, r2
 8003ce6:	00db      	lsls	r3, r3, #3
 8003ce8:	4413      	add	r3, r2
 8003cea:	009b      	lsls	r3, r3, #2
 8003cec:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 8003cf0:	687a      	ldr	r2, [r7, #4]
 8003cf2:	4413      	add	r3, r2
 8003cf4:	3304      	adds	r3, #4
 8003cf6:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 8003cf8:	68fb      	ldr	r3, [r7, #12]
 8003cfa:	2200      	movs	r2, #0
 8003cfc:	705a      	strb	r2, [r3, #1]
  }
  ep->num = ep_addr & EP_ADDR_MSK;
 8003cfe:	78fb      	ldrb	r3, [r7, #3]
 8003d00:	f003 030f 	and.w	r3, r3, #15
 8003d04:	b2da      	uxtb	r2, r3
 8003d06:	68fb      	ldr	r3, [r7, #12]
 8003d08:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
 8003d0a:	687b      	ldr	r3, [r7, #4]
 8003d0c:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
 8003d10:	2b01      	cmp	r3, #1
 8003d12:	d101      	bne.n	8003d18 <HAL_PCD_EP_Close+0x6e>
 8003d14:	2302      	movs	r3, #2
 8003d16:	e00e      	b.n	8003d36 <HAL_PCD_EP_Close+0x8c>
 8003d18:	687b      	ldr	r3, [r7, #4]
 8003d1a:	2201      	movs	r2, #1
 8003d1c:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  (void)USB_DeactivateEndpoint(hpcd->Instance, ep);
 8003d20:	687b      	ldr	r3, [r7, #4]
 8003d22:	681b      	ldr	r3, [r3, #0]
 8003d24:	68f9      	ldr	r1, [r7, #12]
 8003d26:	4618      	mov	r0, r3
 8003d28:	f001 fe96 	bl	8005a58 <USB_DeactivateEndpoint>
  __HAL_UNLOCK(hpcd);
 8003d2c:	687b      	ldr	r3, [r7, #4]
 8003d2e:	2200      	movs	r2, #0
 8003d30:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  return HAL_OK;
 8003d34:	2300      	movs	r3, #0
}
 8003d36:	4618      	mov	r0, r3
 8003d38:	3710      	adds	r7, #16
 8003d3a:	46bd      	mov	sp, r7
 8003d3c:	bd80      	pop	{r7, pc}

08003d3e <HAL_PCD_EP_Receive>:
  * @param  pBuf pointer to the reception buffer
  * @param  len amount of data to be received
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 8003d3e:	b580      	push	{r7, lr}
 8003d40:	b086      	sub	sp, #24
 8003d42:	af00      	add	r7, sp, #0
 8003d44:	60f8      	str	r0, [r7, #12]
 8003d46:	607a      	str	r2, [r7, #4]
 8003d48:	603b      	str	r3, [r7, #0]
 8003d4a:	460b      	mov	r3, r1
 8003d4c:	72fb      	strb	r3, [r7, #11]
  PCD_EPTypeDef *ep;

  ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8003d4e:	7afb      	ldrb	r3, [r7, #11]
 8003d50:	f003 020f 	and.w	r2, r3, #15
 8003d54:	4613      	mov	r3, r2
 8003d56:	00db      	lsls	r3, r3, #3
 8003d58:	4413      	add	r3, r2
 8003d5a:	009b      	lsls	r3, r3, #2
 8003d5c:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 8003d60:	68fa      	ldr	r2, [r7, #12]
 8003d62:	4413      	add	r3, r2
 8003d64:	3304      	adds	r3, #4
 8003d66:	617b      	str	r3, [r7, #20]

  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;
 8003d68:	697b      	ldr	r3, [r7, #20]
 8003d6a:	687a      	ldr	r2, [r7, #4]
 8003d6c:	60da      	str	r2, [r3, #12]
  ep->xfer_len = len;
 8003d6e:	697b      	ldr	r3, [r7, #20]
 8003d70:	683a      	ldr	r2, [r7, #0]
 8003d72:	611a      	str	r2, [r3, #16]
  ep->xfer_count = 0U;
 8003d74:	697b      	ldr	r3, [r7, #20]
 8003d76:	2200      	movs	r2, #0
 8003d78:	615a      	str	r2, [r3, #20]
  ep->is_in = 0U;
 8003d7a:	697b      	ldr	r3, [r7, #20]
 8003d7c:	2200      	movs	r2, #0
 8003d7e:	705a      	strb	r2, [r3, #1]
  ep->num = ep_addr & EP_ADDR_MSK;
 8003d80:	7afb      	ldrb	r3, [r7, #11]
 8003d82:	f003 030f 	and.w	r3, r3, #15
 8003d86:	b2da      	uxtb	r2, r3
 8003d88:	697b      	ldr	r3, [r7, #20]
 8003d8a:	701a      	strb	r2, [r3, #0]

  if (hpcd->Init.dma_enable == 1U)
 8003d8c:	68fb      	ldr	r3, [r7, #12]
 8003d8e:	799b      	ldrb	r3, [r3, #6]
 8003d90:	2b01      	cmp	r3, #1
 8003d92:	d102      	bne.n	8003d9a <HAL_PCD_EP_Receive+0x5c>
  {
    ep->dma_addr = (uint32_t)pBuf;
 8003d94:	687a      	ldr	r2, [r7, #4]
 8003d96:	697b      	ldr	r3, [r7, #20]
 8003d98:	61da      	str	r2, [r3, #28]
  }

  (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 8003d9a:	68fb      	ldr	r3, [r7, #12]
 8003d9c:	6818      	ldr	r0, [r3, #0]
 8003d9e:	68fb      	ldr	r3, [r7, #12]
 8003da0:	799b      	ldrb	r3, [r3, #6]
 8003da2:	461a      	mov	r2, r3
 8003da4:	6979      	ldr	r1, [r7, #20]
 8003da6:	f001 ff33 	bl	8005c10 <USB_EPStartXfer>

  return HAL_OK;
 8003daa:	2300      	movs	r3, #0
}
 8003dac:	4618      	mov	r0, r3
 8003dae:	3718      	adds	r7, #24
 8003db0:	46bd      	mov	sp, r7
 8003db2:	bd80      	pop	{r7, pc}

08003db4 <HAL_PCD_EP_GetRxCount>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval Data Size
  */
uint32_t HAL_PCD_EP_GetRxCount(PCD_HandleTypeDef const *hpcd, uint8_t ep_addr)
{
 8003db4:	b480      	push	{r7}
 8003db6:	b083      	sub	sp, #12
 8003db8:	af00      	add	r7, sp, #0
 8003dba:	6078      	str	r0, [r7, #4]
 8003dbc:	460b      	mov	r3, r1
 8003dbe:	70fb      	strb	r3, [r7, #3]
  return hpcd->OUT_ep[ep_addr & EP_ADDR_MSK].xfer_count;
 8003dc0:	78fb      	ldrb	r3, [r7, #3]
 8003dc2:	f003 020f 	and.w	r2, r3, #15
 8003dc6:	6879      	ldr	r1, [r7, #4]
 8003dc8:	4613      	mov	r3, r2
 8003dca:	00db      	lsls	r3, r3, #3
 8003dcc:	4413      	add	r3, r2
 8003dce:	009b      	lsls	r3, r3, #2
 8003dd0:	440b      	add	r3, r1
 8003dd2:	f503 731a 	add.w	r3, r3, #616	@ 0x268
 8003dd6:	681b      	ldr	r3, [r3, #0]
}
 8003dd8:	4618      	mov	r0, r3
 8003dda:	370c      	adds	r7, #12
 8003ddc:	46bd      	mov	sp, r7
 8003dde:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003de2:	4770      	bx	lr

08003de4 <HAL_PCD_EP_Transmit>:
  * @param  pBuf pointer to the transmission buffer
  * @param  len amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 8003de4:	b580      	push	{r7, lr}
 8003de6:	b086      	sub	sp, #24
 8003de8:	af00      	add	r7, sp, #0
 8003dea:	60f8      	str	r0, [r7, #12]
 8003dec:	607a      	str	r2, [r7, #4]
 8003dee:	603b      	str	r3, [r7, #0]
 8003df0:	460b      	mov	r3, r1
 8003df2:	72fb      	strb	r3, [r7, #11]
  PCD_EPTypeDef *ep;

  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8003df4:	7afb      	ldrb	r3, [r7, #11]
 8003df6:	f003 020f 	and.w	r2, r3, #15
 8003dfa:	4613      	mov	r3, r2
 8003dfc:	00db      	lsls	r3, r3, #3
 8003dfe:	4413      	add	r3, r2
 8003e00:	009b      	lsls	r3, r3, #2
 8003e02:	3310      	adds	r3, #16
 8003e04:	68fa      	ldr	r2, [r7, #12]
 8003e06:	4413      	add	r3, r2
 8003e08:	3304      	adds	r3, #4
 8003e0a:	617b      	str	r3, [r7, #20]

  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;
 8003e0c:	697b      	ldr	r3, [r7, #20]
 8003e0e:	687a      	ldr	r2, [r7, #4]
 8003e10:	60da      	str	r2, [r3, #12]
  ep->xfer_len = len;
 8003e12:	697b      	ldr	r3, [r7, #20]
 8003e14:	683a      	ldr	r2, [r7, #0]
 8003e16:	611a      	str	r2, [r3, #16]
  ep->xfer_count = 0U;
 8003e18:	697b      	ldr	r3, [r7, #20]
 8003e1a:	2200      	movs	r2, #0
 8003e1c:	615a      	str	r2, [r3, #20]
  ep->is_in = 1U;
 8003e1e:	697b      	ldr	r3, [r7, #20]
 8003e20:	2201      	movs	r2, #1
 8003e22:	705a      	strb	r2, [r3, #1]
  ep->num = ep_addr & EP_ADDR_MSK;
 8003e24:	7afb      	ldrb	r3, [r7, #11]
 8003e26:	f003 030f 	and.w	r3, r3, #15
 8003e2a:	b2da      	uxtb	r2, r3
 8003e2c:	697b      	ldr	r3, [r7, #20]
 8003e2e:	701a      	strb	r2, [r3, #0]

  if (hpcd->Init.dma_enable == 1U)
 8003e30:	68fb      	ldr	r3, [r7, #12]
 8003e32:	799b      	ldrb	r3, [r3, #6]
 8003e34:	2b01      	cmp	r3, #1
 8003e36:	d102      	bne.n	8003e3e <HAL_PCD_EP_Transmit+0x5a>
  {
    ep->dma_addr = (uint32_t)pBuf;
 8003e38:	687a      	ldr	r2, [r7, #4]
 8003e3a:	697b      	ldr	r3, [r7, #20]
 8003e3c:	61da      	str	r2, [r3, #28]
  }

  (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 8003e3e:	68fb      	ldr	r3, [r7, #12]
 8003e40:	6818      	ldr	r0, [r3, #0]
 8003e42:	68fb      	ldr	r3, [r7, #12]
 8003e44:	799b      	ldrb	r3, [r3, #6]
 8003e46:	461a      	mov	r2, r3
 8003e48:	6979      	ldr	r1, [r7, #20]
 8003e4a:	f001 fee1 	bl	8005c10 <USB_EPStartXfer>

  return HAL_OK;
 8003e4e:	2300      	movs	r3, #0
}
 8003e50:	4618      	mov	r0, r3
 8003e52:	3718      	adds	r7, #24
 8003e54:	46bd      	mov	sp, r7
 8003e56:	bd80      	pop	{r7, pc}

08003e58 <HAL_PCD_EP_SetStall>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8003e58:	b580      	push	{r7, lr}
 8003e5a:	b084      	sub	sp, #16
 8003e5c:	af00      	add	r7, sp, #0
 8003e5e:	6078      	str	r0, [r7, #4]
 8003e60:	460b      	mov	r3, r1
 8003e62:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;

  if (((uint32_t)ep_addr & EP_ADDR_MSK) > hpcd->Init.dev_endpoints)
 8003e64:	78fb      	ldrb	r3, [r7, #3]
 8003e66:	f003 030f 	and.w	r3, r3, #15
 8003e6a:	687a      	ldr	r2, [r7, #4]
 8003e6c:	7912      	ldrb	r2, [r2, #4]
 8003e6e:	4293      	cmp	r3, r2
 8003e70:	d901      	bls.n	8003e76 <HAL_PCD_EP_SetStall+0x1e>
  {
    return HAL_ERROR;
 8003e72:	2301      	movs	r3, #1
 8003e74:	e04f      	b.n	8003f16 <HAL_PCD_EP_SetStall+0xbe>
  }

  if ((0x80U & ep_addr) == 0x80U)
 8003e76:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8003e7a:	2b00      	cmp	r3, #0
 8003e7c:	da0f      	bge.n	8003e9e <HAL_PCD_EP_SetStall+0x46>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8003e7e:	78fb      	ldrb	r3, [r7, #3]
 8003e80:	f003 020f 	and.w	r2, r3, #15
 8003e84:	4613      	mov	r3, r2
 8003e86:	00db      	lsls	r3, r3, #3
 8003e88:	4413      	add	r3, r2
 8003e8a:	009b      	lsls	r3, r3, #2
 8003e8c:	3310      	adds	r3, #16
 8003e8e:	687a      	ldr	r2, [r7, #4]
 8003e90:	4413      	add	r3, r2
 8003e92:	3304      	adds	r3, #4
 8003e94:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 8003e96:	68fb      	ldr	r3, [r7, #12]
 8003e98:	2201      	movs	r2, #1
 8003e9a:	705a      	strb	r2, [r3, #1]
 8003e9c:	e00d      	b.n	8003eba <HAL_PCD_EP_SetStall+0x62>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 8003e9e:	78fa      	ldrb	r2, [r7, #3]
 8003ea0:	4613      	mov	r3, r2
 8003ea2:	00db      	lsls	r3, r3, #3
 8003ea4:	4413      	add	r3, r2
 8003ea6:	009b      	lsls	r3, r3, #2
 8003ea8:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 8003eac:	687a      	ldr	r2, [r7, #4]
 8003eae:	4413      	add	r3, r2
 8003eb0:	3304      	adds	r3, #4
 8003eb2:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 8003eb4:	68fb      	ldr	r3, [r7, #12]
 8003eb6:	2200      	movs	r2, #0
 8003eb8:	705a      	strb	r2, [r3, #1]
  }

  ep->is_stall = 1U;
 8003eba:	68fb      	ldr	r3, [r7, #12]
 8003ebc:	2201      	movs	r2, #1
 8003ebe:	709a      	strb	r2, [r3, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
 8003ec0:	78fb      	ldrb	r3, [r7, #3]
 8003ec2:	f003 030f 	and.w	r3, r3, #15
 8003ec6:	b2da      	uxtb	r2, r3
 8003ec8:	68fb      	ldr	r3, [r7, #12]
 8003eca:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
 8003ecc:	687b      	ldr	r3, [r7, #4]
 8003ece:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
 8003ed2:	2b01      	cmp	r3, #1
 8003ed4:	d101      	bne.n	8003eda <HAL_PCD_EP_SetStall+0x82>
 8003ed6:	2302      	movs	r3, #2
 8003ed8:	e01d      	b.n	8003f16 <HAL_PCD_EP_SetStall+0xbe>
 8003eda:	687b      	ldr	r3, [r7, #4]
 8003edc:	2201      	movs	r2, #1
 8003ede:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  (void)USB_EPSetStall(hpcd->Instance, ep);
 8003ee2:	687b      	ldr	r3, [r7, #4]
 8003ee4:	681b      	ldr	r3, [r3, #0]
 8003ee6:	68f9      	ldr	r1, [r7, #12]
 8003ee8:	4618      	mov	r0, r3
 8003eea:	f002 fa6f 	bl	80063cc <USB_EPSetStall>

  if ((ep_addr & EP_ADDR_MSK) == 0U)
 8003eee:	78fb      	ldrb	r3, [r7, #3]
 8003ef0:	f003 030f 	and.w	r3, r3, #15
 8003ef4:	2b00      	cmp	r3, #0
 8003ef6:	d109      	bne.n	8003f0c <HAL_PCD_EP_SetStall+0xb4>
  {
    (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 8003ef8:	687b      	ldr	r3, [r7, #4]
 8003efa:	6818      	ldr	r0, [r3, #0]
 8003efc:	687b      	ldr	r3, [r7, #4]
 8003efe:	7999      	ldrb	r1, [r3, #6]
 8003f00:	687b      	ldr	r3, [r7, #4]
 8003f02:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 8003f06:	461a      	mov	r2, r3
 8003f08:	f002 fc60 	bl	80067cc <USB_EP0_OutStart>
  }

  __HAL_UNLOCK(hpcd);
 8003f0c:	687b      	ldr	r3, [r7, #4]
 8003f0e:	2200      	movs	r2, #0
 8003f10:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return HAL_OK;
 8003f14:	2300      	movs	r3, #0
}
 8003f16:	4618      	mov	r0, r3
 8003f18:	3710      	adds	r7, #16
 8003f1a:	46bd      	mov	sp, r7
 8003f1c:	bd80      	pop	{r7, pc}

08003f1e <HAL_PCD_EP_ClrStall>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8003f1e:	b580      	push	{r7, lr}
 8003f20:	b084      	sub	sp, #16
 8003f22:	af00      	add	r7, sp, #0
 8003f24:	6078      	str	r0, [r7, #4]
 8003f26:	460b      	mov	r3, r1
 8003f28:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;

  if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
 8003f2a:	78fb      	ldrb	r3, [r7, #3]
 8003f2c:	f003 030f 	and.w	r3, r3, #15
 8003f30:	687a      	ldr	r2, [r7, #4]
 8003f32:	7912      	ldrb	r2, [r2, #4]
 8003f34:	4293      	cmp	r3, r2
 8003f36:	d901      	bls.n	8003f3c <HAL_PCD_EP_ClrStall+0x1e>
  {
    return HAL_ERROR;
 8003f38:	2301      	movs	r3, #1
 8003f3a:	e042      	b.n	8003fc2 <HAL_PCD_EP_ClrStall+0xa4>
  }

  if ((0x80U & ep_addr) == 0x80U)
 8003f3c:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8003f40:	2b00      	cmp	r3, #0
 8003f42:	da0f      	bge.n	8003f64 <HAL_PCD_EP_ClrStall+0x46>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8003f44:	78fb      	ldrb	r3, [r7, #3]
 8003f46:	f003 020f 	and.w	r2, r3, #15
 8003f4a:	4613      	mov	r3, r2
 8003f4c:	00db      	lsls	r3, r3, #3
 8003f4e:	4413      	add	r3, r2
 8003f50:	009b      	lsls	r3, r3, #2
 8003f52:	3310      	adds	r3, #16
 8003f54:	687a      	ldr	r2, [r7, #4]
 8003f56:	4413      	add	r3, r2
 8003f58:	3304      	adds	r3, #4
 8003f5a:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 8003f5c:	68fb      	ldr	r3, [r7, #12]
 8003f5e:	2201      	movs	r2, #1
 8003f60:	705a      	strb	r2, [r3, #1]
 8003f62:	e00f      	b.n	8003f84 <HAL_PCD_EP_ClrStall+0x66>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8003f64:	78fb      	ldrb	r3, [r7, #3]
 8003f66:	f003 020f 	and.w	r2, r3, #15
 8003f6a:	4613      	mov	r3, r2
 8003f6c:	00db      	lsls	r3, r3, #3
 8003f6e:	4413      	add	r3, r2
 8003f70:	009b      	lsls	r3, r3, #2
 8003f72:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 8003f76:	687a      	ldr	r2, [r7, #4]
 8003f78:	4413      	add	r3, r2
 8003f7a:	3304      	adds	r3, #4
 8003f7c:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 8003f7e:	68fb      	ldr	r3, [r7, #12]
 8003f80:	2200      	movs	r2, #0
 8003f82:	705a      	strb	r2, [r3, #1]
  }

  ep->is_stall = 0U;
 8003f84:	68fb      	ldr	r3, [r7, #12]
 8003f86:	2200      	movs	r2, #0
 8003f88:	709a      	strb	r2, [r3, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
 8003f8a:	78fb      	ldrb	r3, [r7, #3]
 8003f8c:	f003 030f 	and.w	r3, r3, #15
 8003f90:	b2da      	uxtb	r2, r3
 8003f92:	68fb      	ldr	r3, [r7, #12]
 8003f94:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
 8003f96:	687b      	ldr	r3, [r7, #4]
 8003f98:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
 8003f9c:	2b01      	cmp	r3, #1
 8003f9e:	d101      	bne.n	8003fa4 <HAL_PCD_EP_ClrStall+0x86>
 8003fa0:	2302      	movs	r3, #2
 8003fa2:	e00e      	b.n	8003fc2 <HAL_PCD_EP_ClrStall+0xa4>
 8003fa4:	687b      	ldr	r3, [r7, #4]
 8003fa6:	2201      	movs	r2, #1
 8003fa8:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  (void)USB_EPClearStall(hpcd->Instance, ep);
 8003fac:	687b      	ldr	r3, [r7, #4]
 8003fae:	681b      	ldr	r3, [r3, #0]
 8003fb0:	68f9      	ldr	r1, [r7, #12]
 8003fb2:	4618      	mov	r0, r3
 8003fb4:	f002 fa78 	bl	80064a8 <USB_EPClearStall>
  __HAL_UNLOCK(hpcd);
 8003fb8:	687b      	ldr	r3, [r7, #4]
 8003fba:	2200      	movs	r2, #0
 8003fbc:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return HAL_OK;
 8003fc0:	2300      	movs	r3, #0
}
 8003fc2:	4618      	mov	r0, r3
 8003fc4:	3710      	adds	r7, #16
 8003fc6:	46bd      	mov	sp, r7
 8003fc8:	bd80      	pop	{r7, pc}

08003fca <HAL_PCD_EP_Abort>:
   * @param  hpcd PCD handle
   * @param  ep_addr endpoint address
   * @retval HAL status
   */
HAL_StatusTypeDef HAL_PCD_EP_Abort(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8003fca:	b580      	push	{r7, lr}
 8003fcc:	b084      	sub	sp, #16
 8003fce:	af00      	add	r7, sp, #0
 8003fd0:	6078      	str	r0, [r7, #4]
 8003fd2:	460b      	mov	r3, r1
 8003fd4:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef ret;
  PCD_EPTypeDef *ep;

  if ((0x80U & ep_addr) == 0x80U)
 8003fd6:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8003fda:	2b00      	cmp	r3, #0
 8003fdc:	da0c      	bge.n	8003ff8 <HAL_PCD_EP_Abort+0x2e>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8003fde:	78fb      	ldrb	r3, [r7, #3]
 8003fe0:	f003 020f 	and.w	r2, r3, #15
 8003fe4:	4613      	mov	r3, r2
 8003fe6:	00db      	lsls	r3, r3, #3
 8003fe8:	4413      	add	r3, r2
 8003fea:	009b      	lsls	r3, r3, #2
 8003fec:	3310      	adds	r3, #16
 8003fee:	687a      	ldr	r2, [r7, #4]
 8003ff0:	4413      	add	r3, r2
 8003ff2:	3304      	adds	r3, #4
 8003ff4:	60fb      	str	r3, [r7, #12]
 8003ff6:	e00c      	b.n	8004012 <HAL_PCD_EP_Abort+0x48>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8003ff8:	78fb      	ldrb	r3, [r7, #3]
 8003ffa:	f003 020f 	and.w	r2, r3, #15
 8003ffe:	4613      	mov	r3, r2
 8004000:	00db      	lsls	r3, r3, #3
 8004002:	4413      	add	r3, r2
 8004004:	009b      	lsls	r3, r3, #2
 8004006:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 800400a:	687a      	ldr	r2, [r7, #4]
 800400c:	4413      	add	r3, r2
 800400e:	3304      	adds	r3, #4
 8004010:	60fb      	str	r3, [r7, #12]
  }

  /* Stop Xfer */
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8004012:	687b      	ldr	r3, [r7, #4]
 8004014:	681b      	ldr	r3, [r3, #0]
 8004016:	68f9      	ldr	r1, [r7, #12]
 8004018:	4618      	mov	r0, r3
 800401a:	f002 f897 	bl	800614c <USB_EPStopXfer>
 800401e:	4603      	mov	r3, r0
 8004020:	72fb      	strb	r3, [r7, #11]

  return ret;
 8004022:	7afb      	ldrb	r3, [r7, #11]
}
 8004024:	4618      	mov	r0, r3
 8004026:	3710      	adds	r7, #16
 8004028:	46bd      	mov	sp, r7
 800402a:	bd80      	pop	{r7, pc}

0800402c <PCD_WriteEmptyTxFifo>:
  * @param  hpcd PCD handle
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_WriteEmptyTxFifo(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
 800402c:	b580      	push	{r7, lr}
 800402e:	b08a      	sub	sp, #40	@ 0x28
 8004030:	af02      	add	r7, sp, #8
 8004032:	6078      	str	r0, [r7, #4]
 8004034:	6039      	str	r1, [r7, #0]
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8004036:	687b      	ldr	r3, [r7, #4]
 8004038:	681b      	ldr	r3, [r3, #0]
 800403a:	617b      	str	r3, [r7, #20]
  uint32_t USBx_BASE = (uint32_t)USBx;
 800403c:	697b      	ldr	r3, [r7, #20]
 800403e:	613b      	str	r3, [r7, #16]
  USB_OTG_EPTypeDef *ep;
  uint32_t len;
  uint32_t len32b;
  uint32_t fifoemptymsk;

  ep = &hpcd->IN_ep[epnum];
 8004040:	683a      	ldr	r2, [r7, #0]
 8004042:	4613      	mov	r3, r2
 8004044:	00db      	lsls	r3, r3, #3
 8004046:	4413      	add	r3, r2
 8004048:	009b      	lsls	r3, r3, #2
 800404a:	3310      	adds	r3, #16
 800404c:	687a      	ldr	r2, [r7, #4]
 800404e:	4413      	add	r3, r2
 8004050:	3304      	adds	r3, #4
 8004052:	60fb      	str	r3, [r7, #12]

  if (ep->xfer_count > ep->xfer_len)
 8004054:	68fb      	ldr	r3, [r7, #12]
 8004056:	695a      	ldr	r2, [r3, #20]
 8004058:	68fb      	ldr	r3, [r7, #12]
 800405a:	691b      	ldr	r3, [r3, #16]
 800405c:	429a      	cmp	r2, r3
 800405e:	d901      	bls.n	8004064 <PCD_WriteEmptyTxFifo+0x38>
  {
    return HAL_ERROR;
 8004060:	2301      	movs	r3, #1
 8004062:	e06b      	b.n	800413c <PCD_WriteEmptyTxFifo+0x110>
  }

  len = ep->xfer_len - ep->xfer_count;
 8004064:	68fb      	ldr	r3, [r7, #12]
 8004066:	691a      	ldr	r2, [r3, #16]
 8004068:	68fb      	ldr	r3, [r7, #12]
 800406a:	695b      	ldr	r3, [r3, #20]
 800406c:	1ad3      	subs	r3, r2, r3
 800406e:	61fb      	str	r3, [r7, #28]

  if (len > ep->maxpacket)
 8004070:	68fb      	ldr	r3, [r7, #12]
 8004072:	689b      	ldr	r3, [r3, #8]
 8004074:	69fa      	ldr	r2, [r7, #28]
 8004076:	429a      	cmp	r2, r3
 8004078:	d902      	bls.n	8004080 <PCD_WriteEmptyTxFifo+0x54>
  {
    len = ep->maxpacket;
 800407a:	68fb      	ldr	r3, [r7, #12]
 800407c:	689b      	ldr	r3, [r3, #8]
 800407e:	61fb      	str	r3, [r7, #28]
  }

  len32b = (len + 3U) / 4U;
 8004080:	69fb      	ldr	r3, [r7, #28]
 8004082:	3303      	adds	r3, #3
 8004084:	089b      	lsrs	r3, r3, #2
 8004086:	61bb      	str	r3, [r7, #24]

  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8004088:	e02a      	b.n	80040e0 <PCD_WriteEmptyTxFifo+0xb4>
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
  {
    /* Write the FIFO */
    len = ep->xfer_len - ep->xfer_count;
 800408a:	68fb      	ldr	r3, [r7, #12]
 800408c:	691a      	ldr	r2, [r3, #16]
 800408e:	68fb      	ldr	r3, [r7, #12]
 8004090:	695b      	ldr	r3, [r3, #20]
 8004092:	1ad3      	subs	r3, r2, r3
 8004094:	61fb      	str	r3, [r7, #28]

    if (len > ep->maxpacket)
 8004096:	68fb      	ldr	r3, [r7, #12]
 8004098:	689b      	ldr	r3, [r3, #8]
 800409a:	69fa      	ldr	r2, [r7, #28]
 800409c:	429a      	cmp	r2, r3
 800409e:	d902      	bls.n	80040a6 <PCD_WriteEmptyTxFifo+0x7a>
    {
      len = ep->maxpacket;
 80040a0:	68fb      	ldr	r3, [r7, #12]
 80040a2:	689b      	ldr	r3, [r3, #8]
 80040a4:	61fb      	str	r3, [r7, #28]
    }
    len32b = (len + 3U) / 4U;
 80040a6:	69fb      	ldr	r3, [r7, #28]
 80040a8:	3303      	adds	r3, #3
 80040aa:	089b      	lsrs	r3, r3, #2
 80040ac:	61bb      	str	r3, [r7, #24]

    (void)USB_WritePacket(USBx, ep->xfer_buff, (uint8_t)epnum, (uint16_t)len,
 80040ae:	68fb      	ldr	r3, [r7, #12]
 80040b0:	68d9      	ldr	r1, [r3, #12]
 80040b2:	683b      	ldr	r3, [r7, #0]
 80040b4:	b2da      	uxtb	r2, r3
 80040b6:	69fb      	ldr	r3, [r7, #28]
 80040b8:	b298      	uxth	r0, r3
                          (uint8_t)hpcd->Init.dma_enable);
 80040ba:	687b      	ldr	r3, [r7, #4]
 80040bc:	799b      	ldrb	r3, [r3, #6]
    (void)USB_WritePacket(USBx, ep->xfer_buff, (uint8_t)epnum, (uint16_t)len,
 80040be:	9300      	str	r3, [sp, #0]
 80040c0:	4603      	mov	r3, r0
 80040c2:	6978      	ldr	r0, [r7, #20]
 80040c4:	f002 f8ec 	bl	80062a0 <USB_WritePacket>

    ep->xfer_buff  += len;
 80040c8:	68fb      	ldr	r3, [r7, #12]
 80040ca:	68da      	ldr	r2, [r3, #12]
 80040cc:	69fb      	ldr	r3, [r7, #28]
 80040ce:	441a      	add	r2, r3
 80040d0:	68fb      	ldr	r3, [r7, #12]
 80040d2:	60da      	str	r2, [r3, #12]
    ep->xfer_count += len;
 80040d4:	68fb      	ldr	r3, [r7, #12]
 80040d6:	695a      	ldr	r2, [r3, #20]
 80040d8:	69fb      	ldr	r3, [r7, #28]
 80040da:	441a      	add	r2, r3
 80040dc:	68fb      	ldr	r3, [r7, #12]
 80040de:	615a      	str	r2, [r3, #20]
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 80040e0:	683b      	ldr	r3, [r7, #0]
 80040e2:	015a      	lsls	r2, r3, #5
 80040e4:	693b      	ldr	r3, [r7, #16]
 80040e6:	4413      	add	r3, r2
 80040e8:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80040ec:	699b      	ldr	r3, [r3, #24]
 80040ee:	b29b      	uxth	r3, r3
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
 80040f0:	69ba      	ldr	r2, [r7, #24]
 80040f2:	429a      	cmp	r2, r3
 80040f4:	d809      	bhi.n	800410a <PCD_WriteEmptyTxFifo+0xde>
 80040f6:	68fb      	ldr	r3, [r7, #12]
 80040f8:	695a      	ldr	r2, [r3, #20]
 80040fa:	68fb      	ldr	r3, [r7, #12]
 80040fc:	691b      	ldr	r3, [r3, #16]
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 80040fe:	429a      	cmp	r2, r3
 8004100:	d203      	bcs.n	800410a <PCD_WriteEmptyTxFifo+0xde>
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
 8004102:	68fb      	ldr	r3, [r7, #12]
 8004104:	691b      	ldr	r3, [r3, #16]
 8004106:	2b00      	cmp	r3, #0
 8004108:	d1bf      	bne.n	800408a <PCD_WriteEmptyTxFifo+0x5e>
  }

  if (ep->xfer_len <= ep->xfer_count)
 800410a:	68fb      	ldr	r3, [r7, #12]
 800410c:	691a      	ldr	r2, [r3, #16]
 800410e:	68fb      	ldr	r3, [r7, #12]
 8004110:	695b      	ldr	r3, [r3, #20]
 8004112:	429a      	cmp	r2, r3
 8004114:	d811      	bhi.n	800413a <PCD_WriteEmptyTxFifo+0x10e>
  {
    fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 8004116:	683b      	ldr	r3, [r7, #0]
 8004118:	f003 030f 	and.w	r3, r3, #15
 800411c:	2201      	movs	r2, #1
 800411e:	fa02 f303 	lsl.w	r3, r2, r3
 8004122:	60bb      	str	r3, [r7, #8]
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8004124:	693b      	ldr	r3, [r7, #16]
 8004126:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800412a:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 800412c:	68bb      	ldr	r3, [r7, #8]
 800412e:	43db      	mvns	r3, r3
 8004130:	6939      	ldr	r1, [r7, #16]
 8004132:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 8004136:	4013      	ands	r3, r2
 8004138:	634b      	str	r3, [r1, #52]	@ 0x34
  }

  return HAL_OK;
 800413a:	2300      	movs	r3, #0
}
 800413c:	4618      	mov	r0, r3
 800413e:	3720      	adds	r7, #32
 8004140:	46bd      	mov	sp, r7
 8004142:	bd80      	pop	{r7, pc}

08004144 <PCD_EP_OutXfrComplete_int>:
  * @param  hpcd PCD handle
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_EP_OutXfrComplete_int(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
 8004144:	b580      	push	{r7, lr}
 8004146:	b088      	sub	sp, #32
 8004148:	af00      	add	r7, sp, #0
 800414a:	6078      	str	r0, [r7, #4]
 800414c:	6039      	str	r1, [r7, #0]
  USB_OTG_EPTypeDef *ep;
  const USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 800414e:	687b      	ldr	r3, [r7, #4]
 8004150:	681b      	ldr	r3, [r3, #0]
 8004152:	61fb      	str	r3, [r7, #28]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8004154:	69fb      	ldr	r3, [r7, #28]
 8004156:	61bb      	str	r3, [r7, #24]
  uint32_t gSNPSiD = *(__IO const uint32_t *)(&USBx->CID + 0x1U);
 8004158:	69fb      	ldr	r3, [r7, #28]
 800415a:	333c      	adds	r3, #60	@ 0x3c
 800415c:	3304      	adds	r3, #4
 800415e:	681b      	ldr	r3, [r3, #0]
 8004160:	617b      	str	r3, [r7, #20]
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 8004162:	683b      	ldr	r3, [r7, #0]
 8004164:	015a      	lsls	r2, r3, #5
 8004166:	69bb      	ldr	r3, [r7, #24]
 8004168:	4413      	add	r3, r2
 800416a:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800416e:	689b      	ldr	r3, [r3, #8]
 8004170:	613b      	str	r3, [r7, #16]

  if (hpcd->Init.dma_enable == 1U)
 8004172:	687b      	ldr	r3, [r7, #4]
 8004174:	799b      	ldrb	r3, [r3, #6]
 8004176:	2b01      	cmp	r3, #1
 8004178:	d17b      	bne.n	8004272 <PCD_EP_OutXfrComplete_int+0x12e>
  {
    if ((DoepintReg & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP) /* Class C */
 800417a:	693b      	ldr	r3, [r7, #16]
 800417c:	f003 0308 	and.w	r3, r3, #8
 8004180:	2b00      	cmp	r3, #0
 8004182:	d015      	beq.n	80041b0 <PCD_EP_OutXfrComplete_int+0x6c>
    {
      /* StupPktRcvd = 1 this is a setup packet */
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8004184:	697b      	ldr	r3, [r7, #20]
 8004186:	4a61      	ldr	r2, [pc, #388]	@ (800430c <PCD_EP_OutXfrComplete_int+0x1c8>)
 8004188:	4293      	cmp	r3, r2
 800418a:	f240 80b9 	bls.w	8004300 <PCD_EP_OutXfrComplete_int+0x1bc>
          ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
 800418e:	693b      	ldr	r3, [r7, #16]
 8004190:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8004194:	2b00      	cmp	r3, #0
 8004196:	f000 80b3 	beq.w	8004300 <PCD_EP_OutXfrComplete_int+0x1bc>
      {
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 800419a:	683b      	ldr	r3, [r7, #0]
 800419c:	015a      	lsls	r2, r3, #5
 800419e:	69bb      	ldr	r3, [r7, #24]
 80041a0:	4413      	add	r3, r2
 80041a2:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80041a6:	461a      	mov	r2, r3
 80041a8:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 80041ac:	6093      	str	r3, [r2, #8]
 80041ae:	e0a7      	b.n	8004300 <PCD_EP_OutXfrComplete_int+0x1bc>
      }
    }
    else if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR) /* Class E */
 80041b0:	693b      	ldr	r3, [r7, #16]
 80041b2:	f003 0320 	and.w	r3, r3, #32
 80041b6:	2b00      	cmp	r3, #0
 80041b8:	d009      	beq.n	80041ce <PCD_EP_OutXfrComplete_int+0x8a>
    {
      CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 80041ba:	683b      	ldr	r3, [r7, #0]
 80041bc:	015a      	lsls	r2, r3, #5
 80041be:	69bb      	ldr	r3, [r7, #24]
 80041c0:	4413      	add	r3, r2
 80041c2:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80041c6:	461a      	mov	r2, r3
 80041c8:	2320      	movs	r3, #32
 80041ca:	6093      	str	r3, [r2, #8]
 80041cc:	e098      	b.n	8004300 <PCD_EP_OutXfrComplete_int+0x1bc>
    }
    else if ((DoepintReg & (USB_OTG_DOEPINT_STUP | USB_OTG_DOEPINT_OTEPSPR)) == 0U)
 80041ce:	693b      	ldr	r3, [r7, #16]
 80041d0:	f003 0328 	and.w	r3, r3, #40	@ 0x28
 80041d4:	2b00      	cmp	r3, #0
 80041d6:	f040 8093 	bne.w	8004300 <PCD_EP_OutXfrComplete_int+0x1bc>
    {
      /* StupPktRcvd = 1 this is a setup packet */
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 80041da:	697b      	ldr	r3, [r7, #20]
 80041dc:	4a4b      	ldr	r2, [pc, #300]	@ (800430c <PCD_EP_OutXfrComplete_int+0x1c8>)
 80041de:	4293      	cmp	r3, r2
 80041e0:	d90f      	bls.n	8004202 <PCD_EP_OutXfrComplete_int+0xbe>
          ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
 80041e2:	693b      	ldr	r3, [r7, #16]
 80041e4:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 80041e8:	2b00      	cmp	r3, #0
 80041ea:	d00a      	beq.n	8004202 <PCD_EP_OutXfrComplete_int+0xbe>
      {
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 80041ec:	683b      	ldr	r3, [r7, #0]
 80041ee:	015a      	lsls	r2, r3, #5
 80041f0:	69bb      	ldr	r3, [r7, #24]
 80041f2:	4413      	add	r3, r2
 80041f4:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80041f8:	461a      	mov	r2, r3
 80041fa:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 80041fe:	6093      	str	r3, [r2, #8]
 8004200:	e07e      	b.n	8004300 <PCD_EP_OutXfrComplete_int+0x1bc>
      }
      else
      {
        ep = &hpcd->OUT_ep[epnum];
 8004202:	683a      	ldr	r2, [r7, #0]
 8004204:	4613      	mov	r3, r2
 8004206:	00db      	lsls	r3, r3, #3
 8004208:	4413      	add	r3, r2
 800420a:	009b      	lsls	r3, r3, #2
 800420c:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 8004210:	687a      	ldr	r2, [r7, #4]
 8004212:	4413      	add	r3, r2
 8004214:	3304      	adds	r3, #4
 8004216:	60fb      	str	r3, [r7, #12]

        /* out data packet received over EP */
        ep->xfer_count = ep->xfer_size - (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ);
 8004218:	68fb      	ldr	r3, [r7, #12]
 800421a:	6a1a      	ldr	r2, [r3, #32]
 800421c:	683b      	ldr	r3, [r7, #0]
 800421e:	0159      	lsls	r1, r3, #5
 8004220:	69bb      	ldr	r3, [r7, #24]
 8004222:	440b      	add	r3, r1
 8004224:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8004228:	691b      	ldr	r3, [r3, #16]
 800422a:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800422e:	1ad2      	subs	r2, r2, r3
 8004230:	68fb      	ldr	r3, [r7, #12]
 8004232:	615a      	str	r2, [r3, #20]

        if (epnum == 0U)
 8004234:	683b      	ldr	r3, [r7, #0]
 8004236:	2b00      	cmp	r3, #0
 8004238:	d114      	bne.n	8004264 <PCD_EP_OutXfrComplete_int+0x120>
        {
          if (ep->xfer_len == 0U)
 800423a:	68fb      	ldr	r3, [r7, #12]
 800423c:	691b      	ldr	r3, [r3, #16]
 800423e:	2b00      	cmp	r3, #0
 8004240:	d109      	bne.n	8004256 <PCD_EP_OutXfrComplete_int+0x112>
          {
            /* this is ZLP, so prepare EP0 for next setup */
            (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 8004242:	687b      	ldr	r3, [r7, #4]
 8004244:	6818      	ldr	r0, [r3, #0]
 8004246:	687b      	ldr	r3, [r7, #4]
 8004248:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 800424c:	461a      	mov	r2, r3
 800424e:	2101      	movs	r1, #1
 8004250:	f002 fabc 	bl	80067cc <USB_EP0_OutStart>
 8004254:	e006      	b.n	8004264 <PCD_EP_OutXfrComplete_int+0x120>
          }
          else
          {
            ep->xfer_buff += ep->xfer_count;
 8004256:	68fb      	ldr	r3, [r7, #12]
 8004258:	68da      	ldr	r2, [r3, #12]
 800425a:	68fb      	ldr	r3, [r7, #12]
 800425c:	695b      	ldr	r3, [r3, #20]
 800425e:	441a      	add	r2, r3
 8004260:	68fb      	ldr	r3, [r7, #12]
 8004262:	60da      	str	r2, [r3, #12]
        }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);
#else
        HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 8004264:	683b      	ldr	r3, [r7, #0]
 8004266:	b2db      	uxtb	r3, r3
 8004268:	4619      	mov	r1, r3
 800426a:	6878      	ldr	r0, [r7, #4]
 800426c:	f023 fd32 	bl	8027cd4 <HAL_PCD_DataOutStageCallback>
 8004270:	e046      	b.n	8004300 <PCD_EP_OutXfrComplete_int+0x1bc>
      /* ... */
    }
  }
  else
  {
    if (gSNPSiD == USB_OTG_CORE_ID_310A)
 8004272:	697b      	ldr	r3, [r7, #20]
 8004274:	4a26      	ldr	r2, [pc, #152]	@ (8004310 <PCD_EP_OutXfrComplete_int+0x1cc>)
 8004276:	4293      	cmp	r3, r2
 8004278:	d124      	bne.n	80042c4 <PCD_EP_OutXfrComplete_int+0x180>
    {
      /* StupPktRcvd = 1 this is a setup packet */
      if ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX)
 800427a:	693b      	ldr	r3, [r7, #16]
 800427c:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 8004280:	2b00      	cmp	r3, #0
 8004282:	d00a      	beq.n	800429a <PCD_EP_OutXfrComplete_int+0x156>
      {
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 8004284:	683b      	ldr	r3, [r7, #0]
 8004286:	015a      	lsls	r2, r3, #5
 8004288:	69bb      	ldr	r3, [r7, #24]
 800428a:	4413      	add	r3, r2
 800428c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8004290:	461a      	mov	r2, r3
 8004292:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 8004296:	6093      	str	r3, [r2, #8]
 8004298:	e032      	b.n	8004300 <PCD_EP_OutXfrComplete_int+0x1bc>
      }
      else
      {
        if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
 800429a:	693b      	ldr	r3, [r7, #16]
 800429c:	f003 0320 	and.w	r3, r3, #32
 80042a0:	2b00      	cmp	r3, #0
 80042a2:	d008      	beq.n	80042b6 <PCD_EP_OutXfrComplete_int+0x172>
        {
          CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 80042a4:	683b      	ldr	r3, [r7, #0]
 80042a6:	015a      	lsls	r2, r3, #5
 80042a8:	69bb      	ldr	r3, [r7, #24]
 80042aa:	4413      	add	r3, r2
 80042ac:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80042b0:	461a      	mov	r2, r3
 80042b2:	2320      	movs	r3, #32
 80042b4:	6093      	str	r3, [r2, #8]
        }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);
#else
        HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 80042b6:	683b      	ldr	r3, [r7, #0]
 80042b8:	b2db      	uxtb	r3, r3
 80042ba:	4619      	mov	r1, r3
 80042bc:	6878      	ldr	r0, [r7, #4]
 80042be:	f023 fd09 	bl	8027cd4 <HAL_PCD_DataOutStageCallback>
 80042c2:	e01d      	b.n	8004300 <PCD_EP_OutXfrComplete_int+0x1bc>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
    }
    else
    {
      if ((epnum == 0U) && (hpcd->OUT_ep[epnum].xfer_len == 0U))
 80042c4:	683b      	ldr	r3, [r7, #0]
 80042c6:	2b00      	cmp	r3, #0
 80042c8:	d114      	bne.n	80042f4 <PCD_EP_OutXfrComplete_int+0x1b0>
 80042ca:	6879      	ldr	r1, [r7, #4]
 80042cc:	683a      	ldr	r2, [r7, #0]
 80042ce:	4613      	mov	r3, r2
 80042d0:	00db      	lsls	r3, r3, #3
 80042d2:	4413      	add	r3, r2
 80042d4:	009b      	lsls	r3, r3, #2
 80042d6:	440b      	add	r3, r1
 80042d8:	f503 7319 	add.w	r3, r3, #612	@ 0x264
 80042dc:	681b      	ldr	r3, [r3, #0]
 80042de:	2b00      	cmp	r3, #0
 80042e0:	d108      	bne.n	80042f4 <PCD_EP_OutXfrComplete_int+0x1b0>
      {
        /* this is ZLP, so prepare EP0 for next setup */
        (void)USB_EP0_OutStart(hpcd->Instance, 0U, (uint8_t *)hpcd->Setup);
 80042e2:	687b      	ldr	r3, [r7, #4]
 80042e4:	6818      	ldr	r0, [r3, #0]
 80042e6:	687b      	ldr	r3, [r7, #4]
 80042e8:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 80042ec:	461a      	mov	r2, r3
 80042ee:	2100      	movs	r1, #0
 80042f0:	f002 fa6c 	bl	80067cc <USB_EP0_OutStart>
      }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);
#else
      HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 80042f4:	683b      	ldr	r3, [r7, #0]
 80042f6:	b2db      	uxtb	r3, r3
 80042f8:	4619      	mov	r1, r3
 80042fa:	6878      	ldr	r0, [r7, #4]
 80042fc:	f023 fcea 	bl	8027cd4 <HAL_PCD_DataOutStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
    }
  }

  return HAL_OK;
 8004300:	2300      	movs	r3, #0
}
 8004302:	4618      	mov	r0, r3
 8004304:	3720      	adds	r7, #32
 8004306:	46bd      	mov	sp, r7
 8004308:	bd80      	pop	{r7, pc}
 800430a:	bf00      	nop
 800430c:	4f54300a 	.word	0x4f54300a
 8004310:	4f54310a 	.word	0x4f54310a

08004314 <PCD_EP_OutSetupPacket_int>:
  * @param  hpcd PCD handle
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_EP_OutSetupPacket_int(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
 8004314:	b580      	push	{r7, lr}
 8004316:	b086      	sub	sp, #24
 8004318:	af00      	add	r7, sp, #0
 800431a:	6078      	str	r0, [r7, #4]
 800431c:	6039      	str	r1, [r7, #0]
  const USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 800431e:	687b      	ldr	r3, [r7, #4]
 8004320:	681b      	ldr	r3, [r3, #0]
 8004322:	617b      	str	r3, [r7, #20]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8004324:	697b      	ldr	r3, [r7, #20]
 8004326:	613b      	str	r3, [r7, #16]
  uint32_t gSNPSiD = *(__IO const uint32_t *)(&USBx->CID + 0x1U);
 8004328:	697b      	ldr	r3, [r7, #20]
 800432a:	333c      	adds	r3, #60	@ 0x3c
 800432c:	3304      	adds	r3, #4
 800432e:	681b      	ldr	r3, [r3, #0]
 8004330:	60fb      	str	r3, [r7, #12]
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 8004332:	683b      	ldr	r3, [r7, #0]
 8004334:	015a      	lsls	r2, r3, #5
 8004336:	693b      	ldr	r3, [r7, #16]
 8004338:	4413      	add	r3, r2
 800433a:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800433e:	689b      	ldr	r3, [r3, #8]
 8004340:	60bb      	str	r3, [r7, #8]

  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8004342:	68fb      	ldr	r3, [r7, #12]
 8004344:	4a15      	ldr	r2, [pc, #84]	@ (800439c <PCD_EP_OutSetupPacket_int+0x88>)
 8004346:	4293      	cmp	r3, r2
 8004348:	d90e      	bls.n	8004368 <PCD_EP_OutSetupPacket_int+0x54>
      ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
 800434a:	68bb      	ldr	r3, [r7, #8]
 800434c:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8004350:	2b00      	cmp	r3, #0
 8004352:	d009      	beq.n	8004368 <PCD_EP_OutSetupPacket_int+0x54>
  {
    CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 8004354:	683b      	ldr	r3, [r7, #0]
 8004356:	015a      	lsls	r2, r3, #5
 8004358:	693b      	ldr	r3, [r7, #16]
 800435a:	4413      	add	r3, r2
 800435c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8004360:	461a      	mov	r2, r3
 8004362:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 8004366:	6093      	str	r3, [r2, #8]

  /* Inform the upper layer that a setup packet is available */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
  hpcd->SetupStageCallback(hpcd);
#else
  HAL_PCD_SetupStageCallback(hpcd);
 8004368:	6878      	ldr	r0, [r7, #4]
 800436a:	f023 fca1 	bl	8027cb0 <HAL_PCD_SetupStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

  if ((gSNPSiD > USB_OTG_CORE_ID_300A) && (hpcd->Init.dma_enable == 1U))
 800436e:	68fb      	ldr	r3, [r7, #12]
 8004370:	4a0a      	ldr	r2, [pc, #40]	@ (800439c <PCD_EP_OutSetupPacket_int+0x88>)
 8004372:	4293      	cmp	r3, r2
 8004374:	d90c      	bls.n	8004390 <PCD_EP_OutSetupPacket_int+0x7c>
 8004376:	687b      	ldr	r3, [r7, #4]
 8004378:	799b      	ldrb	r3, [r3, #6]
 800437a:	2b01      	cmp	r3, #1
 800437c:	d108      	bne.n	8004390 <PCD_EP_OutSetupPacket_int+0x7c>
  {
    (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 800437e:	687b      	ldr	r3, [r7, #4]
 8004380:	6818      	ldr	r0, [r3, #0]
 8004382:	687b      	ldr	r3, [r7, #4]
 8004384:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 8004388:	461a      	mov	r2, r3
 800438a:	2101      	movs	r1, #1
 800438c:	f002 fa1e 	bl	80067cc <USB_EP0_OutStart>
  }

  return HAL_OK;
 8004390:	2300      	movs	r3, #0
}
 8004392:	4618      	mov	r0, r3
 8004394:	3718      	adds	r7, #24
 8004396:	46bd      	mov	sp, r7
 8004398:	bd80      	pop	{r7, pc}
 800439a:	bf00      	nop
 800439c:	4f54300a 	.word	0x4f54300a

080043a0 <HAL_PCDEx_SetTxFiFo>:
  * @param  fifo The number of Tx fifo
  * @param  size Fifo size
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetTxFiFo(PCD_HandleTypeDef *hpcd, uint8_t fifo, uint16_t size)
{
 80043a0:	b480      	push	{r7}
 80043a2:	b085      	sub	sp, #20
 80043a4:	af00      	add	r7, sp, #0
 80043a6:	6078      	str	r0, [r7, #4]
 80043a8:	460b      	mov	r3, r1
 80043aa:	70fb      	strb	r3, [r7, #3]
 80043ac:	4613      	mov	r3, r2
 80043ae:	803b      	strh	r3, [r7, #0]
         --> Txn should be configured with the minimum space of 16 words
     The FIFO is used optimally when used TxFIFOs are allocated in the top
         of the FIFO.Ex: use EP1 and EP2 as IN instead of EP1 and EP3 as IN ones.
     When DMA is used 3n * FIFO locations should be reserved for internal DMA registers */

  Tx_Offset = hpcd->Instance->GRXFSIZ;
 80043b0:	687b      	ldr	r3, [r7, #4]
 80043b2:	681b      	ldr	r3, [r3, #0]
 80043b4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80043b6:	60bb      	str	r3, [r7, #8]

  if (fifo == 0U)
 80043b8:	78fb      	ldrb	r3, [r7, #3]
 80043ba:	2b00      	cmp	r3, #0
 80043bc:	d107      	bne.n	80043ce <HAL_PCDEx_SetTxFiFo+0x2e>
  {
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = ((uint32_t)size << 16) | Tx_Offset;
 80043be:	883b      	ldrh	r3, [r7, #0]
 80043c0:	0419      	lsls	r1, r3, #16
 80043c2:	687b      	ldr	r3, [r7, #4]
 80043c4:	681b      	ldr	r3, [r3, #0]
 80043c6:	68ba      	ldr	r2, [r7, #8]
 80043c8:	430a      	orrs	r2, r1
 80043ca:	629a      	str	r2, [r3, #40]	@ 0x28
 80043cc:	e028      	b.n	8004420 <HAL_PCDEx_SetTxFiFo+0x80>
  }
  else
  {
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16;
 80043ce:	687b      	ldr	r3, [r7, #4]
 80043d0:	681b      	ldr	r3, [r3, #0]
 80043d2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80043d4:	0c1b      	lsrs	r3, r3, #16
 80043d6:	68ba      	ldr	r2, [r7, #8]
 80043d8:	4413      	add	r3, r2
 80043da:	60bb      	str	r3, [r7, #8]
    for (i = 0U; i < (fifo - 1U); i++)
 80043dc:	2300      	movs	r3, #0
 80043de:	73fb      	strb	r3, [r7, #15]
 80043e0:	e00d      	b.n	80043fe <HAL_PCDEx_SetTxFiFo+0x5e>
    {
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 80043e2:	687b      	ldr	r3, [r7, #4]
 80043e4:	681a      	ldr	r2, [r3, #0]
 80043e6:	7bfb      	ldrb	r3, [r7, #15]
 80043e8:	3340      	adds	r3, #64	@ 0x40
 80043ea:	009b      	lsls	r3, r3, #2
 80043ec:	4413      	add	r3, r2
 80043ee:	685b      	ldr	r3, [r3, #4]
 80043f0:	0c1b      	lsrs	r3, r3, #16
 80043f2:	68ba      	ldr	r2, [r7, #8]
 80043f4:	4413      	add	r3, r2
 80043f6:	60bb      	str	r3, [r7, #8]
    for (i = 0U; i < (fifo - 1U); i++)
 80043f8:	7bfb      	ldrb	r3, [r7, #15]
 80043fa:	3301      	adds	r3, #1
 80043fc:	73fb      	strb	r3, [r7, #15]
 80043fe:	7bfa      	ldrb	r2, [r7, #15]
 8004400:	78fb      	ldrb	r3, [r7, #3]
 8004402:	3b01      	subs	r3, #1
 8004404:	429a      	cmp	r2, r3
 8004406:	d3ec      	bcc.n	80043e2 <HAL_PCDEx_SetTxFiFo+0x42>
    }

    /* Multiply Tx_Size by 2 to get higher performance */
    hpcd->Instance->DIEPTXF[fifo - 1U] = ((uint32_t)size << 16) | Tx_Offset;
 8004408:	883b      	ldrh	r3, [r7, #0]
 800440a:	0418      	lsls	r0, r3, #16
 800440c:	687b      	ldr	r3, [r7, #4]
 800440e:	6819      	ldr	r1, [r3, #0]
 8004410:	78fb      	ldrb	r3, [r7, #3]
 8004412:	3b01      	subs	r3, #1
 8004414:	68ba      	ldr	r2, [r7, #8]
 8004416:	4302      	orrs	r2, r0
 8004418:	3340      	adds	r3, #64	@ 0x40
 800441a:	009b      	lsls	r3, r3, #2
 800441c:	440b      	add	r3, r1
 800441e:	605a      	str	r2, [r3, #4]
  }

  return HAL_OK;
 8004420:	2300      	movs	r3, #0
}
 8004422:	4618      	mov	r0, r3
 8004424:	3714      	adds	r7, #20
 8004426:	46bd      	mov	sp, r7
 8004428:	f85d 7b04 	ldr.w	r7, [sp], #4
 800442c:	4770      	bx	lr

0800442e <HAL_PCDEx_SetRxFiFo>:
  * @param  hpcd PCD handle
  * @param  size Size of Rx fifo
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetRxFiFo(PCD_HandleTypeDef *hpcd, uint16_t size)
{
 800442e:	b480      	push	{r7}
 8004430:	b083      	sub	sp, #12
 8004432:	af00      	add	r7, sp, #0
 8004434:	6078      	str	r0, [r7, #4]
 8004436:	460b      	mov	r3, r1
 8004438:	807b      	strh	r3, [r7, #2]
  hpcd->Instance->GRXFSIZ = size;
 800443a:	687b      	ldr	r3, [r7, #4]
 800443c:	681b      	ldr	r3, [r3, #0]
 800443e:	887a      	ldrh	r2, [r7, #2]
 8004440:	625a      	str	r2, [r3, #36]	@ 0x24

  return HAL_OK;
 8004442:	2300      	movs	r3, #0
}
 8004444:	4618      	mov	r0, r3
 8004446:	370c      	adds	r7, #12
 8004448:	46bd      	mov	sp, r7
 800444a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800444e:	4770      	bx	lr

08004450 <HAL_PCDEx_LPM_Callback>:
  * @param  hpcd PCD handle
  * @param  msg LPM message
  * @retval HAL status
  */
__weak void HAL_PCDEx_LPM_Callback(PCD_HandleTypeDef *hpcd, PCD_LPM_MsgTypeDef msg)
{
 8004450:	b480      	push	{r7}
 8004452:	b083      	sub	sp, #12
 8004454:	af00      	add	r7, sp, #0
 8004456:	6078      	str	r0, [r7, #4]
 8004458:	460b      	mov	r3, r1
 800445a:	70fb      	strb	r3, [r7, #3]
  UNUSED(msg);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PCDEx_LPM_Callback could be implemented in the user file
   */
}
 800445c:	bf00      	nop
 800445e:	370c      	adds	r7, #12
 8004460:	46bd      	mov	sp, r7
 8004462:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004466:	4770      	bx	lr

08004468 <HAL_RCC_OscConfig>:
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8004468:	b580      	push	{r7, lr}
 800446a:	b086      	sub	sp, #24
 800446c:	af00      	add	r7, sp, #0
 800446e:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  uint32_t pll_config;
  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
 8004470:	687b      	ldr	r3, [r7, #4]
 8004472:	2b00      	cmp	r3, #0
 8004474:	d101      	bne.n	800447a <HAL_RCC_OscConfig+0x12>
  {
    return HAL_ERROR;
 8004476:	2301      	movs	r3, #1
 8004478:	e267      	b.n	800494a <HAL_RCC_OscConfig+0x4e2>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800447a:	687b      	ldr	r3, [r7, #4]
 800447c:	681b      	ldr	r3, [r3, #0]
 800447e:	f003 0301 	and.w	r3, r3, #1
 8004482:	2b00      	cmp	r3, #0
 8004484:	d075      	beq.n	8004572 <HAL_RCC_OscConfig+0x10a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) || \
 8004486:	4b88      	ldr	r3, [pc, #544]	@ (80046a8 <HAL_RCC_OscConfig+0x240>)
 8004488:	689b      	ldr	r3, [r3, #8]
 800448a:	f003 030c 	and.w	r3, r3, #12
 800448e:	2b04      	cmp	r3, #4
 8004490:	d00c      	beq.n	80044ac <HAL_RCC_OscConfig+0x44>
        ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8004492:	4b85      	ldr	r3, [pc, #532]	@ (80046a8 <HAL_RCC_OscConfig+0x240>)
 8004494:	689b      	ldr	r3, [r3, #8]
 8004496:	f003 030c 	and.w	r3, r3, #12
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) || \
 800449a:	2b08      	cmp	r3, #8
 800449c:	d112      	bne.n	80044c4 <HAL_RCC_OscConfig+0x5c>
        ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 800449e:	4b82      	ldr	r3, [pc, #520]	@ (80046a8 <HAL_RCC_OscConfig+0x240>)
 80044a0:	685b      	ldr	r3, [r3, #4]
 80044a2:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 80044a6:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 80044aa:	d10b      	bne.n	80044c4 <HAL_RCC_OscConfig+0x5c>
    {
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80044ac:	4b7e      	ldr	r3, [pc, #504]	@ (80046a8 <HAL_RCC_OscConfig+0x240>)
 80044ae:	681b      	ldr	r3, [r3, #0]
 80044b0:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 80044b4:	2b00      	cmp	r3, #0
 80044b6:	d05b      	beq.n	8004570 <HAL_RCC_OscConfig+0x108>
 80044b8:	687b      	ldr	r3, [r7, #4]
 80044ba:	685b      	ldr	r3, [r3, #4]
 80044bc:	2b00      	cmp	r3, #0
 80044be:	d157      	bne.n	8004570 <HAL_RCC_OscConfig+0x108>
      {
        return HAL_ERROR;
 80044c0:	2301      	movs	r3, #1
 80044c2:	e242      	b.n	800494a <HAL_RCC_OscConfig+0x4e2>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80044c4:	687b      	ldr	r3, [r7, #4]
 80044c6:	685b      	ldr	r3, [r3, #4]
 80044c8:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 80044cc:	d106      	bne.n	80044dc <HAL_RCC_OscConfig+0x74>
 80044ce:	4b76      	ldr	r3, [pc, #472]	@ (80046a8 <HAL_RCC_OscConfig+0x240>)
 80044d0:	681b      	ldr	r3, [r3, #0]
 80044d2:	4a75      	ldr	r2, [pc, #468]	@ (80046a8 <HAL_RCC_OscConfig+0x240>)
 80044d4:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 80044d8:	6013      	str	r3, [r2, #0]
 80044da:	e01d      	b.n	8004518 <HAL_RCC_OscConfig+0xb0>
 80044dc:	687b      	ldr	r3, [r7, #4]
 80044de:	685b      	ldr	r3, [r3, #4]
 80044e0:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 80044e4:	d10c      	bne.n	8004500 <HAL_RCC_OscConfig+0x98>
 80044e6:	4b70      	ldr	r3, [pc, #448]	@ (80046a8 <HAL_RCC_OscConfig+0x240>)
 80044e8:	681b      	ldr	r3, [r3, #0]
 80044ea:	4a6f      	ldr	r2, [pc, #444]	@ (80046a8 <HAL_RCC_OscConfig+0x240>)
 80044ec:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 80044f0:	6013      	str	r3, [r2, #0]
 80044f2:	4b6d      	ldr	r3, [pc, #436]	@ (80046a8 <HAL_RCC_OscConfig+0x240>)
 80044f4:	681b      	ldr	r3, [r3, #0]
 80044f6:	4a6c      	ldr	r2, [pc, #432]	@ (80046a8 <HAL_RCC_OscConfig+0x240>)
 80044f8:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 80044fc:	6013      	str	r3, [r2, #0]
 80044fe:	e00b      	b.n	8004518 <HAL_RCC_OscConfig+0xb0>
 8004500:	4b69      	ldr	r3, [pc, #420]	@ (80046a8 <HAL_RCC_OscConfig+0x240>)
 8004502:	681b      	ldr	r3, [r3, #0]
 8004504:	4a68      	ldr	r2, [pc, #416]	@ (80046a8 <HAL_RCC_OscConfig+0x240>)
 8004506:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 800450a:	6013      	str	r3, [r2, #0]
 800450c:	4b66      	ldr	r3, [pc, #408]	@ (80046a8 <HAL_RCC_OscConfig+0x240>)
 800450e:	681b      	ldr	r3, [r3, #0]
 8004510:	4a65      	ldr	r2, [pc, #404]	@ (80046a8 <HAL_RCC_OscConfig+0x240>)
 8004512:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 8004516:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if ((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 8004518:	687b      	ldr	r3, [r7, #4]
 800451a:	685b      	ldr	r3, [r3, #4]
 800451c:	2b00      	cmp	r3, #0
 800451e:	d013      	beq.n	8004548 <HAL_RCC_OscConfig+0xe0>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8004520:	f7fd fc1c 	bl	8001d5c <HAL_GetTick>
 8004524:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8004526:	e008      	b.n	800453a <HAL_RCC_OscConfig+0xd2>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8004528:	f7fd fc18 	bl	8001d5c <HAL_GetTick>
 800452c:	4602      	mov	r2, r0
 800452e:	693b      	ldr	r3, [r7, #16]
 8004530:	1ad3      	subs	r3, r2, r3
 8004532:	2b64      	cmp	r3, #100	@ 0x64
 8004534:	d901      	bls.n	800453a <HAL_RCC_OscConfig+0xd2>
          {
            return HAL_TIMEOUT;
 8004536:	2303      	movs	r3, #3
 8004538:	e207      	b.n	800494a <HAL_RCC_OscConfig+0x4e2>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800453a:	4b5b      	ldr	r3, [pc, #364]	@ (80046a8 <HAL_RCC_OscConfig+0x240>)
 800453c:	681b      	ldr	r3, [r3, #0]
 800453e:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8004542:	2b00      	cmp	r3, #0
 8004544:	d0f0      	beq.n	8004528 <HAL_RCC_OscConfig+0xc0>
 8004546:	e014      	b.n	8004572 <HAL_RCC_OscConfig+0x10a>
        }
      }
      else
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8004548:	f7fd fc08 	bl	8001d5c <HAL_GetTick>
 800454c:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is bypassed or disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800454e:	e008      	b.n	8004562 <HAL_RCC_OscConfig+0xfa>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8004550:	f7fd fc04 	bl	8001d5c <HAL_GetTick>
 8004554:	4602      	mov	r2, r0
 8004556:	693b      	ldr	r3, [r7, #16]
 8004558:	1ad3      	subs	r3, r2, r3
 800455a:	2b64      	cmp	r3, #100	@ 0x64
 800455c:	d901      	bls.n	8004562 <HAL_RCC_OscConfig+0xfa>
          {
            return HAL_TIMEOUT;
 800455e:	2303      	movs	r3, #3
 8004560:	e1f3      	b.n	800494a <HAL_RCC_OscConfig+0x4e2>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8004562:	4b51      	ldr	r3, [pc, #324]	@ (80046a8 <HAL_RCC_OscConfig+0x240>)
 8004564:	681b      	ldr	r3, [r3, #0]
 8004566:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800456a:	2b00      	cmp	r3, #0
 800456c:	d1f0      	bne.n	8004550 <HAL_RCC_OscConfig+0xe8>
 800456e:	e000      	b.n	8004572 <HAL_RCC_OscConfig+0x10a>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8004570:	bf00      	nop
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8004572:	687b      	ldr	r3, [r7, #4]
 8004574:	681b      	ldr	r3, [r3, #0]
 8004576:	f003 0302 	and.w	r3, r3, #2
 800457a:	2b00      	cmp	r3, #0
 800457c:	d063      	beq.n	8004646 <HAL_RCC_OscConfig+0x1de>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) || \
 800457e:	4b4a      	ldr	r3, [pc, #296]	@ (80046a8 <HAL_RCC_OscConfig+0x240>)
 8004580:	689b      	ldr	r3, [r3, #8]
 8004582:	f003 030c 	and.w	r3, r3, #12
 8004586:	2b00      	cmp	r3, #0
 8004588:	d00b      	beq.n	80045a2 <HAL_RCC_OscConfig+0x13a>
        ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 800458a:	4b47      	ldr	r3, [pc, #284]	@ (80046a8 <HAL_RCC_OscConfig+0x240>)
 800458c:	689b      	ldr	r3, [r3, #8]
 800458e:	f003 030c 	and.w	r3, r3, #12
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) || \
 8004592:	2b08      	cmp	r3, #8
 8004594:	d11c      	bne.n	80045d0 <HAL_RCC_OscConfig+0x168>
        ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8004596:	4b44      	ldr	r3, [pc, #272]	@ (80046a8 <HAL_RCC_OscConfig+0x240>)
 8004598:	685b      	ldr	r3, [r3, #4]
 800459a:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 800459e:	2b00      	cmp	r3, #0
 80045a0:	d116      	bne.n	80045d0 <HAL_RCC_OscConfig+0x168>
    {
      /* When HSI is used as system clock it will not disabled */
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 80045a2:	4b41      	ldr	r3, [pc, #260]	@ (80046a8 <HAL_RCC_OscConfig+0x240>)
 80045a4:	681b      	ldr	r3, [r3, #0]
 80045a6:	f003 0302 	and.w	r3, r3, #2
 80045aa:	2b00      	cmp	r3, #0
 80045ac:	d005      	beq.n	80045ba <HAL_RCC_OscConfig+0x152>
 80045ae:	687b      	ldr	r3, [r7, #4]
 80045b0:	68db      	ldr	r3, [r3, #12]
 80045b2:	2b01      	cmp	r3, #1
 80045b4:	d001      	beq.n	80045ba <HAL_RCC_OscConfig+0x152>
      {
        return HAL_ERROR;
 80045b6:	2301      	movs	r3, #1
 80045b8:	e1c7      	b.n	800494a <HAL_RCC_OscConfig+0x4e2>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80045ba:	4b3b      	ldr	r3, [pc, #236]	@ (80046a8 <HAL_RCC_OscConfig+0x240>)
 80045bc:	681b      	ldr	r3, [r3, #0]
 80045be:	f023 02f8 	bic.w	r2, r3, #248	@ 0xf8
 80045c2:	687b      	ldr	r3, [r7, #4]
 80045c4:	691b      	ldr	r3, [r3, #16]
 80045c6:	00db      	lsls	r3, r3, #3
 80045c8:	4937      	ldr	r1, [pc, #220]	@ (80046a8 <HAL_RCC_OscConfig+0x240>)
 80045ca:	4313      	orrs	r3, r2
 80045cc:	600b      	str	r3, [r1, #0]
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 80045ce:	e03a      	b.n	8004646 <HAL_RCC_OscConfig+0x1de>
      }
    }
    else
    {
      /* Check the HSI State */
      if ((RCC_OscInitStruct->HSIState) != RCC_HSI_OFF)
 80045d0:	687b      	ldr	r3, [r7, #4]
 80045d2:	68db      	ldr	r3, [r3, #12]
 80045d4:	2b00      	cmp	r3, #0
 80045d6:	d020      	beq.n	800461a <HAL_RCC_OscConfig+0x1b2>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 80045d8:	4b34      	ldr	r3, [pc, #208]	@ (80046ac <HAL_RCC_OscConfig+0x244>)
 80045da:	2201      	movs	r2, #1
 80045dc:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80045de:	f7fd fbbd 	bl	8001d5c <HAL_GetTick>
 80045e2:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80045e4:	e008      	b.n	80045f8 <HAL_RCC_OscConfig+0x190>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 80045e6:	f7fd fbb9 	bl	8001d5c <HAL_GetTick>
 80045ea:	4602      	mov	r2, r0
 80045ec:	693b      	ldr	r3, [r7, #16]
 80045ee:	1ad3      	subs	r3, r2, r3
 80045f0:	2b02      	cmp	r3, #2
 80045f2:	d901      	bls.n	80045f8 <HAL_RCC_OscConfig+0x190>
          {
            return HAL_TIMEOUT;
 80045f4:	2303      	movs	r3, #3
 80045f6:	e1a8      	b.n	800494a <HAL_RCC_OscConfig+0x4e2>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80045f8:	4b2b      	ldr	r3, [pc, #172]	@ (80046a8 <HAL_RCC_OscConfig+0x240>)
 80045fa:	681b      	ldr	r3, [r3, #0]
 80045fc:	f003 0302 	and.w	r3, r3, #2
 8004600:	2b00      	cmp	r3, #0
 8004602:	d0f0      	beq.n	80045e6 <HAL_RCC_OscConfig+0x17e>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value. */
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8004604:	4b28      	ldr	r3, [pc, #160]	@ (80046a8 <HAL_RCC_OscConfig+0x240>)
 8004606:	681b      	ldr	r3, [r3, #0]
 8004608:	f023 02f8 	bic.w	r2, r3, #248	@ 0xf8
 800460c:	687b      	ldr	r3, [r7, #4]
 800460e:	691b      	ldr	r3, [r3, #16]
 8004610:	00db      	lsls	r3, r3, #3
 8004612:	4925      	ldr	r1, [pc, #148]	@ (80046a8 <HAL_RCC_OscConfig+0x240>)
 8004614:	4313      	orrs	r3, r2
 8004616:	600b      	str	r3, [r1, #0]
 8004618:	e015      	b.n	8004646 <HAL_RCC_OscConfig+0x1de>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 800461a:	4b24      	ldr	r3, [pc, #144]	@ (80046ac <HAL_RCC_OscConfig+0x244>)
 800461c:	2200      	movs	r2, #0
 800461e:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8004620:	f7fd fb9c 	bl	8001d5c <HAL_GetTick>
 8004624:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8004626:	e008      	b.n	800463a <HAL_RCC_OscConfig+0x1d2>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8004628:	f7fd fb98 	bl	8001d5c <HAL_GetTick>
 800462c:	4602      	mov	r2, r0
 800462e:	693b      	ldr	r3, [r7, #16]
 8004630:	1ad3      	subs	r3, r2, r3
 8004632:	2b02      	cmp	r3, #2
 8004634:	d901      	bls.n	800463a <HAL_RCC_OscConfig+0x1d2>
          {
            return HAL_TIMEOUT;
 8004636:	2303      	movs	r3, #3
 8004638:	e187      	b.n	800494a <HAL_RCC_OscConfig+0x4e2>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800463a:	4b1b      	ldr	r3, [pc, #108]	@ (80046a8 <HAL_RCC_OscConfig+0x240>)
 800463c:	681b      	ldr	r3, [r3, #0]
 800463e:	f003 0302 	and.w	r3, r3, #2
 8004642:	2b00      	cmp	r3, #0
 8004644:	d1f0      	bne.n	8004628 <HAL_RCC_OscConfig+0x1c0>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8004646:	687b      	ldr	r3, [r7, #4]
 8004648:	681b      	ldr	r3, [r3, #0]
 800464a:	f003 0308 	and.w	r3, r3, #8
 800464e:	2b00      	cmp	r3, #0
 8004650:	d036      	beq.n	80046c0 <HAL_RCC_OscConfig+0x258>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if ((RCC_OscInitStruct->LSIState) != RCC_LSI_OFF)
 8004652:	687b      	ldr	r3, [r7, #4]
 8004654:	695b      	ldr	r3, [r3, #20]
 8004656:	2b00      	cmp	r3, #0
 8004658:	d016      	beq.n	8004688 <HAL_RCC_OscConfig+0x220>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 800465a:	4b15      	ldr	r3, [pc, #84]	@ (80046b0 <HAL_RCC_OscConfig+0x248>)
 800465c:	2201      	movs	r2, #1
 800465e:	601a      	str	r2, [r3, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8004660:	f7fd fb7c 	bl	8001d5c <HAL_GetTick>
 8004664:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8004666:	e008      	b.n	800467a <HAL_RCC_OscConfig+0x212>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8004668:	f7fd fb78 	bl	8001d5c <HAL_GetTick>
 800466c:	4602      	mov	r2, r0
 800466e:	693b      	ldr	r3, [r7, #16]
 8004670:	1ad3      	subs	r3, r2, r3
 8004672:	2b02      	cmp	r3, #2
 8004674:	d901      	bls.n	800467a <HAL_RCC_OscConfig+0x212>
        {
          return HAL_TIMEOUT;
 8004676:	2303      	movs	r3, #3
 8004678:	e167      	b.n	800494a <HAL_RCC_OscConfig+0x4e2>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800467a:	4b0b      	ldr	r3, [pc, #44]	@ (80046a8 <HAL_RCC_OscConfig+0x240>)
 800467c:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 800467e:	f003 0302 	and.w	r3, r3, #2
 8004682:	2b00      	cmp	r3, #0
 8004684:	d0f0      	beq.n	8004668 <HAL_RCC_OscConfig+0x200>
 8004686:	e01b      	b.n	80046c0 <HAL_RCC_OscConfig+0x258>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8004688:	4b09      	ldr	r3, [pc, #36]	@ (80046b0 <HAL_RCC_OscConfig+0x248>)
 800468a:	2200      	movs	r2, #0
 800468c:	601a      	str	r2, [r3, #0]

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800468e:	f7fd fb65 	bl	8001d5c <HAL_GetTick>
 8004692:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8004694:	e00e      	b.n	80046b4 <HAL_RCC_OscConfig+0x24c>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8004696:	f7fd fb61 	bl	8001d5c <HAL_GetTick>
 800469a:	4602      	mov	r2, r0
 800469c:	693b      	ldr	r3, [r7, #16]
 800469e:	1ad3      	subs	r3, r2, r3
 80046a0:	2b02      	cmp	r3, #2
 80046a2:	d907      	bls.n	80046b4 <HAL_RCC_OscConfig+0x24c>
        {
          return HAL_TIMEOUT;
 80046a4:	2303      	movs	r3, #3
 80046a6:	e150      	b.n	800494a <HAL_RCC_OscConfig+0x4e2>
 80046a8:	40023800 	.word	0x40023800
 80046ac:	42470000 	.word	0x42470000
 80046b0:	42470e80 	.word	0x42470e80
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80046b4:	4b88      	ldr	r3, [pc, #544]	@ (80048d8 <HAL_RCC_OscConfig+0x470>)
 80046b6:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 80046b8:	f003 0302 	and.w	r3, r3, #2
 80046bc:	2b00      	cmp	r3, #0
 80046be:	d1ea      	bne.n	8004696 <HAL_RCC_OscConfig+0x22e>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 80046c0:	687b      	ldr	r3, [r7, #4]
 80046c2:	681b      	ldr	r3, [r3, #0]
 80046c4:	f003 0304 	and.w	r3, r3, #4
 80046c8:	2b00      	cmp	r3, #0
 80046ca:	f000 8097 	beq.w	80047fc <HAL_RCC_OscConfig+0x394>
  {
    FlagStatus       pwrclkchanged = RESET;
 80046ce:	2300      	movs	r3, #0
 80046d0:	75fb      	strb	r3, [r7, #23]
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 80046d2:	4b81      	ldr	r3, [pc, #516]	@ (80048d8 <HAL_RCC_OscConfig+0x470>)
 80046d4:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80046d6:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 80046da:	2b00      	cmp	r3, #0
 80046dc:	d10f      	bne.n	80046fe <HAL_RCC_OscConfig+0x296>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 80046de:	2300      	movs	r3, #0
 80046e0:	60bb      	str	r3, [r7, #8]
 80046e2:	4b7d      	ldr	r3, [pc, #500]	@ (80048d8 <HAL_RCC_OscConfig+0x470>)
 80046e4:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80046e6:	4a7c      	ldr	r2, [pc, #496]	@ (80048d8 <HAL_RCC_OscConfig+0x470>)
 80046e8:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 80046ec:	6413      	str	r3, [r2, #64]	@ 0x40
 80046ee:	4b7a      	ldr	r3, [pc, #488]	@ (80048d8 <HAL_RCC_OscConfig+0x470>)
 80046f0:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80046f2:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 80046f6:	60bb      	str	r3, [r7, #8]
 80046f8:	68bb      	ldr	r3, [r7, #8]
      pwrclkchanged = SET;
 80046fa:	2301      	movs	r3, #1
 80046fc:	75fb      	strb	r3, [r7, #23]
    }

    if (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80046fe:	4b77      	ldr	r3, [pc, #476]	@ (80048dc <HAL_RCC_OscConfig+0x474>)
 8004700:	681b      	ldr	r3, [r3, #0]
 8004702:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8004706:	2b00      	cmp	r3, #0
 8004708:	d118      	bne.n	800473c <HAL_RCC_OscConfig+0x2d4>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 800470a:	4b74      	ldr	r3, [pc, #464]	@ (80048dc <HAL_RCC_OscConfig+0x474>)
 800470c:	681b      	ldr	r3, [r3, #0]
 800470e:	4a73      	ldr	r2, [pc, #460]	@ (80048dc <HAL_RCC_OscConfig+0x474>)
 8004710:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8004714:	6013      	str	r3, [r2, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 8004716:	f7fd fb21 	bl	8001d5c <HAL_GetTick>
 800471a:	6138      	str	r0, [r7, #16]

      while (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800471c:	e008      	b.n	8004730 <HAL_RCC_OscConfig+0x2c8>
      {
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800471e:	f7fd fb1d 	bl	8001d5c <HAL_GetTick>
 8004722:	4602      	mov	r2, r0
 8004724:	693b      	ldr	r3, [r7, #16]
 8004726:	1ad3      	subs	r3, r2, r3
 8004728:	2b02      	cmp	r3, #2
 800472a:	d901      	bls.n	8004730 <HAL_RCC_OscConfig+0x2c8>
        {
          return HAL_TIMEOUT;
 800472c:	2303      	movs	r3, #3
 800472e:	e10c      	b.n	800494a <HAL_RCC_OscConfig+0x4e2>
      while (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8004730:	4b6a      	ldr	r3, [pc, #424]	@ (80048dc <HAL_RCC_OscConfig+0x474>)
 8004732:	681b      	ldr	r3, [r3, #0]
 8004734:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8004738:	2b00      	cmp	r3, #0
 800473a:	d0f0      	beq.n	800471e <HAL_RCC_OscConfig+0x2b6>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800473c:	687b      	ldr	r3, [r7, #4]
 800473e:	689b      	ldr	r3, [r3, #8]
 8004740:	2b01      	cmp	r3, #1
 8004742:	d106      	bne.n	8004752 <HAL_RCC_OscConfig+0x2ea>
 8004744:	4b64      	ldr	r3, [pc, #400]	@ (80048d8 <HAL_RCC_OscConfig+0x470>)
 8004746:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8004748:	4a63      	ldr	r2, [pc, #396]	@ (80048d8 <HAL_RCC_OscConfig+0x470>)
 800474a:	f043 0301 	orr.w	r3, r3, #1
 800474e:	6713      	str	r3, [r2, #112]	@ 0x70
 8004750:	e01c      	b.n	800478c <HAL_RCC_OscConfig+0x324>
 8004752:	687b      	ldr	r3, [r7, #4]
 8004754:	689b      	ldr	r3, [r3, #8]
 8004756:	2b05      	cmp	r3, #5
 8004758:	d10c      	bne.n	8004774 <HAL_RCC_OscConfig+0x30c>
 800475a:	4b5f      	ldr	r3, [pc, #380]	@ (80048d8 <HAL_RCC_OscConfig+0x470>)
 800475c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800475e:	4a5e      	ldr	r2, [pc, #376]	@ (80048d8 <HAL_RCC_OscConfig+0x470>)
 8004760:	f043 0304 	orr.w	r3, r3, #4
 8004764:	6713      	str	r3, [r2, #112]	@ 0x70
 8004766:	4b5c      	ldr	r3, [pc, #368]	@ (80048d8 <HAL_RCC_OscConfig+0x470>)
 8004768:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800476a:	4a5b      	ldr	r2, [pc, #364]	@ (80048d8 <HAL_RCC_OscConfig+0x470>)
 800476c:	f043 0301 	orr.w	r3, r3, #1
 8004770:	6713      	str	r3, [r2, #112]	@ 0x70
 8004772:	e00b      	b.n	800478c <HAL_RCC_OscConfig+0x324>
 8004774:	4b58      	ldr	r3, [pc, #352]	@ (80048d8 <HAL_RCC_OscConfig+0x470>)
 8004776:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8004778:	4a57      	ldr	r2, [pc, #348]	@ (80048d8 <HAL_RCC_OscConfig+0x470>)
 800477a:	f023 0301 	bic.w	r3, r3, #1
 800477e:	6713      	str	r3, [r2, #112]	@ 0x70
 8004780:	4b55      	ldr	r3, [pc, #340]	@ (80048d8 <HAL_RCC_OscConfig+0x470>)
 8004782:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8004784:	4a54      	ldr	r2, [pc, #336]	@ (80048d8 <HAL_RCC_OscConfig+0x470>)
 8004786:	f023 0304 	bic.w	r3, r3, #4
 800478a:	6713      	str	r3, [r2, #112]	@ 0x70
    /* Check the LSE State */
    if ((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 800478c:	687b      	ldr	r3, [r7, #4]
 800478e:	689b      	ldr	r3, [r3, #8]
 8004790:	2b00      	cmp	r3, #0
 8004792:	d015      	beq.n	80047c0 <HAL_RCC_OscConfig+0x358>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8004794:	f7fd fae2 	bl	8001d5c <HAL_GetTick>
 8004798:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800479a:	e00a      	b.n	80047b2 <HAL_RCC_OscConfig+0x34a>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800479c:	f7fd fade 	bl	8001d5c <HAL_GetTick>
 80047a0:	4602      	mov	r2, r0
 80047a2:	693b      	ldr	r3, [r7, #16]
 80047a4:	1ad3      	subs	r3, r2, r3
 80047a6:	f241 3288 	movw	r2, #5000	@ 0x1388
 80047aa:	4293      	cmp	r3, r2
 80047ac:	d901      	bls.n	80047b2 <HAL_RCC_OscConfig+0x34a>
        {
          return HAL_TIMEOUT;
 80047ae:	2303      	movs	r3, #3
 80047b0:	e0cb      	b.n	800494a <HAL_RCC_OscConfig+0x4e2>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80047b2:	4b49      	ldr	r3, [pc, #292]	@ (80048d8 <HAL_RCC_OscConfig+0x470>)
 80047b4:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80047b6:	f003 0302 	and.w	r3, r3, #2
 80047ba:	2b00      	cmp	r3, #0
 80047bc:	d0ee      	beq.n	800479c <HAL_RCC_OscConfig+0x334>
 80047be:	e014      	b.n	80047ea <HAL_RCC_OscConfig+0x382>
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 80047c0:	f7fd facc 	bl	8001d5c <HAL_GetTick>
 80047c4:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80047c6:	e00a      	b.n	80047de <HAL_RCC_OscConfig+0x376>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80047c8:	f7fd fac8 	bl	8001d5c <HAL_GetTick>
 80047cc:	4602      	mov	r2, r0
 80047ce:	693b      	ldr	r3, [r7, #16]
 80047d0:	1ad3      	subs	r3, r2, r3
 80047d2:	f241 3288 	movw	r2, #5000	@ 0x1388
 80047d6:	4293      	cmp	r3, r2
 80047d8:	d901      	bls.n	80047de <HAL_RCC_OscConfig+0x376>
        {
          return HAL_TIMEOUT;
 80047da:	2303      	movs	r3, #3
 80047dc:	e0b5      	b.n	800494a <HAL_RCC_OscConfig+0x4e2>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80047de:	4b3e      	ldr	r3, [pc, #248]	@ (80048d8 <HAL_RCC_OscConfig+0x470>)
 80047e0:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80047e2:	f003 0302 	and.w	r3, r3, #2
 80047e6:	2b00      	cmp	r3, #0
 80047e8:	d1ee      	bne.n	80047c8 <HAL_RCC_OscConfig+0x360>
        }
      }
    }

    /* Restore clock configuration if changed */
    if (pwrclkchanged == SET)
 80047ea:	7dfb      	ldrb	r3, [r7, #23]
 80047ec:	2b01      	cmp	r3, #1
 80047ee:	d105      	bne.n	80047fc <HAL_RCC_OscConfig+0x394>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 80047f0:	4b39      	ldr	r3, [pc, #228]	@ (80048d8 <HAL_RCC_OscConfig+0x470>)
 80047f2:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80047f4:	4a38      	ldr	r2, [pc, #224]	@ (80048d8 <HAL_RCC_OscConfig+0x470>)
 80047f6:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 80047fa:	6413      	str	r3, [r2, #64]	@ 0x40
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 80047fc:	687b      	ldr	r3, [r7, #4]
 80047fe:	699b      	ldr	r3, [r3, #24]
 8004800:	2b00      	cmp	r3, #0
 8004802:	f000 80a1 	beq.w	8004948 <HAL_RCC_OscConfig+0x4e0>
  {
    /* Check if the PLL is used as system clock or not */
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8004806:	4b34      	ldr	r3, [pc, #208]	@ (80048d8 <HAL_RCC_OscConfig+0x470>)
 8004808:	689b      	ldr	r3, [r3, #8]
 800480a:	f003 030c 	and.w	r3, r3, #12
 800480e:	2b08      	cmp	r3, #8
 8004810:	d05c      	beq.n	80048cc <HAL_RCC_OscConfig+0x464>
    {
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8004812:	687b      	ldr	r3, [r7, #4]
 8004814:	699b      	ldr	r3, [r3, #24]
 8004816:	2b02      	cmp	r3, #2
 8004818:	d141      	bne.n	800489e <HAL_RCC_OscConfig+0x436>
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800481a:	4b31      	ldr	r3, [pc, #196]	@ (80048e0 <HAL_RCC_OscConfig+0x478>)
 800481c:	2200      	movs	r2, #0
 800481e:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8004820:	f7fd fa9c 	bl	8001d5c <HAL_GetTick>
 8004824:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8004826:	e008      	b.n	800483a <HAL_RCC_OscConfig+0x3d2>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8004828:	f7fd fa98 	bl	8001d5c <HAL_GetTick>
 800482c:	4602      	mov	r2, r0
 800482e:	693b      	ldr	r3, [r7, #16]
 8004830:	1ad3      	subs	r3, r2, r3
 8004832:	2b02      	cmp	r3, #2
 8004834:	d901      	bls.n	800483a <HAL_RCC_OscConfig+0x3d2>
          {
            return HAL_TIMEOUT;
 8004836:	2303      	movs	r3, #3
 8004838:	e087      	b.n	800494a <HAL_RCC_OscConfig+0x4e2>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800483a:	4b27      	ldr	r3, [pc, #156]	@ (80048d8 <HAL_RCC_OscConfig+0x470>)
 800483c:	681b      	ldr	r3, [r3, #0]
 800483e:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8004842:	2b00      	cmp	r3, #0
 8004844:	d1f0      	bne.n	8004828 <HAL_RCC_OscConfig+0x3c0>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 8004846:	687b      	ldr	r3, [r7, #4]
 8004848:	69da      	ldr	r2, [r3, #28]
 800484a:	687b      	ldr	r3, [r7, #4]
 800484c:	6a1b      	ldr	r3, [r3, #32]
 800484e:	431a      	orrs	r2, r3
 8004850:	687b      	ldr	r3, [r7, #4]
 8004852:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8004854:	019b      	lsls	r3, r3, #6
 8004856:	431a      	orrs	r2, r3
 8004858:	687b      	ldr	r3, [r7, #4]
 800485a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800485c:	085b      	lsrs	r3, r3, #1
 800485e:	3b01      	subs	r3, #1
 8004860:	041b      	lsls	r3, r3, #16
 8004862:	431a      	orrs	r2, r3
 8004864:	687b      	ldr	r3, [r7, #4]
 8004866:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8004868:	061b      	lsls	r3, r3, #24
 800486a:	491b      	ldr	r1, [pc, #108]	@ (80048d8 <HAL_RCC_OscConfig+0x470>)
 800486c:	4313      	orrs	r3, r2
 800486e:	604b      	str	r3, [r1, #4]
                                 RCC_OscInitStruct->PLL.PLLM                                                 | \
                                 (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)             | \
                                 (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos) | \
                                 (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)));
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 8004870:	4b1b      	ldr	r3, [pc, #108]	@ (80048e0 <HAL_RCC_OscConfig+0x478>)
 8004872:	2201      	movs	r2, #1
 8004874:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8004876:	f7fd fa71 	bl	8001d5c <HAL_GetTick>
 800487a:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800487c:	e008      	b.n	8004890 <HAL_RCC_OscConfig+0x428>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800487e:	f7fd fa6d 	bl	8001d5c <HAL_GetTick>
 8004882:	4602      	mov	r2, r0
 8004884:	693b      	ldr	r3, [r7, #16]
 8004886:	1ad3      	subs	r3, r2, r3
 8004888:	2b02      	cmp	r3, #2
 800488a:	d901      	bls.n	8004890 <HAL_RCC_OscConfig+0x428>
          {
            return HAL_TIMEOUT;
 800488c:	2303      	movs	r3, #3
 800488e:	e05c      	b.n	800494a <HAL_RCC_OscConfig+0x4e2>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8004890:	4b11      	ldr	r3, [pc, #68]	@ (80048d8 <HAL_RCC_OscConfig+0x470>)
 8004892:	681b      	ldr	r3, [r3, #0]
 8004894:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8004898:	2b00      	cmp	r3, #0
 800489a:	d0f0      	beq.n	800487e <HAL_RCC_OscConfig+0x416>
 800489c:	e054      	b.n	8004948 <HAL_RCC_OscConfig+0x4e0>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800489e:	4b10      	ldr	r3, [pc, #64]	@ (80048e0 <HAL_RCC_OscConfig+0x478>)
 80048a0:	2200      	movs	r2, #0
 80048a2:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80048a4:	f7fd fa5a 	bl	8001d5c <HAL_GetTick>
 80048a8:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80048aa:	e008      	b.n	80048be <HAL_RCC_OscConfig+0x456>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80048ac:	f7fd fa56 	bl	8001d5c <HAL_GetTick>
 80048b0:	4602      	mov	r2, r0
 80048b2:	693b      	ldr	r3, [r7, #16]
 80048b4:	1ad3      	subs	r3, r2, r3
 80048b6:	2b02      	cmp	r3, #2
 80048b8:	d901      	bls.n	80048be <HAL_RCC_OscConfig+0x456>
          {
            return HAL_TIMEOUT;
 80048ba:	2303      	movs	r3, #3
 80048bc:	e045      	b.n	800494a <HAL_RCC_OscConfig+0x4e2>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80048be:	4b06      	ldr	r3, [pc, #24]	@ (80048d8 <HAL_RCC_OscConfig+0x470>)
 80048c0:	681b      	ldr	r3, [r3, #0]
 80048c2:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 80048c6:	2b00      	cmp	r3, #0
 80048c8:	d1f0      	bne.n	80048ac <HAL_RCC_OscConfig+0x444>
 80048ca:	e03d      	b.n	8004948 <HAL_RCC_OscConfig+0x4e0>
      }
    }
    else
    {
      /* Check if there is a request to disable the PLL used as System clock source */
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 80048cc:	687b      	ldr	r3, [r7, #4]
 80048ce:	699b      	ldr	r3, [r3, #24]
 80048d0:	2b01      	cmp	r3, #1
 80048d2:	d107      	bne.n	80048e4 <HAL_RCC_OscConfig+0x47c>
      {
        return HAL_ERROR;
 80048d4:	2301      	movs	r3, #1
 80048d6:	e038      	b.n	800494a <HAL_RCC_OscConfig+0x4e2>
 80048d8:	40023800 	.word	0x40023800
 80048dc:	40007000 	.word	0x40007000
 80048e0:	42470060 	.word	0x42470060
      }
      else
      {
        /* Do not return HAL_ERROR if request repeats the current configuration */
        pll_config = RCC->PLLCFGR;
 80048e4:	4b1b      	ldr	r3, [pc, #108]	@ (8004954 <HAL_RCC_OscConfig+0x4ec>)
 80048e6:	685b      	ldr	r3, [r3, #4]
 80048e8:	60fb      	str	r3, [r7, #12]
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)) ||
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLR) != (RCC_OscInitStruct->PLL.PLLR << RCC_PLLCFGR_PLLR_Pos)))
#else
        if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 80048ea:	687b      	ldr	r3, [r7, #4]
 80048ec:	699b      	ldr	r3, [r3, #24]
 80048ee:	2b01      	cmp	r3, #1
 80048f0:	d028      	beq.n	8004944 <HAL_RCC_OscConfig+0x4dc>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 80048f2:	68fb      	ldr	r3, [r7, #12]
 80048f4:	f403 0280 	and.w	r2, r3, #4194304	@ 0x400000
 80048f8:	687b      	ldr	r3, [r7, #4]
 80048fa:	69db      	ldr	r3, [r3, #28]
        if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 80048fc:	429a      	cmp	r2, r3
 80048fe:	d121      	bne.n	8004944 <HAL_RCC_OscConfig+0x4dc>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != (RCC_OscInitStruct->PLL.PLLM) << RCC_PLLCFGR_PLLM_Pos) ||
 8004900:	68fb      	ldr	r3, [r7, #12]
 8004902:	f003 023f 	and.w	r2, r3, #63	@ 0x3f
 8004906:	687b      	ldr	r3, [r7, #4]
 8004908:	6a1b      	ldr	r3, [r3, #32]
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800490a:	429a      	cmp	r2, r3
 800490c:	d11a      	bne.n	8004944 <HAL_RCC_OscConfig+0x4dc>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||
 800490e:	68fa      	ldr	r2, [r7, #12]
 8004910:	f647 73c0 	movw	r3, #32704	@ 0x7fc0
 8004914:	4013      	ands	r3, r2
 8004916:	687a      	ldr	r2, [r7, #4]
 8004918:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 800491a:	0192      	lsls	r2, r2, #6
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != (RCC_OscInitStruct->PLL.PLLM) << RCC_PLLCFGR_PLLM_Pos) ||
 800491c:	4293      	cmp	r3, r2
 800491e:	d111      	bne.n	8004944 <HAL_RCC_OscConfig+0x4dc>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||
 8004920:	68fb      	ldr	r3, [r7, #12]
 8004922:	f403 3240 	and.w	r2, r3, #196608	@ 0x30000
 8004926:	687b      	ldr	r3, [r7, #4]
 8004928:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800492a:	085b      	lsrs	r3, r3, #1
 800492c:	3b01      	subs	r3, #1
 800492e:	041b      	lsls	r3, r3, #16
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||
 8004930:	429a      	cmp	r2, r3
 8004932:	d107      	bne.n	8004944 <HAL_RCC_OscConfig+0x4dc>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)))
 8004934:	68fb      	ldr	r3, [r7, #12]
 8004936:	f003 6270 	and.w	r2, r3, #251658240	@ 0xf000000
 800493a:	687b      	ldr	r3, [r7, #4]
 800493c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800493e:	061b      	lsls	r3, r3, #24
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||
 8004940:	429a      	cmp	r2, r3
 8004942:	d001      	beq.n	8004948 <HAL_RCC_OscConfig+0x4e0>
#endif /* RCC_PLLCFGR_PLLR */
        {
          return HAL_ERROR;
 8004944:	2301      	movs	r3, #1
 8004946:	e000      	b.n	800494a <HAL_RCC_OscConfig+0x4e2>
        }
      }
    }
  }
  return HAL_OK;
 8004948:	2300      	movs	r3, #0
}
 800494a:	4618      	mov	r0, r3
 800494c:	3718      	adds	r7, #24
 800494e:	46bd      	mov	sp, r7
 8004950:	bd80      	pop	{r7, pc}
 8004952:	bf00      	nop
 8004954:	40023800 	.word	0x40023800

08004958 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8004958:	b580      	push	{r7, lr}
 800495a:	b084      	sub	sp, #16
 800495c:	af00      	add	r7, sp, #0
 800495e:	6078      	str	r0, [r7, #4]
 8004960:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;

  /* Check Null pointer */
  if (RCC_ClkInitStruct == NULL)
 8004962:	687b      	ldr	r3, [r7, #4]
 8004964:	2b00      	cmp	r3, #0
 8004966:	d101      	bne.n	800496c <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 8004968:	2301      	movs	r3, #1
 800496a:	e0cc      	b.n	8004b06 <HAL_RCC_ClockConfig+0x1ae>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 800496c:	4b68      	ldr	r3, [pc, #416]	@ (8004b10 <HAL_RCC_ClockConfig+0x1b8>)
 800496e:	681b      	ldr	r3, [r3, #0]
 8004970:	f003 0307 	and.w	r3, r3, #7
 8004974:	683a      	ldr	r2, [r7, #0]
 8004976:	429a      	cmp	r2, r3
 8004978:	d90c      	bls.n	8004994 <HAL_RCC_ClockConfig+0x3c>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800497a:	4b65      	ldr	r3, [pc, #404]	@ (8004b10 <HAL_RCC_ClockConfig+0x1b8>)
 800497c:	683a      	ldr	r2, [r7, #0]
 800497e:	b2d2      	uxtb	r2, r2
 8004980:	701a      	strb	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8004982:	4b63      	ldr	r3, [pc, #396]	@ (8004b10 <HAL_RCC_ClockConfig+0x1b8>)
 8004984:	681b      	ldr	r3, [r3, #0]
 8004986:	f003 0307 	and.w	r3, r3, #7
 800498a:	683a      	ldr	r2, [r7, #0]
 800498c:	429a      	cmp	r2, r3
 800498e:	d001      	beq.n	8004994 <HAL_RCC_ClockConfig+0x3c>
    {
      return HAL_ERROR;
 8004990:	2301      	movs	r3, #1
 8004992:	e0b8      	b.n	8004b06 <HAL_RCC_ClockConfig+0x1ae>
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8004994:	687b      	ldr	r3, [r7, #4]
 8004996:	681b      	ldr	r3, [r3, #0]
 8004998:	f003 0302 	and.w	r3, r3, #2
 800499c:	2b00      	cmp	r3, #0
 800499e:	d020      	beq.n	80049e2 <HAL_RCC_ClockConfig+0x8a>
  {
    /* Set the highest APBx dividers in order to ensure that we do not go through
       a non-spec phase whatever we decrease or increase HCLK. */
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80049a0:	687b      	ldr	r3, [r7, #4]
 80049a2:	681b      	ldr	r3, [r3, #0]
 80049a4:	f003 0304 	and.w	r3, r3, #4
 80049a8:	2b00      	cmp	r3, #0
 80049aa:	d005      	beq.n	80049b8 <HAL_RCC_ClockConfig+0x60>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 80049ac:	4b59      	ldr	r3, [pc, #356]	@ (8004b14 <HAL_RCC_ClockConfig+0x1bc>)
 80049ae:	689b      	ldr	r3, [r3, #8]
 80049b0:	4a58      	ldr	r2, [pc, #352]	@ (8004b14 <HAL_RCC_ClockConfig+0x1bc>)
 80049b2:	f443 53e0 	orr.w	r3, r3, #7168	@ 0x1c00
 80049b6:	6093      	str	r3, [r2, #8]
    }

    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80049b8:	687b      	ldr	r3, [r7, #4]
 80049ba:	681b      	ldr	r3, [r3, #0]
 80049bc:	f003 0308 	and.w	r3, r3, #8
 80049c0:	2b00      	cmp	r3, #0
 80049c2:	d005      	beq.n	80049d0 <HAL_RCC_ClockConfig+0x78>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 80049c4:	4b53      	ldr	r3, [pc, #332]	@ (8004b14 <HAL_RCC_ClockConfig+0x1bc>)
 80049c6:	689b      	ldr	r3, [r3, #8]
 80049c8:	4a52      	ldr	r2, [pc, #328]	@ (8004b14 <HAL_RCC_ClockConfig+0x1bc>)
 80049ca:	f443 4360 	orr.w	r3, r3, #57344	@ 0xe000
 80049ce:	6093      	str	r3, [r2, #8]
    }

    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 80049d0:	4b50      	ldr	r3, [pc, #320]	@ (8004b14 <HAL_RCC_ClockConfig+0x1bc>)
 80049d2:	689b      	ldr	r3, [r3, #8]
 80049d4:	f023 02f0 	bic.w	r2, r3, #240	@ 0xf0
 80049d8:	687b      	ldr	r3, [r7, #4]
 80049da:	689b      	ldr	r3, [r3, #8]
 80049dc:	494d      	ldr	r1, [pc, #308]	@ (8004b14 <HAL_RCC_ClockConfig+0x1bc>)
 80049de:	4313      	orrs	r3, r2
 80049e0:	608b      	str	r3, [r1, #8]
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 80049e2:	687b      	ldr	r3, [r7, #4]
 80049e4:	681b      	ldr	r3, [r3, #0]
 80049e6:	f003 0301 	and.w	r3, r3, #1
 80049ea:	2b00      	cmp	r3, #0
 80049ec:	d044      	beq.n	8004a78 <HAL_RCC_ClockConfig+0x120>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80049ee:	687b      	ldr	r3, [r7, #4]
 80049f0:	685b      	ldr	r3, [r3, #4]
 80049f2:	2b01      	cmp	r3, #1
 80049f4:	d107      	bne.n	8004a06 <HAL_RCC_ClockConfig+0xae>
    {
      /* Check the HSE ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80049f6:	4b47      	ldr	r3, [pc, #284]	@ (8004b14 <HAL_RCC_ClockConfig+0x1bc>)
 80049f8:	681b      	ldr	r3, [r3, #0]
 80049fa:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 80049fe:	2b00      	cmp	r3, #0
 8004a00:	d119      	bne.n	8004a36 <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 8004a02:	2301      	movs	r3, #1
 8004a04:	e07f      	b.n	8004b06 <HAL_RCC_ClockConfig+0x1ae>
      }
    }
    /* PLL is selected as System Clock Source */
    else if ((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 8004a06:	687b      	ldr	r3, [r7, #4]
 8004a08:	685b      	ldr	r3, [r3, #4]
 8004a0a:	2b02      	cmp	r3, #2
 8004a0c:	d003      	beq.n	8004a16 <HAL_RCC_ClockConfig+0xbe>
             (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
 8004a0e:	687b      	ldr	r3, [r7, #4]
 8004a10:	685b      	ldr	r3, [r3, #4]
    else if ((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 8004a12:	2b03      	cmp	r3, #3
 8004a14:	d107      	bne.n	8004a26 <HAL_RCC_ClockConfig+0xce>
    {
      /* Check the PLL ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8004a16:	4b3f      	ldr	r3, [pc, #252]	@ (8004b14 <HAL_RCC_ClockConfig+0x1bc>)
 8004a18:	681b      	ldr	r3, [r3, #0]
 8004a1a:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8004a1e:	2b00      	cmp	r3, #0
 8004a20:	d109      	bne.n	8004a36 <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 8004a22:	2301      	movs	r3, #1
 8004a24:	e06f      	b.n	8004b06 <HAL_RCC_ClockConfig+0x1ae>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8004a26:	4b3b      	ldr	r3, [pc, #236]	@ (8004b14 <HAL_RCC_ClockConfig+0x1bc>)
 8004a28:	681b      	ldr	r3, [r3, #0]
 8004a2a:	f003 0302 	and.w	r3, r3, #2
 8004a2e:	2b00      	cmp	r3, #0
 8004a30:	d101      	bne.n	8004a36 <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 8004a32:	2301      	movs	r3, #1
 8004a34:	e067      	b.n	8004b06 <HAL_RCC_ClockConfig+0x1ae>
      }
    }

    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8004a36:	4b37      	ldr	r3, [pc, #220]	@ (8004b14 <HAL_RCC_ClockConfig+0x1bc>)
 8004a38:	689b      	ldr	r3, [r3, #8]
 8004a3a:	f023 0203 	bic.w	r2, r3, #3
 8004a3e:	687b      	ldr	r3, [r7, #4]
 8004a40:	685b      	ldr	r3, [r3, #4]
 8004a42:	4934      	ldr	r1, [pc, #208]	@ (8004b14 <HAL_RCC_ClockConfig+0x1bc>)
 8004a44:	4313      	orrs	r3, r2
 8004a46:	608b      	str	r3, [r1, #8]

    /* Get Start Tick */
    tickstart = HAL_GetTick();
 8004a48:	f7fd f988 	bl	8001d5c <HAL_GetTick>
 8004a4c:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8004a4e:	e00a      	b.n	8004a66 <HAL_RCC_ClockConfig+0x10e>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8004a50:	f7fd f984 	bl	8001d5c <HAL_GetTick>
 8004a54:	4602      	mov	r2, r0
 8004a56:	68fb      	ldr	r3, [r7, #12]
 8004a58:	1ad3      	subs	r3, r2, r3
 8004a5a:	f241 3288 	movw	r2, #5000	@ 0x1388
 8004a5e:	4293      	cmp	r3, r2
 8004a60:	d901      	bls.n	8004a66 <HAL_RCC_ClockConfig+0x10e>
      {
        return HAL_TIMEOUT;
 8004a62:	2303      	movs	r3, #3
 8004a64:	e04f      	b.n	8004b06 <HAL_RCC_ClockConfig+0x1ae>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8004a66:	4b2b      	ldr	r3, [pc, #172]	@ (8004b14 <HAL_RCC_ClockConfig+0x1bc>)
 8004a68:	689b      	ldr	r3, [r3, #8]
 8004a6a:	f003 020c 	and.w	r2, r3, #12
 8004a6e:	687b      	ldr	r3, [r7, #4]
 8004a70:	685b      	ldr	r3, [r3, #4]
 8004a72:	009b      	lsls	r3, r3, #2
 8004a74:	429a      	cmp	r2, r3
 8004a76:	d1eb      	bne.n	8004a50 <HAL_RCC_ClockConfig+0xf8>
      }
    }
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8004a78:	4b25      	ldr	r3, [pc, #148]	@ (8004b10 <HAL_RCC_ClockConfig+0x1b8>)
 8004a7a:	681b      	ldr	r3, [r3, #0]
 8004a7c:	f003 0307 	and.w	r3, r3, #7
 8004a80:	683a      	ldr	r2, [r7, #0]
 8004a82:	429a      	cmp	r2, r3
 8004a84:	d20c      	bcs.n	8004aa0 <HAL_RCC_ClockConfig+0x148>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8004a86:	4b22      	ldr	r3, [pc, #136]	@ (8004b10 <HAL_RCC_ClockConfig+0x1b8>)
 8004a88:	683a      	ldr	r2, [r7, #0]
 8004a8a:	b2d2      	uxtb	r2, r2
 8004a8c:	701a      	strb	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8004a8e:	4b20      	ldr	r3, [pc, #128]	@ (8004b10 <HAL_RCC_ClockConfig+0x1b8>)
 8004a90:	681b      	ldr	r3, [r3, #0]
 8004a92:	f003 0307 	and.w	r3, r3, #7
 8004a96:	683a      	ldr	r2, [r7, #0]
 8004a98:	429a      	cmp	r2, r3
 8004a9a:	d001      	beq.n	8004aa0 <HAL_RCC_ClockConfig+0x148>
    {
      return HAL_ERROR;
 8004a9c:	2301      	movs	r3, #1
 8004a9e:	e032      	b.n	8004b06 <HAL_RCC_ClockConfig+0x1ae>
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8004aa0:	687b      	ldr	r3, [r7, #4]
 8004aa2:	681b      	ldr	r3, [r3, #0]
 8004aa4:	f003 0304 	and.w	r3, r3, #4
 8004aa8:	2b00      	cmp	r3, #0
 8004aaa:	d008      	beq.n	8004abe <HAL_RCC_ClockConfig+0x166>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8004aac:	4b19      	ldr	r3, [pc, #100]	@ (8004b14 <HAL_RCC_ClockConfig+0x1bc>)
 8004aae:	689b      	ldr	r3, [r3, #8]
 8004ab0:	f423 52e0 	bic.w	r2, r3, #7168	@ 0x1c00
 8004ab4:	687b      	ldr	r3, [r7, #4]
 8004ab6:	68db      	ldr	r3, [r3, #12]
 8004ab8:	4916      	ldr	r1, [pc, #88]	@ (8004b14 <HAL_RCC_ClockConfig+0x1bc>)
 8004aba:	4313      	orrs	r3, r2
 8004abc:	608b      	str	r3, [r1, #8]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8004abe:	687b      	ldr	r3, [r7, #4]
 8004ac0:	681b      	ldr	r3, [r3, #0]
 8004ac2:	f003 0308 	and.w	r3, r3, #8
 8004ac6:	2b00      	cmp	r3, #0
 8004ac8:	d009      	beq.n	8004ade <HAL_RCC_ClockConfig+0x186>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8004aca:	4b12      	ldr	r3, [pc, #72]	@ (8004b14 <HAL_RCC_ClockConfig+0x1bc>)
 8004acc:	689b      	ldr	r3, [r3, #8]
 8004ace:	f423 4260 	bic.w	r2, r3, #57344	@ 0xe000
 8004ad2:	687b      	ldr	r3, [r7, #4]
 8004ad4:	691b      	ldr	r3, [r3, #16]
 8004ad6:	00db      	lsls	r3, r3, #3
 8004ad8:	490e      	ldr	r1, [pc, #56]	@ (8004b14 <HAL_RCC_ClockConfig+0x1bc>)
 8004ada:	4313      	orrs	r3, r2
 8004adc:	608b      	str	r3, [r1, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 8004ade:	f000 f821 	bl	8004b24 <HAL_RCC_GetSysClockFreq>
 8004ae2:	4602      	mov	r2, r0
 8004ae4:	4b0b      	ldr	r3, [pc, #44]	@ (8004b14 <HAL_RCC_ClockConfig+0x1bc>)
 8004ae6:	689b      	ldr	r3, [r3, #8]
 8004ae8:	091b      	lsrs	r3, r3, #4
 8004aea:	f003 030f 	and.w	r3, r3, #15
 8004aee:	490a      	ldr	r1, [pc, #40]	@ (8004b18 <HAL_RCC_ClockConfig+0x1c0>)
 8004af0:	5ccb      	ldrb	r3, [r1, r3]
 8004af2:	fa22 f303 	lsr.w	r3, r2, r3
 8004af6:	4a09      	ldr	r2, [pc, #36]	@ (8004b1c <HAL_RCC_ClockConfig+0x1c4>)
 8004af8:	6013      	str	r3, [r2, #0]

  /* Configure the source of time base considering new system clocks settings */
  HAL_InitTick(uwTickPrio);
 8004afa:	4b09      	ldr	r3, [pc, #36]	@ (8004b20 <HAL_RCC_ClockConfig+0x1c8>)
 8004afc:	681b      	ldr	r3, [r3, #0]
 8004afe:	4618      	mov	r0, r3
 8004b00:	f7fd f8e8 	bl	8001cd4 <HAL_InitTick>

  return HAL_OK;
 8004b04:	2300      	movs	r3, #0
}
 8004b06:	4618      	mov	r0, r3
 8004b08:	3710      	adds	r7, #16
 8004b0a:	46bd      	mov	sp, r7
 8004b0c:	bd80      	pop	{r7, pc}
 8004b0e:	bf00      	nop
 8004b10:	40023c00 	.word	0x40023c00
 8004b14:	40023800 	.word	0x40023800
 8004b18:	08030cc4 	.word	0x08030cc4
 8004b1c:	20000018 	.word	0x20000018
 8004b20:	2000001c 	.word	0x2000001c

08004b24 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
__weak uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8004b24:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8004b28:	b094      	sub	sp, #80	@ 0x50
 8004b2a:	af00      	add	r7, sp, #0
  uint32_t pllm = 0U;
 8004b2c:	2300      	movs	r3, #0
 8004b2e:	647b      	str	r3, [r7, #68]	@ 0x44
  uint32_t pllvco = 0U;
 8004b30:	2300      	movs	r3, #0
 8004b32:	64fb      	str	r3, [r7, #76]	@ 0x4c
  uint32_t pllp = 0U;
 8004b34:	2300      	movs	r3, #0
 8004b36:	643b      	str	r3, [r7, #64]	@ 0x40
  uint32_t sysclockfreq = 0U;
 8004b38:	2300      	movs	r3, #0
 8004b3a:	64bb      	str	r3, [r7, #72]	@ 0x48

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8004b3c:	4b79      	ldr	r3, [pc, #484]	@ (8004d24 <HAL_RCC_GetSysClockFreq+0x200>)
 8004b3e:	689b      	ldr	r3, [r3, #8]
 8004b40:	f003 030c 	and.w	r3, r3, #12
 8004b44:	2b08      	cmp	r3, #8
 8004b46:	d00d      	beq.n	8004b64 <HAL_RCC_GetSysClockFreq+0x40>
 8004b48:	2b08      	cmp	r3, #8
 8004b4a:	f200 80e1 	bhi.w	8004d10 <HAL_RCC_GetSysClockFreq+0x1ec>
 8004b4e:	2b00      	cmp	r3, #0
 8004b50:	d002      	beq.n	8004b58 <HAL_RCC_GetSysClockFreq+0x34>
 8004b52:	2b04      	cmp	r3, #4
 8004b54:	d003      	beq.n	8004b5e <HAL_RCC_GetSysClockFreq+0x3a>
 8004b56:	e0db      	b.n	8004d10 <HAL_RCC_GetSysClockFreq+0x1ec>
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 8004b58:	4b73      	ldr	r3, [pc, #460]	@ (8004d28 <HAL_RCC_GetSysClockFreq+0x204>)
 8004b5a:	64bb      	str	r3, [r7, #72]	@ 0x48
      break;
 8004b5c:	e0db      	b.n	8004d16 <HAL_RCC_GetSysClockFreq+0x1f2>
    }
    case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    {
      sysclockfreq = HSE_VALUE;
 8004b5e:	4b73      	ldr	r3, [pc, #460]	@ (8004d2c <HAL_RCC_GetSysClockFreq+0x208>)
 8004b60:	64bb      	str	r3, [r7, #72]	@ 0x48
      break;
 8004b62:	e0d8      	b.n	8004d16 <HAL_RCC_GetSysClockFreq+0x1f2>
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8004b64:	4b6f      	ldr	r3, [pc, #444]	@ (8004d24 <HAL_RCC_GetSysClockFreq+0x200>)
 8004b66:	685b      	ldr	r3, [r3, #4]
 8004b68:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 8004b6c:	647b      	str	r3, [r7, #68]	@ 0x44
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8004b6e:	4b6d      	ldr	r3, [pc, #436]	@ (8004d24 <HAL_RCC_GetSysClockFreq+0x200>)
 8004b70:	685b      	ldr	r3, [r3, #4]
 8004b72:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 8004b76:	2b00      	cmp	r3, #0
 8004b78:	d063      	beq.n	8004c42 <HAL_RCC_GetSysClockFreq+0x11e>
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t)((((uint64_t) HSE_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8004b7a:	4b6a      	ldr	r3, [pc, #424]	@ (8004d24 <HAL_RCC_GetSysClockFreq+0x200>)
 8004b7c:	685b      	ldr	r3, [r3, #4]
 8004b7e:	099b      	lsrs	r3, r3, #6
 8004b80:	2200      	movs	r2, #0
 8004b82:	63bb      	str	r3, [r7, #56]	@ 0x38
 8004b84:	63fa      	str	r2, [r7, #60]	@ 0x3c
 8004b86:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8004b88:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8004b8c:	633b      	str	r3, [r7, #48]	@ 0x30
 8004b8e:	2300      	movs	r3, #0
 8004b90:	637b      	str	r3, [r7, #52]	@ 0x34
 8004b92:	e9d7 450c 	ldrd	r4, r5, [r7, #48]	@ 0x30
 8004b96:	4622      	mov	r2, r4
 8004b98:	462b      	mov	r3, r5
 8004b9a:	f04f 0000 	mov.w	r0, #0
 8004b9e:	f04f 0100 	mov.w	r1, #0
 8004ba2:	0159      	lsls	r1, r3, #5
 8004ba4:	ea41 61d2 	orr.w	r1, r1, r2, lsr #27
 8004ba8:	0150      	lsls	r0, r2, #5
 8004baa:	4602      	mov	r2, r0
 8004bac:	460b      	mov	r3, r1
 8004bae:	4621      	mov	r1, r4
 8004bb0:	1a51      	subs	r1, r2, r1
 8004bb2:	6139      	str	r1, [r7, #16]
 8004bb4:	4629      	mov	r1, r5
 8004bb6:	eb63 0301 	sbc.w	r3, r3, r1
 8004bba:	617b      	str	r3, [r7, #20]
 8004bbc:	f04f 0200 	mov.w	r2, #0
 8004bc0:	f04f 0300 	mov.w	r3, #0
 8004bc4:	e9d7 ab04 	ldrd	sl, fp, [r7, #16]
 8004bc8:	4659      	mov	r1, fp
 8004bca:	018b      	lsls	r3, r1, #6
 8004bcc:	4651      	mov	r1, sl
 8004bce:	ea43 6391 	orr.w	r3, r3, r1, lsr #26
 8004bd2:	4651      	mov	r1, sl
 8004bd4:	018a      	lsls	r2, r1, #6
 8004bd6:	4651      	mov	r1, sl
 8004bd8:	ebb2 0801 	subs.w	r8, r2, r1
 8004bdc:	4659      	mov	r1, fp
 8004bde:	eb63 0901 	sbc.w	r9, r3, r1
 8004be2:	f04f 0200 	mov.w	r2, #0
 8004be6:	f04f 0300 	mov.w	r3, #0
 8004bea:	ea4f 03c9 	mov.w	r3, r9, lsl #3
 8004bee:	ea43 7358 	orr.w	r3, r3, r8, lsr #29
 8004bf2:	ea4f 02c8 	mov.w	r2, r8, lsl #3
 8004bf6:	4690      	mov	r8, r2
 8004bf8:	4699      	mov	r9, r3
 8004bfa:	4623      	mov	r3, r4
 8004bfc:	eb18 0303 	adds.w	r3, r8, r3
 8004c00:	60bb      	str	r3, [r7, #8]
 8004c02:	462b      	mov	r3, r5
 8004c04:	eb49 0303 	adc.w	r3, r9, r3
 8004c08:	60fb      	str	r3, [r7, #12]
 8004c0a:	f04f 0200 	mov.w	r2, #0
 8004c0e:	f04f 0300 	mov.w	r3, #0
 8004c12:	e9d7 4502 	ldrd	r4, r5, [r7, #8]
 8004c16:	4629      	mov	r1, r5
 8004c18:	024b      	lsls	r3, r1, #9
 8004c1a:	4621      	mov	r1, r4
 8004c1c:	ea43 53d1 	orr.w	r3, r3, r1, lsr #23
 8004c20:	4621      	mov	r1, r4
 8004c22:	024a      	lsls	r2, r1, #9
 8004c24:	4610      	mov	r0, r2
 8004c26:	4619      	mov	r1, r3
 8004c28:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8004c2a:	2200      	movs	r2, #0
 8004c2c:	62bb      	str	r3, [r7, #40]	@ 0x28
 8004c2e:	62fa      	str	r2, [r7, #44]	@ 0x2c
 8004c30:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	@ 0x28
 8004c34:	f7fb fb34 	bl	80002a0 <__aeabi_uldivmod>
 8004c38:	4602      	mov	r2, r0
 8004c3a:	460b      	mov	r3, r1
 8004c3c:	4613      	mov	r3, r2
 8004c3e:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8004c40:	e058      	b.n	8004cf4 <HAL_RCC_GetSysClockFreq+0x1d0>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t)((((uint64_t) HSI_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8004c42:	4b38      	ldr	r3, [pc, #224]	@ (8004d24 <HAL_RCC_GetSysClockFreq+0x200>)
 8004c44:	685b      	ldr	r3, [r3, #4]
 8004c46:	099b      	lsrs	r3, r3, #6
 8004c48:	2200      	movs	r2, #0
 8004c4a:	4618      	mov	r0, r3
 8004c4c:	4611      	mov	r1, r2
 8004c4e:	f3c0 0308 	ubfx	r3, r0, #0, #9
 8004c52:	623b      	str	r3, [r7, #32]
 8004c54:	2300      	movs	r3, #0
 8004c56:	627b      	str	r3, [r7, #36]	@ 0x24
 8004c58:	e9d7 8908 	ldrd	r8, r9, [r7, #32]
 8004c5c:	4642      	mov	r2, r8
 8004c5e:	464b      	mov	r3, r9
 8004c60:	f04f 0000 	mov.w	r0, #0
 8004c64:	f04f 0100 	mov.w	r1, #0
 8004c68:	0159      	lsls	r1, r3, #5
 8004c6a:	ea41 61d2 	orr.w	r1, r1, r2, lsr #27
 8004c6e:	0150      	lsls	r0, r2, #5
 8004c70:	4602      	mov	r2, r0
 8004c72:	460b      	mov	r3, r1
 8004c74:	4641      	mov	r1, r8
 8004c76:	ebb2 0a01 	subs.w	sl, r2, r1
 8004c7a:	4649      	mov	r1, r9
 8004c7c:	eb63 0b01 	sbc.w	fp, r3, r1
 8004c80:	f04f 0200 	mov.w	r2, #0
 8004c84:	f04f 0300 	mov.w	r3, #0
 8004c88:	ea4f 138b 	mov.w	r3, fp, lsl #6
 8004c8c:	ea43 639a 	orr.w	r3, r3, sl, lsr #26
 8004c90:	ea4f 128a 	mov.w	r2, sl, lsl #6
 8004c94:	ebb2 040a 	subs.w	r4, r2, sl
 8004c98:	eb63 050b 	sbc.w	r5, r3, fp
 8004c9c:	f04f 0200 	mov.w	r2, #0
 8004ca0:	f04f 0300 	mov.w	r3, #0
 8004ca4:	00eb      	lsls	r3, r5, #3
 8004ca6:	ea43 7354 	orr.w	r3, r3, r4, lsr #29
 8004caa:	00e2      	lsls	r2, r4, #3
 8004cac:	4614      	mov	r4, r2
 8004cae:	461d      	mov	r5, r3
 8004cb0:	4643      	mov	r3, r8
 8004cb2:	18e3      	adds	r3, r4, r3
 8004cb4:	603b      	str	r3, [r7, #0]
 8004cb6:	464b      	mov	r3, r9
 8004cb8:	eb45 0303 	adc.w	r3, r5, r3
 8004cbc:	607b      	str	r3, [r7, #4]
 8004cbe:	f04f 0200 	mov.w	r2, #0
 8004cc2:	f04f 0300 	mov.w	r3, #0
 8004cc6:	e9d7 4500 	ldrd	r4, r5, [r7]
 8004cca:	4629      	mov	r1, r5
 8004ccc:	028b      	lsls	r3, r1, #10
 8004cce:	4621      	mov	r1, r4
 8004cd0:	ea43 5391 	orr.w	r3, r3, r1, lsr #22
 8004cd4:	4621      	mov	r1, r4
 8004cd6:	028a      	lsls	r2, r1, #10
 8004cd8:	4610      	mov	r0, r2
 8004cda:	4619      	mov	r1, r3
 8004cdc:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8004cde:	2200      	movs	r2, #0
 8004ce0:	61bb      	str	r3, [r7, #24]
 8004ce2:	61fa      	str	r2, [r7, #28]
 8004ce4:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 8004ce8:	f7fb fada 	bl	80002a0 <__aeabi_uldivmod>
 8004cec:	4602      	mov	r2, r0
 8004cee:	460b      	mov	r3, r1
 8004cf0:	4613      	mov	r3, r2
 8004cf2:	64fb      	str	r3, [r7, #76]	@ 0x4c
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) * 2U);
 8004cf4:	4b0b      	ldr	r3, [pc, #44]	@ (8004d24 <HAL_RCC_GetSysClockFreq+0x200>)
 8004cf6:	685b      	ldr	r3, [r3, #4]
 8004cf8:	0c1b      	lsrs	r3, r3, #16
 8004cfa:	f003 0303 	and.w	r3, r3, #3
 8004cfe:	3301      	adds	r3, #1
 8004d00:	005b      	lsls	r3, r3, #1
 8004d02:	643b      	str	r3, [r7, #64]	@ 0x40

      sysclockfreq = pllvco / pllp;
 8004d04:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8004d06:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8004d08:	fbb2 f3f3 	udiv	r3, r2, r3
 8004d0c:	64bb      	str	r3, [r7, #72]	@ 0x48
      break;
 8004d0e:	e002      	b.n	8004d16 <HAL_RCC_GetSysClockFreq+0x1f2>
    }
    default:
    {
      sysclockfreq = HSI_VALUE;
 8004d10:	4b05      	ldr	r3, [pc, #20]	@ (8004d28 <HAL_RCC_GetSysClockFreq+0x204>)
 8004d12:	64bb      	str	r3, [r7, #72]	@ 0x48
      break;
 8004d14:	bf00      	nop
    }
  }
  return sysclockfreq;
 8004d16:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
}
 8004d18:	4618      	mov	r0, r3
 8004d1a:	3750      	adds	r7, #80	@ 0x50
 8004d1c:	46bd      	mov	sp, r7
 8004d1e:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 8004d22:	bf00      	nop
 8004d24:	40023800 	.word	0x40023800
 8004d28:	00f42400 	.word	0x00f42400
 8004d2c:	007a1200 	.word	0x007a1200

08004d30 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 8004d30:	b480      	push	{r7}
 8004d32:	af00      	add	r7, sp, #0
  return SystemCoreClock;
 8004d34:	4b03      	ldr	r3, [pc, #12]	@ (8004d44 <HAL_RCC_GetHCLKFreq+0x14>)
 8004d36:	681b      	ldr	r3, [r3, #0]
}
 8004d38:	4618      	mov	r0, r3
 8004d3a:	46bd      	mov	sp, r7
 8004d3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004d40:	4770      	bx	lr
 8004d42:	bf00      	nop
 8004d44:	20000018 	.word	0x20000018

08004d48 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 8004d48:	b580      	push	{r7, lr}
 8004d4a:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 8004d4c:	f7ff fff0 	bl	8004d30 <HAL_RCC_GetHCLKFreq>
 8004d50:	4602      	mov	r2, r0
 8004d52:	4b05      	ldr	r3, [pc, #20]	@ (8004d68 <HAL_RCC_GetPCLK1Freq+0x20>)
 8004d54:	689b      	ldr	r3, [r3, #8]
 8004d56:	0a9b      	lsrs	r3, r3, #10
 8004d58:	f003 0307 	and.w	r3, r3, #7
 8004d5c:	4903      	ldr	r1, [pc, #12]	@ (8004d6c <HAL_RCC_GetPCLK1Freq+0x24>)
 8004d5e:	5ccb      	ldrb	r3, [r1, r3]
 8004d60:	fa22 f303 	lsr.w	r3, r2, r3
}
 8004d64:	4618      	mov	r0, r3
 8004d66:	bd80      	pop	{r7, pc}
 8004d68:	40023800 	.word	0x40023800
 8004d6c:	08030cd4 	.word	0x08030cd4

08004d70 <HAL_RCCEx_PeriphCLKConfig>:
  *        domain (RTC and RCC_BDCR register expect BKPSRAM) will be reset
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8004d70:	b580      	push	{r7, lr}
 8004d72:	b086      	sub	sp, #24
 8004d74:	af00      	add	r7, sp, #0
 8004d76:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0U;
 8004d78:	2300      	movs	r3, #0
 8004d7a:	617b      	str	r3, [r7, #20]
  uint32_t tmpreg1 = 0U;
 8004d7c:	2300      	movs	r3, #0
 8004d7e:	613b      	str	r3, [r7, #16]

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*---------------------------- I2S configuration ---------------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) ||
 8004d80:	687b      	ldr	r3, [r7, #4]
 8004d82:	681b      	ldr	r3, [r3, #0]
 8004d84:	f003 0301 	and.w	r3, r3, #1
 8004d88:	2b00      	cmp	r3, #0
 8004d8a:	d105      	bne.n	8004d98 <HAL_RCCEx_PeriphCLKConfig+0x28>
      (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S))
 8004d8c:	687b      	ldr	r3, [r7, #4]
 8004d8e:	681b      	ldr	r3, [r3, #0]
 8004d90:	f003 0304 	and.w	r3, r3, #4
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) ||
 8004d94:	2b00      	cmp	r3, #0
 8004d96:	d035      	beq.n	8004e04 <HAL_RCCEx_PeriphCLKConfig+0x94>
    assert_param(IS_RCC_PLLI2SN_VALUE(PeriphClkInit->PLLI2S.PLLI2SN));
#if defined(STM32F411xE)
    assert_param(IS_RCC_PLLI2SM_VALUE(PeriphClkInit->PLLI2S.PLLI2SM));
#endif /* STM32F411xE */
    /* Disable the PLLI2S */
    __HAL_RCC_PLLI2S_DISABLE();
 8004d98:	4b62      	ldr	r3, [pc, #392]	@ (8004f24 <HAL_RCCEx_PeriphCLKConfig+0x1b4>)
 8004d9a:	2200      	movs	r2, #0
 8004d9c:	601a      	str	r2, [r3, #0]
    /* Get tick */
    tickstart = HAL_GetTick();
 8004d9e:	f7fc ffdd 	bl	8001d5c <HAL_GetTick>
 8004da2:	6178      	str	r0, [r7, #20]
    /* Wait till PLLI2S is disabled */
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8004da4:	e008      	b.n	8004db8 <HAL_RCCEx_PeriphCLKConfig+0x48>
    {
      if ((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
 8004da6:	f7fc ffd9 	bl	8001d5c <HAL_GetTick>
 8004daa:	4602      	mov	r2, r0
 8004dac:	697b      	ldr	r3, [r7, #20]
 8004dae:	1ad3      	subs	r3, r2, r3
 8004db0:	2b02      	cmp	r3, #2
 8004db2:	d901      	bls.n	8004db8 <HAL_RCCEx_PeriphCLKConfig+0x48>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
 8004db4:	2303      	movs	r3, #3
 8004db6:	e0b0      	b.n	8004f1a <HAL_RCCEx_PeriphCLKConfig+0x1aa>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8004db8:	4b5b      	ldr	r3, [pc, #364]	@ (8004f28 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004dba:	681b      	ldr	r3, [r3, #0]
 8004dbc:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8004dc0:	2b00      	cmp	r3, #0
 8004dc2:	d1f0      	bne.n	8004da6 <HAL_RCCEx_PeriphCLKConfig+0x36>
                                   PeriphClkInit->PLLI2S.PLLI2SR);
#else
    /* Configure the PLLI2S division factors */
    /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * (PLLI2SN/PLLM) */
    /* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */
    __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN, PeriphClkInit->PLLI2S.PLLI2SR);
 8004dc4:	687b      	ldr	r3, [r7, #4]
 8004dc6:	685b      	ldr	r3, [r3, #4]
 8004dc8:	019a      	lsls	r2, r3, #6
 8004dca:	687b      	ldr	r3, [r7, #4]
 8004dcc:	689b      	ldr	r3, [r3, #8]
 8004dce:	071b      	lsls	r3, r3, #28
 8004dd0:	4955      	ldr	r1, [pc, #340]	@ (8004f28 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004dd2:	4313      	orrs	r3, r2
 8004dd4:	f8c1 3084 	str.w	r3, [r1, #132]	@ 0x84
#endif /* STM32F411xE */

    /* Enable the PLLI2S */
    __HAL_RCC_PLLI2S_ENABLE();
 8004dd8:	4b52      	ldr	r3, [pc, #328]	@ (8004f24 <HAL_RCCEx_PeriphCLKConfig+0x1b4>)
 8004dda:	2201      	movs	r2, #1
 8004ddc:	601a      	str	r2, [r3, #0]
    /* Get tick */
    tickstart = HAL_GetTick();
 8004dde:	f7fc ffbd 	bl	8001d5c <HAL_GetTick>
 8004de2:	6178      	str	r0, [r7, #20]
    /* Wait till PLLI2S is ready */
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8004de4:	e008      	b.n	8004df8 <HAL_RCCEx_PeriphCLKConfig+0x88>
    {
      if ((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
 8004de6:	f7fc ffb9 	bl	8001d5c <HAL_GetTick>
 8004dea:	4602      	mov	r2, r0
 8004dec:	697b      	ldr	r3, [r7, #20]
 8004dee:	1ad3      	subs	r3, r2, r3
 8004df0:	2b02      	cmp	r3, #2
 8004df2:	d901      	bls.n	8004df8 <HAL_RCCEx_PeriphCLKConfig+0x88>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
 8004df4:	2303      	movs	r3, #3
 8004df6:	e090      	b.n	8004f1a <HAL_RCCEx_PeriphCLKConfig+0x1aa>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8004df8:	4b4b      	ldr	r3, [pc, #300]	@ (8004f28 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004dfa:	681b      	ldr	r3, [r3, #0]
 8004dfc:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8004e00:	2b00      	cmp	r3, #0
 8004e02:	d0f0      	beq.n	8004de6 <HAL_RCCEx_PeriphCLKConfig+0x76>
      }
    }
  }

  /*---------------------------- RTC configuration ---------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 8004e04:	687b      	ldr	r3, [r7, #4]
 8004e06:	681b      	ldr	r3, [r3, #0]
 8004e08:	f003 0302 	and.w	r3, r3, #2
 8004e0c:	2b00      	cmp	r3, #0
 8004e0e:	f000 8083 	beq.w	8004f18 <HAL_RCCEx_PeriphCLKConfig+0x1a8>
  {
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 8004e12:	2300      	movs	r3, #0
 8004e14:	60fb      	str	r3, [r7, #12]
 8004e16:	4b44      	ldr	r3, [pc, #272]	@ (8004f28 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004e18:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8004e1a:	4a43      	ldr	r2, [pc, #268]	@ (8004f28 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004e1c:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8004e20:	6413      	str	r3, [r2, #64]	@ 0x40
 8004e22:	4b41      	ldr	r3, [pc, #260]	@ (8004f28 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004e24:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8004e26:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8004e2a:	60fb      	str	r3, [r7, #12]
 8004e2c:	68fb      	ldr	r3, [r7, #12]

    /* Enable write access to Backup domain */
    PWR->CR |= PWR_CR_DBP;
 8004e2e:	4b3f      	ldr	r3, [pc, #252]	@ (8004f2c <HAL_RCCEx_PeriphCLKConfig+0x1bc>)
 8004e30:	681b      	ldr	r3, [r3, #0]
 8004e32:	4a3e      	ldr	r2, [pc, #248]	@ (8004f2c <HAL_RCCEx_PeriphCLKConfig+0x1bc>)
 8004e34:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8004e38:	6013      	str	r3, [r2, #0]

    /* Get tick */
    tickstart = HAL_GetTick();
 8004e3a:	f7fc ff8f 	bl	8001d5c <HAL_GetTick>
 8004e3e:	6178      	str	r0, [r7, #20]

    while ((PWR->CR & PWR_CR_DBP) == RESET)
 8004e40:	e008      	b.n	8004e54 <HAL_RCCEx_PeriphCLKConfig+0xe4>
    {
      if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8004e42:	f7fc ff8b 	bl	8001d5c <HAL_GetTick>
 8004e46:	4602      	mov	r2, r0
 8004e48:	697b      	ldr	r3, [r7, #20]
 8004e4a:	1ad3      	subs	r3, r2, r3
 8004e4c:	2b02      	cmp	r3, #2
 8004e4e:	d901      	bls.n	8004e54 <HAL_RCCEx_PeriphCLKConfig+0xe4>
      {
        return HAL_TIMEOUT;
 8004e50:	2303      	movs	r3, #3
 8004e52:	e062      	b.n	8004f1a <HAL_RCCEx_PeriphCLKConfig+0x1aa>
    while ((PWR->CR & PWR_CR_DBP) == RESET)
 8004e54:	4b35      	ldr	r3, [pc, #212]	@ (8004f2c <HAL_RCCEx_PeriphCLKConfig+0x1bc>)
 8004e56:	681b      	ldr	r3, [r3, #0]
 8004e58:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8004e5c:	2b00      	cmp	r3, #0
 8004e5e:	d0f0      	beq.n	8004e42 <HAL_RCCEx_PeriphCLKConfig+0xd2>
      }
    }
    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */
    tmpreg1 = (RCC->BDCR & RCC_BDCR_RTCSEL);
 8004e60:	4b31      	ldr	r3, [pc, #196]	@ (8004f28 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004e62:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8004e64:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8004e68:	613b      	str	r3, [r7, #16]
    if ((tmpreg1 != 0x00000000U) && ((tmpreg1) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 8004e6a:	693b      	ldr	r3, [r7, #16]
 8004e6c:	2b00      	cmp	r3, #0
 8004e6e:	d02f      	beq.n	8004ed0 <HAL_RCCEx_PeriphCLKConfig+0x160>
 8004e70:	687b      	ldr	r3, [r7, #4]
 8004e72:	68db      	ldr	r3, [r3, #12]
 8004e74:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8004e78:	693a      	ldr	r2, [r7, #16]
 8004e7a:	429a      	cmp	r2, r3
 8004e7c:	d028      	beq.n	8004ed0 <HAL_RCCEx_PeriphCLKConfig+0x160>
    {
      /* Store the content of BDCR register before the reset of Backup Domain */
      tmpreg1 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8004e7e:	4b2a      	ldr	r3, [pc, #168]	@ (8004f28 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004e80:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8004e82:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 8004e86:	613b      	str	r3, [r7, #16]
      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
 8004e88:	4b29      	ldr	r3, [pc, #164]	@ (8004f30 <HAL_RCCEx_PeriphCLKConfig+0x1c0>)
 8004e8a:	2201      	movs	r2, #1
 8004e8c:	601a      	str	r2, [r3, #0]
      __HAL_RCC_BACKUPRESET_RELEASE();
 8004e8e:	4b28      	ldr	r3, [pc, #160]	@ (8004f30 <HAL_RCCEx_PeriphCLKConfig+0x1c0>)
 8004e90:	2200      	movs	r2, #0
 8004e92:	601a      	str	r2, [r3, #0]
      /* Restore the Content of BDCR register */
      RCC->BDCR = tmpreg1;
 8004e94:	4a24      	ldr	r2, [pc, #144]	@ (8004f28 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004e96:	693b      	ldr	r3, [r7, #16]
 8004e98:	6713      	str	r3, [r2, #112]	@ 0x70

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
 8004e9a:	4b23      	ldr	r3, [pc, #140]	@ (8004f28 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004e9c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8004e9e:	f003 0301 	and.w	r3, r3, #1
 8004ea2:	2b01      	cmp	r3, #1
 8004ea4:	d114      	bne.n	8004ed0 <HAL_RCCEx_PeriphCLKConfig+0x160>
      {
        /* Get tick */
        tickstart = HAL_GetTick();
 8004ea6:	f7fc ff59 	bl	8001d5c <HAL_GetTick>
 8004eaa:	6178      	str	r0, [r7, #20]

        /* Wait till LSE is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8004eac:	e00a      	b.n	8004ec4 <HAL_RCCEx_PeriphCLKConfig+0x154>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8004eae:	f7fc ff55 	bl	8001d5c <HAL_GetTick>
 8004eb2:	4602      	mov	r2, r0
 8004eb4:	697b      	ldr	r3, [r7, #20]
 8004eb6:	1ad3      	subs	r3, r2, r3
 8004eb8:	f241 3288 	movw	r2, #5000	@ 0x1388
 8004ebc:	4293      	cmp	r3, r2
 8004ebe:	d901      	bls.n	8004ec4 <HAL_RCCEx_PeriphCLKConfig+0x154>
          {
            return HAL_TIMEOUT;
 8004ec0:	2303      	movs	r3, #3
 8004ec2:	e02a      	b.n	8004f1a <HAL_RCCEx_PeriphCLKConfig+0x1aa>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8004ec4:	4b18      	ldr	r3, [pc, #96]	@ (8004f28 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004ec6:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8004ec8:	f003 0302 	and.w	r3, r3, #2
 8004ecc:	2b00      	cmp	r3, #0
 8004ece:	d0ee      	beq.n	8004eae <HAL_RCCEx_PeriphCLKConfig+0x13e>
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8004ed0:	687b      	ldr	r3, [r7, #4]
 8004ed2:	68db      	ldr	r3, [r3, #12]
 8004ed4:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8004ed8:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 8004edc:	d10d      	bne.n	8004efa <HAL_RCCEx_PeriphCLKConfig+0x18a>
 8004ede:	4b12      	ldr	r3, [pc, #72]	@ (8004f28 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004ee0:	689b      	ldr	r3, [r3, #8]
 8004ee2:	f423 12f8 	bic.w	r2, r3, #2031616	@ 0x1f0000
 8004ee6:	687b      	ldr	r3, [r7, #4]
 8004ee8:	68db      	ldr	r3, [r3, #12]
 8004eea:	f023 4370 	bic.w	r3, r3, #4026531840	@ 0xf0000000
 8004eee:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 8004ef2:	490d      	ldr	r1, [pc, #52]	@ (8004f28 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004ef4:	4313      	orrs	r3, r2
 8004ef6:	608b      	str	r3, [r1, #8]
 8004ef8:	e005      	b.n	8004f06 <HAL_RCCEx_PeriphCLKConfig+0x196>
 8004efa:	4b0b      	ldr	r3, [pc, #44]	@ (8004f28 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004efc:	689b      	ldr	r3, [r3, #8]
 8004efe:	4a0a      	ldr	r2, [pc, #40]	@ (8004f28 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004f00:	f423 13f8 	bic.w	r3, r3, #2031616	@ 0x1f0000
 8004f04:	6093      	str	r3, [r2, #8]
 8004f06:	4b08      	ldr	r3, [pc, #32]	@ (8004f28 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004f08:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
 8004f0a:	687b      	ldr	r3, [r7, #4]
 8004f0c:	68db      	ldr	r3, [r3, #12]
 8004f0e:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8004f12:	4905      	ldr	r1, [pc, #20]	@ (8004f28 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004f14:	4313      	orrs	r3, r2
 8004f16:	670b      	str	r3, [r1, #112]	@ 0x70
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
  {
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
  }
#endif /* STM32F401xC || STM32F401xE || STM32F411xE */
  return HAL_OK;
 8004f18:	2300      	movs	r3, #0
}
 8004f1a:	4618      	mov	r0, r3
 8004f1c:	3718      	adds	r7, #24
 8004f1e:	46bd      	mov	sp, r7
 8004f20:	bd80      	pop	{r7, pc}
 8004f22:	bf00      	nop
 8004f24:	42470068 	.word	0x42470068
 8004f28:	40023800 	.word	0x40023800
 8004f2c:	40007000 	.word	0x40007000
 8004f30:	42470e40 	.word	0x42470e40

08004f34 <HAL_RCCEx_GetPeriphCLKFreq>:
  *         This parameter can be one of the following values:
  *            @arg RCC_PERIPHCLK_I2S: I2S peripheral clock
  * @retval Frequency in KHz
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
{
 8004f34:	b480      	push	{r7}
 8004f36:	b087      	sub	sp, #28
 8004f38:	af00      	add	r7, sp, #0
 8004f3a:	6078      	str	r0, [r7, #4]
  /* This variable used to store the I2S clock frequency (value in Hz) */
  uint32_t frequency = 0U;
 8004f3c:	2300      	movs	r3, #0
 8004f3e:	617b      	str	r3, [r7, #20]
  /* This variable used to store the VCO Input (value in Hz) */
  uint32_t vcoinput = 0U;
 8004f40:	2300      	movs	r3, #0
 8004f42:	613b      	str	r3, [r7, #16]
  uint32_t srcclk = 0U;
 8004f44:	2300      	movs	r3, #0
 8004f46:	60fb      	str	r3, [r7, #12]
  /* This variable used to store the VCO Output (value in Hz) */
  uint32_t vcooutput = 0U;
 8004f48:	2300      	movs	r3, #0
 8004f4a:	60bb      	str	r3, [r7, #8]
  switch (PeriphClk)
 8004f4c:	687b      	ldr	r3, [r7, #4]
 8004f4e:	2b01      	cmp	r3, #1
 8004f50:	d13f      	bne.n	8004fd2 <HAL_RCCEx_GetPeriphCLKFreq+0x9e>
  {
    case RCC_PERIPHCLK_I2S:
    {
      /* Get the current I2S source */
      srcclk = __HAL_RCC_GET_I2S_SOURCE();
 8004f52:	4b24      	ldr	r3, [pc, #144]	@ (8004fe4 <HAL_RCCEx_GetPeriphCLKFreq+0xb0>)
 8004f54:	689b      	ldr	r3, [r3, #8]
 8004f56:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8004f5a:	60fb      	str	r3, [r7, #12]
      switch (srcclk)
 8004f5c:	68fb      	ldr	r3, [r7, #12]
 8004f5e:	2b00      	cmp	r3, #0
 8004f60:	d006      	beq.n	8004f70 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
 8004f62:	68fb      	ldr	r3, [r7, #12]
 8004f64:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
 8004f68:	d12f      	bne.n	8004fca <HAL_RCCEx_GetPeriphCLKFreq+0x96>
      {
        /* Check if I2S clock selection is External clock mapped on the I2S_CKIN pin used as I2S clock */
        case RCC_I2SCLKSOURCE_EXT:
        {
          /* Set the I2S clock to the external clock  value */
          frequency = EXTERNAL_CLOCK_VALUE;
 8004f6a:	4b1f      	ldr	r3, [pc, #124]	@ (8004fe8 <HAL_RCCEx_GetPeriphCLKFreq+0xb4>)
 8004f6c:	617b      	str	r3, [r7, #20]
          break;
 8004f6e:	e02f      	b.n	8004fd0 <HAL_RCCEx_GetPeriphCLKFreq+0x9c>
            vcoinput = (uint32_t)(HSI_VALUE / (uint32_t)(RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SM));
          }
#else
          /* Configure the PLLI2S division factor */
          /* PLLI2S_VCO Input  = PLL_SOURCE/PLLM */
          if ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSE)
 8004f70:	4b1c      	ldr	r3, [pc, #112]	@ (8004fe4 <HAL_RCCEx_GetPeriphCLKFreq+0xb0>)
 8004f72:	685b      	ldr	r3, [r3, #4]
 8004f74:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 8004f78:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 8004f7c:	d108      	bne.n	8004f90 <HAL_RCCEx_GetPeriphCLKFreq+0x5c>
          {
            /* Get the I2S source clock value */
            vcoinput = (uint32_t)(HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
 8004f7e:	4b19      	ldr	r3, [pc, #100]	@ (8004fe4 <HAL_RCCEx_GetPeriphCLKFreq+0xb0>)
 8004f80:	685b      	ldr	r3, [r3, #4]
 8004f82:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 8004f86:	4a19      	ldr	r2, [pc, #100]	@ (8004fec <HAL_RCCEx_GetPeriphCLKFreq+0xb8>)
 8004f88:	fbb2 f3f3 	udiv	r3, r2, r3
 8004f8c:	613b      	str	r3, [r7, #16]
 8004f8e:	e007      	b.n	8004fa0 <HAL_RCCEx_GetPeriphCLKFreq+0x6c>
          }
          else
          {
            /* Get the I2S source clock value */
            vcoinput = (uint32_t)(HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
 8004f90:	4b14      	ldr	r3, [pc, #80]	@ (8004fe4 <HAL_RCCEx_GetPeriphCLKFreq+0xb0>)
 8004f92:	685b      	ldr	r3, [r3, #4]
 8004f94:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 8004f98:	4a15      	ldr	r2, [pc, #84]	@ (8004ff0 <HAL_RCCEx_GetPeriphCLKFreq+0xbc>)
 8004f9a:	fbb2 f3f3 	udiv	r3, r2, r3
 8004f9e:	613b      	str	r3, [r7, #16]
          }
#endif /* STM32F411xE */
          /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */
          vcooutput = (uint32_t)(vcoinput * (((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6U) & (RCC_PLLI2SCFGR_PLLI2SN >> 6U)));
 8004fa0:	4b10      	ldr	r3, [pc, #64]	@ (8004fe4 <HAL_RCCEx_GetPeriphCLKFreq+0xb0>)
 8004fa2:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 8004fa6:	099b      	lsrs	r3, r3, #6
 8004fa8:	f3c3 0208 	ubfx	r2, r3, #0, #9
 8004fac:	693b      	ldr	r3, [r7, #16]
 8004fae:	fb02 f303 	mul.w	r3, r2, r3
 8004fb2:	60bb      	str	r3, [r7, #8]
          /* I2S_CLK = PLLI2S_VCO Output/PLLI2SR */
          frequency = (uint32_t)(vcooutput / (((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28U) & (RCC_PLLI2SCFGR_PLLI2SR >> 28U)));
 8004fb4:	4b0b      	ldr	r3, [pc, #44]	@ (8004fe4 <HAL_RCCEx_GetPeriphCLKFreq+0xb0>)
 8004fb6:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 8004fba:	0f1b      	lsrs	r3, r3, #28
 8004fbc:	f003 0307 	and.w	r3, r3, #7
 8004fc0:	68ba      	ldr	r2, [r7, #8]
 8004fc2:	fbb2 f3f3 	udiv	r3, r2, r3
 8004fc6:	617b      	str	r3, [r7, #20]
          break;
 8004fc8:	e002      	b.n	8004fd0 <HAL_RCCEx_GetPeriphCLKFreq+0x9c>
        }
        /* Clock not enabled for I2S*/
        default:
        {
          frequency = 0U;
 8004fca:	2300      	movs	r3, #0
 8004fcc:	617b      	str	r3, [r7, #20]
          break;
 8004fce:	bf00      	nop
        }
      }
      break;
 8004fd0:	e000      	b.n	8004fd4 <HAL_RCCEx_GetPeriphCLKFreq+0xa0>
    }
    default:
    {
      break;
 8004fd2:	bf00      	nop
    }
  }
  return frequency;
 8004fd4:	697b      	ldr	r3, [r7, #20]
}
 8004fd6:	4618      	mov	r0, r3
 8004fd8:	371c      	adds	r7, #28
 8004fda:	46bd      	mov	sp, r7
 8004fdc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004fe0:	4770      	bx	lr
 8004fe2:	bf00      	nop
 8004fe4:	40023800 	.word	0x40023800
 8004fe8:	00bb8000 	.word	0x00bb8000
 8004fec:	007a1200 	.word	0x007a1200
 8004ff0:	00f42400 	.word	0x00f42400

08004ff4 <HAL_RNG_Init>:
  * @param  hrng pointer to a RNG_HandleTypeDef structure that contains
  *                the configuration information for RNG.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RNG_Init(RNG_HandleTypeDef *hrng)
{
 8004ff4:	b580      	push	{r7, lr}
 8004ff6:	b082      	sub	sp, #8
 8004ff8:	af00      	add	r7, sp, #0
 8004ffa:	6078      	str	r0, [r7, #4]
  /* Check the RNG handle allocation */
  if (hrng == NULL)
 8004ffc:	687b      	ldr	r3, [r7, #4]
 8004ffe:	2b00      	cmp	r3, #0
 8005000:	d101      	bne.n	8005006 <HAL_RNG_Init+0x12>
  {
    return HAL_ERROR;
 8005002:	2301      	movs	r3, #1
 8005004:	e01c      	b.n	8005040 <HAL_RNG_Init+0x4c>

    /* Init the low level hardware */
    hrng->MspInitCallback(hrng);
  }
#else
  if (hrng->State == HAL_RNG_STATE_RESET)
 8005006:	687b      	ldr	r3, [r7, #4]
 8005008:	795b      	ldrb	r3, [r3, #5]
 800500a:	b2db      	uxtb	r3, r3
 800500c:	2b00      	cmp	r3, #0
 800500e:	d105      	bne.n	800501c <HAL_RNG_Init+0x28>
  {
    /* Allocate lock resource and initialize it */
    hrng->Lock = HAL_UNLOCKED;
 8005010:	687b      	ldr	r3, [r7, #4]
 8005012:	2200      	movs	r2, #0
 8005014:	711a      	strb	r2, [r3, #4]

    /* Init the low level hardware */
    HAL_RNG_MspInit(hrng);
 8005016:	6878      	ldr	r0, [r7, #4]
 8005018:	f7fc fd0a 	bl	8001a30 <HAL_RNG_MspInit>
  }
#endif /* USE_HAL_RNG_REGISTER_CALLBACKS */

  /* Change RNG peripheral state */
  hrng->State = HAL_RNG_STATE_BUSY;
 800501c:	687b      	ldr	r3, [r7, #4]
 800501e:	2202      	movs	r2, #2
 8005020:	715a      	strb	r2, [r3, #5]


  /* Enable the RNG Peripheral */
  __HAL_RNG_ENABLE(hrng);
 8005022:	687b      	ldr	r3, [r7, #4]
 8005024:	681b      	ldr	r3, [r3, #0]
 8005026:	681a      	ldr	r2, [r3, #0]
 8005028:	687b      	ldr	r3, [r7, #4]
 800502a:	681b      	ldr	r3, [r3, #0]
 800502c:	f042 0204 	orr.w	r2, r2, #4
 8005030:	601a      	str	r2, [r3, #0]

  /* Initialize the RNG state */
  hrng->State = HAL_RNG_STATE_READY;
 8005032:	687b      	ldr	r3, [r7, #4]
 8005034:	2201      	movs	r2, #1
 8005036:	715a      	strb	r2, [r3, #5]

  /* Initialise the error code */
  hrng->ErrorCode = HAL_RNG_ERROR_NONE;
 8005038:	687b      	ldr	r3, [r7, #4]
 800503a:	2200      	movs	r2, #0
 800503c:	609a      	str	r2, [r3, #8]

  /* Return function status */
  return HAL_OK;
 800503e:	2300      	movs	r3, #0
}
 8005040:	4618      	mov	r0, r3
 8005042:	3708      	adds	r7, #8
 8005044:	46bd      	mov	sp, r7
 8005046:	bd80      	pop	{r7, pc}

08005048 <HAL_RNG_DeInit>:
  * @param  hrng pointer to a RNG_HandleTypeDef structure that contains
  *                the configuration information for RNG.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RNG_DeInit(RNG_HandleTypeDef *hrng)
{
 8005048:	b580      	push	{r7, lr}
 800504a:	b082      	sub	sp, #8
 800504c:	af00      	add	r7, sp, #0
 800504e:	6078      	str	r0, [r7, #4]
  /* Check the RNG handle allocation */
  if (hrng == NULL)
 8005050:	687b      	ldr	r3, [r7, #4]
 8005052:	2b00      	cmp	r3, #0
 8005054:	d101      	bne.n	800505a <HAL_RNG_DeInit+0x12>
  {
    return HAL_ERROR;
 8005056:	2301      	movs	r3, #1
 8005058:	e01c      	b.n	8005094 <HAL_RNG_DeInit+0x4c>
  }

  /* Disable the RNG Peripheral */
  CLEAR_BIT(hrng->Instance->CR, RNG_CR_IE | RNG_CR_RNGEN);
 800505a:	687b      	ldr	r3, [r7, #4]
 800505c:	681b      	ldr	r3, [r3, #0]
 800505e:	681a      	ldr	r2, [r3, #0]
 8005060:	687b      	ldr	r3, [r7, #4]
 8005062:	681b      	ldr	r3, [r3, #0]
 8005064:	f022 020c 	bic.w	r2, r2, #12
 8005068:	601a      	str	r2, [r3, #0]

  /* Clear RNG interrupt status flags */
  CLEAR_BIT(hrng->Instance->SR, RNG_SR_CEIS | RNG_SR_SEIS);
 800506a:	687b      	ldr	r3, [r7, #4]
 800506c:	681b      	ldr	r3, [r3, #0]
 800506e:	685a      	ldr	r2, [r3, #4]
 8005070:	687b      	ldr	r3, [r7, #4]
 8005072:	681b      	ldr	r3, [r3, #0]
 8005074:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 8005078:	605a      	str	r2, [r3, #4]

  /* DeInit the low level hardware */
  hrng->MspDeInitCallback(hrng);
#else
  /* DeInit the low level hardware */
  HAL_RNG_MspDeInit(hrng);
 800507a:	6878      	ldr	r0, [r7, #4]
 800507c:	f7fc fcfa 	bl	8001a74 <HAL_RNG_MspDeInit>
#endif /* USE_HAL_RNG_REGISTER_CALLBACKS */

  /* Update the RNG state */
  hrng->State = HAL_RNG_STATE_RESET;
 8005080:	687b      	ldr	r3, [r7, #4]
 8005082:	2200      	movs	r2, #0
 8005084:	715a      	strb	r2, [r3, #5]

  /* Initialise the error code */
  hrng->ErrorCode = HAL_RNG_ERROR_NONE;
 8005086:	687b      	ldr	r3, [r7, #4]
 8005088:	2200      	movs	r2, #0
 800508a:	609a      	str	r2, [r3, #8]

  /* Release Lock */
  __HAL_UNLOCK(hrng);
 800508c:	687b      	ldr	r3, [r7, #4]
 800508e:	2200      	movs	r2, #0
 8005090:	711a      	strb	r2, [r3, #4]

  /* Return the function status */
  return HAL_OK;
 8005092:	2300      	movs	r3, #0
}
 8005094:	4618      	mov	r0, r3
 8005096:	3708      	adds	r7, #8
 8005098:	46bd      	mov	sp, r7
 800509a:	bd80      	pop	{r7, pc}

0800509c <HAL_RNG_GenerateRandomNumber>:
  * @param  random32bit pointer to generated random number variable if successful.
  * @retval HAL status
  */

HAL_StatusTypeDef HAL_RNG_GenerateRandomNumber(RNG_HandleTypeDef *hrng, uint32_t *random32bit)
{
 800509c:	b580      	push	{r7, lr}
 800509e:	b084      	sub	sp, #16
 80050a0:	af00      	add	r7, sp, #0
 80050a2:	6078      	str	r0, [r7, #4]
 80050a4:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
 80050a6:	2300      	movs	r3, #0
 80050a8:	73fb      	strb	r3, [r7, #15]

  /* Process Locked */
  __HAL_LOCK(hrng);
 80050aa:	687b      	ldr	r3, [r7, #4]
 80050ac:	791b      	ldrb	r3, [r3, #4]
 80050ae:	2b01      	cmp	r3, #1
 80050b0:	d101      	bne.n	80050b6 <HAL_RNG_GenerateRandomNumber+0x1a>
 80050b2:	2302      	movs	r3, #2
 80050b4:	e044      	b.n	8005140 <HAL_RNG_GenerateRandomNumber+0xa4>
 80050b6:	687b      	ldr	r3, [r7, #4]
 80050b8:	2201      	movs	r2, #1
 80050ba:	711a      	strb	r2, [r3, #4]

  /* Check RNG peripheral state */
  if (hrng->State == HAL_RNG_STATE_READY)
 80050bc:	687b      	ldr	r3, [r7, #4]
 80050be:	795b      	ldrb	r3, [r3, #5]
 80050c0:	b2db      	uxtb	r3, r3
 80050c2:	2b01      	cmp	r3, #1
 80050c4:	d133      	bne.n	800512e <HAL_RNG_GenerateRandomNumber+0x92>
  {
    /* Change RNG peripheral state */
    hrng->State = HAL_RNG_STATE_BUSY;
 80050c6:	687b      	ldr	r3, [r7, #4]
 80050c8:	2202      	movs	r2, #2
 80050ca:	715a      	strb	r2, [r3, #5]

    /* Get tick */
    tickstart = HAL_GetTick();
 80050cc:	f7fc fe46 	bl	8001d5c <HAL_GetTick>
 80050d0:	60b8      	str	r0, [r7, #8]

    /* Check if data register contains valid random data */
    while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
 80050d2:	e018      	b.n	8005106 <HAL_RNG_GenerateRandomNumber+0x6a>
    {
      if ((HAL_GetTick() - tickstart) > RNG_TIMEOUT_VALUE)
 80050d4:	f7fc fe42 	bl	8001d5c <HAL_GetTick>
 80050d8:	4602      	mov	r2, r0
 80050da:	68bb      	ldr	r3, [r7, #8]
 80050dc:	1ad3      	subs	r3, r2, r3
 80050de:	2b02      	cmp	r3, #2
 80050e0:	d911      	bls.n	8005106 <HAL_RNG_GenerateRandomNumber+0x6a>
      {
        /* New check to avoid false timeout detection in case of preemption */
        if (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
 80050e2:	687b      	ldr	r3, [r7, #4]
 80050e4:	681b      	ldr	r3, [r3, #0]
 80050e6:	685b      	ldr	r3, [r3, #4]
 80050e8:	f003 0301 	and.w	r3, r3, #1
 80050ec:	2b01      	cmp	r3, #1
 80050ee:	d00a      	beq.n	8005106 <HAL_RNG_GenerateRandomNumber+0x6a>
        {
          hrng->State = HAL_RNG_STATE_READY;
 80050f0:	687b      	ldr	r3, [r7, #4]
 80050f2:	2201      	movs	r2, #1
 80050f4:	715a      	strb	r2, [r3, #5]
          hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 80050f6:	687b      	ldr	r3, [r7, #4]
 80050f8:	2202      	movs	r2, #2
 80050fa:	609a      	str	r2, [r3, #8]
          /* Process Unlocked */
          __HAL_UNLOCK(hrng);
 80050fc:	687b      	ldr	r3, [r7, #4]
 80050fe:	2200      	movs	r2, #0
 8005100:	711a      	strb	r2, [r3, #4]
          return HAL_ERROR;
 8005102:	2301      	movs	r3, #1
 8005104:	e01c      	b.n	8005140 <HAL_RNG_GenerateRandomNumber+0xa4>
    while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
 8005106:	687b      	ldr	r3, [r7, #4]
 8005108:	681b      	ldr	r3, [r3, #0]
 800510a:	685b      	ldr	r3, [r3, #4]
 800510c:	f003 0301 	and.w	r3, r3, #1
 8005110:	2b01      	cmp	r3, #1
 8005112:	d1df      	bne.n	80050d4 <HAL_RNG_GenerateRandomNumber+0x38>
        }
      }
    }

    /* Get a 32bit Random number */
    hrng->RandomNumber = hrng->Instance->DR;
 8005114:	687b      	ldr	r3, [r7, #4]
 8005116:	681b      	ldr	r3, [r3, #0]
 8005118:	689a      	ldr	r2, [r3, #8]
 800511a:	687b      	ldr	r3, [r7, #4]
 800511c:	60da      	str	r2, [r3, #12]
    *random32bit = hrng->RandomNumber;
 800511e:	687b      	ldr	r3, [r7, #4]
 8005120:	68da      	ldr	r2, [r3, #12]
 8005122:	683b      	ldr	r3, [r7, #0]
 8005124:	601a      	str	r2, [r3, #0]

    hrng->State = HAL_RNG_STATE_READY;
 8005126:	687b      	ldr	r3, [r7, #4]
 8005128:	2201      	movs	r2, #1
 800512a:	715a      	strb	r2, [r3, #5]
 800512c:	e004      	b.n	8005138 <HAL_RNG_GenerateRandomNumber+0x9c>
  }
  else
  {
    hrng->ErrorCode = HAL_RNG_ERROR_BUSY;
 800512e:	687b      	ldr	r3, [r7, #4]
 8005130:	2204      	movs	r2, #4
 8005132:	609a      	str	r2, [r3, #8]
    status = HAL_ERROR;
 8005134:	2301      	movs	r3, #1
 8005136:	73fb      	strb	r3, [r7, #15]
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hrng);
 8005138:	687b      	ldr	r3, [r7, #4]
 800513a:	2200      	movs	r2, #0
 800513c:	711a      	strb	r2, [r3, #4]

  return status;
 800513e:	7bfb      	ldrb	r3, [r7, #15]
}
 8005140:	4618      	mov	r0, r3
 8005142:	3710      	adds	r7, #16
 8005144:	46bd      	mov	sp, r7
 8005146:	bd80      	pop	{r7, pc}

08005148 <HAL_SPI_Init>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 8005148:	b580      	push	{r7, lr}
 800514a:	b082      	sub	sp, #8
 800514c:	af00      	add	r7, sp, #0
 800514e:	6078      	str	r0, [r7, #4]
  /* Check the SPI handle allocation */
  if (hspi == NULL)
 8005150:	687b      	ldr	r3, [r7, #4]
 8005152:	2b00      	cmp	r3, #0
 8005154:	d101      	bne.n	800515a <HAL_SPI_Init+0x12>
  {
    return HAL_ERROR;
 8005156:	2301      	movs	r3, #1
 8005158:	e07b      	b.n	8005252 <HAL_SPI_Init+0x10a>
  assert_param(IS_SPI_DATASIZE(hspi->Init.DataSize));
  assert_param(IS_SPI_NSS(hspi->Init.NSS));
  assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
  assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
  assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
  if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)
 800515a:	687b      	ldr	r3, [r7, #4]
 800515c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800515e:	2b00      	cmp	r3, #0
 8005160:	d108      	bne.n	8005174 <HAL_SPI_Init+0x2c>
  {
    assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));
    assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));

    if (hspi->Init.Mode == SPI_MODE_MASTER)
 8005162:	687b      	ldr	r3, [r7, #4]
 8005164:	685b      	ldr	r3, [r3, #4]
 8005166:	f5b3 7f82 	cmp.w	r3, #260	@ 0x104
 800516a:	d009      	beq.n	8005180 <HAL_SPI_Init+0x38>
      assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
    }
    else
    {
      /* Baudrate prescaler not use in Motoraola Slave mode. force to default value */
      hspi->Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 800516c:	687b      	ldr	r3, [r7, #4]
 800516e:	2200      	movs	r2, #0
 8005170:	61da      	str	r2, [r3, #28]
 8005172:	e005      	b.n	8005180 <HAL_SPI_Init+0x38>
  else
  {
    assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));

    /* Force polarity and phase to TI protocaol requirements */
    hspi->Init.CLKPolarity = SPI_POLARITY_LOW;
 8005174:	687b      	ldr	r3, [r7, #4]
 8005176:	2200      	movs	r2, #0
 8005178:	611a      	str	r2, [r3, #16]
    hspi->Init.CLKPhase    = SPI_PHASE_1EDGE;
 800517a:	687b      	ldr	r3, [r7, #4]
 800517c:	2200      	movs	r2, #0
 800517e:	615a      	str	r2, [r3, #20]
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8005180:	687b      	ldr	r3, [r7, #4]
 8005182:	2200      	movs	r2, #0
 8005184:	629a      	str	r2, [r3, #40]	@ 0x28
#endif /* USE_SPI_CRC */

  if (hspi->State == HAL_SPI_STATE_RESET)
 8005186:	687b      	ldr	r3, [r7, #4]
 8005188:	f893 3051 	ldrb.w	r3, [r3, #81]	@ 0x51
 800518c:	b2db      	uxtb	r3, r3
 800518e:	2b00      	cmp	r3, #0
 8005190:	d106      	bne.n	80051a0 <HAL_SPI_Init+0x58>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 8005192:	687b      	ldr	r3, [r7, #4]
 8005194:	2200      	movs	r2, #0
 8005196:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    hspi->MspInitCallback(hspi);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 800519a:	6878      	ldr	r0, [r7, #4]
 800519c:	f7fc fc84 	bl	8001aa8 <HAL_SPI_MspInit>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 80051a0:	687b      	ldr	r3, [r7, #4]
 80051a2:	2202      	movs	r2, #2
 80051a4:	f883 2051 	strb.w	r2, [r3, #81]	@ 0x51

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 80051a8:	687b      	ldr	r3, [r7, #4]
 80051aa:	681b      	ldr	r3, [r3, #0]
 80051ac:	681a      	ldr	r2, [r3, #0]
 80051ae:	687b      	ldr	r3, [r7, #4]
 80051b0:	681b      	ldr	r3, [r3, #0]
 80051b2:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
 80051b6:	601a      	str	r2, [r3, #0]

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 80051b8:	687b      	ldr	r3, [r7, #4]
 80051ba:	685b      	ldr	r3, [r3, #4]
 80051bc:	f403 7282 	and.w	r2, r3, #260	@ 0x104
 80051c0:	687b      	ldr	r3, [r7, #4]
 80051c2:	689b      	ldr	r3, [r3, #8]
 80051c4:	f403 4304 	and.w	r3, r3, #33792	@ 0x8400
 80051c8:	431a      	orrs	r2, r3
 80051ca:	687b      	ldr	r3, [r7, #4]
 80051cc:	68db      	ldr	r3, [r3, #12]
 80051ce:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 80051d2:	431a      	orrs	r2, r3
 80051d4:	687b      	ldr	r3, [r7, #4]
 80051d6:	691b      	ldr	r3, [r3, #16]
 80051d8:	f003 0302 	and.w	r3, r3, #2
 80051dc:	431a      	orrs	r2, r3
 80051de:	687b      	ldr	r3, [r7, #4]
 80051e0:	695b      	ldr	r3, [r3, #20]
 80051e2:	f003 0301 	and.w	r3, r3, #1
 80051e6:	431a      	orrs	r2, r3
 80051e8:	687b      	ldr	r3, [r7, #4]
 80051ea:	699b      	ldr	r3, [r3, #24]
 80051ec:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 80051f0:	431a      	orrs	r2, r3
 80051f2:	687b      	ldr	r3, [r7, #4]
 80051f4:	69db      	ldr	r3, [r3, #28]
 80051f6:	f003 0338 	and.w	r3, r3, #56	@ 0x38
 80051fa:	431a      	orrs	r2, r3
 80051fc:	687b      	ldr	r3, [r7, #4]
 80051fe:	6a1b      	ldr	r3, [r3, #32]
 8005200:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8005204:	ea42 0103 	orr.w	r1, r2, r3
 8005208:	687b      	ldr	r3, [r7, #4]
 800520a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800520c:	f403 5200 	and.w	r2, r3, #8192	@ 0x2000
 8005210:	687b      	ldr	r3, [r7, #4]
 8005212:	681b      	ldr	r3, [r3, #0]
 8005214:	430a      	orrs	r2, r1
 8005216:	601a      	str	r2, [r3, #0]
                                  (hspi->Init.BaudRatePrescaler & SPI_CR1_BR_Msk) |
                                  (hspi->Init.FirstBit  & SPI_CR1_LSBFIRST) |
                                  (hspi->Init.CRCCalculation & SPI_CR1_CRCEN)));

  /* Configure : NSS management, TI Mode */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | (hspi->Init.TIMode & SPI_CR2_FRF)));
 8005218:	687b      	ldr	r3, [r7, #4]
 800521a:	699b      	ldr	r3, [r3, #24]
 800521c:	0c1b      	lsrs	r3, r3, #16
 800521e:	f003 0104 	and.w	r1, r3, #4
 8005222:	687b      	ldr	r3, [r7, #4]
 8005224:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8005226:	f003 0210 	and.w	r2, r3, #16
 800522a:	687b      	ldr	r3, [r7, #4]
 800522c:	681b      	ldr	r3, [r3, #0]
 800522e:	430a      	orrs	r2, r1
 8005230:	605a      	str	r2, [r3, #4]
  }
#endif /* USE_SPI_CRC */

#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 8005232:	687b      	ldr	r3, [r7, #4]
 8005234:	681b      	ldr	r3, [r3, #0]
 8005236:	69da      	ldr	r2, [r3, #28]
 8005238:	687b      	ldr	r3, [r7, #4]
 800523a:	681b      	ldr	r3, [r3, #0]
 800523c:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
 8005240:	61da      	str	r2, [r3, #28]
#endif /* SPI_I2SCFGR_I2SMOD */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8005242:	687b      	ldr	r3, [r7, #4]
 8005244:	2200      	movs	r2, #0
 8005246:	655a      	str	r2, [r3, #84]	@ 0x54
  hspi->State     = HAL_SPI_STATE_READY;
 8005248:	687b      	ldr	r3, [r7, #4]
 800524a:	2201      	movs	r2, #1
 800524c:	f883 2051 	strb.w	r2, [r3, #81]	@ 0x51

  return HAL_OK;
 8005250:	2300      	movs	r3, #0
}
 8005252:	4618      	mov	r0, r3
 8005254:	3708      	adds	r7, #8
 8005256:	46bd      	mov	sp, r7
 8005258:	bd80      	pop	{r7, pc}

0800525a <USB_CoreInit>:
  * @param  cfg pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 800525a:	b084      	sub	sp, #16
 800525c:	b580      	push	{r7, lr}
 800525e:	b084      	sub	sp, #16
 8005260:	af00      	add	r7, sp, #0
 8005262:	6078      	str	r0, [r7, #4]
 8005264:	f107 001c 	add.w	r0, r7, #28
 8005268:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  HAL_StatusTypeDef ret;
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 800526c:	f897 3021 	ldrb.w	r3, [r7, #33]	@ 0x21
 8005270:	2b01      	cmp	r3, #1
 8005272:	d123      	bne.n	80052bc <USB_CoreInit+0x62>
  {
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 8005274:	687b      	ldr	r3, [r7, #4]
 8005276:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8005278:	f423 3280 	bic.w	r2, r3, #65536	@ 0x10000
 800527c:	687b      	ldr	r3, [r7, #4]
 800527e:	639a      	str	r2, [r3, #56]	@ 0x38

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 8005280:	687b      	ldr	r3, [r7, #4]
 8005282:	68db      	ldr	r3, [r3, #12]
 8005284:	f423 0384 	bic.w	r3, r3, #4325376	@ 0x420000
 8005288:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 800528c:	687a      	ldr	r2, [r7, #4]
 800528e:	60d3      	str	r3, [r2, #12]

    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 8005290:	687b      	ldr	r3, [r7, #4]
 8005292:	68db      	ldr	r3, [r3, #12]
 8005294:	f423 1240 	bic.w	r2, r3, #3145728	@ 0x300000
 8005298:	687b      	ldr	r3, [r7, #4]
 800529a:	60da      	str	r2, [r3, #12]
    if (cfg.use_external_vbus == 1U)
 800529c:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
 80052a0:	2b01      	cmp	r3, #1
 80052a2:	d105      	bne.n	80052b0 <USB_CoreInit+0x56>
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
 80052a4:	687b      	ldr	r3, [r7, #4]
 80052a6:	68db      	ldr	r3, [r3, #12]
 80052a8:	f443 1280 	orr.w	r2, r3, #1048576	@ 0x100000
 80052ac:	687b      	ldr	r3, [r7, #4]
 80052ae:	60da      	str	r2, [r3, #12]
    }

    /* Reset after a PHY select */
    ret = USB_CoreReset(USBx);
 80052b0:	6878      	ldr	r0, [r7, #4]
 80052b2:	f001 fae9 	bl	8006888 <USB_CoreReset>
 80052b6:	4603      	mov	r3, r0
 80052b8:	73fb      	strb	r3, [r7, #15]
 80052ba:	e01b      	b.n	80052f4 <USB_CoreInit+0x9a>
  }
  else /* FS interface (embedded Phy) */
  {
    /* Select FS Embedded PHY */
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 80052bc:	687b      	ldr	r3, [r7, #4]
 80052be:	68db      	ldr	r3, [r3, #12]
 80052c0:	f043 0240 	orr.w	r2, r3, #64	@ 0x40
 80052c4:	687b      	ldr	r3, [r7, #4]
 80052c6:	60da      	str	r2, [r3, #12]

    /* Reset after a PHY select */
    ret = USB_CoreReset(USBx);
 80052c8:	6878      	ldr	r0, [r7, #4]
 80052ca:	f001 fadd 	bl	8006888 <USB_CoreReset>
 80052ce:	4603      	mov	r3, r0
 80052d0:	73fb      	strb	r3, [r7, #15]

    if (cfg.battery_charging_enable == 0U)
 80052d2:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
 80052d6:	2b00      	cmp	r3, #0
 80052d8:	d106      	bne.n	80052e8 <USB_CoreInit+0x8e>
    {
      /* Activate the USB Transceiver */
      USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 80052da:	687b      	ldr	r3, [r7, #4]
 80052dc:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80052de:	f443 3280 	orr.w	r2, r3, #65536	@ 0x10000
 80052e2:	687b      	ldr	r3, [r7, #4]
 80052e4:	639a      	str	r2, [r3, #56]	@ 0x38
 80052e6:	e005      	b.n	80052f4 <USB_CoreInit+0x9a>
    }
    else
    {
      /* Deactivate the USB Transceiver */
      USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 80052e8:	687b      	ldr	r3, [r7, #4]
 80052ea:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80052ec:	f423 3280 	bic.w	r2, r3, #65536	@ 0x10000
 80052f0:	687b      	ldr	r3, [r7, #4]
 80052f2:	639a      	str	r2, [r3, #56]	@ 0x38
    }
  }

  if (cfg.dma_enable == 1U)
 80052f4:	7fbb      	ldrb	r3, [r7, #30]
 80052f6:	2b01      	cmp	r3, #1
 80052f8:	d10b      	bne.n	8005312 <USB_CoreInit+0xb8>
  {
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;
 80052fa:	687b      	ldr	r3, [r7, #4]
 80052fc:	689b      	ldr	r3, [r3, #8]
 80052fe:	f043 0206 	orr.w	r2, r3, #6
 8005302:	687b      	ldr	r3, [r7, #4]
 8005304:	609a      	str	r2, [r3, #8]
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
 8005306:	687b      	ldr	r3, [r7, #4]
 8005308:	689b      	ldr	r3, [r3, #8]
 800530a:	f043 0220 	orr.w	r2, r3, #32
 800530e:	687b      	ldr	r3, [r7, #4]
 8005310:	609a      	str	r2, [r3, #8]
  }

  return ret;
 8005312:	7bfb      	ldrb	r3, [r7, #15]
}
 8005314:	4618      	mov	r0, r3
 8005316:	3710      	adds	r7, #16
 8005318:	46bd      	mov	sp, r7
 800531a:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 800531e:	b004      	add	sp, #16
 8005320:	4770      	bx	lr
	...

08005324 <USB_SetTurnaroundTime>:
  * @param  hclk: AHB clock frequency
  * @retval USB turnaround time In PHY Clocks number
  */
HAL_StatusTypeDef USB_SetTurnaroundTime(USB_OTG_GlobalTypeDef *USBx,
                                        uint32_t hclk, uint8_t speed)
{
 8005324:	b480      	push	{r7}
 8005326:	b087      	sub	sp, #28
 8005328:	af00      	add	r7, sp, #0
 800532a:	60f8      	str	r0, [r7, #12]
 800532c:	60b9      	str	r1, [r7, #8]
 800532e:	4613      	mov	r3, r2
 8005330:	71fb      	strb	r3, [r7, #7]

  /* The USBTRD is configured according to the tables below, depending on AHB frequency
  used by application. In the low AHB frequency range it is used to stretch enough the USB response
  time to IN tokens, the USB turnaround time, so to compensate for the longer AHB read access
  latency to the Data FIFO */
  if (speed == USBD_FS_SPEED)
 8005332:	79fb      	ldrb	r3, [r7, #7]
 8005334:	2b02      	cmp	r3, #2
 8005336:	d165      	bne.n	8005404 <USB_SetTurnaroundTime+0xe0>
  {
    if ((hclk >= 14200000U) && (hclk < 15000000U))
 8005338:	68bb      	ldr	r3, [r7, #8]
 800533a:	4a41      	ldr	r2, [pc, #260]	@ (8005440 <USB_SetTurnaroundTime+0x11c>)
 800533c:	4293      	cmp	r3, r2
 800533e:	d906      	bls.n	800534e <USB_SetTurnaroundTime+0x2a>
 8005340:	68bb      	ldr	r3, [r7, #8]
 8005342:	4a40      	ldr	r2, [pc, #256]	@ (8005444 <USB_SetTurnaroundTime+0x120>)
 8005344:	4293      	cmp	r3, r2
 8005346:	d202      	bcs.n	800534e <USB_SetTurnaroundTime+0x2a>
    {
      /* hclk Clock Range between 14.2-15 MHz */
      UsbTrd = 0xFU;
 8005348:	230f      	movs	r3, #15
 800534a:	617b      	str	r3, [r7, #20]
 800534c:	e062      	b.n	8005414 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 15000000U) && (hclk < 16000000U))
 800534e:	68bb      	ldr	r3, [r7, #8]
 8005350:	4a3c      	ldr	r2, [pc, #240]	@ (8005444 <USB_SetTurnaroundTime+0x120>)
 8005352:	4293      	cmp	r3, r2
 8005354:	d306      	bcc.n	8005364 <USB_SetTurnaroundTime+0x40>
 8005356:	68bb      	ldr	r3, [r7, #8]
 8005358:	4a3b      	ldr	r2, [pc, #236]	@ (8005448 <USB_SetTurnaroundTime+0x124>)
 800535a:	4293      	cmp	r3, r2
 800535c:	d202      	bcs.n	8005364 <USB_SetTurnaroundTime+0x40>
    {
      /* hclk Clock Range between 15-16 MHz */
      UsbTrd = 0xEU;
 800535e:	230e      	movs	r3, #14
 8005360:	617b      	str	r3, [r7, #20]
 8005362:	e057      	b.n	8005414 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 16000000U) && (hclk < 17200000U))
 8005364:	68bb      	ldr	r3, [r7, #8]
 8005366:	4a38      	ldr	r2, [pc, #224]	@ (8005448 <USB_SetTurnaroundTime+0x124>)
 8005368:	4293      	cmp	r3, r2
 800536a:	d306      	bcc.n	800537a <USB_SetTurnaroundTime+0x56>
 800536c:	68bb      	ldr	r3, [r7, #8]
 800536e:	4a37      	ldr	r2, [pc, #220]	@ (800544c <USB_SetTurnaroundTime+0x128>)
 8005370:	4293      	cmp	r3, r2
 8005372:	d202      	bcs.n	800537a <USB_SetTurnaroundTime+0x56>
    {
      /* hclk Clock Range between 16-17.2 MHz */
      UsbTrd = 0xDU;
 8005374:	230d      	movs	r3, #13
 8005376:	617b      	str	r3, [r7, #20]
 8005378:	e04c      	b.n	8005414 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 17200000U) && (hclk < 18500000U))
 800537a:	68bb      	ldr	r3, [r7, #8]
 800537c:	4a33      	ldr	r2, [pc, #204]	@ (800544c <USB_SetTurnaroundTime+0x128>)
 800537e:	4293      	cmp	r3, r2
 8005380:	d306      	bcc.n	8005390 <USB_SetTurnaroundTime+0x6c>
 8005382:	68bb      	ldr	r3, [r7, #8]
 8005384:	4a32      	ldr	r2, [pc, #200]	@ (8005450 <USB_SetTurnaroundTime+0x12c>)
 8005386:	4293      	cmp	r3, r2
 8005388:	d802      	bhi.n	8005390 <USB_SetTurnaroundTime+0x6c>
    {
      /* hclk Clock Range between 17.2-18.5 MHz */
      UsbTrd = 0xCU;
 800538a:	230c      	movs	r3, #12
 800538c:	617b      	str	r3, [r7, #20]
 800538e:	e041      	b.n	8005414 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 18500000U) && (hclk < 20000000U))
 8005390:	68bb      	ldr	r3, [r7, #8]
 8005392:	4a2f      	ldr	r2, [pc, #188]	@ (8005450 <USB_SetTurnaroundTime+0x12c>)
 8005394:	4293      	cmp	r3, r2
 8005396:	d906      	bls.n	80053a6 <USB_SetTurnaroundTime+0x82>
 8005398:	68bb      	ldr	r3, [r7, #8]
 800539a:	4a2e      	ldr	r2, [pc, #184]	@ (8005454 <USB_SetTurnaroundTime+0x130>)
 800539c:	4293      	cmp	r3, r2
 800539e:	d802      	bhi.n	80053a6 <USB_SetTurnaroundTime+0x82>
    {
      /* hclk Clock Range between 18.5-20 MHz */
      UsbTrd = 0xBU;
 80053a0:	230b      	movs	r3, #11
 80053a2:	617b      	str	r3, [r7, #20]
 80053a4:	e036      	b.n	8005414 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 20000000U) && (hclk < 21800000U))
 80053a6:	68bb      	ldr	r3, [r7, #8]
 80053a8:	4a2a      	ldr	r2, [pc, #168]	@ (8005454 <USB_SetTurnaroundTime+0x130>)
 80053aa:	4293      	cmp	r3, r2
 80053ac:	d906      	bls.n	80053bc <USB_SetTurnaroundTime+0x98>
 80053ae:	68bb      	ldr	r3, [r7, #8]
 80053b0:	4a29      	ldr	r2, [pc, #164]	@ (8005458 <USB_SetTurnaroundTime+0x134>)
 80053b2:	4293      	cmp	r3, r2
 80053b4:	d802      	bhi.n	80053bc <USB_SetTurnaroundTime+0x98>
    {
      /* hclk Clock Range between 20-21.8 MHz */
      UsbTrd = 0xAU;
 80053b6:	230a      	movs	r3, #10
 80053b8:	617b      	str	r3, [r7, #20]
 80053ba:	e02b      	b.n	8005414 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 21800000U) && (hclk < 24000000U))
 80053bc:	68bb      	ldr	r3, [r7, #8]
 80053be:	4a26      	ldr	r2, [pc, #152]	@ (8005458 <USB_SetTurnaroundTime+0x134>)
 80053c0:	4293      	cmp	r3, r2
 80053c2:	d906      	bls.n	80053d2 <USB_SetTurnaroundTime+0xae>
 80053c4:	68bb      	ldr	r3, [r7, #8]
 80053c6:	4a25      	ldr	r2, [pc, #148]	@ (800545c <USB_SetTurnaroundTime+0x138>)
 80053c8:	4293      	cmp	r3, r2
 80053ca:	d202      	bcs.n	80053d2 <USB_SetTurnaroundTime+0xae>
    {
      /* hclk Clock Range between 21.8-24 MHz */
      UsbTrd = 0x9U;
 80053cc:	2309      	movs	r3, #9
 80053ce:	617b      	str	r3, [r7, #20]
 80053d0:	e020      	b.n	8005414 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 24000000U) && (hclk < 27700000U))
 80053d2:	68bb      	ldr	r3, [r7, #8]
 80053d4:	4a21      	ldr	r2, [pc, #132]	@ (800545c <USB_SetTurnaroundTime+0x138>)
 80053d6:	4293      	cmp	r3, r2
 80053d8:	d306      	bcc.n	80053e8 <USB_SetTurnaroundTime+0xc4>
 80053da:	68bb      	ldr	r3, [r7, #8]
 80053dc:	4a20      	ldr	r2, [pc, #128]	@ (8005460 <USB_SetTurnaroundTime+0x13c>)
 80053de:	4293      	cmp	r3, r2
 80053e0:	d802      	bhi.n	80053e8 <USB_SetTurnaroundTime+0xc4>
    {
      /* hclk Clock Range between 24-27.7 MHz */
      UsbTrd = 0x8U;
 80053e2:	2308      	movs	r3, #8
 80053e4:	617b      	str	r3, [r7, #20]
 80053e6:	e015      	b.n	8005414 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 27700000U) && (hclk < 32000000U))
 80053e8:	68bb      	ldr	r3, [r7, #8]
 80053ea:	4a1d      	ldr	r2, [pc, #116]	@ (8005460 <USB_SetTurnaroundTime+0x13c>)
 80053ec:	4293      	cmp	r3, r2
 80053ee:	d906      	bls.n	80053fe <USB_SetTurnaroundTime+0xda>
 80053f0:	68bb      	ldr	r3, [r7, #8]
 80053f2:	4a1c      	ldr	r2, [pc, #112]	@ (8005464 <USB_SetTurnaroundTime+0x140>)
 80053f4:	4293      	cmp	r3, r2
 80053f6:	d202      	bcs.n	80053fe <USB_SetTurnaroundTime+0xda>
    {
      /* hclk Clock Range between 27.7-32 MHz */
      UsbTrd = 0x7U;
 80053f8:	2307      	movs	r3, #7
 80053fa:	617b      	str	r3, [r7, #20]
 80053fc:	e00a      	b.n	8005414 <USB_SetTurnaroundTime+0xf0>
    }
    else /* if(hclk >= 32000000) */
    {
      /* hclk Clock Range between 32-200 MHz */
      UsbTrd = 0x6U;
 80053fe:	2306      	movs	r3, #6
 8005400:	617b      	str	r3, [r7, #20]
 8005402:	e007      	b.n	8005414 <USB_SetTurnaroundTime+0xf0>
    }
  }
  else if (speed == USBD_HS_SPEED)
 8005404:	79fb      	ldrb	r3, [r7, #7]
 8005406:	2b00      	cmp	r3, #0
 8005408:	d102      	bne.n	8005410 <USB_SetTurnaroundTime+0xec>
  {
    UsbTrd = USBD_HS_TRDT_VALUE;
 800540a:	2309      	movs	r3, #9
 800540c:	617b      	str	r3, [r7, #20]
 800540e:	e001      	b.n	8005414 <USB_SetTurnaroundTime+0xf0>
  }
  else
  {
    UsbTrd = USBD_DEFAULT_TRDT_VALUE;
 8005410:	2309      	movs	r3, #9
 8005412:	617b      	str	r3, [r7, #20]
  }

  USBx->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
 8005414:	68fb      	ldr	r3, [r7, #12]
 8005416:	68db      	ldr	r3, [r3, #12]
 8005418:	f423 5270 	bic.w	r2, r3, #15360	@ 0x3c00
 800541c:	68fb      	ldr	r3, [r7, #12]
 800541e:	60da      	str	r2, [r3, #12]
  USBx->GUSBCFG |= (uint32_t)((UsbTrd << 10) & USB_OTG_GUSBCFG_TRDT);
 8005420:	68fb      	ldr	r3, [r7, #12]
 8005422:	68da      	ldr	r2, [r3, #12]
 8005424:	697b      	ldr	r3, [r7, #20]
 8005426:	029b      	lsls	r3, r3, #10
 8005428:	f403 5370 	and.w	r3, r3, #15360	@ 0x3c00
 800542c:	431a      	orrs	r2, r3
 800542e:	68fb      	ldr	r3, [r7, #12]
 8005430:	60da      	str	r2, [r3, #12]

  return HAL_OK;
 8005432:	2300      	movs	r3, #0
}
 8005434:	4618      	mov	r0, r3
 8005436:	371c      	adds	r7, #28
 8005438:	46bd      	mov	sp, r7
 800543a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800543e:	4770      	bx	lr
 8005440:	00d8acbf 	.word	0x00d8acbf
 8005444:	00e4e1c0 	.word	0x00e4e1c0
 8005448:	00f42400 	.word	0x00f42400
 800544c:	01067380 	.word	0x01067380
 8005450:	011a499f 	.word	0x011a499f
 8005454:	01312cff 	.word	0x01312cff
 8005458:	014ca43f 	.word	0x014ca43f
 800545c:	016e3600 	.word	0x016e3600
 8005460:	01a6ab1f 	.word	0x01a6ab1f
 8005464:	01e84800 	.word	0x01e84800

08005468 <USB_EnableGlobalInt>:
  *         Enables the controller's Global Int in the AHB Config reg
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
 8005468:	b480      	push	{r7}
 800546a:	b083      	sub	sp, #12
 800546c:	af00      	add	r7, sp, #0
 800546e:	6078      	str	r0, [r7, #4]
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 8005470:	687b      	ldr	r3, [r7, #4]
 8005472:	689b      	ldr	r3, [r3, #8]
 8005474:	f043 0201 	orr.w	r2, r3, #1
 8005478:	687b      	ldr	r3, [r7, #4]
 800547a:	609a      	str	r2, [r3, #8]
  return HAL_OK;
 800547c:	2300      	movs	r3, #0
}
 800547e:	4618      	mov	r0, r3
 8005480:	370c      	adds	r7, #12
 8005482:	46bd      	mov	sp, r7
 8005484:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005488:	4770      	bx	lr

0800548a <USB_DisableGlobalInt>:
  *         Disable the controller's Global Int in the AHB Config reg
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
 800548a:	b480      	push	{r7}
 800548c:	b083      	sub	sp, #12
 800548e:	af00      	add	r7, sp, #0
 8005490:	6078      	str	r0, [r7, #4]
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 8005492:	687b      	ldr	r3, [r7, #4]
 8005494:	689b      	ldr	r3, [r3, #8]
 8005496:	f023 0201 	bic.w	r2, r3, #1
 800549a:	687b      	ldr	r3, [r7, #4]
 800549c:	609a      	str	r2, [r3, #8]
  return HAL_OK;
 800549e:	2300      	movs	r3, #0
}
 80054a0:	4618      	mov	r0, r3
 80054a2:	370c      	adds	r7, #12
 80054a4:	46bd      	mov	sp, r7
 80054a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80054aa:	4770      	bx	lr

080054ac <USB_SetCurrentMode>:
  *            @arg USB_DEVICE_MODE Peripheral mode
  *            @arg USB_HOST_MODE Host mode
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx, USB_OTG_ModeTypeDef mode)
{
 80054ac:	b580      	push	{r7, lr}
 80054ae:	b084      	sub	sp, #16
 80054b0:	af00      	add	r7, sp, #0
 80054b2:	6078      	str	r0, [r7, #4]
 80054b4:	460b      	mov	r3, r1
 80054b6:	70fb      	strb	r3, [r7, #3]
  uint32_t ms = 0U;
 80054b8:	2300      	movs	r3, #0
 80054ba:	60fb      	str	r3, [r7, #12]

  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 80054bc:	687b      	ldr	r3, [r7, #4]
 80054be:	68db      	ldr	r3, [r3, #12]
 80054c0:	f023 42c0 	bic.w	r2, r3, #1610612736	@ 0x60000000
 80054c4:	687b      	ldr	r3, [r7, #4]
 80054c6:	60da      	str	r2, [r3, #12]

  if (mode == USB_HOST_MODE)
 80054c8:	78fb      	ldrb	r3, [r7, #3]
 80054ca:	2b01      	cmp	r3, #1
 80054cc:	d115      	bne.n	80054fa <USB_SetCurrentMode+0x4e>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
 80054ce:	687b      	ldr	r3, [r7, #4]
 80054d0:	68db      	ldr	r3, [r3, #12]
 80054d2:	f043 5200 	orr.w	r2, r3, #536870912	@ 0x20000000
 80054d6:	687b      	ldr	r3, [r7, #4]
 80054d8:	60da      	str	r2, [r3, #12]

    do
    {
      HAL_Delay(10U);
 80054da:	200a      	movs	r0, #10
 80054dc:	f7fc fc4a 	bl	8001d74 <HAL_Delay>
      ms += 10U;
 80054e0:	68fb      	ldr	r3, [r7, #12]
 80054e2:	330a      	adds	r3, #10
 80054e4:	60fb      	str	r3, [r7, #12]
    } while ((USB_GetMode(USBx) != (uint32_t)USB_HOST_MODE) && (ms < HAL_USB_CURRENT_MODE_MAX_DELAY_MS));
 80054e6:	6878      	ldr	r0, [r7, #4]
 80054e8:	f001 f93f 	bl	800676a <USB_GetMode>
 80054ec:	4603      	mov	r3, r0
 80054ee:	2b01      	cmp	r3, #1
 80054f0:	d01e      	beq.n	8005530 <USB_SetCurrentMode+0x84>
 80054f2:	68fb      	ldr	r3, [r7, #12]
 80054f4:	2bc7      	cmp	r3, #199	@ 0xc7
 80054f6:	d9f0      	bls.n	80054da <USB_SetCurrentMode+0x2e>
 80054f8:	e01a      	b.n	8005530 <USB_SetCurrentMode+0x84>
  }
  else if (mode == USB_DEVICE_MODE)
 80054fa:	78fb      	ldrb	r3, [r7, #3]
 80054fc:	2b00      	cmp	r3, #0
 80054fe:	d115      	bne.n	800552c <USB_SetCurrentMode+0x80>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
 8005500:	687b      	ldr	r3, [r7, #4]
 8005502:	68db      	ldr	r3, [r3, #12]
 8005504:	f043 4280 	orr.w	r2, r3, #1073741824	@ 0x40000000
 8005508:	687b      	ldr	r3, [r7, #4]
 800550a:	60da      	str	r2, [r3, #12]

    do
    {
      HAL_Delay(10U);
 800550c:	200a      	movs	r0, #10
 800550e:	f7fc fc31 	bl	8001d74 <HAL_Delay>
      ms += 10U;
 8005512:	68fb      	ldr	r3, [r7, #12]
 8005514:	330a      	adds	r3, #10
 8005516:	60fb      	str	r3, [r7, #12]
    } while ((USB_GetMode(USBx) != (uint32_t)USB_DEVICE_MODE) && (ms < HAL_USB_CURRENT_MODE_MAX_DELAY_MS));
 8005518:	6878      	ldr	r0, [r7, #4]
 800551a:	f001 f926 	bl	800676a <USB_GetMode>
 800551e:	4603      	mov	r3, r0
 8005520:	2b00      	cmp	r3, #0
 8005522:	d005      	beq.n	8005530 <USB_SetCurrentMode+0x84>
 8005524:	68fb      	ldr	r3, [r7, #12]
 8005526:	2bc7      	cmp	r3, #199	@ 0xc7
 8005528:	d9f0      	bls.n	800550c <USB_SetCurrentMode+0x60>
 800552a:	e001      	b.n	8005530 <USB_SetCurrentMode+0x84>
  }
  else
  {
    return HAL_ERROR;
 800552c:	2301      	movs	r3, #1
 800552e:	e005      	b.n	800553c <USB_SetCurrentMode+0x90>
  }

  if (ms == HAL_USB_CURRENT_MODE_MAX_DELAY_MS)
 8005530:	68fb      	ldr	r3, [r7, #12]
 8005532:	2bc8      	cmp	r3, #200	@ 0xc8
 8005534:	d101      	bne.n	800553a <USB_SetCurrentMode+0x8e>
  {
    return HAL_ERROR;
 8005536:	2301      	movs	r3, #1
 8005538:	e000      	b.n	800553c <USB_SetCurrentMode+0x90>
  }

  return HAL_OK;
 800553a:	2300      	movs	r3, #0
}
 800553c:	4618      	mov	r0, r3
 800553e:	3710      	adds	r7, #16
 8005540:	46bd      	mov	sp, r7
 8005542:	bd80      	pop	{r7, pc}

08005544 <USB_DevInit>:
  * @param  cfg   pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 8005544:	b084      	sub	sp, #16
 8005546:	b580      	push	{r7, lr}
 8005548:	b086      	sub	sp, #24
 800554a:	af00      	add	r7, sp, #0
 800554c:	6078      	str	r0, [r7, #4]
 800554e:	f107 0024 	add.w	r0, r7, #36	@ 0x24
 8005552:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  HAL_StatusTypeDef ret = HAL_OK;
 8005556:	2300      	movs	r3, #0
 8005558:	75fb      	strb	r3, [r7, #23]
  uint32_t USBx_BASE = (uint32_t)USBx;
 800555a:	687b      	ldr	r3, [r7, #4]
 800555c:	60fb      	str	r3, [r7, #12]
  uint32_t i;

  for (i = 0U; i < 15U; i++)
 800555e:	2300      	movs	r3, #0
 8005560:	613b      	str	r3, [r7, #16]
 8005562:	e009      	b.n	8005578 <USB_DevInit+0x34>
  {
    USBx->DIEPTXF[i] = 0U;
 8005564:	687a      	ldr	r2, [r7, #4]
 8005566:	693b      	ldr	r3, [r7, #16]
 8005568:	3340      	adds	r3, #64	@ 0x40
 800556a:	009b      	lsls	r3, r3, #2
 800556c:	4413      	add	r3, r2
 800556e:	2200      	movs	r2, #0
 8005570:	605a      	str	r2, [r3, #4]
  for (i = 0U; i < 15U; i++)
 8005572:	693b      	ldr	r3, [r7, #16]
 8005574:	3301      	adds	r3, #1
 8005576:	613b      	str	r3, [r7, #16]
 8005578:	693b      	ldr	r3, [r7, #16]
 800557a:	2b0e      	cmp	r3, #14
 800557c:	d9f2      	bls.n	8005564 <USB_DevInit+0x20>
    /* Enable HW VBUS sensing */
    USBx->GCCFG |= USB_OTG_GCCFG_VBDEN;
  }
#else
  /* VBUS Sensing setup */
  if (cfg.vbus_sensing_enable == 0U)
 800557e:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
 8005582:	2b00      	cmp	r3, #0
 8005584:	d11c      	bne.n	80055c0 <USB_DevInit+0x7c>
  {
    /*
     * Disable HW VBUS sensing. VBUS is internally considered to be always
     * at VBUS-Valid level (5V).
     */
    USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 8005586:	68fb      	ldr	r3, [r7, #12]
 8005588:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800558c:	685b      	ldr	r3, [r3, #4]
 800558e:	68fa      	ldr	r2, [r7, #12]
 8005590:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8005594:	f043 0302 	orr.w	r3, r3, #2
 8005598:	6053      	str	r3, [r2, #4]
    USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
 800559a:	687b      	ldr	r3, [r7, #4]
 800559c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800559e:	f443 1200 	orr.w	r2, r3, #2097152	@ 0x200000
 80055a2:	687b      	ldr	r3, [r7, #4]
 80055a4:	639a      	str	r2, [r3, #56]	@ 0x38
    USBx->GCCFG &= ~USB_OTG_GCCFG_VBUSBSEN;
 80055a6:	687b      	ldr	r3, [r7, #4]
 80055a8:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80055aa:	f423 2200 	bic.w	r2, r3, #524288	@ 0x80000
 80055ae:	687b      	ldr	r3, [r7, #4]
 80055b0:	639a      	str	r2, [r3, #56]	@ 0x38
    USBx->GCCFG &= ~USB_OTG_GCCFG_VBUSASEN;
 80055b2:	687b      	ldr	r3, [r7, #4]
 80055b4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80055b6:	f423 2280 	bic.w	r2, r3, #262144	@ 0x40000
 80055ba:	687b      	ldr	r3, [r7, #4]
 80055bc:	639a      	str	r2, [r3, #56]	@ 0x38
 80055be:	e00b      	b.n	80055d8 <USB_DevInit+0x94>
  }
  else
  {
    /* Enable HW VBUS sensing */
    USBx->GCCFG &= ~USB_OTG_GCCFG_NOVBUSSENS;
 80055c0:	687b      	ldr	r3, [r7, #4]
 80055c2:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80055c4:	f423 1200 	bic.w	r2, r3, #2097152	@ 0x200000
 80055c8:	687b      	ldr	r3, [r7, #4]
 80055ca:	639a      	str	r2, [r3, #56]	@ 0x38
    USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;
 80055cc:	687b      	ldr	r3, [r7, #4]
 80055ce:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80055d0:	f443 2200 	orr.w	r2, r3, #524288	@ 0x80000
 80055d4:	687b      	ldr	r3, [r7, #4]
 80055d6:	639a      	str	r2, [r3, #56]	@ 0x38
#endif /* defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) ||
          defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) ||
          defined(STM32F423xx) */

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
 80055d8:	68fb      	ldr	r3, [r7, #12]
 80055da:	f503 6360 	add.w	r3, r3, #3584	@ 0xe00
 80055de:	461a      	mov	r2, r3
 80055e0:	2300      	movs	r3, #0
 80055e2:	6013      	str	r3, [r2, #0]

  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 80055e4:	f897 3029 	ldrb.w	r3, [r7, #41]	@ 0x29
 80055e8:	2b01      	cmp	r3, #1
 80055ea:	d10d      	bne.n	8005608 <USB_DevInit+0xc4>
  {
    if (cfg.speed == USBD_HS_SPEED)
 80055ec:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 80055f0:	2b00      	cmp	r3, #0
 80055f2:	d104      	bne.n	80055fe <USB_DevInit+0xba>
    {
      /* Set Core speed to High speed mode */
      (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_HIGH);
 80055f4:	2100      	movs	r1, #0
 80055f6:	6878      	ldr	r0, [r7, #4]
 80055f8:	f000 f968 	bl	80058cc <USB_SetDevSpeed>
 80055fc:	e008      	b.n	8005610 <USB_DevInit+0xcc>
    }
    else
    {
      /* Set Core speed to Full speed mode */
      (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_HIGH_IN_FULL);
 80055fe:	2101      	movs	r1, #1
 8005600:	6878      	ldr	r0, [r7, #4]
 8005602:	f000 f963 	bl	80058cc <USB_SetDevSpeed>
 8005606:	e003      	b.n	8005610 <USB_DevInit+0xcc>
    }
  }
  else
  {
    /* Set Core speed to Full speed mode */
    (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_FULL);
 8005608:	2103      	movs	r1, #3
 800560a:	6878      	ldr	r0, [r7, #4]
 800560c:	f000 f95e 	bl	80058cc <USB_SetDevSpeed>
  }

  /* Flush the FIFOs */
  if (USB_FlushTxFifo(USBx, 0x10U) != HAL_OK) /* all Tx FIFOs */
 8005610:	2110      	movs	r1, #16
 8005612:	6878      	ldr	r0, [r7, #4]
 8005614:	f000 f8fa 	bl	800580c <USB_FlushTxFifo>
 8005618:	4603      	mov	r3, r0
 800561a:	2b00      	cmp	r3, #0
 800561c:	d001      	beq.n	8005622 <USB_DevInit+0xde>
  {
    ret = HAL_ERROR;
 800561e:	2301      	movs	r3, #1
 8005620:	75fb      	strb	r3, [r7, #23]
  }

  if (USB_FlushRxFifo(USBx) != HAL_OK)
 8005622:	6878      	ldr	r0, [r7, #4]
 8005624:	f000 f924 	bl	8005870 <USB_FlushRxFifo>
 8005628:	4603      	mov	r3, r0
 800562a:	2b00      	cmp	r3, #0
 800562c:	d001      	beq.n	8005632 <USB_DevInit+0xee>
  {
    ret = HAL_ERROR;
 800562e:	2301      	movs	r3, #1
 8005630:	75fb      	strb	r3, [r7, #23]
  }

  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
 8005632:	68fb      	ldr	r3, [r7, #12]
 8005634:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8005638:	461a      	mov	r2, r3
 800563a:	2300      	movs	r3, #0
 800563c:	6113      	str	r3, [r2, #16]
  USBx_DEVICE->DOEPMSK = 0U;
 800563e:	68fb      	ldr	r3, [r7, #12]
 8005640:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8005644:	461a      	mov	r2, r3
 8005646:	2300      	movs	r3, #0
 8005648:	6153      	str	r3, [r2, #20]
  USBx_DEVICE->DAINTMSK = 0U;
 800564a:	68fb      	ldr	r3, [r7, #12]
 800564c:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8005650:	461a      	mov	r2, r3
 8005652:	2300      	movs	r3, #0
 8005654:	61d3      	str	r3, [r2, #28]

  for (i = 0U; i < cfg.dev_endpoints; i++)
 8005656:	2300      	movs	r3, #0
 8005658:	613b      	str	r3, [r7, #16]
 800565a:	e043      	b.n	80056e4 <USB_DevInit+0x1a0>
  {
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 800565c:	693b      	ldr	r3, [r7, #16]
 800565e:	015a      	lsls	r2, r3, #5
 8005660:	68fb      	ldr	r3, [r7, #12]
 8005662:	4413      	add	r3, r2
 8005664:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005668:	681b      	ldr	r3, [r3, #0]
 800566a:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 800566e:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8005672:	d118      	bne.n	80056a6 <USB_DevInit+0x162>
    {
      if (i == 0U)
 8005674:	693b      	ldr	r3, [r7, #16]
 8005676:	2b00      	cmp	r3, #0
 8005678:	d10a      	bne.n	8005690 <USB_DevInit+0x14c>
      {
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_SNAK;
 800567a:	693b      	ldr	r3, [r7, #16]
 800567c:	015a      	lsls	r2, r3, #5
 800567e:	68fb      	ldr	r3, [r7, #12]
 8005680:	4413      	add	r3, r2
 8005682:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005686:	461a      	mov	r2, r3
 8005688:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
 800568c:	6013      	str	r3, [r2, #0]
 800568e:	e013      	b.n	80056b8 <USB_DevInit+0x174>
      }
      else
      {
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK;
 8005690:	693b      	ldr	r3, [r7, #16]
 8005692:	015a      	lsls	r2, r3, #5
 8005694:	68fb      	ldr	r3, [r7, #12]
 8005696:	4413      	add	r3, r2
 8005698:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800569c:	461a      	mov	r2, r3
 800569e:	f04f 4390 	mov.w	r3, #1207959552	@ 0x48000000
 80056a2:	6013      	str	r3, [r2, #0]
 80056a4:	e008      	b.n	80056b8 <USB_DevInit+0x174>
      }
    }
    else
    {
      USBx_INEP(i)->DIEPCTL = 0U;
 80056a6:	693b      	ldr	r3, [r7, #16]
 80056a8:	015a      	lsls	r2, r3, #5
 80056aa:	68fb      	ldr	r3, [r7, #12]
 80056ac:	4413      	add	r3, r2
 80056ae:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80056b2:	461a      	mov	r2, r3
 80056b4:	2300      	movs	r3, #0
 80056b6:	6013      	str	r3, [r2, #0]
    }

    USBx_INEP(i)->DIEPTSIZ = 0U;
 80056b8:	693b      	ldr	r3, [r7, #16]
 80056ba:	015a      	lsls	r2, r3, #5
 80056bc:	68fb      	ldr	r3, [r7, #12]
 80056be:	4413      	add	r3, r2
 80056c0:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80056c4:	461a      	mov	r2, r3
 80056c6:	2300      	movs	r3, #0
 80056c8:	6113      	str	r3, [r2, #16]
    USBx_INEP(i)->DIEPINT  = 0xFB7FU;
 80056ca:	693b      	ldr	r3, [r7, #16]
 80056cc:	015a      	lsls	r2, r3, #5
 80056ce:	68fb      	ldr	r3, [r7, #12]
 80056d0:	4413      	add	r3, r2
 80056d2:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80056d6:	461a      	mov	r2, r3
 80056d8:	f64f 337f 	movw	r3, #64383	@ 0xfb7f
 80056dc:	6093      	str	r3, [r2, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 80056de:	693b      	ldr	r3, [r7, #16]
 80056e0:	3301      	adds	r3, #1
 80056e2:	613b      	str	r3, [r7, #16]
 80056e4:	f897 3024 	ldrb.w	r3, [r7, #36]	@ 0x24
 80056e8:	461a      	mov	r2, r3
 80056ea:	693b      	ldr	r3, [r7, #16]
 80056ec:	4293      	cmp	r3, r2
 80056ee:	d3b5      	bcc.n	800565c <USB_DevInit+0x118>
  }

  for (i = 0U; i < cfg.dev_endpoints; i++)
 80056f0:	2300      	movs	r3, #0
 80056f2:	613b      	str	r3, [r7, #16]
 80056f4:	e043      	b.n	800577e <USB_DevInit+0x23a>
  {
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 80056f6:	693b      	ldr	r3, [r7, #16]
 80056f8:	015a      	lsls	r2, r3, #5
 80056fa:	68fb      	ldr	r3, [r7, #12]
 80056fc:	4413      	add	r3, r2
 80056fe:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8005702:	681b      	ldr	r3, [r3, #0]
 8005704:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 8005708:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 800570c:	d118      	bne.n	8005740 <USB_DevInit+0x1fc>
    {
      if (i == 0U)
 800570e:	693b      	ldr	r3, [r7, #16]
 8005710:	2b00      	cmp	r3, #0
 8005712:	d10a      	bne.n	800572a <USB_DevInit+0x1e6>
      {
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_SNAK;
 8005714:	693b      	ldr	r3, [r7, #16]
 8005716:	015a      	lsls	r2, r3, #5
 8005718:	68fb      	ldr	r3, [r7, #12]
 800571a:	4413      	add	r3, r2
 800571c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8005720:	461a      	mov	r2, r3
 8005722:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
 8005726:	6013      	str	r3, [r2, #0]
 8005728:	e013      	b.n	8005752 <USB_DevInit+0x20e>
      }
      else
      {
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK;
 800572a:	693b      	ldr	r3, [r7, #16]
 800572c:	015a      	lsls	r2, r3, #5
 800572e:	68fb      	ldr	r3, [r7, #12]
 8005730:	4413      	add	r3, r2
 8005732:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8005736:	461a      	mov	r2, r3
 8005738:	f04f 4390 	mov.w	r3, #1207959552	@ 0x48000000
 800573c:	6013      	str	r3, [r2, #0]
 800573e:	e008      	b.n	8005752 <USB_DevInit+0x20e>
      }
    }
    else
    {
      USBx_OUTEP(i)->DOEPCTL = 0U;
 8005740:	693b      	ldr	r3, [r7, #16]
 8005742:	015a      	lsls	r2, r3, #5
 8005744:	68fb      	ldr	r3, [r7, #12]
 8005746:	4413      	add	r3, r2
 8005748:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800574c:	461a      	mov	r2, r3
 800574e:	2300      	movs	r3, #0
 8005750:	6013      	str	r3, [r2, #0]
    }

    USBx_OUTEP(i)->DOEPTSIZ = 0U;
 8005752:	693b      	ldr	r3, [r7, #16]
 8005754:	015a      	lsls	r2, r3, #5
 8005756:	68fb      	ldr	r3, [r7, #12]
 8005758:	4413      	add	r3, r2
 800575a:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800575e:	461a      	mov	r2, r3
 8005760:	2300      	movs	r3, #0
 8005762:	6113      	str	r3, [r2, #16]
    USBx_OUTEP(i)->DOEPINT  = 0xFB7FU;
 8005764:	693b      	ldr	r3, [r7, #16]
 8005766:	015a      	lsls	r2, r3, #5
 8005768:	68fb      	ldr	r3, [r7, #12]
 800576a:	4413      	add	r3, r2
 800576c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8005770:	461a      	mov	r2, r3
 8005772:	f64f 337f 	movw	r3, #64383	@ 0xfb7f
 8005776:	6093      	str	r3, [r2, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8005778:	693b      	ldr	r3, [r7, #16]
 800577a:	3301      	adds	r3, #1
 800577c:	613b      	str	r3, [r7, #16]
 800577e:	f897 3024 	ldrb.w	r3, [r7, #36]	@ 0x24
 8005782:	461a      	mov	r2, r3
 8005784:	693b      	ldr	r3, [r7, #16]
 8005786:	4293      	cmp	r3, r2
 8005788:	d3b5      	bcc.n	80056f6 <USB_DevInit+0x1b2>
  }

  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 800578a:	68fb      	ldr	r3, [r7, #12]
 800578c:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8005790:	691b      	ldr	r3, [r3, #16]
 8005792:	68fa      	ldr	r2, [r7, #12]
 8005794:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8005798:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 800579c:	6113      	str	r3, [r2, #16]

  /* Disable all interrupts. */
  USBx->GINTMSK = 0U;
 800579e:	687b      	ldr	r3, [r7, #4]
 80057a0:	2200      	movs	r2, #0
 80057a2:	619a      	str	r2, [r3, #24]

  /* Clear any pending interrupts */
  USBx->GINTSTS = 0xBFFFFFFFU;
 80057a4:	687b      	ldr	r3, [r7, #4]
 80057a6:	f06f 4280 	mvn.w	r2, #1073741824	@ 0x40000000
 80057aa:	615a      	str	r2, [r3, #20]

  /* Enable the common interrupts */
  if (cfg.dma_enable == 0U)
 80057ac:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 80057b0:	2b00      	cmp	r3, #0
 80057b2:	d105      	bne.n	80057c0 <USB_DevInit+0x27c>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
 80057b4:	687b      	ldr	r3, [r7, #4]
 80057b6:	699b      	ldr	r3, [r3, #24]
 80057b8:	f043 0210 	orr.w	r2, r3, #16
 80057bc:	687b      	ldr	r3, [r7, #4]
 80057be:	619a      	str	r2, [r3, #24]
  }

  /* Enable interrupts matching to the Device mode ONLY */
  USBx->GINTMSK |= USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |
 80057c0:	687b      	ldr	r3, [r7, #4]
 80057c2:	699a      	ldr	r2, [r3, #24]
 80057c4:	4b10      	ldr	r3, [pc, #64]	@ (8005808 <USB_DevInit+0x2c4>)
 80057c6:	4313      	orrs	r3, r2
 80057c8:	687a      	ldr	r2, [r7, #4]
 80057ca:	6193      	str	r3, [r2, #24]
                   USB_OTG_GINTMSK_ENUMDNEM | USB_OTG_GINTMSK_IEPINT |
                   USB_OTG_GINTMSK_OEPINT   | USB_OTG_GINTMSK_IISOIXFRM |
                   USB_OTG_GINTMSK_PXFRM_IISOOXFRM | USB_OTG_GINTMSK_WUIM;

  if (cfg.Sof_enable != 0U)
 80057cc:	f897 302a 	ldrb.w	r3, [r7, #42]	@ 0x2a
 80057d0:	2b00      	cmp	r3, #0
 80057d2:	d005      	beq.n	80057e0 <USB_DevInit+0x29c>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
 80057d4:	687b      	ldr	r3, [r7, #4]
 80057d6:	699b      	ldr	r3, [r3, #24]
 80057d8:	f043 0208 	orr.w	r2, r3, #8
 80057dc:	687b      	ldr	r3, [r7, #4]
 80057de:	619a      	str	r2, [r3, #24]
  }

  if (cfg.vbus_sensing_enable == 1U)
 80057e0:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
 80057e4:	2b01      	cmp	r3, #1
 80057e6:	d107      	bne.n	80057f8 <USB_DevInit+0x2b4>
  {
    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT);
 80057e8:	687b      	ldr	r3, [r7, #4]
 80057ea:	699b      	ldr	r3, [r3, #24]
 80057ec:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 80057f0:	f043 0304 	orr.w	r3, r3, #4
 80057f4:	687a      	ldr	r2, [r7, #4]
 80057f6:	6193      	str	r3, [r2, #24]
  }

  return ret;
 80057f8:	7dfb      	ldrb	r3, [r7, #23]
}
 80057fa:	4618      	mov	r0, r3
 80057fc:	3718      	adds	r7, #24
 80057fe:	46bd      	mov	sp, r7
 8005800:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 8005804:	b004      	add	sp, #16
 8005806:	4770      	bx	lr
 8005808:	803c3800 	.word	0x803c3800

0800580c <USB_FlushTxFifo>:
  *         This parameter can be a value from 1 to 15
            15 means Flush all Tx FIFOs
  * @retval HAL status
  */
HAL_StatusTypeDef USB_FlushTxFifo(USB_OTG_GlobalTypeDef *USBx, uint32_t num)
{
 800580c:	b480      	push	{r7}
 800580e:	b085      	sub	sp, #20
 8005810:	af00      	add	r7, sp, #0
 8005812:	6078      	str	r0, [r7, #4]
 8005814:	6039      	str	r1, [r7, #0]
  __IO uint32_t count = 0U;
 8005816:	2300      	movs	r3, #0
 8005818:	60fb      	str	r3, [r7, #12]

  /* Wait for AHB master IDLE state. */
  do
  {
    count++;
 800581a:	68fb      	ldr	r3, [r7, #12]
 800581c:	3301      	adds	r3, #1
 800581e:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 8005820:	68fb      	ldr	r3, [r7, #12]
 8005822:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 8005826:	d901      	bls.n	800582c <USB_FlushTxFifo+0x20>
    {
      return HAL_TIMEOUT;
 8005828:	2303      	movs	r3, #3
 800582a:	e01b      	b.n	8005864 <USB_FlushTxFifo+0x58>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 800582c:	687b      	ldr	r3, [r7, #4]
 800582e:	691b      	ldr	r3, [r3, #16]
 8005830:	2b00      	cmp	r3, #0
 8005832:	daf2      	bge.n	800581a <USB_FlushTxFifo+0xe>

  /* Flush TX Fifo */
  count = 0U;
 8005834:	2300      	movs	r3, #0
 8005836:	60fb      	str	r3, [r7, #12]
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 8005838:	683b      	ldr	r3, [r7, #0]
 800583a:	019b      	lsls	r3, r3, #6
 800583c:	f043 0220 	orr.w	r2, r3, #32
 8005840:	687b      	ldr	r3, [r7, #4]
 8005842:	611a      	str	r2, [r3, #16]

  do
  {
    count++;
 8005844:	68fb      	ldr	r3, [r7, #12]
 8005846:	3301      	adds	r3, #1
 8005848:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 800584a:	68fb      	ldr	r3, [r7, #12]
 800584c:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 8005850:	d901      	bls.n	8005856 <USB_FlushTxFifo+0x4a>
    {
      return HAL_TIMEOUT;
 8005852:	2303      	movs	r3, #3
 8005854:	e006      	b.n	8005864 <USB_FlushTxFifo+0x58>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 8005856:	687b      	ldr	r3, [r7, #4]
 8005858:	691b      	ldr	r3, [r3, #16]
 800585a:	f003 0320 	and.w	r3, r3, #32
 800585e:	2b20      	cmp	r3, #32
 8005860:	d0f0      	beq.n	8005844 <USB_FlushTxFifo+0x38>

  return HAL_OK;
 8005862:	2300      	movs	r3, #0
}
 8005864:	4618      	mov	r0, r3
 8005866:	3714      	adds	r7, #20
 8005868:	46bd      	mov	sp, r7
 800586a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800586e:	4770      	bx	lr

08005870 <USB_FlushRxFifo>:
  * @brief  USB_FlushRxFifo  Flush Rx FIFO
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
{
 8005870:	b480      	push	{r7}
 8005872:	b085      	sub	sp, #20
 8005874:	af00      	add	r7, sp, #0
 8005876:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0U;
 8005878:	2300      	movs	r3, #0
 800587a:	60fb      	str	r3, [r7, #12]

  /* Wait for AHB master IDLE state. */
  do
  {
    count++;
 800587c:	68fb      	ldr	r3, [r7, #12]
 800587e:	3301      	adds	r3, #1
 8005880:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 8005882:	68fb      	ldr	r3, [r7, #12]
 8005884:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 8005888:	d901      	bls.n	800588e <USB_FlushRxFifo+0x1e>
    {
      return HAL_TIMEOUT;
 800588a:	2303      	movs	r3, #3
 800588c:	e018      	b.n	80058c0 <USB_FlushRxFifo+0x50>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 800588e:	687b      	ldr	r3, [r7, #4]
 8005890:	691b      	ldr	r3, [r3, #16]
 8005892:	2b00      	cmp	r3, #0
 8005894:	daf2      	bge.n	800587c <USB_FlushRxFifo+0xc>

  /* Flush RX Fifo */
  count = 0U;
 8005896:	2300      	movs	r3, #0
 8005898:	60fb      	str	r3, [r7, #12]
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 800589a:	687b      	ldr	r3, [r7, #4]
 800589c:	2210      	movs	r2, #16
 800589e:	611a      	str	r2, [r3, #16]

  do
  {
    count++;
 80058a0:	68fb      	ldr	r3, [r7, #12]
 80058a2:	3301      	adds	r3, #1
 80058a4:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 80058a6:	68fb      	ldr	r3, [r7, #12]
 80058a8:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 80058ac:	d901      	bls.n	80058b2 <USB_FlushRxFifo+0x42>
    {
      return HAL_TIMEOUT;
 80058ae:	2303      	movs	r3, #3
 80058b0:	e006      	b.n	80058c0 <USB_FlushRxFifo+0x50>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 80058b2:	687b      	ldr	r3, [r7, #4]
 80058b4:	691b      	ldr	r3, [r3, #16]
 80058b6:	f003 0310 	and.w	r3, r3, #16
 80058ba:	2b10      	cmp	r3, #16
 80058bc:	d0f0      	beq.n	80058a0 <USB_FlushRxFifo+0x30>

  return HAL_OK;
 80058be:	2300      	movs	r3, #0
}
 80058c0:	4618      	mov	r0, r3
 80058c2:	3714      	adds	r7, #20
 80058c4:	46bd      	mov	sp, r7
 80058c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80058ca:	4770      	bx	lr

080058cc <USB_SetDevSpeed>:
  *            @arg USB_OTG_SPEED_HIGH_IN_FULL: High speed core in Full Speed mode
  *            @arg USB_OTG_SPEED_FULL: Full speed mode
  * @retval  Hal status
  */
HAL_StatusTypeDef USB_SetDevSpeed(const USB_OTG_GlobalTypeDef *USBx, uint8_t speed)
{
 80058cc:	b480      	push	{r7}
 80058ce:	b085      	sub	sp, #20
 80058d0:	af00      	add	r7, sp, #0
 80058d2:	6078      	str	r0, [r7, #4]
 80058d4:	460b      	mov	r3, r1
 80058d6:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80058d8:	687b      	ldr	r3, [r7, #4]
 80058da:	60fb      	str	r3, [r7, #12]

  USBx_DEVICE->DCFG |= speed;
 80058dc:	68fb      	ldr	r3, [r7, #12]
 80058de:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80058e2:	681a      	ldr	r2, [r3, #0]
 80058e4:	78fb      	ldrb	r3, [r7, #3]
 80058e6:	68f9      	ldr	r1, [r7, #12]
 80058e8:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 80058ec:	4313      	orrs	r3, r2
 80058ee:	600b      	str	r3, [r1, #0]
  return HAL_OK;
 80058f0:	2300      	movs	r3, #0
}
 80058f2:	4618      	mov	r0, r3
 80058f4:	3714      	adds	r7, #20
 80058f6:	46bd      	mov	sp, r7
 80058f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80058fc:	4770      	bx	lr

080058fe <USB_GetDevSpeed>:
  *          This parameter can be one of these values:
  *            @arg USBD_HS_SPEED: High speed mode
  *            @arg USBD_FS_SPEED: Full speed mode
  */
uint8_t USB_GetDevSpeed(const USB_OTG_GlobalTypeDef *USBx)
{
 80058fe:	b480      	push	{r7}
 8005900:	b087      	sub	sp, #28
 8005902:	af00      	add	r7, sp, #0
 8005904:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8005906:	687b      	ldr	r3, [r7, #4]
 8005908:	613b      	str	r3, [r7, #16]
  uint8_t speed;
  uint32_t DevEnumSpeed = USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD;
 800590a:	693b      	ldr	r3, [r7, #16]
 800590c:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8005910:	689b      	ldr	r3, [r3, #8]
 8005912:	f003 0306 	and.w	r3, r3, #6
 8005916:	60fb      	str	r3, [r7, #12]

  if (DevEnumSpeed == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
 8005918:	68fb      	ldr	r3, [r7, #12]
 800591a:	2b00      	cmp	r3, #0
 800591c:	d102      	bne.n	8005924 <USB_GetDevSpeed+0x26>
  {
    speed = USBD_HS_SPEED;
 800591e:	2300      	movs	r3, #0
 8005920:	75fb      	strb	r3, [r7, #23]
 8005922:	e00a      	b.n	800593a <USB_GetDevSpeed+0x3c>
  }
  else if ((DevEnumSpeed == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ) ||
 8005924:	68fb      	ldr	r3, [r7, #12]
 8005926:	2b02      	cmp	r3, #2
 8005928:	d002      	beq.n	8005930 <USB_GetDevSpeed+0x32>
 800592a:	68fb      	ldr	r3, [r7, #12]
 800592c:	2b06      	cmp	r3, #6
 800592e:	d102      	bne.n	8005936 <USB_GetDevSpeed+0x38>
           (DevEnumSpeed == DSTS_ENUMSPD_FS_PHY_48MHZ))
  {
    speed = USBD_FS_SPEED;
 8005930:	2302      	movs	r3, #2
 8005932:	75fb      	strb	r3, [r7, #23]
 8005934:	e001      	b.n	800593a <USB_GetDevSpeed+0x3c>
  }
  else
  {
    speed = 0xFU;
 8005936:	230f      	movs	r3, #15
 8005938:	75fb      	strb	r3, [r7, #23]
  }

  return speed;
 800593a:	7dfb      	ldrb	r3, [r7, #23]
}
 800593c:	4618      	mov	r0, r3
 800593e:	371c      	adds	r7, #28
 8005940:	46bd      	mov	sp, r7
 8005942:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005946:	4770      	bx	lr

08005948 <USB_ActivateEndpoint>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateEndpoint(const USB_OTG_GlobalTypeDef *USBx, const USB_OTG_EPTypeDef *ep)
{
 8005948:	b480      	push	{r7}
 800594a:	b085      	sub	sp, #20
 800594c:	af00      	add	r7, sp, #0
 800594e:	6078      	str	r0, [r7, #4]
 8005950:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8005952:	687b      	ldr	r3, [r7, #4]
 8005954:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
 8005956:	683b      	ldr	r3, [r7, #0]
 8005958:	781b      	ldrb	r3, [r3, #0]
 800595a:	60bb      	str	r3, [r7, #8]

  if (ep->is_in == 1U)
 800595c:	683b      	ldr	r3, [r7, #0]
 800595e:	785b      	ldrb	r3, [r3, #1]
 8005960:	2b01      	cmp	r3, #1
 8005962:	d13a      	bne.n	80059da <USB_ActivateEndpoint+0x92>
  {
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK));
 8005964:	68fb      	ldr	r3, [r7, #12]
 8005966:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800596a:	69da      	ldr	r2, [r3, #28]
 800596c:	683b      	ldr	r3, [r7, #0]
 800596e:	781b      	ldrb	r3, [r3, #0]
 8005970:	f003 030f 	and.w	r3, r3, #15
 8005974:	2101      	movs	r1, #1
 8005976:	fa01 f303 	lsl.w	r3, r1, r3
 800597a:	b29b      	uxth	r3, r3
 800597c:	68f9      	ldr	r1, [r7, #12]
 800597e:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 8005982:	4313      	orrs	r3, r2
 8005984:	61cb      	str	r3, [r1, #28]

    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_USBAEP) == 0U)
 8005986:	68bb      	ldr	r3, [r7, #8]
 8005988:	015a      	lsls	r2, r3, #5
 800598a:	68fb      	ldr	r3, [r7, #12]
 800598c:	4413      	add	r3, r2
 800598e:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005992:	681b      	ldr	r3, [r3, #0]
 8005994:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 8005998:	2b00      	cmp	r3, #0
 800599a:	d155      	bne.n	8005a48 <USB_ActivateEndpoint+0x100>
    {
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 800599c:	68bb      	ldr	r3, [r7, #8]
 800599e:	015a      	lsls	r2, r3, #5
 80059a0:	68fb      	ldr	r3, [r7, #12]
 80059a2:	4413      	add	r3, r2
 80059a4:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80059a8:	681a      	ldr	r2, [r3, #0]
 80059aa:	683b      	ldr	r3, [r7, #0]
 80059ac:	689b      	ldr	r3, [r3, #8]
 80059ae:	f3c3 010a 	ubfx	r1, r3, #0, #11
                                   ((uint32_t)ep->type << 18) | (epnum << 22) |
 80059b2:	683b      	ldr	r3, [r7, #0]
 80059b4:	791b      	ldrb	r3, [r3, #4]
 80059b6:	049b      	lsls	r3, r3, #18
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 80059b8:	4319      	orrs	r1, r3
                                   ((uint32_t)ep->type << 18) | (epnum << 22) |
 80059ba:	68bb      	ldr	r3, [r7, #8]
 80059bc:	059b      	lsls	r3, r3, #22
 80059be:	430b      	orrs	r3, r1
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 80059c0:	4313      	orrs	r3, r2
 80059c2:	68ba      	ldr	r2, [r7, #8]
 80059c4:	0151      	lsls	r1, r2, #5
 80059c6:	68fa      	ldr	r2, [r7, #12]
 80059c8:	440a      	add	r2, r1
 80059ca:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 80059ce:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 80059d2:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 80059d6:	6013      	str	r3, [r2, #0]
 80059d8:	e036      	b.n	8005a48 <USB_ActivateEndpoint+0x100>
                                   USB_OTG_DIEPCTL_USBAEP;
    }
  }
  else
  {
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16);
 80059da:	68fb      	ldr	r3, [r7, #12]
 80059dc:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80059e0:	69da      	ldr	r2, [r3, #28]
 80059e2:	683b      	ldr	r3, [r7, #0]
 80059e4:	781b      	ldrb	r3, [r3, #0]
 80059e6:	f003 030f 	and.w	r3, r3, #15
 80059ea:	2101      	movs	r1, #1
 80059ec:	fa01 f303 	lsl.w	r3, r1, r3
 80059f0:	041b      	lsls	r3, r3, #16
 80059f2:	68f9      	ldr	r1, [r7, #12]
 80059f4:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 80059f8:	4313      	orrs	r3, r2
 80059fa:	61cb      	str	r3, [r1, #28]

    if (((USBx_OUTEP(epnum)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
 80059fc:	68bb      	ldr	r3, [r7, #8]
 80059fe:	015a      	lsls	r2, r3, #5
 8005a00:	68fb      	ldr	r3, [r7, #12]
 8005a02:	4413      	add	r3, r2
 8005a04:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8005a08:	681b      	ldr	r3, [r3, #0]
 8005a0a:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 8005a0e:	2b00      	cmp	r3, #0
 8005a10:	d11a      	bne.n	8005a48 <USB_ActivateEndpoint+0x100>
    {
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
 8005a12:	68bb      	ldr	r3, [r7, #8]
 8005a14:	015a      	lsls	r2, r3, #5
 8005a16:	68fb      	ldr	r3, [r7, #12]
 8005a18:	4413      	add	r3, r2
 8005a1a:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8005a1e:	681a      	ldr	r2, [r3, #0]
 8005a20:	683b      	ldr	r3, [r7, #0]
 8005a22:	689b      	ldr	r3, [r3, #8]
 8005a24:	f3c3 010a 	ubfx	r1, r3, #0, #11
                                    ((uint32_t)ep->type << 18) |
 8005a28:	683b      	ldr	r3, [r7, #0]
 8005a2a:	791b      	ldrb	r3, [r3, #4]
 8005a2c:	049b      	lsls	r3, r3, #18
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
 8005a2e:	430b      	orrs	r3, r1
 8005a30:	4313      	orrs	r3, r2
 8005a32:	68ba      	ldr	r2, [r7, #8]
 8005a34:	0151      	lsls	r1, r2, #5
 8005a36:	68fa      	ldr	r2, [r7, #12]
 8005a38:	440a      	add	r2, r1
 8005a3a:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8005a3e:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8005a42:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 8005a46:	6013      	str	r3, [r2, #0]
                                    USB_OTG_DIEPCTL_SD0PID_SEVNFRM |
                                    USB_OTG_DOEPCTL_USBAEP;
    }
  }
  return HAL_OK;
 8005a48:	2300      	movs	r3, #0
}
 8005a4a:	4618      	mov	r0, r3
 8005a4c:	3714      	adds	r7, #20
 8005a4e:	46bd      	mov	sp, r7
 8005a50:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005a54:	4770      	bx	lr
	...

08005a58 <USB_DeactivateEndpoint>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DeactivateEndpoint(const USB_OTG_GlobalTypeDef *USBx, const USB_OTG_EPTypeDef *ep)
{
 8005a58:	b480      	push	{r7}
 8005a5a:	b085      	sub	sp, #20
 8005a5c:	af00      	add	r7, sp, #0
 8005a5e:	6078      	str	r0, [r7, #4]
 8005a60:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8005a62:	687b      	ldr	r3, [r7, #4]
 8005a64:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
 8005a66:	683b      	ldr	r3, [r7, #0]
 8005a68:	781b      	ldrb	r3, [r3, #0]
 8005a6a:	60bb      	str	r3, [r7, #8]

  /* Read DEPCTLn register */
  if (ep->is_in == 1U)
 8005a6c:	683b      	ldr	r3, [r7, #0]
 8005a6e:	785b      	ldrb	r3, [r3, #1]
 8005a70:	2b01      	cmp	r3, #1
 8005a72:	d161      	bne.n	8005b38 <USB_DeactivateEndpoint+0xe0>
  {
    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 8005a74:	68bb      	ldr	r3, [r7, #8]
 8005a76:	015a      	lsls	r2, r3, #5
 8005a78:	68fb      	ldr	r3, [r7, #12]
 8005a7a:	4413      	add	r3, r2
 8005a7c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005a80:	681b      	ldr	r3, [r3, #0]
 8005a82:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 8005a86:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8005a8a:	d11f      	bne.n	8005acc <USB_DeactivateEndpoint+0x74>
    {
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SNAK;
 8005a8c:	68bb      	ldr	r3, [r7, #8]
 8005a8e:	015a      	lsls	r2, r3, #5
 8005a90:	68fb      	ldr	r3, [r7, #12]
 8005a92:	4413      	add	r3, r2
 8005a94:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005a98:	681b      	ldr	r3, [r3, #0]
 8005a9a:	68ba      	ldr	r2, [r7, #8]
 8005a9c:	0151      	lsls	r1, r2, #5
 8005a9e:	68fa      	ldr	r2, [r7, #12]
 8005aa0:	440a      	add	r2, r1
 8005aa2:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005aa6:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 8005aaa:	6013      	str	r3, [r2, #0]
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_EPDIS;
 8005aac:	68bb      	ldr	r3, [r7, #8]
 8005aae:	015a      	lsls	r2, r3, #5
 8005ab0:	68fb      	ldr	r3, [r7, #12]
 8005ab2:	4413      	add	r3, r2
 8005ab4:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005ab8:	681b      	ldr	r3, [r3, #0]
 8005aba:	68ba      	ldr	r2, [r7, #8]
 8005abc:	0151      	lsls	r1, r2, #5
 8005abe:	68fa      	ldr	r2, [r7, #12]
 8005ac0:	440a      	add	r2, r1
 8005ac2:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005ac6:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 8005aca:	6013      	str	r3, [r2, #0]
    }

    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
 8005acc:	68fb      	ldr	r3, [r7, #12]
 8005ace:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8005ad2:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8005ad4:	683b      	ldr	r3, [r7, #0]
 8005ad6:	781b      	ldrb	r3, [r3, #0]
 8005ad8:	f003 030f 	and.w	r3, r3, #15
 8005adc:	2101      	movs	r1, #1
 8005ade:	fa01 f303 	lsl.w	r3, r1, r3
 8005ae2:	b29b      	uxth	r3, r3
 8005ae4:	43db      	mvns	r3, r3
 8005ae6:	68f9      	ldr	r1, [r7, #12]
 8005ae8:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 8005aec:	4013      	ands	r3, r2
 8005aee:	63cb      	str	r3, [r1, #60]	@ 0x3c
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
 8005af0:	68fb      	ldr	r3, [r7, #12]
 8005af2:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8005af6:	69da      	ldr	r2, [r3, #28]
 8005af8:	683b      	ldr	r3, [r7, #0]
 8005afa:	781b      	ldrb	r3, [r3, #0]
 8005afc:	f003 030f 	and.w	r3, r3, #15
 8005b00:	2101      	movs	r1, #1
 8005b02:	fa01 f303 	lsl.w	r3, r1, r3
 8005b06:	b29b      	uxth	r3, r3
 8005b08:	43db      	mvns	r3, r3
 8005b0a:	68f9      	ldr	r1, [r7, #12]
 8005b0c:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 8005b10:	4013      	ands	r3, r2
 8005b12:	61cb      	str	r3, [r1, #28]
    USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_USBAEP |
 8005b14:	68bb      	ldr	r3, [r7, #8]
 8005b16:	015a      	lsls	r2, r3, #5
 8005b18:	68fb      	ldr	r3, [r7, #12]
 8005b1a:	4413      	add	r3, r2
 8005b1c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005b20:	681a      	ldr	r2, [r3, #0]
 8005b22:	68bb      	ldr	r3, [r7, #8]
 8005b24:	0159      	lsls	r1, r3, #5
 8005b26:	68fb      	ldr	r3, [r7, #12]
 8005b28:	440b      	add	r3, r1
 8005b2a:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005b2e:	4619      	mov	r1, r3
 8005b30:	4b35      	ldr	r3, [pc, #212]	@ (8005c08 <USB_DeactivateEndpoint+0x1b0>)
 8005b32:	4013      	ands	r3, r2
 8005b34:	600b      	str	r3, [r1, #0]
 8005b36:	e060      	b.n	8005bfa <USB_DeactivateEndpoint+0x1a2>
                                   USB_OTG_DIEPCTL_SD0PID_SEVNFRM |
                                   USB_OTG_DIEPCTL_EPTYP);
  }
  else
  {
    if ((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8005b38:	68bb      	ldr	r3, [r7, #8]
 8005b3a:	015a      	lsls	r2, r3, #5
 8005b3c:	68fb      	ldr	r3, [r7, #12]
 8005b3e:	4413      	add	r3, r2
 8005b40:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8005b44:	681b      	ldr	r3, [r3, #0]
 8005b46:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 8005b4a:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8005b4e:	d11f      	bne.n	8005b90 <USB_DeactivateEndpoint+0x138>
    {
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
 8005b50:	68bb      	ldr	r3, [r7, #8]
 8005b52:	015a      	lsls	r2, r3, #5
 8005b54:	68fb      	ldr	r3, [r7, #12]
 8005b56:	4413      	add	r3, r2
 8005b58:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8005b5c:	681b      	ldr	r3, [r3, #0]
 8005b5e:	68ba      	ldr	r2, [r7, #8]
 8005b60:	0151      	lsls	r1, r2, #5
 8005b62:	68fa      	ldr	r2, [r7, #12]
 8005b64:	440a      	add	r2, r1
 8005b66:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8005b6a:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 8005b6e:	6013      	str	r3, [r2, #0]
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_EPDIS;
 8005b70:	68bb      	ldr	r3, [r7, #8]
 8005b72:	015a      	lsls	r2, r3, #5
 8005b74:	68fb      	ldr	r3, [r7, #12]
 8005b76:	4413      	add	r3, r2
 8005b78:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8005b7c:	681b      	ldr	r3, [r3, #0]
 8005b7e:	68ba      	ldr	r2, [r7, #8]
 8005b80:	0151      	lsls	r1, r2, #5
 8005b82:	68fa      	ldr	r2, [r7, #12]
 8005b84:	440a      	add	r2, r1
 8005b86:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8005b8a:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 8005b8e:	6013      	str	r3, [r2, #0]
    }

    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
 8005b90:	68fb      	ldr	r3, [r7, #12]
 8005b92:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8005b96:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8005b98:	683b      	ldr	r3, [r7, #0]
 8005b9a:	781b      	ldrb	r3, [r3, #0]
 8005b9c:	f003 030f 	and.w	r3, r3, #15
 8005ba0:	2101      	movs	r1, #1
 8005ba2:	fa01 f303 	lsl.w	r3, r1, r3
 8005ba6:	041b      	lsls	r3, r3, #16
 8005ba8:	43db      	mvns	r3, r3
 8005baa:	68f9      	ldr	r1, [r7, #12]
 8005bac:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 8005bb0:	4013      	ands	r3, r2
 8005bb2:	63cb      	str	r3, [r1, #60]	@ 0x3c
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
 8005bb4:	68fb      	ldr	r3, [r7, #12]
 8005bb6:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8005bba:	69da      	ldr	r2, [r3, #28]
 8005bbc:	683b      	ldr	r3, [r7, #0]
 8005bbe:	781b      	ldrb	r3, [r3, #0]
 8005bc0:	f003 030f 	and.w	r3, r3, #15
 8005bc4:	2101      	movs	r1, #1
 8005bc6:	fa01 f303 	lsl.w	r3, r1, r3
 8005bca:	041b      	lsls	r3, r3, #16
 8005bcc:	43db      	mvns	r3, r3
 8005bce:	68f9      	ldr	r1, [r7, #12]
 8005bd0:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 8005bd4:	4013      	ands	r3, r2
 8005bd6:	61cb      	str	r3, [r1, #28]
    USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_USBAEP |
 8005bd8:	68bb      	ldr	r3, [r7, #8]
 8005bda:	015a      	lsls	r2, r3, #5
 8005bdc:	68fb      	ldr	r3, [r7, #12]
 8005bde:	4413      	add	r3, r2
 8005be0:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8005be4:	681a      	ldr	r2, [r3, #0]
 8005be6:	68bb      	ldr	r3, [r7, #8]
 8005be8:	0159      	lsls	r1, r3, #5
 8005bea:	68fb      	ldr	r3, [r7, #12]
 8005bec:	440b      	add	r3, r1
 8005bee:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8005bf2:	4619      	mov	r1, r3
 8005bf4:	4b05      	ldr	r3, [pc, #20]	@ (8005c0c <USB_DeactivateEndpoint+0x1b4>)
 8005bf6:	4013      	ands	r3, r2
 8005bf8:	600b      	str	r3, [r1, #0]
                                    USB_OTG_DOEPCTL_MPSIZ |
                                    USB_OTG_DOEPCTL_SD0PID_SEVNFRM |
                                    USB_OTG_DOEPCTL_EPTYP);
  }

  return HAL_OK;
 8005bfa:	2300      	movs	r3, #0
}
 8005bfc:	4618      	mov	r0, r3
 8005bfe:	3714      	adds	r7, #20
 8005c00:	46bd      	mov	sp, r7
 8005c02:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005c06:	4770      	bx	lr
 8005c08:	ec337800 	.word	0xec337800
 8005c0c:	eff37800 	.word	0xeff37800

08005c10 <USB_EPStartXfer>:
  *           0 : DMA feature not used
  *           1 : DMA feature used
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPStartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep, uint8_t dma)
{
 8005c10:	b580      	push	{r7, lr}
 8005c12:	b08a      	sub	sp, #40	@ 0x28
 8005c14:	af02      	add	r7, sp, #8
 8005c16:	60f8      	str	r0, [r7, #12]
 8005c18:	60b9      	str	r1, [r7, #8]
 8005c1a:	4613      	mov	r3, r2
 8005c1c:	71fb      	strb	r3, [r7, #7]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8005c1e:	68fb      	ldr	r3, [r7, #12]
 8005c20:	61fb      	str	r3, [r7, #28]
  uint32_t epnum = (uint32_t)ep->num;
 8005c22:	68bb      	ldr	r3, [r7, #8]
 8005c24:	781b      	ldrb	r3, [r3, #0]
 8005c26:	61bb      	str	r3, [r7, #24]
  uint16_t pktcnt;

  /* IN endpoint */
  if (ep->is_in == 1U)
 8005c28:	68bb      	ldr	r3, [r7, #8]
 8005c2a:	785b      	ldrb	r3, [r3, #1]
 8005c2c:	2b01      	cmp	r3, #1
 8005c2e:	f040 817f 	bne.w	8005f30 <USB_EPStartXfer+0x320>
  {
    /* Zero Length Packet? */
    if (ep->xfer_len == 0U)
 8005c32:	68bb      	ldr	r3, [r7, #8]
 8005c34:	691b      	ldr	r3, [r3, #16]
 8005c36:	2b00      	cmp	r3, #0
 8005c38:	d132      	bne.n	8005ca0 <USB_EPStartXfer+0x90>
    {
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 8005c3a:	69bb      	ldr	r3, [r7, #24]
 8005c3c:	015a      	lsls	r2, r3, #5
 8005c3e:	69fb      	ldr	r3, [r7, #28]
 8005c40:	4413      	add	r3, r2
 8005c42:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005c46:	691b      	ldr	r3, [r3, #16]
 8005c48:	69ba      	ldr	r2, [r7, #24]
 8005c4a:	0151      	lsls	r1, r2, #5
 8005c4c:	69fa      	ldr	r2, [r7, #28]
 8005c4e:	440a      	add	r2, r1
 8005c50:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005c54:	f023 53ff 	bic.w	r3, r3, #534773760	@ 0x1fe00000
 8005c58:	f423 13c0 	bic.w	r3, r3, #1572864	@ 0x180000
 8005c5c:	6113      	str	r3, [r2, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 8005c5e:	69bb      	ldr	r3, [r7, #24]
 8005c60:	015a      	lsls	r2, r3, #5
 8005c62:	69fb      	ldr	r3, [r7, #28]
 8005c64:	4413      	add	r3, r2
 8005c66:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005c6a:	691b      	ldr	r3, [r3, #16]
 8005c6c:	69ba      	ldr	r2, [r7, #24]
 8005c6e:	0151      	lsls	r1, r2, #5
 8005c70:	69fa      	ldr	r2, [r7, #28]
 8005c72:	440a      	add	r2, r1
 8005c74:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005c78:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 8005c7c:	6113      	str	r3, [r2, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8005c7e:	69bb      	ldr	r3, [r7, #24]
 8005c80:	015a      	lsls	r2, r3, #5
 8005c82:	69fb      	ldr	r3, [r7, #28]
 8005c84:	4413      	add	r3, r2
 8005c86:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005c8a:	691b      	ldr	r3, [r3, #16]
 8005c8c:	69ba      	ldr	r2, [r7, #24]
 8005c8e:	0151      	lsls	r1, r2, #5
 8005c90:	69fa      	ldr	r2, [r7, #28]
 8005c92:	440a      	add	r2, r1
 8005c94:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005c98:	0cdb      	lsrs	r3, r3, #19
 8005c9a:	04db      	lsls	r3, r3, #19
 8005c9c:	6113      	str	r3, [r2, #16]
 8005c9e:	e097      	b.n	8005dd0 <USB_EPStartXfer+0x1c0>
      /* Program the transfer size and packet count
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8005ca0:	69bb      	ldr	r3, [r7, #24]
 8005ca2:	015a      	lsls	r2, r3, #5
 8005ca4:	69fb      	ldr	r3, [r7, #28]
 8005ca6:	4413      	add	r3, r2
 8005ca8:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005cac:	691b      	ldr	r3, [r3, #16]
 8005cae:	69ba      	ldr	r2, [r7, #24]
 8005cb0:	0151      	lsls	r1, r2, #5
 8005cb2:	69fa      	ldr	r2, [r7, #28]
 8005cb4:	440a      	add	r2, r1
 8005cb6:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005cba:	0cdb      	lsrs	r3, r3, #19
 8005cbc:	04db      	lsls	r3, r3, #19
 8005cbe:	6113      	str	r3, [r2, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 8005cc0:	69bb      	ldr	r3, [r7, #24]
 8005cc2:	015a      	lsls	r2, r3, #5
 8005cc4:	69fb      	ldr	r3, [r7, #28]
 8005cc6:	4413      	add	r3, r2
 8005cc8:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005ccc:	691b      	ldr	r3, [r3, #16]
 8005cce:	69ba      	ldr	r2, [r7, #24]
 8005cd0:	0151      	lsls	r1, r2, #5
 8005cd2:	69fa      	ldr	r2, [r7, #28]
 8005cd4:	440a      	add	r2, r1
 8005cd6:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005cda:	f023 53ff 	bic.w	r3, r3, #534773760	@ 0x1fe00000
 8005cde:	f423 13c0 	bic.w	r3, r3, #1572864	@ 0x180000
 8005ce2:	6113      	str	r3, [r2, #16]

      if (epnum == 0U)
 8005ce4:	69bb      	ldr	r3, [r7, #24]
 8005ce6:	2b00      	cmp	r3, #0
 8005ce8:	d11a      	bne.n	8005d20 <USB_EPStartXfer+0x110>
      {
        if (ep->xfer_len > ep->maxpacket)
 8005cea:	68bb      	ldr	r3, [r7, #8]
 8005cec:	691a      	ldr	r2, [r3, #16]
 8005cee:	68bb      	ldr	r3, [r7, #8]
 8005cf0:	689b      	ldr	r3, [r3, #8]
 8005cf2:	429a      	cmp	r2, r3
 8005cf4:	d903      	bls.n	8005cfe <USB_EPStartXfer+0xee>
        {
          ep->xfer_len = ep->maxpacket;
 8005cf6:	68bb      	ldr	r3, [r7, #8]
 8005cf8:	689a      	ldr	r2, [r3, #8]
 8005cfa:	68bb      	ldr	r3, [r7, #8]
 8005cfc:	611a      	str	r2, [r3, #16]
        }

        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 8005cfe:	69bb      	ldr	r3, [r7, #24]
 8005d00:	015a      	lsls	r2, r3, #5
 8005d02:	69fb      	ldr	r3, [r7, #28]
 8005d04:	4413      	add	r3, r2
 8005d06:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005d0a:	691b      	ldr	r3, [r3, #16]
 8005d0c:	69ba      	ldr	r2, [r7, #24]
 8005d0e:	0151      	lsls	r1, r2, #5
 8005d10:	69fa      	ldr	r2, [r7, #28]
 8005d12:	440a      	add	r2, r1
 8005d14:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005d18:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 8005d1c:	6113      	str	r3, [r2, #16]
 8005d1e:	e044      	b.n	8005daa <USB_EPStartXfer+0x19a>
      }
      else
      {
        pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);
 8005d20:	68bb      	ldr	r3, [r7, #8]
 8005d22:	691a      	ldr	r2, [r3, #16]
 8005d24:	68bb      	ldr	r3, [r7, #8]
 8005d26:	689b      	ldr	r3, [r3, #8]
 8005d28:	4413      	add	r3, r2
 8005d2a:	1e5a      	subs	r2, r3, #1
 8005d2c:	68bb      	ldr	r3, [r7, #8]
 8005d2e:	689b      	ldr	r3, [r3, #8]
 8005d30:	fbb2 f3f3 	udiv	r3, r2, r3
 8005d34:	82fb      	strh	r3, [r7, #22]
        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (pktcnt << 19));
 8005d36:	69bb      	ldr	r3, [r7, #24]
 8005d38:	015a      	lsls	r2, r3, #5
 8005d3a:	69fb      	ldr	r3, [r7, #28]
 8005d3c:	4413      	add	r3, r2
 8005d3e:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005d42:	691a      	ldr	r2, [r3, #16]
 8005d44:	8afb      	ldrh	r3, [r7, #22]
 8005d46:	04d9      	lsls	r1, r3, #19
 8005d48:	4ba4      	ldr	r3, [pc, #656]	@ (8005fdc <USB_EPStartXfer+0x3cc>)
 8005d4a:	400b      	ands	r3, r1
 8005d4c:	69b9      	ldr	r1, [r7, #24]
 8005d4e:	0148      	lsls	r0, r1, #5
 8005d50:	69f9      	ldr	r1, [r7, #28]
 8005d52:	4401      	add	r1, r0
 8005d54:	f501 6110 	add.w	r1, r1, #2304	@ 0x900
 8005d58:	4313      	orrs	r3, r2
 8005d5a:	610b      	str	r3, [r1, #16]

        if (ep->type == EP_TYPE_ISOC)
 8005d5c:	68bb      	ldr	r3, [r7, #8]
 8005d5e:	791b      	ldrb	r3, [r3, #4]
 8005d60:	2b01      	cmp	r3, #1
 8005d62:	d122      	bne.n	8005daa <USB_EPStartXfer+0x19a>
        {
          USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT);
 8005d64:	69bb      	ldr	r3, [r7, #24]
 8005d66:	015a      	lsls	r2, r3, #5
 8005d68:	69fb      	ldr	r3, [r7, #28]
 8005d6a:	4413      	add	r3, r2
 8005d6c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005d70:	691b      	ldr	r3, [r3, #16]
 8005d72:	69ba      	ldr	r2, [r7, #24]
 8005d74:	0151      	lsls	r1, r2, #5
 8005d76:	69fa      	ldr	r2, [r7, #28]
 8005d78:	440a      	add	r2, r1
 8005d7a:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005d7e:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 8005d82:	6113      	str	r3, [r2, #16]
          USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (pktcnt << 29));
 8005d84:	69bb      	ldr	r3, [r7, #24]
 8005d86:	015a      	lsls	r2, r3, #5
 8005d88:	69fb      	ldr	r3, [r7, #28]
 8005d8a:	4413      	add	r3, r2
 8005d8c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005d90:	691a      	ldr	r2, [r3, #16]
 8005d92:	8afb      	ldrh	r3, [r7, #22]
 8005d94:	075b      	lsls	r3, r3, #29
 8005d96:	f003 43c0 	and.w	r3, r3, #1610612736	@ 0x60000000
 8005d9a:	69b9      	ldr	r1, [r7, #24]
 8005d9c:	0148      	lsls	r0, r1, #5
 8005d9e:	69f9      	ldr	r1, [r7, #28]
 8005da0:	4401      	add	r1, r0
 8005da2:	f501 6110 	add.w	r1, r1, #2304	@ 0x900
 8005da6:	4313      	orrs	r3, r2
 8005da8:	610b      	str	r3, [r1, #16]
        }
      }

      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 8005daa:	69bb      	ldr	r3, [r7, #24]
 8005dac:	015a      	lsls	r2, r3, #5
 8005dae:	69fb      	ldr	r3, [r7, #28]
 8005db0:	4413      	add	r3, r2
 8005db2:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005db6:	691a      	ldr	r2, [r3, #16]
 8005db8:	68bb      	ldr	r3, [r7, #8]
 8005dba:	691b      	ldr	r3, [r3, #16]
 8005dbc:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8005dc0:	69b9      	ldr	r1, [r7, #24]
 8005dc2:	0148      	lsls	r0, r1, #5
 8005dc4:	69f9      	ldr	r1, [r7, #28]
 8005dc6:	4401      	add	r1, r0
 8005dc8:	f501 6110 	add.w	r1, r1, #2304	@ 0x900
 8005dcc:	4313      	orrs	r3, r2
 8005dce:	610b      	str	r3, [r1, #16]
    }

    if (dma == 1U)
 8005dd0:	79fb      	ldrb	r3, [r7, #7]
 8005dd2:	2b01      	cmp	r3, #1
 8005dd4:	d14b      	bne.n	8005e6e <USB_EPStartXfer+0x25e>
    {
      if ((uint32_t)ep->dma_addr != 0U)
 8005dd6:	68bb      	ldr	r3, [r7, #8]
 8005dd8:	69db      	ldr	r3, [r3, #28]
 8005dda:	2b00      	cmp	r3, #0
 8005ddc:	d009      	beq.n	8005df2 <USB_EPStartXfer+0x1e2>
      {
        USBx_INEP(epnum)->DIEPDMA = (uint32_t)(ep->dma_addr);
 8005dde:	69bb      	ldr	r3, [r7, #24]
 8005de0:	015a      	lsls	r2, r3, #5
 8005de2:	69fb      	ldr	r3, [r7, #28]
 8005de4:	4413      	add	r3, r2
 8005de6:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005dea:	461a      	mov	r2, r3
 8005dec:	68bb      	ldr	r3, [r7, #8]
 8005dee:	69db      	ldr	r3, [r3, #28]
 8005df0:	6153      	str	r3, [r2, #20]
      }

      if (ep->type == EP_TYPE_ISOC)
 8005df2:	68bb      	ldr	r3, [r7, #8]
 8005df4:	791b      	ldrb	r3, [r3, #4]
 8005df6:	2b01      	cmp	r3, #1
 8005df8:	d128      	bne.n	8005e4c <USB_EPStartXfer+0x23c>
      {
        if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 8005dfa:	69fb      	ldr	r3, [r7, #28]
 8005dfc:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8005e00:	689b      	ldr	r3, [r3, #8]
 8005e02:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8005e06:	2b00      	cmp	r3, #0
 8005e08:	d110      	bne.n	8005e2c <USB_EPStartXfer+0x21c>
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 8005e0a:	69bb      	ldr	r3, [r7, #24]
 8005e0c:	015a      	lsls	r2, r3, #5
 8005e0e:	69fb      	ldr	r3, [r7, #28]
 8005e10:	4413      	add	r3, r2
 8005e12:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005e16:	681b      	ldr	r3, [r3, #0]
 8005e18:	69ba      	ldr	r2, [r7, #24]
 8005e1a:	0151      	lsls	r1, r2, #5
 8005e1c:	69fa      	ldr	r2, [r7, #28]
 8005e1e:	440a      	add	r2, r1
 8005e20:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005e24:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
 8005e28:	6013      	str	r3, [r2, #0]
 8005e2a:	e00f      	b.n	8005e4c <USB_EPStartXfer+0x23c>
        }
        else
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 8005e2c:	69bb      	ldr	r3, [r7, #24]
 8005e2e:	015a      	lsls	r2, r3, #5
 8005e30:	69fb      	ldr	r3, [r7, #28]
 8005e32:	4413      	add	r3, r2
 8005e34:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005e38:	681b      	ldr	r3, [r3, #0]
 8005e3a:	69ba      	ldr	r2, [r7, #24]
 8005e3c:	0151      	lsls	r1, r2, #5
 8005e3e:	69fa      	ldr	r2, [r7, #28]
 8005e40:	440a      	add	r2, r1
 8005e42:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005e46:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8005e4a:	6013      	str	r3, [r2, #0]
        }
      }

      /* EP enable, IN data in FIFO */
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 8005e4c:	69bb      	ldr	r3, [r7, #24]
 8005e4e:	015a      	lsls	r2, r3, #5
 8005e50:	69fb      	ldr	r3, [r7, #28]
 8005e52:	4413      	add	r3, r2
 8005e54:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005e58:	681b      	ldr	r3, [r3, #0]
 8005e5a:	69ba      	ldr	r2, [r7, #24]
 8005e5c:	0151      	lsls	r1, r2, #5
 8005e5e:	69fa      	ldr	r2, [r7, #28]
 8005e60:	440a      	add	r2, r1
 8005e62:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005e66:	f043 4304 	orr.w	r3, r3, #2214592512	@ 0x84000000
 8005e6a:	6013      	str	r3, [r2, #0]
 8005e6c:	e166      	b.n	800613c <USB_EPStartXfer+0x52c>
    }
    else
    {
      /* EP enable, IN data in FIFO */
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 8005e6e:	69bb      	ldr	r3, [r7, #24]
 8005e70:	015a      	lsls	r2, r3, #5
 8005e72:	69fb      	ldr	r3, [r7, #28]
 8005e74:	4413      	add	r3, r2
 8005e76:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005e7a:	681b      	ldr	r3, [r3, #0]
 8005e7c:	69ba      	ldr	r2, [r7, #24]
 8005e7e:	0151      	lsls	r1, r2, #5
 8005e80:	69fa      	ldr	r2, [r7, #28]
 8005e82:	440a      	add	r2, r1
 8005e84:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005e88:	f043 4304 	orr.w	r3, r3, #2214592512	@ 0x84000000
 8005e8c:	6013      	str	r3, [r2, #0]

      if (ep->type != EP_TYPE_ISOC)
 8005e8e:	68bb      	ldr	r3, [r7, #8]
 8005e90:	791b      	ldrb	r3, [r3, #4]
 8005e92:	2b01      	cmp	r3, #1
 8005e94:	d015      	beq.n	8005ec2 <USB_EPStartXfer+0x2b2>
      {
        /* Enable the Tx FIFO Empty Interrupt for this EP */
        if (ep->xfer_len > 0U)
 8005e96:	68bb      	ldr	r3, [r7, #8]
 8005e98:	691b      	ldr	r3, [r3, #16]
 8005e9a:	2b00      	cmp	r3, #0
 8005e9c:	f000 814e 	beq.w	800613c <USB_EPStartXfer+0x52c>
        {
          USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & EP_ADDR_MSK);
 8005ea0:	69fb      	ldr	r3, [r7, #28]
 8005ea2:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8005ea6:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8005ea8:	68bb      	ldr	r3, [r7, #8]
 8005eaa:	781b      	ldrb	r3, [r3, #0]
 8005eac:	f003 030f 	and.w	r3, r3, #15
 8005eb0:	2101      	movs	r1, #1
 8005eb2:	fa01 f303 	lsl.w	r3, r1, r3
 8005eb6:	69f9      	ldr	r1, [r7, #28]
 8005eb8:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 8005ebc:	4313      	orrs	r3, r2
 8005ebe:	634b      	str	r3, [r1, #52]	@ 0x34
 8005ec0:	e13c      	b.n	800613c <USB_EPStartXfer+0x52c>
        }
      }
      else
      {
        if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 8005ec2:	69fb      	ldr	r3, [r7, #28]
 8005ec4:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8005ec8:	689b      	ldr	r3, [r3, #8]
 8005eca:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8005ece:	2b00      	cmp	r3, #0
 8005ed0:	d110      	bne.n	8005ef4 <USB_EPStartXfer+0x2e4>
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 8005ed2:	69bb      	ldr	r3, [r7, #24]
 8005ed4:	015a      	lsls	r2, r3, #5
 8005ed6:	69fb      	ldr	r3, [r7, #28]
 8005ed8:	4413      	add	r3, r2
 8005eda:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005ede:	681b      	ldr	r3, [r3, #0]
 8005ee0:	69ba      	ldr	r2, [r7, #24]
 8005ee2:	0151      	lsls	r1, r2, #5
 8005ee4:	69fa      	ldr	r2, [r7, #28]
 8005ee6:	440a      	add	r2, r1
 8005ee8:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005eec:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
 8005ef0:	6013      	str	r3, [r2, #0]
 8005ef2:	e00f      	b.n	8005f14 <USB_EPStartXfer+0x304>
        }
        else
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 8005ef4:	69bb      	ldr	r3, [r7, #24]
 8005ef6:	015a      	lsls	r2, r3, #5
 8005ef8:	69fb      	ldr	r3, [r7, #28]
 8005efa:	4413      	add	r3, r2
 8005efc:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005f00:	681b      	ldr	r3, [r3, #0]
 8005f02:	69ba      	ldr	r2, [r7, #24]
 8005f04:	0151      	lsls	r1, r2, #5
 8005f06:	69fa      	ldr	r2, [r7, #28]
 8005f08:	440a      	add	r2, r1
 8005f0a:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005f0e:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8005f12:	6013      	str	r3, [r2, #0]
        }

        (void)USB_WritePacket(USBx, ep->xfer_buff, ep->num, (uint16_t)ep->xfer_len, dma);
 8005f14:	68bb      	ldr	r3, [r7, #8]
 8005f16:	68d9      	ldr	r1, [r3, #12]
 8005f18:	68bb      	ldr	r3, [r7, #8]
 8005f1a:	781a      	ldrb	r2, [r3, #0]
 8005f1c:	68bb      	ldr	r3, [r7, #8]
 8005f1e:	691b      	ldr	r3, [r3, #16]
 8005f20:	b298      	uxth	r0, r3
 8005f22:	79fb      	ldrb	r3, [r7, #7]
 8005f24:	9300      	str	r3, [sp, #0]
 8005f26:	4603      	mov	r3, r0
 8005f28:	68f8      	ldr	r0, [r7, #12]
 8005f2a:	f000 f9b9 	bl	80062a0 <USB_WritePacket>
 8005f2e:	e105      	b.n	800613c <USB_EPStartXfer+0x52c>
  {
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
 8005f30:	69bb      	ldr	r3, [r7, #24]
 8005f32:	015a      	lsls	r2, r3, #5
 8005f34:	69fb      	ldr	r3, [r7, #28]
 8005f36:	4413      	add	r3, r2
 8005f38:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8005f3c:	691b      	ldr	r3, [r3, #16]
 8005f3e:	69ba      	ldr	r2, [r7, #24]
 8005f40:	0151      	lsls	r1, r2, #5
 8005f42:	69fa      	ldr	r2, [r7, #28]
 8005f44:	440a      	add	r2, r1
 8005f46:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8005f4a:	0cdb      	lsrs	r3, r3, #19
 8005f4c:	04db      	lsls	r3, r3, #19
 8005f4e:	6113      	str	r3, [r2, #16]
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
 8005f50:	69bb      	ldr	r3, [r7, #24]
 8005f52:	015a      	lsls	r2, r3, #5
 8005f54:	69fb      	ldr	r3, [r7, #28]
 8005f56:	4413      	add	r3, r2
 8005f58:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8005f5c:	691b      	ldr	r3, [r3, #16]
 8005f5e:	69ba      	ldr	r2, [r7, #24]
 8005f60:	0151      	lsls	r1, r2, #5
 8005f62:	69fa      	ldr	r2, [r7, #28]
 8005f64:	440a      	add	r2, r1
 8005f66:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8005f6a:	f023 53ff 	bic.w	r3, r3, #534773760	@ 0x1fe00000
 8005f6e:	f423 13c0 	bic.w	r3, r3, #1572864	@ 0x180000
 8005f72:	6113      	str	r3, [r2, #16]

    if (epnum == 0U)
 8005f74:	69bb      	ldr	r3, [r7, #24]
 8005f76:	2b00      	cmp	r3, #0
 8005f78:	d132      	bne.n	8005fe0 <USB_EPStartXfer+0x3d0>
    {
      if (ep->xfer_len > 0U)
 8005f7a:	68bb      	ldr	r3, [r7, #8]
 8005f7c:	691b      	ldr	r3, [r3, #16]
 8005f7e:	2b00      	cmp	r3, #0
 8005f80:	d003      	beq.n	8005f8a <USB_EPStartXfer+0x37a>
      {
        ep->xfer_len = ep->maxpacket;
 8005f82:	68bb      	ldr	r3, [r7, #8]
 8005f84:	689a      	ldr	r2, [r3, #8]
 8005f86:	68bb      	ldr	r3, [r7, #8]
 8005f88:	611a      	str	r2, [r3, #16]
      }

      /* Store transfer size, for EP0 this is equal to endpoint max packet size */
      ep->xfer_size = ep->maxpacket;
 8005f8a:	68bb      	ldr	r3, [r7, #8]
 8005f8c:	689a      	ldr	r2, [r3, #8]
 8005f8e:	68bb      	ldr	r3, [r7, #8]
 8005f90:	621a      	str	r2, [r3, #32]

      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->xfer_size);
 8005f92:	69bb      	ldr	r3, [r7, #24]
 8005f94:	015a      	lsls	r2, r3, #5
 8005f96:	69fb      	ldr	r3, [r7, #28]
 8005f98:	4413      	add	r3, r2
 8005f9a:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8005f9e:	691a      	ldr	r2, [r3, #16]
 8005fa0:	68bb      	ldr	r3, [r7, #8]
 8005fa2:	6a1b      	ldr	r3, [r3, #32]
 8005fa4:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8005fa8:	69b9      	ldr	r1, [r7, #24]
 8005faa:	0148      	lsls	r0, r1, #5
 8005fac:	69f9      	ldr	r1, [r7, #28]
 8005fae:	4401      	add	r1, r0
 8005fb0:	f501 6130 	add.w	r1, r1, #2816	@ 0xb00
 8005fb4:	4313      	orrs	r3, r2
 8005fb6:	610b      	str	r3, [r1, #16]
      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 8005fb8:	69bb      	ldr	r3, [r7, #24]
 8005fba:	015a      	lsls	r2, r3, #5
 8005fbc:	69fb      	ldr	r3, [r7, #28]
 8005fbe:	4413      	add	r3, r2
 8005fc0:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8005fc4:	691b      	ldr	r3, [r3, #16]
 8005fc6:	69ba      	ldr	r2, [r7, #24]
 8005fc8:	0151      	lsls	r1, r2, #5
 8005fca:	69fa      	ldr	r2, [r7, #28]
 8005fcc:	440a      	add	r2, r1
 8005fce:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8005fd2:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 8005fd6:	6113      	str	r3, [r2, #16]
 8005fd8:	e062      	b.n	80060a0 <USB_EPStartXfer+0x490>
 8005fda:	bf00      	nop
 8005fdc:	1ff80000 	.word	0x1ff80000
    }
    else
    {
      if (ep->xfer_len == 0U)
 8005fe0:	68bb      	ldr	r3, [r7, #8]
 8005fe2:	691b      	ldr	r3, [r3, #16]
 8005fe4:	2b00      	cmp	r3, #0
 8005fe6:	d123      	bne.n	8006030 <USB_EPStartXfer+0x420>
      {
        USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
 8005fe8:	69bb      	ldr	r3, [r7, #24]
 8005fea:	015a      	lsls	r2, r3, #5
 8005fec:	69fb      	ldr	r3, [r7, #28]
 8005fee:	4413      	add	r3, r2
 8005ff0:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8005ff4:	691a      	ldr	r2, [r3, #16]
 8005ff6:	68bb      	ldr	r3, [r7, #8]
 8005ff8:	689b      	ldr	r3, [r3, #8]
 8005ffa:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8005ffe:	69b9      	ldr	r1, [r7, #24]
 8006000:	0148      	lsls	r0, r1, #5
 8006002:	69f9      	ldr	r1, [r7, #28]
 8006004:	4401      	add	r1, r0
 8006006:	f501 6130 	add.w	r1, r1, #2816	@ 0xb00
 800600a:	4313      	orrs	r3, r2
 800600c:	610b      	str	r3, [r1, #16]
        USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 800600e:	69bb      	ldr	r3, [r7, #24]
 8006010:	015a      	lsls	r2, r3, #5
 8006012:	69fb      	ldr	r3, [r7, #28]
 8006014:	4413      	add	r3, r2
 8006016:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800601a:	691b      	ldr	r3, [r3, #16]
 800601c:	69ba      	ldr	r2, [r7, #24]
 800601e:	0151      	lsls	r1, r2, #5
 8006020:	69fa      	ldr	r2, [r7, #28]
 8006022:	440a      	add	r2, r1
 8006024:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8006028:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 800602c:	6113      	str	r3, [r2, #16]
 800602e:	e037      	b.n	80060a0 <USB_EPStartXfer+0x490>
      }
      else
      {
        pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);
 8006030:	68bb      	ldr	r3, [r7, #8]
 8006032:	691a      	ldr	r2, [r3, #16]
 8006034:	68bb      	ldr	r3, [r7, #8]
 8006036:	689b      	ldr	r3, [r3, #8]
 8006038:	4413      	add	r3, r2
 800603a:	1e5a      	subs	r2, r3, #1
 800603c:	68bb      	ldr	r3, [r7, #8]
 800603e:	689b      	ldr	r3, [r3, #8]
 8006040:	fbb2 f3f3 	udiv	r3, r2, r3
 8006044:	82fb      	strh	r3, [r7, #22]
        ep->xfer_size = ep->maxpacket * pktcnt;
 8006046:	68bb      	ldr	r3, [r7, #8]
 8006048:	689b      	ldr	r3, [r3, #8]
 800604a:	8afa      	ldrh	r2, [r7, #22]
 800604c:	fb03 f202 	mul.w	r2, r3, r2
 8006050:	68bb      	ldr	r3, [r7, #8]
 8006052:	621a      	str	r2, [r3, #32]

        USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
 8006054:	69bb      	ldr	r3, [r7, #24]
 8006056:	015a      	lsls	r2, r3, #5
 8006058:	69fb      	ldr	r3, [r7, #28]
 800605a:	4413      	add	r3, r2
 800605c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8006060:	691a      	ldr	r2, [r3, #16]
 8006062:	8afb      	ldrh	r3, [r7, #22]
 8006064:	04d9      	lsls	r1, r3, #19
 8006066:	4b38      	ldr	r3, [pc, #224]	@ (8006148 <USB_EPStartXfer+0x538>)
 8006068:	400b      	ands	r3, r1
 800606a:	69b9      	ldr	r1, [r7, #24]
 800606c:	0148      	lsls	r0, r1, #5
 800606e:	69f9      	ldr	r1, [r7, #28]
 8006070:	4401      	add	r1, r0
 8006072:	f501 6130 	add.w	r1, r1, #2816	@ 0xb00
 8006076:	4313      	orrs	r3, r2
 8006078:	610b      	str	r3, [r1, #16]
        USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_XFRSIZ & ep->xfer_size;
 800607a:	69bb      	ldr	r3, [r7, #24]
 800607c:	015a      	lsls	r2, r3, #5
 800607e:	69fb      	ldr	r3, [r7, #28]
 8006080:	4413      	add	r3, r2
 8006082:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8006086:	691a      	ldr	r2, [r3, #16]
 8006088:	68bb      	ldr	r3, [r7, #8]
 800608a:	6a1b      	ldr	r3, [r3, #32]
 800608c:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8006090:	69b9      	ldr	r1, [r7, #24]
 8006092:	0148      	lsls	r0, r1, #5
 8006094:	69f9      	ldr	r1, [r7, #28]
 8006096:	4401      	add	r1, r0
 8006098:	f501 6130 	add.w	r1, r1, #2816	@ 0xb00
 800609c:	4313      	orrs	r3, r2
 800609e:	610b      	str	r3, [r1, #16]
      }
    }

    if (dma == 1U)
 80060a0:	79fb      	ldrb	r3, [r7, #7]
 80060a2:	2b01      	cmp	r3, #1
 80060a4:	d10d      	bne.n	80060c2 <USB_EPStartXfer+0x4b2>
    {
      if ((uint32_t)ep->xfer_buff != 0U)
 80060a6:	68bb      	ldr	r3, [r7, #8]
 80060a8:	68db      	ldr	r3, [r3, #12]
 80060aa:	2b00      	cmp	r3, #0
 80060ac:	d009      	beq.n	80060c2 <USB_EPStartXfer+0x4b2>
      {
        USBx_OUTEP(epnum)->DOEPDMA = (uint32_t)(ep->xfer_buff);
 80060ae:	68bb      	ldr	r3, [r7, #8]
 80060b0:	68d9      	ldr	r1, [r3, #12]
 80060b2:	69bb      	ldr	r3, [r7, #24]
 80060b4:	015a      	lsls	r2, r3, #5
 80060b6:	69fb      	ldr	r3, [r7, #28]
 80060b8:	4413      	add	r3, r2
 80060ba:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80060be:	460a      	mov	r2, r1
 80060c0:	615a      	str	r2, [r3, #20]
      }
    }

    if (ep->type == EP_TYPE_ISOC)
 80060c2:	68bb      	ldr	r3, [r7, #8]
 80060c4:	791b      	ldrb	r3, [r3, #4]
 80060c6:	2b01      	cmp	r3, #1
 80060c8:	d128      	bne.n	800611c <USB_EPStartXfer+0x50c>
    {
      if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 80060ca:	69fb      	ldr	r3, [r7, #28]
 80060cc:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80060d0:	689b      	ldr	r3, [r3, #8]
 80060d2:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 80060d6:	2b00      	cmp	r3, #0
 80060d8:	d110      	bne.n	80060fc <USB_EPStartXfer+0x4ec>
      {
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
 80060da:	69bb      	ldr	r3, [r7, #24]
 80060dc:	015a      	lsls	r2, r3, #5
 80060de:	69fb      	ldr	r3, [r7, #28]
 80060e0:	4413      	add	r3, r2
 80060e2:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80060e6:	681b      	ldr	r3, [r3, #0]
 80060e8:	69ba      	ldr	r2, [r7, #24]
 80060ea:	0151      	lsls	r1, r2, #5
 80060ec:	69fa      	ldr	r2, [r7, #28]
 80060ee:	440a      	add	r2, r1
 80060f0:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 80060f4:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
 80060f8:	6013      	str	r3, [r2, #0]
 80060fa:	e00f      	b.n	800611c <USB_EPStartXfer+0x50c>
      }
      else
      {
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
 80060fc:	69bb      	ldr	r3, [r7, #24]
 80060fe:	015a      	lsls	r2, r3, #5
 8006100:	69fb      	ldr	r3, [r7, #28]
 8006102:	4413      	add	r3, r2
 8006104:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8006108:	681b      	ldr	r3, [r3, #0]
 800610a:	69ba      	ldr	r2, [r7, #24]
 800610c:	0151      	lsls	r1, r2, #5
 800610e:	69fa      	ldr	r2, [r7, #28]
 8006110:	440a      	add	r2, r1
 8006112:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8006116:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 800611a:	6013      	str	r3, [r2, #0]
      }
    }
    /* EP enable */
    USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 800611c:	69bb      	ldr	r3, [r7, #24]
 800611e:	015a      	lsls	r2, r3, #5
 8006120:	69fb      	ldr	r3, [r7, #28]
 8006122:	4413      	add	r3, r2
 8006124:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8006128:	681b      	ldr	r3, [r3, #0]
 800612a:	69ba      	ldr	r2, [r7, #24]
 800612c:	0151      	lsls	r1, r2, #5
 800612e:	69fa      	ldr	r2, [r7, #28]
 8006130:	440a      	add	r2, r1
 8006132:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8006136:	f043 4304 	orr.w	r3, r3, #2214592512	@ 0x84000000
 800613a:	6013      	str	r3, [r2, #0]
  }

  return HAL_OK;
 800613c:	2300      	movs	r3, #0
}
 800613e:	4618      	mov	r0, r3
 8006140:	3720      	adds	r7, #32
 8006142:	46bd      	mov	sp, r7
 8006144:	bd80      	pop	{r7, pc}
 8006146:	bf00      	nop
 8006148:	1ff80000 	.word	0x1ff80000

0800614c <USB_EPStopXfer>:
   * @param  USBx  usb device instance
   * @param  ep pointer to endpoint structure
   * @retval HAL status
   */
HAL_StatusTypeDef USB_EPStopXfer(const USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 800614c:	b480      	push	{r7}
 800614e:	b087      	sub	sp, #28
 8006150:	af00      	add	r7, sp, #0
 8006152:	6078      	str	r0, [r7, #4]
 8006154:	6039      	str	r1, [r7, #0]
  __IO uint32_t count = 0U;
 8006156:	2300      	movs	r3, #0
 8006158:	60fb      	str	r3, [r7, #12]
  HAL_StatusTypeDef ret = HAL_OK;
 800615a:	2300      	movs	r3, #0
 800615c:	75fb      	strb	r3, [r7, #23]
  uint32_t USBx_BASE = (uint32_t)USBx;
 800615e:	687b      	ldr	r3, [r7, #4]
 8006160:	613b      	str	r3, [r7, #16]

  /* IN endpoint */
  if (ep->is_in == 1U)
 8006162:	683b      	ldr	r3, [r7, #0]
 8006164:	785b      	ldrb	r3, [r3, #1]
 8006166:	2b01      	cmp	r3, #1
 8006168:	d14a      	bne.n	8006200 <USB_EPStopXfer+0xb4>
  {
    /* EP enable, IN data in FIFO */
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 800616a:	683b      	ldr	r3, [r7, #0]
 800616c:	781b      	ldrb	r3, [r3, #0]
 800616e:	015a      	lsls	r2, r3, #5
 8006170:	693b      	ldr	r3, [r7, #16]
 8006172:	4413      	add	r3, r2
 8006174:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8006178:	681b      	ldr	r3, [r3, #0]
 800617a:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 800617e:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8006182:	f040 8086 	bne.w	8006292 <USB_EPStopXfer+0x146>
    {
      USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_SNAK);
 8006186:	683b      	ldr	r3, [r7, #0]
 8006188:	781b      	ldrb	r3, [r3, #0]
 800618a:	015a      	lsls	r2, r3, #5
 800618c:	693b      	ldr	r3, [r7, #16]
 800618e:	4413      	add	r3, r2
 8006190:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8006194:	681b      	ldr	r3, [r3, #0]
 8006196:	683a      	ldr	r2, [r7, #0]
 8006198:	7812      	ldrb	r2, [r2, #0]
 800619a:	0151      	lsls	r1, r2, #5
 800619c:	693a      	ldr	r2, [r7, #16]
 800619e:	440a      	add	r2, r1
 80061a0:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 80061a4:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 80061a8:	6013      	str	r3, [r2, #0]
      USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_EPDIS);
 80061aa:	683b      	ldr	r3, [r7, #0]
 80061ac:	781b      	ldrb	r3, [r3, #0]
 80061ae:	015a      	lsls	r2, r3, #5
 80061b0:	693b      	ldr	r3, [r7, #16]
 80061b2:	4413      	add	r3, r2
 80061b4:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80061b8:	681b      	ldr	r3, [r3, #0]
 80061ba:	683a      	ldr	r2, [r7, #0]
 80061bc:	7812      	ldrb	r2, [r2, #0]
 80061be:	0151      	lsls	r1, r2, #5
 80061c0:	693a      	ldr	r2, [r7, #16]
 80061c2:	440a      	add	r2, r1
 80061c4:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 80061c8:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 80061cc:	6013      	str	r3, [r2, #0]

      do
      {
        count++;
 80061ce:	68fb      	ldr	r3, [r7, #12]
 80061d0:	3301      	adds	r3, #1
 80061d2:	60fb      	str	r3, [r7, #12]

        if (count > 10000U)
 80061d4:	68fb      	ldr	r3, [r7, #12]
 80061d6:	f242 7210 	movw	r2, #10000	@ 0x2710
 80061da:	4293      	cmp	r3, r2
 80061dc:	d902      	bls.n	80061e4 <USB_EPStopXfer+0x98>
        {
          ret = HAL_ERROR;
 80061de:	2301      	movs	r3, #1
 80061e0:	75fb      	strb	r3, [r7, #23]
          break;
 80061e2:	e056      	b.n	8006292 <USB_EPStopXfer+0x146>
        }
      } while (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) ==  USB_OTG_DIEPCTL_EPENA);
 80061e4:	683b      	ldr	r3, [r7, #0]
 80061e6:	781b      	ldrb	r3, [r3, #0]
 80061e8:	015a      	lsls	r2, r3, #5
 80061ea:	693b      	ldr	r3, [r7, #16]
 80061ec:	4413      	add	r3, r2
 80061ee:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80061f2:	681b      	ldr	r3, [r3, #0]
 80061f4:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 80061f8:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 80061fc:	d0e7      	beq.n	80061ce <USB_EPStopXfer+0x82>
 80061fe:	e048      	b.n	8006292 <USB_EPStopXfer+0x146>
    }
  }
  else /* OUT endpoint */
  {
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8006200:	683b      	ldr	r3, [r7, #0]
 8006202:	781b      	ldrb	r3, [r3, #0]
 8006204:	015a      	lsls	r2, r3, #5
 8006206:	693b      	ldr	r3, [r7, #16]
 8006208:	4413      	add	r3, r2
 800620a:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800620e:	681b      	ldr	r3, [r3, #0]
 8006210:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 8006214:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8006218:	d13b      	bne.n	8006292 <USB_EPStopXfer+0x146>
    {
      USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_SNAK);
 800621a:	683b      	ldr	r3, [r7, #0]
 800621c:	781b      	ldrb	r3, [r3, #0]
 800621e:	015a      	lsls	r2, r3, #5
 8006220:	693b      	ldr	r3, [r7, #16]
 8006222:	4413      	add	r3, r2
 8006224:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8006228:	681b      	ldr	r3, [r3, #0]
 800622a:	683a      	ldr	r2, [r7, #0]
 800622c:	7812      	ldrb	r2, [r2, #0]
 800622e:	0151      	lsls	r1, r2, #5
 8006230:	693a      	ldr	r2, [r7, #16]
 8006232:	440a      	add	r2, r1
 8006234:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8006238:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 800623c:	6013      	str	r3, [r2, #0]
      USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_EPDIS);
 800623e:	683b      	ldr	r3, [r7, #0]
 8006240:	781b      	ldrb	r3, [r3, #0]
 8006242:	015a      	lsls	r2, r3, #5
 8006244:	693b      	ldr	r3, [r7, #16]
 8006246:	4413      	add	r3, r2
 8006248:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800624c:	681b      	ldr	r3, [r3, #0]
 800624e:	683a      	ldr	r2, [r7, #0]
 8006250:	7812      	ldrb	r2, [r2, #0]
 8006252:	0151      	lsls	r1, r2, #5
 8006254:	693a      	ldr	r2, [r7, #16]
 8006256:	440a      	add	r2, r1
 8006258:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 800625c:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 8006260:	6013      	str	r3, [r2, #0]

      do
      {
        count++;
 8006262:	68fb      	ldr	r3, [r7, #12]
 8006264:	3301      	adds	r3, #1
 8006266:	60fb      	str	r3, [r7, #12]

        if (count > 10000U)
 8006268:	68fb      	ldr	r3, [r7, #12]
 800626a:	f242 7210 	movw	r2, #10000	@ 0x2710
 800626e:	4293      	cmp	r3, r2
 8006270:	d902      	bls.n	8006278 <USB_EPStopXfer+0x12c>
        {
          ret = HAL_ERROR;
 8006272:	2301      	movs	r3, #1
 8006274:	75fb      	strb	r3, [r7, #23]
          break;
 8006276:	e00c      	b.n	8006292 <USB_EPStopXfer+0x146>
        }
      } while (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) ==  USB_OTG_DOEPCTL_EPENA);
 8006278:	683b      	ldr	r3, [r7, #0]
 800627a:	781b      	ldrb	r3, [r3, #0]
 800627c:	015a      	lsls	r2, r3, #5
 800627e:	693b      	ldr	r3, [r7, #16]
 8006280:	4413      	add	r3, r2
 8006282:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8006286:	681b      	ldr	r3, [r3, #0]
 8006288:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 800628c:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8006290:	d0e7      	beq.n	8006262 <USB_EPStopXfer+0x116>
    }
  }

  return ret;
 8006292:	7dfb      	ldrb	r3, [r7, #23]
}
 8006294:	4618      	mov	r0, r3
 8006296:	371c      	adds	r7, #28
 8006298:	46bd      	mov	sp, r7
 800629a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800629e:	4770      	bx	lr

080062a0 <USB_WritePacket>:
  *           1 : DMA feature used
  * @retval HAL status
  */
HAL_StatusTypeDef USB_WritePacket(const USB_OTG_GlobalTypeDef *USBx, uint8_t *src,
                                  uint8_t ch_ep_num, uint16_t len, uint8_t dma)
{
 80062a0:	b480      	push	{r7}
 80062a2:	b089      	sub	sp, #36	@ 0x24
 80062a4:	af00      	add	r7, sp, #0
 80062a6:	60f8      	str	r0, [r7, #12]
 80062a8:	60b9      	str	r1, [r7, #8]
 80062aa:	4611      	mov	r1, r2
 80062ac:	461a      	mov	r2, r3
 80062ae:	460b      	mov	r3, r1
 80062b0:	71fb      	strb	r3, [r7, #7]
 80062b2:	4613      	mov	r3, r2
 80062b4:	80bb      	strh	r3, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80062b6:	68fb      	ldr	r3, [r7, #12]
 80062b8:	617b      	str	r3, [r7, #20]
  uint8_t *pSrc = src;
 80062ba:	68bb      	ldr	r3, [r7, #8]
 80062bc:	61fb      	str	r3, [r7, #28]
  uint32_t count32b;
  uint32_t i;

  if (dma == 0U)
 80062be:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
 80062c2:	2b00      	cmp	r3, #0
 80062c4:	d123      	bne.n	800630e <USB_WritePacket+0x6e>
  {
    count32b = ((uint32_t)len + 3U) / 4U;
 80062c6:	88bb      	ldrh	r3, [r7, #4]
 80062c8:	3303      	adds	r3, #3
 80062ca:	089b      	lsrs	r3, r3, #2
 80062cc:	613b      	str	r3, [r7, #16]
    for (i = 0U; i < count32b; i++)
 80062ce:	2300      	movs	r3, #0
 80062d0:	61bb      	str	r3, [r7, #24]
 80062d2:	e018      	b.n	8006306 <USB_WritePacket+0x66>
    {
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 80062d4:	79fb      	ldrb	r3, [r7, #7]
 80062d6:	031a      	lsls	r2, r3, #12
 80062d8:	697b      	ldr	r3, [r7, #20]
 80062da:	4413      	add	r3, r2
 80062dc:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 80062e0:	461a      	mov	r2, r3
 80062e2:	69fb      	ldr	r3, [r7, #28]
 80062e4:	681b      	ldr	r3, [r3, #0]
 80062e6:	6013      	str	r3, [r2, #0]
      pSrc++;
 80062e8:	69fb      	ldr	r3, [r7, #28]
 80062ea:	3301      	adds	r3, #1
 80062ec:	61fb      	str	r3, [r7, #28]
      pSrc++;
 80062ee:	69fb      	ldr	r3, [r7, #28]
 80062f0:	3301      	adds	r3, #1
 80062f2:	61fb      	str	r3, [r7, #28]
      pSrc++;
 80062f4:	69fb      	ldr	r3, [r7, #28]
 80062f6:	3301      	adds	r3, #1
 80062f8:	61fb      	str	r3, [r7, #28]
      pSrc++;
 80062fa:	69fb      	ldr	r3, [r7, #28]
 80062fc:	3301      	adds	r3, #1
 80062fe:	61fb      	str	r3, [r7, #28]
    for (i = 0U; i < count32b; i++)
 8006300:	69bb      	ldr	r3, [r7, #24]
 8006302:	3301      	adds	r3, #1
 8006304:	61bb      	str	r3, [r7, #24]
 8006306:	69ba      	ldr	r2, [r7, #24]
 8006308:	693b      	ldr	r3, [r7, #16]
 800630a:	429a      	cmp	r2, r3
 800630c:	d3e2      	bcc.n	80062d4 <USB_WritePacket+0x34>
    }
  }

  return HAL_OK;
 800630e:	2300      	movs	r3, #0
}
 8006310:	4618      	mov	r0, r3
 8006312:	3724      	adds	r7, #36	@ 0x24
 8006314:	46bd      	mov	sp, r7
 8006316:	f85d 7b04 	ldr.w	r7, [sp], #4
 800631a:	4770      	bx	lr

0800631c <USB_ReadPacket>:
  * @param  dest  source pointer
  * @param  len  Number of bytes to read
  * @retval pointer to destination buffer
  */
void *USB_ReadPacket(const USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
{
 800631c:	b480      	push	{r7}
 800631e:	b08b      	sub	sp, #44	@ 0x2c
 8006320:	af00      	add	r7, sp, #0
 8006322:	60f8      	str	r0, [r7, #12]
 8006324:	60b9      	str	r1, [r7, #8]
 8006326:	4613      	mov	r3, r2
 8006328:	80fb      	strh	r3, [r7, #6]
  uint32_t USBx_BASE = (uint32_t)USBx;
 800632a:	68fb      	ldr	r3, [r7, #12]
 800632c:	61bb      	str	r3, [r7, #24]
  uint8_t *pDest = dest;
 800632e:	68bb      	ldr	r3, [r7, #8]
 8006330:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t pData;
  uint32_t i;
  uint32_t count32b = (uint32_t)len >> 2U;
 8006332:	88fb      	ldrh	r3, [r7, #6]
 8006334:	089b      	lsrs	r3, r3, #2
 8006336:	b29b      	uxth	r3, r3
 8006338:	617b      	str	r3, [r7, #20]
  uint16_t remaining_bytes = len % 4U;
 800633a:	88fb      	ldrh	r3, [r7, #6]
 800633c:	f003 0303 	and.w	r3, r3, #3
 8006340:	83fb      	strh	r3, [r7, #30]

  for (i = 0U; i < count32b; i++)
 8006342:	2300      	movs	r3, #0
 8006344:	623b      	str	r3, [r7, #32]
 8006346:	e014      	b.n	8006372 <USB_ReadPacket+0x56>
  {
    __UNALIGNED_UINT32_WRITE(pDest, USBx_DFIFO(0U));
 8006348:	69bb      	ldr	r3, [r7, #24]
 800634a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 800634e:	681a      	ldr	r2, [r3, #0]
 8006350:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8006352:	601a      	str	r2, [r3, #0]
    pDest++;
 8006354:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8006356:	3301      	adds	r3, #1
 8006358:	627b      	str	r3, [r7, #36]	@ 0x24
    pDest++;
 800635a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800635c:	3301      	adds	r3, #1
 800635e:	627b      	str	r3, [r7, #36]	@ 0x24
    pDest++;
 8006360:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8006362:	3301      	adds	r3, #1
 8006364:	627b      	str	r3, [r7, #36]	@ 0x24
    pDest++;
 8006366:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8006368:	3301      	adds	r3, #1
 800636a:	627b      	str	r3, [r7, #36]	@ 0x24
  for (i = 0U; i < count32b; i++)
 800636c:	6a3b      	ldr	r3, [r7, #32]
 800636e:	3301      	adds	r3, #1
 8006370:	623b      	str	r3, [r7, #32]
 8006372:	6a3a      	ldr	r2, [r7, #32]
 8006374:	697b      	ldr	r3, [r7, #20]
 8006376:	429a      	cmp	r2, r3
 8006378:	d3e6      	bcc.n	8006348 <USB_ReadPacket+0x2c>
  }

  /* When Number of data is not word aligned, read the remaining byte */
  if (remaining_bytes != 0U)
 800637a:	8bfb      	ldrh	r3, [r7, #30]
 800637c:	2b00      	cmp	r3, #0
 800637e:	d01e      	beq.n	80063be <USB_ReadPacket+0xa2>
  {
    i = 0U;
 8006380:	2300      	movs	r3, #0
 8006382:	623b      	str	r3, [r7, #32]
    __UNALIGNED_UINT32_WRITE(&pData, USBx_DFIFO(0U));
 8006384:	69bb      	ldr	r3, [r7, #24]
 8006386:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 800638a:	461a      	mov	r2, r3
 800638c:	f107 0310 	add.w	r3, r7, #16
 8006390:	6812      	ldr	r2, [r2, #0]
 8006392:	601a      	str	r2, [r3, #0]

    do
    {
      *(uint8_t *)pDest = (uint8_t)(pData >> (8U * (uint8_t)(i)));
 8006394:	693a      	ldr	r2, [r7, #16]
 8006396:	6a3b      	ldr	r3, [r7, #32]
 8006398:	b2db      	uxtb	r3, r3
 800639a:	00db      	lsls	r3, r3, #3
 800639c:	fa22 f303 	lsr.w	r3, r2, r3
 80063a0:	b2da      	uxtb	r2, r3
 80063a2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80063a4:	701a      	strb	r2, [r3, #0]
      i++;
 80063a6:	6a3b      	ldr	r3, [r7, #32]
 80063a8:	3301      	adds	r3, #1
 80063aa:	623b      	str	r3, [r7, #32]
      pDest++;
 80063ac:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80063ae:	3301      	adds	r3, #1
 80063b0:	627b      	str	r3, [r7, #36]	@ 0x24
      remaining_bytes--;
 80063b2:	8bfb      	ldrh	r3, [r7, #30]
 80063b4:	3b01      	subs	r3, #1
 80063b6:	83fb      	strh	r3, [r7, #30]
    } while (remaining_bytes != 0U);
 80063b8:	8bfb      	ldrh	r3, [r7, #30]
 80063ba:	2b00      	cmp	r3, #0
 80063bc:	d1ea      	bne.n	8006394 <USB_ReadPacket+0x78>
  }

  return ((void *)pDest);
 80063be:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 80063c0:	4618      	mov	r0, r3
 80063c2:	372c      	adds	r7, #44	@ 0x2c
 80063c4:	46bd      	mov	sp, r7
 80063c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80063ca:	4770      	bx	lr

080063cc <USB_EPSetStall>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPSetStall(const USB_OTG_GlobalTypeDef *USBx, const USB_OTG_EPTypeDef *ep)
{
 80063cc:	b480      	push	{r7}
 80063ce:	b085      	sub	sp, #20
 80063d0:	af00      	add	r7, sp, #0
 80063d2:	6078      	str	r0, [r7, #4]
 80063d4:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80063d6:	687b      	ldr	r3, [r7, #4]
 80063d8:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
 80063da:	683b      	ldr	r3, [r7, #0]
 80063dc:	781b      	ldrb	r3, [r3, #0]
 80063de:	60bb      	str	r3, [r7, #8]

  if (ep->is_in == 1U)
 80063e0:	683b      	ldr	r3, [r7, #0]
 80063e2:	785b      	ldrb	r3, [r3, #1]
 80063e4:	2b01      	cmp	r3, #1
 80063e6:	d12c      	bne.n	8006442 <USB_EPSetStall+0x76>
  {
    if (((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == 0U) && (epnum != 0U))
 80063e8:	68bb      	ldr	r3, [r7, #8]
 80063ea:	015a      	lsls	r2, r3, #5
 80063ec:	68fb      	ldr	r3, [r7, #12]
 80063ee:	4413      	add	r3, r2
 80063f0:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80063f4:	681b      	ldr	r3, [r3, #0]
 80063f6:	2b00      	cmp	r3, #0
 80063f8:	db12      	blt.n	8006420 <USB_EPSetStall+0x54>
 80063fa:	68bb      	ldr	r3, [r7, #8]
 80063fc:	2b00      	cmp	r3, #0
 80063fe:	d00f      	beq.n	8006420 <USB_EPSetStall+0x54>
    {
      USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_EPDIS);
 8006400:	68bb      	ldr	r3, [r7, #8]
 8006402:	015a      	lsls	r2, r3, #5
 8006404:	68fb      	ldr	r3, [r7, #12]
 8006406:	4413      	add	r3, r2
 8006408:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800640c:	681b      	ldr	r3, [r3, #0]
 800640e:	68ba      	ldr	r2, [r7, #8]
 8006410:	0151      	lsls	r1, r2, #5
 8006412:	68fa      	ldr	r2, [r7, #12]
 8006414:	440a      	add	r2, r1
 8006416:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 800641a:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
 800641e:	6013      	str	r3, [r2, #0]
    }
    USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
 8006420:	68bb      	ldr	r3, [r7, #8]
 8006422:	015a      	lsls	r2, r3, #5
 8006424:	68fb      	ldr	r3, [r7, #12]
 8006426:	4413      	add	r3, r2
 8006428:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800642c:	681b      	ldr	r3, [r3, #0]
 800642e:	68ba      	ldr	r2, [r7, #8]
 8006430:	0151      	lsls	r1, r2, #5
 8006432:	68fa      	ldr	r2, [r7, #12]
 8006434:	440a      	add	r2, r1
 8006436:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 800643a:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 800643e:	6013      	str	r3, [r2, #0]
 8006440:	e02b      	b.n	800649a <USB_EPSetStall+0xce>
  }
  else
  {
    if (((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == 0U) && (epnum != 0U))
 8006442:	68bb      	ldr	r3, [r7, #8]
 8006444:	015a      	lsls	r2, r3, #5
 8006446:	68fb      	ldr	r3, [r7, #12]
 8006448:	4413      	add	r3, r2
 800644a:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800644e:	681b      	ldr	r3, [r3, #0]
 8006450:	2b00      	cmp	r3, #0
 8006452:	db12      	blt.n	800647a <USB_EPSetStall+0xae>
 8006454:	68bb      	ldr	r3, [r7, #8]
 8006456:	2b00      	cmp	r3, #0
 8006458:	d00f      	beq.n	800647a <USB_EPSetStall+0xae>
    {
      USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS);
 800645a:	68bb      	ldr	r3, [r7, #8]
 800645c:	015a      	lsls	r2, r3, #5
 800645e:	68fb      	ldr	r3, [r7, #12]
 8006460:	4413      	add	r3, r2
 8006462:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8006466:	681b      	ldr	r3, [r3, #0]
 8006468:	68ba      	ldr	r2, [r7, #8]
 800646a:	0151      	lsls	r1, r2, #5
 800646c:	68fa      	ldr	r2, [r7, #12]
 800646e:	440a      	add	r2, r1
 8006470:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8006474:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
 8006478:	6013      	str	r3, [r2, #0]
    }
    USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
 800647a:	68bb      	ldr	r3, [r7, #8]
 800647c:	015a      	lsls	r2, r3, #5
 800647e:	68fb      	ldr	r3, [r7, #12]
 8006480:	4413      	add	r3, r2
 8006482:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8006486:	681b      	ldr	r3, [r3, #0]
 8006488:	68ba      	ldr	r2, [r7, #8]
 800648a:	0151      	lsls	r1, r2, #5
 800648c:	68fa      	ldr	r2, [r7, #12]
 800648e:	440a      	add	r2, r1
 8006490:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8006494:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 8006498:	6013      	str	r3, [r2, #0]
  }

  return HAL_OK;
 800649a:	2300      	movs	r3, #0
}
 800649c:	4618      	mov	r0, r3
 800649e:	3714      	adds	r7, #20
 80064a0:	46bd      	mov	sp, r7
 80064a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80064a6:	4770      	bx	lr

080064a8 <USB_EPClearStall>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPClearStall(const USB_OTG_GlobalTypeDef *USBx, const USB_OTG_EPTypeDef *ep)
{
 80064a8:	b480      	push	{r7}
 80064aa:	b085      	sub	sp, #20
 80064ac:	af00      	add	r7, sp, #0
 80064ae:	6078      	str	r0, [r7, #4]
 80064b0:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80064b2:	687b      	ldr	r3, [r7, #4]
 80064b4:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
 80064b6:	683b      	ldr	r3, [r7, #0]
 80064b8:	781b      	ldrb	r3, [r3, #0]
 80064ba:	60bb      	str	r3, [r7, #8]

  if (ep->is_in == 1U)
 80064bc:	683b      	ldr	r3, [r7, #0]
 80064be:	785b      	ldrb	r3, [r3, #1]
 80064c0:	2b01      	cmp	r3, #1
 80064c2:	d128      	bne.n	8006516 <USB_EPClearStall+0x6e>
  {
    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 80064c4:	68bb      	ldr	r3, [r7, #8]
 80064c6:	015a      	lsls	r2, r3, #5
 80064c8:	68fb      	ldr	r3, [r7, #12]
 80064ca:	4413      	add	r3, r2
 80064cc:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80064d0:	681b      	ldr	r3, [r3, #0]
 80064d2:	68ba      	ldr	r2, [r7, #8]
 80064d4:	0151      	lsls	r1, r2, #5
 80064d6:	68fa      	ldr	r2, [r7, #12]
 80064d8:	440a      	add	r2, r1
 80064da:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 80064de:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
 80064e2:	6013      	str	r3, [r2, #0]
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 80064e4:	683b      	ldr	r3, [r7, #0]
 80064e6:	791b      	ldrb	r3, [r3, #4]
 80064e8:	2b03      	cmp	r3, #3
 80064ea:	d003      	beq.n	80064f4 <USB_EPClearStall+0x4c>
 80064ec:	683b      	ldr	r3, [r7, #0]
 80064ee:	791b      	ldrb	r3, [r3, #4]
 80064f0:	2b02      	cmp	r3, #2
 80064f2:	d138      	bne.n	8006566 <USB_EPClearStall+0xbe>
    {
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 80064f4:	68bb      	ldr	r3, [r7, #8]
 80064f6:	015a      	lsls	r2, r3, #5
 80064f8:	68fb      	ldr	r3, [r7, #12]
 80064fa:	4413      	add	r3, r2
 80064fc:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8006500:	681b      	ldr	r3, [r3, #0]
 8006502:	68ba      	ldr	r2, [r7, #8]
 8006504:	0151      	lsls	r1, r2, #5
 8006506:	68fa      	ldr	r2, [r7, #12]
 8006508:	440a      	add	r2, r1
 800650a:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 800650e:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8006512:	6013      	str	r3, [r2, #0]
 8006514:	e027      	b.n	8006566 <USB_EPClearStall+0xbe>
    }
  }
  else
  {
    USBx_OUTEP(epnum)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 8006516:	68bb      	ldr	r3, [r7, #8]
 8006518:	015a      	lsls	r2, r3, #5
 800651a:	68fb      	ldr	r3, [r7, #12]
 800651c:	4413      	add	r3, r2
 800651e:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8006522:	681b      	ldr	r3, [r3, #0]
 8006524:	68ba      	ldr	r2, [r7, #8]
 8006526:	0151      	lsls	r1, r2, #5
 8006528:	68fa      	ldr	r2, [r7, #12]
 800652a:	440a      	add	r2, r1
 800652c:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8006530:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
 8006534:	6013      	str	r3, [r2, #0]
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 8006536:	683b      	ldr	r3, [r7, #0]
 8006538:	791b      	ldrb	r3, [r3, #4]
 800653a:	2b03      	cmp	r3, #3
 800653c:	d003      	beq.n	8006546 <USB_EPClearStall+0x9e>
 800653e:	683b      	ldr	r3, [r7, #0]
 8006540:	791b      	ldrb	r3, [r3, #4]
 8006542:	2b02      	cmp	r3, #2
 8006544:	d10f      	bne.n	8006566 <USB_EPClearStall+0xbe>
    {
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 8006546:	68bb      	ldr	r3, [r7, #8]
 8006548:	015a      	lsls	r2, r3, #5
 800654a:	68fb      	ldr	r3, [r7, #12]
 800654c:	4413      	add	r3, r2
 800654e:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8006552:	681b      	ldr	r3, [r3, #0]
 8006554:	68ba      	ldr	r2, [r7, #8]
 8006556:	0151      	lsls	r1, r2, #5
 8006558:	68fa      	ldr	r2, [r7, #12]
 800655a:	440a      	add	r2, r1
 800655c:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8006560:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8006564:	6013      	str	r3, [r2, #0]
    }
  }
  return HAL_OK;
 8006566:	2300      	movs	r3, #0
}
 8006568:	4618      	mov	r0, r3
 800656a:	3714      	adds	r7, #20
 800656c:	46bd      	mov	sp, r7
 800656e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006572:	4770      	bx	lr

08006574 <USB_SetDevAddress>:
  * @param  address  new device address to be assigned
  *          This parameter can be a value from 0 to 255
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetDevAddress(const USB_OTG_GlobalTypeDef *USBx, uint8_t address)
{
 8006574:	b480      	push	{r7}
 8006576:	b085      	sub	sp, #20
 8006578:	af00      	add	r7, sp, #0
 800657a:	6078      	str	r0, [r7, #4]
 800657c:	460b      	mov	r3, r1
 800657e:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8006580:	687b      	ldr	r3, [r7, #4]
 8006582:	60fb      	str	r3, [r7, #12]

  USBx_DEVICE->DCFG &= ~(USB_OTG_DCFG_DAD);
 8006584:	68fb      	ldr	r3, [r7, #12]
 8006586:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800658a:	681b      	ldr	r3, [r3, #0]
 800658c:	68fa      	ldr	r2, [r7, #12]
 800658e:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8006592:	f423 63fe 	bic.w	r3, r3, #2032	@ 0x7f0
 8006596:	6013      	str	r3, [r2, #0]
  USBx_DEVICE->DCFG |= ((uint32_t)address << 4) & USB_OTG_DCFG_DAD;
 8006598:	68fb      	ldr	r3, [r7, #12]
 800659a:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800659e:	681a      	ldr	r2, [r3, #0]
 80065a0:	78fb      	ldrb	r3, [r7, #3]
 80065a2:	011b      	lsls	r3, r3, #4
 80065a4:	f403 63fe 	and.w	r3, r3, #2032	@ 0x7f0
 80065a8:	68f9      	ldr	r1, [r7, #12]
 80065aa:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 80065ae:	4313      	orrs	r3, r2
 80065b0:	600b      	str	r3, [r1, #0]

  return HAL_OK;
 80065b2:	2300      	movs	r3, #0
}
 80065b4:	4618      	mov	r0, r3
 80065b6:	3714      	adds	r7, #20
 80065b8:	46bd      	mov	sp, r7
 80065ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 80065be:	4770      	bx	lr

080065c0 <USB_DevConnect>:
  * @brief  USB_DevConnect : Connect the USB device by enabling Rpu
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevConnect(const USB_OTG_GlobalTypeDef *USBx)
{
 80065c0:	b480      	push	{r7}
 80065c2:	b085      	sub	sp, #20
 80065c4:	af00      	add	r7, sp, #0
 80065c6:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80065c8:	687b      	ldr	r3, [r7, #4]
 80065ca:	60fb      	str	r3, [r7, #12]

  /* In case phy is stopped, ensure to ungate and restore the phy CLK */
  USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
 80065cc:	68fb      	ldr	r3, [r7, #12]
 80065ce:	f503 6360 	add.w	r3, r3, #3584	@ 0xe00
 80065d2:	681b      	ldr	r3, [r3, #0]
 80065d4:	68fa      	ldr	r2, [r7, #12]
 80065d6:	f502 6260 	add.w	r2, r2, #3584	@ 0xe00
 80065da:	f023 0303 	bic.w	r3, r3, #3
 80065de:	6013      	str	r3, [r2, #0]

  USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS;
 80065e0:	68fb      	ldr	r3, [r7, #12]
 80065e2:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80065e6:	685b      	ldr	r3, [r3, #4]
 80065e8:	68fa      	ldr	r2, [r7, #12]
 80065ea:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 80065ee:	f023 0302 	bic.w	r3, r3, #2
 80065f2:	6053      	str	r3, [r2, #4]

  return HAL_OK;
 80065f4:	2300      	movs	r3, #0
}
 80065f6:	4618      	mov	r0, r3
 80065f8:	3714      	adds	r7, #20
 80065fa:	46bd      	mov	sp, r7
 80065fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006600:	4770      	bx	lr

08006602 <USB_DevDisconnect>:
  * @brief  USB_DevDisconnect : Disconnect the USB device by disabling Rpu
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevDisconnect(const USB_OTG_GlobalTypeDef *USBx)
{
 8006602:	b480      	push	{r7}
 8006604:	b085      	sub	sp, #20
 8006606:	af00      	add	r7, sp, #0
 8006608:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 800660a:	687b      	ldr	r3, [r7, #4]
 800660c:	60fb      	str	r3, [r7, #12]

  /* In case phy is stopped, ensure to ungate and restore the phy CLK */
  USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
 800660e:	68fb      	ldr	r3, [r7, #12]
 8006610:	f503 6360 	add.w	r3, r3, #3584	@ 0xe00
 8006614:	681b      	ldr	r3, [r3, #0]
 8006616:	68fa      	ldr	r2, [r7, #12]
 8006618:	f502 6260 	add.w	r2, r2, #3584	@ 0xe00
 800661c:	f023 0303 	bic.w	r3, r3, #3
 8006620:	6013      	str	r3, [r2, #0]

  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 8006622:	68fb      	ldr	r3, [r7, #12]
 8006624:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8006628:	685b      	ldr	r3, [r3, #4]
 800662a:	68fa      	ldr	r2, [r7, #12]
 800662c:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8006630:	f043 0302 	orr.w	r3, r3, #2
 8006634:	6053      	str	r3, [r2, #4]

  return HAL_OK;
 8006636:	2300      	movs	r3, #0
}
 8006638:	4618      	mov	r0, r3
 800663a:	3714      	adds	r7, #20
 800663c:	46bd      	mov	sp, r7
 800663e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006642:	4770      	bx	lr

08006644 <USB_ReadInterrupts>:
  * @brief  USB_ReadInterrupts: return the global USB interrupt status
  * @param  USBx  Selected device
  * @retval USB Global Interrupt status
  */
uint32_t USB_ReadInterrupts(USB_OTG_GlobalTypeDef const *USBx)
{
 8006644:	b480      	push	{r7}
 8006646:	b085      	sub	sp, #20
 8006648:	af00      	add	r7, sp, #0
 800664a:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg;

  tmpreg = USBx->GINTSTS;
 800664c:	687b      	ldr	r3, [r7, #4]
 800664e:	695b      	ldr	r3, [r3, #20]
 8006650:	60fb      	str	r3, [r7, #12]
  tmpreg &= USBx->GINTMSK;
 8006652:	687b      	ldr	r3, [r7, #4]
 8006654:	699b      	ldr	r3, [r3, #24]
 8006656:	68fa      	ldr	r2, [r7, #12]
 8006658:	4013      	ands	r3, r2
 800665a:	60fb      	str	r3, [r7, #12]

  return tmpreg;
 800665c:	68fb      	ldr	r3, [r7, #12]
}
 800665e:	4618      	mov	r0, r3
 8006660:	3714      	adds	r7, #20
 8006662:	46bd      	mov	sp, r7
 8006664:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006668:	4770      	bx	lr

0800666a <USB_ReadDevAllOutEpInterrupt>:
  * @brief  USB_ReadDevAllOutEpInterrupt: return the USB device OUT endpoints interrupt status
  * @param  USBx  Selected device
  * @retval USB Device OUT EP interrupt status
  */
uint32_t USB_ReadDevAllOutEpInterrupt(const USB_OTG_GlobalTypeDef *USBx)
{
 800666a:	b480      	push	{r7}
 800666c:	b085      	sub	sp, #20
 800666e:	af00      	add	r7, sp, #0
 8006670:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8006672:	687b      	ldr	r3, [r7, #4]
 8006674:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg;

  tmpreg  = USBx_DEVICE->DAINT;
 8006676:	68fb      	ldr	r3, [r7, #12]
 8006678:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800667c:	699b      	ldr	r3, [r3, #24]
 800667e:	60bb      	str	r3, [r7, #8]
  tmpreg &= USBx_DEVICE->DAINTMSK;
 8006680:	68fb      	ldr	r3, [r7, #12]
 8006682:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8006686:	69db      	ldr	r3, [r3, #28]
 8006688:	68ba      	ldr	r2, [r7, #8]
 800668a:	4013      	ands	r3, r2
 800668c:	60bb      	str	r3, [r7, #8]

  return ((tmpreg & 0xffff0000U) >> 16);
 800668e:	68bb      	ldr	r3, [r7, #8]
 8006690:	0c1b      	lsrs	r3, r3, #16
}
 8006692:	4618      	mov	r0, r3
 8006694:	3714      	adds	r7, #20
 8006696:	46bd      	mov	sp, r7
 8006698:	f85d 7b04 	ldr.w	r7, [sp], #4
 800669c:	4770      	bx	lr

0800669e <USB_ReadDevAllInEpInterrupt>:
  * @brief  USB_ReadDevAllInEpInterrupt: return the USB device IN endpoints interrupt status
  * @param  USBx  Selected device
  * @retval USB Device IN EP interrupt status
  */
uint32_t USB_ReadDevAllInEpInterrupt(const USB_OTG_GlobalTypeDef *USBx)
{
 800669e:	b480      	push	{r7}
 80066a0:	b085      	sub	sp, #20
 80066a2:	af00      	add	r7, sp, #0
 80066a4:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80066a6:	687b      	ldr	r3, [r7, #4]
 80066a8:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg;

  tmpreg  = USBx_DEVICE->DAINT;
 80066aa:	68fb      	ldr	r3, [r7, #12]
 80066ac:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80066b0:	699b      	ldr	r3, [r3, #24]
 80066b2:	60bb      	str	r3, [r7, #8]
  tmpreg &= USBx_DEVICE->DAINTMSK;
 80066b4:	68fb      	ldr	r3, [r7, #12]
 80066b6:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80066ba:	69db      	ldr	r3, [r3, #28]
 80066bc:	68ba      	ldr	r2, [r7, #8]
 80066be:	4013      	ands	r3, r2
 80066c0:	60bb      	str	r3, [r7, #8]

  return ((tmpreg & 0xFFFFU));
 80066c2:	68bb      	ldr	r3, [r7, #8]
 80066c4:	b29b      	uxth	r3, r3
}
 80066c6:	4618      	mov	r0, r3
 80066c8:	3714      	adds	r7, #20
 80066ca:	46bd      	mov	sp, r7
 80066cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80066d0:	4770      	bx	lr

080066d2 <USB_ReadDevOutEPInterrupt>:
  * @param  epnum  endpoint number
  *          This parameter can be a value from 0 to 15
  * @retval Device OUT EP Interrupt register
  */
uint32_t USB_ReadDevOutEPInterrupt(const USB_OTG_GlobalTypeDef *USBx, uint8_t epnum)
{
 80066d2:	b480      	push	{r7}
 80066d4:	b085      	sub	sp, #20
 80066d6:	af00      	add	r7, sp, #0
 80066d8:	6078      	str	r0, [r7, #4]
 80066da:	460b      	mov	r3, r1
 80066dc:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80066de:	687b      	ldr	r3, [r7, #4]
 80066e0:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg;

  tmpreg  = USBx_OUTEP((uint32_t)epnum)->DOEPINT;
 80066e2:	78fb      	ldrb	r3, [r7, #3]
 80066e4:	015a      	lsls	r2, r3, #5
 80066e6:	68fb      	ldr	r3, [r7, #12]
 80066e8:	4413      	add	r3, r2
 80066ea:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80066ee:	689b      	ldr	r3, [r3, #8]
 80066f0:	60bb      	str	r3, [r7, #8]
  tmpreg &= USBx_DEVICE->DOEPMSK;
 80066f2:	68fb      	ldr	r3, [r7, #12]
 80066f4:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80066f8:	695b      	ldr	r3, [r3, #20]
 80066fa:	68ba      	ldr	r2, [r7, #8]
 80066fc:	4013      	ands	r3, r2
 80066fe:	60bb      	str	r3, [r7, #8]

  return tmpreg;
 8006700:	68bb      	ldr	r3, [r7, #8]
}
 8006702:	4618      	mov	r0, r3
 8006704:	3714      	adds	r7, #20
 8006706:	46bd      	mov	sp, r7
 8006708:	f85d 7b04 	ldr.w	r7, [sp], #4
 800670c:	4770      	bx	lr

0800670e <USB_ReadDevInEPInterrupt>:
  * @param  epnum  endpoint number
  *          This parameter can be a value from 0 to 15
  * @retval Device IN EP Interrupt register
  */
uint32_t USB_ReadDevInEPInterrupt(const USB_OTG_GlobalTypeDef *USBx, uint8_t epnum)
{
 800670e:	b480      	push	{r7}
 8006710:	b087      	sub	sp, #28
 8006712:	af00      	add	r7, sp, #0
 8006714:	6078      	str	r0, [r7, #4]
 8006716:	460b      	mov	r3, r1
 8006718:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 800671a:	687b      	ldr	r3, [r7, #4]
 800671c:	617b      	str	r3, [r7, #20]
  uint32_t tmpreg;
  uint32_t msk;
  uint32_t emp;

  msk = USBx_DEVICE->DIEPMSK;
 800671e:	697b      	ldr	r3, [r7, #20]
 8006720:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8006724:	691b      	ldr	r3, [r3, #16]
 8006726:	613b      	str	r3, [r7, #16]
  emp = USBx_DEVICE->DIEPEMPMSK;
 8006728:	697b      	ldr	r3, [r7, #20]
 800672a:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800672e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8006730:	60fb      	str	r3, [r7, #12]
  msk |= ((emp >> (epnum & EP_ADDR_MSK)) & 0x1U) << 7;
 8006732:	78fb      	ldrb	r3, [r7, #3]
 8006734:	f003 030f 	and.w	r3, r3, #15
 8006738:	68fa      	ldr	r2, [r7, #12]
 800673a:	fa22 f303 	lsr.w	r3, r2, r3
 800673e:	01db      	lsls	r3, r3, #7
 8006740:	b2db      	uxtb	r3, r3
 8006742:	693a      	ldr	r2, [r7, #16]
 8006744:	4313      	orrs	r3, r2
 8006746:	613b      	str	r3, [r7, #16]
  tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
 8006748:	78fb      	ldrb	r3, [r7, #3]
 800674a:	015a      	lsls	r2, r3, #5
 800674c:	697b      	ldr	r3, [r7, #20]
 800674e:	4413      	add	r3, r2
 8006750:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8006754:	689b      	ldr	r3, [r3, #8]
 8006756:	693a      	ldr	r2, [r7, #16]
 8006758:	4013      	ands	r3, r2
 800675a:	60bb      	str	r3, [r7, #8]

  return tmpreg;
 800675c:	68bb      	ldr	r3, [r7, #8]
}
 800675e:	4618      	mov	r0, r3
 8006760:	371c      	adds	r7, #28
 8006762:	46bd      	mov	sp, r7
 8006764:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006768:	4770      	bx	lr

0800676a <USB_GetMode>:
  *          This parameter can be one of these values:
  *           0 : Host
  *           1 : Device
  */
uint32_t USB_GetMode(const USB_OTG_GlobalTypeDef *USBx)
{
 800676a:	b480      	push	{r7}
 800676c:	b083      	sub	sp, #12
 800676e:	af00      	add	r7, sp, #0
 8006770:	6078      	str	r0, [r7, #4]
  return ((USBx->GINTSTS) & 0x1U);
 8006772:	687b      	ldr	r3, [r7, #4]
 8006774:	695b      	ldr	r3, [r3, #20]
 8006776:	f003 0301 	and.w	r3, r3, #1
}
 800677a:	4618      	mov	r0, r3
 800677c:	370c      	adds	r7, #12
 800677e:	46bd      	mov	sp, r7
 8006780:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006784:	4770      	bx	lr

08006786 <USB_ActivateSetup>:
  * @brief  Activate EP0 for Setup transactions
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateSetup(const USB_OTG_GlobalTypeDef *USBx)
{
 8006786:	b480      	push	{r7}
 8006788:	b085      	sub	sp, #20
 800678a:	af00      	add	r7, sp, #0
 800678c:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 800678e:	687b      	ldr	r3, [r7, #4]
 8006790:	60fb      	str	r3, [r7, #12]

  /* Set the MPS of the IN EP0 to 64 bytes */
  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
 8006792:	68fb      	ldr	r3, [r7, #12]
 8006794:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8006798:	681b      	ldr	r3, [r3, #0]
 800679a:	68fa      	ldr	r2, [r7, #12]
 800679c:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 80067a0:	f423 63ff 	bic.w	r3, r3, #2040	@ 0x7f8
 80067a4:	f023 0307 	bic.w	r3, r3, #7
 80067a8:	6013      	str	r3, [r2, #0]

  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
 80067aa:	68fb      	ldr	r3, [r7, #12]
 80067ac:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80067b0:	685b      	ldr	r3, [r3, #4]
 80067b2:	68fa      	ldr	r2, [r7, #12]
 80067b4:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 80067b8:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 80067bc:	6053      	str	r3, [r2, #4]

  return HAL_OK;
 80067be:	2300      	movs	r3, #0
}
 80067c0:	4618      	mov	r0, r3
 80067c2:	3714      	adds	r7, #20
 80067c4:	46bd      	mov	sp, r7
 80067c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80067ca:	4770      	bx	lr

080067cc <USB_EP0_OutStart>:
  *           1 : DMA feature used
  * @param  psetup  pointer to setup packet
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0_OutStart(const USB_OTG_GlobalTypeDef *USBx, uint8_t dma, const uint8_t *psetup)
{
 80067cc:	b480      	push	{r7}
 80067ce:	b087      	sub	sp, #28
 80067d0:	af00      	add	r7, sp, #0
 80067d2:	60f8      	str	r0, [r7, #12]
 80067d4:	460b      	mov	r3, r1
 80067d6:	607a      	str	r2, [r7, #4]
 80067d8:	72fb      	strb	r3, [r7, #11]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80067da:	68fb      	ldr	r3, [r7, #12]
 80067dc:	617b      	str	r3, [r7, #20]
  uint32_t gSNPSiD = *(__IO const uint32_t *)(&USBx->CID + 0x1U);
 80067de:	68fb      	ldr	r3, [r7, #12]
 80067e0:	333c      	adds	r3, #60	@ 0x3c
 80067e2:	3304      	adds	r3, #4
 80067e4:	681b      	ldr	r3, [r3, #0]
 80067e6:	613b      	str	r3, [r7, #16]

  if (gSNPSiD > USB_OTG_CORE_ID_300A)
 80067e8:	693b      	ldr	r3, [r7, #16]
 80067ea:	4a26      	ldr	r2, [pc, #152]	@ (8006884 <USB_EP0_OutStart+0xb8>)
 80067ec:	4293      	cmp	r3, r2
 80067ee:	d90a      	bls.n	8006806 <USB_EP0_OutStart+0x3a>
  {
    if ((USBx_OUTEP(0U)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 80067f0:	697b      	ldr	r3, [r7, #20]
 80067f2:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80067f6:	681b      	ldr	r3, [r3, #0]
 80067f8:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 80067fc:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8006800:	d101      	bne.n	8006806 <USB_EP0_OutStart+0x3a>
    {
      return HAL_OK;
 8006802:	2300      	movs	r3, #0
 8006804:	e037      	b.n	8006876 <USB_EP0_OutStart+0xaa>
    }
  }

  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
 8006806:	697b      	ldr	r3, [r7, #20]
 8006808:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800680c:	461a      	mov	r2, r3
 800680e:	2300      	movs	r3, #0
 8006810:	6113      	str	r3, [r2, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 8006812:	697b      	ldr	r3, [r7, #20]
 8006814:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8006818:	691b      	ldr	r3, [r3, #16]
 800681a:	697a      	ldr	r2, [r7, #20]
 800681c:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8006820:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 8006824:	6113      	str	r3, [r2, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
 8006826:	697b      	ldr	r3, [r7, #20]
 8006828:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800682c:	691b      	ldr	r3, [r3, #16]
 800682e:	697a      	ldr	r2, [r7, #20]
 8006830:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8006834:	f043 0318 	orr.w	r3, r3, #24
 8006838:	6113      	str	r3, [r2, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;
 800683a:	697b      	ldr	r3, [r7, #20]
 800683c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8006840:	691b      	ldr	r3, [r3, #16]
 8006842:	697a      	ldr	r2, [r7, #20]
 8006844:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8006848:	f043 43c0 	orr.w	r3, r3, #1610612736	@ 0x60000000
 800684c:	6113      	str	r3, [r2, #16]

  if (dma == 1U)
 800684e:	7afb      	ldrb	r3, [r7, #11]
 8006850:	2b01      	cmp	r3, #1
 8006852:	d10f      	bne.n	8006874 <USB_EP0_OutStart+0xa8>
  {
    USBx_OUTEP(0U)->DOEPDMA = (uint32_t)psetup;
 8006854:	697b      	ldr	r3, [r7, #20]
 8006856:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800685a:	461a      	mov	r2, r3
 800685c:	687b      	ldr	r3, [r7, #4]
 800685e:	6153      	str	r3, [r2, #20]
    /* EP enable */
    USBx_OUTEP(0U)->DOEPCTL |= USB_OTG_DOEPCTL_EPENA | USB_OTG_DOEPCTL_USBAEP;
 8006860:	697b      	ldr	r3, [r7, #20]
 8006862:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8006866:	681b      	ldr	r3, [r3, #0]
 8006868:	697a      	ldr	r2, [r7, #20]
 800686a:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 800686e:	f043 2380 	orr.w	r3, r3, #2147516416	@ 0x80008000
 8006872:	6013      	str	r3, [r2, #0]
  }

  return HAL_OK;
 8006874:	2300      	movs	r3, #0
}
 8006876:	4618      	mov	r0, r3
 8006878:	371c      	adds	r7, #28
 800687a:	46bd      	mov	sp, r7
 800687c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006880:	4770      	bx	lr
 8006882:	bf00      	nop
 8006884:	4f54300a 	.word	0x4f54300a

08006888 <USB_CoreReset>:
  * @brief  Reset the USB Core (needed after USB clock settings change)
  * @param  USBx  Selected device
  * @retval HAL status
  */
static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
{
 8006888:	b480      	push	{r7}
 800688a:	b085      	sub	sp, #20
 800688c:	af00      	add	r7, sp, #0
 800688e:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0U;
 8006890:	2300      	movs	r3, #0
 8006892:	60fb      	str	r3, [r7, #12]

  /* Wait for AHB master IDLE state. */
  do
  {
    count++;
 8006894:	68fb      	ldr	r3, [r7, #12]
 8006896:	3301      	adds	r3, #1
 8006898:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 800689a:	68fb      	ldr	r3, [r7, #12]
 800689c:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 80068a0:	d901      	bls.n	80068a6 <USB_CoreReset+0x1e>
    {
      return HAL_TIMEOUT;
 80068a2:	2303      	movs	r3, #3
 80068a4:	e01b      	b.n	80068de <USB_CoreReset+0x56>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 80068a6:	687b      	ldr	r3, [r7, #4]
 80068a8:	691b      	ldr	r3, [r3, #16]
 80068aa:	2b00      	cmp	r3, #0
 80068ac:	daf2      	bge.n	8006894 <USB_CoreReset+0xc>

  /* Core Soft Reset */
  count = 0U;
 80068ae:	2300      	movs	r3, #0
 80068b0:	60fb      	str	r3, [r7, #12]
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 80068b2:	687b      	ldr	r3, [r7, #4]
 80068b4:	691b      	ldr	r3, [r3, #16]
 80068b6:	f043 0201 	orr.w	r2, r3, #1
 80068ba:	687b      	ldr	r3, [r7, #4]
 80068bc:	611a      	str	r2, [r3, #16]

  do
  {
    count++;
 80068be:	68fb      	ldr	r3, [r7, #12]
 80068c0:	3301      	adds	r3, #1
 80068c2:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 80068c4:	68fb      	ldr	r3, [r7, #12]
 80068c6:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 80068ca:	d901      	bls.n	80068d0 <USB_CoreReset+0x48>
    {
      return HAL_TIMEOUT;
 80068cc:	2303      	movs	r3, #3
 80068ce:	e006      	b.n	80068de <USB_CoreReset+0x56>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 80068d0:	687b      	ldr	r3, [r7, #4]
 80068d2:	691b      	ldr	r3, [r3, #16]
 80068d4:	f003 0301 	and.w	r3, r3, #1
 80068d8:	2b01      	cmp	r3, #1
 80068da:	d0f0      	beq.n	80068be <USB_CoreReset+0x36>

  return HAL_OK;
 80068dc:	2300      	movs	r3, #0
}
 80068de:	4618      	mov	r0, r3
 80068e0:	3714      	adds	r7, #20
 80068e2:	46bd      	mov	sp, r7
 80068e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80068e8:	4770      	bx	lr
	...

080068ec <USBD_CDC_Init>:
  * @param  pdev: device instance
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t USBD_CDC_Init(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 80068ec:	b580      	push	{r7, lr}
 80068ee:	b084      	sub	sp, #16
 80068f0:	af00      	add	r7, sp, #0
 80068f2:	6078      	str	r0, [r7, #4]
 80068f4:	460b      	mov	r3, r1
 80068f6:	70fb      	strb	r3, [r7, #3]
  UNUSED(cfgidx);
  USBD_CDC_HandleTypeDef *hcdc;

  hcdc = (USBD_CDC_HandleTypeDef *)USBD_malloc(sizeof(USBD_CDC_HandleTypeDef));
 80068f8:	f44f 7007 	mov.w	r0, #540	@ 0x21c
 80068fc:	f021 fc54 	bl	80281a8 <USBD_static_malloc>
 8006900:	60f8      	str	r0, [r7, #12]

  if (hcdc == NULL)
 8006902:	68fb      	ldr	r3, [r7, #12]
 8006904:	2b00      	cmp	r3, #0
 8006906:	d109      	bne.n	800691c <USBD_CDC_Init+0x30>
  {
    pdev->pClassDataCmsit[pdev->classId] = NULL;
 8006908:	687b      	ldr	r3, [r7, #4]
 800690a:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 800690e:	687b      	ldr	r3, [r7, #4]
 8006910:	32b0      	adds	r2, #176	@ 0xb0
 8006912:	2100      	movs	r1, #0
 8006914:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    return (uint8_t)USBD_EMEM;
 8006918:	2302      	movs	r3, #2
 800691a:	e0d4      	b.n	8006ac6 <USBD_CDC_Init+0x1da>
  }

  (void)USBD_memset(hcdc, 0, sizeof(USBD_CDC_HandleTypeDef));
 800691c:	f44f 7207 	mov.w	r2, #540	@ 0x21c
 8006920:	2100      	movs	r1, #0
 8006922:	68f8      	ldr	r0, [r7, #12]
 8006924:	f021 fdd0 	bl	80284c8 <memset>

  pdev->pClassDataCmsit[pdev->classId] = (void *)hcdc;
 8006928:	687b      	ldr	r3, [r7, #4]
 800692a:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 800692e:	687b      	ldr	r3, [r7, #4]
 8006930:	32b0      	adds	r2, #176	@ 0xb0
 8006932:	68f9      	ldr	r1, [r7, #12]
 8006934:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  pdev->pClassData = pdev->pClassDataCmsit[pdev->classId];
 8006938:	687b      	ldr	r3, [r7, #4]
 800693a:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 800693e:	687b      	ldr	r3, [r7, #4]
 8006940:	32b0      	adds	r2, #176	@ 0xb0
 8006942:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8006946:	687b      	ldr	r3, [r7, #4]
 8006948:	f8c3 22bc 	str.w	r2, [r3, #700]	@ 0x2bc
  CDCInEpAdd  = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
  CDCOutEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_OUT, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
  CDCCmdEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_INTR, (uint8_t)pdev->classId);
#endif /* USE_USBD_COMPOSITE */

  if (pdev->dev_speed == USBD_SPEED_HIGH)
 800694c:	687b      	ldr	r3, [r7, #4]
 800694e:	7c1b      	ldrb	r3, [r3, #16]
 8006950:	2b00      	cmp	r3, #0
 8006952:	d138      	bne.n	80069c6 <USBD_CDC_Init+0xda>
  {
    /* Open EP IN */
    (void)USBD_LL_OpenEP(pdev, CDCInEpAdd, USBD_EP_TYPE_BULK,
 8006954:	4b5e      	ldr	r3, [pc, #376]	@ (8006ad0 <USBD_CDC_Init+0x1e4>)
 8006956:	7819      	ldrb	r1, [r3, #0]
 8006958:	f44f 7300 	mov.w	r3, #512	@ 0x200
 800695c:	2202      	movs	r2, #2
 800695e:	6878      	ldr	r0, [r7, #4]
 8006960:	f021 faff 	bl	8027f62 <USBD_LL_OpenEP>
                         CDC_DATA_HS_IN_PACKET_SIZE);

    pdev->ep_in[CDCInEpAdd & 0xFU].is_used = 1U;
 8006964:	4b5a      	ldr	r3, [pc, #360]	@ (8006ad0 <USBD_CDC_Init+0x1e4>)
 8006966:	781b      	ldrb	r3, [r3, #0]
 8006968:	f003 020f 	and.w	r2, r3, #15
 800696c:	6879      	ldr	r1, [r7, #4]
 800696e:	4613      	mov	r3, r2
 8006970:	009b      	lsls	r3, r3, #2
 8006972:	4413      	add	r3, r2
 8006974:	009b      	lsls	r3, r3, #2
 8006976:	440b      	add	r3, r1
 8006978:	3324      	adds	r3, #36	@ 0x24
 800697a:	2201      	movs	r2, #1
 800697c:	801a      	strh	r2, [r3, #0]

    /* Open EP OUT */
    (void)USBD_LL_OpenEP(pdev, CDCOutEpAdd, USBD_EP_TYPE_BULK,
 800697e:	4b55      	ldr	r3, [pc, #340]	@ (8006ad4 <USBD_CDC_Init+0x1e8>)
 8006980:	7819      	ldrb	r1, [r3, #0]
 8006982:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8006986:	2202      	movs	r2, #2
 8006988:	6878      	ldr	r0, [r7, #4]
 800698a:	f021 faea 	bl	8027f62 <USBD_LL_OpenEP>
                         CDC_DATA_HS_OUT_PACKET_SIZE);

    pdev->ep_out[CDCOutEpAdd & 0xFU].is_used = 1U;
 800698e:	4b51      	ldr	r3, [pc, #324]	@ (8006ad4 <USBD_CDC_Init+0x1e8>)
 8006990:	781b      	ldrb	r3, [r3, #0]
 8006992:	f003 020f 	and.w	r2, r3, #15
 8006996:	6879      	ldr	r1, [r7, #4]
 8006998:	4613      	mov	r3, r2
 800699a:	009b      	lsls	r3, r3, #2
 800699c:	4413      	add	r3, r2
 800699e:	009b      	lsls	r3, r3, #2
 80069a0:	440b      	add	r3, r1
 80069a2:	f503 73b2 	add.w	r3, r3, #356	@ 0x164
 80069a6:	2201      	movs	r2, #1
 80069a8:	801a      	strh	r2, [r3, #0]

    /* Set bInterval for CDC CMD Endpoint */
    pdev->ep_in[CDCCmdEpAdd & 0xFU].bInterval = CDC_HS_BINTERVAL;
 80069aa:	4b4b      	ldr	r3, [pc, #300]	@ (8006ad8 <USBD_CDC_Init+0x1ec>)
 80069ac:	781b      	ldrb	r3, [r3, #0]
 80069ae:	f003 020f 	and.w	r2, r3, #15
 80069b2:	6879      	ldr	r1, [r7, #4]
 80069b4:	4613      	mov	r3, r2
 80069b6:	009b      	lsls	r3, r3, #2
 80069b8:	4413      	add	r3, r2
 80069ba:	009b      	lsls	r3, r3, #2
 80069bc:	440b      	add	r3, r1
 80069be:	3326      	adds	r3, #38	@ 0x26
 80069c0:	2210      	movs	r2, #16
 80069c2:	801a      	strh	r2, [r3, #0]
 80069c4:	e035      	b.n	8006a32 <USBD_CDC_Init+0x146>
  }
  else
  {
    /* Open EP IN */
    (void)USBD_LL_OpenEP(pdev, CDCInEpAdd, USBD_EP_TYPE_BULK,
 80069c6:	4b42      	ldr	r3, [pc, #264]	@ (8006ad0 <USBD_CDC_Init+0x1e4>)
 80069c8:	7819      	ldrb	r1, [r3, #0]
 80069ca:	2340      	movs	r3, #64	@ 0x40
 80069cc:	2202      	movs	r2, #2
 80069ce:	6878      	ldr	r0, [r7, #4]
 80069d0:	f021 fac7 	bl	8027f62 <USBD_LL_OpenEP>
                         CDC_DATA_FS_IN_PACKET_SIZE);

    pdev->ep_in[CDCInEpAdd & 0xFU].is_used = 1U;
 80069d4:	4b3e      	ldr	r3, [pc, #248]	@ (8006ad0 <USBD_CDC_Init+0x1e4>)
 80069d6:	781b      	ldrb	r3, [r3, #0]
 80069d8:	f003 020f 	and.w	r2, r3, #15
 80069dc:	6879      	ldr	r1, [r7, #4]
 80069de:	4613      	mov	r3, r2
 80069e0:	009b      	lsls	r3, r3, #2
 80069e2:	4413      	add	r3, r2
 80069e4:	009b      	lsls	r3, r3, #2
 80069e6:	440b      	add	r3, r1
 80069e8:	3324      	adds	r3, #36	@ 0x24
 80069ea:	2201      	movs	r2, #1
 80069ec:	801a      	strh	r2, [r3, #0]

    /* Open EP OUT */
    (void)USBD_LL_OpenEP(pdev, CDCOutEpAdd, USBD_EP_TYPE_BULK,
 80069ee:	4b39      	ldr	r3, [pc, #228]	@ (8006ad4 <USBD_CDC_Init+0x1e8>)
 80069f0:	7819      	ldrb	r1, [r3, #0]
 80069f2:	2340      	movs	r3, #64	@ 0x40
 80069f4:	2202      	movs	r2, #2
 80069f6:	6878      	ldr	r0, [r7, #4]
 80069f8:	f021 fab3 	bl	8027f62 <USBD_LL_OpenEP>
                         CDC_DATA_FS_OUT_PACKET_SIZE);

    pdev->ep_out[CDCOutEpAdd & 0xFU].is_used = 1U;
 80069fc:	4b35      	ldr	r3, [pc, #212]	@ (8006ad4 <USBD_CDC_Init+0x1e8>)
 80069fe:	781b      	ldrb	r3, [r3, #0]
 8006a00:	f003 020f 	and.w	r2, r3, #15
 8006a04:	6879      	ldr	r1, [r7, #4]
 8006a06:	4613      	mov	r3, r2
 8006a08:	009b      	lsls	r3, r3, #2
 8006a0a:	4413      	add	r3, r2
 8006a0c:	009b      	lsls	r3, r3, #2
 8006a0e:	440b      	add	r3, r1
 8006a10:	f503 73b2 	add.w	r3, r3, #356	@ 0x164
 8006a14:	2201      	movs	r2, #1
 8006a16:	801a      	strh	r2, [r3, #0]

    /* Set bInterval for CMD Endpoint */
    pdev->ep_in[CDCCmdEpAdd & 0xFU].bInterval = CDC_FS_BINTERVAL;
 8006a18:	4b2f      	ldr	r3, [pc, #188]	@ (8006ad8 <USBD_CDC_Init+0x1ec>)
 8006a1a:	781b      	ldrb	r3, [r3, #0]
 8006a1c:	f003 020f 	and.w	r2, r3, #15
 8006a20:	6879      	ldr	r1, [r7, #4]
 8006a22:	4613      	mov	r3, r2
 8006a24:	009b      	lsls	r3, r3, #2
 8006a26:	4413      	add	r3, r2
 8006a28:	009b      	lsls	r3, r3, #2
 8006a2a:	440b      	add	r3, r1
 8006a2c:	3326      	adds	r3, #38	@ 0x26
 8006a2e:	2210      	movs	r2, #16
 8006a30:	801a      	strh	r2, [r3, #0]
  }

  /* Open Command IN EP */
  (void)USBD_LL_OpenEP(pdev, CDCCmdEpAdd, USBD_EP_TYPE_INTR, CDC_CMD_PACKET_SIZE);
 8006a32:	4b29      	ldr	r3, [pc, #164]	@ (8006ad8 <USBD_CDC_Init+0x1ec>)
 8006a34:	7819      	ldrb	r1, [r3, #0]
 8006a36:	2308      	movs	r3, #8
 8006a38:	2203      	movs	r2, #3
 8006a3a:	6878      	ldr	r0, [r7, #4]
 8006a3c:	f021 fa91 	bl	8027f62 <USBD_LL_OpenEP>
  pdev->ep_in[CDCCmdEpAdd & 0xFU].is_used = 1U;
 8006a40:	4b25      	ldr	r3, [pc, #148]	@ (8006ad8 <USBD_CDC_Init+0x1ec>)
 8006a42:	781b      	ldrb	r3, [r3, #0]
 8006a44:	f003 020f 	and.w	r2, r3, #15
 8006a48:	6879      	ldr	r1, [r7, #4]
 8006a4a:	4613      	mov	r3, r2
 8006a4c:	009b      	lsls	r3, r3, #2
 8006a4e:	4413      	add	r3, r2
 8006a50:	009b      	lsls	r3, r3, #2
 8006a52:	440b      	add	r3, r1
 8006a54:	3324      	adds	r3, #36	@ 0x24
 8006a56:	2201      	movs	r2, #1
 8006a58:	801a      	strh	r2, [r3, #0]

  hcdc->RxBuffer = NULL;
 8006a5a:	68fb      	ldr	r3, [r7, #12]
 8006a5c:	2200      	movs	r2, #0
 8006a5e:	f8c3 2204 	str.w	r2, [r3, #516]	@ 0x204

  /* Init  physical Interface components */
  ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Init();
 8006a62:	687b      	ldr	r3, [r7, #4]
 8006a64:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8006a68:	687a      	ldr	r2, [r7, #4]
 8006a6a:	33b0      	adds	r3, #176	@ 0xb0
 8006a6c:	009b      	lsls	r3, r3, #2
 8006a6e:	4413      	add	r3, r2
 8006a70:	685b      	ldr	r3, [r3, #4]
 8006a72:	681b      	ldr	r3, [r3, #0]
 8006a74:	4798      	blx	r3

  /* Init Xfer states */
  hcdc->TxState = 0U;
 8006a76:	68fb      	ldr	r3, [r7, #12]
 8006a78:	2200      	movs	r2, #0
 8006a7a:	f8c3 2214 	str.w	r2, [r3, #532]	@ 0x214
  hcdc->RxState = 0U;
 8006a7e:	68fb      	ldr	r3, [r7, #12]
 8006a80:	2200      	movs	r2, #0
 8006a82:	f8c3 2218 	str.w	r2, [r3, #536]	@ 0x218

  if (hcdc->RxBuffer == NULL)
 8006a86:	68fb      	ldr	r3, [r7, #12]
 8006a88:	f8d3 3204 	ldr.w	r3, [r3, #516]	@ 0x204
 8006a8c:	2b00      	cmp	r3, #0
 8006a8e:	d101      	bne.n	8006a94 <USBD_CDC_Init+0x1a8>
  {
    return (uint8_t)USBD_EMEM;
 8006a90:	2302      	movs	r3, #2
 8006a92:	e018      	b.n	8006ac6 <USBD_CDC_Init+0x1da>
  }

  if (pdev->dev_speed == USBD_SPEED_HIGH)
 8006a94:	687b      	ldr	r3, [r7, #4]
 8006a96:	7c1b      	ldrb	r3, [r3, #16]
 8006a98:	2b00      	cmp	r3, #0
 8006a9a:	d10a      	bne.n	8006ab2 <USBD_CDC_Init+0x1c6>
  {
    /* Prepare Out endpoint to receive next packet */
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
 8006a9c:	4b0d      	ldr	r3, [pc, #52]	@ (8006ad4 <USBD_CDC_Init+0x1e8>)
 8006a9e:	7819      	ldrb	r1, [r3, #0]
 8006aa0:	68fb      	ldr	r3, [r7, #12]
 8006aa2:	f8d3 2204 	ldr.w	r2, [r3, #516]	@ 0x204
 8006aa6:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8006aaa:	6878      	ldr	r0, [r7, #4]
 8006aac:	f021 fb48 	bl	8028140 <USBD_LL_PrepareReceive>
 8006ab0:	e008      	b.n	8006ac4 <USBD_CDC_Init+0x1d8>
                                 CDC_DATA_HS_OUT_PACKET_SIZE);
  }
  else
  {
    /* Prepare Out endpoint to receive next packet */
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
 8006ab2:	4b08      	ldr	r3, [pc, #32]	@ (8006ad4 <USBD_CDC_Init+0x1e8>)
 8006ab4:	7819      	ldrb	r1, [r3, #0]
 8006ab6:	68fb      	ldr	r3, [r7, #12]
 8006ab8:	f8d3 2204 	ldr.w	r2, [r3, #516]	@ 0x204
 8006abc:	2340      	movs	r3, #64	@ 0x40
 8006abe:	6878      	ldr	r0, [r7, #4]
 8006ac0:	f021 fb3e 	bl	8028140 <USBD_LL_PrepareReceive>
                                 CDC_DATA_FS_OUT_PACKET_SIZE);
  }

  return (uint8_t)USBD_OK;
 8006ac4:	2300      	movs	r3, #0
}
 8006ac6:	4618      	mov	r0, r3
 8006ac8:	3710      	adds	r7, #16
 8006aca:	46bd      	mov	sp, r7
 8006acc:	bd80      	pop	{r7, pc}
 8006ace:	bf00      	nop
 8006ad0:	200000ab 	.word	0x200000ab
 8006ad4:	200000ac 	.word	0x200000ac
 8006ad8:	200000ad 	.word	0x200000ad

08006adc <USBD_CDC_DeInit>:
  * @param  pdev: device instance
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t USBD_CDC_DeInit(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 8006adc:	b580      	push	{r7, lr}
 8006ade:	b082      	sub	sp, #8
 8006ae0:	af00      	add	r7, sp, #0
 8006ae2:	6078      	str	r0, [r7, #4]
 8006ae4:	460b      	mov	r3, r1
 8006ae6:	70fb      	strb	r3, [r7, #3]
  CDCOutEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_OUT, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
  CDCCmdEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_INTR, (uint8_t)pdev->classId);
#endif /* USE_USBD_COMPOSITE */

  /* Close EP IN */
  (void)USBD_LL_CloseEP(pdev, CDCInEpAdd);
 8006ae8:	4b3a      	ldr	r3, [pc, #232]	@ (8006bd4 <USBD_CDC_DeInit+0xf8>)
 8006aea:	781b      	ldrb	r3, [r3, #0]
 8006aec:	4619      	mov	r1, r3
 8006aee:	6878      	ldr	r0, [r7, #4]
 8006af0:	f021 fa5d 	bl	8027fae <USBD_LL_CloseEP>
  pdev->ep_in[CDCInEpAdd & 0xFU].is_used = 0U;
 8006af4:	4b37      	ldr	r3, [pc, #220]	@ (8006bd4 <USBD_CDC_DeInit+0xf8>)
 8006af6:	781b      	ldrb	r3, [r3, #0]
 8006af8:	f003 020f 	and.w	r2, r3, #15
 8006afc:	6879      	ldr	r1, [r7, #4]
 8006afe:	4613      	mov	r3, r2
 8006b00:	009b      	lsls	r3, r3, #2
 8006b02:	4413      	add	r3, r2
 8006b04:	009b      	lsls	r3, r3, #2
 8006b06:	440b      	add	r3, r1
 8006b08:	3324      	adds	r3, #36	@ 0x24
 8006b0a:	2200      	movs	r2, #0
 8006b0c:	801a      	strh	r2, [r3, #0]

  /* Close EP OUT */
  (void)USBD_LL_CloseEP(pdev, CDCOutEpAdd);
 8006b0e:	4b32      	ldr	r3, [pc, #200]	@ (8006bd8 <USBD_CDC_DeInit+0xfc>)
 8006b10:	781b      	ldrb	r3, [r3, #0]
 8006b12:	4619      	mov	r1, r3
 8006b14:	6878      	ldr	r0, [r7, #4]
 8006b16:	f021 fa4a 	bl	8027fae <USBD_LL_CloseEP>
  pdev->ep_out[CDCOutEpAdd & 0xFU].is_used = 0U;
 8006b1a:	4b2f      	ldr	r3, [pc, #188]	@ (8006bd8 <USBD_CDC_DeInit+0xfc>)
 8006b1c:	781b      	ldrb	r3, [r3, #0]
 8006b1e:	f003 020f 	and.w	r2, r3, #15
 8006b22:	6879      	ldr	r1, [r7, #4]
 8006b24:	4613      	mov	r3, r2
 8006b26:	009b      	lsls	r3, r3, #2
 8006b28:	4413      	add	r3, r2
 8006b2a:	009b      	lsls	r3, r3, #2
 8006b2c:	440b      	add	r3, r1
 8006b2e:	f503 73b2 	add.w	r3, r3, #356	@ 0x164
 8006b32:	2200      	movs	r2, #0
 8006b34:	801a      	strh	r2, [r3, #0]

  /* Close Command IN EP */
  (void)USBD_LL_CloseEP(pdev, CDCCmdEpAdd);
 8006b36:	4b29      	ldr	r3, [pc, #164]	@ (8006bdc <USBD_CDC_DeInit+0x100>)
 8006b38:	781b      	ldrb	r3, [r3, #0]
 8006b3a:	4619      	mov	r1, r3
 8006b3c:	6878      	ldr	r0, [r7, #4]
 8006b3e:	f021 fa36 	bl	8027fae <USBD_LL_CloseEP>
  pdev->ep_in[CDCCmdEpAdd & 0xFU].is_used = 0U;
 8006b42:	4b26      	ldr	r3, [pc, #152]	@ (8006bdc <USBD_CDC_DeInit+0x100>)
 8006b44:	781b      	ldrb	r3, [r3, #0]
 8006b46:	f003 020f 	and.w	r2, r3, #15
 8006b4a:	6879      	ldr	r1, [r7, #4]
 8006b4c:	4613      	mov	r3, r2
 8006b4e:	009b      	lsls	r3, r3, #2
 8006b50:	4413      	add	r3, r2
 8006b52:	009b      	lsls	r3, r3, #2
 8006b54:	440b      	add	r3, r1
 8006b56:	3324      	adds	r3, #36	@ 0x24
 8006b58:	2200      	movs	r2, #0
 8006b5a:	801a      	strh	r2, [r3, #0]
  pdev->ep_in[CDCCmdEpAdd & 0xFU].bInterval = 0U;
 8006b5c:	4b1f      	ldr	r3, [pc, #124]	@ (8006bdc <USBD_CDC_DeInit+0x100>)
 8006b5e:	781b      	ldrb	r3, [r3, #0]
 8006b60:	f003 020f 	and.w	r2, r3, #15
 8006b64:	6879      	ldr	r1, [r7, #4]
 8006b66:	4613      	mov	r3, r2
 8006b68:	009b      	lsls	r3, r3, #2
 8006b6a:	4413      	add	r3, r2
 8006b6c:	009b      	lsls	r3, r3, #2
 8006b6e:	440b      	add	r3, r1
 8006b70:	3326      	adds	r3, #38	@ 0x26
 8006b72:	2200      	movs	r2, #0
 8006b74:	801a      	strh	r2, [r3, #0]

  /* DeInit  physical Interface components */
  if (pdev->pClassDataCmsit[pdev->classId] != NULL)
 8006b76:	687b      	ldr	r3, [r7, #4]
 8006b78:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8006b7c:	687b      	ldr	r3, [r7, #4]
 8006b7e:	32b0      	adds	r2, #176	@ 0xb0
 8006b80:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8006b84:	2b00      	cmp	r3, #0
 8006b86:	d01f      	beq.n	8006bc8 <USBD_CDC_DeInit+0xec>
  {
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->DeInit();
 8006b88:	687b      	ldr	r3, [r7, #4]
 8006b8a:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8006b8e:	687a      	ldr	r2, [r7, #4]
 8006b90:	33b0      	adds	r3, #176	@ 0xb0
 8006b92:	009b      	lsls	r3, r3, #2
 8006b94:	4413      	add	r3, r2
 8006b96:	685b      	ldr	r3, [r3, #4]
 8006b98:	685b      	ldr	r3, [r3, #4]
 8006b9a:	4798      	blx	r3
    (void)USBD_free(pdev->pClassDataCmsit[pdev->classId]);
 8006b9c:	687b      	ldr	r3, [r7, #4]
 8006b9e:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8006ba2:	687b      	ldr	r3, [r7, #4]
 8006ba4:	32b0      	adds	r2, #176	@ 0xb0
 8006ba6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8006baa:	4618      	mov	r0, r3
 8006bac:	f021 fb0a 	bl	80281c4 <USBD_static_free>
    pdev->pClassDataCmsit[pdev->classId] = NULL;
 8006bb0:	687b      	ldr	r3, [r7, #4]
 8006bb2:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8006bb6:	687b      	ldr	r3, [r7, #4]
 8006bb8:	32b0      	adds	r2, #176	@ 0xb0
 8006bba:	2100      	movs	r1, #0
 8006bbc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    pdev->pClassData = NULL;
 8006bc0:	687b      	ldr	r3, [r7, #4]
 8006bc2:	2200      	movs	r2, #0
 8006bc4:	f8c3 22bc 	str.w	r2, [r3, #700]	@ 0x2bc
  }

  return (uint8_t)USBD_OK;
 8006bc8:	2300      	movs	r3, #0
}
 8006bca:	4618      	mov	r0, r3
 8006bcc:	3708      	adds	r7, #8
 8006bce:	46bd      	mov	sp, r7
 8006bd0:	bd80      	pop	{r7, pc}
 8006bd2:	bf00      	nop
 8006bd4:	200000ab 	.word	0x200000ab
 8006bd8:	200000ac 	.word	0x200000ac
 8006bdc:	200000ad 	.word	0x200000ad

08006be0 <USBD_CDC_Setup>:
  * @param  req: usb requests
  * @retval status
  */
static uint8_t USBD_CDC_Setup(USBD_HandleTypeDef *pdev,
                              USBD_SetupReqTypedef *req)
{
 8006be0:	b580      	push	{r7, lr}
 8006be2:	b086      	sub	sp, #24
 8006be4:	af00      	add	r7, sp, #0
 8006be6:	6078      	str	r0, [r7, #4]
 8006be8:	6039      	str	r1, [r7, #0]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8006bea:	687b      	ldr	r3, [r7, #4]
 8006bec:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8006bf0:	687b      	ldr	r3, [r7, #4]
 8006bf2:	32b0      	adds	r2, #176	@ 0xb0
 8006bf4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8006bf8:	613b      	str	r3, [r7, #16]
  uint16_t len;
  uint8_t ifalt = 0U;
 8006bfa:	2300      	movs	r3, #0
 8006bfc:	737b      	strb	r3, [r7, #13]
  uint16_t status_info = 0U;
 8006bfe:	2300      	movs	r3, #0
 8006c00:	817b      	strh	r3, [r7, #10]
  USBD_StatusTypeDef ret = USBD_OK;
 8006c02:	2300      	movs	r3, #0
 8006c04:	75fb      	strb	r3, [r7, #23]

  if (hcdc == NULL)
 8006c06:	693b      	ldr	r3, [r7, #16]
 8006c08:	2b00      	cmp	r3, #0
 8006c0a:	d101      	bne.n	8006c10 <USBD_CDC_Setup+0x30>
  {
    return (uint8_t)USBD_FAIL;
 8006c0c:	2303      	movs	r3, #3
 8006c0e:	e0bf      	b.n	8006d90 <USBD_CDC_Setup+0x1b0>
  }

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8006c10:	683b      	ldr	r3, [r7, #0]
 8006c12:	781b      	ldrb	r3, [r3, #0]
 8006c14:	f003 0360 	and.w	r3, r3, #96	@ 0x60
 8006c18:	2b00      	cmp	r3, #0
 8006c1a:	d050      	beq.n	8006cbe <USBD_CDC_Setup+0xde>
 8006c1c:	2b20      	cmp	r3, #32
 8006c1e:	f040 80af 	bne.w	8006d80 <USBD_CDC_Setup+0x1a0>
  {
    case USB_REQ_TYPE_CLASS:
      if (req->wLength != 0U)
 8006c22:	683b      	ldr	r3, [r7, #0]
 8006c24:	88db      	ldrh	r3, [r3, #6]
 8006c26:	2b00      	cmp	r3, #0
 8006c28:	d03a      	beq.n	8006ca0 <USBD_CDC_Setup+0xc0>
      {
        if ((req->bmRequest & 0x80U) != 0U)
 8006c2a:	683b      	ldr	r3, [r7, #0]
 8006c2c:	781b      	ldrb	r3, [r3, #0]
 8006c2e:	b25b      	sxtb	r3, r3
 8006c30:	2b00      	cmp	r3, #0
 8006c32:	da1b      	bge.n	8006c6c <USBD_CDC_Setup+0x8c>
        {
          ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(req->bRequest,
 8006c34:	687b      	ldr	r3, [r7, #4]
 8006c36:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8006c3a:	687a      	ldr	r2, [r7, #4]
 8006c3c:	33b0      	adds	r3, #176	@ 0xb0
 8006c3e:	009b      	lsls	r3, r3, #2
 8006c40:	4413      	add	r3, r2
 8006c42:	685b      	ldr	r3, [r3, #4]
 8006c44:	689b      	ldr	r3, [r3, #8]
 8006c46:	683a      	ldr	r2, [r7, #0]
 8006c48:	7850      	ldrb	r0, [r2, #1]
                                                                           (uint8_t *)hcdc->data,
 8006c4a:	6939      	ldr	r1, [r7, #16]
          ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(req->bRequest,
 8006c4c:	683a      	ldr	r2, [r7, #0]
 8006c4e:	88d2      	ldrh	r2, [r2, #6]
 8006c50:	4798      	blx	r3
                                                                           req->wLength);

          len = MIN(CDC_REQ_MAX_DATA_SIZE, req->wLength);
 8006c52:	683b      	ldr	r3, [r7, #0]
 8006c54:	88db      	ldrh	r3, [r3, #6]
 8006c56:	2b07      	cmp	r3, #7
 8006c58:	bf28      	it	cs
 8006c5a:	2307      	movcs	r3, #7
 8006c5c:	81fb      	strh	r3, [r7, #14]
          (void)USBD_CtlSendData(pdev, (uint8_t *)hcdc->data, len);
 8006c5e:	693b      	ldr	r3, [r7, #16]
 8006c60:	89fa      	ldrh	r2, [r7, #14]
 8006c62:	4619      	mov	r1, r3
 8006c64:	6878      	ldr	r0, [r7, #4]
 8006c66:	f001 fd93 	bl	8008790 <USBD_CtlSendData>
      else
      {
        ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(req->bRequest,
                                                                         (uint8_t *)req, 0U);
      }
      break;
 8006c6a:	e090      	b.n	8006d8e <USBD_CDC_Setup+0x1ae>
          hcdc->CmdOpCode = req->bRequest;
 8006c6c:	683b      	ldr	r3, [r7, #0]
 8006c6e:	785a      	ldrb	r2, [r3, #1]
 8006c70:	693b      	ldr	r3, [r7, #16]
 8006c72:	f883 2200 	strb.w	r2, [r3, #512]	@ 0x200
          hcdc->CmdLength = (uint8_t)MIN(req->wLength, USB_MAX_EP0_SIZE);
 8006c76:	683b      	ldr	r3, [r7, #0]
 8006c78:	88db      	ldrh	r3, [r3, #6]
 8006c7a:	2b3f      	cmp	r3, #63	@ 0x3f
 8006c7c:	d803      	bhi.n	8006c86 <USBD_CDC_Setup+0xa6>
 8006c7e:	683b      	ldr	r3, [r7, #0]
 8006c80:	88db      	ldrh	r3, [r3, #6]
 8006c82:	b2da      	uxtb	r2, r3
 8006c84:	e000      	b.n	8006c88 <USBD_CDC_Setup+0xa8>
 8006c86:	2240      	movs	r2, #64	@ 0x40
 8006c88:	693b      	ldr	r3, [r7, #16]
 8006c8a:	f883 2201 	strb.w	r2, [r3, #513]	@ 0x201
          (void)USBD_CtlPrepareRx(pdev, (uint8_t *)hcdc->data, hcdc->CmdLength);
 8006c8e:	6939      	ldr	r1, [r7, #16]
 8006c90:	693b      	ldr	r3, [r7, #16]
 8006c92:	f893 3201 	ldrb.w	r3, [r3, #513]	@ 0x201
 8006c96:	461a      	mov	r2, r3
 8006c98:	6878      	ldr	r0, [r7, #4]
 8006c9a:	f001 fda5 	bl	80087e8 <USBD_CtlPrepareRx>
      break;
 8006c9e:	e076      	b.n	8006d8e <USBD_CDC_Setup+0x1ae>
        ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(req->bRequest,
 8006ca0:	687b      	ldr	r3, [r7, #4]
 8006ca2:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8006ca6:	687a      	ldr	r2, [r7, #4]
 8006ca8:	33b0      	adds	r3, #176	@ 0xb0
 8006caa:	009b      	lsls	r3, r3, #2
 8006cac:	4413      	add	r3, r2
 8006cae:	685b      	ldr	r3, [r3, #4]
 8006cb0:	689b      	ldr	r3, [r3, #8]
 8006cb2:	683a      	ldr	r2, [r7, #0]
 8006cb4:	7850      	ldrb	r0, [r2, #1]
 8006cb6:	2200      	movs	r2, #0
 8006cb8:	6839      	ldr	r1, [r7, #0]
 8006cba:	4798      	blx	r3
      break;
 8006cbc:	e067      	b.n	8006d8e <USBD_CDC_Setup+0x1ae>

    case USB_REQ_TYPE_STANDARD:
      switch (req->bRequest)
 8006cbe:	683b      	ldr	r3, [r7, #0]
 8006cc0:	785b      	ldrb	r3, [r3, #1]
 8006cc2:	2b0b      	cmp	r3, #11
 8006cc4:	d851      	bhi.n	8006d6a <USBD_CDC_Setup+0x18a>
 8006cc6:	a201      	add	r2, pc, #4	@ (adr r2, 8006ccc <USBD_CDC_Setup+0xec>)
 8006cc8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8006ccc:	08006cfd 	.word	0x08006cfd
 8006cd0:	08006d79 	.word	0x08006d79
 8006cd4:	08006d6b 	.word	0x08006d6b
 8006cd8:	08006d6b 	.word	0x08006d6b
 8006cdc:	08006d6b 	.word	0x08006d6b
 8006ce0:	08006d6b 	.word	0x08006d6b
 8006ce4:	08006d6b 	.word	0x08006d6b
 8006ce8:	08006d6b 	.word	0x08006d6b
 8006cec:	08006d6b 	.word	0x08006d6b
 8006cf0:	08006d6b 	.word	0x08006d6b
 8006cf4:	08006d27 	.word	0x08006d27
 8006cf8:	08006d51 	.word	0x08006d51
      {
        case USB_REQ_GET_STATUS:
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8006cfc:	687b      	ldr	r3, [r7, #4]
 8006cfe:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8006d02:	b2db      	uxtb	r3, r3
 8006d04:	2b03      	cmp	r3, #3
 8006d06:	d107      	bne.n	8006d18 <USBD_CDC_Setup+0x138>
          {
            (void)USBD_CtlSendData(pdev, (uint8_t *)&status_info, 2U);
 8006d08:	f107 030a 	add.w	r3, r7, #10
 8006d0c:	2202      	movs	r2, #2
 8006d0e:	4619      	mov	r1, r3
 8006d10:	6878      	ldr	r0, [r7, #4]
 8006d12:	f001 fd3d 	bl	8008790 <USBD_CtlSendData>
          else
          {
            USBD_CtlError(pdev, req);
            ret = USBD_FAIL;
          }
          break;
 8006d16:	e032      	b.n	8006d7e <USBD_CDC_Setup+0x19e>
            USBD_CtlError(pdev, req);
 8006d18:	6839      	ldr	r1, [r7, #0]
 8006d1a:	6878      	ldr	r0, [r7, #4]
 8006d1c:	f001 fcbb 	bl	8008696 <USBD_CtlError>
            ret = USBD_FAIL;
 8006d20:	2303      	movs	r3, #3
 8006d22:	75fb      	strb	r3, [r7, #23]
          break;
 8006d24:	e02b      	b.n	8006d7e <USBD_CDC_Setup+0x19e>

        case USB_REQ_GET_INTERFACE:
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8006d26:	687b      	ldr	r3, [r7, #4]
 8006d28:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8006d2c:	b2db      	uxtb	r3, r3
 8006d2e:	2b03      	cmp	r3, #3
 8006d30:	d107      	bne.n	8006d42 <USBD_CDC_Setup+0x162>
          {
            (void)USBD_CtlSendData(pdev, &ifalt, 1U);
 8006d32:	f107 030d 	add.w	r3, r7, #13
 8006d36:	2201      	movs	r2, #1
 8006d38:	4619      	mov	r1, r3
 8006d3a:	6878      	ldr	r0, [r7, #4]
 8006d3c:	f001 fd28 	bl	8008790 <USBD_CtlSendData>
          else
          {
            USBD_CtlError(pdev, req);
            ret = USBD_FAIL;
          }
          break;
 8006d40:	e01d      	b.n	8006d7e <USBD_CDC_Setup+0x19e>
            USBD_CtlError(pdev, req);
 8006d42:	6839      	ldr	r1, [r7, #0]
 8006d44:	6878      	ldr	r0, [r7, #4]
 8006d46:	f001 fca6 	bl	8008696 <USBD_CtlError>
            ret = USBD_FAIL;
 8006d4a:	2303      	movs	r3, #3
 8006d4c:	75fb      	strb	r3, [r7, #23]
          break;
 8006d4e:	e016      	b.n	8006d7e <USBD_CDC_Setup+0x19e>

        case USB_REQ_SET_INTERFACE:
          if (pdev->dev_state != USBD_STATE_CONFIGURED)
 8006d50:	687b      	ldr	r3, [r7, #4]
 8006d52:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8006d56:	b2db      	uxtb	r3, r3
 8006d58:	2b03      	cmp	r3, #3
 8006d5a:	d00f      	beq.n	8006d7c <USBD_CDC_Setup+0x19c>
          {
            USBD_CtlError(pdev, req);
 8006d5c:	6839      	ldr	r1, [r7, #0]
 8006d5e:	6878      	ldr	r0, [r7, #4]
 8006d60:	f001 fc99 	bl	8008696 <USBD_CtlError>
            ret = USBD_FAIL;
 8006d64:	2303      	movs	r3, #3
 8006d66:	75fb      	strb	r3, [r7, #23]
          }
          break;
 8006d68:	e008      	b.n	8006d7c <USBD_CDC_Setup+0x19c>

        case USB_REQ_CLEAR_FEATURE:
          break;

        default:
          USBD_CtlError(pdev, req);
 8006d6a:	6839      	ldr	r1, [r7, #0]
 8006d6c:	6878      	ldr	r0, [r7, #4]
 8006d6e:	f001 fc92 	bl	8008696 <USBD_CtlError>
          ret = USBD_FAIL;
 8006d72:	2303      	movs	r3, #3
 8006d74:	75fb      	strb	r3, [r7, #23]
          break;
 8006d76:	e002      	b.n	8006d7e <USBD_CDC_Setup+0x19e>
          break;
 8006d78:	bf00      	nop
 8006d7a:	e008      	b.n	8006d8e <USBD_CDC_Setup+0x1ae>
          break;
 8006d7c:	bf00      	nop
      }
      break;
 8006d7e:	e006      	b.n	8006d8e <USBD_CDC_Setup+0x1ae>

    default:
      USBD_CtlError(pdev, req);
 8006d80:	6839      	ldr	r1, [r7, #0]
 8006d82:	6878      	ldr	r0, [r7, #4]
 8006d84:	f001 fc87 	bl	8008696 <USBD_CtlError>
      ret = USBD_FAIL;
 8006d88:	2303      	movs	r3, #3
 8006d8a:	75fb      	strb	r3, [r7, #23]
      break;
 8006d8c:	bf00      	nop
  }

  return (uint8_t)ret;
 8006d8e:	7dfb      	ldrb	r3, [r7, #23]
}
 8006d90:	4618      	mov	r0, r3
 8006d92:	3718      	adds	r7, #24
 8006d94:	46bd      	mov	sp, r7
 8006d96:	bd80      	pop	{r7, pc}

08006d98 <USBD_CDC_DataIn>:
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t USBD_CDC_DataIn(USBD_HandleTypeDef *pdev, uint8_t epnum)
{
 8006d98:	b580      	push	{r7, lr}
 8006d9a:	b084      	sub	sp, #16
 8006d9c:	af00      	add	r7, sp, #0
 8006d9e:	6078      	str	r0, [r7, #4]
 8006da0:	460b      	mov	r3, r1
 8006da2:	70fb      	strb	r3, [r7, #3]
  USBD_CDC_HandleTypeDef *hcdc;
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef *)pdev->pData;
 8006da4:	687b      	ldr	r3, [r7, #4]
 8006da6:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 8006daa:	60fb      	str	r3, [r7, #12]

  if (pdev->pClassDataCmsit[pdev->classId] == NULL)
 8006dac:	687b      	ldr	r3, [r7, #4]
 8006dae:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8006db2:	687b      	ldr	r3, [r7, #4]
 8006db4:	32b0      	adds	r2, #176	@ 0xb0
 8006db6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8006dba:	2b00      	cmp	r3, #0
 8006dbc:	d101      	bne.n	8006dc2 <USBD_CDC_DataIn+0x2a>
  {
    return (uint8_t)USBD_FAIL;
 8006dbe:	2303      	movs	r3, #3
 8006dc0:	e065      	b.n	8006e8e <USBD_CDC_DataIn+0xf6>
  }

  hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8006dc2:	687b      	ldr	r3, [r7, #4]
 8006dc4:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8006dc8:	687b      	ldr	r3, [r7, #4]
 8006dca:	32b0      	adds	r2, #176	@ 0xb0
 8006dcc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8006dd0:	60bb      	str	r3, [r7, #8]

  if ((pdev->ep_in[epnum & 0xFU].total_length > 0U) &&
 8006dd2:	78fb      	ldrb	r3, [r7, #3]
 8006dd4:	f003 020f 	and.w	r2, r3, #15
 8006dd8:	6879      	ldr	r1, [r7, #4]
 8006dda:	4613      	mov	r3, r2
 8006ddc:	009b      	lsls	r3, r3, #2
 8006dde:	4413      	add	r3, r2
 8006de0:	009b      	lsls	r3, r3, #2
 8006de2:	440b      	add	r3, r1
 8006de4:	3318      	adds	r3, #24
 8006de6:	681b      	ldr	r3, [r3, #0]
 8006de8:	2b00      	cmp	r3, #0
 8006dea:	d02f      	beq.n	8006e4c <USBD_CDC_DataIn+0xb4>
      ((pdev->ep_in[epnum & 0xFU].total_length % hpcd->IN_ep[epnum & 0xFU].maxpacket) == 0U))
 8006dec:	78fb      	ldrb	r3, [r7, #3]
 8006dee:	f003 020f 	and.w	r2, r3, #15
 8006df2:	6879      	ldr	r1, [r7, #4]
 8006df4:	4613      	mov	r3, r2
 8006df6:	009b      	lsls	r3, r3, #2
 8006df8:	4413      	add	r3, r2
 8006dfa:	009b      	lsls	r3, r3, #2
 8006dfc:	440b      	add	r3, r1
 8006dfe:	3318      	adds	r3, #24
 8006e00:	681a      	ldr	r2, [r3, #0]
 8006e02:	78fb      	ldrb	r3, [r7, #3]
 8006e04:	f003 010f 	and.w	r1, r3, #15
 8006e08:	68f8      	ldr	r0, [r7, #12]
 8006e0a:	460b      	mov	r3, r1
 8006e0c:	00db      	lsls	r3, r3, #3
 8006e0e:	440b      	add	r3, r1
 8006e10:	009b      	lsls	r3, r3, #2
 8006e12:	4403      	add	r3, r0
 8006e14:	331c      	adds	r3, #28
 8006e16:	681b      	ldr	r3, [r3, #0]
 8006e18:	fbb2 f1f3 	udiv	r1, r2, r3
 8006e1c:	fb01 f303 	mul.w	r3, r1, r3
 8006e20:	1ad3      	subs	r3, r2, r3
  if ((pdev->ep_in[epnum & 0xFU].total_length > 0U) &&
 8006e22:	2b00      	cmp	r3, #0
 8006e24:	d112      	bne.n	8006e4c <USBD_CDC_DataIn+0xb4>
  {
    /* Update the packet total length */
    pdev->ep_in[epnum & 0xFU].total_length = 0U;
 8006e26:	78fb      	ldrb	r3, [r7, #3]
 8006e28:	f003 020f 	and.w	r2, r3, #15
 8006e2c:	6879      	ldr	r1, [r7, #4]
 8006e2e:	4613      	mov	r3, r2
 8006e30:	009b      	lsls	r3, r3, #2
 8006e32:	4413      	add	r3, r2
 8006e34:	009b      	lsls	r3, r3, #2
 8006e36:	440b      	add	r3, r1
 8006e38:	3318      	adds	r3, #24
 8006e3a:	2200      	movs	r2, #0
 8006e3c:	601a      	str	r2, [r3, #0]

    /* Send ZLP */
    (void)USBD_LL_Transmit(pdev, epnum, NULL, 0U);
 8006e3e:	78f9      	ldrb	r1, [r7, #3]
 8006e40:	2300      	movs	r3, #0
 8006e42:	2200      	movs	r2, #0
 8006e44:	6878      	ldr	r0, [r7, #4]
 8006e46:	f021 f95a 	bl	80280fe <USBD_LL_Transmit>
 8006e4a:	e01f      	b.n	8006e8c <USBD_CDC_DataIn+0xf4>
  }
  else
  {
    hcdc->TxState = 0U;
 8006e4c:	68bb      	ldr	r3, [r7, #8]
 8006e4e:	2200      	movs	r2, #0
 8006e50:	f8c3 2214 	str.w	r2, [r3, #532]	@ 0x214

    if (((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->TransmitCplt != NULL)
 8006e54:	687b      	ldr	r3, [r7, #4]
 8006e56:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8006e5a:	687a      	ldr	r2, [r7, #4]
 8006e5c:	33b0      	adds	r3, #176	@ 0xb0
 8006e5e:	009b      	lsls	r3, r3, #2
 8006e60:	4413      	add	r3, r2
 8006e62:	685b      	ldr	r3, [r3, #4]
 8006e64:	691b      	ldr	r3, [r3, #16]
 8006e66:	2b00      	cmp	r3, #0
 8006e68:	d010      	beq.n	8006e8c <USBD_CDC_DataIn+0xf4>
    {
      ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->TransmitCplt(hcdc->TxBuffer, &hcdc->TxLength, epnum);
 8006e6a:	687b      	ldr	r3, [r7, #4]
 8006e6c:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8006e70:	687a      	ldr	r2, [r7, #4]
 8006e72:	33b0      	adds	r3, #176	@ 0xb0
 8006e74:	009b      	lsls	r3, r3, #2
 8006e76:	4413      	add	r3, r2
 8006e78:	685b      	ldr	r3, [r3, #4]
 8006e7a:	691b      	ldr	r3, [r3, #16]
 8006e7c:	68ba      	ldr	r2, [r7, #8]
 8006e7e:	f8d2 0208 	ldr.w	r0, [r2, #520]	@ 0x208
 8006e82:	68ba      	ldr	r2, [r7, #8]
 8006e84:	f502 7104 	add.w	r1, r2, #528	@ 0x210
 8006e88:	78fa      	ldrb	r2, [r7, #3]
 8006e8a:	4798      	blx	r3
    }
  }

  return (uint8_t)USBD_OK;
 8006e8c:	2300      	movs	r3, #0
}
 8006e8e:	4618      	mov	r0, r3
 8006e90:	3710      	adds	r7, #16
 8006e92:	46bd      	mov	sp, r7
 8006e94:	bd80      	pop	{r7, pc}

08006e96 <USBD_CDC_DataOut>:
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t USBD_CDC_DataOut(USBD_HandleTypeDef *pdev, uint8_t epnum)
{
 8006e96:	b580      	push	{r7, lr}
 8006e98:	b084      	sub	sp, #16
 8006e9a:	af00      	add	r7, sp, #0
 8006e9c:	6078      	str	r0, [r7, #4]
 8006e9e:	460b      	mov	r3, r1
 8006ea0:	70fb      	strb	r3, [r7, #3]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8006ea2:	687b      	ldr	r3, [r7, #4]
 8006ea4:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8006ea8:	687b      	ldr	r3, [r7, #4]
 8006eaa:	32b0      	adds	r2, #176	@ 0xb0
 8006eac:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8006eb0:	60fb      	str	r3, [r7, #12]

  if (pdev->pClassDataCmsit[pdev->classId] == NULL)
 8006eb2:	687b      	ldr	r3, [r7, #4]
 8006eb4:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8006eb8:	687b      	ldr	r3, [r7, #4]
 8006eba:	32b0      	adds	r2, #176	@ 0xb0
 8006ebc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8006ec0:	2b00      	cmp	r3, #0
 8006ec2:	d101      	bne.n	8006ec8 <USBD_CDC_DataOut+0x32>
  {
    return (uint8_t)USBD_FAIL;
 8006ec4:	2303      	movs	r3, #3
 8006ec6:	e01a      	b.n	8006efe <USBD_CDC_DataOut+0x68>
  }

  /* Get the received data length */
  hcdc->RxLength = USBD_LL_GetRxDataSize(pdev, epnum);
 8006ec8:	78fb      	ldrb	r3, [r7, #3]
 8006eca:	4619      	mov	r1, r3
 8006ecc:	6878      	ldr	r0, [r7, #4]
 8006ece:	f021 f958 	bl	8028182 <USBD_LL_GetRxDataSize>
 8006ed2:	4602      	mov	r2, r0
 8006ed4:	68fb      	ldr	r3, [r7, #12]
 8006ed6:	f8c3 220c 	str.w	r2, [r3, #524]	@ 0x20c

  /* USB data will be immediately processed, this allow next USB traffic being
  NAKed till the end of the application Xfer */

  ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Receive(hcdc->RxBuffer, &hcdc->RxLength);
 8006eda:	687b      	ldr	r3, [r7, #4]
 8006edc:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8006ee0:	687a      	ldr	r2, [r7, #4]
 8006ee2:	33b0      	adds	r3, #176	@ 0xb0
 8006ee4:	009b      	lsls	r3, r3, #2
 8006ee6:	4413      	add	r3, r2
 8006ee8:	685b      	ldr	r3, [r3, #4]
 8006eea:	68db      	ldr	r3, [r3, #12]
 8006eec:	68fa      	ldr	r2, [r7, #12]
 8006eee:	f8d2 0204 	ldr.w	r0, [r2, #516]	@ 0x204
 8006ef2:	68fa      	ldr	r2, [r7, #12]
 8006ef4:	f502 7203 	add.w	r2, r2, #524	@ 0x20c
 8006ef8:	4611      	mov	r1, r2
 8006efa:	4798      	blx	r3

  return (uint8_t)USBD_OK;
 8006efc:	2300      	movs	r3, #0
}
 8006efe:	4618      	mov	r0, r3
 8006f00:	3710      	adds	r7, #16
 8006f02:	46bd      	mov	sp, r7
 8006f04:	bd80      	pop	{r7, pc}

08006f06 <USBD_CDC_EP0_RxReady>:
  *         Handle EP0 Rx Ready event
  * @param  pdev: device instance
  * @retval status
  */
static uint8_t USBD_CDC_EP0_RxReady(USBD_HandleTypeDef *pdev)
{
 8006f06:	b580      	push	{r7, lr}
 8006f08:	b084      	sub	sp, #16
 8006f0a:	af00      	add	r7, sp, #0
 8006f0c:	6078      	str	r0, [r7, #4]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8006f0e:	687b      	ldr	r3, [r7, #4]
 8006f10:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8006f14:	687b      	ldr	r3, [r7, #4]
 8006f16:	32b0      	adds	r2, #176	@ 0xb0
 8006f18:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8006f1c:	60fb      	str	r3, [r7, #12]

  if (hcdc == NULL)
 8006f1e:	68fb      	ldr	r3, [r7, #12]
 8006f20:	2b00      	cmp	r3, #0
 8006f22:	d101      	bne.n	8006f28 <USBD_CDC_EP0_RxReady+0x22>
  {
    return (uint8_t)USBD_FAIL;
 8006f24:	2303      	movs	r3, #3
 8006f26:	e024      	b.n	8006f72 <USBD_CDC_EP0_RxReady+0x6c>
  }

  if ((pdev->pUserData[pdev->classId] != NULL) && (hcdc->CmdOpCode != 0xFFU))
 8006f28:	687b      	ldr	r3, [r7, #4]
 8006f2a:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8006f2e:	687a      	ldr	r2, [r7, #4]
 8006f30:	33b0      	adds	r3, #176	@ 0xb0
 8006f32:	009b      	lsls	r3, r3, #2
 8006f34:	4413      	add	r3, r2
 8006f36:	685b      	ldr	r3, [r3, #4]
 8006f38:	2b00      	cmp	r3, #0
 8006f3a:	d019      	beq.n	8006f70 <USBD_CDC_EP0_RxReady+0x6a>
 8006f3c:	68fb      	ldr	r3, [r7, #12]
 8006f3e:	f893 3200 	ldrb.w	r3, [r3, #512]	@ 0x200
 8006f42:	2bff      	cmp	r3, #255	@ 0xff
 8006f44:	d014      	beq.n	8006f70 <USBD_CDC_EP0_RxReady+0x6a>
  {
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(hcdc->CmdOpCode,
 8006f46:	687b      	ldr	r3, [r7, #4]
 8006f48:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8006f4c:	687a      	ldr	r2, [r7, #4]
 8006f4e:	33b0      	adds	r3, #176	@ 0xb0
 8006f50:	009b      	lsls	r3, r3, #2
 8006f52:	4413      	add	r3, r2
 8006f54:	685b      	ldr	r3, [r3, #4]
 8006f56:	689b      	ldr	r3, [r3, #8]
 8006f58:	68fa      	ldr	r2, [r7, #12]
 8006f5a:	f892 0200 	ldrb.w	r0, [r2, #512]	@ 0x200
                                                                     (uint8_t *)hcdc->data,
 8006f5e:	68f9      	ldr	r1, [r7, #12]
                                                                     (uint16_t)hcdc->CmdLength);
 8006f60:	68fa      	ldr	r2, [r7, #12]
 8006f62:	f892 2201 	ldrb.w	r2, [r2, #513]	@ 0x201
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(hcdc->CmdOpCode,
 8006f66:	4798      	blx	r3
    hcdc->CmdOpCode = 0xFFU;
 8006f68:	68fb      	ldr	r3, [r7, #12]
 8006f6a:	22ff      	movs	r2, #255	@ 0xff
 8006f6c:	f883 2200 	strb.w	r2, [r3, #512]	@ 0x200
  }

  return (uint8_t)USBD_OK;
 8006f70:	2300      	movs	r3, #0
}
 8006f72:	4618      	mov	r0, r3
 8006f74:	3710      	adds	r7, #16
 8006f76:	46bd      	mov	sp, r7
 8006f78:	bd80      	pop	{r7, pc}
	...

08006f7c <USBD_CDC_GetFSCfgDesc>:
  *         Return configuration descriptor
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t *USBD_CDC_GetFSCfgDesc(uint16_t *length)
{
 8006f7c:	b580      	push	{r7, lr}
 8006f7e:	b086      	sub	sp, #24
 8006f80:	af00      	add	r7, sp, #0
 8006f82:	6078      	str	r0, [r7, #4]
  USBD_EpDescTypeDef *pEpCmdDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_CMD_EP);
 8006f84:	2182      	movs	r1, #130	@ 0x82
 8006f86:	4818      	ldr	r0, [pc, #96]	@ (8006fe8 <USBD_CDC_GetFSCfgDesc+0x6c>)
 8006f88:	f000 fd4f 	bl	8007a2a <USBD_GetEpDesc>
 8006f8c:	6178      	str	r0, [r7, #20]
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_OUT_EP);
 8006f8e:	2101      	movs	r1, #1
 8006f90:	4815      	ldr	r0, [pc, #84]	@ (8006fe8 <USBD_CDC_GetFSCfgDesc+0x6c>)
 8006f92:	f000 fd4a 	bl	8007a2a <USBD_GetEpDesc>
 8006f96:	6138      	str	r0, [r7, #16]
  USBD_EpDescTypeDef *pEpInDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_IN_EP);
 8006f98:	2181      	movs	r1, #129	@ 0x81
 8006f9a:	4813      	ldr	r0, [pc, #76]	@ (8006fe8 <USBD_CDC_GetFSCfgDesc+0x6c>)
 8006f9c:	f000 fd45 	bl	8007a2a <USBD_GetEpDesc>
 8006fa0:	60f8      	str	r0, [r7, #12]

  if (pEpCmdDesc != NULL)
 8006fa2:	697b      	ldr	r3, [r7, #20]
 8006fa4:	2b00      	cmp	r3, #0
 8006fa6:	d002      	beq.n	8006fae <USBD_CDC_GetFSCfgDesc+0x32>
  {
    pEpCmdDesc->bInterval = CDC_FS_BINTERVAL;
 8006fa8:	697b      	ldr	r3, [r7, #20]
 8006faa:	2210      	movs	r2, #16
 8006fac:	719a      	strb	r2, [r3, #6]
  }

  if (pEpOutDesc != NULL)
 8006fae:	693b      	ldr	r3, [r7, #16]
 8006fb0:	2b00      	cmp	r3, #0
 8006fb2:	d006      	beq.n	8006fc2 <USBD_CDC_GetFSCfgDesc+0x46>
  {
    pEpOutDesc->wMaxPacketSize = CDC_DATA_FS_MAX_PACKET_SIZE;
 8006fb4:	693b      	ldr	r3, [r7, #16]
 8006fb6:	2200      	movs	r2, #0
 8006fb8:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 8006fbc:	711a      	strb	r2, [r3, #4]
 8006fbe:	2200      	movs	r2, #0
 8006fc0:	715a      	strb	r2, [r3, #5]
  }

  if (pEpInDesc != NULL)
 8006fc2:	68fb      	ldr	r3, [r7, #12]
 8006fc4:	2b00      	cmp	r3, #0
 8006fc6:	d006      	beq.n	8006fd6 <USBD_CDC_GetFSCfgDesc+0x5a>
  {
    pEpInDesc->wMaxPacketSize = CDC_DATA_FS_MAX_PACKET_SIZE;
 8006fc8:	68fb      	ldr	r3, [r7, #12]
 8006fca:	2200      	movs	r2, #0
 8006fcc:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 8006fd0:	711a      	strb	r2, [r3, #4]
 8006fd2:	2200      	movs	r2, #0
 8006fd4:	715a      	strb	r2, [r3, #5]
  }

  *length = (uint16_t)sizeof(USBD_CDC_CfgDesc);
 8006fd6:	687b      	ldr	r3, [r7, #4]
 8006fd8:	2243      	movs	r2, #67	@ 0x43
 8006fda:	801a      	strh	r2, [r3, #0]
  return USBD_CDC_CfgDesc;
 8006fdc:	4b02      	ldr	r3, [pc, #8]	@ (8006fe8 <USBD_CDC_GetFSCfgDesc+0x6c>)
}
 8006fde:	4618      	mov	r0, r3
 8006fe0:	3718      	adds	r7, #24
 8006fe2:	46bd      	mov	sp, r7
 8006fe4:	bd80      	pop	{r7, pc}
 8006fe6:	bf00      	nop
 8006fe8:	20000068 	.word	0x20000068

08006fec <USBD_CDC_GetHSCfgDesc>:
  *         Return configuration descriptor
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t *USBD_CDC_GetHSCfgDesc(uint16_t *length)
{
 8006fec:	b580      	push	{r7, lr}
 8006fee:	b086      	sub	sp, #24
 8006ff0:	af00      	add	r7, sp, #0
 8006ff2:	6078      	str	r0, [r7, #4]
  USBD_EpDescTypeDef *pEpCmdDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_CMD_EP);
 8006ff4:	2182      	movs	r1, #130	@ 0x82
 8006ff6:	4818      	ldr	r0, [pc, #96]	@ (8007058 <USBD_CDC_GetHSCfgDesc+0x6c>)
 8006ff8:	f000 fd17 	bl	8007a2a <USBD_GetEpDesc>
 8006ffc:	6178      	str	r0, [r7, #20]
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_OUT_EP);
 8006ffe:	2101      	movs	r1, #1
 8007000:	4815      	ldr	r0, [pc, #84]	@ (8007058 <USBD_CDC_GetHSCfgDesc+0x6c>)
 8007002:	f000 fd12 	bl	8007a2a <USBD_GetEpDesc>
 8007006:	6138      	str	r0, [r7, #16]
  USBD_EpDescTypeDef *pEpInDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_IN_EP);
 8007008:	2181      	movs	r1, #129	@ 0x81
 800700a:	4813      	ldr	r0, [pc, #76]	@ (8007058 <USBD_CDC_GetHSCfgDesc+0x6c>)
 800700c:	f000 fd0d 	bl	8007a2a <USBD_GetEpDesc>
 8007010:	60f8      	str	r0, [r7, #12]

  if (pEpCmdDesc != NULL)
 8007012:	697b      	ldr	r3, [r7, #20]
 8007014:	2b00      	cmp	r3, #0
 8007016:	d002      	beq.n	800701e <USBD_CDC_GetHSCfgDesc+0x32>
  {
    pEpCmdDesc->bInterval = CDC_HS_BINTERVAL;
 8007018:	697b      	ldr	r3, [r7, #20]
 800701a:	2210      	movs	r2, #16
 800701c:	719a      	strb	r2, [r3, #6]
  }

  if (pEpOutDesc != NULL)
 800701e:	693b      	ldr	r3, [r7, #16]
 8007020:	2b00      	cmp	r3, #0
 8007022:	d006      	beq.n	8007032 <USBD_CDC_GetHSCfgDesc+0x46>
  {
    pEpOutDesc->wMaxPacketSize = CDC_DATA_HS_MAX_PACKET_SIZE;
 8007024:	693b      	ldr	r3, [r7, #16]
 8007026:	2200      	movs	r2, #0
 8007028:	711a      	strb	r2, [r3, #4]
 800702a:	2200      	movs	r2, #0
 800702c:	f042 0202 	orr.w	r2, r2, #2
 8007030:	715a      	strb	r2, [r3, #5]
  }

  if (pEpInDesc != NULL)
 8007032:	68fb      	ldr	r3, [r7, #12]
 8007034:	2b00      	cmp	r3, #0
 8007036:	d006      	beq.n	8007046 <USBD_CDC_GetHSCfgDesc+0x5a>
  {
    pEpInDesc->wMaxPacketSize = CDC_DATA_HS_MAX_PACKET_SIZE;
 8007038:	68fb      	ldr	r3, [r7, #12]
 800703a:	2200      	movs	r2, #0
 800703c:	711a      	strb	r2, [r3, #4]
 800703e:	2200      	movs	r2, #0
 8007040:	f042 0202 	orr.w	r2, r2, #2
 8007044:	715a      	strb	r2, [r3, #5]
  }

  *length = (uint16_t)sizeof(USBD_CDC_CfgDesc);
 8007046:	687b      	ldr	r3, [r7, #4]
 8007048:	2243      	movs	r2, #67	@ 0x43
 800704a:	801a      	strh	r2, [r3, #0]
  return USBD_CDC_CfgDesc;
 800704c:	4b02      	ldr	r3, [pc, #8]	@ (8007058 <USBD_CDC_GetHSCfgDesc+0x6c>)
}
 800704e:	4618      	mov	r0, r3
 8007050:	3718      	adds	r7, #24
 8007052:	46bd      	mov	sp, r7
 8007054:	bd80      	pop	{r7, pc}
 8007056:	bf00      	nop
 8007058:	20000068 	.word	0x20000068

0800705c <USBD_CDC_GetOtherSpeedCfgDesc>:
  *         Return configuration descriptor
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t *USBD_CDC_GetOtherSpeedCfgDesc(uint16_t *length)
{
 800705c:	b580      	push	{r7, lr}
 800705e:	b086      	sub	sp, #24
 8007060:	af00      	add	r7, sp, #0
 8007062:	6078      	str	r0, [r7, #4]
  USBD_EpDescTypeDef *pEpCmdDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_CMD_EP);
 8007064:	2182      	movs	r1, #130	@ 0x82
 8007066:	4818      	ldr	r0, [pc, #96]	@ (80070c8 <USBD_CDC_GetOtherSpeedCfgDesc+0x6c>)
 8007068:	f000 fcdf 	bl	8007a2a <USBD_GetEpDesc>
 800706c:	6178      	str	r0, [r7, #20]
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_OUT_EP);
 800706e:	2101      	movs	r1, #1
 8007070:	4815      	ldr	r0, [pc, #84]	@ (80070c8 <USBD_CDC_GetOtherSpeedCfgDesc+0x6c>)
 8007072:	f000 fcda 	bl	8007a2a <USBD_GetEpDesc>
 8007076:	6138      	str	r0, [r7, #16]
  USBD_EpDescTypeDef *pEpInDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_IN_EP);
 8007078:	2181      	movs	r1, #129	@ 0x81
 800707a:	4813      	ldr	r0, [pc, #76]	@ (80070c8 <USBD_CDC_GetOtherSpeedCfgDesc+0x6c>)
 800707c:	f000 fcd5 	bl	8007a2a <USBD_GetEpDesc>
 8007080:	60f8      	str	r0, [r7, #12]

  if (pEpCmdDesc != NULL)
 8007082:	697b      	ldr	r3, [r7, #20]
 8007084:	2b00      	cmp	r3, #0
 8007086:	d002      	beq.n	800708e <USBD_CDC_GetOtherSpeedCfgDesc+0x32>
  {
    pEpCmdDesc->bInterval = CDC_FS_BINTERVAL;
 8007088:	697b      	ldr	r3, [r7, #20]
 800708a:	2210      	movs	r2, #16
 800708c:	719a      	strb	r2, [r3, #6]
  }

  if (pEpOutDesc != NULL)
 800708e:	693b      	ldr	r3, [r7, #16]
 8007090:	2b00      	cmp	r3, #0
 8007092:	d006      	beq.n	80070a2 <USBD_CDC_GetOtherSpeedCfgDesc+0x46>
  {
    pEpOutDesc->wMaxPacketSize = CDC_DATA_FS_MAX_PACKET_SIZE;
 8007094:	693b      	ldr	r3, [r7, #16]
 8007096:	2200      	movs	r2, #0
 8007098:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 800709c:	711a      	strb	r2, [r3, #4]
 800709e:	2200      	movs	r2, #0
 80070a0:	715a      	strb	r2, [r3, #5]
  }

  if (pEpInDesc != NULL)
 80070a2:	68fb      	ldr	r3, [r7, #12]
 80070a4:	2b00      	cmp	r3, #0
 80070a6:	d006      	beq.n	80070b6 <USBD_CDC_GetOtherSpeedCfgDesc+0x5a>
  {
    pEpInDesc->wMaxPacketSize = CDC_DATA_FS_MAX_PACKET_SIZE;
 80070a8:	68fb      	ldr	r3, [r7, #12]
 80070aa:	2200      	movs	r2, #0
 80070ac:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 80070b0:	711a      	strb	r2, [r3, #4]
 80070b2:	2200      	movs	r2, #0
 80070b4:	715a      	strb	r2, [r3, #5]
  }

  *length = (uint16_t)sizeof(USBD_CDC_CfgDesc);
 80070b6:	687b      	ldr	r3, [r7, #4]
 80070b8:	2243      	movs	r2, #67	@ 0x43
 80070ba:	801a      	strh	r2, [r3, #0]
  return USBD_CDC_CfgDesc;
 80070bc:	4b02      	ldr	r3, [pc, #8]	@ (80070c8 <USBD_CDC_GetOtherSpeedCfgDesc+0x6c>)
}
 80070be:	4618      	mov	r0, r3
 80070c0:	3718      	adds	r7, #24
 80070c2:	46bd      	mov	sp, r7
 80070c4:	bd80      	pop	{r7, pc}
 80070c6:	bf00      	nop
 80070c8:	20000068 	.word	0x20000068

080070cc <USBD_CDC_GetDeviceQualifierDescriptor>:
  *         return Device Qualifier descriptor
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
uint8_t *USBD_CDC_GetDeviceQualifierDescriptor(uint16_t *length)
{
 80070cc:	b480      	push	{r7}
 80070ce:	b083      	sub	sp, #12
 80070d0:	af00      	add	r7, sp, #0
 80070d2:	6078      	str	r0, [r7, #4]
  *length = (uint16_t)sizeof(USBD_CDC_DeviceQualifierDesc);
 80070d4:	687b      	ldr	r3, [r7, #4]
 80070d6:	220a      	movs	r2, #10
 80070d8:	801a      	strh	r2, [r3, #0]

  return USBD_CDC_DeviceQualifierDesc;
 80070da:	4b03      	ldr	r3, [pc, #12]	@ (80070e8 <USBD_CDC_GetDeviceQualifierDescriptor+0x1c>)
}
 80070dc:	4618      	mov	r0, r3
 80070de:	370c      	adds	r7, #12
 80070e0:	46bd      	mov	sp, r7
 80070e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80070e6:	4770      	bx	lr
 80070e8:	20000024 	.word	0x20000024

080070ec <USBD_CDC_RegisterInterface>:
  * @param  fops: CD  Interface callback
  * @retval status
  */
uint8_t USBD_CDC_RegisterInterface(USBD_HandleTypeDef *pdev,
                                   USBD_CDC_ItfTypeDef *fops)
{
 80070ec:	b480      	push	{r7}
 80070ee:	b083      	sub	sp, #12
 80070f0:	af00      	add	r7, sp, #0
 80070f2:	6078      	str	r0, [r7, #4]
 80070f4:	6039      	str	r1, [r7, #0]
  if (fops == NULL)
 80070f6:	683b      	ldr	r3, [r7, #0]
 80070f8:	2b00      	cmp	r3, #0
 80070fa:	d101      	bne.n	8007100 <USBD_CDC_RegisterInterface+0x14>
  {
    return (uint8_t)USBD_FAIL;
 80070fc:	2303      	movs	r3, #3
 80070fe:	e009      	b.n	8007114 <USBD_CDC_RegisterInterface+0x28>
  }

  pdev->pUserData[pdev->classId] = fops;
 8007100:	687b      	ldr	r3, [r7, #4]
 8007102:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8007106:	687a      	ldr	r2, [r7, #4]
 8007108:	33b0      	adds	r3, #176	@ 0xb0
 800710a:	009b      	lsls	r3, r3, #2
 800710c:	4413      	add	r3, r2
 800710e:	683a      	ldr	r2, [r7, #0]
 8007110:	605a      	str	r2, [r3, #4]

  return (uint8_t)USBD_OK;
 8007112:	2300      	movs	r3, #0
}
 8007114:	4618      	mov	r0, r3
 8007116:	370c      	adds	r7, #12
 8007118:	46bd      	mov	sp, r7
 800711a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800711e:	4770      	bx	lr

08007120 <USBD_CDC_SetTxBuffer>:
{
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[ClassId];
#else
uint8_t USBD_CDC_SetTxBuffer(USBD_HandleTypeDef *pdev,
                             uint8_t *pbuff, uint32_t length)
{
 8007120:	b480      	push	{r7}
 8007122:	b087      	sub	sp, #28
 8007124:	af00      	add	r7, sp, #0
 8007126:	60f8      	str	r0, [r7, #12]
 8007128:	60b9      	str	r1, [r7, #8]
 800712a:	607a      	str	r2, [r7, #4]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 800712c:	68fb      	ldr	r3, [r7, #12]
 800712e:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8007132:	68fb      	ldr	r3, [r7, #12]
 8007134:	32b0      	adds	r2, #176	@ 0xb0
 8007136:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800713a:	617b      	str	r3, [r7, #20]
#endif /* USE_USBD_COMPOSITE */

  if (hcdc == NULL)
 800713c:	697b      	ldr	r3, [r7, #20]
 800713e:	2b00      	cmp	r3, #0
 8007140:	d101      	bne.n	8007146 <USBD_CDC_SetTxBuffer+0x26>
  {
    return (uint8_t)USBD_FAIL;
 8007142:	2303      	movs	r3, #3
 8007144:	e008      	b.n	8007158 <USBD_CDC_SetTxBuffer+0x38>
  }

  hcdc->TxBuffer = pbuff;
 8007146:	697b      	ldr	r3, [r7, #20]
 8007148:	68ba      	ldr	r2, [r7, #8]
 800714a:	f8c3 2208 	str.w	r2, [r3, #520]	@ 0x208
  hcdc->TxLength = length;
 800714e:	697b      	ldr	r3, [r7, #20]
 8007150:	687a      	ldr	r2, [r7, #4]
 8007152:	f8c3 2210 	str.w	r2, [r3, #528]	@ 0x210

  return (uint8_t)USBD_OK;
 8007156:	2300      	movs	r3, #0
}
 8007158:	4618      	mov	r0, r3
 800715a:	371c      	adds	r7, #28
 800715c:	46bd      	mov	sp, r7
 800715e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007162:	4770      	bx	lr

08007164 <USBD_CDC_SetRxBuffer>:
  * @param  pdev: device instance
  * @param  pbuff: Rx Buffer
  * @retval status
  */
uint8_t USBD_CDC_SetRxBuffer(USBD_HandleTypeDef *pdev, uint8_t *pbuff)
{
 8007164:	b480      	push	{r7}
 8007166:	b085      	sub	sp, #20
 8007168:	af00      	add	r7, sp, #0
 800716a:	6078      	str	r0, [r7, #4]
 800716c:	6039      	str	r1, [r7, #0]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 800716e:	687b      	ldr	r3, [r7, #4]
 8007170:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8007174:	687b      	ldr	r3, [r7, #4]
 8007176:	32b0      	adds	r2, #176	@ 0xb0
 8007178:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800717c:	60fb      	str	r3, [r7, #12]

  if (hcdc == NULL)
 800717e:	68fb      	ldr	r3, [r7, #12]
 8007180:	2b00      	cmp	r3, #0
 8007182:	d101      	bne.n	8007188 <USBD_CDC_SetRxBuffer+0x24>
  {
    return (uint8_t)USBD_FAIL;
 8007184:	2303      	movs	r3, #3
 8007186:	e004      	b.n	8007192 <USBD_CDC_SetRxBuffer+0x2e>
  }

  hcdc->RxBuffer = pbuff;
 8007188:	68fb      	ldr	r3, [r7, #12]
 800718a:	683a      	ldr	r2, [r7, #0]
 800718c:	f8c3 2204 	str.w	r2, [r3, #516]	@ 0x204

  return (uint8_t)USBD_OK;
 8007190:	2300      	movs	r3, #0
}
 8007192:	4618      	mov	r0, r3
 8007194:	3714      	adds	r7, #20
 8007196:	46bd      	mov	sp, r7
 8007198:	f85d 7b04 	ldr.w	r7, [sp], #4
 800719c:	4770      	bx	lr
	...

080071a0 <USBD_CDC_TransmitPacket>:
uint8_t USBD_CDC_TransmitPacket(USBD_HandleTypeDef *pdev, uint8_t ClassId)
{
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[ClassId];
#else
uint8_t USBD_CDC_TransmitPacket(USBD_HandleTypeDef *pdev)
{
 80071a0:	b580      	push	{r7, lr}
 80071a2:	b084      	sub	sp, #16
 80071a4:	af00      	add	r7, sp, #0
 80071a6:	6078      	str	r0, [r7, #4]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 80071a8:	687b      	ldr	r3, [r7, #4]
 80071aa:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 80071ae:	687b      	ldr	r3, [r7, #4]
 80071b0:	32b0      	adds	r2, #176	@ 0xb0
 80071b2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80071b6:	60bb      	str	r3, [r7, #8]
#endif  /* USE_USBD_COMPOSITE */

  USBD_StatusTypeDef ret = USBD_BUSY;
 80071b8:	2301      	movs	r3, #1
 80071ba:	73fb      	strb	r3, [r7, #15]
#ifdef USE_USBD_COMPOSITE
  /* Get the Endpoints addresses allocated for this class instance */
  CDCInEpAdd  = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_BULK, ClassId);
#endif  /* USE_USBD_COMPOSITE */

  if (hcdc == NULL)
 80071bc:	68bb      	ldr	r3, [r7, #8]
 80071be:	2b00      	cmp	r3, #0
 80071c0:	d101      	bne.n	80071c6 <USBD_CDC_TransmitPacket+0x26>
  {
    return (uint8_t)USBD_FAIL;
 80071c2:	2303      	movs	r3, #3
 80071c4:	e025      	b.n	8007212 <USBD_CDC_TransmitPacket+0x72>
  }

  if (hcdc->TxState == 0U)
 80071c6:	68bb      	ldr	r3, [r7, #8]
 80071c8:	f8d3 3214 	ldr.w	r3, [r3, #532]	@ 0x214
 80071cc:	2b00      	cmp	r3, #0
 80071ce:	d11f      	bne.n	8007210 <USBD_CDC_TransmitPacket+0x70>
  {
    /* Tx Transfer in progress */
    hcdc->TxState = 1U;
 80071d0:	68bb      	ldr	r3, [r7, #8]
 80071d2:	2201      	movs	r2, #1
 80071d4:	f8c3 2214 	str.w	r2, [r3, #532]	@ 0x214

    /* Update the packet total length */
    pdev->ep_in[CDCInEpAdd & 0xFU].total_length = hcdc->TxLength;
 80071d8:	4b10      	ldr	r3, [pc, #64]	@ (800721c <USBD_CDC_TransmitPacket+0x7c>)
 80071da:	781b      	ldrb	r3, [r3, #0]
 80071dc:	f003 020f 	and.w	r2, r3, #15
 80071e0:	68bb      	ldr	r3, [r7, #8]
 80071e2:	f8d3 1210 	ldr.w	r1, [r3, #528]	@ 0x210
 80071e6:	6878      	ldr	r0, [r7, #4]
 80071e8:	4613      	mov	r3, r2
 80071ea:	009b      	lsls	r3, r3, #2
 80071ec:	4413      	add	r3, r2
 80071ee:	009b      	lsls	r3, r3, #2
 80071f0:	4403      	add	r3, r0
 80071f2:	3318      	adds	r3, #24
 80071f4:	6019      	str	r1, [r3, #0]

    /* Transmit next packet */
    (void)USBD_LL_Transmit(pdev, CDCInEpAdd, hcdc->TxBuffer, hcdc->TxLength);
 80071f6:	4b09      	ldr	r3, [pc, #36]	@ (800721c <USBD_CDC_TransmitPacket+0x7c>)
 80071f8:	7819      	ldrb	r1, [r3, #0]
 80071fa:	68bb      	ldr	r3, [r7, #8]
 80071fc:	f8d3 2208 	ldr.w	r2, [r3, #520]	@ 0x208
 8007200:	68bb      	ldr	r3, [r7, #8]
 8007202:	f8d3 3210 	ldr.w	r3, [r3, #528]	@ 0x210
 8007206:	6878      	ldr	r0, [r7, #4]
 8007208:	f020 ff79 	bl	80280fe <USBD_LL_Transmit>

    ret = USBD_OK;
 800720c:	2300      	movs	r3, #0
 800720e:	73fb      	strb	r3, [r7, #15]
  }

  return (uint8_t)ret;
 8007210:	7bfb      	ldrb	r3, [r7, #15]
}
 8007212:	4618      	mov	r0, r3
 8007214:	3710      	adds	r7, #16
 8007216:	46bd      	mov	sp, r7
 8007218:	bd80      	pop	{r7, pc}
 800721a:	bf00      	nop
 800721c:	200000ab 	.word	0x200000ab

08007220 <USBD_CDC_ReceivePacket>:
  *         prepare OUT Endpoint for reception
  * @param  pdev: device instance
  * @retval status
  */
uint8_t USBD_CDC_ReceivePacket(USBD_HandleTypeDef *pdev)
{
 8007220:	b580      	push	{r7, lr}
 8007222:	b084      	sub	sp, #16
 8007224:	af00      	add	r7, sp, #0
 8007226:	6078      	str	r0, [r7, #4]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8007228:	687b      	ldr	r3, [r7, #4]
 800722a:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 800722e:	687b      	ldr	r3, [r7, #4]
 8007230:	32b0      	adds	r2, #176	@ 0xb0
 8007232:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007236:	60fb      	str	r3, [r7, #12]
#ifdef USE_USBD_COMPOSITE
  /* Get the Endpoints addresses allocated for this class instance */
  CDCOutEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_OUT, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
#endif /* USE_USBD_COMPOSITE */

  if (pdev->pClassDataCmsit[pdev->classId] == NULL)
 8007238:	687b      	ldr	r3, [r7, #4]
 800723a:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 800723e:	687b      	ldr	r3, [r7, #4]
 8007240:	32b0      	adds	r2, #176	@ 0xb0
 8007242:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007246:	2b00      	cmp	r3, #0
 8007248:	d101      	bne.n	800724e <USBD_CDC_ReceivePacket+0x2e>
  {
    return (uint8_t)USBD_FAIL;
 800724a:	2303      	movs	r3, #3
 800724c:	e018      	b.n	8007280 <USBD_CDC_ReceivePacket+0x60>
  }

  if (pdev->dev_speed == USBD_SPEED_HIGH)
 800724e:	687b      	ldr	r3, [r7, #4]
 8007250:	7c1b      	ldrb	r3, [r3, #16]
 8007252:	2b00      	cmp	r3, #0
 8007254:	d10a      	bne.n	800726c <USBD_CDC_ReceivePacket+0x4c>
  {
    /* Prepare Out endpoint to receive next packet */
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
 8007256:	4b0c      	ldr	r3, [pc, #48]	@ (8007288 <USBD_CDC_ReceivePacket+0x68>)
 8007258:	7819      	ldrb	r1, [r3, #0]
 800725a:	68fb      	ldr	r3, [r7, #12]
 800725c:	f8d3 2204 	ldr.w	r2, [r3, #516]	@ 0x204
 8007260:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8007264:	6878      	ldr	r0, [r7, #4]
 8007266:	f020 ff6b 	bl	8028140 <USBD_LL_PrepareReceive>
 800726a:	e008      	b.n	800727e <USBD_CDC_ReceivePacket+0x5e>
                                 CDC_DATA_HS_OUT_PACKET_SIZE);
  }
  else
  {
    /* Prepare Out endpoint to receive next packet */
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
 800726c:	4b06      	ldr	r3, [pc, #24]	@ (8007288 <USBD_CDC_ReceivePacket+0x68>)
 800726e:	7819      	ldrb	r1, [r3, #0]
 8007270:	68fb      	ldr	r3, [r7, #12]
 8007272:	f8d3 2204 	ldr.w	r2, [r3, #516]	@ 0x204
 8007276:	2340      	movs	r3, #64	@ 0x40
 8007278:	6878      	ldr	r0, [r7, #4]
 800727a:	f020 ff61 	bl	8028140 <USBD_LL_PrepareReceive>
                                 CDC_DATA_FS_OUT_PACKET_SIZE);
  }

  return (uint8_t)USBD_OK;
 800727e:	2300      	movs	r3, #0
}
 8007280:	4618      	mov	r0, r3
 8007282:	3710      	adds	r7, #16
 8007284:	46bd      	mov	sp, r7
 8007286:	bd80      	pop	{r7, pc}
 8007288:	200000ac 	.word	0x200000ac

0800728c <USBD_Init>:
  * @param  id: Low level core index
  * @retval status: USBD Status
  */
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev,
                             USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
 800728c:	b580      	push	{r7, lr}
 800728e:	b086      	sub	sp, #24
 8007290:	af00      	add	r7, sp, #0
 8007292:	60f8      	str	r0, [r7, #12]
 8007294:	60b9      	str	r1, [r7, #8]
 8007296:	4613      	mov	r3, r2
 8007298:	71fb      	strb	r3, [r7, #7]
  USBD_StatusTypeDef ret;

  /* Check whether the USB Host handle is valid */
  if (pdev == NULL)
 800729a:	68fb      	ldr	r3, [r7, #12]
 800729c:	2b00      	cmp	r3, #0
 800729e:	d101      	bne.n	80072a4 <USBD_Init+0x18>
  {
#if (USBD_DEBUG_LEVEL > 1U)
    USBD_ErrLog("Invalid Device handle");
#endif /* (USBD_DEBUG_LEVEL > 1U) */
    return USBD_FAIL;
 80072a0:	2303      	movs	r3, #3
 80072a2:	e01f      	b.n	80072e4 <USBD_Init+0x58>
    pdev->NumClasses = 0;
    pdev->classId = 0;
  }
#else
  /* Unlink previous class*/
  pdev->pClass[0] = NULL;
 80072a4:	68fb      	ldr	r3, [r7, #12]
 80072a6:	2200      	movs	r2, #0
 80072a8:	f8c3 22b8 	str.w	r2, [r3, #696]	@ 0x2b8
  pdev->pUserData[0] = NULL;
 80072ac:	68fb      	ldr	r3, [r7, #12]
 80072ae:	2200      	movs	r2, #0
 80072b0:	f8c3 22c4 	str.w	r2, [r3, #708]	@ 0x2c4
#endif /* USE_USBD_COMPOSITE */

  pdev->pConfDesc = NULL;
 80072b4:	68fb      	ldr	r3, [r7, #12]
 80072b6:	2200      	movs	r2, #0
 80072b8:	f8c3 22d0 	str.w	r2, [r3, #720]	@ 0x2d0

  /* Assign USBD Descriptors */
  if (pdesc != NULL)
 80072bc:	68bb      	ldr	r3, [r7, #8]
 80072be:	2b00      	cmp	r3, #0
 80072c0:	d003      	beq.n	80072ca <USBD_Init+0x3e>
  {
    pdev->pDesc = pdesc;
 80072c2:	68fb      	ldr	r3, [r7, #12]
 80072c4:	68ba      	ldr	r2, [r7, #8]
 80072c6:	f8c3 22b4 	str.w	r2, [r3, #692]	@ 0x2b4
  }

  /* Set Device initial State */
  pdev->dev_state = USBD_STATE_DEFAULT;
 80072ca:	68fb      	ldr	r3, [r7, #12]
 80072cc:	2201      	movs	r2, #1
 80072ce:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
  pdev->id = id;
 80072d2:	68fb      	ldr	r3, [r7, #12]
 80072d4:	79fa      	ldrb	r2, [r7, #7]
 80072d6:	701a      	strb	r2, [r3, #0]

  /* Initialize low level driver */
  ret = USBD_LL_Init(pdev);
 80072d8:	68f8      	ldr	r0, [r7, #12]
 80072da:	f020 fddb 	bl	8027e94 <USBD_LL_Init>
 80072de:	4603      	mov	r3, r0
 80072e0:	75fb      	strb	r3, [r7, #23]

  return ret;
 80072e2:	7dfb      	ldrb	r3, [r7, #23]
}
 80072e4:	4618      	mov	r0, r3
 80072e6:	3718      	adds	r7, #24
 80072e8:	46bd      	mov	sp, r7
 80072ea:	bd80      	pop	{r7, pc}

080072ec <USBD_RegisterClass>:
  * @param  pdev: Device Handle
  * @param  pclass: Class handle
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
 80072ec:	b580      	push	{r7, lr}
 80072ee:	b084      	sub	sp, #16
 80072f0:	af00      	add	r7, sp, #0
 80072f2:	6078      	str	r0, [r7, #4]
 80072f4:	6039      	str	r1, [r7, #0]
  uint16_t len = 0U;
 80072f6:	2300      	movs	r3, #0
 80072f8:	81fb      	strh	r3, [r7, #14]

  if (pclass == NULL)
 80072fa:	683b      	ldr	r3, [r7, #0]
 80072fc:	2b00      	cmp	r3, #0
 80072fe:	d101      	bne.n	8007304 <USBD_RegisterClass+0x18>
  {
#if (USBD_DEBUG_LEVEL > 1U)
    USBD_ErrLog("Invalid Class handle");
#endif /* (USBD_DEBUG_LEVEL > 1U) */
    return USBD_FAIL;
 8007300:	2303      	movs	r3, #3
 8007302:	e025      	b.n	8007350 <USBD_RegisterClass+0x64>
  }

  /* link the class to the USB Device handle */
  pdev->pClass[0] = pclass;
 8007304:	687b      	ldr	r3, [r7, #4]
 8007306:	683a      	ldr	r2, [r7, #0]
 8007308:	f8c3 22b8 	str.w	r2, [r3, #696]	@ 0x2b8
  if (pdev->pClass[pdev->classId]->GetHSConfigDescriptor != NULL)
  {
    pdev->pConfDesc = (void *)pdev->pClass[pdev->classId]->GetHSConfigDescriptor(&len);
  }
#else /* Default USE_USB_FS */
  if (pdev->pClass[pdev->classId]->GetFSConfigDescriptor != NULL)
 800730c:	687b      	ldr	r3, [r7, #4]
 800730e:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8007312:	687b      	ldr	r3, [r7, #4]
 8007314:	32ae      	adds	r2, #174	@ 0xae
 8007316:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800731a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800731c:	2b00      	cmp	r3, #0
 800731e:	d00f      	beq.n	8007340 <USBD_RegisterClass+0x54>
  {
    pdev->pConfDesc = (void *)pdev->pClass[pdev->classId]->GetFSConfigDescriptor(&len);
 8007320:	687b      	ldr	r3, [r7, #4]
 8007322:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8007326:	687b      	ldr	r3, [r7, #4]
 8007328:	32ae      	adds	r2, #174	@ 0xae
 800732a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800732e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8007330:	f107 020e 	add.w	r2, r7, #14
 8007334:	4610      	mov	r0, r2
 8007336:	4798      	blx	r3
 8007338:	4602      	mov	r2, r0
 800733a:	687b      	ldr	r3, [r7, #4]
 800733c:	f8c3 22d0 	str.w	r2, [r3, #720]	@ 0x2d0
  }
#endif /* USE_USB_FS */

  /* Increment the NumClasses */
  pdev->NumClasses++;
 8007340:	687b      	ldr	r3, [r7, #4]
 8007342:	f8d3 32d8 	ldr.w	r3, [r3, #728]	@ 0x2d8
 8007346:	1c5a      	adds	r2, r3, #1
 8007348:	687b      	ldr	r3, [r7, #4]
 800734a:	f8c3 22d8 	str.w	r2, [r3, #728]	@ 0x2d8

  return USBD_OK;
 800734e:	2300      	movs	r3, #0
}
 8007350:	4618      	mov	r0, r3
 8007352:	3710      	adds	r7, #16
 8007354:	46bd      	mov	sp, r7
 8007356:	bd80      	pop	{r7, pc}

08007358 <USBD_Start>:
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_Start(USBD_HandleTypeDef *pdev)
{
 8007358:	b580      	push	{r7, lr}
 800735a:	b082      	sub	sp, #8
 800735c:	af00      	add	r7, sp, #0
 800735e:	6078      	str	r0, [r7, #4]
#ifdef USE_USBD_COMPOSITE
  pdev->classId = 0U;
#endif /* USE_USBD_COMPOSITE */

  /* Start the low level driver  */
  return USBD_LL_Start(pdev);
 8007360:	6878      	ldr	r0, [r7, #4]
 8007362:	f020 fde3 	bl	8027f2c <USBD_LL_Start>
 8007366:	4603      	mov	r3, r0
}
 8007368:	4618      	mov	r0, r3
 800736a:	3708      	adds	r7, #8
 800736c:	46bd      	mov	sp, r7
 800736e:	bd80      	pop	{r7, pc}

08007370 <USBD_RunTestMode>:
  *         Launch test mode process
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_RunTestMode(USBD_HandleTypeDef *pdev)
{
 8007370:	b480      	push	{r7}
 8007372:	b083      	sub	sp, #12
 8007374:	af00      	add	r7, sp, #0
 8007376:	6078      	str	r0, [r7, #4]
  return ret;
#else
  /* Prevent unused argument compilation warning */
  UNUSED(pdev);

  return USBD_OK;
 8007378:	2300      	movs	r3, #0
#endif /* USBD_HS_TESTMODE_ENABLE */
}
 800737a:	4618      	mov	r0, r3
 800737c:	370c      	adds	r7, #12
 800737e:	46bd      	mov	sp, r7
 8007380:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007384:	4770      	bx	lr

08007386 <USBD_SetClassConfig>:
  * @param  cfgidx: configuration index
  * @retval status
  */

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 8007386:	b580      	push	{r7, lr}
 8007388:	b084      	sub	sp, #16
 800738a:	af00      	add	r7, sp, #0
 800738c:	6078      	str	r0, [r7, #4]
 800738e:	460b      	mov	r3, r1
 8007390:	70fb      	strb	r3, [r7, #3]
  USBD_StatusTypeDef ret = USBD_OK;
 8007392:	2300      	movs	r3, #0
 8007394:	73fb      	strb	r3, [r7, #15]
        }
      }
    }
  }
#else
  if (pdev->pClass[0] != NULL)
 8007396:	687b      	ldr	r3, [r7, #4]
 8007398:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 800739c:	2b00      	cmp	r3, #0
 800739e:	d009      	beq.n	80073b4 <USBD_SetClassConfig+0x2e>
  {
    /* Set configuration and Start the Class */
    ret = (USBD_StatusTypeDef)pdev->pClass[0]->Init(pdev, cfgidx);
 80073a0:	687b      	ldr	r3, [r7, #4]
 80073a2:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 80073a6:	681b      	ldr	r3, [r3, #0]
 80073a8:	78fa      	ldrb	r2, [r7, #3]
 80073aa:	4611      	mov	r1, r2
 80073ac:	6878      	ldr	r0, [r7, #4]
 80073ae:	4798      	blx	r3
 80073b0:	4603      	mov	r3, r0
 80073b2:	73fb      	strb	r3, [r7, #15]
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
 80073b4:	7bfb      	ldrb	r3, [r7, #15]
}
 80073b6:	4618      	mov	r0, r3
 80073b8:	3710      	adds	r7, #16
 80073ba:	46bd      	mov	sp, r7
 80073bc:	bd80      	pop	{r7, pc}

080073be <USBD_ClrClassConfig>:
  * @param  pdev: device instance
  * @param  cfgidx: configuration index
  * @retval status
  */
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 80073be:	b580      	push	{r7, lr}
 80073c0:	b084      	sub	sp, #16
 80073c2:	af00      	add	r7, sp, #0
 80073c4:	6078      	str	r0, [r7, #4]
 80073c6:	460b      	mov	r3, r1
 80073c8:	70fb      	strb	r3, [r7, #3]
  USBD_StatusTypeDef ret = USBD_OK;
 80073ca:	2300      	movs	r3, #0
 80073cc:	73fb      	strb	r3, [r7, #15]
      }
    }
  }
#else
  /* Clear configuration  and De-initialize the Class process */
  if (pdev->pClass[0]->DeInit(pdev, cfgidx) != 0U)
 80073ce:	687b      	ldr	r3, [r7, #4]
 80073d0:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 80073d4:	685b      	ldr	r3, [r3, #4]
 80073d6:	78fa      	ldrb	r2, [r7, #3]
 80073d8:	4611      	mov	r1, r2
 80073da:	6878      	ldr	r0, [r7, #4]
 80073dc:	4798      	blx	r3
 80073de:	4603      	mov	r3, r0
 80073e0:	2b00      	cmp	r3, #0
 80073e2:	d001      	beq.n	80073e8 <USBD_ClrClassConfig+0x2a>
  {
    ret = USBD_FAIL;
 80073e4:	2303      	movs	r3, #3
 80073e6:	73fb      	strb	r3, [r7, #15]
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
 80073e8:	7bfb      	ldrb	r3, [r7, #15]
}
 80073ea:	4618      	mov	r0, r3
 80073ec:	3710      	adds	r7, #16
 80073ee:	46bd      	mov	sp, r7
 80073f0:	bd80      	pop	{r7, pc}

080073f2 <USBD_LL_SetupStage>:
  * @param  pdev: device instance
  * @param  psetup: setup packet buffer pointer
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
 80073f2:	b580      	push	{r7, lr}
 80073f4:	b084      	sub	sp, #16
 80073f6:	af00      	add	r7, sp, #0
 80073f8:	6078      	str	r0, [r7, #4]
 80073fa:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret;

  USBD_ParseSetupRequest(&pdev->request, psetup);
 80073fc:	687b      	ldr	r3, [r7, #4]
 80073fe:	f203 23aa 	addw	r3, r3, #682	@ 0x2aa
 8007402:	6839      	ldr	r1, [r7, #0]
 8007404:	4618      	mov	r0, r3
 8007406:	f001 f90c 	bl	8008622 <USBD_ParseSetupRequest>

  pdev->ep0_state = USBD_EP0_SETUP;
 800740a:	687b      	ldr	r3, [r7, #4]
 800740c:	2201      	movs	r2, #1
 800740e:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294

  pdev->ep0_data_len = pdev->request.wLength;
 8007412:	687b      	ldr	r3, [r7, #4]
 8007414:	f8b3 32b0 	ldrh.w	r3, [r3, #688]	@ 0x2b0
 8007418:	461a      	mov	r2, r3
 800741a:	687b      	ldr	r3, [r7, #4]
 800741c:	f8c3 2298 	str.w	r2, [r3, #664]	@ 0x298

  switch (pdev->request.bmRequest & 0x1FU)
 8007420:	687b      	ldr	r3, [r7, #4]
 8007422:	f893 32aa 	ldrb.w	r3, [r3, #682]	@ 0x2aa
 8007426:	f003 031f 	and.w	r3, r3, #31
 800742a:	2b02      	cmp	r3, #2
 800742c:	d01a      	beq.n	8007464 <USBD_LL_SetupStage+0x72>
 800742e:	2b02      	cmp	r3, #2
 8007430:	d822      	bhi.n	8007478 <USBD_LL_SetupStage+0x86>
 8007432:	2b00      	cmp	r3, #0
 8007434:	d002      	beq.n	800743c <USBD_LL_SetupStage+0x4a>
 8007436:	2b01      	cmp	r3, #1
 8007438:	d00a      	beq.n	8007450 <USBD_LL_SetupStage+0x5e>
 800743a:	e01d      	b.n	8007478 <USBD_LL_SetupStage+0x86>
  {
    case USB_REQ_RECIPIENT_DEVICE:
      ret = USBD_StdDevReq(pdev, &pdev->request);
 800743c:	687b      	ldr	r3, [r7, #4]
 800743e:	f203 23aa 	addw	r3, r3, #682	@ 0x2aa
 8007442:	4619      	mov	r1, r3
 8007444:	6878      	ldr	r0, [r7, #4]
 8007446:	f000 fb63 	bl	8007b10 <USBD_StdDevReq>
 800744a:	4603      	mov	r3, r0
 800744c:	73fb      	strb	r3, [r7, #15]
      break;
 800744e:	e020      	b.n	8007492 <USBD_LL_SetupStage+0xa0>

    case USB_REQ_RECIPIENT_INTERFACE:
      ret = USBD_StdItfReq(pdev, &pdev->request);
 8007450:	687b      	ldr	r3, [r7, #4]
 8007452:	f203 23aa 	addw	r3, r3, #682	@ 0x2aa
 8007456:	4619      	mov	r1, r3
 8007458:	6878      	ldr	r0, [r7, #4]
 800745a:	f000 fbcb 	bl	8007bf4 <USBD_StdItfReq>
 800745e:	4603      	mov	r3, r0
 8007460:	73fb      	strb	r3, [r7, #15]
      break;
 8007462:	e016      	b.n	8007492 <USBD_LL_SetupStage+0xa0>

    case USB_REQ_RECIPIENT_ENDPOINT:
      ret = USBD_StdEPReq(pdev, &pdev->request);
 8007464:	687b      	ldr	r3, [r7, #4]
 8007466:	f203 23aa 	addw	r3, r3, #682	@ 0x2aa
 800746a:	4619      	mov	r1, r3
 800746c:	6878      	ldr	r0, [r7, #4]
 800746e:	f000 fc2d 	bl	8007ccc <USBD_StdEPReq>
 8007472:	4603      	mov	r3, r0
 8007474:	73fb      	strb	r3, [r7, #15]
      break;
 8007476:	e00c      	b.n	8007492 <USBD_LL_SetupStage+0xa0>

    default:
      ret = USBD_LL_StallEP(pdev, (pdev->request.bmRequest & 0x80U));
 8007478:	687b      	ldr	r3, [r7, #4]
 800747a:	f893 32aa 	ldrb.w	r3, [r3, #682]	@ 0x2aa
 800747e:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 8007482:	b2db      	uxtb	r3, r3
 8007484:	4619      	mov	r1, r3
 8007486:	6878      	ldr	r0, [r7, #4]
 8007488:	f020 fdb0 	bl	8027fec <USBD_LL_StallEP>
 800748c:	4603      	mov	r3, r0
 800748e:	73fb      	strb	r3, [r7, #15]
      break;
 8007490:	bf00      	nop
  }

  return ret;
 8007492:	7bfb      	ldrb	r3, [r7, #15]
}
 8007494:	4618      	mov	r0, r3
 8007496:	3710      	adds	r7, #16
 8007498:	46bd      	mov	sp, r7
 800749a:	bd80      	pop	{r7, pc}

0800749c <USBD_LL_DataOutStage>:
  * @param  pdata: data pointer
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev,
                                        uint8_t epnum, uint8_t *pdata)
{
 800749c:	b580      	push	{r7, lr}
 800749e:	b086      	sub	sp, #24
 80074a0:	af00      	add	r7, sp, #0
 80074a2:	60f8      	str	r0, [r7, #12]
 80074a4:	460b      	mov	r3, r1
 80074a6:	607a      	str	r2, [r7, #4]
 80074a8:	72fb      	strb	r3, [r7, #11]
  USBD_EndpointTypeDef *pep;
  USBD_StatusTypeDef ret = USBD_OK;
 80074aa:	2300      	movs	r3, #0
 80074ac:	75fb      	strb	r3, [r7, #23]
  uint8_t idx;

  if (epnum == 0U)
 80074ae:	7afb      	ldrb	r3, [r7, #11]
 80074b0:	2b00      	cmp	r3, #0
 80074b2:	d16e      	bne.n	8007592 <USBD_LL_DataOutStage+0xf6>
  {
    pep = &pdev->ep_out[0];
 80074b4:	68fb      	ldr	r3, [r7, #12]
 80074b6:	f503 73aa 	add.w	r3, r3, #340	@ 0x154
 80074ba:	613b      	str	r3, [r7, #16]

    if (pdev->ep0_state == USBD_EP0_DATA_OUT)
 80074bc:	68fb      	ldr	r3, [r7, #12]
 80074be:	f8d3 3294 	ldr.w	r3, [r3, #660]	@ 0x294
 80074c2:	2b03      	cmp	r3, #3
 80074c4:	f040 8098 	bne.w	80075f8 <USBD_LL_DataOutStage+0x15c>
    {
      if (pep->rem_length > pep->maxpacket)
 80074c8:	693b      	ldr	r3, [r7, #16]
 80074ca:	689a      	ldr	r2, [r3, #8]
 80074cc:	693b      	ldr	r3, [r7, #16]
 80074ce:	68db      	ldr	r3, [r3, #12]
 80074d0:	429a      	cmp	r2, r3
 80074d2:	d913      	bls.n	80074fc <USBD_LL_DataOutStage+0x60>
      {
        pep->rem_length -= pep->maxpacket;
 80074d4:	693b      	ldr	r3, [r7, #16]
 80074d6:	689a      	ldr	r2, [r3, #8]
 80074d8:	693b      	ldr	r3, [r7, #16]
 80074da:	68db      	ldr	r3, [r3, #12]
 80074dc:	1ad2      	subs	r2, r2, r3
 80074de:	693b      	ldr	r3, [r7, #16]
 80074e0:	609a      	str	r2, [r3, #8]

        (void)USBD_CtlContinueRx(pdev, pdata, MIN(pep->rem_length, pep->maxpacket));
 80074e2:	693b      	ldr	r3, [r7, #16]
 80074e4:	68da      	ldr	r2, [r3, #12]
 80074e6:	693b      	ldr	r3, [r7, #16]
 80074e8:	689b      	ldr	r3, [r3, #8]
 80074ea:	4293      	cmp	r3, r2
 80074ec:	bf28      	it	cs
 80074ee:	4613      	movcs	r3, r2
 80074f0:	461a      	mov	r2, r3
 80074f2:	6879      	ldr	r1, [r7, #4]
 80074f4:	68f8      	ldr	r0, [r7, #12]
 80074f6:	f001 f994 	bl	8008822 <USBD_CtlContinueRx>
 80074fa:	e07d      	b.n	80075f8 <USBD_LL_DataOutStage+0x15c>
      }
      else
      {
        /* Find the class ID relative to the current request */
        switch (pdev->request.bmRequest & 0x1FU)
 80074fc:	68fb      	ldr	r3, [r7, #12]
 80074fe:	f893 32aa 	ldrb.w	r3, [r3, #682]	@ 0x2aa
 8007502:	f003 031f 	and.w	r3, r3, #31
 8007506:	2b02      	cmp	r3, #2
 8007508:	d014      	beq.n	8007534 <USBD_LL_DataOutStage+0x98>
 800750a:	2b02      	cmp	r3, #2
 800750c:	d81d      	bhi.n	800754a <USBD_LL_DataOutStage+0xae>
 800750e:	2b00      	cmp	r3, #0
 8007510:	d002      	beq.n	8007518 <USBD_LL_DataOutStage+0x7c>
 8007512:	2b01      	cmp	r3, #1
 8007514:	d003      	beq.n	800751e <USBD_LL_DataOutStage+0x82>
 8007516:	e018      	b.n	800754a <USBD_LL_DataOutStage+0xae>
        {
          case USB_REQ_RECIPIENT_DEVICE:
            /* Device requests must be managed by the first instantiated class
               (or duplicated by all classes for simplicity) */
            idx = 0U;
 8007518:	2300      	movs	r3, #0
 800751a:	75bb      	strb	r3, [r7, #22]
            break;
 800751c:	e018      	b.n	8007550 <USBD_LL_DataOutStage+0xb4>

          case USB_REQ_RECIPIENT_INTERFACE:
            idx = USBD_CoreFindIF(pdev, LOBYTE(pdev->request.wIndex));
 800751e:	68fb      	ldr	r3, [r7, #12]
 8007520:	f8b3 32ae 	ldrh.w	r3, [r3, #686]	@ 0x2ae
 8007524:	b2db      	uxtb	r3, r3
 8007526:	4619      	mov	r1, r3
 8007528:	68f8      	ldr	r0, [r7, #12]
 800752a:	f000 fa64 	bl	80079f6 <USBD_CoreFindIF>
 800752e:	4603      	mov	r3, r0
 8007530:	75bb      	strb	r3, [r7, #22]
            break;
 8007532:	e00d      	b.n	8007550 <USBD_LL_DataOutStage+0xb4>

          case USB_REQ_RECIPIENT_ENDPOINT:
            idx = USBD_CoreFindEP(pdev, LOBYTE(pdev->request.wIndex));
 8007534:	68fb      	ldr	r3, [r7, #12]
 8007536:	f8b3 32ae 	ldrh.w	r3, [r3, #686]	@ 0x2ae
 800753a:	b2db      	uxtb	r3, r3
 800753c:	4619      	mov	r1, r3
 800753e:	68f8      	ldr	r0, [r7, #12]
 8007540:	f000 fa66 	bl	8007a10 <USBD_CoreFindEP>
 8007544:	4603      	mov	r3, r0
 8007546:	75bb      	strb	r3, [r7, #22]
            break;
 8007548:	e002      	b.n	8007550 <USBD_LL_DataOutStage+0xb4>

          default:
            /* Back to the first class in case of doubt */
            idx = 0U;
 800754a:	2300      	movs	r3, #0
 800754c:	75bb      	strb	r3, [r7, #22]
            break;
 800754e:	bf00      	nop
        }

        if (idx < USBD_MAX_SUPPORTED_CLASS)
 8007550:	7dbb      	ldrb	r3, [r7, #22]
 8007552:	2b00      	cmp	r3, #0
 8007554:	d119      	bne.n	800758a <USBD_LL_DataOutStage+0xee>
        {
          /* Setup the class ID and route the request to the relative class function */
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8007556:	68fb      	ldr	r3, [r7, #12]
 8007558:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 800755c:	b2db      	uxtb	r3, r3
 800755e:	2b03      	cmp	r3, #3
 8007560:	d113      	bne.n	800758a <USBD_LL_DataOutStage+0xee>
          {
            if (pdev->pClass[idx]->EP0_RxReady != NULL)
 8007562:	7dba      	ldrb	r2, [r7, #22]
 8007564:	68fb      	ldr	r3, [r7, #12]
 8007566:	32ae      	adds	r2, #174	@ 0xae
 8007568:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800756c:	691b      	ldr	r3, [r3, #16]
 800756e:	2b00      	cmp	r3, #0
 8007570:	d00b      	beq.n	800758a <USBD_LL_DataOutStage+0xee>
            {
              pdev->classId = idx;
 8007572:	7dba      	ldrb	r2, [r7, #22]
 8007574:	68fb      	ldr	r3, [r7, #12]
 8007576:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
              pdev->pClass[idx]->EP0_RxReady(pdev);
 800757a:	7dba      	ldrb	r2, [r7, #22]
 800757c:	68fb      	ldr	r3, [r7, #12]
 800757e:	32ae      	adds	r2, #174	@ 0xae
 8007580:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007584:	691b      	ldr	r3, [r3, #16]
 8007586:	68f8      	ldr	r0, [r7, #12]
 8007588:	4798      	blx	r3
            }
          }
        }

        (void)USBD_CtlSendStatus(pdev);
 800758a:	68f8      	ldr	r0, [r7, #12]
 800758c:	f001 f95a 	bl	8008844 <USBD_CtlSendStatus>
 8007590:	e032      	b.n	80075f8 <USBD_LL_DataOutStage+0x15c>
    }
  }
  else
  {
    /* Get the class index relative to this interface */
    idx = USBD_CoreFindEP(pdev, (epnum & 0x7FU));
 8007592:	7afb      	ldrb	r3, [r7, #11]
 8007594:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8007598:	b2db      	uxtb	r3, r3
 800759a:	4619      	mov	r1, r3
 800759c:	68f8      	ldr	r0, [r7, #12]
 800759e:	f000 fa37 	bl	8007a10 <USBD_CoreFindEP>
 80075a2:	4603      	mov	r3, r0
 80075a4:	75bb      	strb	r3, [r7, #22]

    if (((uint16_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 80075a6:	7dbb      	ldrb	r3, [r7, #22]
 80075a8:	2bff      	cmp	r3, #255	@ 0xff
 80075aa:	d025      	beq.n	80075f8 <USBD_LL_DataOutStage+0x15c>
 80075ac:	7dbb      	ldrb	r3, [r7, #22]
 80075ae:	2b00      	cmp	r3, #0
 80075b0:	d122      	bne.n	80075f8 <USBD_LL_DataOutStage+0x15c>
    {
      /* Call the class data out function to manage the request */
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 80075b2:	68fb      	ldr	r3, [r7, #12]
 80075b4:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 80075b8:	b2db      	uxtb	r3, r3
 80075ba:	2b03      	cmp	r3, #3
 80075bc:	d117      	bne.n	80075ee <USBD_LL_DataOutStage+0x152>
      {
        if (pdev->pClass[idx]->DataOut != NULL)
 80075be:	7dba      	ldrb	r2, [r7, #22]
 80075c0:	68fb      	ldr	r3, [r7, #12]
 80075c2:	32ae      	adds	r2, #174	@ 0xae
 80075c4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80075c8:	699b      	ldr	r3, [r3, #24]
 80075ca:	2b00      	cmp	r3, #0
 80075cc:	d00f      	beq.n	80075ee <USBD_LL_DataOutStage+0x152>
        {
          pdev->classId = idx;
 80075ce:	7dba      	ldrb	r2, [r7, #22]
 80075d0:	68fb      	ldr	r3, [r7, #12]
 80075d2:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
          ret = (USBD_StatusTypeDef)pdev->pClass[idx]->DataOut(pdev, epnum);
 80075d6:	7dba      	ldrb	r2, [r7, #22]
 80075d8:	68fb      	ldr	r3, [r7, #12]
 80075da:	32ae      	adds	r2, #174	@ 0xae
 80075dc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80075e0:	699b      	ldr	r3, [r3, #24]
 80075e2:	7afa      	ldrb	r2, [r7, #11]
 80075e4:	4611      	mov	r1, r2
 80075e6:	68f8      	ldr	r0, [r7, #12]
 80075e8:	4798      	blx	r3
 80075ea:	4603      	mov	r3, r0
 80075ec:	75fb      	strb	r3, [r7, #23]
        }
      }
      if (ret != USBD_OK)
 80075ee:	7dfb      	ldrb	r3, [r7, #23]
 80075f0:	2b00      	cmp	r3, #0
 80075f2:	d001      	beq.n	80075f8 <USBD_LL_DataOutStage+0x15c>
      {
        return ret;
 80075f4:	7dfb      	ldrb	r3, [r7, #23]
 80075f6:	e000      	b.n	80075fa <USBD_LL_DataOutStage+0x15e>
      }
    }
  }

  return USBD_OK;
 80075f8:	2300      	movs	r3, #0
}
 80075fa:	4618      	mov	r0, r3
 80075fc:	3718      	adds	r7, #24
 80075fe:	46bd      	mov	sp, r7
 8007600:	bd80      	pop	{r7, pc}

08007602 <USBD_LL_DataInStage>:
  * @param  pdata: data pointer
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev,
                                       uint8_t epnum, uint8_t *pdata)
{
 8007602:	b580      	push	{r7, lr}
 8007604:	b086      	sub	sp, #24
 8007606:	af00      	add	r7, sp, #0
 8007608:	60f8      	str	r0, [r7, #12]
 800760a:	460b      	mov	r3, r1
 800760c:	607a      	str	r2, [r7, #4]
 800760e:	72fb      	strb	r3, [r7, #11]
  USBD_EndpointTypeDef *pep;
  USBD_StatusTypeDef ret;
  uint8_t idx;

  if (epnum == 0U)
 8007610:	7afb      	ldrb	r3, [r7, #11]
 8007612:	2b00      	cmp	r3, #0
 8007614:	d16f      	bne.n	80076f6 <USBD_LL_DataInStage+0xf4>
  {
    pep = &pdev->ep_in[0];
 8007616:	68fb      	ldr	r3, [r7, #12]
 8007618:	3314      	adds	r3, #20
 800761a:	613b      	str	r3, [r7, #16]

    if (pdev->ep0_state == USBD_EP0_DATA_IN)
 800761c:	68fb      	ldr	r3, [r7, #12]
 800761e:	f8d3 3294 	ldr.w	r3, [r3, #660]	@ 0x294
 8007622:	2b02      	cmp	r3, #2
 8007624:	d15a      	bne.n	80076dc <USBD_LL_DataInStage+0xda>
    {
      if (pep->rem_length > pep->maxpacket)
 8007626:	693b      	ldr	r3, [r7, #16]
 8007628:	689a      	ldr	r2, [r3, #8]
 800762a:	693b      	ldr	r3, [r7, #16]
 800762c:	68db      	ldr	r3, [r3, #12]
 800762e:	429a      	cmp	r2, r3
 8007630:	d914      	bls.n	800765c <USBD_LL_DataInStage+0x5a>
      {
        pep->rem_length -= pep->maxpacket;
 8007632:	693b      	ldr	r3, [r7, #16]
 8007634:	689a      	ldr	r2, [r3, #8]
 8007636:	693b      	ldr	r3, [r7, #16]
 8007638:	68db      	ldr	r3, [r3, #12]
 800763a:	1ad2      	subs	r2, r2, r3
 800763c:	693b      	ldr	r3, [r7, #16]
 800763e:	609a      	str	r2, [r3, #8]

        (void)USBD_CtlContinueSendData(pdev, pdata, pep->rem_length);
 8007640:	693b      	ldr	r3, [r7, #16]
 8007642:	689b      	ldr	r3, [r3, #8]
 8007644:	461a      	mov	r2, r3
 8007646:	6879      	ldr	r1, [r7, #4]
 8007648:	68f8      	ldr	r0, [r7, #12]
 800764a:	f001 f8bc 	bl	80087c6 <USBD_CtlContinueSendData>

        /* Prepare endpoint for premature end of transfer */
        (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 800764e:	2300      	movs	r3, #0
 8007650:	2200      	movs	r2, #0
 8007652:	2100      	movs	r1, #0
 8007654:	68f8      	ldr	r0, [r7, #12]
 8007656:	f020 fd73 	bl	8028140 <USBD_LL_PrepareReceive>
 800765a:	e03f      	b.n	80076dc <USBD_LL_DataInStage+0xda>
      }
      else
      {
        /* last packet is MPS multiple, so send ZLP packet */
        if ((pep->maxpacket == pep->rem_length) &&
 800765c:	693b      	ldr	r3, [r7, #16]
 800765e:	68da      	ldr	r2, [r3, #12]
 8007660:	693b      	ldr	r3, [r7, #16]
 8007662:	689b      	ldr	r3, [r3, #8]
 8007664:	429a      	cmp	r2, r3
 8007666:	d11c      	bne.n	80076a2 <USBD_LL_DataInStage+0xa0>
            (pep->total_length >= pep->maxpacket) &&
 8007668:	693b      	ldr	r3, [r7, #16]
 800766a:	685a      	ldr	r2, [r3, #4]
 800766c:	693b      	ldr	r3, [r7, #16]
 800766e:	68db      	ldr	r3, [r3, #12]
        if ((pep->maxpacket == pep->rem_length) &&
 8007670:	429a      	cmp	r2, r3
 8007672:	d316      	bcc.n	80076a2 <USBD_LL_DataInStage+0xa0>
            (pep->total_length < pdev->ep0_data_len))
 8007674:	693b      	ldr	r3, [r7, #16]
 8007676:	685a      	ldr	r2, [r3, #4]
 8007678:	68fb      	ldr	r3, [r7, #12]
 800767a:	f8d3 3298 	ldr.w	r3, [r3, #664]	@ 0x298
            (pep->total_length >= pep->maxpacket) &&
 800767e:	429a      	cmp	r2, r3
 8007680:	d20f      	bcs.n	80076a2 <USBD_LL_DataInStage+0xa0>
        {
          (void)USBD_CtlContinueSendData(pdev, NULL, 0U);
 8007682:	2200      	movs	r2, #0
 8007684:	2100      	movs	r1, #0
 8007686:	68f8      	ldr	r0, [r7, #12]
 8007688:	f001 f89d 	bl	80087c6 <USBD_CtlContinueSendData>
          pdev->ep0_data_len = 0U;
 800768c:	68fb      	ldr	r3, [r7, #12]
 800768e:	2200      	movs	r2, #0
 8007690:	f8c3 2298 	str.w	r2, [r3, #664]	@ 0x298

          /* Prepare endpoint for premature end of transfer */
          (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 8007694:	2300      	movs	r3, #0
 8007696:	2200      	movs	r2, #0
 8007698:	2100      	movs	r1, #0
 800769a:	68f8      	ldr	r0, [r7, #12]
 800769c:	f020 fd50 	bl	8028140 <USBD_LL_PrepareReceive>
 80076a0:	e01c      	b.n	80076dc <USBD_LL_DataInStage+0xda>
        }
        else
        {
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 80076a2:	68fb      	ldr	r3, [r7, #12]
 80076a4:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 80076a8:	b2db      	uxtb	r3, r3
 80076aa:	2b03      	cmp	r3, #3
 80076ac:	d10f      	bne.n	80076ce <USBD_LL_DataInStage+0xcc>
          {
            if (pdev->pClass[0]->EP0_TxSent != NULL)
 80076ae:	68fb      	ldr	r3, [r7, #12]
 80076b0:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 80076b4:	68db      	ldr	r3, [r3, #12]
 80076b6:	2b00      	cmp	r3, #0
 80076b8:	d009      	beq.n	80076ce <USBD_LL_DataInStage+0xcc>
            {
              pdev->classId = 0U;
 80076ba:	68fb      	ldr	r3, [r7, #12]
 80076bc:	2200      	movs	r2, #0
 80076be:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
              pdev->pClass[0]->EP0_TxSent(pdev);
 80076c2:	68fb      	ldr	r3, [r7, #12]
 80076c4:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 80076c8:	68db      	ldr	r3, [r3, #12]
 80076ca:	68f8      	ldr	r0, [r7, #12]
 80076cc:	4798      	blx	r3
            }
          }
          (void)USBD_LL_StallEP(pdev, 0x80U);
 80076ce:	2180      	movs	r1, #128	@ 0x80
 80076d0:	68f8      	ldr	r0, [r7, #12]
 80076d2:	f020 fc8b 	bl	8027fec <USBD_LL_StallEP>
          (void)USBD_CtlReceiveStatus(pdev);
 80076d6:	68f8      	ldr	r0, [r7, #12]
 80076d8:	f001 f8c7 	bl	800886a <USBD_CtlReceiveStatus>
        }
      }
    }

    if (pdev->dev_test_mode != 0U)
 80076dc:	68fb      	ldr	r3, [r7, #12]
 80076de:	f893 32a0 	ldrb.w	r3, [r3, #672]	@ 0x2a0
 80076e2:	2b00      	cmp	r3, #0
 80076e4:	d03a      	beq.n	800775c <USBD_LL_DataInStage+0x15a>
    {
      (void)USBD_RunTestMode(pdev);
 80076e6:	68f8      	ldr	r0, [r7, #12]
 80076e8:	f7ff fe42 	bl	8007370 <USBD_RunTestMode>
      pdev->dev_test_mode = 0U;
 80076ec:	68fb      	ldr	r3, [r7, #12]
 80076ee:	2200      	movs	r2, #0
 80076f0:	f883 22a0 	strb.w	r2, [r3, #672]	@ 0x2a0
 80076f4:	e032      	b.n	800775c <USBD_LL_DataInStage+0x15a>
    }
  }
  else
  {
    /* Get the class index relative to this interface */
    idx = USBD_CoreFindEP(pdev, ((uint8_t)epnum | 0x80U));
 80076f6:	7afb      	ldrb	r3, [r7, #11]
 80076f8:	f063 037f 	orn	r3, r3, #127	@ 0x7f
 80076fc:	b2db      	uxtb	r3, r3
 80076fe:	4619      	mov	r1, r3
 8007700:	68f8      	ldr	r0, [r7, #12]
 8007702:	f000 f985 	bl	8007a10 <USBD_CoreFindEP>
 8007706:	4603      	mov	r3, r0
 8007708:	75fb      	strb	r3, [r7, #23]

    if (((uint16_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 800770a:	7dfb      	ldrb	r3, [r7, #23]
 800770c:	2bff      	cmp	r3, #255	@ 0xff
 800770e:	d025      	beq.n	800775c <USBD_LL_DataInStage+0x15a>
 8007710:	7dfb      	ldrb	r3, [r7, #23]
 8007712:	2b00      	cmp	r3, #0
 8007714:	d122      	bne.n	800775c <USBD_LL_DataInStage+0x15a>
    {
      /* Call the class data out function to manage the request */
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8007716:	68fb      	ldr	r3, [r7, #12]
 8007718:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 800771c:	b2db      	uxtb	r3, r3
 800771e:	2b03      	cmp	r3, #3
 8007720:	d11c      	bne.n	800775c <USBD_LL_DataInStage+0x15a>
      {
        if (pdev->pClass[idx]->DataIn != NULL)
 8007722:	7dfa      	ldrb	r2, [r7, #23]
 8007724:	68fb      	ldr	r3, [r7, #12]
 8007726:	32ae      	adds	r2, #174	@ 0xae
 8007728:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800772c:	695b      	ldr	r3, [r3, #20]
 800772e:	2b00      	cmp	r3, #0
 8007730:	d014      	beq.n	800775c <USBD_LL_DataInStage+0x15a>
        {
          pdev->classId = idx;
 8007732:	7dfa      	ldrb	r2, [r7, #23]
 8007734:	68fb      	ldr	r3, [r7, #12]
 8007736:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
          ret = (USBD_StatusTypeDef)pdev->pClass[idx]->DataIn(pdev, epnum);
 800773a:	7dfa      	ldrb	r2, [r7, #23]
 800773c:	68fb      	ldr	r3, [r7, #12]
 800773e:	32ae      	adds	r2, #174	@ 0xae
 8007740:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007744:	695b      	ldr	r3, [r3, #20]
 8007746:	7afa      	ldrb	r2, [r7, #11]
 8007748:	4611      	mov	r1, r2
 800774a:	68f8      	ldr	r0, [r7, #12]
 800774c:	4798      	blx	r3
 800774e:	4603      	mov	r3, r0
 8007750:	75bb      	strb	r3, [r7, #22]

          if (ret != USBD_OK)
 8007752:	7dbb      	ldrb	r3, [r7, #22]
 8007754:	2b00      	cmp	r3, #0
 8007756:	d001      	beq.n	800775c <USBD_LL_DataInStage+0x15a>
          {
            return ret;
 8007758:	7dbb      	ldrb	r3, [r7, #22]
 800775a:	e000      	b.n	800775e <USBD_LL_DataInStage+0x15c>
        }
      }
    }
  }

  return USBD_OK;
 800775c:	2300      	movs	r3, #0
}
 800775e:	4618      	mov	r0, r3
 8007760:	3718      	adds	r7, #24
 8007762:	46bd      	mov	sp, r7
 8007764:	bd80      	pop	{r7, pc}

08007766 <USBD_LL_Reset>:
  *         Handle Reset event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef *pdev)
{
 8007766:	b580      	push	{r7, lr}
 8007768:	b084      	sub	sp, #16
 800776a:	af00      	add	r7, sp, #0
 800776c:	6078      	str	r0, [r7, #4]
  USBD_StatusTypeDef ret = USBD_OK;
 800776e:	2300      	movs	r3, #0
 8007770:	73fb      	strb	r3, [r7, #15]

  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
 8007772:	687b      	ldr	r3, [r7, #4]
 8007774:	2201      	movs	r2, #1
 8007776:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
  pdev->ep0_state = USBD_EP0_IDLE;
 800777a:	687b      	ldr	r3, [r7, #4]
 800777c:	2200      	movs	r2, #0
 800777e:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294
  pdev->dev_config = 0U;
 8007782:	687b      	ldr	r3, [r7, #4]
 8007784:	2200      	movs	r2, #0
 8007786:	605a      	str	r2, [r3, #4]
  pdev->dev_remote_wakeup = 0U;
 8007788:	687b      	ldr	r3, [r7, #4]
 800778a:	2200      	movs	r2, #0
 800778c:	f8c3 22a4 	str.w	r2, [r3, #676]	@ 0x2a4
  pdev->dev_test_mode = 0U;
 8007790:	687b      	ldr	r3, [r7, #4]
 8007792:	2200      	movs	r2, #0
 8007794:	f883 22a0 	strb.w	r2, [r3, #672]	@ 0x2a0
      }
    }
  }
#else

  if (pdev->pClass[0] != NULL)
 8007798:	687b      	ldr	r3, [r7, #4]
 800779a:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 800779e:	2b00      	cmp	r3, #0
 80077a0:	d014      	beq.n	80077cc <USBD_LL_Reset+0x66>
  {
    if (pdev->pClass[0]->DeInit != NULL)
 80077a2:	687b      	ldr	r3, [r7, #4]
 80077a4:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 80077a8:	685b      	ldr	r3, [r3, #4]
 80077aa:	2b00      	cmp	r3, #0
 80077ac:	d00e      	beq.n	80077cc <USBD_LL_Reset+0x66>
    {
      if (pdev->pClass[0]->DeInit(pdev, (uint8_t)pdev->dev_config) != USBD_OK)
 80077ae:	687b      	ldr	r3, [r7, #4]
 80077b0:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 80077b4:	685b      	ldr	r3, [r3, #4]
 80077b6:	687a      	ldr	r2, [r7, #4]
 80077b8:	6852      	ldr	r2, [r2, #4]
 80077ba:	b2d2      	uxtb	r2, r2
 80077bc:	4611      	mov	r1, r2
 80077be:	6878      	ldr	r0, [r7, #4]
 80077c0:	4798      	blx	r3
 80077c2:	4603      	mov	r3, r0
 80077c4:	2b00      	cmp	r3, #0
 80077c6:	d001      	beq.n	80077cc <USBD_LL_Reset+0x66>
      {
        ret = USBD_FAIL;
 80077c8:	2303      	movs	r3, #3
 80077ca:	73fb      	strb	r3, [r7, #15]
    }
  }
#endif /* USE_USBD_COMPOSITE */

  /* Open EP0 OUT */
  (void)USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 80077cc:	2340      	movs	r3, #64	@ 0x40
 80077ce:	2200      	movs	r2, #0
 80077d0:	2100      	movs	r1, #0
 80077d2:	6878      	ldr	r0, [r7, #4]
 80077d4:	f020 fbc5 	bl	8027f62 <USBD_LL_OpenEP>
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
 80077d8:	687b      	ldr	r3, [r7, #4]
 80077da:	2201      	movs	r2, #1
 80077dc:	f8a3 2164 	strh.w	r2, [r3, #356]	@ 0x164

  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 80077e0:	687b      	ldr	r3, [r7, #4]
 80077e2:	2240      	movs	r2, #64	@ 0x40
 80077e4:	f8c3 2160 	str.w	r2, [r3, #352]	@ 0x160

  /* Open EP0 IN */
  (void)USBD_LL_OpenEP(pdev, 0x80U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 80077e8:	2340      	movs	r3, #64	@ 0x40
 80077ea:	2200      	movs	r2, #0
 80077ec:	2180      	movs	r1, #128	@ 0x80
 80077ee:	6878      	ldr	r0, [r7, #4]
 80077f0:	f020 fbb7 	bl	8027f62 <USBD_LL_OpenEP>
  pdev->ep_in[0x80U & 0xFU].is_used = 1U;
 80077f4:	687b      	ldr	r3, [r7, #4]
 80077f6:	2201      	movs	r2, #1
 80077f8:	849a      	strh	r2, [r3, #36]	@ 0x24

  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 80077fa:	687b      	ldr	r3, [r7, #4]
 80077fc:	2240      	movs	r2, #64	@ 0x40
 80077fe:	621a      	str	r2, [r3, #32]

  return ret;
 8007800:	7bfb      	ldrb	r3, [r7, #15]
}
 8007802:	4618      	mov	r0, r3
 8007804:	3710      	adds	r7, #16
 8007806:	46bd      	mov	sp, r7
 8007808:	bd80      	pop	{r7, pc}

0800780a <USBD_LL_SetSpeed>:
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef *pdev,
                                    USBD_SpeedTypeDef speed)
{
 800780a:	b480      	push	{r7}
 800780c:	b083      	sub	sp, #12
 800780e:	af00      	add	r7, sp, #0
 8007810:	6078      	str	r0, [r7, #4]
 8007812:	460b      	mov	r3, r1
 8007814:	70fb      	strb	r3, [r7, #3]
  pdev->dev_speed = speed;
 8007816:	687b      	ldr	r3, [r7, #4]
 8007818:	78fa      	ldrb	r2, [r7, #3]
 800781a:	741a      	strb	r2, [r3, #16]

  return USBD_OK;
 800781c:	2300      	movs	r3, #0
}
 800781e:	4618      	mov	r0, r3
 8007820:	370c      	adds	r7, #12
 8007822:	46bd      	mov	sp, r7
 8007824:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007828:	4770      	bx	lr

0800782a <USBD_LL_Suspend>:
  *         Handle Suspend event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef *pdev)
{
 800782a:	b480      	push	{r7}
 800782c:	b083      	sub	sp, #12
 800782e:	af00      	add	r7, sp, #0
 8007830:	6078      	str	r0, [r7, #4]
  if (pdev->dev_state != USBD_STATE_SUSPENDED)
 8007832:	687b      	ldr	r3, [r7, #4]
 8007834:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8007838:	b2db      	uxtb	r3, r3
 800783a:	2b04      	cmp	r3, #4
 800783c:	d006      	beq.n	800784c <USBD_LL_Suspend+0x22>
  {
    pdev->dev_old_state = pdev->dev_state;
 800783e:	687b      	ldr	r3, [r7, #4]
 8007840:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8007844:	b2da      	uxtb	r2, r3
 8007846:	687b      	ldr	r3, [r7, #4]
 8007848:	f883 229d 	strb.w	r2, [r3, #669]	@ 0x29d
  }

  pdev->dev_state = USBD_STATE_SUSPENDED;
 800784c:	687b      	ldr	r3, [r7, #4]
 800784e:	2204      	movs	r2, #4
 8007850:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c

  return USBD_OK;
 8007854:	2300      	movs	r3, #0
}
 8007856:	4618      	mov	r0, r3
 8007858:	370c      	adds	r7, #12
 800785a:	46bd      	mov	sp, r7
 800785c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007860:	4770      	bx	lr

08007862 <USBD_LL_Resume>:
  *         Handle Resume event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef *pdev)
{
 8007862:	b480      	push	{r7}
 8007864:	b083      	sub	sp, #12
 8007866:	af00      	add	r7, sp, #0
 8007868:	6078      	str	r0, [r7, #4]
  if (pdev->dev_state == USBD_STATE_SUSPENDED)
 800786a:	687b      	ldr	r3, [r7, #4]
 800786c:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8007870:	b2db      	uxtb	r3, r3
 8007872:	2b04      	cmp	r3, #4
 8007874:	d106      	bne.n	8007884 <USBD_LL_Resume+0x22>
  {
    pdev->dev_state = pdev->dev_old_state;
 8007876:	687b      	ldr	r3, [r7, #4]
 8007878:	f893 329d 	ldrb.w	r3, [r3, #669]	@ 0x29d
 800787c:	b2da      	uxtb	r2, r3
 800787e:	687b      	ldr	r3, [r7, #4]
 8007880:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
  }

  return USBD_OK;
 8007884:	2300      	movs	r3, #0
}
 8007886:	4618      	mov	r0, r3
 8007888:	370c      	adds	r7, #12
 800788a:	46bd      	mov	sp, r7
 800788c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007890:	4770      	bx	lr

08007892 <USBD_LL_SOF>:
  *         Handle SOF event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef *pdev)
{
 8007892:	b580      	push	{r7, lr}
 8007894:	b082      	sub	sp, #8
 8007896:	af00      	add	r7, sp, #0
 8007898:	6078      	str	r0, [r7, #4]
  /* The SOF event can be distributed for all classes that support it */
  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 800789a:	687b      	ldr	r3, [r7, #4]
 800789c:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 80078a0:	b2db      	uxtb	r3, r3
 80078a2:	2b03      	cmp	r3, #3
 80078a4:	d110      	bne.n	80078c8 <USBD_LL_SOF+0x36>
          }
        }
      }
    }
#else
    if (pdev->pClass[0] != NULL)
 80078a6:	687b      	ldr	r3, [r7, #4]
 80078a8:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 80078ac:	2b00      	cmp	r3, #0
 80078ae:	d00b      	beq.n	80078c8 <USBD_LL_SOF+0x36>
    {
      if (pdev->pClass[0]->SOF != NULL)
 80078b0:	687b      	ldr	r3, [r7, #4]
 80078b2:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 80078b6:	69db      	ldr	r3, [r3, #28]
 80078b8:	2b00      	cmp	r3, #0
 80078ba:	d005      	beq.n	80078c8 <USBD_LL_SOF+0x36>
      {
        (void)pdev->pClass[0]->SOF(pdev);
 80078bc:	687b      	ldr	r3, [r7, #4]
 80078be:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 80078c2:	69db      	ldr	r3, [r3, #28]
 80078c4:	6878      	ldr	r0, [r7, #4]
 80078c6:	4798      	blx	r3
      }
    }
#endif /* USE_USBD_COMPOSITE */
  }

  return USBD_OK;
 80078c8:	2300      	movs	r3, #0
}
 80078ca:	4618      	mov	r0, r3
 80078cc:	3708      	adds	r7, #8
 80078ce:	46bd      	mov	sp, r7
 80078d0:	bd80      	pop	{r7, pc}

080078d2 <USBD_LL_IsoINIncomplete>:
  * @param  epnum: Endpoint number
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_IsoINIncomplete(USBD_HandleTypeDef *pdev,
                                           uint8_t epnum)
{
 80078d2:	b580      	push	{r7, lr}
 80078d4:	b082      	sub	sp, #8
 80078d6:	af00      	add	r7, sp, #0
 80078d8:	6078      	str	r0, [r7, #4]
 80078da:	460b      	mov	r3, r1
 80078dc:	70fb      	strb	r3, [r7, #3]
  if (pdev->pClass[pdev->classId] == NULL)
 80078de:	687b      	ldr	r3, [r7, #4]
 80078e0:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 80078e4:	687b      	ldr	r3, [r7, #4]
 80078e6:	32ae      	adds	r2, #174	@ 0xae
 80078e8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80078ec:	2b00      	cmp	r3, #0
 80078ee:	d101      	bne.n	80078f4 <USBD_LL_IsoINIncomplete+0x22>
  {
    return USBD_FAIL;
 80078f0:	2303      	movs	r3, #3
 80078f2:	e01c      	b.n	800792e <USBD_LL_IsoINIncomplete+0x5c>
  }

  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 80078f4:	687b      	ldr	r3, [r7, #4]
 80078f6:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 80078fa:	b2db      	uxtb	r3, r3
 80078fc:	2b03      	cmp	r3, #3
 80078fe:	d115      	bne.n	800792c <USBD_LL_IsoINIncomplete+0x5a>
  {
    if (pdev->pClass[pdev->classId]->IsoINIncomplete != NULL)
 8007900:	687b      	ldr	r3, [r7, #4]
 8007902:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8007906:	687b      	ldr	r3, [r7, #4]
 8007908:	32ae      	adds	r2, #174	@ 0xae
 800790a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800790e:	6a1b      	ldr	r3, [r3, #32]
 8007910:	2b00      	cmp	r3, #0
 8007912:	d00b      	beq.n	800792c <USBD_LL_IsoINIncomplete+0x5a>
    {
      (void)pdev->pClass[pdev->classId]->IsoINIncomplete(pdev, epnum);
 8007914:	687b      	ldr	r3, [r7, #4]
 8007916:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 800791a:	687b      	ldr	r3, [r7, #4]
 800791c:	32ae      	adds	r2, #174	@ 0xae
 800791e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007922:	6a1b      	ldr	r3, [r3, #32]
 8007924:	78fa      	ldrb	r2, [r7, #3]
 8007926:	4611      	mov	r1, r2
 8007928:	6878      	ldr	r0, [r7, #4]
 800792a:	4798      	blx	r3
    }
  }

  return USBD_OK;
 800792c:	2300      	movs	r3, #0
}
 800792e:	4618      	mov	r0, r3
 8007930:	3708      	adds	r7, #8
 8007932:	46bd      	mov	sp, r7
 8007934:	bd80      	pop	{r7, pc}

08007936 <USBD_LL_IsoOUTIncomplete>:
  * @param  epnum: Endpoint number
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_IsoOUTIncomplete(USBD_HandleTypeDef *pdev,
                                            uint8_t epnum)
{
 8007936:	b580      	push	{r7, lr}
 8007938:	b082      	sub	sp, #8
 800793a:	af00      	add	r7, sp, #0
 800793c:	6078      	str	r0, [r7, #4]
 800793e:	460b      	mov	r3, r1
 8007940:	70fb      	strb	r3, [r7, #3]
  if (pdev->pClass[pdev->classId] == NULL)
 8007942:	687b      	ldr	r3, [r7, #4]
 8007944:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8007948:	687b      	ldr	r3, [r7, #4]
 800794a:	32ae      	adds	r2, #174	@ 0xae
 800794c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007950:	2b00      	cmp	r3, #0
 8007952:	d101      	bne.n	8007958 <USBD_LL_IsoOUTIncomplete+0x22>
  {
    return USBD_FAIL;
 8007954:	2303      	movs	r3, #3
 8007956:	e01c      	b.n	8007992 <USBD_LL_IsoOUTIncomplete+0x5c>
  }

  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8007958:	687b      	ldr	r3, [r7, #4]
 800795a:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 800795e:	b2db      	uxtb	r3, r3
 8007960:	2b03      	cmp	r3, #3
 8007962:	d115      	bne.n	8007990 <USBD_LL_IsoOUTIncomplete+0x5a>
  {
    if (pdev->pClass[pdev->classId]->IsoOUTIncomplete != NULL)
 8007964:	687b      	ldr	r3, [r7, #4]
 8007966:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 800796a:	687b      	ldr	r3, [r7, #4]
 800796c:	32ae      	adds	r2, #174	@ 0xae
 800796e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007972:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8007974:	2b00      	cmp	r3, #0
 8007976:	d00b      	beq.n	8007990 <USBD_LL_IsoOUTIncomplete+0x5a>
    {
      (void)pdev->pClass[pdev->classId]->IsoOUTIncomplete(pdev, epnum);
 8007978:	687b      	ldr	r3, [r7, #4]
 800797a:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 800797e:	687b      	ldr	r3, [r7, #4]
 8007980:	32ae      	adds	r2, #174	@ 0xae
 8007982:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007986:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8007988:	78fa      	ldrb	r2, [r7, #3]
 800798a:	4611      	mov	r1, r2
 800798c:	6878      	ldr	r0, [r7, #4]
 800798e:	4798      	blx	r3
    }
  }

  return USBD_OK;
 8007990:	2300      	movs	r3, #0
}
 8007992:	4618      	mov	r0, r3
 8007994:	3708      	adds	r7, #8
 8007996:	46bd      	mov	sp, r7
 8007998:	bd80      	pop	{r7, pc}

0800799a <USBD_LL_DevConnected>:
  *         Handle device connection event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DevConnected(USBD_HandleTypeDef *pdev)
{
 800799a:	b480      	push	{r7}
 800799c:	b083      	sub	sp, #12
 800799e:	af00      	add	r7, sp, #0
 80079a0:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument compilation warning */
  UNUSED(pdev);

  return USBD_OK;
 80079a2:	2300      	movs	r3, #0
}
 80079a4:	4618      	mov	r0, r3
 80079a6:	370c      	adds	r7, #12
 80079a8:	46bd      	mov	sp, r7
 80079aa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80079ae:	4770      	bx	lr

080079b0 <USBD_LL_DevDisconnected>:
  *         Handle device disconnection event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DevDisconnected(USBD_HandleTypeDef *pdev)
{
 80079b0:	b580      	push	{r7, lr}
 80079b2:	b084      	sub	sp, #16
 80079b4:	af00      	add	r7, sp, #0
 80079b6:	6078      	str	r0, [r7, #4]
  USBD_StatusTypeDef   ret = USBD_OK;
 80079b8:	2300      	movs	r3, #0
 80079ba:	73fb      	strb	r3, [r7, #15]

  /* Free Class Resources */
  pdev->dev_state = USBD_STATE_DEFAULT;
 80079bc:	687b      	ldr	r3, [r7, #4]
 80079be:	2201      	movs	r2, #1
 80079c0:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
        }
      }
    }
  }
#else
  if (pdev->pClass[0] != NULL)
 80079c4:	687b      	ldr	r3, [r7, #4]
 80079c6:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 80079ca:	2b00      	cmp	r3, #0
 80079cc:	d00e      	beq.n	80079ec <USBD_LL_DevDisconnected+0x3c>
  {
    if (pdev->pClass[0]->DeInit(pdev, (uint8_t)pdev->dev_config) != 0U)
 80079ce:	687b      	ldr	r3, [r7, #4]
 80079d0:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 80079d4:	685b      	ldr	r3, [r3, #4]
 80079d6:	687a      	ldr	r2, [r7, #4]
 80079d8:	6852      	ldr	r2, [r2, #4]
 80079da:	b2d2      	uxtb	r2, r2
 80079dc:	4611      	mov	r1, r2
 80079de:	6878      	ldr	r0, [r7, #4]
 80079e0:	4798      	blx	r3
 80079e2:	4603      	mov	r3, r0
 80079e4:	2b00      	cmp	r3, #0
 80079e6:	d001      	beq.n	80079ec <USBD_LL_DevDisconnected+0x3c>
    {
      ret = USBD_FAIL;
 80079e8:	2303      	movs	r3, #3
 80079ea:	73fb      	strb	r3, [r7, #15]
    }
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
 80079ec:	7bfb      	ldrb	r3, [r7, #15]
}
 80079ee:	4618      	mov	r0, r3
 80079f0:	3710      	adds	r7, #16
 80079f2:	46bd      	mov	sp, r7
 80079f4:	bd80      	pop	{r7, pc}

080079f6 <USBD_CoreFindIF>:
  * @param  pdev: device instance
  * @param  index : selected interface number
  * @retval index of the class using the selected interface number. OxFF if no class found.
  */
uint8_t USBD_CoreFindIF(USBD_HandleTypeDef *pdev, uint8_t index)
{
 80079f6:	b480      	push	{r7}
 80079f8:	b083      	sub	sp, #12
 80079fa:	af00      	add	r7, sp, #0
 80079fc:	6078      	str	r0, [r7, #4]
 80079fe:	460b      	mov	r3, r1
 8007a00:	70fb      	strb	r3, [r7, #3]
  return 0xFFU;
#else
  UNUSED(pdev);
  UNUSED(index);

  return 0x00U;
 8007a02:	2300      	movs	r3, #0
#endif /* USE_USBD_COMPOSITE */
}
 8007a04:	4618      	mov	r0, r3
 8007a06:	370c      	adds	r7, #12
 8007a08:	46bd      	mov	sp, r7
 8007a0a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007a0e:	4770      	bx	lr

08007a10 <USBD_CoreFindEP>:
  * @param  pdev: device instance
  * @param  index : selected endpoint number
  * @retval index of the class using the selected endpoint number. 0xFF if no class found.
  */
uint8_t USBD_CoreFindEP(USBD_HandleTypeDef *pdev, uint8_t index)
{
 8007a10:	b480      	push	{r7}
 8007a12:	b083      	sub	sp, #12
 8007a14:	af00      	add	r7, sp, #0
 8007a16:	6078      	str	r0, [r7, #4]
 8007a18:	460b      	mov	r3, r1
 8007a1a:	70fb      	strb	r3, [r7, #3]
  return 0xFFU;
#else
  UNUSED(pdev);
  UNUSED(index);

  return 0x00U;
 8007a1c:	2300      	movs	r3, #0
#endif /* USE_USBD_COMPOSITE */
}
 8007a1e:	4618      	mov	r0, r3
 8007a20:	370c      	adds	r7, #12
 8007a22:	46bd      	mov	sp, r7
 8007a24:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007a28:	4770      	bx	lr

08007a2a <USBD_GetEpDesc>:
  * @param  pConfDesc:  pointer to Bos descriptor
  * @param  EpAddr:  endpoint address
  * @retval pointer to video endpoint descriptor
  */
void *USBD_GetEpDesc(uint8_t *pConfDesc, uint8_t EpAddr)
{
 8007a2a:	b580      	push	{r7, lr}
 8007a2c:	b086      	sub	sp, #24
 8007a2e:	af00      	add	r7, sp, #0
 8007a30:	6078      	str	r0, [r7, #4]
 8007a32:	460b      	mov	r3, r1
 8007a34:	70fb      	strb	r3, [r7, #3]
  USBD_DescHeaderTypeDef *pdesc = (USBD_DescHeaderTypeDef *)(void *)pConfDesc;
 8007a36:	687b      	ldr	r3, [r7, #4]
 8007a38:	617b      	str	r3, [r7, #20]
  USBD_ConfigDescTypeDef *desc = (USBD_ConfigDescTypeDef *)(void *)pConfDesc;
 8007a3a:	687b      	ldr	r3, [r7, #4]
 8007a3c:	60fb      	str	r3, [r7, #12]
  USBD_EpDescTypeDef *pEpDesc = NULL;
 8007a3e:	2300      	movs	r3, #0
 8007a40:	613b      	str	r3, [r7, #16]
  uint16_t ptr;

  if (desc->wTotalLength > desc->bLength)
 8007a42:	68fb      	ldr	r3, [r7, #12]
 8007a44:	885b      	ldrh	r3, [r3, #2]
 8007a46:	b29b      	uxth	r3, r3
 8007a48:	68fa      	ldr	r2, [r7, #12]
 8007a4a:	7812      	ldrb	r2, [r2, #0]
 8007a4c:	4293      	cmp	r3, r2
 8007a4e:	d91f      	bls.n	8007a90 <USBD_GetEpDesc+0x66>
  {
    ptr = desc->bLength;
 8007a50:	68fb      	ldr	r3, [r7, #12]
 8007a52:	781b      	ldrb	r3, [r3, #0]
 8007a54:	817b      	strh	r3, [r7, #10]

    while (ptr < desc->wTotalLength)
 8007a56:	e013      	b.n	8007a80 <USBD_GetEpDesc+0x56>
    {
      pdesc = USBD_GetNextDesc((uint8_t *)pdesc, &ptr);
 8007a58:	f107 030a 	add.w	r3, r7, #10
 8007a5c:	4619      	mov	r1, r3
 8007a5e:	6978      	ldr	r0, [r7, #20]
 8007a60:	f000 f81b 	bl	8007a9a <USBD_GetNextDesc>
 8007a64:	6178      	str	r0, [r7, #20]

      if (pdesc->bDescriptorType == USB_DESC_TYPE_ENDPOINT)
 8007a66:	697b      	ldr	r3, [r7, #20]
 8007a68:	785b      	ldrb	r3, [r3, #1]
 8007a6a:	2b05      	cmp	r3, #5
 8007a6c:	d108      	bne.n	8007a80 <USBD_GetEpDesc+0x56>
      {
        pEpDesc = (USBD_EpDescTypeDef *)(void *)pdesc;
 8007a6e:	697b      	ldr	r3, [r7, #20]
 8007a70:	613b      	str	r3, [r7, #16]

        if (pEpDesc->bEndpointAddress == EpAddr)
 8007a72:	693b      	ldr	r3, [r7, #16]
 8007a74:	789b      	ldrb	r3, [r3, #2]
 8007a76:	78fa      	ldrb	r2, [r7, #3]
 8007a78:	429a      	cmp	r2, r3
 8007a7a:	d008      	beq.n	8007a8e <USBD_GetEpDesc+0x64>
        {
          break;
        }
        else
        {
          pEpDesc = NULL;
 8007a7c:	2300      	movs	r3, #0
 8007a7e:	613b      	str	r3, [r7, #16]
    while (ptr < desc->wTotalLength)
 8007a80:	68fb      	ldr	r3, [r7, #12]
 8007a82:	885b      	ldrh	r3, [r3, #2]
 8007a84:	b29a      	uxth	r2, r3
 8007a86:	897b      	ldrh	r3, [r7, #10]
 8007a88:	429a      	cmp	r2, r3
 8007a8a:	d8e5      	bhi.n	8007a58 <USBD_GetEpDesc+0x2e>
 8007a8c:	e000      	b.n	8007a90 <USBD_GetEpDesc+0x66>
          break;
 8007a8e:	bf00      	nop
        }
      }
    }
  }

  return (void *)pEpDesc;
 8007a90:	693b      	ldr	r3, [r7, #16]
}
 8007a92:	4618      	mov	r0, r3
 8007a94:	3718      	adds	r7, #24
 8007a96:	46bd      	mov	sp, r7
 8007a98:	bd80      	pop	{r7, pc}

08007a9a <USBD_GetNextDesc>:
  * @param  buf: Buffer where the descriptor is available
  * @param  ptr: data pointer inside the descriptor
  * @retval next header
  */
USBD_DescHeaderTypeDef *USBD_GetNextDesc(uint8_t *pbuf, uint16_t *ptr)
{
 8007a9a:	b480      	push	{r7}
 8007a9c:	b085      	sub	sp, #20
 8007a9e:	af00      	add	r7, sp, #0
 8007aa0:	6078      	str	r0, [r7, #4]
 8007aa2:	6039      	str	r1, [r7, #0]
  USBD_DescHeaderTypeDef *pnext = (USBD_DescHeaderTypeDef *)(void *)pbuf;
 8007aa4:	687b      	ldr	r3, [r7, #4]
 8007aa6:	60fb      	str	r3, [r7, #12]

  *ptr += pnext->bLength;
 8007aa8:	683b      	ldr	r3, [r7, #0]
 8007aaa:	881b      	ldrh	r3, [r3, #0]
 8007aac:	68fa      	ldr	r2, [r7, #12]
 8007aae:	7812      	ldrb	r2, [r2, #0]
 8007ab0:	4413      	add	r3, r2
 8007ab2:	b29a      	uxth	r2, r3
 8007ab4:	683b      	ldr	r3, [r7, #0]
 8007ab6:	801a      	strh	r2, [r3, #0]
  pnext = (USBD_DescHeaderTypeDef *)(void *)(pbuf + pnext->bLength);
 8007ab8:	68fb      	ldr	r3, [r7, #12]
 8007aba:	781b      	ldrb	r3, [r3, #0]
 8007abc:	461a      	mov	r2, r3
 8007abe:	687b      	ldr	r3, [r7, #4]
 8007ac0:	4413      	add	r3, r2
 8007ac2:	60fb      	str	r3, [r7, #12]

  return (pnext);
 8007ac4:	68fb      	ldr	r3, [r7, #12]
}
 8007ac6:	4618      	mov	r0, r3
 8007ac8:	3714      	adds	r7, #20
 8007aca:	46bd      	mov	sp, r7
 8007acc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007ad0:	4770      	bx	lr

08007ad2 <SWAPBYTE>:

/** @defgroup USBD_DEF_Exported_Macros
  * @{
  */
__STATIC_INLINE uint16_t SWAPBYTE(uint8_t *addr)
{
 8007ad2:	b480      	push	{r7}
 8007ad4:	b087      	sub	sp, #28
 8007ad6:	af00      	add	r7, sp, #0
 8007ad8:	6078      	str	r0, [r7, #4]
  uint16_t _SwapVal;
  uint16_t _Byte1;
  uint16_t _Byte2;
  uint8_t *_pbuff = addr;
 8007ada:	687b      	ldr	r3, [r7, #4]
 8007adc:	617b      	str	r3, [r7, #20]

  _Byte1 = *(uint8_t *)_pbuff;
 8007ade:	697b      	ldr	r3, [r7, #20]
 8007ae0:	781b      	ldrb	r3, [r3, #0]
 8007ae2:	827b      	strh	r3, [r7, #18]
  _pbuff++;
 8007ae4:	697b      	ldr	r3, [r7, #20]
 8007ae6:	3301      	adds	r3, #1
 8007ae8:	617b      	str	r3, [r7, #20]
  _Byte2 = *(uint8_t *)_pbuff;
 8007aea:	697b      	ldr	r3, [r7, #20]
 8007aec:	781b      	ldrb	r3, [r3, #0]
 8007aee:	823b      	strh	r3, [r7, #16]

  _SwapVal = (_Byte2 << 8) | _Byte1;
 8007af0:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8007af4:	021b      	lsls	r3, r3, #8
 8007af6:	b21a      	sxth	r2, r3
 8007af8:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8007afc:	4313      	orrs	r3, r2
 8007afe:	b21b      	sxth	r3, r3
 8007b00:	81fb      	strh	r3, [r7, #14]

  return _SwapVal;
 8007b02:	89fb      	ldrh	r3, [r7, #14]
}
 8007b04:	4618      	mov	r0, r3
 8007b06:	371c      	adds	r7, #28
 8007b08:	46bd      	mov	sp, r7
 8007b0a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007b0e:	4770      	bx	lr

08007b10 <USBD_StdDevReq>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
USBD_StatusTypeDef USBD_StdDevReq(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8007b10:	b580      	push	{r7, lr}
 8007b12:	b084      	sub	sp, #16
 8007b14:	af00      	add	r7, sp, #0
 8007b16:	6078      	str	r0, [r7, #4]
 8007b18:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK;
 8007b1a:	2300      	movs	r3, #0
 8007b1c:	73fb      	strb	r3, [r7, #15]

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8007b1e:	683b      	ldr	r3, [r7, #0]
 8007b20:	781b      	ldrb	r3, [r3, #0]
 8007b22:	f003 0360 	and.w	r3, r3, #96	@ 0x60
 8007b26:	2b40      	cmp	r3, #64	@ 0x40
 8007b28:	d005      	beq.n	8007b36 <USBD_StdDevReq+0x26>
 8007b2a:	2b40      	cmp	r3, #64	@ 0x40
 8007b2c:	d857      	bhi.n	8007bde <USBD_StdDevReq+0xce>
 8007b2e:	2b00      	cmp	r3, #0
 8007b30:	d00f      	beq.n	8007b52 <USBD_StdDevReq+0x42>
 8007b32:	2b20      	cmp	r3, #32
 8007b34:	d153      	bne.n	8007bde <USBD_StdDevReq+0xce>
  {
    case USB_REQ_TYPE_CLASS:
    case USB_REQ_TYPE_VENDOR:
      ret = (USBD_StatusTypeDef)pdev->pClass[pdev->classId]->Setup(pdev, req);
 8007b36:	687b      	ldr	r3, [r7, #4]
 8007b38:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8007b3c:	687b      	ldr	r3, [r7, #4]
 8007b3e:	32ae      	adds	r2, #174	@ 0xae
 8007b40:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007b44:	689b      	ldr	r3, [r3, #8]
 8007b46:	6839      	ldr	r1, [r7, #0]
 8007b48:	6878      	ldr	r0, [r7, #4]
 8007b4a:	4798      	blx	r3
 8007b4c:	4603      	mov	r3, r0
 8007b4e:	73fb      	strb	r3, [r7, #15]
      break;
 8007b50:	e04a      	b.n	8007be8 <USBD_StdDevReq+0xd8>

    case USB_REQ_TYPE_STANDARD:
      switch (req->bRequest)
 8007b52:	683b      	ldr	r3, [r7, #0]
 8007b54:	785b      	ldrb	r3, [r3, #1]
 8007b56:	2b09      	cmp	r3, #9
 8007b58:	d83b      	bhi.n	8007bd2 <USBD_StdDevReq+0xc2>
 8007b5a:	a201      	add	r2, pc, #4	@ (adr r2, 8007b60 <USBD_StdDevReq+0x50>)
 8007b5c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8007b60:	08007bb5 	.word	0x08007bb5
 8007b64:	08007bc9 	.word	0x08007bc9
 8007b68:	08007bd3 	.word	0x08007bd3
 8007b6c:	08007bbf 	.word	0x08007bbf
 8007b70:	08007bd3 	.word	0x08007bd3
 8007b74:	08007b93 	.word	0x08007b93
 8007b78:	08007b89 	.word	0x08007b89
 8007b7c:	08007bd3 	.word	0x08007bd3
 8007b80:	08007bab 	.word	0x08007bab
 8007b84:	08007b9d 	.word	0x08007b9d
      {
        case USB_REQ_GET_DESCRIPTOR:
          USBD_GetDescriptor(pdev, req);
 8007b88:	6839      	ldr	r1, [r7, #0]
 8007b8a:	6878      	ldr	r0, [r7, #4]
 8007b8c:	f000 fa3c 	bl	8008008 <USBD_GetDescriptor>
          break;
 8007b90:	e024      	b.n	8007bdc <USBD_StdDevReq+0xcc>

        case USB_REQ_SET_ADDRESS:
          USBD_SetAddress(pdev, req);
 8007b92:	6839      	ldr	r1, [r7, #0]
 8007b94:	6878      	ldr	r0, [r7, #4]
 8007b96:	f000 fba1 	bl	80082dc <USBD_SetAddress>
          break;
 8007b9a:	e01f      	b.n	8007bdc <USBD_StdDevReq+0xcc>

        case USB_REQ_SET_CONFIGURATION:
          ret = USBD_SetConfig(pdev, req);
 8007b9c:	6839      	ldr	r1, [r7, #0]
 8007b9e:	6878      	ldr	r0, [r7, #4]
 8007ba0:	f000 fbe0 	bl	8008364 <USBD_SetConfig>
 8007ba4:	4603      	mov	r3, r0
 8007ba6:	73fb      	strb	r3, [r7, #15]
          break;
 8007ba8:	e018      	b.n	8007bdc <USBD_StdDevReq+0xcc>

        case USB_REQ_GET_CONFIGURATION:
          USBD_GetConfig(pdev, req);
 8007baa:	6839      	ldr	r1, [r7, #0]
 8007bac:	6878      	ldr	r0, [r7, #4]
 8007bae:	f000 fc83 	bl	80084b8 <USBD_GetConfig>
          break;
 8007bb2:	e013      	b.n	8007bdc <USBD_StdDevReq+0xcc>

        case USB_REQ_GET_STATUS:
          USBD_GetStatus(pdev, req);
 8007bb4:	6839      	ldr	r1, [r7, #0]
 8007bb6:	6878      	ldr	r0, [r7, #4]
 8007bb8:	f000 fcb4 	bl	8008524 <USBD_GetStatus>
          break;
 8007bbc:	e00e      	b.n	8007bdc <USBD_StdDevReq+0xcc>

        case USB_REQ_SET_FEATURE:
          USBD_SetFeature(pdev, req);
 8007bbe:	6839      	ldr	r1, [r7, #0]
 8007bc0:	6878      	ldr	r0, [r7, #4]
 8007bc2:	f000 fce3 	bl	800858c <USBD_SetFeature>
          break;
 8007bc6:	e009      	b.n	8007bdc <USBD_StdDevReq+0xcc>

        case USB_REQ_CLEAR_FEATURE:
          USBD_ClrFeature(pdev, req);
 8007bc8:	6839      	ldr	r1, [r7, #0]
 8007bca:	6878      	ldr	r0, [r7, #4]
 8007bcc:	f000 fd07 	bl	80085de <USBD_ClrFeature>
          break;
 8007bd0:	e004      	b.n	8007bdc <USBD_StdDevReq+0xcc>

        default:
          USBD_CtlError(pdev, req);
 8007bd2:	6839      	ldr	r1, [r7, #0]
 8007bd4:	6878      	ldr	r0, [r7, #4]
 8007bd6:	f000 fd5e 	bl	8008696 <USBD_CtlError>
          break;
 8007bda:	bf00      	nop
      }
      break;
 8007bdc:	e004      	b.n	8007be8 <USBD_StdDevReq+0xd8>

    default:
      USBD_CtlError(pdev, req);
 8007bde:	6839      	ldr	r1, [r7, #0]
 8007be0:	6878      	ldr	r0, [r7, #4]
 8007be2:	f000 fd58 	bl	8008696 <USBD_CtlError>
      break;
 8007be6:	bf00      	nop
  }

  return ret;
 8007be8:	7bfb      	ldrb	r3, [r7, #15]
}
 8007bea:	4618      	mov	r0, r3
 8007bec:	3710      	adds	r7, #16
 8007bee:	46bd      	mov	sp, r7
 8007bf0:	bd80      	pop	{r7, pc}
 8007bf2:	bf00      	nop

08007bf4 <USBD_StdItfReq>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
USBD_StatusTypeDef USBD_StdItfReq(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8007bf4:	b580      	push	{r7, lr}
 8007bf6:	b084      	sub	sp, #16
 8007bf8:	af00      	add	r7, sp, #0
 8007bfa:	6078      	str	r0, [r7, #4]
 8007bfc:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK;
 8007bfe:	2300      	movs	r3, #0
 8007c00:	73fb      	strb	r3, [r7, #15]
  uint8_t idx;

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8007c02:	683b      	ldr	r3, [r7, #0]
 8007c04:	781b      	ldrb	r3, [r3, #0]
 8007c06:	f003 0360 	and.w	r3, r3, #96	@ 0x60
 8007c0a:	2b40      	cmp	r3, #64	@ 0x40
 8007c0c:	d005      	beq.n	8007c1a <USBD_StdItfReq+0x26>
 8007c0e:	2b40      	cmp	r3, #64	@ 0x40
 8007c10:	d852      	bhi.n	8007cb8 <USBD_StdItfReq+0xc4>
 8007c12:	2b00      	cmp	r3, #0
 8007c14:	d001      	beq.n	8007c1a <USBD_StdItfReq+0x26>
 8007c16:	2b20      	cmp	r3, #32
 8007c18:	d14e      	bne.n	8007cb8 <USBD_StdItfReq+0xc4>
  {
    case USB_REQ_TYPE_CLASS:
    case USB_REQ_TYPE_VENDOR:
    case USB_REQ_TYPE_STANDARD:
      switch (pdev->dev_state)
 8007c1a:	687b      	ldr	r3, [r7, #4]
 8007c1c:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8007c20:	b2db      	uxtb	r3, r3
 8007c22:	3b01      	subs	r3, #1
 8007c24:	2b02      	cmp	r3, #2
 8007c26:	d840      	bhi.n	8007caa <USBD_StdItfReq+0xb6>
      {
        case USBD_STATE_DEFAULT:
        case USBD_STATE_ADDRESSED:
        case USBD_STATE_CONFIGURED:

          if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES)
 8007c28:	683b      	ldr	r3, [r7, #0]
 8007c2a:	889b      	ldrh	r3, [r3, #4]
 8007c2c:	b2db      	uxtb	r3, r3
 8007c2e:	2b01      	cmp	r3, #1
 8007c30:	d836      	bhi.n	8007ca0 <USBD_StdItfReq+0xac>
          {
            /* Get the class index relative to this interface */
            idx = USBD_CoreFindIF(pdev, LOBYTE(req->wIndex));
 8007c32:	683b      	ldr	r3, [r7, #0]
 8007c34:	889b      	ldrh	r3, [r3, #4]
 8007c36:	b2db      	uxtb	r3, r3
 8007c38:	4619      	mov	r1, r3
 8007c3a:	6878      	ldr	r0, [r7, #4]
 8007c3c:	f7ff fedb 	bl	80079f6 <USBD_CoreFindIF>
 8007c40:	4603      	mov	r3, r0
 8007c42:	73bb      	strb	r3, [r7, #14]
            if (((uint8_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 8007c44:	7bbb      	ldrb	r3, [r7, #14]
 8007c46:	2bff      	cmp	r3, #255	@ 0xff
 8007c48:	d01d      	beq.n	8007c86 <USBD_StdItfReq+0x92>
 8007c4a:	7bbb      	ldrb	r3, [r7, #14]
 8007c4c:	2b00      	cmp	r3, #0
 8007c4e:	d11a      	bne.n	8007c86 <USBD_StdItfReq+0x92>
            {
              /* Call the class data out function to manage the request */
              if (pdev->pClass[idx]->Setup != NULL)
 8007c50:	7bba      	ldrb	r2, [r7, #14]
 8007c52:	687b      	ldr	r3, [r7, #4]
 8007c54:	32ae      	adds	r2, #174	@ 0xae
 8007c56:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007c5a:	689b      	ldr	r3, [r3, #8]
 8007c5c:	2b00      	cmp	r3, #0
 8007c5e:	d00f      	beq.n	8007c80 <USBD_StdItfReq+0x8c>
              {
                pdev->classId = idx;
 8007c60:	7bba      	ldrb	r2, [r7, #14]
 8007c62:	687b      	ldr	r3, [r7, #4]
 8007c64:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
                ret = (USBD_StatusTypeDef)(pdev->pClass[idx]->Setup(pdev, req));
 8007c68:	7bba      	ldrb	r2, [r7, #14]
 8007c6a:	687b      	ldr	r3, [r7, #4]
 8007c6c:	32ae      	adds	r2, #174	@ 0xae
 8007c6e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007c72:	689b      	ldr	r3, [r3, #8]
 8007c74:	6839      	ldr	r1, [r7, #0]
 8007c76:	6878      	ldr	r0, [r7, #4]
 8007c78:	4798      	blx	r3
 8007c7a:	4603      	mov	r3, r0
 8007c7c:	73fb      	strb	r3, [r7, #15]
              if (pdev->pClass[idx]->Setup != NULL)
 8007c7e:	e004      	b.n	8007c8a <USBD_StdItfReq+0x96>
              }
              else
              {
                /* should never reach this condition */
                ret = USBD_FAIL;
 8007c80:	2303      	movs	r3, #3
 8007c82:	73fb      	strb	r3, [r7, #15]
              if (pdev->pClass[idx]->Setup != NULL)
 8007c84:	e001      	b.n	8007c8a <USBD_StdItfReq+0x96>
              }
            }
            else
            {
              /* No relative interface found */
              ret = USBD_FAIL;
 8007c86:	2303      	movs	r3, #3
 8007c88:	73fb      	strb	r3, [r7, #15]
            }

            if ((req->wLength == 0U) && (ret == USBD_OK))
 8007c8a:	683b      	ldr	r3, [r7, #0]
 8007c8c:	88db      	ldrh	r3, [r3, #6]
 8007c8e:	2b00      	cmp	r3, #0
 8007c90:	d110      	bne.n	8007cb4 <USBD_StdItfReq+0xc0>
 8007c92:	7bfb      	ldrb	r3, [r7, #15]
 8007c94:	2b00      	cmp	r3, #0
 8007c96:	d10d      	bne.n	8007cb4 <USBD_StdItfReq+0xc0>
            {
              (void)USBD_CtlSendStatus(pdev);
 8007c98:	6878      	ldr	r0, [r7, #4]
 8007c9a:	f000 fdd3 	bl	8008844 <USBD_CtlSendStatus>
          }
          else
          {
            USBD_CtlError(pdev, req);
          }
          break;
 8007c9e:	e009      	b.n	8007cb4 <USBD_StdItfReq+0xc0>
            USBD_CtlError(pdev, req);
 8007ca0:	6839      	ldr	r1, [r7, #0]
 8007ca2:	6878      	ldr	r0, [r7, #4]
 8007ca4:	f000 fcf7 	bl	8008696 <USBD_CtlError>
          break;
 8007ca8:	e004      	b.n	8007cb4 <USBD_StdItfReq+0xc0>

        default:
          USBD_CtlError(pdev, req);
 8007caa:	6839      	ldr	r1, [r7, #0]
 8007cac:	6878      	ldr	r0, [r7, #4]
 8007cae:	f000 fcf2 	bl	8008696 <USBD_CtlError>
          break;
 8007cb2:	e000      	b.n	8007cb6 <USBD_StdItfReq+0xc2>
          break;
 8007cb4:	bf00      	nop
      }
      break;
 8007cb6:	e004      	b.n	8007cc2 <USBD_StdItfReq+0xce>

    default:
      USBD_CtlError(pdev, req);
 8007cb8:	6839      	ldr	r1, [r7, #0]
 8007cba:	6878      	ldr	r0, [r7, #4]
 8007cbc:	f000 fceb 	bl	8008696 <USBD_CtlError>
      break;
 8007cc0:	bf00      	nop
  }

  return ret;
 8007cc2:	7bfb      	ldrb	r3, [r7, #15]
}
 8007cc4:	4618      	mov	r0, r3
 8007cc6:	3710      	adds	r7, #16
 8007cc8:	46bd      	mov	sp, r7
 8007cca:	bd80      	pop	{r7, pc}

08007ccc <USBD_StdEPReq>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
USBD_StatusTypeDef USBD_StdEPReq(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8007ccc:	b580      	push	{r7, lr}
 8007cce:	b084      	sub	sp, #16
 8007cd0:	af00      	add	r7, sp, #0
 8007cd2:	6078      	str	r0, [r7, #4]
 8007cd4:	6039      	str	r1, [r7, #0]
  USBD_EndpointTypeDef *pep;
  uint8_t ep_addr;
  uint8_t idx;
  USBD_StatusTypeDef ret = USBD_OK;
 8007cd6:	2300      	movs	r3, #0
 8007cd8:	73fb      	strb	r3, [r7, #15]

  ep_addr = LOBYTE(req->wIndex);
 8007cda:	683b      	ldr	r3, [r7, #0]
 8007cdc:	889b      	ldrh	r3, [r3, #4]
 8007cde:	73bb      	strb	r3, [r7, #14]

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8007ce0:	683b      	ldr	r3, [r7, #0]
 8007ce2:	781b      	ldrb	r3, [r3, #0]
 8007ce4:	f003 0360 	and.w	r3, r3, #96	@ 0x60
 8007ce8:	2b40      	cmp	r3, #64	@ 0x40
 8007cea:	d007      	beq.n	8007cfc <USBD_StdEPReq+0x30>
 8007cec:	2b40      	cmp	r3, #64	@ 0x40
 8007cee:	f200 817f 	bhi.w	8007ff0 <USBD_StdEPReq+0x324>
 8007cf2:	2b00      	cmp	r3, #0
 8007cf4:	d02a      	beq.n	8007d4c <USBD_StdEPReq+0x80>
 8007cf6:	2b20      	cmp	r3, #32
 8007cf8:	f040 817a 	bne.w	8007ff0 <USBD_StdEPReq+0x324>
  {
    case USB_REQ_TYPE_CLASS:
    case USB_REQ_TYPE_VENDOR:
      /* Get the class index relative to this endpoint */
      idx = USBD_CoreFindEP(pdev, ep_addr);
 8007cfc:	7bbb      	ldrb	r3, [r7, #14]
 8007cfe:	4619      	mov	r1, r3
 8007d00:	6878      	ldr	r0, [r7, #4]
 8007d02:	f7ff fe85 	bl	8007a10 <USBD_CoreFindEP>
 8007d06:	4603      	mov	r3, r0
 8007d08:	737b      	strb	r3, [r7, #13]
      if (((uint8_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 8007d0a:	7b7b      	ldrb	r3, [r7, #13]
 8007d0c:	2bff      	cmp	r3, #255	@ 0xff
 8007d0e:	f000 8174 	beq.w	8007ffa <USBD_StdEPReq+0x32e>
 8007d12:	7b7b      	ldrb	r3, [r7, #13]
 8007d14:	2b00      	cmp	r3, #0
 8007d16:	f040 8170 	bne.w	8007ffa <USBD_StdEPReq+0x32e>
      {
        pdev->classId = idx;
 8007d1a:	7b7a      	ldrb	r2, [r7, #13]
 8007d1c:	687b      	ldr	r3, [r7, #4]
 8007d1e:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
        /* Call the class data out function to manage the request */
        if (pdev->pClass[idx]->Setup != NULL)
 8007d22:	7b7a      	ldrb	r2, [r7, #13]
 8007d24:	687b      	ldr	r3, [r7, #4]
 8007d26:	32ae      	adds	r2, #174	@ 0xae
 8007d28:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007d2c:	689b      	ldr	r3, [r3, #8]
 8007d2e:	2b00      	cmp	r3, #0
 8007d30:	f000 8163 	beq.w	8007ffa <USBD_StdEPReq+0x32e>
        {
          ret = (USBD_StatusTypeDef)pdev->pClass[idx]->Setup(pdev, req);
 8007d34:	7b7a      	ldrb	r2, [r7, #13]
 8007d36:	687b      	ldr	r3, [r7, #4]
 8007d38:	32ae      	adds	r2, #174	@ 0xae
 8007d3a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007d3e:	689b      	ldr	r3, [r3, #8]
 8007d40:	6839      	ldr	r1, [r7, #0]
 8007d42:	6878      	ldr	r0, [r7, #4]
 8007d44:	4798      	blx	r3
 8007d46:	4603      	mov	r3, r0
 8007d48:	73fb      	strb	r3, [r7, #15]
        }
      }
      break;
 8007d4a:	e156      	b.n	8007ffa <USBD_StdEPReq+0x32e>

    case USB_REQ_TYPE_STANDARD:
      switch (req->bRequest)
 8007d4c:	683b      	ldr	r3, [r7, #0]
 8007d4e:	785b      	ldrb	r3, [r3, #1]
 8007d50:	2b03      	cmp	r3, #3
 8007d52:	d008      	beq.n	8007d66 <USBD_StdEPReq+0x9a>
 8007d54:	2b03      	cmp	r3, #3
 8007d56:	f300 8145 	bgt.w	8007fe4 <USBD_StdEPReq+0x318>
 8007d5a:	2b00      	cmp	r3, #0
 8007d5c:	f000 809b 	beq.w	8007e96 <USBD_StdEPReq+0x1ca>
 8007d60:	2b01      	cmp	r3, #1
 8007d62:	d03c      	beq.n	8007dde <USBD_StdEPReq+0x112>
 8007d64:	e13e      	b.n	8007fe4 <USBD_StdEPReq+0x318>
      {
        case USB_REQ_SET_FEATURE:
          switch (pdev->dev_state)
 8007d66:	687b      	ldr	r3, [r7, #4]
 8007d68:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8007d6c:	b2db      	uxtb	r3, r3
 8007d6e:	2b02      	cmp	r3, #2
 8007d70:	d002      	beq.n	8007d78 <USBD_StdEPReq+0xac>
 8007d72:	2b03      	cmp	r3, #3
 8007d74:	d016      	beq.n	8007da4 <USBD_StdEPReq+0xd8>
 8007d76:	e02c      	b.n	8007dd2 <USBD_StdEPReq+0x106>
          {
            case USBD_STATE_ADDRESSED:
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 8007d78:	7bbb      	ldrb	r3, [r7, #14]
 8007d7a:	2b00      	cmp	r3, #0
 8007d7c:	d00d      	beq.n	8007d9a <USBD_StdEPReq+0xce>
 8007d7e:	7bbb      	ldrb	r3, [r7, #14]
 8007d80:	2b80      	cmp	r3, #128	@ 0x80
 8007d82:	d00a      	beq.n	8007d9a <USBD_StdEPReq+0xce>
              {
                (void)USBD_LL_StallEP(pdev, ep_addr);
 8007d84:	7bbb      	ldrb	r3, [r7, #14]
 8007d86:	4619      	mov	r1, r3
 8007d88:	6878      	ldr	r0, [r7, #4]
 8007d8a:	f020 f92f 	bl	8027fec <USBD_LL_StallEP>
                (void)USBD_LL_StallEP(pdev, 0x80U);
 8007d8e:	2180      	movs	r1, #128	@ 0x80
 8007d90:	6878      	ldr	r0, [r7, #4]
 8007d92:	f020 f92b 	bl	8027fec <USBD_LL_StallEP>
 8007d96:	bf00      	nop
              }
              else
              {
                USBD_CtlError(pdev, req);
              }
              break;
 8007d98:	e020      	b.n	8007ddc <USBD_StdEPReq+0x110>
                USBD_CtlError(pdev, req);
 8007d9a:	6839      	ldr	r1, [r7, #0]
 8007d9c:	6878      	ldr	r0, [r7, #4]
 8007d9e:	f000 fc7a 	bl	8008696 <USBD_CtlError>
              break;
 8007da2:	e01b      	b.n	8007ddc <USBD_StdEPReq+0x110>

            case USBD_STATE_CONFIGURED:
              if (req->wValue == USB_FEATURE_EP_HALT)
 8007da4:	683b      	ldr	r3, [r7, #0]
 8007da6:	885b      	ldrh	r3, [r3, #2]
 8007da8:	2b00      	cmp	r3, #0
 8007daa:	d10e      	bne.n	8007dca <USBD_StdEPReq+0xfe>
              {
                if ((ep_addr != 0x00U) && (ep_addr != 0x80U) && (req->wLength == 0x00U))
 8007dac:	7bbb      	ldrb	r3, [r7, #14]
 8007dae:	2b00      	cmp	r3, #0
 8007db0:	d00b      	beq.n	8007dca <USBD_StdEPReq+0xfe>
 8007db2:	7bbb      	ldrb	r3, [r7, #14]
 8007db4:	2b80      	cmp	r3, #128	@ 0x80
 8007db6:	d008      	beq.n	8007dca <USBD_StdEPReq+0xfe>
 8007db8:	683b      	ldr	r3, [r7, #0]
 8007dba:	88db      	ldrh	r3, [r3, #6]
 8007dbc:	2b00      	cmp	r3, #0
 8007dbe:	d104      	bne.n	8007dca <USBD_StdEPReq+0xfe>
                {
                  (void)USBD_LL_StallEP(pdev, ep_addr);
 8007dc0:	7bbb      	ldrb	r3, [r7, #14]
 8007dc2:	4619      	mov	r1, r3
 8007dc4:	6878      	ldr	r0, [r7, #4]
 8007dc6:	f020 f911 	bl	8027fec <USBD_LL_StallEP>
                }
              }
              (void)USBD_CtlSendStatus(pdev);
 8007dca:	6878      	ldr	r0, [r7, #4]
 8007dcc:	f000 fd3a 	bl	8008844 <USBD_CtlSendStatus>

              break;
 8007dd0:	e004      	b.n	8007ddc <USBD_StdEPReq+0x110>

            default:
              USBD_CtlError(pdev, req);
 8007dd2:	6839      	ldr	r1, [r7, #0]
 8007dd4:	6878      	ldr	r0, [r7, #4]
 8007dd6:	f000 fc5e 	bl	8008696 <USBD_CtlError>
              break;
 8007dda:	bf00      	nop
          }
          break;
 8007ddc:	e107      	b.n	8007fee <USBD_StdEPReq+0x322>

        case USB_REQ_CLEAR_FEATURE:

          switch (pdev->dev_state)
 8007dde:	687b      	ldr	r3, [r7, #4]
 8007de0:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8007de4:	b2db      	uxtb	r3, r3
 8007de6:	2b02      	cmp	r3, #2
 8007de8:	d002      	beq.n	8007df0 <USBD_StdEPReq+0x124>
 8007dea:	2b03      	cmp	r3, #3
 8007dec:	d016      	beq.n	8007e1c <USBD_StdEPReq+0x150>
 8007dee:	e04b      	b.n	8007e88 <USBD_StdEPReq+0x1bc>
          {
            case USBD_STATE_ADDRESSED:
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 8007df0:	7bbb      	ldrb	r3, [r7, #14]
 8007df2:	2b00      	cmp	r3, #0
 8007df4:	d00d      	beq.n	8007e12 <USBD_StdEPReq+0x146>
 8007df6:	7bbb      	ldrb	r3, [r7, #14]
 8007df8:	2b80      	cmp	r3, #128	@ 0x80
 8007dfa:	d00a      	beq.n	8007e12 <USBD_StdEPReq+0x146>
              {
                (void)USBD_LL_StallEP(pdev, ep_addr);
 8007dfc:	7bbb      	ldrb	r3, [r7, #14]
 8007dfe:	4619      	mov	r1, r3
 8007e00:	6878      	ldr	r0, [r7, #4]
 8007e02:	f020 f8f3 	bl	8027fec <USBD_LL_StallEP>
                (void)USBD_LL_StallEP(pdev, 0x80U);
 8007e06:	2180      	movs	r1, #128	@ 0x80
 8007e08:	6878      	ldr	r0, [r7, #4]
 8007e0a:	f020 f8ef 	bl	8027fec <USBD_LL_StallEP>
 8007e0e:	bf00      	nop
              }
              else
              {
                USBD_CtlError(pdev, req);
              }
              break;
 8007e10:	e040      	b.n	8007e94 <USBD_StdEPReq+0x1c8>
                USBD_CtlError(pdev, req);
 8007e12:	6839      	ldr	r1, [r7, #0]
 8007e14:	6878      	ldr	r0, [r7, #4]
 8007e16:	f000 fc3e 	bl	8008696 <USBD_CtlError>
              break;
 8007e1a:	e03b      	b.n	8007e94 <USBD_StdEPReq+0x1c8>

            case USBD_STATE_CONFIGURED:
              if (req->wValue == USB_FEATURE_EP_HALT)
 8007e1c:	683b      	ldr	r3, [r7, #0]
 8007e1e:	885b      	ldrh	r3, [r3, #2]
 8007e20:	2b00      	cmp	r3, #0
 8007e22:	d136      	bne.n	8007e92 <USBD_StdEPReq+0x1c6>
              {
                if ((ep_addr & 0x7FU) != 0x00U)
 8007e24:	7bbb      	ldrb	r3, [r7, #14]
 8007e26:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8007e2a:	2b00      	cmp	r3, #0
 8007e2c:	d004      	beq.n	8007e38 <USBD_StdEPReq+0x16c>
                {
                  (void)USBD_LL_ClearStallEP(pdev, ep_addr);
 8007e2e:	7bbb      	ldrb	r3, [r7, #14]
 8007e30:	4619      	mov	r1, r3
 8007e32:	6878      	ldr	r0, [r7, #4]
 8007e34:	f020 f8f9 	bl	802802a <USBD_LL_ClearStallEP>
                }
                (void)USBD_CtlSendStatus(pdev);
 8007e38:	6878      	ldr	r0, [r7, #4]
 8007e3a:	f000 fd03 	bl	8008844 <USBD_CtlSendStatus>

                /* Get the class index relative to this interface */
                idx = USBD_CoreFindEP(pdev, ep_addr);
 8007e3e:	7bbb      	ldrb	r3, [r7, #14]
 8007e40:	4619      	mov	r1, r3
 8007e42:	6878      	ldr	r0, [r7, #4]
 8007e44:	f7ff fde4 	bl	8007a10 <USBD_CoreFindEP>
 8007e48:	4603      	mov	r3, r0
 8007e4a:	737b      	strb	r3, [r7, #13]
                if (((uint8_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 8007e4c:	7b7b      	ldrb	r3, [r7, #13]
 8007e4e:	2bff      	cmp	r3, #255	@ 0xff
 8007e50:	d01f      	beq.n	8007e92 <USBD_StdEPReq+0x1c6>
 8007e52:	7b7b      	ldrb	r3, [r7, #13]
 8007e54:	2b00      	cmp	r3, #0
 8007e56:	d11c      	bne.n	8007e92 <USBD_StdEPReq+0x1c6>
                {
                  pdev->classId = idx;
 8007e58:	7b7a      	ldrb	r2, [r7, #13]
 8007e5a:	687b      	ldr	r3, [r7, #4]
 8007e5c:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
                  /* Call the class data out function to manage the request */
                  if (pdev->pClass[idx]->Setup != NULL)
 8007e60:	7b7a      	ldrb	r2, [r7, #13]
 8007e62:	687b      	ldr	r3, [r7, #4]
 8007e64:	32ae      	adds	r2, #174	@ 0xae
 8007e66:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007e6a:	689b      	ldr	r3, [r3, #8]
 8007e6c:	2b00      	cmp	r3, #0
 8007e6e:	d010      	beq.n	8007e92 <USBD_StdEPReq+0x1c6>
                  {
                    ret = (USBD_StatusTypeDef)(pdev->pClass[idx]->Setup(pdev, req));
 8007e70:	7b7a      	ldrb	r2, [r7, #13]
 8007e72:	687b      	ldr	r3, [r7, #4]
 8007e74:	32ae      	adds	r2, #174	@ 0xae
 8007e76:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007e7a:	689b      	ldr	r3, [r3, #8]
 8007e7c:	6839      	ldr	r1, [r7, #0]
 8007e7e:	6878      	ldr	r0, [r7, #4]
 8007e80:	4798      	blx	r3
 8007e82:	4603      	mov	r3, r0
 8007e84:	73fb      	strb	r3, [r7, #15]
                  }
                }
              }
              break;
 8007e86:	e004      	b.n	8007e92 <USBD_StdEPReq+0x1c6>

            default:
              USBD_CtlError(pdev, req);
 8007e88:	6839      	ldr	r1, [r7, #0]
 8007e8a:	6878      	ldr	r0, [r7, #4]
 8007e8c:	f000 fc03 	bl	8008696 <USBD_CtlError>
              break;
 8007e90:	e000      	b.n	8007e94 <USBD_StdEPReq+0x1c8>
              break;
 8007e92:	bf00      	nop
          }
          break;
 8007e94:	e0ab      	b.n	8007fee <USBD_StdEPReq+0x322>

        case USB_REQ_GET_STATUS:
          switch (pdev->dev_state)
 8007e96:	687b      	ldr	r3, [r7, #4]
 8007e98:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8007e9c:	b2db      	uxtb	r3, r3
 8007e9e:	2b02      	cmp	r3, #2
 8007ea0:	d002      	beq.n	8007ea8 <USBD_StdEPReq+0x1dc>
 8007ea2:	2b03      	cmp	r3, #3
 8007ea4:	d032      	beq.n	8007f0c <USBD_StdEPReq+0x240>
 8007ea6:	e097      	b.n	8007fd8 <USBD_StdEPReq+0x30c>
          {
            case USBD_STATE_ADDRESSED:
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 8007ea8:	7bbb      	ldrb	r3, [r7, #14]
 8007eaa:	2b00      	cmp	r3, #0
 8007eac:	d007      	beq.n	8007ebe <USBD_StdEPReq+0x1f2>
 8007eae:	7bbb      	ldrb	r3, [r7, #14]
 8007eb0:	2b80      	cmp	r3, #128	@ 0x80
 8007eb2:	d004      	beq.n	8007ebe <USBD_StdEPReq+0x1f2>
              {
                USBD_CtlError(pdev, req);
 8007eb4:	6839      	ldr	r1, [r7, #0]
 8007eb6:	6878      	ldr	r0, [r7, #4]
 8007eb8:	f000 fbed 	bl	8008696 <USBD_CtlError>
                break;
 8007ebc:	e091      	b.n	8007fe2 <USBD_StdEPReq+0x316>
              }
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 8007ebe:	f997 300e 	ldrsb.w	r3, [r7, #14]
 8007ec2:	2b00      	cmp	r3, #0
 8007ec4:	da0b      	bge.n	8007ede <USBD_StdEPReq+0x212>
 8007ec6:	7bbb      	ldrb	r3, [r7, #14]
 8007ec8:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 8007ecc:	4613      	mov	r3, r2
 8007ece:	009b      	lsls	r3, r3, #2
 8007ed0:	4413      	add	r3, r2
 8007ed2:	009b      	lsls	r3, r3, #2
 8007ed4:	3310      	adds	r3, #16
 8007ed6:	687a      	ldr	r2, [r7, #4]
 8007ed8:	4413      	add	r3, r2
 8007eda:	3304      	adds	r3, #4
 8007edc:	e00b      	b.n	8007ef6 <USBD_StdEPReq+0x22a>
                    &pdev->ep_out[ep_addr & 0x7FU];
 8007ede:	7bbb      	ldrb	r3, [r7, #14]
 8007ee0:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 8007ee4:	4613      	mov	r3, r2
 8007ee6:	009b      	lsls	r3, r3, #2
 8007ee8:	4413      	add	r3, r2
 8007eea:	009b      	lsls	r3, r3, #2
 8007eec:	f503 73a8 	add.w	r3, r3, #336	@ 0x150
 8007ef0:	687a      	ldr	r2, [r7, #4]
 8007ef2:	4413      	add	r3, r2
 8007ef4:	3304      	adds	r3, #4
 8007ef6:	60bb      	str	r3, [r7, #8]

              pep->status = 0x0000U;
 8007ef8:	68bb      	ldr	r3, [r7, #8]
 8007efa:	2200      	movs	r2, #0
 8007efc:	601a      	str	r2, [r3, #0]

              (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
 8007efe:	68bb      	ldr	r3, [r7, #8]
 8007f00:	2202      	movs	r2, #2
 8007f02:	4619      	mov	r1, r3
 8007f04:	6878      	ldr	r0, [r7, #4]
 8007f06:	f000 fc43 	bl	8008790 <USBD_CtlSendData>
              break;
 8007f0a:	e06a      	b.n	8007fe2 <USBD_StdEPReq+0x316>

            case USBD_STATE_CONFIGURED:
              if ((ep_addr & 0x80U) == 0x80U)
 8007f0c:	f997 300e 	ldrsb.w	r3, [r7, #14]
 8007f10:	2b00      	cmp	r3, #0
 8007f12:	da11      	bge.n	8007f38 <USBD_StdEPReq+0x26c>
              {
                if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 8007f14:	7bbb      	ldrb	r3, [r7, #14]
 8007f16:	f003 020f 	and.w	r2, r3, #15
 8007f1a:	6879      	ldr	r1, [r7, #4]
 8007f1c:	4613      	mov	r3, r2
 8007f1e:	009b      	lsls	r3, r3, #2
 8007f20:	4413      	add	r3, r2
 8007f22:	009b      	lsls	r3, r3, #2
 8007f24:	440b      	add	r3, r1
 8007f26:	3324      	adds	r3, #36	@ 0x24
 8007f28:	881b      	ldrh	r3, [r3, #0]
 8007f2a:	2b00      	cmp	r3, #0
 8007f2c:	d117      	bne.n	8007f5e <USBD_StdEPReq+0x292>
                {
                  USBD_CtlError(pdev, req);
 8007f2e:	6839      	ldr	r1, [r7, #0]
 8007f30:	6878      	ldr	r0, [r7, #4]
 8007f32:	f000 fbb0 	bl	8008696 <USBD_CtlError>
                  break;
 8007f36:	e054      	b.n	8007fe2 <USBD_StdEPReq+0x316>
                }
              }
              else
              {
                if (pdev->ep_out[ep_addr & 0xFU].is_used == 0U)
 8007f38:	7bbb      	ldrb	r3, [r7, #14]
 8007f3a:	f003 020f 	and.w	r2, r3, #15
 8007f3e:	6879      	ldr	r1, [r7, #4]
 8007f40:	4613      	mov	r3, r2
 8007f42:	009b      	lsls	r3, r3, #2
 8007f44:	4413      	add	r3, r2
 8007f46:	009b      	lsls	r3, r3, #2
 8007f48:	440b      	add	r3, r1
 8007f4a:	f503 73b2 	add.w	r3, r3, #356	@ 0x164
 8007f4e:	881b      	ldrh	r3, [r3, #0]
 8007f50:	2b00      	cmp	r3, #0
 8007f52:	d104      	bne.n	8007f5e <USBD_StdEPReq+0x292>
                {
                  USBD_CtlError(pdev, req);
 8007f54:	6839      	ldr	r1, [r7, #0]
 8007f56:	6878      	ldr	r0, [r7, #4]
 8007f58:	f000 fb9d 	bl	8008696 <USBD_CtlError>
                  break;
 8007f5c:	e041      	b.n	8007fe2 <USBD_StdEPReq+0x316>
                }
              }

              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 8007f5e:	f997 300e 	ldrsb.w	r3, [r7, #14]
 8007f62:	2b00      	cmp	r3, #0
 8007f64:	da0b      	bge.n	8007f7e <USBD_StdEPReq+0x2b2>
 8007f66:	7bbb      	ldrb	r3, [r7, #14]
 8007f68:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 8007f6c:	4613      	mov	r3, r2
 8007f6e:	009b      	lsls	r3, r3, #2
 8007f70:	4413      	add	r3, r2
 8007f72:	009b      	lsls	r3, r3, #2
 8007f74:	3310      	adds	r3, #16
 8007f76:	687a      	ldr	r2, [r7, #4]
 8007f78:	4413      	add	r3, r2
 8007f7a:	3304      	adds	r3, #4
 8007f7c:	e00b      	b.n	8007f96 <USBD_StdEPReq+0x2ca>
                    &pdev->ep_out[ep_addr & 0x7FU];
 8007f7e:	7bbb      	ldrb	r3, [r7, #14]
 8007f80:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 8007f84:	4613      	mov	r3, r2
 8007f86:	009b      	lsls	r3, r3, #2
 8007f88:	4413      	add	r3, r2
 8007f8a:	009b      	lsls	r3, r3, #2
 8007f8c:	f503 73a8 	add.w	r3, r3, #336	@ 0x150
 8007f90:	687a      	ldr	r2, [r7, #4]
 8007f92:	4413      	add	r3, r2
 8007f94:	3304      	adds	r3, #4
 8007f96:	60bb      	str	r3, [r7, #8]

              if ((ep_addr == 0x00U) || (ep_addr == 0x80U))
 8007f98:	7bbb      	ldrb	r3, [r7, #14]
 8007f9a:	2b00      	cmp	r3, #0
 8007f9c:	d002      	beq.n	8007fa4 <USBD_StdEPReq+0x2d8>
 8007f9e:	7bbb      	ldrb	r3, [r7, #14]
 8007fa0:	2b80      	cmp	r3, #128	@ 0x80
 8007fa2:	d103      	bne.n	8007fac <USBD_StdEPReq+0x2e0>
              {
                pep->status = 0x0000U;
 8007fa4:	68bb      	ldr	r3, [r7, #8]
 8007fa6:	2200      	movs	r2, #0
 8007fa8:	601a      	str	r2, [r3, #0]
 8007faa:	e00e      	b.n	8007fca <USBD_StdEPReq+0x2fe>
              }
              else if (USBD_LL_IsStallEP(pdev, ep_addr) != 0U)
 8007fac:	7bbb      	ldrb	r3, [r7, #14]
 8007fae:	4619      	mov	r1, r3
 8007fb0:	6878      	ldr	r0, [r7, #4]
 8007fb2:	f020 f859 	bl	8028068 <USBD_LL_IsStallEP>
 8007fb6:	4603      	mov	r3, r0
 8007fb8:	2b00      	cmp	r3, #0
 8007fba:	d003      	beq.n	8007fc4 <USBD_StdEPReq+0x2f8>
              {
                pep->status = 0x0001U;
 8007fbc:	68bb      	ldr	r3, [r7, #8]
 8007fbe:	2201      	movs	r2, #1
 8007fc0:	601a      	str	r2, [r3, #0]
 8007fc2:	e002      	b.n	8007fca <USBD_StdEPReq+0x2fe>
              }
              else
              {
                pep->status = 0x0000U;
 8007fc4:	68bb      	ldr	r3, [r7, #8]
 8007fc6:	2200      	movs	r2, #0
 8007fc8:	601a      	str	r2, [r3, #0]
              }

              (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
 8007fca:	68bb      	ldr	r3, [r7, #8]
 8007fcc:	2202      	movs	r2, #2
 8007fce:	4619      	mov	r1, r3
 8007fd0:	6878      	ldr	r0, [r7, #4]
 8007fd2:	f000 fbdd 	bl	8008790 <USBD_CtlSendData>
              break;
 8007fd6:	e004      	b.n	8007fe2 <USBD_StdEPReq+0x316>

            default:
              USBD_CtlError(pdev, req);
 8007fd8:	6839      	ldr	r1, [r7, #0]
 8007fda:	6878      	ldr	r0, [r7, #4]
 8007fdc:	f000 fb5b 	bl	8008696 <USBD_CtlError>
              break;
 8007fe0:	bf00      	nop
          }
          break;
 8007fe2:	e004      	b.n	8007fee <USBD_StdEPReq+0x322>

        default:
          USBD_CtlError(pdev, req);
 8007fe4:	6839      	ldr	r1, [r7, #0]
 8007fe6:	6878      	ldr	r0, [r7, #4]
 8007fe8:	f000 fb55 	bl	8008696 <USBD_CtlError>
          break;
 8007fec:	bf00      	nop
      }
      break;
 8007fee:	e005      	b.n	8007ffc <USBD_StdEPReq+0x330>

    default:
      USBD_CtlError(pdev, req);
 8007ff0:	6839      	ldr	r1, [r7, #0]
 8007ff2:	6878      	ldr	r0, [r7, #4]
 8007ff4:	f000 fb4f 	bl	8008696 <USBD_CtlError>
      break;
 8007ff8:	e000      	b.n	8007ffc <USBD_StdEPReq+0x330>
      break;
 8007ffa:	bf00      	nop
  }

  return ret;
 8007ffc:	7bfb      	ldrb	r3, [r7, #15]
}
 8007ffe:	4618      	mov	r0, r3
 8008000:	3710      	adds	r7, #16
 8008002:	46bd      	mov	sp, r7
 8008004:	bd80      	pop	{r7, pc}
	...

08008008 <USBD_GetDescriptor>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_GetDescriptor(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8008008:	b580      	push	{r7, lr}
 800800a:	b084      	sub	sp, #16
 800800c:	af00      	add	r7, sp, #0
 800800e:	6078      	str	r0, [r7, #4]
 8008010:	6039      	str	r1, [r7, #0]
  uint16_t len = 0U;
 8008012:	2300      	movs	r3, #0
 8008014:	813b      	strh	r3, [r7, #8]
  uint8_t *pbuf = NULL;
 8008016:	2300      	movs	r3, #0
 8008018:	60fb      	str	r3, [r7, #12]
  uint8_t err = 0U;
 800801a:	2300      	movs	r3, #0
 800801c:	72fb      	strb	r3, [r7, #11]

  switch (req->wValue >> 8)
 800801e:	683b      	ldr	r3, [r7, #0]
 8008020:	885b      	ldrh	r3, [r3, #2]
 8008022:	0a1b      	lsrs	r3, r3, #8
 8008024:	b29b      	uxth	r3, r3
 8008026:	3b01      	subs	r3, #1
 8008028:	2b06      	cmp	r3, #6
 800802a:	f200 8128 	bhi.w	800827e <USBD_GetDescriptor+0x276>
 800802e:	a201      	add	r2, pc, #4	@ (adr r2, 8008034 <USBD_GetDescriptor+0x2c>)
 8008030:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8008034:	08008051 	.word	0x08008051
 8008038:	08008069 	.word	0x08008069
 800803c:	080080a9 	.word	0x080080a9
 8008040:	0800827f 	.word	0x0800827f
 8008044:	0800827f 	.word	0x0800827f
 8008048:	0800821f 	.word	0x0800821f
 800804c:	0800824b 	.word	0x0800824b
        err++;
      }
      break;
#endif /* (USBD_LPM_ENABLED == 1U) || (USBD_CLASS_BOS_ENABLED == 1U) */
    case USB_DESC_TYPE_DEVICE:
      pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 8008050:	687b      	ldr	r3, [r7, #4]
 8008052:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 8008056:	681b      	ldr	r3, [r3, #0]
 8008058:	687a      	ldr	r2, [r7, #4]
 800805a:	7c12      	ldrb	r2, [r2, #16]
 800805c:	f107 0108 	add.w	r1, r7, #8
 8008060:	4610      	mov	r0, r2
 8008062:	4798      	blx	r3
 8008064:	60f8      	str	r0, [r7, #12]
      break;
 8008066:	e112      	b.n	800828e <USBD_GetDescriptor+0x286>

    case USB_DESC_TYPE_CONFIGURATION:
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 8008068:	687b      	ldr	r3, [r7, #4]
 800806a:	7c1b      	ldrb	r3, [r3, #16]
 800806c:	2b00      	cmp	r3, #0
 800806e:	d10d      	bne.n	800808c <USBD_GetDescriptor+0x84>
          pbuf = (uint8_t *)USBD_CMPSIT.GetHSConfigDescriptor(&len);
        }
        else
#endif /* USE_USBD_COMPOSITE */
        {
          pbuf = (uint8_t *)pdev->pClass[0]->GetHSConfigDescriptor(&len);
 8008070:	687b      	ldr	r3, [r7, #4]
 8008072:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 8008076:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8008078:	f107 0208 	add.w	r2, r7, #8
 800807c:	4610      	mov	r0, r2
 800807e:	4798      	blx	r3
 8008080:	60f8      	str	r0, [r7, #12]
        }
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 8008082:	68fb      	ldr	r3, [r7, #12]
 8008084:	3301      	adds	r3, #1
 8008086:	2202      	movs	r2, #2
 8008088:	701a      	strb	r2, [r3, #0]
        {
          pbuf = (uint8_t *)pdev->pClass[0]->GetFSConfigDescriptor(&len);
        }
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
      }
      break;
 800808a:	e100      	b.n	800828e <USBD_GetDescriptor+0x286>
          pbuf = (uint8_t *)pdev->pClass[0]->GetFSConfigDescriptor(&len);
 800808c:	687b      	ldr	r3, [r7, #4]
 800808e:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 8008092:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8008094:	f107 0208 	add.w	r2, r7, #8
 8008098:	4610      	mov	r0, r2
 800809a:	4798      	blx	r3
 800809c:	60f8      	str	r0, [r7, #12]
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 800809e:	68fb      	ldr	r3, [r7, #12]
 80080a0:	3301      	adds	r3, #1
 80080a2:	2202      	movs	r2, #2
 80080a4:	701a      	strb	r2, [r3, #0]
      break;
 80080a6:	e0f2      	b.n	800828e <USBD_GetDescriptor+0x286>

    case USB_DESC_TYPE_STRING:
      switch ((uint8_t)(req->wValue))
 80080a8:	683b      	ldr	r3, [r7, #0]
 80080aa:	885b      	ldrh	r3, [r3, #2]
 80080ac:	b2db      	uxtb	r3, r3
 80080ae:	2b05      	cmp	r3, #5
 80080b0:	f200 80ac 	bhi.w	800820c <USBD_GetDescriptor+0x204>
 80080b4:	a201      	add	r2, pc, #4	@ (adr r2, 80080bc <USBD_GetDescriptor+0xb4>)
 80080b6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80080ba:	bf00      	nop
 80080bc:	080080d5 	.word	0x080080d5
 80080c0:	08008109 	.word	0x08008109
 80080c4:	0800813d 	.word	0x0800813d
 80080c8:	08008171 	.word	0x08008171
 80080cc:	080081a5 	.word	0x080081a5
 80080d0:	080081d9 	.word	0x080081d9
      {
        case USBD_IDX_LANGID_STR:
          if (pdev->pDesc->GetLangIDStrDescriptor != NULL)
 80080d4:	687b      	ldr	r3, [r7, #4]
 80080d6:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 80080da:	685b      	ldr	r3, [r3, #4]
 80080dc:	2b00      	cmp	r3, #0
 80080de:	d00b      	beq.n	80080f8 <USBD_GetDescriptor+0xf0>
          {
            pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);
 80080e0:	687b      	ldr	r3, [r7, #4]
 80080e2:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 80080e6:	685b      	ldr	r3, [r3, #4]
 80080e8:	687a      	ldr	r2, [r7, #4]
 80080ea:	7c12      	ldrb	r2, [r2, #16]
 80080ec:	f107 0108 	add.w	r1, r7, #8
 80080f0:	4610      	mov	r0, r2
 80080f2:	4798      	blx	r3
 80080f4:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 80080f6:	e091      	b.n	800821c <USBD_GetDescriptor+0x214>
            USBD_CtlError(pdev, req);
 80080f8:	6839      	ldr	r1, [r7, #0]
 80080fa:	6878      	ldr	r0, [r7, #4]
 80080fc:	f000 facb 	bl	8008696 <USBD_CtlError>
            err++;
 8008100:	7afb      	ldrb	r3, [r7, #11]
 8008102:	3301      	adds	r3, #1
 8008104:	72fb      	strb	r3, [r7, #11]
          break;
 8008106:	e089      	b.n	800821c <USBD_GetDescriptor+0x214>

        case USBD_IDX_MFC_STR:
          if (pdev->pDesc->GetManufacturerStrDescriptor != NULL)
 8008108:	687b      	ldr	r3, [r7, #4]
 800810a:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 800810e:	689b      	ldr	r3, [r3, #8]
 8008110:	2b00      	cmp	r3, #0
 8008112:	d00b      	beq.n	800812c <USBD_GetDescriptor+0x124>
          {
            pbuf = pdev->pDesc->GetManufacturerStrDescriptor(pdev->dev_speed, &len);
 8008114:	687b      	ldr	r3, [r7, #4]
 8008116:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 800811a:	689b      	ldr	r3, [r3, #8]
 800811c:	687a      	ldr	r2, [r7, #4]
 800811e:	7c12      	ldrb	r2, [r2, #16]
 8008120:	f107 0108 	add.w	r1, r7, #8
 8008124:	4610      	mov	r0, r2
 8008126:	4798      	blx	r3
 8008128:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 800812a:	e077      	b.n	800821c <USBD_GetDescriptor+0x214>
            USBD_CtlError(pdev, req);
 800812c:	6839      	ldr	r1, [r7, #0]
 800812e:	6878      	ldr	r0, [r7, #4]
 8008130:	f000 fab1 	bl	8008696 <USBD_CtlError>
            err++;
 8008134:	7afb      	ldrb	r3, [r7, #11]
 8008136:	3301      	adds	r3, #1
 8008138:	72fb      	strb	r3, [r7, #11]
          break;
 800813a:	e06f      	b.n	800821c <USBD_GetDescriptor+0x214>

        case USBD_IDX_PRODUCT_STR:
          if (pdev->pDesc->GetProductStrDescriptor != NULL)
 800813c:	687b      	ldr	r3, [r7, #4]
 800813e:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 8008142:	68db      	ldr	r3, [r3, #12]
 8008144:	2b00      	cmp	r3, #0
 8008146:	d00b      	beq.n	8008160 <USBD_GetDescriptor+0x158>
          {
            pbuf = pdev->pDesc->GetProductStrDescriptor(pdev->dev_speed, &len);
 8008148:	687b      	ldr	r3, [r7, #4]
 800814a:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 800814e:	68db      	ldr	r3, [r3, #12]
 8008150:	687a      	ldr	r2, [r7, #4]
 8008152:	7c12      	ldrb	r2, [r2, #16]
 8008154:	f107 0108 	add.w	r1, r7, #8
 8008158:	4610      	mov	r0, r2
 800815a:	4798      	blx	r3
 800815c:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 800815e:	e05d      	b.n	800821c <USBD_GetDescriptor+0x214>
            USBD_CtlError(pdev, req);
 8008160:	6839      	ldr	r1, [r7, #0]
 8008162:	6878      	ldr	r0, [r7, #4]
 8008164:	f000 fa97 	bl	8008696 <USBD_CtlError>
            err++;
 8008168:	7afb      	ldrb	r3, [r7, #11]
 800816a:	3301      	adds	r3, #1
 800816c:	72fb      	strb	r3, [r7, #11]
          break;
 800816e:	e055      	b.n	800821c <USBD_GetDescriptor+0x214>

        case USBD_IDX_SERIAL_STR:
          if (pdev->pDesc->GetSerialStrDescriptor != NULL)
 8008170:	687b      	ldr	r3, [r7, #4]
 8008172:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 8008176:	691b      	ldr	r3, [r3, #16]
 8008178:	2b00      	cmp	r3, #0
 800817a:	d00b      	beq.n	8008194 <USBD_GetDescriptor+0x18c>
          {
            pbuf = pdev->pDesc->GetSerialStrDescriptor(pdev->dev_speed, &len);
 800817c:	687b      	ldr	r3, [r7, #4]
 800817e:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 8008182:	691b      	ldr	r3, [r3, #16]
 8008184:	687a      	ldr	r2, [r7, #4]
 8008186:	7c12      	ldrb	r2, [r2, #16]
 8008188:	f107 0108 	add.w	r1, r7, #8
 800818c:	4610      	mov	r0, r2
 800818e:	4798      	blx	r3
 8008190:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 8008192:	e043      	b.n	800821c <USBD_GetDescriptor+0x214>
            USBD_CtlError(pdev, req);
 8008194:	6839      	ldr	r1, [r7, #0]
 8008196:	6878      	ldr	r0, [r7, #4]
 8008198:	f000 fa7d 	bl	8008696 <USBD_CtlError>
            err++;
 800819c:	7afb      	ldrb	r3, [r7, #11]
 800819e:	3301      	adds	r3, #1
 80081a0:	72fb      	strb	r3, [r7, #11]
          break;
 80081a2:	e03b      	b.n	800821c <USBD_GetDescriptor+0x214>

        case USBD_IDX_CONFIG_STR:
          if (pdev->pDesc->GetConfigurationStrDescriptor != NULL)
 80081a4:	687b      	ldr	r3, [r7, #4]
 80081a6:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 80081aa:	695b      	ldr	r3, [r3, #20]
 80081ac:	2b00      	cmp	r3, #0
 80081ae:	d00b      	beq.n	80081c8 <USBD_GetDescriptor+0x1c0>
          {
            pbuf = pdev->pDesc->GetConfigurationStrDescriptor(pdev->dev_speed, &len);
 80081b0:	687b      	ldr	r3, [r7, #4]
 80081b2:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 80081b6:	695b      	ldr	r3, [r3, #20]
 80081b8:	687a      	ldr	r2, [r7, #4]
 80081ba:	7c12      	ldrb	r2, [r2, #16]
 80081bc:	f107 0108 	add.w	r1, r7, #8
 80081c0:	4610      	mov	r0, r2
 80081c2:	4798      	blx	r3
 80081c4:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 80081c6:	e029      	b.n	800821c <USBD_GetDescriptor+0x214>
            USBD_CtlError(pdev, req);
 80081c8:	6839      	ldr	r1, [r7, #0]
 80081ca:	6878      	ldr	r0, [r7, #4]
 80081cc:	f000 fa63 	bl	8008696 <USBD_CtlError>
            err++;
 80081d0:	7afb      	ldrb	r3, [r7, #11]
 80081d2:	3301      	adds	r3, #1
 80081d4:	72fb      	strb	r3, [r7, #11]
          break;
 80081d6:	e021      	b.n	800821c <USBD_GetDescriptor+0x214>

        case USBD_IDX_INTERFACE_STR:
          if (pdev->pDesc->GetInterfaceStrDescriptor != NULL)
 80081d8:	687b      	ldr	r3, [r7, #4]
 80081da:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 80081de:	699b      	ldr	r3, [r3, #24]
 80081e0:	2b00      	cmp	r3, #0
 80081e2:	d00b      	beq.n	80081fc <USBD_GetDescriptor+0x1f4>
          {
            pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
 80081e4:	687b      	ldr	r3, [r7, #4]
 80081e6:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 80081ea:	699b      	ldr	r3, [r3, #24]
 80081ec:	687a      	ldr	r2, [r7, #4]
 80081ee:	7c12      	ldrb	r2, [r2, #16]
 80081f0:	f107 0108 	add.w	r1, r7, #8
 80081f4:	4610      	mov	r0, r2
 80081f6:	4798      	blx	r3
 80081f8:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 80081fa:	e00f      	b.n	800821c <USBD_GetDescriptor+0x214>
            USBD_CtlError(pdev, req);
 80081fc:	6839      	ldr	r1, [r7, #0]
 80081fe:	6878      	ldr	r0, [r7, #4]
 8008200:	f000 fa49 	bl	8008696 <USBD_CtlError>
            err++;
 8008204:	7afb      	ldrb	r3, [r7, #11]
 8008206:	3301      	adds	r3, #1
 8008208:	72fb      	strb	r3, [r7, #11]
          break;
 800820a:	e007      	b.n	800821c <USBD_GetDescriptor+0x214>
            err++;
          }
#endif /* USBD_SUPPORT_USER_STRING_DESC  */

#if ((USBD_CLASS_USER_STRING_DESC == 0U) && (USBD_SUPPORT_USER_STRING_DESC == 0U))
          USBD_CtlError(pdev, req);
 800820c:	6839      	ldr	r1, [r7, #0]
 800820e:	6878      	ldr	r0, [r7, #4]
 8008210:	f000 fa41 	bl	8008696 <USBD_CtlError>
          err++;
 8008214:	7afb      	ldrb	r3, [r7, #11]
 8008216:	3301      	adds	r3, #1
 8008218:	72fb      	strb	r3, [r7, #11]
#endif /* (USBD_CLASS_USER_STRING_DESC == 0U) && (USBD_SUPPORT_USER_STRING_DESC == 0U) */
          break;
 800821a:	bf00      	nop
      }
      break;
 800821c:	e037      	b.n	800828e <USBD_GetDescriptor+0x286>

    case USB_DESC_TYPE_DEVICE_QUALIFIER:
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 800821e:	687b      	ldr	r3, [r7, #4]
 8008220:	7c1b      	ldrb	r3, [r3, #16]
 8008222:	2b00      	cmp	r3, #0
 8008224:	d109      	bne.n	800823a <USBD_GetDescriptor+0x232>
          pbuf = (uint8_t *)USBD_CMPSIT.GetDeviceQualifierDescriptor(&len);
        }
        else
#endif /* USE_USBD_COMPOSITE */
        {
          pbuf = (uint8_t *)pdev->pClass[0]->GetDeviceQualifierDescriptor(&len);
 8008226:	687b      	ldr	r3, [r7, #4]
 8008228:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 800822c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800822e:	f107 0208 	add.w	r2, r7, #8
 8008232:	4610      	mov	r0, r2
 8008234:	4798      	blx	r3
 8008236:	60f8      	str	r0, [r7, #12]
      else
      {
        USBD_CtlError(pdev, req);
        err++;
      }
      break;
 8008238:	e029      	b.n	800828e <USBD_GetDescriptor+0x286>
        USBD_CtlError(pdev, req);
 800823a:	6839      	ldr	r1, [r7, #0]
 800823c:	6878      	ldr	r0, [r7, #4]
 800823e:	f000 fa2a 	bl	8008696 <USBD_CtlError>
        err++;
 8008242:	7afb      	ldrb	r3, [r7, #11]
 8008244:	3301      	adds	r3, #1
 8008246:	72fb      	strb	r3, [r7, #11]
      break;
 8008248:	e021      	b.n	800828e <USBD_GetDescriptor+0x286>

    case USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION:
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 800824a:	687b      	ldr	r3, [r7, #4]
 800824c:	7c1b      	ldrb	r3, [r3, #16]
 800824e:	2b00      	cmp	r3, #0
 8008250:	d10d      	bne.n	800826e <USBD_GetDescriptor+0x266>
          pbuf = (uint8_t *)USBD_CMPSIT.GetOtherSpeedConfigDescriptor(&len);
        }
        else
#endif /* USE_USBD_COMPOSITE */
        {
          pbuf = (uint8_t *)pdev->pClass[0]->GetOtherSpeedConfigDescriptor(&len);
 8008252:	687b      	ldr	r3, [r7, #4]
 8008254:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 8008258:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800825a:	f107 0208 	add.w	r2, r7, #8
 800825e:	4610      	mov	r0, r2
 8008260:	4798      	blx	r3
 8008262:	60f8      	str	r0, [r7, #12]
        }
        pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 8008264:	68fb      	ldr	r3, [r7, #12]
 8008266:	3301      	adds	r3, #1
 8008268:	2207      	movs	r2, #7
 800826a:	701a      	strb	r2, [r3, #0]
      else
      {
        USBD_CtlError(pdev, req);
        err++;
      }
      break;
 800826c:	e00f      	b.n	800828e <USBD_GetDescriptor+0x286>
        USBD_CtlError(pdev, req);
 800826e:	6839      	ldr	r1, [r7, #0]
 8008270:	6878      	ldr	r0, [r7, #4]
 8008272:	f000 fa10 	bl	8008696 <USBD_CtlError>
        err++;
 8008276:	7afb      	ldrb	r3, [r7, #11]
 8008278:	3301      	adds	r3, #1
 800827a:	72fb      	strb	r3, [r7, #11]
      break;
 800827c:	e007      	b.n	800828e <USBD_GetDescriptor+0x286>

    default:
      USBD_CtlError(pdev, req);
 800827e:	6839      	ldr	r1, [r7, #0]
 8008280:	6878      	ldr	r0, [r7, #4]
 8008282:	f000 fa08 	bl	8008696 <USBD_CtlError>
      err++;
 8008286:	7afb      	ldrb	r3, [r7, #11]
 8008288:	3301      	adds	r3, #1
 800828a:	72fb      	strb	r3, [r7, #11]
      break;
 800828c:	bf00      	nop
  }

  if (err != 0U)
 800828e:	7afb      	ldrb	r3, [r7, #11]
 8008290:	2b00      	cmp	r3, #0
 8008292:	d11e      	bne.n	80082d2 <USBD_GetDescriptor+0x2ca>
  {
    return;
  }

  if (req->wLength != 0U)
 8008294:	683b      	ldr	r3, [r7, #0]
 8008296:	88db      	ldrh	r3, [r3, #6]
 8008298:	2b00      	cmp	r3, #0
 800829a:	d016      	beq.n	80082ca <USBD_GetDescriptor+0x2c2>
  {
    if (len != 0U)
 800829c:	893b      	ldrh	r3, [r7, #8]
 800829e:	2b00      	cmp	r3, #0
 80082a0:	d00e      	beq.n	80082c0 <USBD_GetDescriptor+0x2b8>
    {
      len = MIN(len, req->wLength);
 80082a2:	683b      	ldr	r3, [r7, #0]
 80082a4:	88da      	ldrh	r2, [r3, #6]
 80082a6:	893b      	ldrh	r3, [r7, #8]
 80082a8:	4293      	cmp	r3, r2
 80082aa:	bf28      	it	cs
 80082ac:	4613      	movcs	r3, r2
 80082ae:	b29b      	uxth	r3, r3
 80082b0:	813b      	strh	r3, [r7, #8]
      (void)USBD_CtlSendData(pdev, pbuf, len);
 80082b2:	893b      	ldrh	r3, [r7, #8]
 80082b4:	461a      	mov	r2, r3
 80082b6:	68f9      	ldr	r1, [r7, #12]
 80082b8:	6878      	ldr	r0, [r7, #4]
 80082ba:	f000 fa69 	bl	8008790 <USBD_CtlSendData>
 80082be:	e009      	b.n	80082d4 <USBD_GetDescriptor+0x2cc>
    }
    else
    {
      USBD_CtlError(pdev, req);
 80082c0:	6839      	ldr	r1, [r7, #0]
 80082c2:	6878      	ldr	r0, [r7, #4]
 80082c4:	f000 f9e7 	bl	8008696 <USBD_CtlError>
 80082c8:	e004      	b.n	80082d4 <USBD_GetDescriptor+0x2cc>
    }
  }
  else
  {
    (void)USBD_CtlSendStatus(pdev);
 80082ca:	6878      	ldr	r0, [r7, #4]
 80082cc:	f000 faba 	bl	8008844 <USBD_CtlSendStatus>
 80082d0:	e000      	b.n	80082d4 <USBD_GetDescriptor+0x2cc>
    return;
 80082d2:	bf00      	nop
  }
}
 80082d4:	3710      	adds	r7, #16
 80082d6:	46bd      	mov	sp, r7
 80082d8:	bd80      	pop	{r7, pc}
 80082da:	bf00      	nop

080082dc <USBD_SetAddress>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_SetAddress(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 80082dc:	b580      	push	{r7, lr}
 80082de:	b084      	sub	sp, #16
 80082e0:	af00      	add	r7, sp, #0
 80082e2:	6078      	str	r0, [r7, #4]
 80082e4:	6039      	str	r1, [r7, #0]
  uint8_t  dev_addr;

  if ((req->wIndex == 0U) && (req->wLength == 0U) && (req->wValue < 128U))
 80082e6:	683b      	ldr	r3, [r7, #0]
 80082e8:	889b      	ldrh	r3, [r3, #4]
 80082ea:	2b00      	cmp	r3, #0
 80082ec:	d131      	bne.n	8008352 <USBD_SetAddress+0x76>
 80082ee:	683b      	ldr	r3, [r7, #0]
 80082f0:	88db      	ldrh	r3, [r3, #6]
 80082f2:	2b00      	cmp	r3, #0
 80082f4:	d12d      	bne.n	8008352 <USBD_SetAddress+0x76>
 80082f6:	683b      	ldr	r3, [r7, #0]
 80082f8:	885b      	ldrh	r3, [r3, #2]
 80082fa:	2b7f      	cmp	r3, #127	@ 0x7f
 80082fc:	d829      	bhi.n	8008352 <USBD_SetAddress+0x76>
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7FU;
 80082fe:	683b      	ldr	r3, [r7, #0]
 8008300:	885b      	ldrh	r3, [r3, #2]
 8008302:	b2db      	uxtb	r3, r3
 8008304:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8008308:	73fb      	strb	r3, [r7, #15]

    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 800830a:	687b      	ldr	r3, [r7, #4]
 800830c:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8008310:	b2db      	uxtb	r3, r3
 8008312:	2b03      	cmp	r3, #3
 8008314:	d104      	bne.n	8008320 <USBD_SetAddress+0x44>
    {
      USBD_CtlError(pdev, req);
 8008316:	6839      	ldr	r1, [r7, #0]
 8008318:	6878      	ldr	r0, [r7, #4]
 800831a:	f000 f9bc 	bl	8008696 <USBD_CtlError>
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 800831e:	e01d      	b.n	800835c <USBD_SetAddress+0x80>
    }
    else
    {
      pdev->dev_address = dev_addr;
 8008320:	687b      	ldr	r3, [r7, #4]
 8008322:	7bfa      	ldrb	r2, [r7, #15]
 8008324:	f883 229e 	strb.w	r2, [r3, #670]	@ 0x29e
      (void)USBD_LL_SetUSBAddress(pdev, dev_addr);
 8008328:	7bfb      	ldrb	r3, [r7, #15]
 800832a:	4619      	mov	r1, r3
 800832c:	6878      	ldr	r0, [r7, #4]
 800832e:	f01f fec7 	bl	80280c0 <USBD_LL_SetUSBAddress>
      (void)USBD_CtlSendStatus(pdev);
 8008332:	6878      	ldr	r0, [r7, #4]
 8008334:	f000 fa86 	bl	8008844 <USBD_CtlSendStatus>

      if (dev_addr != 0U)
 8008338:	7bfb      	ldrb	r3, [r7, #15]
 800833a:	2b00      	cmp	r3, #0
 800833c:	d004      	beq.n	8008348 <USBD_SetAddress+0x6c>
      {
        pdev->dev_state = USBD_STATE_ADDRESSED;
 800833e:	687b      	ldr	r3, [r7, #4]
 8008340:	2202      	movs	r2, #2
 8008342:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8008346:	e009      	b.n	800835c <USBD_SetAddress+0x80>
      }
      else
      {
        pdev->dev_state = USBD_STATE_DEFAULT;
 8008348:	687b      	ldr	r3, [r7, #4]
 800834a:	2201      	movs	r2, #1
 800834c:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8008350:	e004      	b.n	800835c <USBD_SetAddress+0x80>
      }
    }
  }
  else
  {
    USBD_CtlError(pdev, req);
 8008352:	6839      	ldr	r1, [r7, #0]
 8008354:	6878      	ldr	r0, [r7, #4]
 8008356:	f000 f99e 	bl	8008696 <USBD_CtlError>
  }
}
 800835a:	bf00      	nop
 800835c:	bf00      	nop
 800835e:	3710      	adds	r7, #16
 8008360:	46bd      	mov	sp, r7
 8008362:	bd80      	pop	{r7, pc}

08008364 <USBD_SetConfig>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
static USBD_StatusTypeDef USBD_SetConfig(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8008364:	b580      	push	{r7, lr}
 8008366:	b084      	sub	sp, #16
 8008368:	af00      	add	r7, sp, #0
 800836a:	6078      	str	r0, [r7, #4]
 800836c:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK;
 800836e:	2300      	movs	r3, #0
 8008370:	73fb      	strb	r3, [r7, #15]
  static uint8_t cfgidx;

  cfgidx = (uint8_t)(req->wValue);
 8008372:	683b      	ldr	r3, [r7, #0]
 8008374:	885b      	ldrh	r3, [r3, #2]
 8008376:	b2da      	uxtb	r2, r3
 8008378:	4b4e      	ldr	r3, [pc, #312]	@ (80084b4 <USBD_SetConfig+0x150>)
 800837a:	701a      	strb	r2, [r3, #0]

  if (cfgidx > USBD_MAX_NUM_CONFIGURATION)
 800837c:	4b4d      	ldr	r3, [pc, #308]	@ (80084b4 <USBD_SetConfig+0x150>)
 800837e:	781b      	ldrb	r3, [r3, #0]
 8008380:	2b01      	cmp	r3, #1
 8008382:	d905      	bls.n	8008390 <USBD_SetConfig+0x2c>
  {
    USBD_CtlError(pdev, req);
 8008384:	6839      	ldr	r1, [r7, #0]
 8008386:	6878      	ldr	r0, [r7, #4]
 8008388:	f000 f985 	bl	8008696 <USBD_CtlError>
    return USBD_FAIL;
 800838c:	2303      	movs	r3, #3
 800838e:	e08c      	b.n	80084aa <USBD_SetConfig+0x146>
  }

  switch (pdev->dev_state)
 8008390:	687b      	ldr	r3, [r7, #4]
 8008392:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8008396:	b2db      	uxtb	r3, r3
 8008398:	2b02      	cmp	r3, #2
 800839a:	d002      	beq.n	80083a2 <USBD_SetConfig+0x3e>
 800839c:	2b03      	cmp	r3, #3
 800839e:	d029      	beq.n	80083f4 <USBD_SetConfig+0x90>
 80083a0:	e075      	b.n	800848e <USBD_SetConfig+0x12a>
  {
    case USBD_STATE_ADDRESSED:
      if (cfgidx != 0U)
 80083a2:	4b44      	ldr	r3, [pc, #272]	@ (80084b4 <USBD_SetConfig+0x150>)
 80083a4:	781b      	ldrb	r3, [r3, #0]
 80083a6:	2b00      	cmp	r3, #0
 80083a8:	d020      	beq.n	80083ec <USBD_SetConfig+0x88>
      {
        pdev->dev_config = cfgidx;
 80083aa:	4b42      	ldr	r3, [pc, #264]	@ (80084b4 <USBD_SetConfig+0x150>)
 80083ac:	781b      	ldrb	r3, [r3, #0]
 80083ae:	461a      	mov	r2, r3
 80083b0:	687b      	ldr	r3, [r7, #4]
 80083b2:	605a      	str	r2, [r3, #4]

        ret = USBD_SetClassConfig(pdev, cfgidx);
 80083b4:	4b3f      	ldr	r3, [pc, #252]	@ (80084b4 <USBD_SetConfig+0x150>)
 80083b6:	781b      	ldrb	r3, [r3, #0]
 80083b8:	4619      	mov	r1, r3
 80083ba:	6878      	ldr	r0, [r7, #4]
 80083bc:	f7fe ffe3 	bl	8007386 <USBD_SetClassConfig>
 80083c0:	4603      	mov	r3, r0
 80083c2:	73fb      	strb	r3, [r7, #15]

        if (ret != USBD_OK)
 80083c4:	7bfb      	ldrb	r3, [r7, #15]
 80083c6:	2b00      	cmp	r3, #0
 80083c8:	d008      	beq.n	80083dc <USBD_SetConfig+0x78>
        {
          USBD_CtlError(pdev, req);
 80083ca:	6839      	ldr	r1, [r7, #0]
 80083cc:	6878      	ldr	r0, [r7, #4]
 80083ce:	f000 f962 	bl	8008696 <USBD_CtlError>
          pdev->dev_state = USBD_STATE_ADDRESSED;
 80083d2:	687b      	ldr	r3, [r7, #4]
 80083d4:	2202      	movs	r2, #2
 80083d6:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
      }
      else
      {
        (void)USBD_CtlSendStatus(pdev);
      }
      break;
 80083da:	e065      	b.n	80084a8 <USBD_SetConfig+0x144>
          (void)USBD_CtlSendStatus(pdev);
 80083dc:	6878      	ldr	r0, [r7, #4]
 80083de:	f000 fa31 	bl	8008844 <USBD_CtlSendStatus>
          pdev->dev_state = USBD_STATE_CONFIGURED;
 80083e2:	687b      	ldr	r3, [r7, #4]
 80083e4:	2203      	movs	r2, #3
 80083e6:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
      break;
 80083ea:	e05d      	b.n	80084a8 <USBD_SetConfig+0x144>
        (void)USBD_CtlSendStatus(pdev);
 80083ec:	6878      	ldr	r0, [r7, #4]
 80083ee:	f000 fa29 	bl	8008844 <USBD_CtlSendStatus>
      break;
 80083f2:	e059      	b.n	80084a8 <USBD_SetConfig+0x144>

    case USBD_STATE_CONFIGURED:
      if (cfgidx == 0U)
 80083f4:	4b2f      	ldr	r3, [pc, #188]	@ (80084b4 <USBD_SetConfig+0x150>)
 80083f6:	781b      	ldrb	r3, [r3, #0]
 80083f8:	2b00      	cmp	r3, #0
 80083fa:	d112      	bne.n	8008422 <USBD_SetConfig+0xbe>
      {
        pdev->dev_state = USBD_STATE_ADDRESSED;
 80083fc:	687b      	ldr	r3, [r7, #4]
 80083fe:	2202      	movs	r2, #2
 8008400:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
        pdev->dev_config = cfgidx;
 8008404:	4b2b      	ldr	r3, [pc, #172]	@ (80084b4 <USBD_SetConfig+0x150>)
 8008406:	781b      	ldrb	r3, [r3, #0]
 8008408:	461a      	mov	r2, r3
 800840a:	687b      	ldr	r3, [r7, #4]
 800840c:	605a      	str	r2, [r3, #4]
        (void)USBD_ClrClassConfig(pdev, cfgidx);
 800840e:	4b29      	ldr	r3, [pc, #164]	@ (80084b4 <USBD_SetConfig+0x150>)
 8008410:	781b      	ldrb	r3, [r3, #0]
 8008412:	4619      	mov	r1, r3
 8008414:	6878      	ldr	r0, [r7, #4]
 8008416:	f7fe ffd2 	bl	80073be <USBD_ClrClassConfig>
        (void)USBD_CtlSendStatus(pdev);
 800841a:	6878      	ldr	r0, [r7, #4]
 800841c:	f000 fa12 	bl	8008844 <USBD_CtlSendStatus>
      }
      else
      {
        (void)USBD_CtlSendStatus(pdev);
      }
      break;
 8008420:	e042      	b.n	80084a8 <USBD_SetConfig+0x144>
      else if (cfgidx != pdev->dev_config)
 8008422:	4b24      	ldr	r3, [pc, #144]	@ (80084b4 <USBD_SetConfig+0x150>)
 8008424:	781b      	ldrb	r3, [r3, #0]
 8008426:	461a      	mov	r2, r3
 8008428:	687b      	ldr	r3, [r7, #4]
 800842a:	685b      	ldr	r3, [r3, #4]
 800842c:	429a      	cmp	r2, r3
 800842e:	d02a      	beq.n	8008486 <USBD_SetConfig+0x122>
        (void)USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 8008430:	687b      	ldr	r3, [r7, #4]
 8008432:	685b      	ldr	r3, [r3, #4]
 8008434:	b2db      	uxtb	r3, r3
 8008436:	4619      	mov	r1, r3
 8008438:	6878      	ldr	r0, [r7, #4]
 800843a:	f7fe ffc0 	bl	80073be <USBD_ClrClassConfig>
        pdev->dev_config = cfgidx;
 800843e:	4b1d      	ldr	r3, [pc, #116]	@ (80084b4 <USBD_SetConfig+0x150>)
 8008440:	781b      	ldrb	r3, [r3, #0]
 8008442:	461a      	mov	r2, r3
 8008444:	687b      	ldr	r3, [r7, #4]
 8008446:	605a      	str	r2, [r3, #4]
        ret = USBD_SetClassConfig(pdev, cfgidx);
 8008448:	4b1a      	ldr	r3, [pc, #104]	@ (80084b4 <USBD_SetConfig+0x150>)
 800844a:	781b      	ldrb	r3, [r3, #0]
 800844c:	4619      	mov	r1, r3
 800844e:	6878      	ldr	r0, [r7, #4]
 8008450:	f7fe ff99 	bl	8007386 <USBD_SetClassConfig>
 8008454:	4603      	mov	r3, r0
 8008456:	73fb      	strb	r3, [r7, #15]
        if (ret != USBD_OK)
 8008458:	7bfb      	ldrb	r3, [r7, #15]
 800845a:	2b00      	cmp	r3, #0
 800845c:	d00f      	beq.n	800847e <USBD_SetConfig+0x11a>
          USBD_CtlError(pdev, req);
 800845e:	6839      	ldr	r1, [r7, #0]
 8008460:	6878      	ldr	r0, [r7, #4]
 8008462:	f000 f918 	bl	8008696 <USBD_CtlError>
          (void)USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 8008466:	687b      	ldr	r3, [r7, #4]
 8008468:	685b      	ldr	r3, [r3, #4]
 800846a:	b2db      	uxtb	r3, r3
 800846c:	4619      	mov	r1, r3
 800846e:	6878      	ldr	r0, [r7, #4]
 8008470:	f7fe ffa5 	bl	80073be <USBD_ClrClassConfig>
          pdev->dev_state = USBD_STATE_ADDRESSED;
 8008474:	687b      	ldr	r3, [r7, #4]
 8008476:	2202      	movs	r2, #2
 8008478:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
      break;
 800847c:	e014      	b.n	80084a8 <USBD_SetConfig+0x144>
          (void)USBD_CtlSendStatus(pdev);
 800847e:	6878      	ldr	r0, [r7, #4]
 8008480:	f000 f9e0 	bl	8008844 <USBD_CtlSendStatus>
      break;
 8008484:	e010      	b.n	80084a8 <USBD_SetConfig+0x144>
        (void)USBD_CtlSendStatus(pdev);
 8008486:	6878      	ldr	r0, [r7, #4]
 8008488:	f000 f9dc 	bl	8008844 <USBD_CtlSendStatus>
      break;
 800848c:	e00c      	b.n	80084a8 <USBD_SetConfig+0x144>

    default:
      USBD_CtlError(pdev, req);
 800848e:	6839      	ldr	r1, [r7, #0]
 8008490:	6878      	ldr	r0, [r7, #4]
 8008492:	f000 f900 	bl	8008696 <USBD_CtlError>
      (void)USBD_ClrClassConfig(pdev, cfgidx);
 8008496:	4b07      	ldr	r3, [pc, #28]	@ (80084b4 <USBD_SetConfig+0x150>)
 8008498:	781b      	ldrb	r3, [r3, #0]
 800849a:	4619      	mov	r1, r3
 800849c:	6878      	ldr	r0, [r7, #4]
 800849e:	f7fe ff8e 	bl	80073be <USBD_ClrClassConfig>
      ret = USBD_FAIL;
 80084a2:	2303      	movs	r3, #3
 80084a4:	73fb      	strb	r3, [r7, #15]
      break;
 80084a6:	bf00      	nop
  }

  return ret;
 80084a8:	7bfb      	ldrb	r3, [r7, #15]
}
 80084aa:	4618      	mov	r0, r3
 80084ac:	3710      	adds	r7, #16
 80084ae:	46bd      	mov	sp, r7
 80084b0:	bd80      	pop	{r7, pc}
 80084b2:	bf00      	nop
 80084b4:	200028a4 	.word	0x200028a4

080084b8 <USBD_GetConfig>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_GetConfig(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 80084b8:	b580      	push	{r7, lr}
 80084ba:	b082      	sub	sp, #8
 80084bc:	af00      	add	r7, sp, #0
 80084be:	6078      	str	r0, [r7, #4]
 80084c0:	6039      	str	r1, [r7, #0]
  if (req->wLength != 1U)
 80084c2:	683b      	ldr	r3, [r7, #0]
 80084c4:	88db      	ldrh	r3, [r3, #6]
 80084c6:	2b01      	cmp	r3, #1
 80084c8:	d004      	beq.n	80084d4 <USBD_GetConfig+0x1c>
  {
    USBD_CtlError(pdev, req);
 80084ca:	6839      	ldr	r1, [r7, #0]
 80084cc:	6878      	ldr	r0, [r7, #4]
 80084ce:	f000 f8e2 	bl	8008696 <USBD_CtlError>
      default:
        USBD_CtlError(pdev, req);
        break;
    }
  }
}
 80084d2:	e023      	b.n	800851c <USBD_GetConfig+0x64>
    switch (pdev->dev_state)
 80084d4:	687b      	ldr	r3, [r7, #4]
 80084d6:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 80084da:	b2db      	uxtb	r3, r3
 80084dc:	2b02      	cmp	r3, #2
 80084de:	dc02      	bgt.n	80084e6 <USBD_GetConfig+0x2e>
 80084e0:	2b00      	cmp	r3, #0
 80084e2:	dc03      	bgt.n	80084ec <USBD_GetConfig+0x34>
 80084e4:	e015      	b.n	8008512 <USBD_GetConfig+0x5a>
 80084e6:	2b03      	cmp	r3, #3
 80084e8:	d00b      	beq.n	8008502 <USBD_GetConfig+0x4a>
 80084ea:	e012      	b.n	8008512 <USBD_GetConfig+0x5a>
        pdev->dev_default_config = 0U;
 80084ec:	687b      	ldr	r3, [r7, #4]
 80084ee:	2200      	movs	r2, #0
 80084f0:	609a      	str	r2, [r3, #8]
        (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_default_config, 1U);
 80084f2:	687b      	ldr	r3, [r7, #4]
 80084f4:	3308      	adds	r3, #8
 80084f6:	2201      	movs	r2, #1
 80084f8:	4619      	mov	r1, r3
 80084fa:	6878      	ldr	r0, [r7, #4]
 80084fc:	f000 f948 	bl	8008790 <USBD_CtlSendData>
        break;
 8008500:	e00c      	b.n	800851c <USBD_GetConfig+0x64>
        (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_config, 1U);
 8008502:	687b      	ldr	r3, [r7, #4]
 8008504:	3304      	adds	r3, #4
 8008506:	2201      	movs	r2, #1
 8008508:	4619      	mov	r1, r3
 800850a:	6878      	ldr	r0, [r7, #4]
 800850c:	f000 f940 	bl	8008790 <USBD_CtlSendData>
        break;
 8008510:	e004      	b.n	800851c <USBD_GetConfig+0x64>
        USBD_CtlError(pdev, req);
 8008512:	6839      	ldr	r1, [r7, #0]
 8008514:	6878      	ldr	r0, [r7, #4]
 8008516:	f000 f8be 	bl	8008696 <USBD_CtlError>
        break;
 800851a:	bf00      	nop
}
 800851c:	bf00      	nop
 800851e:	3708      	adds	r7, #8
 8008520:	46bd      	mov	sp, r7
 8008522:	bd80      	pop	{r7, pc}

08008524 <USBD_GetStatus>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_GetStatus(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8008524:	b580      	push	{r7, lr}
 8008526:	b082      	sub	sp, #8
 8008528:	af00      	add	r7, sp, #0
 800852a:	6078      	str	r0, [r7, #4]
 800852c:	6039      	str	r1, [r7, #0]
  switch (pdev->dev_state)
 800852e:	687b      	ldr	r3, [r7, #4]
 8008530:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8008534:	b2db      	uxtb	r3, r3
 8008536:	3b01      	subs	r3, #1
 8008538:	2b02      	cmp	r3, #2
 800853a:	d81e      	bhi.n	800857a <USBD_GetStatus+0x56>
  {
    case USBD_STATE_DEFAULT:
    case USBD_STATE_ADDRESSED:
    case USBD_STATE_CONFIGURED:
      if (req->wLength != 0x2U)
 800853c:	683b      	ldr	r3, [r7, #0]
 800853e:	88db      	ldrh	r3, [r3, #6]
 8008540:	2b02      	cmp	r3, #2
 8008542:	d004      	beq.n	800854e <USBD_GetStatus+0x2a>
      {
        USBD_CtlError(pdev, req);
 8008544:	6839      	ldr	r1, [r7, #0]
 8008546:	6878      	ldr	r0, [r7, #4]
 8008548:	f000 f8a5 	bl	8008696 <USBD_CtlError>
        break;
 800854c:	e01a      	b.n	8008584 <USBD_GetStatus+0x60>
      }

#if (USBD_SELF_POWERED == 1U)
      pdev->dev_config_status = USB_CONFIG_SELF_POWERED;
 800854e:	687b      	ldr	r3, [r7, #4]
 8008550:	2201      	movs	r2, #1
 8008552:	60da      	str	r2, [r3, #12]
#else
      pdev->dev_config_status = 0U;
#endif /* USBD_SELF_POWERED */

      if (pdev->dev_remote_wakeup != 0U)
 8008554:	687b      	ldr	r3, [r7, #4]
 8008556:	f8d3 32a4 	ldr.w	r3, [r3, #676]	@ 0x2a4
 800855a:	2b00      	cmp	r3, #0
 800855c:	d005      	beq.n	800856a <USBD_GetStatus+0x46>
      {
        pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;
 800855e:	687b      	ldr	r3, [r7, #4]
 8008560:	68db      	ldr	r3, [r3, #12]
 8008562:	f043 0202 	orr.w	r2, r3, #2
 8008566:	687b      	ldr	r3, [r7, #4]
 8008568:	60da      	str	r2, [r3, #12]
      }

      (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_config_status, 2U);
 800856a:	687b      	ldr	r3, [r7, #4]
 800856c:	330c      	adds	r3, #12
 800856e:	2202      	movs	r2, #2
 8008570:	4619      	mov	r1, r3
 8008572:	6878      	ldr	r0, [r7, #4]
 8008574:	f000 f90c 	bl	8008790 <USBD_CtlSendData>
      break;
 8008578:	e004      	b.n	8008584 <USBD_GetStatus+0x60>

    default:
      USBD_CtlError(pdev, req);
 800857a:	6839      	ldr	r1, [r7, #0]
 800857c:	6878      	ldr	r0, [r7, #4]
 800857e:	f000 f88a 	bl	8008696 <USBD_CtlError>
      break;
 8008582:	bf00      	nop
  }
}
 8008584:	bf00      	nop
 8008586:	3708      	adds	r7, #8
 8008588:	46bd      	mov	sp, r7
 800858a:	bd80      	pop	{r7, pc}

0800858c <USBD_SetFeature>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_SetFeature(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 800858c:	b580      	push	{r7, lr}
 800858e:	b082      	sub	sp, #8
 8008590:	af00      	add	r7, sp, #0
 8008592:	6078      	str	r0, [r7, #4]
 8008594:	6039      	str	r1, [r7, #0]
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 8008596:	683b      	ldr	r3, [r7, #0]
 8008598:	885b      	ldrh	r3, [r3, #2]
 800859a:	2b01      	cmp	r3, #1
 800859c:	d107      	bne.n	80085ae <USBD_SetFeature+0x22>
  {
    pdev->dev_remote_wakeup = 1U;
 800859e:	687b      	ldr	r3, [r7, #4]
 80085a0:	2201      	movs	r2, #1
 80085a2:	f8c3 22a4 	str.w	r2, [r3, #676]	@ 0x2a4
    (void)USBD_CtlSendStatus(pdev);
 80085a6:	6878      	ldr	r0, [r7, #4]
 80085a8:	f000 f94c 	bl	8008844 <USBD_CtlSendStatus>
  }
  else
  {
    USBD_CtlError(pdev, req);
  }
}
 80085ac:	e013      	b.n	80085d6 <USBD_SetFeature+0x4a>
  else if (req->wValue == USB_FEATURE_TEST_MODE)
 80085ae:	683b      	ldr	r3, [r7, #0]
 80085b0:	885b      	ldrh	r3, [r3, #2]
 80085b2:	2b02      	cmp	r3, #2
 80085b4:	d10b      	bne.n	80085ce <USBD_SetFeature+0x42>
    pdev->dev_test_mode = (uint8_t)(req->wIndex >> 8);
 80085b6:	683b      	ldr	r3, [r7, #0]
 80085b8:	889b      	ldrh	r3, [r3, #4]
 80085ba:	0a1b      	lsrs	r3, r3, #8
 80085bc:	b29b      	uxth	r3, r3
 80085be:	b2da      	uxtb	r2, r3
 80085c0:	687b      	ldr	r3, [r7, #4]
 80085c2:	f883 22a0 	strb.w	r2, [r3, #672]	@ 0x2a0
    (void)USBD_CtlSendStatus(pdev);
 80085c6:	6878      	ldr	r0, [r7, #4]
 80085c8:	f000 f93c 	bl	8008844 <USBD_CtlSendStatus>
}
 80085cc:	e003      	b.n	80085d6 <USBD_SetFeature+0x4a>
    USBD_CtlError(pdev, req);
 80085ce:	6839      	ldr	r1, [r7, #0]
 80085d0:	6878      	ldr	r0, [r7, #4]
 80085d2:	f000 f860 	bl	8008696 <USBD_CtlError>
}
 80085d6:	bf00      	nop
 80085d8:	3708      	adds	r7, #8
 80085da:	46bd      	mov	sp, r7
 80085dc:	bd80      	pop	{r7, pc}

080085de <USBD_ClrFeature>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_ClrFeature(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 80085de:	b580      	push	{r7, lr}
 80085e0:	b082      	sub	sp, #8
 80085e2:	af00      	add	r7, sp, #0
 80085e4:	6078      	str	r0, [r7, #4]
 80085e6:	6039      	str	r1, [r7, #0]
  switch (pdev->dev_state)
 80085e8:	687b      	ldr	r3, [r7, #4]
 80085ea:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 80085ee:	b2db      	uxtb	r3, r3
 80085f0:	3b01      	subs	r3, #1
 80085f2:	2b02      	cmp	r3, #2
 80085f4:	d80b      	bhi.n	800860e <USBD_ClrFeature+0x30>
  {
    case USBD_STATE_DEFAULT:
    case USBD_STATE_ADDRESSED:
    case USBD_STATE_CONFIGURED:
      if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 80085f6:	683b      	ldr	r3, [r7, #0]
 80085f8:	885b      	ldrh	r3, [r3, #2]
 80085fa:	2b01      	cmp	r3, #1
 80085fc:	d10c      	bne.n	8008618 <USBD_ClrFeature+0x3a>
      {
        pdev->dev_remote_wakeup = 0U;
 80085fe:	687b      	ldr	r3, [r7, #4]
 8008600:	2200      	movs	r2, #0
 8008602:	f8c3 22a4 	str.w	r2, [r3, #676]	@ 0x2a4
        (void)USBD_CtlSendStatus(pdev);
 8008606:	6878      	ldr	r0, [r7, #4]
 8008608:	f000 f91c 	bl	8008844 <USBD_CtlSendStatus>
      }
      break;
 800860c:	e004      	b.n	8008618 <USBD_ClrFeature+0x3a>

    default:
      USBD_CtlError(pdev, req);
 800860e:	6839      	ldr	r1, [r7, #0]
 8008610:	6878      	ldr	r0, [r7, #4]
 8008612:	f000 f840 	bl	8008696 <USBD_CtlError>
      break;
 8008616:	e000      	b.n	800861a <USBD_ClrFeature+0x3c>
      break;
 8008618:	bf00      	nop
  }
}
 800861a:	bf00      	nop
 800861c:	3708      	adds	r7, #8
 800861e:	46bd      	mov	sp, r7
 8008620:	bd80      	pop	{r7, pc}

08008622 <USBD_ParseSetupRequest>:
  * @param  req: usb request
  * @param  pdata: setup data pointer
  * @retval None
  */
void USBD_ParseSetupRequest(USBD_SetupReqTypedef *req, uint8_t *pdata)
{
 8008622:	b580      	push	{r7, lr}
 8008624:	b084      	sub	sp, #16
 8008626:	af00      	add	r7, sp, #0
 8008628:	6078      	str	r0, [r7, #4]
 800862a:	6039      	str	r1, [r7, #0]
  uint8_t *pbuff = pdata;
 800862c:	683b      	ldr	r3, [r7, #0]
 800862e:	60fb      	str	r3, [r7, #12]

  req->bmRequest = *(uint8_t *)(pbuff);
 8008630:	68fb      	ldr	r3, [r7, #12]
 8008632:	781a      	ldrb	r2, [r3, #0]
 8008634:	687b      	ldr	r3, [r7, #4]
 8008636:	701a      	strb	r2, [r3, #0]

  pbuff++;
 8008638:	68fb      	ldr	r3, [r7, #12]
 800863a:	3301      	adds	r3, #1
 800863c:	60fb      	str	r3, [r7, #12]
  req->bRequest = *(uint8_t *)(pbuff);
 800863e:	68fb      	ldr	r3, [r7, #12]
 8008640:	781a      	ldrb	r2, [r3, #0]
 8008642:	687b      	ldr	r3, [r7, #4]
 8008644:	705a      	strb	r2, [r3, #1]

  pbuff++;
 8008646:	68fb      	ldr	r3, [r7, #12]
 8008648:	3301      	adds	r3, #1
 800864a:	60fb      	str	r3, [r7, #12]
  req->wValue = SWAPBYTE(pbuff);
 800864c:	68f8      	ldr	r0, [r7, #12]
 800864e:	f7ff fa40 	bl	8007ad2 <SWAPBYTE>
 8008652:	4603      	mov	r3, r0
 8008654:	461a      	mov	r2, r3
 8008656:	687b      	ldr	r3, [r7, #4]
 8008658:	805a      	strh	r2, [r3, #2]

  pbuff++;
 800865a:	68fb      	ldr	r3, [r7, #12]
 800865c:	3301      	adds	r3, #1
 800865e:	60fb      	str	r3, [r7, #12]
  pbuff++;
 8008660:	68fb      	ldr	r3, [r7, #12]
 8008662:	3301      	adds	r3, #1
 8008664:	60fb      	str	r3, [r7, #12]
  req->wIndex = SWAPBYTE(pbuff);
 8008666:	68f8      	ldr	r0, [r7, #12]
 8008668:	f7ff fa33 	bl	8007ad2 <SWAPBYTE>
 800866c:	4603      	mov	r3, r0
 800866e:	461a      	mov	r2, r3
 8008670:	687b      	ldr	r3, [r7, #4]
 8008672:	809a      	strh	r2, [r3, #4]

  pbuff++;
 8008674:	68fb      	ldr	r3, [r7, #12]
 8008676:	3301      	adds	r3, #1
 8008678:	60fb      	str	r3, [r7, #12]
  pbuff++;
 800867a:	68fb      	ldr	r3, [r7, #12]
 800867c:	3301      	adds	r3, #1
 800867e:	60fb      	str	r3, [r7, #12]
  req->wLength = SWAPBYTE(pbuff);
 8008680:	68f8      	ldr	r0, [r7, #12]
 8008682:	f7ff fa26 	bl	8007ad2 <SWAPBYTE>
 8008686:	4603      	mov	r3, r0
 8008688:	461a      	mov	r2, r3
 800868a:	687b      	ldr	r3, [r7, #4]
 800868c:	80da      	strh	r2, [r3, #6]
}
 800868e:	bf00      	nop
 8008690:	3710      	adds	r7, #16
 8008692:	46bd      	mov	sp, r7
 8008694:	bd80      	pop	{r7, pc}

08008696 <USBD_CtlError>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
void USBD_CtlError(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8008696:	b580      	push	{r7, lr}
 8008698:	b082      	sub	sp, #8
 800869a:	af00      	add	r7, sp, #0
 800869c:	6078      	str	r0, [r7, #4]
 800869e:	6039      	str	r1, [r7, #0]
  UNUSED(req);

  (void)USBD_LL_StallEP(pdev, 0x80U);
 80086a0:	2180      	movs	r1, #128	@ 0x80
 80086a2:	6878      	ldr	r0, [r7, #4]
 80086a4:	f01f fca2 	bl	8027fec <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 80086a8:	2100      	movs	r1, #0
 80086aa:	6878      	ldr	r0, [r7, #4]
 80086ac:	f01f fc9e 	bl	8027fec <USBD_LL_StallEP>
}
 80086b0:	bf00      	nop
 80086b2:	3708      	adds	r7, #8
 80086b4:	46bd      	mov	sp, r7
 80086b6:	bd80      	pop	{r7, pc}

080086b8 <USBD_GetString>:
  * @param  unicode : Formatted string buffer (unicode)
  * @param  len : descriptor length
  * @retval None
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
 80086b8:	b580      	push	{r7, lr}
 80086ba:	b086      	sub	sp, #24
 80086bc:	af00      	add	r7, sp, #0
 80086be:	60f8      	str	r0, [r7, #12]
 80086c0:	60b9      	str	r1, [r7, #8]
 80086c2:	607a      	str	r2, [r7, #4]
  uint8_t idx = 0U;
 80086c4:	2300      	movs	r3, #0
 80086c6:	75fb      	strb	r3, [r7, #23]
  uint8_t *pdesc;

  if (desc == NULL)
 80086c8:	68fb      	ldr	r3, [r7, #12]
 80086ca:	2b00      	cmp	r3, #0
 80086cc:	d042      	beq.n	8008754 <USBD_GetString+0x9c>
  {
    return;
  }

  pdesc = desc;
 80086ce:	68fb      	ldr	r3, [r7, #12]
 80086d0:	613b      	str	r3, [r7, #16]
  *len = MIN(USBD_MAX_STR_DESC_SIZ, ((uint16_t)USBD_GetLen(pdesc) * 2U) + 2U);
 80086d2:	6938      	ldr	r0, [r7, #16]
 80086d4:	f000 f842 	bl	800875c <USBD_GetLen>
 80086d8:	4603      	mov	r3, r0
 80086da:	3301      	adds	r3, #1
 80086dc:	005b      	lsls	r3, r3, #1
 80086de:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 80086e2:	d808      	bhi.n	80086f6 <USBD_GetString+0x3e>
 80086e4:	6938      	ldr	r0, [r7, #16]
 80086e6:	f000 f839 	bl	800875c <USBD_GetLen>
 80086ea:	4603      	mov	r3, r0
 80086ec:	3301      	adds	r3, #1
 80086ee:	b29b      	uxth	r3, r3
 80086f0:	005b      	lsls	r3, r3, #1
 80086f2:	b29a      	uxth	r2, r3
 80086f4:	e001      	b.n	80086fa <USBD_GetString+0x42>
 80086f6:	f44f 7200 	mov.w	r2, #512	@ 0x200
 80086fa:	687b      	ldr	r3, [r7, #4]
 80086fc:	801a      	strh	r2, [r3, #0]

  unicode[idx] = *(uint8_t *)len;
 80086fe:	7dfb      	ldrb	r3, [r7, #23]
 8008700:	68ba      	ldr	r2, [r7, #8]
 8008702:	4413      	add	r3, r2
 8008704:	687a      	ldr	r2, [r7, #4]
 8008706:	7812      	ldrb	r2, [r2, #0]
 8008708:	701a      	strb	r2, [r3, #0]
  idx++;
 800870a:	7dfb      	ldrb	r3, [r7, #23]
 800870c:	3301      	adds	r3, #1
 800870e:	75fb      	strb	r3, [r7, #23]
  unicode[idx] = USB_DESC_TYPE_STRING;
 8008710:	7dfb      	ldrb	r3, [r7, #23]
 8008712:	68ba      	ldr	r2, [r7, #8]
 8008714:	4413      	add	r3, r2
 8008716:	2203      	movs	r2, #3
 8008718:	701a      	strb	r2, [r3, #0]
  idx++;
 800871a:	7dfb      	ldrb	r3, [r7, #23]
 800871c:	3301      	adds	r3, #1
 800871e:	75fb      	strb	r3, [r7, #23]

  while (*pdesc != (uint8_t)'\0')
 8008720:	e013      	b.n	800874a <USBD_GetString+0x92>
  {
    unicode[idx] = *pdesc;
 8008722:	7dfb      	ldrb	r3, [r7, #23]
 8008724:	68ba      	ldr	r2, [r7, #8]
 8008726:	4413      	add	r3, r2
 8008728:	693a      	ldr	r2, [r7, #16]
 800872a:	7812      	ldrb	r2, [r2, #0]
 800872c:	701a      	strb	r2, [r3, #0]
    pdesc++;
 800872e:	693b      	ldr	r3, [r7, #16]
 8008730:	3301      	adds	r3, #1
 8008732:	613b      	str	r3, [r7, #16]
    idx++;
 8008734:	7dfb      	ldrb	r3, [r7, #23]
 8008736:	3301      	adds	r3, #1
 8008738:	75fb      	strb	r3, [r7, #23]

    unicode[idx] = 0U;
 800873a:	7dfb      	ldrb	r3, [r7, #23]
 800873c:	68ba      	ldr	r2, [r7, #8]
 800873e:	4413      	add	r3, r2
 8008740:	2200      	movs	r2, #0
 8008742:	701a      	strb	r2, [r3, #0]
    idx++;
 8008744:	7dfb      	ldrb	r3, [r7, #23]
 8008746:	3301      	adds	r3, #1
 8008748:	75fb      	strb	r3, [r7, #23]
  while (*pdesc != (uint8_t)'\0')
 800874a:	693b      	ldr	r3, [r7, #16]
 800874c:	781b      	ldrb	r3, [r3, #0]
 800874e:	2b00      	cmp	r3, #0
 8008750:	d1e7      	bne.n	8008722 <USBD_GetString+0x6a>
 8008752:	e000      	b.n	8008756 <USBD_GetString+0x9e>
    return;
 8008754:	bf00      	nop
  }
}
 8008756:	3718      	adds	r7, #24
 8008758:	46bd      	mov	sp, r7
 800875a:	bd80      	pop	{r7, pc}

0800875c <USBD_GetLen>:
  *         return the string length
   * @param  buf : pointer to the ascii string buffer
  * @retval string length
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
 800875c:	b480      	push	{r7}
 800875e:	b085      	sub	sp, #20
 8008760:	af00      	add	r7, sp, #0
 8008762:	6078      	str	r0, [r7, #4]
  uint8_t  len = 0U;
 8008764:	2300      	movs	r3, #0
 8008766:	73fb      	strb	r3, [r7, #15]
  uint8_t *pbuff = buf;
 8008768:	687b      	ldr	r3, [r7, #4]
 800876a:	60bb      	str	r3, [r7, #8]

  while (*pbuff != (uint8_t)'\0')
 800876c:	e005      	b.n	800877a <USBD_GetLen+0x1e>
  {
    len++;
 800876e:	7bfb      	ldrb	r3, [r7, #15]
 8008770:	3301      	adds	r3, #1
 8008772:	73fb      	strb	r3, [r7, #15]
    pbuff++;
 8008774:	68bb      	ldr	r3, [r7, #8]
 8008776:	3301      	adds	r3, #1
 8008778:	60bb      	str	r3, [r7, #8]
  while (*pbuff != (uint8_t)'\0')
 800877a:	68bb      	ldr	r3, [r7, #8]
 800877c:	781b      	ldrb	r3, [r3, #0]
 800877e:	2b00      	cmp	r3, #0
 8008780:	d1f5      	bne.n	800876e <USBD_GetLen+0x12>
  }

  return len;
 8008782:	7bfb      	ldrb	r3, [r7, #15]
}
 8008784:	4618      	mov	r0, r3
 8008786:	3714      	adds	r7, #20
 8008788:	46bd      	mov	sp, r7
 800878a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800878e:	4770      	bx	lr

08008790 <USBD_CtlSendData>:
  * @param  len: length of data to be sent
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlSendData(USBD_HandleTypeDef *pdev,
                                    uint8_t *pbuf, uint32_t len)
{
 8008790:	b580      	push	{r7, lr}
 8008792:	b084      	sub	sp, #16
 8008794:	af00      	add	r7, sp, #0
 8008796:	60f8      	str	r0, [r7, #12]
 8008798:	60b9      	str	r1, [r7, #8]
 800879a:	607a      	str	r2, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_IN;
 800879c:	68fb      	ldr	r3, [r7, #12]
 800879e:	2202      	movs	r2, #2
 80087a0:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294
  pdev->ep_in[0].total_length = len;
 80087a4:	68fb      	ldr	r3, [r7, #12]
 80087a6:	687a      	ldr	r2, [r7, #4]
 80087a8:	619a      	str	r2, [r3, #24]

#ifdef USBD_AVOID_PACKET_SPLIT_MPS
  pdev->ep_in[0].rem_length = 0U;
#else
  pdev->ep_in[0].rem_length = len;
 80087aa:	68fb      	ldr	r3, [r7, #12]
 80087ac:	687a      	ldr	r2, [r7, #4]
 80087ae:	61da      	str	r2, [r3, #28]
#endif /* USBD_AVOID_PACKET_SPLIT_MPS */

  /* Start the transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 80087b0:	687b      	ldr	r3, [r7, #4]
 80087b2:	68ba      	ldr	r2, [r7, #8]
 80087b4:	2100      	movs	r1, #0
 80087b6:	68f8      	ldr	r0, [r7, #12]
 80087b8:	f01f fca1 	bl	80280fe <USBD_LL_Transmit>

  return USBD_OK;
 80087bc:	2300      	movs	r3, #0
}
 80087be:	4618      	mov	r0, r3
 80087c0:	3710      	adds	r7, #16
 80087c2:	46bd      	mov	sp, r7
 80087c4:	bd80      	pop	{r7, pc}

080087c6 <USBD_CtlContinueSendData>:
  * @param  len: length of data to be sent
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlContinueSendData(USBD_HandleTypeDef *pdev,
                                            uint8_t *pbuf, uint32_t len)
{
 80087c6:	b580      	push	{r7, lr}
 80087c8:	b084      	sub	sp, #16
 80087ca:	af00      	add	r7, sp, #0
 80087cc:	60f8      	str	r0, [r7, #12]
 80087ce:	60b9      	str	r1, [r7, #8]
 80087d0:	607a      	str	r2, [r7, #4]
  /* Start the next transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 80087d2:	687b      	ldr	r3, [r7, #4]
 80087d4:	68ba      	ldr	r2, [r7, #8]
 80087d6:	2100      	movs	r1, #0
 80087d8:	68f8      	ldr	r0, [r7, #12]
 80087da:	f01f fc90 	bl	80280fe <USBD_LL_Transmit>

  return USBD_OK;
 80087de:	2300      	movs	r3, #0
}
 80087e0:	4618      	mov	r0, r3
 80087e2:	3710      	adds	r7, #16
 80087e4:	46bd      	mov	sp, r7
 80087e6:	bd80      	pop	{r7, pc}

080087e8 <USBD_CtlPrepareRx>:
  * @param  len: length of data to be received
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlPrepareRx(USBD_HandleTypeDef *pdev,
                                     uint8_t *pbuf, uint32_t len)
{
 80087e8:	b580      	push	{r7, lr}
 80087ea:	b084      	sub	sp, #16
 80087ec:	af00      	add	r7, sp, #0
 80087ee:	60f8      	str	r0, [r7, #12]
 80087f0:	60b9      	str	r1, [r7, #8]
 80087f2:	607a      	str	r2, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_OUT;
 80087f4:	68fb      	ldr	r3, [r7, #12]
 80087f6:	2203      	movs	r2, #3
 80087f8:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294
  pdev->ep_out[0].total_length = len;
 80087fc:	68fb      	ldr	r3, [r7, #12]
 80087fe:	687a      	ldr	r2, [r7, #4]
 8008800:	f8c3 2158 	str.w	r2, [r3, #344]	@ 0x158

#ifdef USBD_AVOID_PACKET_SPLIT_MPS
  pdev->ep_out[0].rem_length = 0U;
#else
  pdev->ep_out[0].rem_length = len;
 8008804:	68fb      	ldr	r3, [r7, #12]
 8008806:	687a      	ldr	r2, [r7, #4]
 8008808:	f8c3 215c 	str.w	r2, [r3, #348]	@ 0x15c
#endif /* USBD_AVOID_PACKET_SPLIT_MPS */

  /* Start the transfer */
  (void)USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 800880c:	687b      	ldr	r3, [r7, #4]
 800880e:	68ba      	ldr	r2, [r7, #8]
 8008810:	2100      	movs	r1, #0
 8008812:	68f8      	ldr	r0, [r7, #12]
 8008814:	f01f fc94 	bl	8028140 <USBD_LL_PrepareReceive>

  return USBD_OK;
 8008818:	2300      	movs	r3, #0
}
 800881a:	4618      	mov	r0, r3
 800881c:	3710      	adds	r7, #16
 800881e:	46bd      	mov	sp, r7
 8008820:	bd80      	pop	{r7, pc}

08008822 <USBD_CtlContinueRx>:
  * @param  len: length of data to be received
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlContinueRx(USBD_HandleTypeDef *pdev,
                                      uint8_t *pbuf, uint32_t len)
{
 8008822:	b580      	push	{r7, lr}
 8008824:	b084      	sub	sp, #16
 8008826:	af00      	add	r7, sp, #0
 8008828:	60f8      	str	r0, [r7, #12]
 800882a:	60b9      	str	r1, [r7, #8]
 800882c:	607a      	str	r2, [r7, #4]
  (void)USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 800882e:	687b      	ldr	r3, [r7, #4]
 8008830:	68ba      	ldr	r2, [r7, #8]
 8008832:	2100      	movs	r1, #0
 8008834:	68f8      	ldr	r0, [r7, #12]
 8008836:	f01f fc83 	bl	8028140 <USBD_LL_PrepareReceive>

  return USBD_OK;
 800883a:	2300      	movs	r3, #0
}
 800883c:	4618      	mov	r0, r3
 800883e:	3710      	adds	r7, #16
 8008840:	46bd      	mov	sp, r7
 8008842:	bd80      	pop	{r7, pc}

08008844 <USBD_CtlSendStatus>:
  *         send zero lzngth packet on the ctl pipe
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlSendStatus(USBD_HandleTypeDef *pdev)
{
 8008844:	b580      	push	{r7, lr}
 8008846:	b082      	sub	sp, #8
 8008848:	af00      	add	r7, sp, #0
 800884a:	6078      	str	r0, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 800884c:	687b      	ldr	r3, [r7, #4]
 800884e:	2204      	movs	r2, #4
 8008850:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294

  /* Start the transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, NULL, 0U);
 8008854:	2300      	movs	r3, #0
 8008856:	2200      	movs	r2, #0
 8008858:	2100      	movs	r1, #0
 800885a:	6878      	ldr	r0, [r7, #4]
 800885c:	f01f fc4f 	bl	80280fe <USBD_LL_Transmit>

  return USBD_OK;
 8008860:	2300      	movs	r3, #0
}
 8008862:	4618      	mov	r0, r3
 8008864:	3708      	adds	r7, #8
 8008866:	46bd      	mov	sp, r7
 8008868:	bd80      	pop	{r7, pc}

0800886a <USBD_CtlReceiveStatus>:
  *         receive zero lzngth packet on the ctl pipe
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlReceiveStatus(USBD_HandleTypeDef *pdev)
{
 800886a:	b580      	push	{r7, lr}
 800886c:	b082      	sub	sp, #8
 800886e:	af00      	add	r7, sp, #0
 8008870:	6078      	str	r0, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT;
 8008872:	687b      	ldr	r3, [r7, #4]
 8008874:	2205      	movs	r2, #5
 8008876:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294

  /* Start the transfer */
  (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 800887a:	2300      	movs	r3, #0
 800887c:	2200      	movs	r2, #0
 800887e:	2100      	movs	r1, #0
 8008880:	6878      	ldr	r0, [r7, #4]
 8008882:	f01f fc5d 	bl	8028140 <USBD_LL_PrepareReceive>

  return USBD_OK;
 8008886:	2300      	movs	r3, #0
}
 8008888:	4618      	mov	r0, r3
 800888a:	3708      	adds	r7, #8
 800888c:	46bd      	mov	sp, r7
 800888e:	bd80      	pop	{r7, pc}

08008890 <wolfSSL_Atomic_Int_FetchSub>:
    static WC_INLINE int wolfSSL_Atomic_Int_FetchAdd(int *c, int i) {
        int ret = *c;
        *c += i;
        return ret;
    }
    static WC_INLINE int wolfSSL_Atomic_Int_FetchSub(int *c, int i) {
 8008890:	b480      	push	{r7}
 8008892:	b085      	sub	sp, #20
 8008894:	af00      	add	r7, sp, #0
 8008896:	6078      	str	r0, [r7, #4]
 8008898:	6039      	str	r1, [r7, #0]
        int ret = *c;
 800889a:	687b      	ldr	r3, [r7, #4]
 800889c:	681b      	ldr	r3, [r3, #0]
 800889e:	60fb      	str	r3, [r7, #12]
        *c -= i;
 80088a0:	687b      	ldr	r3, [r7, #4]
 80088a2:	681a      	ldr	r2, [r3, #0]
 80088a4:	683b      	ldr	r3, [r7, #0]
 80088a6:	1ad2      	subs	r2, r2, r3
 80088a8:	687b      	ldr	r3, [r7, #4]
 80088aa:	601a      	str	r2, [r3, #0]
        return ret;
 80088ac:	68fb      	ldr	r3, [r7, #12]
    }
 80088ae:	4618      	mov	r0, r3
 80088b0:	3714      	adds	r7, #20
 80088b2:	46bd      	mov	sp, r7
 80088b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80088b8:	4770      	bx	lr

080088ba <ForceZero>:

#ifndef WOLFSSL_NO_FORCE_ZERO
/* This routine fills the first len bytes of the memory area pointed by mem
   with zeros. It ensures compiler optimizations doesn't skip it  */
WC_MISC_STATIC WC_INLINE void ForceZero(void* mem, word32 len)
{
 80088ba:	b480      	push	{r7}
 80088bc:	b085      	sub	sp, #20
 80088be:	af00      	add	r7, sp, #0
 80088c0:	6078      	str	r0, [r7, #4]
 80088c2:	6039      	str	r1, [r7, #0]
    volatile byte* z = (volatile byte*)mem;
 80088c4:	687b      	ldr	r3, [r7, #4]
 80088c6:	60fb      	str	r3, [r7, #12]
            *w++ = 0;
        }
    z = (volatile byte*)w;
#endif

    while (len--) *z++ = 0;
 80088c8:	e004      	b.n	80088d4 <ForceZero+0x1a>
 80088ca:	68fb      	ldr	r3, [r7, #12]
 80088cc:	1c5a      	adds	r2, r3, #1
 80088ce:	60fa      	str	r2, [r7, #12]
 80088d0:	2200      	movs	r2, #0
 80088d2:	701a      	strb	r2, [r3, #0]
 80088d4:	683b      	ldr	r3, [r7, #0]
 80088d6:	1e5a      	subs	r2, r3, #1
 80088d8:	603a      	str	r2, [r7, #0]
 80088da:	2b00      	cmp	r3, #0
 80088dc:	d1f5      	bne.n	80088ca <ForceZero+0x10>
}
 80088de:	bf00      	nop
 80088e0:	bf00      	nop
 80088e2:	3714      	adds	r7, #20
 80088e4:	46bd      	mov	sp, r7
 80088e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80088ea:	4770      	bx	lr

080088ec <min>:
    #if defined(HAVE_FIPS) && !defined(min) /* so ifdef check passes */
        #define min min
    #endif
    /* returns the smaller of a and b */
    WC_MISC_STATIC WC_INLINE word32 min(word32 a, word32 b)
    {
 80088ec:	b480      	push	{r7}
 80088ee:	b083      	sub	sp, #12
 80088f0:	af00      	add	r7, sp, #0
 80088f2:	6078      	str	r0, [r7, #4]
 80088f4:	6039      	str	r1, [r7, #0]
        return a > b ? b : a;
 80088f6:	687a      	ldr	r2, [r7, #4]
 80088f8:	683b      	ldr	r3, [r7, #0]
 80088fa:	4293      	cmp	r3, r2
 80088fc:	bf28      	it	cs
 80088fe:	4613      	movcs	r3, r2
    }
 8008900:	4618      	mov	r0, r3
 8008902:	370c      	adds	r7, #12
 8008904:	46bd      	mov	sp, r7
 8008906:	f85d 7b04 	ldr.w	r7, [sp], #4
 800890a:	4770      	bx	lr

0800890c <IsAtLeastTLSv1_3>:

    return 0;
}

int IsAtLeastTLSv1_3(const ProtocolVersion pv)
{
 800890c:	b480      	push	{r7}
 800890e:	b085      	sub	sp, #20
 8008910:	af00      	add	r7, sp, #0
 8008912:	80b8      	strh	r0, [r7, #4]
    int ret;
    ret = (pv.major == SSLv3_MAJOR && pv.minor >= TLSv1_3_MINOR);
 8008914:	793b      	ldrb	r3, [r7, #4]
 8008916:	2b03      	cmp	r3, #3
 8008918:	d104      	bne.n	8008924 <IsAtLeastTLSv1_3+0x18>
 800891a:	797b      	ldrb	r3, [r7, #5]
 800891c:	2b03      	cmp	r3, #3
 800891e:	d901      	bls.n	8008924 <IsAtLeastTLSv1_3+0x18>
 8008920:	2301      	movs	r3, #1
 8008922:	e000      	b.n	8008926 <IsAtLeastTLSv1_3+0x1a>
 8008924:	2300      	movs	r3, #0
 8008926:	60fb      	str	r3, [r7, #12]
#ifdef WOLFSSL_DTLS13
    if (ret == 0 && pv.major == DTLS_MAJOR && pv.minor <= DTLSv1_3_MINOR)
        return 1;
#endif

    return ret;
 8008928:	68fb      	ldr	r3, [r7, #12]
}
 800892a:	4618      	mov	r0, r3
 800892c:	3714      	adds	r7, #20
 800892e:	46bd      	mov	sp, r7
 8008930:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008934:	4770      	bx	lr

08008936 <InitSSL_Method>:
}
#endif /* WOLFSSL_SESSION_EXPORT */


void InitSSL_Method(WOLFSSL_METHOD* method, ProtocolVersion pv)
{
 8008936:	b480      	push	{r7}
 8008938:	b083      	sub	sp, #12
 800893a:	af00      	add	r7, sp, #0
 800893c:	6078      	str	r0, [r7, #4]
 800893e:	8039      	strh	r1, [r7, #0]
    method->version    = pv;
 8008940:	687b      	ldr	r3, [r7, #4]
 8008942:	461a      	mov	r2, r3
 8008944:	463b      	mov	r3, r7
 8008946:	881b      	ldrh	r3, [r3, #0]
 8008948:	8013      	strh	r3, [r2, #0]
    method->side       = WOLFSSL_CLIENT_END;
 800894a:	687b      	ldr	r3, [r7, #4]
 800894c:	2201      	movs	r2, #1
 800894e:	709a      	strb	r2, [r3, #2]
    method->downgrade  = 0;
 8008950:	687b      	ldr	r3, [r7, #4]
 8008952:	2200      	movs	r2, #0
 8008954:	70da      	strb	r2, [r3, #3]
}
 8008956:	bf00      	nop
 8008958:	370c      	adds	r7, #12
 800895a:	46bd      	mov	sp, r7
 800895c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008960:	4770      	bx	lr

08008962 <InitSSL_Ctx>:
}
#endif /* WOLFSSL_SYS_CRYPTO_POLICY */

/* Initialize SSL context, return 0 on success */
int InitSSL_Ctx(WOLFSSL_CTX* ctx, WOLFSSL_METHOD* method, void* heap)
{
 8008962:	b580      	push	{r7, lr}
 8008964:	b086      	sub	sp, #24
 8008966:	af00      	add	r7, sp, #0
 8008968:	60f8      	str	r0, [r7, #12]
 800896a:	60b9      	str	r1, [r7, #8]
 800896c:	607a      	str	r2, [r7, #4]
    int ret = 0;
 800896e:	2300      	movs	r3, #0
 8008970:	617b      	str	r3, [r7, #20]

    XMEMSET(ctx, 0, sizeof(WOLFSSL_CTX));
 8008972:	f44f 72a8 	mov.w	r2, #336	@ 0x150
 8008976:	2100      	movs	r1, #0
 8008978:	68f8      	ldr	r0, [r7, #12]
 800897a:	f01f fda5 	bl	80284c8 <memset>

    ctx->method   = method;
 800897e:	68fb      	ldr	r3, [r7, #12]
 8008980:	68ba      	ldr	r2, [r7, #8]
 8008982:	601a      	str	r2, [r3, #0]
    if (heap == NULL) {
 8008984:	687b      	ldr	r3, [r7, #4]
 8008986:	2b00      	cmp	r3, #0
 8008988:	d103      	bne.n	8008992 <InitSSL_Ctx+0x30>
        ctx->heap = ctx;  /* defaults to self */
 800898a:	68fb      	ldr	r3, [r7, #12]
 800898c:	68fa      	ldr	r2, [r7, #12]
 800898e:	659a      	str	r2, [r3, #88]	@ 0x58
 8008990:	e002      	b.n	8008998 <InitSSL_Ctx+0x36>
    }
    else {
        ctx->heap = heap; /* wolfSSL_CTX_load_static_memory sets */
 8008992:	68fb      	ldr	r3, [r7, #12]
 8008994:	687a      	ldr	r2, [r7, #4]
 8008996:	659a      	str	r2, [r3, #88]	@ 0x58
    }
    ctx->timeout  = WOLFSSL_SESSION_TIMEOUT;
 8008998:	68fb      	ldr	r3, [r7, #12]
 800899a:	f44f 72fa 	mov.w	r2, #500	@ 0x1f4
 800899e:	f8c3 20c4 	str.w	r2, [r3, #196]	@ 0xc4
    }
    else
#endif /* WOLFSSL_DTLS */
    {
        /* current default: TLSv1_MINOR */
        ctx->minDowngrade = WOLFSSL_MIN_DOWNGRADE;
 80089a2:	68fb      	ldr	r3, [r7, #12]
 80089a4:	2203      	movs	r2, #3
 80089a6:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60
    }

    wolfSSL_RefWithMutexInit(&ctx->ref, &ret);
 80089aa:	68fb      	ldr	r3, [r7, #12]
 80089ac:	2201      	movs	r2, #1
 80089ae:	609a      	str	r2, [r3, #8]
 80089b0:	2300      	movs	r3, #0
 80089b2:	617b      	str	r3, [r7, #20]
#else
    (void)ret;
#endif

#ifndef NO_CERTS
    ctx->privateKeyDevId = INVALID_DEVID;
 80089b4:	68fb      	ldr	r3, [r7, #12]
 80089b6:	f06f 0201 	mvn.w	r2, #1
 80089ba:	64da      	str	r2, [r3, #76]	@ 0x4c
    ctx->altPrivateKeyDevId = INVALID_DEVID;
#endif
#endif

#ifndef NO_DH
    ctx->minDhKeySz  = MIN_DHKEY_SZ;
 80089bc:	68fb      	ldr	r3, [r7, #12]
 80089be:	2280      	movs	r2, #128	@ 0x80
 80089c0:	f8a3 2062 	strh.w	r2, [r3, #98]	@ 0x62
    ctx->maxDhKeySz  = MAX_DHKEY_SZ;
 80089c4:	68fb      	ldr	r3, [r7, #12]
 80089c6:	f44f 7200 	mov.w	r2, #512	@ 0x200
 80089ca:	f8a3 2064 	strh.w	r2, [r3, #100]	@ 0x64
#endif
#ifndef NO_RSA
    ctx->minRsaKeySz = MIN_RSAKEY_SZ;
 80089ce:	68fb      	ldr	r3, [r7, #12]
 80089d0:	2280      	movs	r2, #128	@ 0x80
 80089d2:	f8a3 2066 	strh.w	r2, [r3, #102]	@ 0x66
#endif

#ifdef HAVE_ECC
    ctx->minEccKeySz  = MIN_ECCKEY_SZ;
 80089d6:	68fb      	ldr	r3, [r7, #12]
 80089d8:	221c      	movs	r2, #28
 80089da:	f8a3 2068 	strh.w	r2, [r3, #104]	@ 0x68
    ctx->eccTempKeySz = ECDHE_SIZE;
 80089de:	68fb      	ldr	r3, [r7, #12]
 80089e0:	2220      	movs	r2, #32
 80089e2:	f8a3 20cc 	strh.w	r2, [r3, #204]	@ 0xcc
    ctx->minFalconKeySz = MIN_FALCONKEY_SZ;
#endif /* HAVE_FALCON */
#ifdef HAVE_DILITHIUM
    ctx->minDilithiumKeySz = MIN_DILITHIUMKEY_SZ;
#endif /* HAVE_DILITHIUM */
    ctx->verifyDepth = MAX_CHAIN_DEPTH;
 80089e6:	68fb      	ldr	r3, [r7, #12]
 80089e8:	2209      	movs	r2, #9
 80089ea:	f883 205c 	strb.w	r2, [r3, #92]	@ 0x5c
#ifdef OPENSSL_EXTRA
    ctx->cbioFlag = WOLFSSL_CBIO_NONE;
 80089ee:	68fb      	ldr	r3, [r7, #12]
 80089f0:	2200      	movs	r2, #0
 80089f2:	f883 20a0 	strb.w	r2, [r3, #160]	@ 0xa0
    if (method->side == WOLFSSL_CLIENT_END)
        ctx->haveDilithiumSig = 1;     /* always on client side */
                                       /* server can turn on by loading key */
#endif /* HAVE_DILITHIUM */
#ifdef HAVE_ECC
    if (method->side == WOLFSSL_CLIENT_END) {
 80089f6:	68bb      	ldr	r3, [r7, #8]
 80089f8:	789b      	ldrb	r3, [r3, #2]
 80089fa:	2b01      	cmp	r3, #1
 80089fc:	d114      	bne.n	8008a28 <InitSSL_Ctx+0xc6>
        ctx->haveECDSAsig  = 1;        /* always on client side */
 80089fe:	68fa      	ldr	r2, [r7, #12]
 8008a00:	f892 305e 	ldrb.w	r3, [r2, #94]	@ 0x5e
 8008a04:	f043 0320 	orr.w	r3, r3, #32
 8008a08:	f882 305e 	strb.w	r3, [r2, #94]	@ 0x5e
        ctx->haveECC  = 1;             /* server turns on with ECC key cert */
 8008a0c:	68fa      	ldr	r2, [r7, #12]
 8008a0e:	f892 305e 	ldrb.w	r3, [r2, #94]	@ 0x5e
 8008a12:	f043 0308 	orr.w	r3, r3, #8
 8008a16:	f882 305e 	strb.w	r3, [r2, #94]	@ 0x5e
        ctx->haveStaticECC = 1;        /* server can turn on by loading key */
 8008a1a:	68fa      	ldr	r2, [r7, #12]
 8008a1c:	f892 305f 	ldrb.w	r3, [r2, #95]	@ 0x5f
 8008a20:	f043 0301 	orr.w	r3, r3, #1
 8008a24:	f882 305f 	strb.w	r3, [r2, #95]	@ 0x5f
    /* default to try using CAAM when built */
    ctx->devId = WOLFSSL_CAAM_DEVID;
#elif defined(HAVE_ARIA) && defined(WOLF_CRYPTO_CB)
    ctx->devId = WOLFSSL_ARIA_DEVID;
#else
    ctx->devId = INVALID_DEVID;
 8008a28:	68fb      	ldr	r3, [r7, #12]
 8008a2a:	f06f 0201 	mvn.w	r2, #1
 8008a2e:	f8c3 2138 	str.w	r2, [r3, #312]	@ 0x138
        ctx->dtlsMtuSz = MAX_MTU;
    #endif
#endif

#ifndef NO_CERTS
    ctx->cm = wolfSSL_CertManagerNew_ex(heap);
 8008a32:	6878      	ldr	r0, [r7, #4]
 8008a34:	f002 fd88 	bl	800b548 <wolfSSL_CertManagerNew_ex>
 8008a38:	4602      	mov	r2, r0
 8008a3a:	68fb      	ldr	r3, [r7, #12]
 8008a3c:	651a      	str	r2, [r3, #80]	@ 0x50
    if (ctx->cm == NULL) {
 8008a3e:	68fb      	ldr	r3, [r7, #12]
 8008a40:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8008a42:	2b00      	cmp	r3, #0
 8008a44:	d102      	bne.n	8008a4c <InitSSL_Ctx+0xea>
        WOLFSSL_MSG("Bad Cert Manager New");
        WOLFSSL_ERROR_VERBOSE(BAD_CERT_MANAGER_ERROR);
        return BAD_CERT_MANAGER_ERROR;
 8008a46:	f46f 73b3 	mvn.w	r3, #358	@ 0x166
 8008a4a:	e076      	b.n	8008b3a <InitSSL_Ctx+0x1d8>
    }
    #ifdef OPENSSL_EXTRA
    /* setup WOLFSSL_X509_STORE */
    ctx->x509_store.cm = ctx->cm;
 8008a4c:	68fb      	ldr	r3, [r7, #12]
 8008a4e:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 8008a50:	68fb      	ldr	r3, [r7, #12]
 8008a52:	f8c3 20f8 	str.w	r2, [r3, #248]	@ 0xf8
    /* set pointer back to x509 store */
    ctx->cm->x509_store_p = &ctx->x509_store;
 8008a56:	68fb      	ldr	r3, [r7, #12]
 8008a58:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8008a5a:	68fa      	ldr	r2, [r7, #12]
 8008a5c:	32f4      	adds	r2, #244	@ 0xf4
 8008a5e:	669a      	str	r2, [r3, #104]	@ 0x68

    /* WOLFSSL_X509_VERIFY_PARAM */
    if ((ctx->param = (WOLFSSL_X509_VERIFY_PARAM*)XMALLOC(
 8008a60:	f44f 70a8 	mov.w	r0, #336	@ 0x150
 8008a64:	f016 f810 	bl	801ea88 <wolfSSL_Malloc>
 8008a68:	4602      	mov	r2, r0
 8008a6a:	68fb      	ldr	r3, [r7, #12]
 8008a6c:	f8c3 20a8 	str.w	r2, [r3, #168]	@ 0xa8
 8008a70:	68fb      	ldr	r3, [r7, #12]
 8008a72:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 8008a76:	2b00      	cmp	r3, #0
 8008a78:	d102      	bne.n	8008a80 <InitSSL_Ctx+0x11e>
                           sizeof(WOLFSSL_X509_VERIFY_PARAM),
                           heap, DYNAMIC_TYPE_OPENSSL)) == NULL) {
        WOLFSSL_MSG("ctx->param memory error");
        return MEMORY_E;
 8008a7a:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8008a7e:	e05c      	b.n	8008b3a <InitSSL_Ctx+0x1d8>
    }
    XMEMSET(ctx->param, 0, sizeof(WOLFSSL_X509_VERIFY_PARAM));
 8008a80:	68fb      	ldr	r3, [r7, #12]
 8008a82:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 8008a86:	f44f 72a8 	mov.w	r2, #336	@ 0x150
 8008a8a:	2100      	movs	r1, #0
 8008a8c:	4618      	mov	r0, r3
 8008a8e:	f01f fd1b 	bl	80284c8 <memset>

    /* WOLFSSL_X509_LOOKUP */
    if ((ctx->x509_store.lookup.dirs = (WOLFSSL_BY_DIR*)XMALLOC(
 8008a92:	2008      	movs	r0, #8
 8008a94:	f015 fff8 	bl	801ea88 <wolfSSL_Malloc>
 8008a98:	4602      	mov	r2, r0
 8008a9a:	68fb      	ldr	r3, [r7, #12]
 8008a9c:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
 8008aa0:	68fb      	ldr	r3, [r7, #12]
 8008aa2:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
 8008aa6:	2b00      	cmp	r3, #0
 8008aa8:	d102      	bne.n	8008ab0 <InitSSL_Ctx+0x14e>
                           sizeof(WOLFSSL_BY_DIR),
                           heap, DYNAMIC_TYPE_OPENSSL)) == NULL) {
        WOLFSSL_MSG("ctx->x509_store.lookup.dirs: allocation error");
        return MEMORY_E;
 8008aaa:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8008aae:	e044      	b.n	8008b3a <InitSSL_Ctx+0x1d8>
    }
    XMEMSET(ctx->x509_store.lookup.dirs, 0, sizeof(WOLFSSL_BY_DIR));
 8008ab0:	68fb      	ldr	r3, [r7, #12]
 8008ab2:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
 8008ab6:	2208      	movs	r2, #8
 8008ab8:	2100      	movs	r1, #0
 8008aba:	4618      	mov	r0, r3
 8008abc:	f01f fd04 	bl	80284c8 <memset>

    /* param */
    if ((ctx->x509_store.param = (WOLFSSL_X509_VERIFY_PARAM*)XMALLOC(
 8008ac0:	f44f 70a8 	mov.w	r0, #336	@ 0x150
 8008ac4:	f015 ffe0 	bl	801ea88 <wolfSSL_Malloc>
 8008ac8:	4602      	mov	r2, r0
 8008aca:	68fb      	ldr	r3, [r7, #12]
 8008acc:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
 8008ad0:	68fb      	ldr	r3, [r7, #12]
 8008ad2:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
 8008ad6:	2b00      	cmp	r3, #0
 8008ad8:	d102      	bne.n	8008ae0 <InitSSL_Ctx+0x17e>
                           sizeof(WOLFSSL_X509_VERIFY_PARAM),
                           heap, DYNAMIC_TYPE_OPENSSL)) == NULL) {
        WOLFSSL_MSG("ctx->x509_store.param: allocation error");
        return MEMORY_E;
 8008ada:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8008ade:	e02c      	b.n	8008b3a <InitSSL_Ctx+0x1d8>
    }
    XMEMSET(ctx->x509_store.param, 0, sizeof(WOLFSSL_X509_VERIFY_PARAM));
 8008ae0:	68fb      	ldr	r3, [r7, #12]
 8008ae2:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
 8008ae6:	f44f 72a8 	mov.w	r2, #336	@ 0x150
 8008aea:	2100      	movs	r1, #0
 8008aec:	4618      	mov	r0, r3
 8008aee:	f01f fceb 	bl	80284c8 <memset>

    if (wc_InitMutex(&ctx->x509_store.lookup.dirs->lock) != 0) {
 8008af2:	68fb      	ldr	r3, [r7, #12]
 8008af4:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
 8008af8:	3304      	adds	r3, #4
 8008afa:	4618      	mov	r0, r3
 8008afc:	f01e fc3e 	bl	802737c <wc_InitMutex>
 8008b00:	4603      	mov	r3, r0
 8008b02:	2b00      	cmp	r3, #0
 8008b04:	d002      	beq.n	8008b0c <InitSSL_Ctx+0x1aa>
        WOLFSSL_MSG("Bad mutex init");
        WOLFSSL_ERROR_VERBOSE(BAD_MUTEX_E);
        return BAD_MUTEX_E;
 8008b06:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 8008b0a:	e016      	b.n	8008b3a <InitSSL_Ctx+0x1d8>
    }
    #endif
#endif

#if defined(HAVE_EXTENDED_MASTER) && !defined(NO_WOLFSSL_CLIENT)
    if (method->side == WOLFSSL_CLIENT_END) {
 8008b0c:	68bb      	ldr	r3, [r7, #8]
 8008b0e:	789b      	ldrb	r3, [r3, #2]
 8008b10:	2b01      	cmp	r3, #1
 8008b12:	d10e      	bne.n	8008b32 <InitSSL_Ctx+0x1d0>
        if ((method->version.major == SSLv3_MAJOR) &&
 8008b14:	68bb      	ldr	r3, [r7, #8]
 8008b16:	781b      	ldrb	r3, [r3, #0]
 8008b18:	2b03      	cmp	r3, #3
 8008b1a:	d10a      	bne.n	8008b32 <InitSSL_Ctx+0x1d0>
             (method->version.minor >= TLSv1_MINOR)) {
 8008b1c:	68bb      	ldr	r3, [r7, #8]
 8008b1e:	785b      	ldrb	r3, [r3, #1]
        if ((method->version.major == SSLv3_MAJOR) &&
 8008b20:	2b00      	cmp	r3, #0
 8008b22:	d006      	beq.n	8008b32 <InitSSL_Ctx+0x1d0>

            ctx->haveEMS = 1;
 8008b24:	68fa      	ldr	r2, [r7, #12]
 8008b26:	f892 3061 	ldrb.w	r3, [r2, #97]	@ 0x61
 8008b2a:	f043 0301 	orr.w	r3, r3, #1
 8008b2e:	f882 3061 	strb.w	r3, [r2, #97]	@ 0x61
     * Qt doesn't allow to use a cipher if it is not in the supported list.
     * Therefore, we need to enable PSK cipher at the beginning.
     */
    ctx->havePSK = 1;
#endif
    ctx->heap = heap; /* wolfSSL_CTX_load_static_memory sets */
 8008b32:	68fb      	ldr	r3, [r7, #12]
 8008b34:	687a      	ldr	r2, [r7, #4]
 8008b36:	659a      	str	r2, [r3, #88]	@ 0x58
        WOLFSSL_MSG_EX("crypto_policy_init_ctx returned %d", ret);
        return ret;
    }
#endif /* WOLFSSL_SYS_CRYPTO_POLICY */

    return ret;
 8008b38:	697b      	ldr	r3, [r7, #20]
}
 8008b3a:	4618      	mov	r0, r3
 8008b3c:	3718      	adds	r7, #24
 8008b3e:	46bd      	mov	sp, r7
 8008b40:	bd80      	pop	{r7, pc}

08008b42 <SSL_CtxResourceFree>:
 * logic. A WOLFSSL_CTX can be assigned a static memory heap hint using
 * wolfSSL_CTX_load_static_memory after CTX creation, which means variables
 * allocated in InitSSL_Ctx were allocated from heap and should be free'd with
 * a NULL heap hint. */
void SSL_CtxResourceFree(WOLFSSL_CTX* ctx)
{
 8008b42:	b580      	push	{r7, lr}
 8008b44:	b08c      	sub	sp, #48	@ 0x30
 8008b46:	af00      	add	r7, sp, #0
 8008b48:	6078      	str	r0, [r7, #4]
#if defined(HAVE_CERTIFICATE_STATUS_REQUEST_V2) && \
                     defined(HAVE_TLS_EXTENSIONS) && !defined(NO_WOLFSSL_SERVER)
    int i;
#endif
    void* heapAtCTXInit = ctx->heap;
 8008b4a:	687b      	ldr	r3, [r7, #4]
 8008b4c:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8008b4e:	62fb      	str	r3, [r7, #44]	@ 0x2c
#ifdef HAVE_WOLF_EVENT
    wolfEventQueue_Free(&ctx->event_queue);
#endif /* HAVE_WOLF_EVENT */

#ifndef NO_TLS /* its a static global see ssl.c "gNoTlsMethod" */
    XFREE(ctx->method, heapAtCTXInit, DYNAMIC_TYPE_METHOD);
 8008b50:	687b      	ldr	r3, [r7, #4]
 8008b52:	681b      	ldr	r3, [r3, #0]
 8008b54:	62bb      	str	r3, [r7, #40]	@ 0x28
 8008b56:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8008b58:	2b00      	cmp	r3, #0
 8008b5a:	d002      	beq.n	8008b62 <SSL_CtxResourceFree+0x20>
 8008b5c:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8008b5e:	f015 ffaf 	bl	801eac0 <wolfSSL_Free>
#endif
    ctx->method = NULL;
 8008b62:	687b      	ldr	r3, [r7, #4]
 8008b64:	2200      	movs	r2, #0
 8008b66:	601a      	str	r2, [r3, #0]

    XFREE(ctx->suites, ctx->heap, DYNAMIC_TYPE_SUITES);
 8008b68:	687b      	ldr	r3, [r7, #4]
 8008b6a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8008b6c:	627b      	str	r3, [r7, #36]	@ 0x24
 8008b6e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8008b70:	2b00      	cmp	r3, #0
 8008b72:	d002      	beq.n	8008b7a <SSL_CtxResourceFree+0x38>
 8008b74:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8008b76:	f015 ffa3 	bl	801eac0 <wolfSSL_Free>
    ctx->suites = NULL;
 8008b7a:	687b      	ldr	r3, [r7, #4]
 8008b7c:	2200      	movs	r2, #0
 8008b7e:	655a      	str	r2, [r3, #84]	@ 0x54

#ifndef NO_DH
    XFREE(ctx->serverDH_G.buffer, ctx->heap, DYNAMIC_TYPE_PUBLIC_KEY);
 8008b80:	687b      	ldr	r3, [r7, #4]
 8008b82:	699b      	ldr	r3, [r3, #24]
 8008b84:	623b      	str	r3, [r7, #32]
 8008b86:	6a3b      	ldr	r3, [r7, #32]
 8008b88:	2b00      	cmp	r3, #0
 8008b8a:	d002      	beq.n	8008b92 <SSL_CtxResourceFree+0x50>
 8008b8c:	6a38      	ldr	r0, [r7, #32]
 8008b8e:	f015 ff97 	bl	801eac0 <wolfSSL_Free>
    ctx->serverDH_G.buffer = NULL;
 8008b92:	687b      	ldr	r3, [r7, #4]
 8008b94:	2200      	movs	r2, #0
 8008b96:	619a      	str	r2, [r3, #24]
    XFREE(ctx->serverDH_P.buffer, ctx->heap, DYNAMIC_TYPE_PUBLIC_KEY);
 8008b98:	687b      	ldr	r3, [r7, #4]
 8008b9a:	691b      	ldr	r3, [r3, #16]
 8008b9c:	61fb      	str	r3, [r7, #28]
 8008b9e:	69fb      	ldr	r3, [r7, #28]
 8008ba0:	2b00      	cmp	r3, #0
 8008ba2:	d002      	beq.n	8008baa <SSL_CtxResourceFree+0x68>
 8008ba4:	69f8      	ldr	r0, [r7, #28]
 8008ba6:	f015 ff8b 	bl	801eac0 <wolfSSL_Free>
    ctx->serverDH_P.buffer = NULL;
 8008baa:	687b      	ldr	r3, [r7, #4]
 8008bac:	2200      	movs	r2, #0
 8008bae:	611a      	str	r2, [r3, #16]
#endif /* !NO_DH */

#ifdef SINGLE_THREADED
    if (ctx->rng) {
 8008bb0:	687b      	ldr	r3, [r7, #4]
 8008bb2:	685b      	ldr	r3, [r3, #4]
 8008bb4:	2b00      	cmp	r3, #0
 8008bb6:	d010      	beq.n	8008bda <SSL_CtxResourceFree+0x98>
        wc_FreeRng(ctx->rng);
 8008bb8:	687b      	ldr	r3, [r7, #4]
 8008bba:	685b      	ldr	r3, [r3, #4]
 8008bbc:	4618      	mov	r0, r3
 8008bbe:	f016 fd8b 	bl	801f6d8 <wc_FreeRng>
        XFREE(ctx->rng, ctx->heap, DYNAMIC_TYPE_RNG);
 8008bc2:	687b      	ldr	r3, [r7, #4]
 8008bc4:	685b      	ldr	r3, [r3, #4]
 8008bc6:	61bb      	str	r3, [r7, #24]
 8008bc8:	69bb      	ldr	r3, [r7, #24]
 8008bca:	2b00      	cmp	r3, #0
 8008bcc:	d002      	beq.n	8008bd4 <SSL_CtxResourceFree+0x92>
 8008bce:	69b8      	ldr	r0, [r7, #24]
 8008bd0:	f015 ff76 	bl	801eac0 <wolfSSL_Free>
        ctx->rng = NULL;
 8008bd4:	687b      	ldr	r3, [r7, #4]
 8008bd6:	2200      	movs	r2, #0
 8008bd8:	605a      	str	r2, [r3, #4]
    }
#endif /* SINGLE_THREADED */

#ifndef NO_CERTS
    if (ctx->privateKey != NULL && ctx->privateKey->buffer != NULL) {
 8008bda:	687b      	ldr	r3, [r7, #4]
 8008bdc:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8008bde:	2b00      	cmp	r3, #0
 8008be0:	d00e      	beq.n	8008c00 <SSL_CtxResourceFree+0xbe>
 8008be2:	687b      	ldr	r3, [r7, #4]
 8008be4:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8008be6:	681b      	ldr	r3, [r3, #0]
 8008be8:	2b00      	cmp	r3, #0
 8008bea:	d009      	beq.n	8008c00 <SSL_CtxResourceFree+0xbe>
        ForceZero(ctx->privateKey->buffer, ctx->privateKey->length);
 8008bec:	687b      	ldr	r3, [r7, #4]
 8008bee:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8008bf0:	681a      	ldr	r2, [r3, #0]
 8008bf2:	687b      	ldr	r3, [r7, #4]
 8008bf4:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8008bf6:	689b      	ldr	r3, [r3, #8]
 8008bf8:	4619      	mov	r1, r3
 8008bfa:	4610      	mov	r0, r2
 8008bfc:	f7ff fe5d 	bl	80088ba <ForceZero>
    }
    FreeDer(&ctx->privateKey);
 8008c00:	687b      	ldr	r3, [r7, #4]
 8008c02:	3340      	adds	r3, #64	@ 0x40
 8008c04:	4618      	mov	r0, r3
 8008c06:	f010 f9b9 	bl	8018f7c <FreeDer>
#endif
#endif /* WOLFSSL_DUAL_ALG_CERTS */
#ifdef OPENSSL_ALL
    wolfSSL_EVP_PKEY_free(ctx->privateKeyPKey);
#endif
    FreeDer(&ctx->certificate);
 8008c0a:	687b      	ldr	r3, [r7, #4]
 8008c0c:	3320      	adds	r3, #32
 8008c0e:	4618      	mov	r0, r3
 8008c10:	f010 f9b4 	bl	8018f7c <FreeDer>
        if (ctx->ourCert && ctx->ownOurCert) {
            wolfSSL_X509_free(ctx->ourCert);
            ctx->ourCert = NULL;
        }
    #endif /* KEEP_OUR_CERT */
    FreeDer(&ctx->certChain);
 8008c14:	687b      	ldr	r3, [r7, #4]
 8008c16:	3324      	adds	r3, #36	@ 0x24
 8008c18:	4618      	mov	r0, r3
 8008c1a:	f010 f9af 	bl	8018f7c <FreeDer>
    wolfSSL_CertManagerFree(ctx->cm);
 8008c1e:	687b      	ldr	r3, [r7, #4]
 8008c20:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8008c22:	4618      	mov	r0, r3
 8008c24:	f002 fcd7 	bl	800b5d6 <wolfSSL_CertManagerFree>
    ctx->cm = NULL;
 8008c28:	687b      	ldr	r3, [r7, #4]
 8008c2a:	2200      	movs	r2, #0
 8008c2c:	651a      	str	r2, [r3, #80]	@ 0x50
            ctx->x509_store.objs = NULL;
        }
    #endif
    #if defined(OPENSSL_EXTRA) || defined(HAVE_WEBSERVER) || \
        defined(WOLFSSL_WPAS_SMALL)
        wolfSSL_X509_STORE_free(ctx->x509_store_pt);
 8008c2e:	687b      	ldr	r3, [r7, #4]
 8008c30:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 8008c34:	4618      	mov	r0, r3
 8008c36:	f006 fa3c 	bl	800f0b2 <wolfSSL_X509_STORE_free>
    #endif
    #if defined(OPENSSL_EXTRA) || defined(WOLFSSL_EXTRA) || defined(HAVE_LIGHTY)
        wolfSSL_sk_X509_NAME_pop_free(ctx->client_ca_names, NULL);
 8008c3a:	687b      	ldr	r3, [r7, #4]
 8008c3c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8008c3e:	2100      	movs	r1, #0
 8008c40:	4618      	mov	r0, r3
 8008c42:	f005 ff97 	bl	800eb74 <wolfSSL_sk_X509_NAME_pop_free>
        ctx->client_ca_names = NULL;
 8008c46:	687b      	ldr	r3, [r7, #4]
 8008c48:	2200      	movs	r2, #0
 8008c4a:	629a      	str	r2, [r3, #40]	@ 0x28
    #endif
    #ifdef OPENSSL_EXTRA
        if (ctx->x509Chain) {
 8008c4c:	687b      	ldr	r3, [r7, #4]
 8008c4e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8008c50:	2b00      	cmp	r3, #0
 8008c52:	d008      	beq.n	8008c66 <SSL_CtxResourceFree+0x124>
            wolfSSL_sk_X509_pop_free(ctx->x509Chain, NULL);
 8008c54:	687b      	ldr	r3, [r7, #4]
 8008c56:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8008c58:	2100      	movs	r1, #0
 8008c5a:	4618      	mov	r0, r3
 8008c5c:	f005 fb7e 	bl	800e35c <wolfSSL_sk_X509_pop_free>
            ctx->x509Chain = NULL;
 8008c60:	687b      	ldr	r3, [r7, #4]
 8008c62:	2200      	movs	r2, #0
 8008c64:	62da      	str	r2, [r3, #44]	@ 0x2c
    #endif
#endif /* !NO_CERTS */

#ifdef HAVE_TLS_EXTENSIONS
#if !defined(NO_TLS)
    TLSX_FreeAll(ctx->extensions, ctx->heap);
 8008c66:	687b      	ldr	r3, [r7, #4]
 8008c68:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
 8008c6c:	687b      	ldr	r3, [r7, #4]
 8008c6e:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8008c70:	4619      	mov	r1, r3
 8008c72:	4610      	mov	r0, r2
 8008c74:	f006 fbcc 	bl	800f410 <TLSX_FreeAll>
#endif /* HAVE_CERTIFICATE_STATUS_REQUEST_V2 */
#endif /* !NO_WOLFSSL_SERVER */

#endif /* HAVE_TLS_EXTENSIONS */
#ifdef OPENSSL_EXTRA
    if (ctx->alpn_cli_protos) {
 8008c78:	687b      	ldr	r3, [r7, #4]
 8008c7a:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
 8008c7e:	2b00      	cmp	r3, #0
 8008c80:	d00d      	beq.n	8008c9e <SSL_CtxResourceFree+0x15c>
        XFREE((void*)ctx->alpn_cli_protos, ctx->heap, DYNAMIC_TYPE_OPENSSL);
 8008c82:	687b      	ldr	r3, [r7, #4]
 8008c84:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
 8008c88:	617b      	str	r3, [r7, #20]
 8008c8a:	697b      	ldr	r3, [r7, #20]
 8008c8c:	2b00      	cmp	r3, #0
 8008c8e:	d002      	beq.n	8008c96 <SSL_CtxResourceFree+0x154>
 8008c90:	6978      	ldr	r0, [r7, #20]
 8008c92:	f015 ff15 	bl	801eac0 <wolfSSL_Free>
        ctx->alpn_cli_protos = NULL;
 8008c96:	687b      	ldr	r3, [r7, #4]
 8008c98:	2200      	movs	r2, #0
 8008c9a:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
    }
    XFREE(ctx->param, heapAtCTXInit, DYNAMIC_TYPE_OPENSSL);
 8008c9e:	687b      	ldr	r3, [r7, #4]
 8008ca0:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 8008ca4:	613b      	str	r3, [r7, #16]
 8008ca6:	693b      	ldr	r3, [r7, #16]
 8008ca8:	2b00      	cmp	r3, #0
 8008caa:	d002      	beq.n	8008cb2 <SSL_CtxResourceFree+0x170>
 8008cac:	6938      	ldr	r0, [r7, #16]
 8008cae:	f015 ff07 	bl	801eac0 <wolfSSL_Free>
    ctx->param = NULL;
 8008cb2:	687b      	ldr	r3, [r7, #4]
 8008cb4:	2200      	movs	r2, #0
 8008cb6:	f8c3 20a8 	str.w	r2, [r3, #168]	@ 0xa8

    if (ctx->x509_store.param) {
 8008cba:	687b      	ldr	r3, [r7, #4]
 8008cbc:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
 8008cc0:	2b00      	cmp	r3, #0
 8008cc2:	d00d      	beq.n	8008ce0 <SSL_CtxResourceFree+0x19e>
        XFREE(ctx->x509_store.param, heapAtCTXInit, DYNAMIC_TYPE_OPENSSL);
 8008cc4:	687b      	ldr	r3, [r7, #4]
 8008cc6:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
 8008cca:	60fb      	str	r3, [r7, #12]
 8008ccc:	68fb      	ldr	r3, [r7, #12]
 8008cce:	2b00      	cmp	r3, #0
 8008cd0:	d002      	beq.n	8008cd8 <SSL_CtxResourceFree+0x196>
 8008cd2:	68f8      	ldr	r0, [r7, #12]
 8008cd4:	f015 fef4 	bl	801eac0 <wolfSSL_Free>
        ctx->x509_store.param = NULL;
 8008cd8:	687b      	ldr	r3, [r7, #4]
 8008cda:	2200      	movs	r2, #0
 8008cdc:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
    }

    if (ctx->x509_store.lookup.dirs) {
 8008ce0:	687b      	ldr	r3, [r7, #4]
 8008ce2:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
 8008ce6:	2b00      	cmp	r3, #0
 8008ce8:	d010      	beq.n	8008d0c <SSL_CtxResourceFree+0x1ca>
        if (ctx->x509_store.lookup.dirs->dir_entry) {
            wolfSSL_sk_BY_DIR_entry_free(ctx->x509_store.lookup.dirs->dir_entry);
        }

#endif
        wc_FreeMutex(&ctx->x509_store.lookup.dirs->lock);
 8008cea:	687b      	ldr	r3, [r7, #4]
 8008cec:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
 8008cf0:	3304      	adds	r3, #4
 8008cf2:	4618      	mov	r0, r3
 8008cf4:	f01e fb4d 	bl	8027392 <wc_FreeMutex>
        XFREE(ctx->x509_store.lookup.dirs, heapAtCTXInit, DYNAMIC_TYPE_OPENSSL);
 8008cf8:	687b      	ldr	r3, [r7, #4]
 8008cfa:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
 8008cfe:	60bb      	str	r3, [r7, #8]
 8008d00:	68bb      	ldr	r3, [r7, #8]
 8008d02:	2b00      	cmp	r3, #0
 8008d04:	d002      	beq.n	8008d0c <SSL_CtxResourceFree+0x1ca>
 8008d06:	68b8      	ldr	r0, [r7, #8]
 8008d08:	f015 feda 	bl	801eac0 <wolfSSL_Free>
#if defined(WOLFSSL_TLS13) && defined(HAVE_ECH)
    FreeEchConfigs(ctx->echConfigs, ctx->heap);
    ctx->echConfigs = NULL;
#endif
    (void)heapAtCTXInit;
}
 8008d0c:	bf00      	nop
 8008d0e:	3730      	adds	r7, #48	@ 0x30
 8008d10:	46bd      	mov	sp, r7
 8008d12:	bd80      	pop	{r7, pc}

08008d14 <FreeSSL_Ctx>:


void FreeSSL_Ctx(WOLFSSL_CTX* ctx)
{
 8008d14:	b580      	push	{r7, lr}
 8008d16:	b088      	sub	sp, #32
 8008d18:	af00      	add	r7, sp, #0
 8008d1a:	6078      	str	r0, [r7, #4]
    int isZero;
    int ret;
    void* heap = ctx->heap;
 8008d1c:	687b      	ldr	r3, [r7, #4]
 8008d1e:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8008d20:	61fb      	str	r3, [r7, #28]
        heap = NULL;
    }
#endif

    /* decrement CTX reference count */
    wolfSSL_RefWithMutexDec(&ctx->ref, &isZero, &ret);
 8008d22:	687b      	ldr	r3, [r7, #4]
 8008d24:	3308      	adds	r3, #8
 8008d26:	2101      	movs	r1, #1
 8008d28:	4618      	mov	r0, r3
 8008d2a:	f7ff fdb1 	bl	8008890 <wolfSSL_Atomic_Int_FetchSub>
 8008d2e:	61b8      	str	r0, [r7, #24]
 8008d30:	69bb      	ldr	r3, [r7, #24]
 8008d32:	2b01      	cmp	r3, #1
 8008d34:	bf0c      	ite	eq
 8008d36:	2301      	moveq	r3, #1
 8008d38:	2300      	movne	r3, #0
 8008d3a:	b2db      	uxtb	r3, r3
 8008d3c:	613b      	str	r3, [r7, #16]
 8008d3e:	2300      	movs	r3, #0
 8008d40:	60fb      	str	r3, [r7, #12]
    }
#else
    (void)ret;
#endif

    if (isZero) {
 8008d42:	693b      	ldr	r3, [r7, #16]
 8008d44:	2b00      	cmp	r3, #0
 8008d46:	d00a      	beq.n	8008d5e <FreeSSL_Ctx+0x4a>
        WOLFSSL_MSG("CTX ref count down to 0, doing full free");

        SSL_CtxResourceFree(ctx);
 8008d48:	6878      	ldr	r0, [r7, #4]
 8008d4a:	f7ff fefa 	bl	8008b42 <SSL_CtxResourceFree>
#if defined(HAVE_SESSION_TICKET) && !defined(NO_WOLFSSL_SERVER) && \
    !defined(WOLFSSL_NO_DEF_TICKET_ENC_CB) && !defined(NO_TLS)
        TicketEncCbCtx_Free(&ctx->ticketKeyCtx);
#endif
        wolfSSL_RefFree(&ctx->ref);
        XFREE(ctx, heap, DYNAMIC_TYPE_CTX);
 8008d4e:	687b      	ldr	r3, [r7, #4]
 8008d50:	617b      	str	r3, [r7, #20]
 8008d52:	697b      	ldr	r3, [r7, #20]
 8008d54:	2b00      	cmp	r3, #0
 8008d56:	d002      	beq.n	8008d5e <FreeSSL_Ctx+0x4a>
 8008d58:	6978      	ldr	r0, [r7, #20]
 8008d5a:	f015 feb1 	bl	801eac0 <wolfSSL_Free>
    }
    else {
        WOLFSSL_MSG("CTX ref count not 0 yet, no free");
    }
    (void)heap; /* not used in some builds */
}
 8008d5e:	bf00      	nop
 8008d60:	3720      	adds	r7, #32
 8008d62:	46bd      	mov	sp, r7
 8008d64:	bd80      	pop	{r7, pc}

08008d66 <FreeCiphersSide>:
#endif /* WOLFSSL_DTLS13 */

}

static void FreeCiphersSide(Ciphers *cipher, void* heap)
{
 8008d66:	b580      	push	{r7, lr}
 8008d68:	b086      	sub	sp, #24
 8008d6a:	af00      	add	r7, sp, #0
 8008d6c:	6078      	str	r0, [r7, #4]
 8008d6e:	6039      	str	r1, [r7, #0]
    cipher->des3 = NULL;
#endif
#if defined(BUILD_AES) || defined(BUILD_AESGCM) || defined(HAVE_ARIA)
    /* See: InitKeys() in keys.c on addition of BUILD_AESGCM check (enc->aes,
     * dec->aes) */
    wc_AesFree(cipher->aes);
 8008d70:	687b      	ldr	r3, [r7, #4]
 8008d72:	681b      	ldr	r3, [r3, #0]
 8008d74:	4618      	mov	r0, r3
 8008d76:	f009 fc7b 	bl	8012670 <wc_AesFree>
    XFREE(cipher->aes, heap, DYNAMIC_TYPE_CIPHER);
 8008d7a:	687b      	ldr	r3, [r7, #4]
 8008d7c:	681b      	ldr	r3, [r3, #0]
 8008d7e:	617b      	str	r3, [r7, #20]
 8008d80:	697b      	ldr	r3, [r7, #20]
 8008d82:	2b00      	cmp	r3, #0
 8008d84:	d002      	beq.n	8008d8c <FreeCiphersSide+0x26>
 8008d86:	6978      	ldr	r0, [r7, #20]
 8008d88:	f015 fe9a 	bl	801eac0 <wolfSSL_Free>
    cipher->aes = NULL;
 8008d8c:	687b      	ldr	r3, [r7, #4]
 8008d8e:	2200      	movs	r2, #0
 8008d90:	601a      	str	r2, [r3, #0]
    XFREE(cipher->sm4, heap, DYNAMIC_TYPE_CIPHER);
    cipher->sm4 = NULL;
#endif
#if (defined(BUILD_AESGCM) || defined(BUILD_AESCCM) || defined(HAVE_ARIA)) && \
    !defined(WOLFSSL_NO_TLS12)
    XFREE(cipher->additional, heap, DYNAMIC_TYPE_CIPHER);
 8008d92:	687b      	ldr	r3, [r7, #4]
 8008d94:	685b      	ldr	r3, [r3, #4]
 8008d96:	613b      	str	r3, [r7, #16]
 8008d98:	693b      	ldr	r3, [r7, #16]
 8008d9a:	2b00      	cmp	r3, #0
 8008d9c:	d002      	beq.n	8008da4 <FreeCiphersSide+0x3e>
 8008d9e:	6938      	ldr	r0, [r7, #16]
 8008da0:	f015 fe8e 	bl	801eac0 <wolfSSL_Free>
    cipher->additional = NULL;
 8008da4:	687b      	ldr	r3, [r7, #4]
 8008da6:	2200      	movs	r2, #0
 8008da8:	605a      	str	r2, [r3, #4]
#endif
#ifdef CIPHER_NONCE
    XFREE(cipher->nonce, heap, DYNAMIC_TYPE_CIPHER);
 8008daa:	687b      	ldr	r3, [r7, #4]
 8008dac:	689b      	ldr	r3, [r3, #8]
 8008dae:	60fb      	str	r3, [r7, #12]
 8008db0:	68fb      	ldr	r3, [r7, #12]
 8008db2:	2b00      	cmp	r3, #0
 8008db4:	d002      	beq.n	8008dbc <FreeCiphersSide+0x56>
 8008db6:	68f8      	ldr	r0, [r7, #12]
 8008db8:	f015 fe82 	bl	801eac0 <wolfSSL_Free>
    cipher->nonce = NULL;
 8008dbc:	687b      	ldr	r3, [r7, #4]
 8008dbe:	2200      	movs	r2, #0
 8008dc0:	609a      	str	r2, [r3, #8]
#ifdef HAVE_CAMELLIA
    XFREE(cipher->cam, heap, DYNAMIC_TYPE_CIPHER);
    cipher->cam = NULL;
#endif
#ifdef HAVE_CHACHA
    if (cipher->chacha)
 8008dc2:	687b      	ldr	r3, [r7, #4]
 8008dc4:	68db      	ldr	r3, [r3, #12]
 8008dc6:	2b00      	cmp	r3, #0
 8008dc8:	d005      	beq.n	8008dd6 <FreeCiphersSide+0x70>
        ForceZero(cipher->chacha, sizeof(ChaCha));
 8008dca:	687b      	ldr	r3, [r7, #4]
 8008dcc:	68db      	ldr	r3, [r3, #12]
 8008dce:	2144      	movs	r1, #68	@ 0x44
 8008dd0:	4618      	mov	r0, r3
 8008dd2:	f7ff fd72 	bl	80088ba <ForceZero>
    XFREE(cipher->chacha, heap, DYNAMIC_TYPE_CIPHER);
 8008dd6:	687b      	ldr	r3, [r7, #4]
 8008dd8:	68db      	ldr	r3, [r3, #12]
 8008dda:	60bb      	str	r3, [r7, #8]
 8008ddc:	68bb      	ldr	r3, [r7, #8]
 8008dde:	2b00      	cmp	r3, #0
 8008de0:	d002      	beq.n	8008de8 <FreeCiphersSide+0x82>
 8008de2:	68b8      	ldr	r0, [r7, #8]
 8008de4:	f015 fe6c 	bl	801eac0 <wolfSSL_Free>
    cipher->chacha = NULL;
 8008de8:	687b      	ldr	r3, [r7, #4]
 8008dea:	2200      	movs	r2, #0
 8008dec:	60da      	str	r2, [r3, #12]
#if defined(WOLFSSL_TLS13) && defined(HAVE_NULL_CIPHER)
    wc_HmacFree(cipher->hmac);
    XFREE(cipher->hmac, heap, DYNAMIC_TYPE_CIPHER);
    cipher->hmac = NULL;
#endif
}
 8008dee:	bf00      	nop
 8008df0:	3718      	adds	r7, #24
 8008df2:	46bd      	mov	sp, r7
 8008df4:	bd80      	pop	{r7, pc}

08008df6 <FreeCiphers>:

/* Free ciphers */
void FreeCiphers(WOLFSSL* ssl)
{
 8008df6:	b580      	push	{r7, lr}
 8008df8:	b084      	sub	sp, #16
 8008dfa:	af00      	add	r7, sp, #0
 8008dfc:	6078      	str	r0, [r7, #4]
    FreeCiphersSide(&ssl->encrypt, ssl->heap);
 8008dfe:	687b      	ldr	r3, [r7, #4]
 8008e00:	f103 02bc 	add.w	r2, r3, #188	@ 0xbc
 8008e04:	687b      	ldr	r3, [r7, #4]
 8008e06:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8008e0a:	4619      	mov	r1, r3
 8008e0c:	4610      	mov	r0, r2
 8008e0e:	f7ff ffaa 	bl	8008d66 <FreeCiphersSide>
    FreeCiphersSide(&ssl->decrypt, ssl->heap);
 8008e12:	687b      	ldr	r3, [r7, #4]
 8008e14:	f103 02d0 	add.w	r2, r3, #208	@ 0xd0
 8008e18:	687b      	ldr	r3, [r7, #4]
 8008e1a:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8008e1e:	4619      	mov	r1, r3
 8008e20:	4610      	mov	r0, r2
 8008e22:	f7ff ffa0 	bl	8008d66 <FreeCiphersSide>

#if defined(HAVE_POLY1305) && defined(HAVE_ONE_TIME_AUTH)
    if (ssl->auth.poly1305)
 8008e26:	687b      	ldr	r3, [r7, #4]
 8008e28:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8008e2c:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
 8008e30:	2b00      	cmp	r3, #0
 8008e32:	d008      	beq.n	8008e46 <FreeCiphers+0x50>
        ForceZero(ssl->auth.poly1305, sizeof(Poly1305));
 8008e34:	687b      	ldr	r3, [r7, #4]
 8008e36:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8008e3a:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
 8008e3e:	2150      	movs	r1, #80	@ 0x50
 8008e40:	4618      	mov	r0, r3
 8008e42:	f7ff fd3a 	bl	80088ba <ForceZero>
    XFREE(ssl->auth.poly1305, ssl->heap, DYNAMIC_TYPE_CIPHER);
 8008e46:	687b      	ldr	r3, [r7, #4]
 8008e48:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8008e4c:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
 8008e50:	60fb      	str	r3, [r7, #12]
 8008e52:	68fb      	ldr	r3, [r7, #12]
 8008e54:	2b00      	cmp	r3, #0
 8008e56:	d002      	beq.n	8008e5e <FreeCiphers+0x68>
 8008e58:	68f8      	ldr	r0, [r7, #12]
 8008e5a:	f015 fe31 	bl	801eac0 <wolfSSL_Free>
    ssl->auth.poly1305 = NULL;
 8008e5e:	687b      	ldr	r3, [r7, #4]
 8008e60:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8008e64:	461a      	mov	r2, r3
 8008e66:	2300      	movs	r3, #0
 8008e68:	f8c2 3098 	str.w	r3, [r2, #152]	@ 0x98
    XFREE(ssl->dtlsRecordNumberDecrypt.chacha, ssl->heap, DYNAMIC_TYPE_CIPHER);
    ssl->dtlsRecordNumberEncrypt.chacha = NULL;
    ssl->dtlsRecordNumberDecrypt.chacha = NULL;
#endif /* HAVE_CHACHA */
#endif /* WOLFSSL_DTLS13 */
}
 8008e6c:	bf00      	nop
 8008e6e:	3710      	adds	r7, #16
 8008e70:	46bd      	mov	sp, r7
 8008e72:	bd80      	pop	{r7, pc}

08008e74 <AddSuiteHashSigAlgo>:
        *(inOutIdx) += 2;                               \
    } while (0)

static WC_INLINE void AddSuiteHashSigAlgo(byte* hashSigAlgo, byte macAlgo,
    byte sigAlgo, int keySz, word16* inOutIdx)
{
 8008e74:	b480      	push	{r7}
 8008e76:	b087      	sub	sp, #28
 8008e78:	af00      	add	r7, sp, #0
 8008e7a:	60f8      	str	r0, [r7, #12]
 8008e7c:	607b      	str	r3, [r7, #4]
 8008e7e:	460b      	mov	r3, r1
 8008e80:	72fb      	strb	r3, [r7, #11]
 8008e82:	4613      	mov	r3, r2
 8008e84:	72bb      	strb	r3, [r7, #10]
    int addSigAlgo = 1;
 8008e86:	2301      	movs	r3, #1
 8008e88:	617b      	str	r3, [r7, #20]
    }
#else
    (void)keySz;
#endif /* USE_ECDSA_KEYSZ_HASH_ALGO */

    if (addSigAlgo) {
 8008e8a:	697b      	ldr	r3, [r7, #20]
 8008e8c:	2b00      	cmp	r3, #0
 8008e8e:	d04a      	beq.n	8008f26 <AddSuiteHashSigAlgo+0xb2>
                DILITHIUM_LEVEL5_SA_MAJOR, DILITHIUM_LEVEL5_SA_MINOR);
        }
        else
    #endif /* HAVE_DILITHIUM */
#ifdef WC_RSA_PSS
        if (sigAlgo == rsa_pss_sa_algo) {
 8008e90:	7abb      	ldrb	r3, [r7, #10]
 8008e92:	2b08      	cmp	r3, #8
 8008e94:	d130      	bne.n	8008ef8 <AddSuiteHashSigAlgo+0x84>
            /* RSA PSS is sig then mac */
            ADD_HASH_SIG_ALGO(hashSigAlgo, inOutIdx, sigAlgo, macAlgo);
 8008e96:	68fb      	ldr	r3, [r7, #12]
 8008e98:	2b00      	cmp	r3, #0
 8008e9a:	d00d      	beq.n	8008eb8 <AddSuiteHashSigAlgo+0x44>
 8008e9c:	6a3b      	ldr	r3, [r7, #32]
 8008e9e:	881b      	ldrh	r3, [r3, #0]
 8008ea0:	461a      	mov	r2, r3
 8008ea2:	68fb      	ldr	r3, [r7, #12]
 8008ea4:	4413      	add	r3, r2
 8008ea6:	7aba      	ldrb	r2, [r7, #10]
 8008ea8:	701a      	strb	r2, [r3, #0]
 8008eaa:	6a3b      	ldr	r3, [r7, #32]
 8008eac:	881b      	ldrh	r3, [r3, #0]
 8008eae:	3301      	adds	r3, #1
 8008eb0:	68fa      	ldr	r2, [r7, #12]
 8008eb2:	4413      	add	r3, r2
 8008eb4:	7afa      	ldrb	r2, [r7, #11]
 8008eb6:	701a      	strb	r2, [r3, #0]
 8008eb8:	6a3b      	ldr	r3, [r7, #32]
 8008eba:	881b      	ldrh	r3, [r3, #0]
 8008ebc:	3302      	adds	r3, #2
 8008ebe:	b29a      	uxth	r2, r3
 8008ec0:	6a3b      	ldr	r3, [r7, #32]
 8008ec2:	801a      	strh	r2, [r3, #0]
    #ifdef WOLFSSL_TLS13
            /* Add the certificate algorithm as well */
            ADD_HASH_SIG_ALGO(hashSigAlgo, inOutIdx, sigAlgo,
 8008ec4:	68fb      	ldr	r3, [r7, #12]
 8008ec6:	2b00      	cmp	r3, #0
 8008ec8:	d00f      	beq.n	8008eea <AddSuiteHashSigAlgo+0x76>
 8008eca:	6a3b      	ldr	r3, [r7, #32]
 8008ecc:	881b      	ldrh	r3, [r3, #0]
 8008ece:	461a      	mov	r2, r3
 8008ed0:	68fb      	ldr	r3, [r7, #12]
 8008ed2:	4413      	add	r3, r2
 8008ed4:	7aba      	ldrb	r2, [r7, #10]
 8008ed6:	701a      	strb	r2, [r3, #0]
 8008ed8:	6a3b      	ldr	r3, [r7, #32]
 8008eda:	881b      	ldrh	r3, [r3, #0]
 8008edc:	3301      	adds	r3, #1
 8008ede:	68fa      	ldr	r2, [r7, #12]
 8008ee0:	4413      	add	r3, r2
 8008ee2:	7afa      	ldrb	r2, [r7, #11]
 8008ee4:	3205      	adds	r2, #5
 8008ee6:	b2d2      	uxtb	r2, r2
 8008ee8:	701a      	strb	r2, [r3, #0]
 8008eea:	6a3b      	ldr	r3, [r7, #32]
 8008eec:	881b      	ldrh	r3, [r3, #0]
 8008eee:	3302      	adds	r3, #2
 8008ef0:	b29a      	uxth	r2, r3
 8008ef2:	6a3b      	ldr	r3, [r7, #32]
 8008ef4:	801a      	strh	r2, [r3, #0]
#endif
        {
            ADD_HASH_SIG_ALGO(hashSigAlgo, inOutIdx, macAlgo, sigAlgo);
        }
    }
}
 8008ef6:	e016      	b.n	8008f26 <AddSuiteHashSigAlgo+0xb2>
            ADD_HASH_SIG_ALGO(hashSigAlgo, inOutIdx, macAlgo, sigAlgo);
 8008ef8:	68fb      	ldr	r3, [r7, #12]
 8008efa:	2b00      	cmp	r3, #0
 8008efc:	d00d      	beq.n	8008f1a <AddSuiteHashSigAlgo+0xa6>
 8008efe:	6a3b      	ldr	r3, [r7, #32]
 8008f00:	881b      	ldrh	r3, [r3, #0]
 8008f02:	461a      	mov	r2, r3
 8008f04:	68fb      	ldr	r3, [r7, #12]
 8008f06:	4413      	add	r3, r2
 8008f08:	7afa      	ldrb	r2, [r7, #11]
 8008f0a:	701a      	strb	r2, [r3, #0]
 8008f0c:	6a3b      	ldr	r3, [r7, #32]
 8008f0e:	881b      	ldrh	r3, [r3, #0]
 8008f10:	3301      	adds	r3, #1
 8008f12:	68fa      	ldr	r2, [r7, #12]
 8008f14:	4413      	add	r3, r2
 8008f16:	7aba      	ldrb	r2, [r7, #10]
 8008f18:	701a      	strb	r2, [r3, #0]
 8008f1a:	6a3b      	ldr	r3, [r7, #32]
 8008f1c:	881b      	ldrh	r3, [r3, #0]
 8008f1e:	3302      	adds	r3, #2
 8008f20:	b29a      	uxth	r2, r3
 8008f22:	6a3b      	ldr	r3, [r7, #32]
 8008f24:	801a      	strh	r2, [r3, #0]
}
 8008f26:	bf00      	nop
 8008f28:	371c      	adds	r7, #28
 8008f2a:	46bd      	mov	sp, r7
 8008f2c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008f30:	4770      	bx	lr

08008f32 <InitSuitesHashSigAlgo>:

void InitSuitesHashSigAlgo(byte* hashSigAlgo, int haveSig, int tls1_2,
    int keySz, word16* len)
{
 8008f32:	b580      	push	{r7, lr}
 8008f34:	b088      	sub	sp, #32
 8008f36:	af02      	add	r7, sp, #8
 8008f38:	60f8      	str	r0, [r7, #12]
 8008f3a:	60b9      	str	r1, [r7, #8]
 8008f3c:	607a      	str	r2, [r7, #4]
 8008f3e:	603b      	str	r3, [r7, #0]
    word16 idx = 0;
 8008f40:	2300      	movs	r3, #0
 8008f42:	82fb      	strh	r3, [r7, #22]

    (void)tls1_2;
    (void)keySz;

#if defined(HAVE_ECC) || defined(HAVE_ED25519) || defined(HAVE_ED448)
    if (haveSig & SIG_ECDSA) {
 8008f44:	68bb      	ldr	r3, [r7, #8]
 8008f46:	f003 0301 	and.w	r3, r3, #1
 8008f4a:	2b00      	cmp	r3, #0
 8008f4c:	d008      	beq.n	8008f60 <InitSuitesHashSigAlgo+0x2e>
    #ifdef WOLFSSL_SHA384
        AddSuiteHashSigAlgo(hashSigAlgo, sha384_mac, ecc_dsa_sa_algo, keySz,
            &idx);
    #endif
    #ifndef NO_SHA256
        AddSuiteHashSigAlgo(hashSigAlgo, sha256_mac, ecc_dsa_sa_algo, keySz,
 8008f4e:	f107 0316 	add.w	r3, r7, #22
 8008f52:	9300      	str	r3, [sp, #0]
 8008f54:	683b      	ldr	r3, [r7, #0]
 8008f56:	2203      	movs	r2, #3
 8008f58:	2104      	movs	r1, #4
 8008f5a:	68f8      	ldr	r0, [r7, #12]
 8008f5c:	f7ff ff8a 	bl	8008e74 <AddSuiteHashSigAlgo>
            keySz, &idx);
        AddSuiteHashSigAlgo(hashSigAlgo, no_mac, dilithium_level5_sa_algo,
            keySz, &idx);
    }
#endif /* HAVE_DILITHIUM */
    if (haveSig & SIG_RSA) {
 8008f60:	68bb      	ldr	r3, [r7, #8]
 8008f62:	f003 0302 	and.w	r3, r3, #2
 8008f66:	2b00      	cmp	r3, #0
 8008f68:	d014      	beq.n	8008f94 <InitSuitesHashSigAlgo+0x62>
    #ifdef WC_RSA_PSS
        if (tls1_2) {
 8008f6a:	687b      	ldr	r3, [r7, #4]
 8008f6c:	2b00      	cmp	r3, #0
 8008f6e:	d008      	beq.n	8008f82 <InitSuitesHashSigAlgo+0x50>
        #ifdef WOLFSSL_SHA384
            AddSuiteHashSigAlgo(hashSigAlgo, sha384_mac, rsa_pss_sa_algo, keySz,
                &idx);
        #endif
        #ifndef NO_SHA256
            AddSuiteHashSigAlgo(hashSigAlgo, sha256_mac, rsa_pss_sa_algo, keySz,
 8008f70:	f107 0316 	add.w	r3, r7, #22
 8008f74:	9300      	str	r3, [sp, #0]
 8008f76:	683b      	ldr	r3, [r7, #0]
 8008f78:	2208      	movs	r2, #8
 8008f7a:	2104      	movs	r1, #4
 8008f7c:	68f8      	ldr	r0, [r7, #12]
 8008f7e:	f7ff ff79 	bl	8008e74 <AddSuiteHashSigAlgo>
    #endif
    #ifdef WOLFSSL_SHA384
        AddSuiteHashSigAlgo(hashSigAlgo, sha384_mac, rsa_sa_algo, keySz, &idx);
    #endif
    #ifndef NO_SHA256
        AddSuiteHashSigAlgo(hashSigAlgo, sha256_mac, rsa_sa_algo, keySz, &idx);
 8008f82:	f107 0316 	add.w	r3, r7, #22
 8008f86:	9300      	str	r3, [sp, #0]
 8008f88:	683b      	ldr	r3, [r7, #0]
 8008f8a:	2201      	movs	r2, #1
 8008f8c:	2104      	movs	r1, #4
 8008f8e:	68f8      	ldr	r0, [r7, #12]
 8008f90:	f7ff ff70 	bl	8008e74 <AddSuiteHashSigAlgo>
        AddSuiteHashSigAlgo(hashSigAlgo, sha_mac, anonymous_sa_algo, keySz,
            &idx);
    }
#endif

    *len = idx;
 8008f94:	8afa      	ldrh	r2, [r7, #22]
 8008f96:	6a3b      	ldr	r3, [r7, #32]
 8008f98:	801a      	strh	r2, [r3, #0]
}
 8008f9a:	bf00      	nop
 8008f9c:	3718      	adds	r7, #24
 8008f9e:	46bd      	mov	sp, r7
 8008fa0:	bd80      	pop	{r7, pc}

08008fa2 <AllocateCtxSuites>:

int AllocateCtxSuites(WOLFSSL_CTX* ctx)
{
 8008fa2:	b580      	push	{r7, lr}
 8008fa4:	b082      	sub	sp, #8
 8008fa6:	af00      	add	r7, sp, #0
 8008fa8:	6078      	str	r0, [r7, #4]
    if (ctx->suites == NULL) {
 8008faa:	687b      	ldr	r3, [r7, #4]
 8008fac:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8008fae:	2b00      	cmp	r3, #0
 8008fb0:	d115      	bne.n	8008fde <AllocateCtxSuites+0x3c>
        ctx->suites = (Suites*)XMALLOC(sizeof(Suites), ctx->heap,
 8008fb2:	f44f 70ac 	mov.w	r0, #344	@ 0x158
 8008fb6:	f015 fd67 	bl	801ea88 <wolfSSL_Malloc>
 8008fba:	4602      	mov	r2, r0
 8008fbc:	687b      	ldr	r3, [r7, #4]
 8008fbe:	655a      	str	r2, [r3, #84]	@ 0x54
                                       DYNAMIC_TYPE_SUITES);
        if (ctx->suites == NULL) {
 8008fc0:	687b      	ldr	r3, [r7, #4]
 8008fc2:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8008fc4:	2b00      	cmp	r3, #0
 8008fc6:	d102      	bne.n	8008fce <AllocateCtxSuites+0x2c>
            WOLFSSL_MSG("Memory alloc for Suites failed");
            return MEMORY_ERROR;
 8008fc8:	f46f 7397 	mvn.w	r3, #302	@ 0x12e
 8008fcc:	e008      	b.n	8008fe0 <AllocateCtxSuites+0x3e>
        }
        XMEMSET(ctx->suites, 0, sizeof(Suites));
 8008fce:	687b      	ldr	r3, [r7, #4]
 8008fd0:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8008fd2:	f44f 72ac 	mov.w	r2, #344	@ 0x158
 8008fd6:	2100      	movs	r1, #0
 8008fd8:	4618      	mov	r0, r3
 8008fda:	f01f fa75 	bl	80284c8 <memset>
    }
    return 0;
 8008fde:	2300      	movs	r3, #0
}
 8008fe0:	4618      	mov	r0, r3
 8008fe2:	3708      	adds	r7, #8
 8008fe4:	46bd      	mov	sp, r7
 8008fe6:	bd80      	pop	{r7, pc}

08008fe8 <AllocateSuites>:

/* Call this when the ssl object needs to have its own ssl->suites object */
int AllocateSuites(WOLFSSL* ssl)
{
 8008fe8:	b580      	push	{r7, lr}
 8008fea:	b082      	sub	sp, #8
 8008fec:	af00      	add	r7, sp, #0
 8008fee:	6078      	str	r0, [r7, #4]
    if (ssl->suites == NULL) {
 8008ff0:	687b      	ldr	r3, [r7, #4]
 8008ff2:	685b      	ldr	r3, [r3, #4]
 8008ff4:	2b00      	cmp	r3, #0
 8008ff6:	d129      	bne.n	800904c <AllocateSuites+0x64>
        ssl->suites = (Suites*)XMALLOC(sizeof(Suites), ssl->heap,
 8008ff8:	f44f 70ac 	mov.w	r0, #344	@ 0x158
 8008ffc:	f015 fd44 	bl	801ea88 <wolfSSL_Malloc>
 8009000:	4602      	mov	r2, r0
 8009002:	687b      	ldr	r3, [r7, #4]
 8009004:	605a      	str	r2, [r3, #4]
                                       DYNAMIC_TYPE_SUITES);
        if (ssl->suites == NULL) {
 8009006:	687b      	ldr	r3, [r7, #4]
 8009008:	685b      	ldr	r3, [r3, #4]
 800900a:	2b00      	cmp	r3, #0
 800900c:	d102      	bne.n	8009014 <AllocateSuites+0x2c>
            WOLFSSL_MSG("Suites Memory error");
            return MEMORY_ERROR;
 800900e:	f46f 7397 	mvn.w	r3, #302	@ 0x12e
 8009012:	e01c      	b.n	800904e <AllocateSuites+0x66>
        }
        if (ssl->ctx != NULL && ssl->ctx->suites != NULL)
 8009014:	687b      	ldr	r3, [r7, #4]
 8009016:	681b      	ldr	r3, [r3, #0]
 8009018:	2b00      	cmp	r3, #0
 800901a:	d00f      	beq.n	800903c <AllocateSuites+0x54>
 800901c:	687b      	ldr	r3, [r7, #4]
 800901e:	681b      	ldr	r3, [r3, #0]
 8009020:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8009022:	2b00      	cmp	r3, #0
 8009024:	d00a      	beq.n	800903c <AllocateSuites+0x54>
            XMEMCPY(ssl->suites, ssl->ctx->suites, sizeof(Suites));
 8009026:	687b      	ldr	r3, [r7, #4]
 8009028:	6858      	ldr	r0, [r3, #4]
 800902a:	687b      	ldr	r3, [r7, #4]
 800902c:	681b      	ldr	r3, [r3, #0]
 800902e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8009030:	f44f 72ac 	mov.w	r2, #344	@ 0x158
 8009034:	4619      	mov	r1, r3
 8009036:	f01f fab1 	bl	802859c <memcpy>
 800903a:	e007      	b.n	800904c <AllocateSuites+0x64>
        else
            XMEMSET(ssl->suites, 0, sizeof(Suites));
 800903c:	687b      	ldr	r3, [r7, #4]
 800903e:	685b      	ldr	r3, [r3, #4]
 8009040:	f44f 72ac 	mov.w	r2, #344	@ 0x158
 8009044:	2100      	movs	r1, #0
 8009046:	4618      	mov	r0, r3
 8009048:	f01f fa3e 	bl	80284c8 <memset>
    }
    return 0;
 800904c:	2300      	movs	r3, #0
}
 800904e:	4618      	mov	r0, r3
 8009050:	3708      	adds	r7, #8
 8009052:	46bd      	mov	sp, r7
 8009054:	bd80      	pop	{r7, pc}

08009056 <InitSuites>:
void InitSuites(Suites* suites, ProtocolVersion pv, int keySz, word16 haveRSA,
                word16 havePSK, word16 haveDH, word16 haveECDSAsig,
                word16 haveECC, word16 haveStaticRSA, word16 haveStaticECC,
                word16 haveAnon, word16 haveNull, word16 haveAES128,
                word16 haveSHA1, word16 haveRC4, int side)
{
 8009056:	b580      	push	{r7, lr}
 8009058:	b08c      	sub	sp, #48	@ 0x30
 800905a:	af02      	add	r7, sp, #8
 800905c:	60f8      	str	r0, [r7, #12]
 800905e:	8139      	strh	r1, [r7, #8]
 8009060:	607a      	str	r2, [r7, #4]
 8009062:	807b      	strh	r3, [r7, #2]
    word16 idx = 0;
 8009064:	2300      	movs	r3, #0
 8009066:	84fb      	strh	r3, [r7, #38]	@ 0x26
    int    tls    = pv.major == SSLv3_MAJOR && pv.minor >= TLSv1_MINOR;
 8009068:	7a3b      	ldrb	r3, [r7, #8]
 800906a:	2b03      	cmp	r3, #3
 800906c:	d104      	bne.n	8009078 <InitSuites+0x22>
 800906e:	7a7b      	ldrb	r3, [r7, #9]
 8009070:	2b00      	cmp	r3, #0
 8009072:	d001      	beq.n	8009078 <InitSuites+0x22>
 8009074:	2301      	movs	r3, #1
 8009076:	e000      	b.n	800907a <InitSuites+0x24>
 8009078:	2300      	movs	r3, #0
 800907a:	623b      	str	r3, [r7, #32]
    int    tls1_2 = pv.major == SSLv3_MAJOR && pv.minor >= TLSv1_2_MINOR;
 800907c:	7a3b      	ldrb	r3, [r7, #8]
 800907e:	2b03      	cmp	r3, #3
 8009080:	d104      	bne.n	800908c <InitSuites+0x36>
 8009082:	7a7b      	ldrb	r3, [r7, #9]
 8009084:	2b02      	cmp	r3, #2
 8009086:	d901      	bls.n	800908c <InitSuites+0x36>
 8009088:	2301      	movs	r3, #1
 800908a:	e000      	b.n	800908e <InitSuites+0x38>
 800908c:	2300      	movs	r3, #0
 800908e:	61fb      	str	r3, [r7, #28]
#ifdef WOLFSSL_TLS13
    int    tls1_3 = IsAtLeastTLSv1_3(pv);
 8009090:	68b8      	ldr	r0, [r7, #8]
 8009092:	f7ff fc3b 	bl	800890c <IsAtLeastTLSv1_3>
 8009096:	61b8      	str	r0, [r7, #24]
#endif
    int    dtls   = 0;
 8009098:	2300      	movs	r3, #0
 800909a:	617b      	str	r3, [r7, #20]
    int    haveRSAsig = 1;
 800909c:	2301      	movs	r3, #1
 800909e:	613b      	str	r3, [r7, #16]
    (void)haveNull;
    (void)haveAES128;
    (void)haveSHA1;
    (void)haveRC4;

    if (suites == NULL) {
 80090a0:	68fb      	ldr	r3, [r7, #12]
 80090a2:	2b00      	cmp	r3, #0
 80090a4:	f000 81bc 	beq.w	8009420 <InitSuites+0x3ca>
        WOLFSSL_MSG("InitSuites pointer error");
        return;
    }

    if (suites->setSuites)
 80090a8:	68fb      	ldr	r3, [r7, #12]
 80090aa:	f893 3156 	ldrb.w	r3, [r3, #342]	@ 0x156
 80090ae:	f003 0301 	and.w	r3, r3, #1
 80090b2:	b2db      	uxtb	r3, r3
 80090b4:	2b00      	cmp	r3, #0
 80090b6:	f040 81b5 	bne.w	8009424 <InitSuites+0x3ce>
        suites->suites[idx++] = TLS_AES_256_GCM_SHA384;
    }
#endif

#ifdef BUILD_TLS_AES_128_GCM_SHA256
    if (tls1_3 && haveAES128) {
 80090ba:	69bb      	ldr	r3, [r7, #24]
 80090bc:	2b00      	cmp	r3, #0
 80090be:	d013      	beq.n	80090e8 <InitSuites+0x92>
 80090c0:	f8b7 3050 	ldrh.w	r3, [r7, #80]	@ 0x50
 80090c4:	2b00      	cmp	r3, #0
 80090c6:	d00f      	beq.n	80090e8 <InitSuites+0x92>
        suites->suites[idx++] = TLS13_BYTE;
 80090c8:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80090ca:	1c5a      	adds	r2, r3, #1
 80090cc:	84fa      	strh	r2, [r7, #38]	@ 0x26
 80090ce:	461a      	mov	r2, r3
 80090d0:	68fb      	ldr	r3, [r7, #12]
 80090d2:	4413      	add	r3, r2
 80090d4:	2213      	movs	r2, #19
 80090d6:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_AES_128_GCM_SHA256;
 80090d8:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80090da:	1c5a      	adds	r2, r3, #1
 80090dc:	84fa      	strh	r2, [r7, #38]	@ 0x26
 80090de:	461a      	mov	r2, r3
 80090e0:	68fb      	ldr	r3, [r7, #12]
 80090e2:	4413      	add	r3, r2
 80090e4:	2201      	movs	r2, #1
 80090e6:	711a      	strb	r2, [r3, #4]
    }
#endif

#ifdef BUILD_TLS_CHACHA20_POLY1305_SHA256
    if (tls1_3) {
 80090e8:	69bb      	ldr	r3, [r7, #24]
 80090ea:	2b00      	cmp	r3, #0
 80090ec:	d00f      	beq.n	800910e <InitSuites+0xb8>
        suites->suites[idx++] = TLS13_BYTE;
 80090ee:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80090f0:	1c5a      	adds	r2, r3, #1
 80090f2:	84fa      	strh	r2, [r7, #38]	@ 0x26
 80090f4:	461a      	mov	r2, r3
 80090f6:	68fb      	ldr	r3, [r7, #12]
 80090f8:	4413      	add	r3, r2
 80090fa:	2213      	movs	r2, #19
 80090fc:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_CHACHA20_POLY1305_SHA256;
 80090fe:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8009100:	1c5a      	adds	r2, r3, #1
 8009102:	84fa      	strh	r2, [r7, #38]	@ 0x26
 8009104:	461a      	mov	r2, r3
 8009106:	68fb      	ldr	r3, [r7, #12]
 8009108:	4413      	add	r3, r2
 800910a:	2203      	movs	r2, #3
 800910c:	711a      	strb	r2, [r3, #4]
#endif /* WOLFSSL_TLS13 */

#ifndef WOLFSSL_NO_TLS12

#if !defined(NO_WOLFSSL_SERVER) && !defined(NO_RSA)
    if (side == WOLFSSL_SERVER_END && haveStaticECC) {
 800910e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8009110:	2b00      	cmp	r3, #0
 8009112:	d105      	bne.n	8009120 <InitSuites+0xca>
 8009114:	f8b7 3044 	ldrh.w	r3, [r7, #68]	@ 0x44
 8009118:	2b00      	cmp	r3, #0
 800911a:	d001      	beq.n	8009120 <InitSuites+0xca>
        haveRSA = 0;   /* can't do RSA with ECDSA key */
 800911c:	2300      	movs	r3, #0
 800911e:	807b      	strh	r3, [r7, #2]
    }

    if (side == WOLFSSL_SERVER_END && haveECDSAsig) {
 8009120:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8009122:	2b00      	cmp	r3, #0
 8009124:	d104      	bne.n	8009130 <InitSuites+0xda>
 8009126:	8f3b      	ldrh	r3, [r7, #56]	@ 0x38
 8009128:	2b00      	cmp	r3, #0
 800912a:	d001      	beq.n	8009130 <InitSuites+0xda>
        haveRSAsig = 0;     /* can't have RSA sig if signed by ECDSA */
 800912c:	2300      	movs	r3, #0
 800912e:	613b      	str	r3, [r7, #16]
        suites->suites[idx++] = TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384;
    }
#endif

#ifdef BUILD_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
    if (tls1_2 && haveECC && haveAES128) {
 8009130:	69fb      	ldr	r3, [r7, #28]
 8009132:	2b00      	cmp	r3, #0
 8009134:	d016      	beq.n	8009164 <InitSuites+0x10e>
 8009136:	8fbb      	ldrh	r3, [r7, #60]	@ 0x3c
 8009138:	2b00      	cmp	r3, #0
 800913a:	d013      	beq.n	8009164 <InitSuites+0x10e>
 800913c:	f8b7 3050 	ldrh.w	r3, [r7, #80]	@ 0x50
 8009140:	2b00      	cmp	r3, #0
 8009142:	d00f      	beq.n	8009164 <InitSuites+0x10e>
        suites->suites[idx++] = ECC_BYTE;
 8009144:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8009146:	1c5a      	adds	r2, r3, #1
 8009148:	84fa      	strh	r2, [r7, #38]	@ 0x26
 800914a:	461a      	mov	r2, r3
 800914c:	68fb      	ldr	r3, [r7, #12]
 800914e:	4413      	add	r3, r2
 8009150:	22c0      	movs	r2, #192	@ 0xc0
 8009152:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256;
 8009154:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8009156:	1c5a      	adds	r2, r3, #1
 8009158:	84fa      	strh	r2, [r7, #38]	@ 0x26
 800915a:	461a      	mov	r2, r3
 800915c:	68fb      	ldr	r3, [r7, #12]
 800915e:	4413      	add	r3, r2
 8009160:	222b      	movs	r2, #43	@ 0x2b
 8009162:	711a      	strb	r2, [r3, #4]
    }
#endif

#ifdef BUILD_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
    #ifdef OPENSSL_EXTRA
    if ((tls1_2 && haveRSA && haveAES128) ||
 8009164:	69fb      	ldr	r3, [r7, #28]
 8009166:	2b00      	cmp	r3, #0
 8009168:	d006      	beq.n	8009178 <InitSuites+0x122>
 800916a:	887b      	ldrh	r3, [r7, #2]
 800916c:	2b00      	cmp	r3, #0
 800916e:	d003      	beq.n	8009178 <InitSuites+0x122>
 8009170:	f8b7 3050 	ldrh.w	r3, [r7, #80]	@ 0x50
 8009174:	2b00      	cmp	r3, #0
 8009176:	d109      	bne.n	800918c <InitSuites+0x136>
 8009178:	69fb      	ldr	r3, [r7, #28]
 800917a:	2b00      	cmp	r3, #0
 800917c:	d016      	beq.n	80091ac <InitSuites+0x156>
        (tls1_2 && haveECDSAsig && haveAES128)) {
 800917e:	8f3b      	ldrh	r3, [r7, #56]	@ 0x38
 8009180:	2b00      	cmp	r3, #0
 8009182:	d013      	beq.n	80091ac <InitSuites+0x156>
 8009184:	f8b7 3050 	ldrh.w	r3, [r7, #80]	@ 0x50
 8009188:	2b00      	cmp	r3, #0
 800918a:	d00f      	beq.n	80091ac <InitSuites+0x156>
    #else
    if (tls1_2 && haveRSA && haveAES128) {
    #endif
        suites->suites[idx++] = ECC_BYTE;
 800918c:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 800918e:	1c5a      	adds	r2, r3, #1
 8009190:	84fa      	strh	r2, [r7, #38]	@ 0x26
 8009192:	461a      	mov	r2, r3
 8009194:	68fb      	ldr	r3, [r7, #12]
 8009196:	4413      	add	r3, r2
 8009198:	22c0      	movs	r2, #192	@ 0xc0
 800919a:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256;
 800919c:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 800919e:	1c5a      	adds	r2, r3, #1
 80091a0:	84fa      	strh	r2, [r7, #38]	@ 0x26
 80091a2:	461a      	mov	r2, r3
 80091a4:	68fb      	ldr	r3, [r7, #12]
 80091a6:	4413      	add	r3, r2
 80091a8:	222f      	movs	r2, #47	@ 0x2f
 80091aa:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_DHE_RSA_WITH_AES_256_GCM_SHA384;
    }
#endif

#ifdef BUILD_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256
    if (tls1_2 && haveDH && haveRSA && haveAES128) {
 80091ac:	69fb      	ldr	r3, [r7, #28]
 80091ae:	2b00      	cmp	r3, #0
 80091b0:	d019      	beq.n	80091e6 <InitSuites+0x190>
 80091b2:	8ebb      	ldrh	r3, [r7, #52]	@ 0x34
 80091b4:	2b00      	cmp	r3, #0
 80091b6:	d016      	beq.n	80091e6 <InitSuites+0x190>
 80091b8:	887b      	ldrh	r3, [r7, #2]
 80091ba:	2b00      	cmp	r3, #0
 80091bc:	d013      	beq.n	80091e6 <InitSuites+0x190>
 80091be:	f8b7 3050 	ldrh.w	r3, [r7, #80]	@ 0x50
 80091c2:	2b00      	cmp	r3, #0
 80091c4:	d00f      	beq.n	80091e6 <InitSuites+0x190>
        suites->suites[idx++] = CIPHER_BYTE;
 80091c6:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80091c8:	1c5a      	adds	r2, r3, #1
 80091ca:	84fa      	strh	r2, [r7, #38]	@ 0x26
 80091cc:	461a      	mov	r2, r3
 80091ce:	68fb      	ldr	r3, [r7, #12]
 80091d0:	4413      	add	r3, r2
 80091d2:	2200      	movs	r2, #0
 80091d4:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_DHE_RSA_WITH_AES_128_GCM_SHA256;
 80091d6:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80091d8:	1c5a      	adds	r2, r3, #1
 80091da:	84fa      	strh	r2, [r7, #38]	@ 0x26
 80091dc:	461a      	mov	r2, r3
 80091de:	68fb      	ldr	r3, [r7, #12]
 80091e0:	4413      	add	r3, r2
 80091e2:	229e      	movs	r2, #158	@ 0x9e
 80091e4:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_PSK_WITH_AES_128_GCM_SHA256;
    }
#endif

#ifdef BUILD_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
    if (tls1_2 && haveECC) {
 80091e6:	69fb      	ldr	r3, [r7, #28]
 80091e8:	2b00      	cmp	r3, #0
 80091ea:	d012      	beq.n	8009212 <InitSuites+0x1bc>
 80091ec:	8fbb      	ldrh	r3, [r7, #60]	@ 0x3c
 80091ee:	2b00      	cmp	r3, #0
 80091f0:	d00f      	beq.n	8009212 <InitSuites+0x1bc>
        suites->suites[idx++] = CHACHA_BYTE;
 80091f2:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80091f4:	1c5a      	adds	r2, r3, #1
 80091f6:	84fa      	strh	r2, [r7, #38]	@ 0x26
 80091f8:	461a      	mov	r2, r3
 80091fa:	68fb      	ldr	r3, [r7, #12]
 80091fc:	4413      	add	r3, r2
 80091fe:	22cc      	movs	r2, #204	@ 0xcc
 8009200:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256;
 8009202:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8009204:	1c5a      	adds	r2, r3, #1
 8009206:	84fa      	strh	r2, [r7, #38]	@ 0x26
 8009208:	461a      	mov	r2, r3
 800920a:	68fb      	ldr	r3, [r7, #12]
 800920c:	4413      	add	r3, r2
 800920e:	22a9      	movs	r2, #169	@ 0xa9
 8009210:	711a      	strb	r2, [r3, #4]
    }
#endif

#ifdef BUILD_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
    #ifdef OPENSSL_EXTRA
    if ((tls1_2 && haveRSA) || (tls1_2 && haveECDSAsig)) {
 8009212:	69fb      	ldr	r3, [r7, #28]
 8009214:	2b00      	cmp	r3, #0
 8009216:	d002      	beq.n	800921e <InitSuites+0x1c8>
 8009218:	887b      	ldrh	r3, [r7, #2]
 800921a:	2b00      	cmp	r3, #0
 800921c:	d105      	bne.n	800922a <InitSuites+0x1d4>
 800921e:	69fb      	ldr	r3, [r7, #28]
 8009220:	2b00      	cmp	r3, #0
 8009222:	d012      	beq.n	800924a <InitSuites+0x1f4>
 8009224:	8f3b      	ldrh	r3, [r7, #56]	@ 0x38
 8009226:	2b00      	cmp	r3, #0
 8009228:	d00f      	beq.n	800924a <InitSuites+0x1f4>
    #else
    if (tls1_2 && haveRSA) {
    #endif
        suites->suites[idx++] = CHACHA_BYTE;
 800922a:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 800922c:	1c5a      	adds	r2, r3, #1
 800922e:	84fa      	strh	r2, [r7, #38]	@ 0x26
 8009230:	461a      	mov	r2, r3
 8009232:	68fb      	ldr	r3, [r7, #12]
 8009234:	4413      	add	r3, r2
 8009236:	22cc      	movs	r2, #204	@ 0xcc
 8009238:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256;
 800923a:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 800923c:	1c5a      	adds	r2, r3, #1
 800923e:	84fa      	strh	r2, [r7, #38]	@ 0x26
 8009240:	461a      	mov	r2, r3
 8009242:	68fb      	ldr	r3, [r7, #12]
 8009244:	4413      	add	r3, r2
 8009246:	22a8      	movs	r2, #168	@ 0xa8
 8009248:	711a      	strb	r2, [r3, #4]
    }
#endif

#ifdef BUILD_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256
    if (tls1_2 && haveRSA) {
 800924a:	69fb      	ldr	r3, [r7, #28]
 800924c:	2b00      	cmp	r3, #0
 800924e:	d012      	beq.n	8009276 <InitSuites+0x220>
 8009250:	887b      	ldrh	r3, [r7, #2]
 8009252:	2b00      	cmp	r3, #0
 8009254:	d00f      	beq.n	8009276 <InitSuites+0x220>
        suites->suites[idx++] = CHACHA_BYTE;
 8009256:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8009258:	1c5a      	adds	r2, r3, #1
 800925a:	84fa      	strh	r2, [r7, #38]	@ 0x26
 800925c:	461a      	mov	r2, r3
 800925e:	68fb      	ldr	r3, [r7, #12]
 8009260:	4413      	add	r3, r2
 8009262:	22cc      	movs	r2, #204	@ 0xcc
 8009264:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256;
 8009266:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8009268:	1c5a      	adds	r2, r3, #1
 800926a:	84fa      	strh	r2, [r7, #38]	@ 0x26
 800926c:	461a      	mov	r2, r3
 800926e:	68fb      	ldr	r3, [r7, #12]
 8009270:	4413      	add	r3, r2
 8009272:	22aa      	movs	r2, #170	@ 0xaa
 8009274:	711a      	strb	r2, [r3, #4]
#endif
#endif

#ifdef BUILD_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256
    #ifdef OPENSSL_EXTRA
    if ((tls1_2 && haveRSA && haveAES128) ||
 8009276:	69fb      	ldr	r3, [r7, #28]
 8009278:	2b00      	cmp	r3, #0
 800927a:	d006      	beq.n	800928a <InitSuites+0x234>
 800927c:	887b      	ldrh	r3, [r7, #2]
 800927e:	2b00      	cmp	r3, #0
 8009280:	d003      	beq.n	800928a <InitSuites+0x234>
 8009282:	f8b7 3050 	ldrh.w	r3, [r7, #80]	@ 0x50
 8009286:	2b00      	cmp	r3, #0
 8009288:	d109      	bne.n	800929e <InitSuites+0x248>
 800928a:	69fb      	ldr	r3, [r7, #28]
 800928c:	2b00      	cmp	r3, #0
 800928e:	d016      	beq.n	80092be <InitSuites+0x268>
        (tls1_2 && haveECDSAsig && haveAES128)) {
 8009290:	8f3b      	ldrh	r3, [r7, #56]	@ 0x38
 8009292:	2b00      	cmp	r3, #0
 8009294:	d013      	beq.n	80092be <InitSuites+0x268>
 8009296:	f8b7 3050 	ldrh.w	r3, [r7, #80]	@ 0x50
 800929a:	2b00      	cmp	r3, #0
 800929c:	d00f      	beq.n	80092be <InitSuites+0x268>
    #else
    if (tls1_2 && haveRSA && haveAES128) {
    #endif
        suites->suites[idx++] = ECC_BYTE;
 800929e:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80092a0:	1c5a      	adds	r2, r3, #1
 80092a2:	84fa      	strh	r2, [r7, #38]	@ 0x26
 80092a4:	461a      	mov	r2, r3
 80092a6:	68fb      	ldr	r3, [r7, #12]
 80092a8:	4413      	add	r3, r2
 80092aa:	22c0      	movs	r2, #192	@ 0xc0
 80092ac:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256;
 80092ae:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80092b0:	1c5a      	adds	r2, r3, #1
 80092b2:	84fa      	strh	r2, [r7, #38]	@ 0x26
 80092b4:	461a      	mov	r2, r3
 80092b6:	68fb      	ldr	r3, [r7, #12]
 80092b8:	4413      	add	r3, r2
 80092ba:	2227      	movs	r2, #39	@ 0x27
 80092bc:	711a      	strb	r2, [r3, #4]
    }
#endif

#ifdef BUILD_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256
    if (tls1_2 && haveECC && haveAES128) {
 80092be:	69fb      	ldr	r3, [r7, #28]
 80092c0:	2b00      	cmp	r3, #0
 80092c2:	d016      	beq.n	80092f2 <InitSuites+0x29c>
 80092c4:	8fbb      	ldrh	r3, [r7, #60]	@ 0x3c
 80092c6:	2b00      	cmp	r3, #0
 80092c8:	d013      	beq.n	80092f2 <InitSuites+0x29c>
 80092ca:	f8b7 3050 	ldrh.w	r3, [r7, #80]	@ 0x50
 80092ce:	2b00      	cmp	r3, #0
 80092d0:	d00f      	beq.n	80092f2 <InitSuites+0x29c>
        suites->suites[idx++] = ECC_BYTE;
 80092d2:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80092d4:	1c5a      	adds	r2, r3, #1
 80092d6:	84fa      	strh	r2, [r7, #38]	@ 0x26
 80092d8:	461a      	mov	r2, r3
 80092da:	68fb      	ldr	r3, [r7, #12]
 80092dc:	4413      	add	r3, r2
 80092de:	22c0      	movs	r2, #192	@ 0xc0
 80092e0:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256;
 80092e2:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80092e4:	1c5a      	adds	r2, r3, #1
 80092e6:	84fa      	strh	r2, [r7, #38]	@ 0x26
 80092e8:	461a      	mov	r2, r3
 80092ea:	68fb      	ldr	r3, [r7, #12]
 80092ec:	4413      	add	r3, r2
 80092ee:	2223      	movs	r2, #35	@ 0x23
 80092f0:	711a      	strb	r2, [r3, #4]
    }
#endif

#ifdef BUILD_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256
#ifndef WOLFSSL_OLDTLS_SHA2_CIPHERSUITES
    if (tls1_2 && haveDH && haveRSA)
 80092f2:	69fb      	ldr	r3, [r7, #28]
 80092f4:	2b00      	cmp	r3, #0
 80092f6:	d015      	beq.n	8009324 <InitSuites+0x2ce>
 80092f8:	8ebb      	ldrh	r3, [r7, #52]	@ 0x34
 80092fa:	2b00      	cmp	r3, #0
 80092fc:	d012      	beq.n	8009324 <InitSuites+0x2ce>
 80092fe:	887b      	ldrh	r3, [r7, #2]
 8009300:	2b00      	cmp	r3, #0
 8009302:	d00f      	beq.n	8009324 <InitSuites+0x2ce>
#else
    if (tls && haveDH && haveRSA)
#endif
    {
        suites->suites[idx++] = CIPHER_BYTE;
 8009304:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8009306:	1c5a      	adds	r2, r3, #1
 8009308:	84fa      	strh	r2, [r7, #38]	@ 0x26
 800930a:	461a      	mov	r2, r3
 800930c:	68fb      	ldr	r3, [r7, #12]
 800930e:	4413      	add	r3, r2
 8009310:	2200      	movs	r2, #0
 8009312:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_DHE_RSA_WITH_AES_256_CBC_SHA256;
 8009314:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8009316:	1c5a      	adds	r2, r3, #1
 8009318:	84fa      	strh	r2, [r7, #38]	@ 0x26
 800931a:	461a      	mov	r2, r3
 800931c:	68fb      	ldr	r3, [r7, #12]
 800931e:	4413      	add	r3, r2
 8009320:	226b      	movs	r2, #107	@ 0x6b
 8009322:	711a      	strb	r2, [r3, #4]
    }
#endif

#ifdef BUILD_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256
#ifndef WOLFSSL_OLDTLS_SHA2_CIPHERSUITES
    if (tls1_2 && haveDH && haveRSA && haveAES128)
 8009324:	69fb      	ldr	r3, [r7, #28]
 8009326:	2b00      	cmp	r3, #0
 8009328:	d019      	beq.n	800935e <InitSuites+0x308>
 800932a:	8ebb      	ldrh	r3, [r7, #52]	@ 0x34
 800932c:	2b00      	cmp	r3, #0
 800932e:	d016      	beq.n	800935e <InitSuites+0x308>
 8009330:	887b      	ldrh	r3, [r7, #2]
 8009332:	2b00      	cmp	r3, #0
 8009334:	d013      	beq.n	800935e <InitSuites+0x308>
 8009336:	f8b7 3050 	ldrh.w	r3, [r7, #80]	@ 0x50
 800933a:	2b00      	cmp	r3, #0
 800933c:	d00f      	beq.n	800935e <InitSuites+0x308>
#else
    if (tls && haveDH && haveRSA && haveAES128)
#endif
    {
        suites->suites[idx++] = CIPHER_BYTE;
 800933e:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8009340:	1c5a      	adds	r2, r3, #1
 8009342:	84fa      	strh	r2, [r7, #38]	@ 0x26
 8009344:	461a      	mov	r2, r3
 8009346:	68fb      	ldr	r3, [r7, #12]
 8009348:	4413      	add	r3, r2
 800934a:	2200      	movs	r2, #0
 800934c:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_DHE_RSA_WITH_AES_128_CBC_SHA256;
 800934e:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8009350:	1c5a      	adds	r2, r3, #1
 8009352:	84fa      	strh	r2, [r7, #38]	@ 0x26
 8009354:	461a      	mov	r2, r3
 8009356:	68fb      	ldr	r3, [r7, #12]
 8009358:	4413      	add	r3, r2
 800935a:	2267      	movs	r2, #103	@ 0x67
 800935c:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_RSA_WITH_AES_128_CBC_SHA;
    }
#endif

#ifdef BUILD_TLS_ECDHE_ECDSA_WITH_CHACHA20_OLD_POLY1305_SHA256
    if (tls1_2 && haveECC) {
 800935e:	69fb      	ldr	r3, [r7, #28]
 8009360:	2b00      	cmp	r3, #0
 8009362:	d012      	beq.n	800938a <InitSuites+0x334>
 8009364:	8fbb      	ldrh	r3, [r7, #60]	@ 0x3c
 8009366:	2b00      	cmp	r3, #0
 8009368:	d00f      	beq.n	800938a <InitSuites+0x334>
        suites->suites[idx++] = CHACHA_BYTE;
 800936a:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 800936c:	1c5a      	adds	r2, r3, #1
 800936e:	84fa      	strh	r2, [r7, #38]	@ 0x26
 8009370:	461a      	mov	r2, r3
 8009372:	68fb      	ldr	r3, [r7, #12]
 8009374:	4413      	add	r3, r2
 8009376:	22cc      	movs	r2, #204	@ 0xcc
 8009378:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] =
 800937a:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 800937c:	1c5a      	adds	r2, r3, #1
 800937e:	84fa      	strh	r2, [r7, #38]	@ 0x26
 8009380:	461a      	mov	r2, r3
 8009382:	68fb      	ldr	r3, [r7, #12]
 8009384:	4413      	add	r3, r2
 8009386:	2214      	movs	r2, #20
 8009388:	711a      	strb	r2, [r3, #4]
    }
#endif

#ifdef BUILD_TLS_ECDHE_RSA_WITH_CHACHA20_OLD_POLY1305_SHA256
    #ifdef OPENSSL_EXTRA
    if ((tls1_2 && haveRSA) || (tls1_2 && haveECDSAsig)) {
 800938a:	69fb      	ldr	r3, [r7, #28]
 800938c:	2b00      	cmp	r3, #0
 800938e:	d002      	beq.n	8009396 <InitSuites+0x340>
 8009390:	887b      	ldrh	r3, [r7, #2]
 8009392:	2b00      	cmp	r3, #0
 8009394:	d105      	bne.n	80093a2 <InitSuites+0x34c>
 8009396:	69fb      	ldr	r3, [r7, #28]
 8009398:	2b00      	cmp	r3, #0
 800939a:	d012      	beq.n	80093c2 <InitSuites+0x36c>
 800939c:	8f3b      	ldrh	r3, [r7, #56]	@ 0x38
 800939e:	2b00      	cmp	r3, #0
 80093a0:	d00f      	beq.n	80093c2 <InitSuites+0x36c>
    #else
    if (tls1_2 && haveRSA) {
    #endif
        suites->suites[idx++] = CHACHA_BYTE;
 80093a2:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80093a4:	1c5a      	adds	r2, r3, #1
 80093a6:	84fa      	strh	r2, [r7, #38]	@ 0x26
 80093a8:	461a      	mov	r2, r3
 80093aa:	68fb      	ldr	r3, [r7, #12]
 80093ac:	4413      	add	r3, r2
 80093ae:	22cc      	movs	r2, #204	@ 0xcc
 80093b0:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_ECDHE_RSA_WITH_CHACHA20_OLD_POLY1305_SHA256;
 80093b2:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80093b4:	1c5a      	adds	r2, r3, #1
 80093b6:	84fa      	strh	r2, [r7, #38]	@ 0x26
 80093b8:	461a      	mov	r2, r3
 80093ba:	68fb      	ldr	r3, [r7, #12]
 80093bc:	4413      	add	r3, r2
 80093be:	2213      	movs	r2, #19
 80093c0:	711a      	strb	r2, [r3, #4]
    }
#endif

#ifdef BUILD_TLS_DHE_RSA_WITH_CHACHA20_OLD_POLY1305_SHA256
    #ifdef OPENSSL_EXTRA
    if ((tls1_2 && haveRSA) || (tls1_2 && haveECDSAsig)) {
 80093c2:	69fb      	ldr	r3, [r7, #28]
 80093c4:	2b00      	cmp	r3, #0
 80093c6:	d002      	beq.n	80093ce <InitSuites+0x378>
 80093c8:	887b      	ldrh	r3, [r7, #2]
 80093ca:	2b00      	cmp	r3, #0
 80093cc:	d105      	bne.n	80093da <InitSuites+0x384>
 80093ce:	69fb      	ldr	r3, [r7, #28]
 80093d0:	2b00      	cmp	r3, #0
 80093d2:	d012      	beq.n	80093fa <InitSuites+0x3a4>
 80093d4:	8f3b      	ldrh	r3, [r7, #56]	@ 0x38
 80093d6:	2b00      	cmp	r3, #0
 80093d8:	d00f      	beq.n	80093fa <InitSuites+0x3a4>
    #else
    if (tls1_2 && haveRSA) {
    #endif
        suites->suites[idx++] = CHACHA_BYTE;
 80093da:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80093dc:	1c5a      	adds	r2, r3, #1
 80093de:	84fa      	strh	r2, [r7, #38]	@ 0x26
 80093e0:	461a      	mov	r2, r3
 80093e2:	68fb      	ldr	r3, [r7, #12]
 80093e4:	4413      	add	r3, r2
 80093e6:	22cc      	movs	r2, #204	@ 0xcc
 80093e8:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_DHE_RSA_WITH_CHACHA20_OLD_POLY1305_SHA256;
 80093ea:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80093ec:	1c5a      	adds	r2, r3, #1
 80093ee:	84fa      	strh	r2, [r7, #38]	@ 0x26
 80093f0:	461a      	mov	r2, r3
 80093f2:	68fb      	ldr	r3, [r7, #12]
 80093f4:	4413      	add	r3, r2
 80093f6:	2215      	movs	r2, #21
 80093f8:	711a      	strb	r2, [r3, #4]
    }
#endif

#endif /* !WOLFSSL_NO_TLS12 */

    suites->suiteSz = idx;
 80093fa:	68fb      	ldr	r3, [r7, #12]
 80093fc:	8cfa      	ldrh	r2, [r7, #38]	@ 0x26
 80093fe:	801a      	strh	r2, [r3, #0]

    if (suites->hashSigAlgoSz == 0) {
 8009400:	68fb      	ldr	r3, [r7, #12]
 8009402:	885b      	ldrh	r3, [r3, #2]
 8009404:	2b00      	cmp	r3, #0
 8009406:	d10e      	bne.n	8009426 <InitSuites+0x3d0>
        InitSuitesHashSigAlgo(suites->hashSigAlgo, SIG_ALL, tls1_2, keySz,
 8009408:	68fb      	ldr	r3, [r7, #12]
 800940a:	f503 7098 	add.w	r0, r3, #304	@ 0x130
 800940e:	68fb      	ldr	r3, [r7, #12]
 8009410:	3302      	adds	r3, #2
 8009412:	9300      	str	r3, [sp, #0]
 8009414:	687b      	ldr	r3, [r7, #4]
 8009416:	69fa      	ldr	r2, [r7, #28]
 8009418:	211f      	movs	r1, #31
 800941a:	f7ff fd8a 	bl	8008f32 <InitSuitesHashSigAlgo>
 800941e:	e002      	b.n	8009426 <InitSuites+0x3d0>
        return;
 8009420:	bf00      	nop
 8009422:	e000      	b.n	8009426 <InitSuites+0x3d0>
        return;      /* trust user settings, don't override */
 8009424:	bf00      	nop
    (void)side;
    (void)haveRSA;    /* some builds won't read */
    (void)haveRSAsig; /* non ecc builds won't read */
    (void)haveAnon;   /* anon ciphers optional */
    (void)haveNull;
}
 8009426:	3728      	adds	r7, #40	@ 0x28
 8009428:	46bd      	mov	sp, r7
 800942a:	bd80      	pop	{r7, pc}

0800942c <InitX509Name>:
#endif /* !WOLFSSL_NO_TLS12 */

#ifndef NO_CERTS

void InitX509Name(WOLFSSL_X509_NAME* name, int dynamicFlag, void* heap)
{
 800942c:	b580      	push	{r7, lr}
 800942e:	b084      	sub	sp, #16
 8009430:	af00      	add	r7, sp, #0
 8009432:	60f8      	str	r0, [r7, #12]
 8009434:	60b9      	str	r1, [r7, #8]
 8009436:	607a      	str	r2, [r7, #4]
    (void)dynamicFlag;

    if (name != NULL) {
 8009438:	68fb      	ldr	r3, [r7, #12]
 800943a:	2b00      	cmp	r3, #0
 800943c:	d011      	beq.n	8009462 <InitX509Name+0x36>
        XMEMSET(name, 0, sizeof(WOLFSSL_X509_NAME));
 800943e:	f240 520c 	movw	r2, #1292	@ 0x50c
 8009442:	2100      	movs	r1, #0
 8009444:	68f8      	ldr	r0, [r7, #12]
 8009446:	f01f f83f 	bl	80284c8 <memset>
        name->name        = name->staticName;
 800944a:	68fb      	ldr	r3, [r7, #12]
 800944c:	f103 020c 	add.w	r2, r3, #12
 8009450:	68fb      	ldr	r3, [r7, #12]
 8009452:	601a      	str	r2, [r3, #0]
        name->heap = heap;
 8009454:	68fb      	ldr	r3, [r7, #12]
 8009456:	687a      	ldr	r2, [r7, #4]
 8009458:	f8c3 2508 	str.w	r2, [r3, #1288]	@ 0x508
        name->dynamicName = 0;
 800945c:	68fb      	ldr	r3, [r7, #12]
 800945e:	2200      	movs	r2, #0
 8009460:	605a      	str	r2, [r3, #4]
    }
}
 8009462:	bf00      	nop
 8009464:	3710      	adds	r7, #16
 8009466:	46bd      	mov	sp, r7
 8009468:	bd80      	pop	{r7, pc}

0800946a <FreeX509Name>:


void FreeX509Name(WOLFSSL_X509_NAME* name)
{
 800946a:	b580      	push	{r7, lr}
 800946c:	b084      	sub	sp, #16
 800946e:	af00      	add	r7, sp, #0
 8009470:	6078      	str	r0, [r7, #4]
    if (name != NULL) {
 8009472:	687b      	ldr	r3, [r7, #4]
 8009474:	2b00      	cmp	r3, #0
 8009476:	d059      	beq.n	800952c <FreeX509Name+0xc2>
        if (name->dynamicName) {
 8009478:	687b      	ldr	r3, [r7, #4]
 800947a:	685b      	ldr	r3, [r3, #4]
 800947c:	2b00      	cmp	r3, #0
 800947e:	d00b      	beq.n	8009498 <FreeX509Name+0x2e>
            XFREE(name->name, name->heap, DYNAMIC_TYPE_SUBJECT_CN);
 8009480:	687b      	ldr	r3, [r7, #4]
 8009482:	681b      	ldr	r3, [r3, #0]
 8009484:	60bb      	str	r3, [r7, #8]
 8009486:	68bb      	ldr	r3, [r7, #8]
 8009488:	2b00      	cmp	r3, #0
 800948a:	d002      	beq.n	8009492 <FreeX509Name+0x28>
 800948c:	68b8      	ldr	r0, [r7, #8]
 800948e:	f015 fb17 	bl	801eac0 <wolfSSL_Free>
            name->name = NULL;
 8009492:	687b      	ldr	r3, [r7, #4]
 8009494:	2200      	movs	r2, #0
 8009496:	601a      	str	r2, [r3, #0]
        }
#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
        {
            int i;
            for (i = 0; i < MAX_NAME_ENTRIES; i++) {
 8009498:	2300      	movs	r3, #0
 800949a:	60fb      	str	r3, [r7, #12]
 800949c:	e043      	b.n	8009526 <FreeX509Name+0xbc>
                if (name->entry[i].object != NULL)
 800949e:	6879      	ldr	r1, [r7, #4]
 80094a0:	68fa      	ldr	r2, [r7, #12]
 80094a2:	4613      	mov	r3, r2
 80094a4:	009b      	lsls	r3, r3, #2
 80094a6:	4413      	add	r3, r2
 80094a8:	009b      	lsls	r3, r3, #2
 80094aa:	440b      	add	r3, r1
 80094ac:	f503 7315 	add.w	r3, r3, #596	@ 0x254
 80094b0:	681b      	ldr	r3, [r3, #0]
 80094b2:	2b00      	cmp	r3, #0
 80094b4:	d00c      	beq.n	80094d0 <FreeX509Name+0x66>
                    wolfSSL_ASN1_OBJECT_free(name->entry[i].object);
 80094b6:	6879      	ldr	r1, [r7, #4]
 80094b8:	68fa      	ldr	r2, [r7, #12]
 80094ba:	4613      	mov	r3, r2
 80094bc:	009b      	lsls	r3, r3, #2
 80094be:	4413      	add	r3, r2
 80094c0:	009b      	lsls	r3, r3, #2
 80094c2:	440b      	add	r3, r1
 80094c4:	f503 7315 	add.w	r3, r3, #596	@ 0x254
 80094c8:	681b      	ldr	r3, [r3, #0]
 80094ca:	4618      	mov	r0, r3
 80094cc:	f002 fa87 	bl	800b9de <wolfSSL_ASN1_OBJECT_free>
                if (name->entry[i].value != NULL)
 80094d0:	6879      	ldr	r1, [r7, #4]
 80094d2:	68fa      	ldr	r2, [r7, #12]
 80094d4:	4613      	mov	r3, r2
 80094d6:	009b      	lsls	r3, r3, #2
 80094d8:	4413      	add	r3, r2
 80094da:	009b      	lsls	r3, r3, #2
 80094dc:	440b      	add	r3, r1
 80094de:	f503 7316 	add.w	r3, r3, #600	@ 0x258
 80094e2:	681b      	ldr	r3, [r3, #0]
 80094e4:	2b00      	cmp	r3, #0
 80094e6:	d00c      	beq.n	8009502 <FreeX509Name+0x98>
                    wolfSSL_ASN1_STRING_free(name->entry[i].value);
 80094e8:	6879      	ldr	r1, [r7, #4]
 80094ea:	68fa      	ldr	r2, [r7, #12]
 80094ec:	4613      	mov	r3, r2
 80094ee:	009b      	lsls	r3, r3, #2
 80094f0:	4413      	add	r3, r2
 80094f2:	009b      	lsls	r3, r3, #2
 80094f4:	440b      	add	r3, r1
 80094f6:	f503 7316 	add.w	r3, r3, #600	@ 0x258
 80094fa:	681b      	ldr	r3, [r3, #0]
 80094fc:	4618      	mov	r0, r3
 80094fe:	f002 facd 	bl	800ba9c <wolfSSL_ASN1_STRING_free>
                XMEMSET(&name->entry[i], 0, sizeof(WOLFSSL_X509_NAME_ENTRY));
 8009502:	68fa      	ldr	r2, [r7, #12]
 8009504:	4613      	mov	r3, r2
 8009506:	009b      	lsls	r3, r3, #2
 8009508:	4413      	add	r3, r2
 800950a:	009b      	lsls	r3, r3, #2
 800950c:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 8009510:	687a      	ldr	r2, [r7, #4]
 8009512:	4413      	add	r3, r2
 8009514:	3304      	adds	r3, #4
 8009516:	2214      	movs	r2, #20
 8009518:	2100      	movs	r1, #0
 800951a:	4618      	mov	r0, r3
 800951c:	f01e ffd4 	bl	80284c8 <memset>
            for (i = 0; i < MAX_NAME_ENTRIES; i++) {
 8009520:	68fb      	ldr	r3, [r7, #12]
 8009522:	3301      	adds	r3, #1
 8009524:	60fb      	str	r3, [r7, #12]
 8009526:	68fb      	ldr	r3, [r7, #12]
 8009528:	2b0f      	cmp	r3, #15
 800952a:	ddb8      	ble.n	800949e <FreeX509Name+0x34>
            wolfSSL_sk_X509_NAME_ENTRY_free(name->entries);
            name->entries = NULL;
        }
#endif
    }
}
 800952c:	bf00      	nop
 800952e:	3710      	adds	r7, #16
 8009530:	46bd      	mov	sp, r7
 8009532:	bd80      	pop	{r7, pc}

08009534 <InitX509>:


/* Initialize wolfSSL X509 type */
void InitX509(WOLFSSL_X509* x509, int dynamicFlag, void* heap)
{
 8009534:	b580      	push	{r7, lr}
 8009536:	b086      	sub	sp, #24
 8009538:	af00      	add	r7, sp, #0
 800953a:	60f8      	str	r0, [r7, #12]
 800953c:	60b9      	str	r1, [r7, #8]
 800953e:	607a      	str	r2, [r7, #4]
    if (x509 == NULL) {
 8009540:	68fb      	ldr	r3, [r7, #12]
 8009542:	2b00      	cmp	r3, #0
 8009544:	d025      	beq.n	8009592 <InitX509+0x5e>
        WOLFSSL_MSG("Null parameter passed in!");
        return;
    }

    XMEMSET(x509, 0, sizeof(WOLFSSL_X509));
 8009546:	f640 42d4 	movw	r2, #3284	@ 0xcd4
 800954a:	2100      	movs	r1, #0
 800954c:	68f8      	ldr	r0, [r7, #12]
 800954e:	f01e ffbb 	bl	80284c8 <memset>

    x509->heap = heap;
 8009552:	68fb      	ldr	r3, [r7, #12]
 8009554:	687a      	ldr	r2, [r7, #4]
 8009556:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
    InitX509Name(&x509->issuer, 0, heap);
 800955a:	68fb      	ldr	r3, [r7, #12]
 800955c:	f503 731f 	add.w	r3, r3, #636	@ 0x27c
 8009560:	687a      	ldr	r2, [r7, #4]
 8009562:	2100      	movs	r1, #0
 8009564:	4618      	mov	r0, r3
 8009566:	f7ff ff61 	bl	800942c <InitX509Name>
    InitX509Name(&x509->subject, 0, heap);
 800956a:	68fb      	ldr	r3, [r7, #12]
 800956c:	f503 63f1 	add.w	r3, r3, #1928	@ 0x788
 8009570:	687a      	ldr	r2, [r7, #4]
 8009572:	2100      	movs	r1, #0
 8009574:	4618      	mov	r0, r3
 8009576:	f7ff ff59 	bl	800942c <InitX509Name>
    x509->dynamicMemory  = (byte)dynamicFlag;
 800957a:	68bb      	ldr	r3, [r7, #8]
 800957c:	b2da      	uxtb	r2, r3
 800957e:	68fb      	ldr	r3, [r7, #12]
 8009580:	f883 2094 	strb.w	r2, [r3, #148]	@ 0x94
#if defined(OPENSSL_EXTRA_X509_SMALL) || defined(OPENSSL_EXTRA)
    {
        int ret;
        wolfSSL_RefInit(&x509->ref, &ret);
 8009584:	68fb      	ldr	r3, [r7, #12]
 8009586:	2201      	movs	r2, #1
 8009588:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
 800958c:	2300      	movs	r3, #0
 800958e:	617b      	str	r3, [r7, #20]
 8009590:	e000      	b.n	8009594 <InitX509+0x60>
        return;
 8009592:	bf00      	nop
        (void)ret;
    }
#endif
}
 8009594:	3718      	adds	r7, #24
 8009596:	46bd      	mov	sp, r7
 8009598:	bd80      	pop	{r7, pc}

0800959a <FreeX509>:


/* Free wolfSSL X509 type */
void FreeX509(WOLFSSL_X509* x509)
{
 800959a:	b580      	push	{r7, lr}
 800959c:	b08c      	sub	sp, #48	@ 0x30
 800959e:	af00      	add	r7, sp, #0
 80095a0:	6078      	str	r0, [r7, #4]
    #if defined(WOLFSSL_CERT_REQ) && defined(OPENSSL_ALL) \
    &&  defined( WOLFSSL_CUSTOM_OID)
    int idx;
    #endif /* WOLFSSL_CERT_REQ && OPENSSL_ALL && WOLFSSL_CUSTOM_OID */
    if (x509 == NULL)
 80095a2:	687b      	ldr	r3, [r7, #4]
 80095a4:	2b00      	cmp	r3, #0
 80095a6:	f000 80dc 	beq.w	8009762 <FreeX509+0x1c8>
        return;

    FreeX509Name(&x509->issuer);
 80095aa:	687b      	ldr	r3, [r7, #4]
 80095ac:	f503 731f 	add.w	r3, r3, #636	@ 0x27c
 80095b0:	4618      	mov	r0, r3
 80095b2:	f7ff ff5a 	bl	800946a <FreeX509Name>
    FreeX509Name(&x509->subject);
 80095b6:	687b      	ldr	r3, [r7, #4]
 80095b8:	f503 63f1 	add.w	r3, r3, #1928	@ 0x788
 80095bc:	4618      	mov	r0, r3
 80095be:	f7ff ff54 	bl	800946a <FreeX509Name>
    if (x509->pubKey.buffer) {
 80095c2:	687b      	ldr	r3, [r7, #4]
 80095c4:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 80095c6:	2b00      	cmp	r3, #0
 80095c8:	d00b      	beq.n	80095e2 <FreeX509+0x48>
        XFREE(x509->pubKey.buffer, x509->heap, DYNAMIC_TYPE_PUBLIC_KEY);
 80095ca:	687b      	ldr	r3, [r7, #4]
 80095cc:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 80095ce:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80095d0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80095d2:	2b00      	cmp	r3, #0
 80095d4:	d002      	beq.n	80095dc <FreeX509+0x42>
 80095d6:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 80095d8:	f015 fa72 	bl	801eac0 <wolfSSL_Free>
        x509->pubKey.buffer = NULL;
 80095dc:	687b      	ldr	r3, [r7, #4]
 80095de:	2200      	movs	r2, #0
 80095e0:	679a      	str	r2, [r3, #120]	@ 0x78
    }
    FreeDer(&x509->derCert);
 80095e2:	687b      	ldr	r3, [r7, #4]
 80095e4:	338c      	adds	r3, #140	@ 0x8c
 80095e6:	4618      	mov	r0, r3
 80095e8:	f00f fcc8 	bl	8018f7c <FreeDer>
    XFREE(x509->sig.buffer, x509->heap, DYNAMIC_TYPE_SIGNATURE);
 80095ec:	687b      	ldr	r3, [r7, #4]
 80095ee:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 80095f0:	62bb      	str	r3, [r7, #40]	@ 0x28
 80095f2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80095f4:	2b00      	cmp	r3, #0
 80095f6:	d002      	beq.n	80095fe <FreeX509+0x64>
 80095f8:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 80095fa:	f015 fa61 	bl	801eac0 <wolfSSL_Free>
    x509->sig.buffer = NULL;
 80095fe:	687b      	ldr	r3, [r7, #4]
 8009600:	2200      	movs	r2, #0
 8009602:	669a      	str	r2, [r3, #104]	@ 0x68
    #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
        if (x509->authKeyIdSrc != NULL) {
 8009604:	687b      	ldr	r3, [r7, #4]
 8009606:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
 800960a:	2b00      	cmp	r3, #0
 800960c:	d00a      	beq.n	8009624 <FreeX509+0x8a>
            XFREE(x509->authKeyIdSrc, x509->heap, DYNAMIC_TYPE_X509_EXT);
 800960e:	687b      	ldr	r3, [r7, #4]
 8009610:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
 8009614:	623b      	str	r3, [r7, #32]
 8009616:	6a3b      	ldr	r3, [r7, #32]
 8009618:	2b00      	cmp	r3, #0
 800961a:	d00d      	beq.n	8009638 <FreeX509+0x9e>
 800961c:	6a38      	ldr	r0, [r7, #32]
 800961e:	f015 fa4f 	bl	801eac0 <wolfSSL_Free>
 8009622:	e009      	b.n	8009638 <FreeX509+0x9e>
        }
        else {
            XFREE(x509->authKeyId, x509->heap, DYNAMIC_TYPE_X509_EXT);
 8009624:	687b      	ldr	r3, [r7, #4]
 8009626:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 800962a:	627b      	str	r3, [r7, #36]	@ 0x24
 800962c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800962e:	2b00      	cmp	r3, #0
 8009630:	d002      	beq.n	8009638 <FreeX509+0x9e>
 8009632:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8009634:	f015 fa44 	bl	801eac0 <wolfSSL_Free>
        }
        x509->authKeyIdSrc = NULL;
 8009638:	687b      	ldr	r3, [r7, #4]
 800963a:	2200      	movs	r2, #0
 800963c:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
        x509->authKeyId = NULL;
 8009640:	687b      	ldr	r3, [r7, #4]
 8009642:	2200      	movs	r2, #0
 8009644:	f8c3 209c 	str.w	r2, [r3, #156]	@ 0x9c
        XFREE(x509->subjKeyId, x509->heap, DYNAMIC_TYPE_X509_EXT);
 8009648:	687b      	ldr	r3, [r7, #4]
 800964a:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 800964e:	61fb      	str	r3, [r7, #28]
 8009650:	69fb      	ldr	r3, [r7, #28]
 8009652:	2b00      	cmp	r3, #0
 8009654:	d002      	beq.n	800965c <FreeX509+0xc2>
 8009656:	69f8      	ldr	r0, [r7, #28]
 8009658:	f015 fa32 	bl	801eac0 <wolfSSL_Free>
        x509->subjKeyId = NULL;
 800965c:	687b      	ldr	r3, [r7, #4]
 800965e:	2200      	movs	r2, #0
 8009660:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4
        wolfSSL_ASN1_STRING_free(x509->subjKeyIdStr);
 8009664:	687b      	ldr	r3, [r7, #4]
 8009666:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 800966a:	4618      	mov	r0, r3
 800966c:	f002 fa16 	bl	800ba9c <wolfSSL_ASN1_STRING_free>
        x509->subjKeyIdStr = NULL;
 8009670:	687b      	ldr	r3, [r7, #4]
 8009672:	2200      	movs	r2, #0
 8009674:	f8c3 20a8 	str.w	r2, [r3, #168]	@ 0xa8
        XFREE(x509->authInfo, x509->heap, DYNAMIC_TYPE_X509_EXT);
 8009678:	687b      	ldr	r3, [r7, #4]
 800967a:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
 800967e:	61bb      	str	r3, [r7, #24]
 8009680:	69bb      	ldr	r3, [r7, #24]
 8009682:	2b00      	cmp	r3, #0
 8009684:	d002      	beq.n	800968c <FreeX509+0xf2>
 8009686:	69b8      	ldr	r0, [r7, #24]
 8009688:	f015 fa1a 	bl	801eac0 <wolfSSL_Free>
        x509->authInfo = NULL;
 800968c:	687b      	ldr	r3, [r7, #4]
 800968e:	2200      	movs	r2, #0
 8009690:	f8c3 20b8 	str.w	r2, [r3, #184]	@ 0xb8
        XFREE(x509->rawCRLInfo, x509->heap, DYNAMIC_TYPE_X509_EXT);
 8009694:	687b      	ldr	r3, [r7, #4]
 8009696:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
 800969a:	617b      	str	r3, [r7, #20]
 800969c:	697b      	ldr	r3, [r7, #20]
 800969e:	2b00      	cmp	r3, #0
 80096a0:	d002      	beq.n	80096a8 <FreeX509+0x10e>
 80096a2:	6978      	ldr	r0, [r7, #20]
 80096a4:	f015 fa0c 	bl	801eac0 <wolfSSL_Free>
        x509->rawCRLInfo = NULL;
 80096a8:	687b      	ldr	r3, [r7, #4]
 80096aa:	2200      	movs	r2, #0
 80096ac:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0
        XFREE(x509->CRLInfo, x509->heap, DYNAMIC_TYPE_X509_EXT);
 80096b0:	687b      	ldr	r3, [r7, #4]
 80096b2:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
 80096b6:	613b      	str	r3, [r7, #16]
 80096b8:	693b      	ldr	r3, [r7, #16]
 80096ba:	2b00      	cmp	r3, #0
 80096bc:	d002      	beq.n	80096c4 <FreeX509+0x12a>
 80096be:	6938      	ldr	r0, [r7, #16]
 80096c0:	f015 f9fe 	bl	801eac0 <wolfSSL_Free>
        x509->CRLInfo = NULL;
 80096c4:	687b      	ldr	r3, [r7, #4]
 80096c6:	2200      	movs	r2, #0
 80096c8:	f8c3 20b4 	str.w	r2, [r3, #180]	@ 0xb4
        #if defined(OPENSSL_ALL) || defined(OPENSSL_EXTRA) || \
            defined(WOLFSSL_QT)
        XFREE(x509->authInfoCaIssuer, x509->heap, DYNAMIC_TYPE_X509_EXT);
 80096cc:	687b      	ldr	r3, [r7, #4]
 80096ce:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 80096d2:	60fb      	str	r3, [r7, #12]
 80096d4:	68fb      	ldr	r3, [r7, #12]
 80096d6:	2b00      	cmp	r3, #0
 80096d8:	d002      	beq.n	80096e0 <FreeX509+0x146>
 80096da:	68f8      	ldr	r0, [r7, #12]
 80096dc:	f015 f9f0 	bl	801eac0 <wolfSSL_Free>
        if (x509->ext_sk != NULL) {
 80096e0:	687b      	ldr	r3, [r7, #4]
 80096e2:	689b      	ldr	r3, [r3, #8]
 80096e4:	2b00      	cmp	r3, #0
 80096e6:	d005      	beq.n	80096f4 <FreeX509+0x15a>
            wolfSSL_sk_X509_EXTENSION_pop_free(x509->ext_sk, NULL);
 80096e8:	687b      	ldr	r3, [r7, #4]
 80096ea:	689b      	ldr	r3, [r3, #8]
 80096ec:	2100      	movs	r1, #0
 80096ee:	4618      	mov	r0, r3
 80096f0:	f004 ff1e 	bl	800e530 <wolfSSL_sk_X509_EXTENSION_pop_free>
        }
        if (x509->ext_sk_full != NULL) {
 80096f4:	687b      	ldr	r3, [r7, #4]
 80096f6:	68db      	ldr	r3, [r3, #12]
 80096f8:	2b00      	cmp	r3, #0
 80096fa:	d005      	beq.n	8009708 <FreeX509+0x16e>
            wolfSSL_sk_X509_EXTENSION_pop_free(x509->ext_sk_full, NULL);
 80096fc:	687b      	ldr	r3, [r7, #4]
 80096fe:	68db      	ldr	r3, [r3, #12]
 8009700:	2100      	movs	r1, #0
 8009702:	4618      	mov	r0, r3
 8009704:	f004 ff14 	bl	800e530 <wolfSSL_sk_X509_EXTENSION_pop_free>
        }
        #endif /* OPENSSL_ALL || WOLFSSL_QT */
        #ifdef OPENSSL_EXTRA
        /* Free serialNumber that was set by wolfSSL_X509_get_serialNumber */
        if (x509->serialNumber != NULL) {
 8009708:	687b      	ldr	r3, [r7, #4]
 800970a:	695b      	ldr	r3, [r3, #20]
 800970c:	2b00      	cmp	r3, #0
 800970e:	d004      	beq.n	800971a <FreeX509+0x180>
            wolfSSL_ASN1_INTEGER_free(x509->serialNumber);
 8009710:	687b      	ldr	r3, [r7, #4]
 8009712:	695b      	ldr	r3, [r3, #20]
 8009714:	4618      	mov	r0, r3
 8009716:	f002 f91b 	bl	800b950 <wolfSSL_ASN1_INTEGER_free>
        }
        #endif
        if (x509->extKeyUsageSrc != NULL) {
 800971a:	687b      	ldr	r3, [r7, #4]
 800971c:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
 8009720:	2b00      	cmp	r3, #0
 8009722:	d00d      	beq.n	8009740 <FreeX509+0x1a6>
            XFREE(x509->extKeyUsageSrc, x509->heap, DYNAMIC_TYPE_X509_EXT);
 8009724:	687b      	ldr	r3, [r7, #4]
 8009726:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
 800972a:	60bb      	str	r3, [r7, #8]
 800972c:	68bb      	ldr	r3, [r7, #8]
 800972e:	2b00      	cmp	r3, #0
 8009730:	d002      	beq.n	8009738 <FreeX509+0x19e>
 8009732:	68b8      	ldr	r0, [r7, #8]
 8009734:	f015 f9c4 	bl	801eac0 <wolfSSL_Free>
            x509->extKeyUsageSrc= NULL;
 8009738:	687b      	ldr	r3, [r7, #4]
 800973a:	2200      	movs	r2, #0
 800973c:	f8c3 20ac 	str.w	r2, [r3, #172]	@ 0xac
            XFREE(x509->custom_exts[idx].val, x509->heap,
                  DYNAMIC_TYPE_X509_EXT);
        }
    #endif /* WOLFSSL_CUSTOM_OID */
    #endif /* WOLFSSL_CERT_REQ && OPENSSL_ALL */
    if (x509->altNames) {
 8009740:	687b      	ldr	r3, [r7, #4]
 8009742:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 8009744:	2b00      	cmp	r3, #0
 8009746:	d00d      	beq.n	8009764 <FreeX509+0x1ca>
        FreeAltNames(x509->altNames, x509->heap);
 8009748:	687b      	ldr	r3, [r7, #4]
 800974a:	6f5a      	ldr	r2, [r3, #116]	@ 0x74
 800974c:	687b      	ldr	r3, [r7, #4]
 800974e:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 8009752:	4619      	mov	r1, r3
 8009754:	4610      	mov	r0, r2
 8009756:	f00b fd10 	bl	801517a <FreeAltNames>
        x509->altNames = NULL;
 800975a:	687b      	ldr	r3, [r7, #4]
 800975c:	2200      	movs	r2, #0
 800975e:	675a      	str	r2, [r3, #116]	@ 0x74
 8009760:	e000      	b.n	8009764 <FreeX509+0x1ca>
        return;
 8009762:	bf00      	nop
    #endif /* WOLFSSL_DUAL_ALG_CERTS */

    #if defined(OPENSSL_EXTRA) || defined(OPENSSL_ALL)
        wolfSSL_RefFree(&x509->ref);
    #endif
}
 8009764:	3730      	adds	r7, #48	@ 0x30
 8009766:	46bd      	mov	sp, r7
 8009768:	bd80      	pop	{r7, pc}

0800976a <FreeHandshakeHashes>:

    return ret;
}

void FreeHandshakeHashes(WOLFSSL* ssl)
{
 800976a:	b580      	push	{r7, lr}
 800976c:	b084      	sub	sp, #16
 800976e:	af00      	add	r7, sp, #0
 8009770:	6078      	str	r0, [r7, #4]
    if (ssl->hsHashes) {
 8009772:	687b      	ldr	r3, [r7, #4]
 8009774:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 8009776:	2b00      	cmp	r3, #0
 8009778:	d011      	beq.n	800979e <FreeHandshakeHashes+0x34>
    #if !defined(NO_SHA) && (!defined(NO_OLD_TLS) || \
                              defined(WOLFSSL_ALLOW_TLS_SHA1))
        wc_ShaFree(&ssl->hsHashes->hashSha);
    #endif
    #ifndef NO_SHA256
        wc_Sha256Free(&ssl->hsHashes->hashSha256);
 800977a:	687b      	ldr	r3, [r7, #4]
 800977c:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 800977e:	3340      	adds	r3, #64	@ 0x40
 8009780:	4618      	mov	r0, r3
 8009782:	f018 fc42 	bl	802200a <wc_Sha256Free>
            XFREE(ssl->hsHashes->messages, ssl->heap, DYNAMIC_TYPE_HASHES);
            ssl->hsHashes->messages = NULL;
         }
    #endif

        XFREE(ssl->hsHashes, ssl->heap, DYNAMIC_TYPE_HASHES);
 8009786:	687b      	ldr	r3, [r7, #4]
 8009788:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 800978a:	60fb      	str	r3, [r7, #12]
 800978c:	68fb      	ldr	r3, [r7, #12]
 800978e:	2b00      	cmp	r3, #0
 8009790:	d002      	beq.n	8009798 <FreeHandshakeHashes+0x2e>
 8009792:	68f8      	ldr	r0, [r7, #12]
 8009794:	f015 f994 	bl	801eac0 <wolfSSL_Free>
        ssl->hsHashes = NULL;
 8009798:	687b      	ldr	r3, [r7, #4]
 800979a:	2200      	movs	r2, #0
 800979c:	675a      	str	r2, [r3, #116]	@ 0x74
    }
}
 800979e:	bf00      	nop
 80097a0:	3710      	adds	r7, #16
 80097a2:	46bd      	mov	sp, r7
 80097a4:	bd80      	pop	{r7, pc}

080097a6 <FreeArrays>:
}


/* free use of temporary arrays */
void FreeArrays(WOLFSSL* ssl, int keep)
{
 80097a6:	b580      	push	{r7, lr}
 80097a8:	b086      	sub	sp, #24
 80097aa:	af00      	add	r7, sp, #0
 80097ac:	6078      	str	r0, [r7, #4]
 80097ae:	6039      	str	r1, [r7, #0]
    if (ssl->arrays) {
 80097b0:	687b      	ldr	r3, [r7, #4]
 80097b2:	691b      	ldr	r3, [r3, #16]
 80097b4:	2b00      	cmp	r3, #0
 80097b6:	d052      	beq.n	800985e <FreeArrays+0xb8>
        if (keep && !IsAtLeastTLSv1_3(ssl->version)) {
 80097b8:	683b      	ldr	r3, [r7, #0]
 80097ba:	2b00      	cmp	r3, #0
 80097bc:	d020      	beq.n	8009800 <FreeArrays+0x5a>
 80097be:	687b      	ldr	r3, [r7, #4]
 80097c0:	f8b3 21da 	ldrh.w	r2, [r3, #474]	@ 0x1da
 80097c4:	2300      	movs	r3, #0
 80097c6:	f362 030f 	bfi	r3, r2, #0, #16
 80097ca:	4618      	mov	r0, r3
 80097cc:	f7ff f89e 	bl	800890c <IsAtLeastTLSv1_3>
 80097d0:	4603      	mov	r3, r0
 80097d2:	2b00      	cmp	r3, #0
 80097d4:	d114      	bne.n	8009800 <FreeArrays+0x5a>
            /* keeps session id for user retrieval */
            XMEMCPY(ssl->session->sessionID, ssl->arrays->sessionID, ID_LEN);
 80097d6:	687b      	ldr	r3, [r7, #4]
 80097d8:	f8d3 318c 	ldr.w	r3, [r3, #396]	@ 0x18c
 80097dc:	f103 0040 	add.w	r0, r3, #64	@ 0x40
 80097e0:	687b      	ldr	r3, [r7, #4]
 80097e2:	691b      	ldr	r3, [r3, #16]
 80097e4:	3354      	adds	r3, #84	@ 0x54
 80097e6:	2220      	movs	r2, #32
 80097e8:	4619      	mov	r1, r3
 80097ea:	f01e fed7 	bl	802859c <memcpy>
            ssl->session->sessionIDSz = ssl->arrays->sessionIDSz;
 80097ee:	687b      	ldr	r3, [r7, #4]
 80097f0:	691a      	ldr	r2, [r3, #16]
 80097f2:	687b      	ldr	r3, [r7, #4]
 80097f4:	f8d3 318c 	ldr.w	r3, [r3, #396]	@ 0x18c
 80097f8:	f892 2074 	ldrb.w	r2, [r2, #116]	@ 0x74
 80097fc:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60
        }
        if (ssl->arrays->preMasterSecret) {
 8009800:	687b      	ldr	r3, [r7, #4]
 8009802:	691b      	ldr	r3, [r3, #16]
 8009804:	685b      	ldr	r3, [r3, #4]
 8009806:	2b00      	cmp	r3, #0
 8009808:	d015      	beq.n	8009836 <FreeArrays+0x90>
            ForceZero(ssl->arrays->preMasterSecret, ENCRYPT_LEN);
 800980a:	687b      	ldr	r3, [r7, #4]
 800980c:	691b      	ldr	r3, [r3, #16]
 800980e:	685b      	ldr	r3, [r3, #4]
 8009810:	f44f 7180 	mov.w	r1, #256	@ 0x100
 8009814:	4618      	mov	r0, r3
 8009816:	f7ff f850 	bl	80088ba <ForceZero>
            XFREE(ssl->arrays->preMasterSecret, ssl->heap, DYNAMIC_TYPE_SECRET);
 800981a:	687b      	ldr	r3, [r7, #4]
 800981c:	691b      	ldr	r3, [r3, #16]
 800981e:	685b      	ldr	r3, [r3, #4]
 8009820:	617b      	str	r3, [r7, #20]
 8009822:	697b      	ldr	r3, [r7, #20]
 8009824:	2b00      	cmp	r3, #0
 8009826:	d002      	beq.n	800982e <FreeArrays+0x88>
 8009828:	6978      	ldr	r0, [r7, #20]
 800982a:	f015 f949 	bl	801eac0 <wolfSSL_Free>
            ssl->arrays->preMasterSecret = NULL;
 800982e:	687b      	ldr	r3, [r7, #4]
 8009830:	691b      	ldr	r3, [r3, #16]
 8009832:	2200      	movs	r2, #0
 8009834:	605a      	str	r2, [r3, #4]
        }
        XFREE(ssl->arrays->pendingMsg, ssl->heap, DYNAMIC_TYPE_ARRAYS);
 8009836:	687b      	ldr	r3, [r7, #4]
 8009838:	691b      	ldr	r3, [r3, #16]
 800983a:	681b      	ldr	r3, [r3, #0]
 800983c:	613b      	str	r3, [r7, #16]
 800983e:	693b      	ldr	r3, [r7, #16]
 8009840:	2b00      	cmp	r3, #0
 8009842:	d002      	beq.n	800984a <FreeArrays+0xa4>
 8009844:	6938      	ldr	r0, [r7, #16]
 8009846:	f015 f93b 	bl	801eac0 <wolfSSL_Free>
        ssl->arrays->pendingMsg = NULL;
 800984a:	687b      	ldr	r3, [r7, #4]
 800984c:	691b      	ldr	r3, [r3, #16]
 800984e:	2200      	movs	r2, #0
 8009850:	601a      	str	r2, [r3, #0]
        ForceZero(ssl->arrays, sizeof(Arrays)); /* clear arrays struct */
 8009852:	687b      	ldr	r3, [r7, #4]
 8009854:	691b      	ldr	r3, [r3, #16]
 8009856:	21d8      	movs	r1, #216	@ 0xd8
 8009858:	4618      	mov	r0, r3
 800985a:	f7ff f82e 	bl	80088ba <ForceZero>
    }
    XFREE(ssl->arrays, ssl->heap, DYNAMIC_TYPE_ARRAYS);
 800985e:	687b      	ldr	r3, [r7, #4]
 8009860:	691b      	ldr	r3, [r3, #16]
 8009862:	60fb      	str	r3, [r7, #12]
 8009864:	68fb      	ldr	r3, [r7, #12]
 8009866:	2b00      	cmp	r3, #0
 8009868:	d002      	beq.n	8009870 <FreeArrays+0xca>
 800986a:	68f8      	ldr	r0, [r7, #12]
 800986c:	f015 f928 	bl	801eac0 <wolfSSL_Free>
    ssl->arrays = NULL;
 8009870:	687b      	ldr	r3, [r7, #4]
 8009872:	2200      	movs	r2, #0
 8009874:	611a      	str	r2, [r3, #16]
}
 8009876:	bf00      	nop
 8009878:	3718      	adds	r7, #24
 800987a:	46bd      	mov	sp, r7
 800987c:	bd80      	pop	{r7, pc}

0800987e <FreeKey>:

void FreeKey(WOLFSSL* ssl, int type, void** pKey)
{
 800987e:	b580      	push	{r7, lr}
 8009880:	b086      	sub	sp, #24
 8009882:	af00      	add	r7, sp, #0
 8009884:	60f8      	str	r0, [r7, #12]
 8009886:	60b9      	str	r1, [r7, #8]
 8009888:	607a      	str	r2, [r7, #4]
    if (ssl && pKey && *pKey) {
 800988a:	68fb      	ldr	r3, [r7, #12]
 800988c:	2b00      	cmp	r3, #0
 800988e:	d032      	beq.n	80098f6 <FreeKey+0x78>
 8009890:	687b      	ldr	r3, [r7, #4]
 8009892:	2b00      	cmp	r3, #0
 8009894:	d02f      	beq.n	80098f6 <FreeKey+0x78>
 8009896:	687b      	ldr	r3, [r7, #4]
 8009898:	681b      	ldr	r3, [r3, #0]
 800989a:	2b00      	cmp	r3, #0
 800989c:	d02b      	beq.n	80098f6 <FreeKey+0x78>
        switch (type) {
 800989e:	68bb      	ldr	r3, [r7, #8]
 80098a0:	2b25      	cmp	r3, #37	@ 0x25
 80098a2:	d00f      	beq.n	80098c4 <FreeKey+0x46>
 80098a4:	68bb      	ldr	r3, [r7, #8]
 80098a6:	2b25      	cmp	r3, #37	@ 0x25
 80098a8:	dc18      	bgt.n	80098dc <FreeKey+0x5e>
 80098aa:	68bb      	ldr	r3, [r7, #8]
 80098ac:	2b0a      	cmp	r3, #10
 80098ae:	d003      	beq.n	80098b8 <FreeKey+0x3a>
 80098b0:	68bb      	ldr	r3, [r7, #8]
 80098b2:	2b0f      	cmp	r3, #15
 80098b4:	d00c      	beq.n	80098d0 <FreeKey+0x52>
            case DYNAMIC_TYPE_DH:
                wc_FreeDhKey((DhKey*)*pKey);
                break;
        #endif /* !NO_DH */
            default:
                break;
 80098b6:	e011      	b.n	80098dc <FreeKey+0x5e>
                wc_FreeRsaKey((RsaKey*)*pKey);
 80098b8:	687b      	ldr	r3, [r7, #4]
 80098ba:	681b      	ldr	r3, [r3, #0]
 80098bc:	4618      	mov	r0, r3
 80098be:	f016 fb67 	bl	801ff90 <wc_FreeRsaKey>
                break;
 80098c2:	e00c      	b.n	80098de <FreeKey+0x60>
                wc_ecc_free((ecc_key*)*pKey);
 80098c4:	687b      	ldr	r3, [r7, #4]
 80098c6:	681b      	ldr	r3, [r3, #0]
 80098c8:	4618      	mov	r0, r3
 80098ca:	f013 fb26 	bl	801cf1a <wc_ecc_free>
                break;
 80098ce:	e006      	b.n	80098de <FreeKey+0x60>
                wc_FreeDhKey((DhKey*)*pKey);
 80098d0:	687b      	ldr	r3, [r7, #4]
 80098d2:	681b      	ldr	r3, [r3, #0]
 80098d4:	4618      	mov	r0, r3
 80098d6:	f010 ff35 	bl	801a744 <wc_FreeDhKey>
                break;
 80098da:	e000      	b.n	80098de <FreeKey+0x60>
                break;
 80098dc:	bf00      	nop
        }
        XFREE(*pKey, ssl->heap, type);
 80098de:	687b      	ldr	r3, [r7, #4]
 80098e0:	681b      	ldr	r3, [r3, #0]
 80098e2:	617b      	str	r3, [r7, #20]
 80098e4:	697b      	ldr	r3, [r7, #20]
 80098e6:	2b00      	cmp	r3, #0
 80098e8:	d002      	beq.n	80098f0 <FreeKey+0x72>
 80098ea:	6978      	ldr	r0, [r7, #20]
 80098ec:	f015 f8e8 	bl	801eac0 <wolfSSL_Free>

        /* Reset pointer */
        *pKey = NULL;
 80098f0:	687b      	ldr	r3, [r7, #4]
 80098f2:	2200      	movs	r2, #0
 80098f4:	601a      	str	r2, [r3, #0]
    }
}
 80098f6:	bf00      	nop
 80098f8:	3718      	adds	r7, #24
 80098fa:	46bd      	mov	sp, r7
 80098fc:	bd80      	pop	{r7, pc}

080098fe <FreeAsyncCtx>:
}
#endif

#ifdef WOLFSSL_ASYNC_IO
void FreeAsyncCtx(WOLFSSL* ssl, byte freeAsync)
{
 80098fe:	b580      	push	{r7, lr}
 8009900:	b084      	sub	sp, #16
 8009902:	af00      	add	r7, sp, #0
 8009904:	6078      	str	r0, [r7, #4]
 8009906:	460b      	mov	r3, r1
 8009908:	70fb      	strb	r3, [r7, #3]
    if (ssl->async != NULL) {
 800990a:	687b      	ldr	r3, [r7, #4]
 800990c:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 8009910:	2b00      	cmp	r3, #0
 8009912:	d026      	beq.n	8009962 <FreeAsyncCtx+0x64>
        if (ssl->async->freeArgs != NULL) {
 8009914:	687b      	ldr	r3, [r7, #4]
 8009916:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 800991a:	681b      	ldr	r3, [r3, #0]
 800991c:	2b00      	cmp	r3, #0
 800991e:	d00f      	beq.n	8009940 <FreeAsyncCtx+0x42>
            ssl->async->freeArgs(ssl, ssl->async->args);
 8009920:	687b      	ldr	r3, [r7, #4]
 8009922:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 8009926:	681b      	ldr	r3, [r3, #0]
 8009928:	687a      	ldr	r2, [r7, #4]
 800992a:	f8d2 20a4 	ldr.w	r2, [r2, #164]	@ 0xa4
 800992e:	3204      	adds	r2, #4
 8009930:	4611      	mov	r1, r2
 8009932:	6878      	ldr	r0, [r7, #4]
 8009934:	4798      	blx	r3
            ssl->async->freeArgs = NULL;
 8009936:	687b      	ldr	r3, [r7, #4]
 8009938:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 800993c:	2200      	movs	r2, #0
 800993e:	601a      	str	r2, [r3, #0]
        if (ssl->options.buildArgsSet) {
            FreeBuildMsgArgs(ssl, &ssl->async->buildArgs);
            ssl->options.buildArgsSet = 0;
        }
#endif
        if (freeAsync) {
 8009940:	78fb      	ldrb	r3, [r7, #3]
 8009942:	2b00      	cmp	r3, #0
 8009944:	d00d      	beq.n	8009962 <FreeAsyncCtx+0x64>
            XFREE(ssl->async, ssl->heap, DYNAMIC_TYPE_ASYNC);
 8009946:	687b      	ldr	r3, [r7, #4]
 8009948:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 800994c:	60fb      	str	r3, [r7, #12]
 800994e:	68fb      	ldr	r3, [r7, #12]
 8009950:	2b00      	cmp	r3, #0
 8009952:	d002      	beq.n	800995a <FreeAsyncCtx+0x5c>
 8009954:	68f8      	ldr	r0, [r7, #12]
 8009956:	f015 f8b3 	bl	801eac0 <wolfSSL_Free>
            ssl->async = NULL;
 800995a:	687b      	ldr	r3, [r7, #4]
 800995c:	2200      	movs	r2, #0
 800995e:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4
        }
    }
}
 8009962:	bf00      	nop
 8009964:	3710      	adds	r7, #16
 8009966:	46bd      	mov	sp, r7
 8009968:	bd80      	pop	{r7, pc}

0800996a <FreeKeyExchange>:
#endif

void FreeKeyExchange(WOLFSSL* ssl)
{
 800996a:	b580      	push	{r7, lr}
 800996c:	b084      	sub	sp, #16
 800996e:	af00      	add	r7, sp, #0
 8009970:	6078      	str	r0, [r7, #4]
    /* Cleanup signature buffer */
    if (ssl->buffers.sig.buffer) {
 8009972:	687b      	ldr	r3, [r7, #4]
 8009974:	f8d3 312c 	ldr.w	r3, [r3, #300]	@ 0x12c
 8009978:	2b00      	cmp	r3, #0
 800997a:	d011      	beq.n	80099a0 <FreeKeyExchange+0x36>
        XFREE(ssl->buffers.sig.buffer, ssl->heap, DYNAMIC_TYPE_SIGNATURE);
 800997c:	687b      	ldr	r3, [r7, #4]
 800997e:	f8d3 312c 	ldr.w	r3, [r3, #300]	@ 0x12c
 8009982:	60fb      	str	r3, [r7, #12]
 8009984:	68fb      	ldr	r3, [r7, #12]
 8009986:	2b00      	cmp	r3, #0
 8009988:	d002      	beq.n	8009990 <FreeKeyExchange+0x26>
 800998a:	68f8      	ldr	r0, [r7, #12]
 800998c:	f015 f898 	bl	801eac0 <wolfSSL_Free>
        ssl->buffers.sig.buffer = NULL;
 8009990:	687b      	ldr	r3, [r7, #4]
 8009992:	2200      	movs	r2, #0
 8009994:	f8c3 212c 	str.w	r2, [r3, #300]	@ 0x12c
        ssl->buffers.sig.length = 0;
 8009998:	687b      	ldr	r3, [r7, #4]
 800999a:	2200      	movs	r2, #0
 800999c:	f8c3 2130 	str.w	r2, [r3, #304]	@ 0x130
    }

    /* Cleanup digest buffer */
    if (ssl->buffers.digest.buffer) {
 80099a0:	687b      	ldr	r3, [r7, #4]
 80099a2:	f8d3 3134 	ldr.w	r3, [r3, #308]	@ 0x134
 80099a6:	2b00      	cmp	r3, #0
 80099a8:	d020      	beq.n	80099ec <FreeKeyExchange+0x82>
        /* Only free if digest buffer was not set using SetDigest */
        if (!ssl->options.dontFreeDigest) {
 80099aa:	687b      	ldr	r3, [r7, #4]
 80099ac:	f893 32d5 	ldrb.w	r3, [r3, #725]	@ 0x2d5
 80099b0:	f003 0310 	and.w	r3, r3, #16
 80099b4:	b2db      	uxtb	r3, r3
 80099b6:	2b00      	cmp	r3, #0
 80099b8:	d109      	bne.n	80099ce <FreeKeyExchange+0x64>
            XFREE(ssl->buffers.digest.buffer, ssl->heap, DYNAMIC_TYPE_DIGEST);
 80099ba:	687b      	ldr	r3, [r7, #4]
 80099bc:	f8d3 3134 	ldr.w	r3, [r3, #308]	@ 0x134
 80099c0:	60bb      	str	r3, [r7, #8]
 80099c2:	68bb      	ldr	r3, [r7, #8]
 80099c4:	2b00      	cmp	r3, #0
 80099c6:	d002      	beq.n	80099ce <FreeKeyExchange+0x64>
 80099c8:	68b8      	ldr	r0, [r7, #8]
 80099ca:	f015 f879 	bl	801eac0 <wolfSSL_Free>
        }
        ssl->buffers.digest.buffer = NULL;
 80099ce:	687b      	ldr	r3, [r7, #4]
 80099d0:	2200      	movs	r2, #0
 80099d2:	f8c3 2134 	str.w	r2, [r3, #308]	@ 0x134
        ssl->buffers.digest.length = 0;
 80099d6:	687b      	ldr	r3, [r7, #4]
 80099d8:	2200      	movs	r2, #0
 80099da:	f8c3 2138 	str.w	r2, [r3, #312]	@ 0x138
        ssl->options.dontFreeDigest = 0;
 80099de:	687a      	ldr	r2, [r7, #4]
 80099e0:	f892 32d5 	ldrb.w	r3, [r2, #725]	@ 0x2d5
 80099e4:	f023 0310 	bic.w	r3, r3, #16
 80099e8:	f882 32d5 	strb.w	r3, [r2, #725]	@ 0x2d5
    }

    /* Free handshake key */
    FreeKey(ssl, (int)ssl->hsType, &ssl->hsKey);
 80099ec:	687b      	ldr	r3, [r7, #4]
 80099ee:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
 80099f2:	4619      	mov	r1, r3
 80099f4:	687b      	ldr	r3, [r7, #4]
 80099f6:	33a8      	adds	r3, #168	@ 0xa8
 80099f8:	461a      	mov	r2, r3
 80099fa:	6878      	ldr	r0, [r7, #4]
 80099fc:	f7ff ff3f 	bl	800987e <FreeKey>
    FreeKey(ssl, ssl->hsAltType, &ssl->hsAltKey);
#endif /* WOLFSSL_DUAL_ALG_CERTS */

#ifndef NO_DH
    /* Free temp DH key */
    FreeKey(ssl, DYNAMIC_TYPE_DH, (void**)&ssl->buffers.serverDH_Key);
 8009a00:	687b      	ldr	r3, [r7, #4]
 8009a02:	f503 73b4 	add.w	r3, r3, #360	@ 0x168
 8009a06:	461a      	mov	r2, r3
 8009a08:	210f      	movs	r1, #15
 8009a0a:	6878      	ldr	r0, [r7, #4]
 8009a0c:	f7ff ff37 	bl	800987e <FreeKey>
#endif
}
 8009a10:	bf00      	nop
 8009a12:	3710      	adds	r7, #16
 8009a14:	46bd      	mov	sp, r7
 8009a16:	bd80      	pop	{r7, pc}

08009a18 <FreeSuites>:


/* Free up all memory used by Suites structure from WOLFSSL */
void FreeSuites(WOLFSSL* ssl)
{
 8009a18:	b580      	push	{r7, lr}
 8009a1a:	b084      	sub	sp, #16
 8009a1c:	af00      	add	r7, sp, #0
 8009a1e:	6078      	str	r0, [r7, #4]
         * isn't allocated separately. */
        wolfSSL_sk_SSL_CIPHER_free(ssl->suitesStack);
        ssl->suitesStack = NULL;
    }
#endif
    XFREE(ssl->suites, ssl->heap, DYNAMIC_TYPE_SUITES);
 8009a20:	687b      	ldr	r3, [r7, #4]
 8009a22:	685b      	ldr	r3, [r3, #4]
 8009a24:	60fb      	str	r3, [r7, #12]
 8009a26:	68fb      	ldr	r3, [r7, #12]
 8009a28:	2b00      	cmp	r3, #0
 8009a2a:	d002      	beq.n	8009a32 <FreeSuites+0x1a>
 8009a2c:	68f8      	ldr	r0, [r7, #12]
 8009a2e:	f015 f847 	bl	801eac0 <wolfSSL_Free>
    ssl->suites = NULL;
 8009a32:	687b      	ldr	r3, [r7, #4]
 8009a34:	2200      	movs	r2, #0
 8009a36:	605a      	str	r2, [r3, #4]
}
 8009a38:	bf00      	nop
 8009a3a:	3710      	adds	r7, #16
 8009a3c:	46bd      	mov	sp, r7
 8009a3e:	bd80      	pop	{r7, pc}

08009a40 <wolfSSL_ResourceFree>:


/* In case holding SSL object in array and don't want to free actual ssl */
void wolfSSL_ResourceFree(WOLFSSL* ssl)
{
 8009a40:	b580      	push	{r7, lr}
 8009a42:	b08a      	sub	sp, #40	@ 0x28
 8009a44:	af00      	add	r7, sp, #0
 8009a46:	6078      	str	r0, [r7, #4]

#ifdef HAVE_EX_DATA_CLEANUP_HOOKS
    wolfSSL_CRYPTO_cleanup_ex_data(&ssl->ex_data);
#endif

    FreeCiphers(ssl);
 8009a48:	6878      	ldr	r0, [r7, #4]
 8009a4a:	f7ff f9d4 	bl	8008df6 <FreeCiphers>
    FreeArrays(ssl, 0);
 8009a4e:	2100      	movs	r1, #0
 8009a50:	6878      	ldr	r0, [r7, #4]
 8009a52:	f7ff fea8 	bl	80097a6 <FreeArrays>
    FreeKeyExchange(ssl);
 8009a56:	6878      	ldr	r0, [r7, #4]
 8009a58:	f7ff ff87 	bl	800996a <FreeKeyExchange>
#ifdef WOLFSSL_ASYNC_IO
    /* Cleanup async */
    FreeAsyncCtx(ssl, 1);
 8009a5c:	2101      	movs	r1, #1
 8009a5e:	6878      	ldr	r0, [r7, #4]
 8009a60:	f7ff ff4d 	bl	80098fe <FreeAsyncCtx>
#endif
    if (ssl->options.weOwnRng) {
 8009a64:	687b      	ldr	r3, [r7, #4]
 8009a66:	f893 32d5 	ldrb.w	r3, [r3, #725]	@ 0x2d5
 8009a6a:	f003 0308 	and.w	r3, r3, #8
 8009a6e:	b2db      	uxtb	r3, r3
 8009a70:	2b00      	cmp	r3, #0
 8009a72:	d01a      	beq.n	8009aaa <wolfSSL_ResourceFree+0x6a>
        wc_FreeRng(ssl->rng);
 8009a74:	687b      	ldr	r3, [r7, #4]
 8009a76:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 8009a7a:	4618      	mov	r0, r3
 8009a7c:	f015 fe2c 	bl	801f6d8 <wc_FreeRng>
        XFREE(ssl->rng, ssl->heap, DYNAMIC_TYPE_RNG);
 8009a80:	687b      	ldr	r3, [r7, #4]
 8009a82:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 8009a86:	627b      	str	r3, [r7, #36]	@ 0x24
 8009a88:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8009a8a:	2b00      	cmp	r3, #0
 8009a8c:	d002      	beq.n	8009a94 <wolfSSL_ResourceFree+0x54>
 8009a8e:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8009a90:	f015 f816 	bl	801eac0 <wolfSSL_Free>
        ssl->rng = NULL;
 8009a94:	687b      	ldr	r3, [r7, #4]
 8009a96:	2200      	movs	r2, #0
 8009a98:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
        ssl->options.weOwnRng = 0;
 8009a9c:	687a      	ldr	r2, [r7, #4]
 8009a9e:	f892 32d5 	ldrb.w	r3, [r2, #725]	@ 0x2d5
 8009aa2:	f023 0308 	bic.w	r3, r3, #8
 8009aa6:	f882 32d5 	strb.w	r3, [r2, #725]	@ 0x2d5
    }
    FreeSuites(ssl);
 8009aaa:	6878      	ldr	r0, [r7, #4]
 8009aac:	f7ff ffb4 	bl	8009a18 <FreeSuites>
    FreeHandshakeHashes(ssl);
 8009ab0:	6878      	ldr	r0, [r7, #4]
 8009ab2:	f7ff fe5a 	bl	800976a <FreeHandshakeHashes>
    XFREE(ssl->buffers.domainName.buffer, ssl->heap, DYNAMIC_TYPE_DOMAIN);
 8009ab6:	687b      	ldr	r3, [r7, #4]
 8009ab8:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
 8009abc:	623b      	str	r3, [r7, #32]
 8009abe:	6a3b      	ldr	r3, [r7, #32]
 8009ac0:	2b00      	cmp	r3, #0
 8009ac2:	d002      	beq.n	8009aca <wolfSSL_ResourceFree+0x8a>
 8009ac4:	6a38      	ldr	r0, [r7, #32]
 8009ac6:	f014 fffb 	bl	801eac0 <wolfSSL_Free>

    /* clear keys struct after session */
    ForceZero(&ssl->keys, sizeof(Keys));
 8009aca:	687b      	ldr	r3, [r7, #4]
 8009acc:	f503 73f8 	add.w	r3, r3, #496	@ 0x1f0
 8009ad0:	21dc      	movs	r1, #220	@ 0xdc
 8009ad2:	4618      	mov	r0, r3
 8009ad4:	f7fe fef1 	bl	80088ba <ForceZero>

#ifdef WOLFSSL_TLS13
    ForceZero(&ssl->clientSecret, sizeof(ssl->clientSecret));
 8009ad8:	687b      	ldr	r3, [r7, #4]
 8009ada:	3314      	adds	r3, #20
 8009adc:	2130      	movs	r1, #48	@ 0x30
 8009ade:	4618      	mov	r0, r3
 8009ae0:	f7fe feeb 	bl	80088ba <ForceZero>
    ForceZero(&ssl->serverSecret, sizeof(ssl->serverSecret));
 8009ae4:	687b      	ldr	r3, [r7, #4]
 8009ae6:	3344      	adds	r3, #68	@ 0x44
 8009ae8:	2130      	movs	r1, #48	@ 0x30
 8009aea:	4618      	mov	r0, r3
 8009aec:	f7fe fee5 	bl	80088ba <ForceZero>
    ForceZero(&ssl->serverFinished, TLS_FINISHED_SZ_MAX);
    ssl->serverFinished_len = 0;
    ssl->clientFinished_len = 0;
#endif
#ifndef NO_DH
    if (ssl->buffers.serverDH_Priv.buffer != NULL) {
 8009af0:	687b      	ldr	r3, [r7, #4]
 8009af2:	f8d3 3160 	ldr.w	r3, [r3, #352]	@ 0x160
 8009af6:	2b00      	cmp	r3, #0
 8009af8:	d009      	beq.n	8009b0e <wolfSSL_ResourceFree+0xce>
        ForceZero(ssl->buffers.serverDH_Priv.buffer,
 8009afa:	687b      	ldr	r3, [r7, #4]
 8009afc:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
 8009b00:	687b      	ldr	r3, [r7, #4]
 8009b02:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
 8009b06:	4619      	mov	r1, r3
 8009b08:	4610      	mov	r0, r2
 8009b0a:	f7fe fed6 	bl	80088ba <ForceZero>
                                             ssl->buffers.serverDH_Priv.length);
    }
    XFREE(ssl->buffers.serverDH_Priv.buffer, ssl->heap, DYNAMIC_TYPE_PRIVATE_KEY);
 8009b0e:	687b      	ldr	r3, [r7, #4]
 8009b10:	f8d3 3160 	ldr.w	r3, [r3, #352]	@ 0x160
 8009b14:	61fb      	str	r3, [r7, #28]
 8009b16:	69fb      	ldr	r3, [r7, #28]
 8009b18:	2b00      	cmp	r3, #0
 8009b1a:	d002      	beq.n	8009b22 <wolfSSL_ResourceFree+0xe2>
 8009b1c:	69f8      	ldr	r0, [r7, #28]
 8009b1e:	f014 ffcf 	bl	801eac0 <wolfSSL_Free>
    XFREE(ssl->buffers.serverDH_Pub.buffer, ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
 8009b22:	687b      	ldr	r3, [r7, #4]
 8009b24:	f8d3 3158 	ldr.w	r3, [r3, #344]	@ 0x158
 8009b28:	61bb      	str	r3, [r7, #24]
 8009b2a:	69bb      	ldr	r3, [r7, #24]
 8009b2c:	2b00      	cmp	r3, #0
 8009b2e:	d002      	beq.n	8009b36 <wolfSSL_ResourceFree+0xf6>
 8009b30:	69b8      	ldr	r0, [r7, #24]
 8009b32:	f014 ffc5 	bl	801eac0 <wolfSSL_Free>
    /* parameters (p,g) may be owned by ctx */
    if (ssl->buffers.weOwnDH) {
 8009b36:	687b      	ldr	r3, [r7, #4]
 8009b38:	f893 3147 	ldrb.w	r3, [r3, #327]	@ 0x147
 8009b3c:	2b00      	cmp	r3, #0
 8009b3e:	d013      	beq.n	8009b68 <wolfSSL_ResourceFree+0x128>
        XFREE(ssl->buffers.serverDH_G.buffer, ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
 8009b40:	687b      	ldr	r3, [r7, #4]
 8009b42:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 8009b46:	617b      	str	r3, [r7, #20]
 8009b48:	697b      	ldr	r3, [r7, #20]
 8009b4a:	2b00      	cmp	r3, #0
 8009b4c:	d002      	beq.n	8009b54 <wolfSSL_ResourceFree+0x114>
 8009b4e:	6978      	ldr	r0, [r7, #20]
 8009b50:	f014 ffb6 	bl	801eac0 <wolfSSL_Free>
        XFREE(ssl->buffers.serverDH_P.buffer, ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
 8009b54:	687b      	ldr	r3, [r7, #4]
 8009b56:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
 8009b5a:	613b      	str	r3, [r7, #16]
 8009b5c:	693b      	ldr	r3, [r7, #16]
 8009b5e:	2b00      	cmp	r3, #0
 8009b60:	d002      	beq.n	8009b68 <wolfSSL_ResourceFree+0x128>
 8009b62:	6938      	ldr	r0, [r7, #16]
 8009b64:	f014 ffac 	bl	801eac0 <wolfSSL_Free>
    }
#endif /* !NO_DH */
#ifndef NO_CERTS
    ssl->keepCert = 0; /* make sure certificate is free'd */
 8009b68:	687b      	ldr	r3, [r7, #4]
 8009b6a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8009b6e:	2200      	movs	r2, #0
 8009b70:	f883 2090 	strb.w	r2, [r3, #144]	@ 0x90
    wolfSSL_UnloadCertsKeys(ssl);
 8009b74:	6878      	ldr	r0, [r7, #4]
 8009b76:	f003 ff73 	bl	800da60 <wolfSSL_UnloadCertsKeys>
#endif
#ifndef NO_RSA
    FreeKey(ssl, DYNAMIC_TYPE_RSA, (void**)&ssl->peerRsaKey);
 8009b7a:	687b      	ldr	r3, [r7, #4]
 8009b7c:	f503 7351 	add.w	r3, r3, #836	@ 0x344
 8009b80:	461a      	mov	r2, r3
 8009b82:	210a      	movs	r1, #10
 8009b84:	6878      	ldr	r0, [r7, #4]
 8009b86:	f7ff fe7a 	bl	800987e <FreeKey>
    ssl->peerRsaKeyPresent = 0;
 8009b8a:	687b      	ldr	r3, [r7, #4]
 8009b8c:	2200      	movs	r2, #0
 8009b8e:	f883 2348 	strb.w	r2, [r3, #840]	@ 0x348
#if defined(WOLFSSL_RENESAS_TSIP_TLS) || defined(WOLFSSL_RENESAS_FSPSM_TLS)
    XFREE(ssl->peerSceTsipEncRsaKeyIndex, ssl->heap, DYNAMIC_TYPE_RSA);
    Renesas_cmn_Cleanup(ssl);
#endif
#ifndef NO_TLS
    if (ssl->buffers.inputBuffer.dynamicFlag)
 8009b92:	687b      	ldr	r3, [r7, #4]
 8009b94:	f893 30fc 	ldrb.w	r3, [r3, #252]	@ 0xfc
 8009b98:	2b00      	cmp	r3, #0
 8009b9a:	d003      	beq.n	8009ba4 <wolfSSL_ResourceFree+0x164>
        ShrinkInputBuffer(ssl, FORCED_FREE);
 8009b9c:	2101      	movs	r1, #1
 8009b9e:	6878      	ldr	r0, [r7, #4]
 8009ba0:	f000 f902 	bl	8009da8 <ShrinkInputBuffer>
    if (ssl->buffers.outputBuffer.dynamicFlag)
 8009ba4:	687b      	ldr	r3, [r7, #4]
 8009ba6:	f893 3118 	ldrb.w	r3, [r3, #280]	@ 0x118
 8009baa:	2b00      	cmp	r3, #0
 8009bac:	d002      	beq.n	8009bb4 <wolfSSL_ResourceFree+0x174>
        ShrinkOutputBuffer(ssl);
 8009bae:	6878      	ldr	r0, [r7, #4]
 8009bb0:	f000 f8d1 	bl	8009d56 <ShrinkOutputBuffer>
#ifdef OPENSSL_EXTRA
#ifndef NO_BIO
    /* Don't free if there was/is a previous element in the chain.
     * This means that this BIO was part of a chain that will be
     * free'd separately. */
    if (ssl->biord != ssl->biowr)        /* only free write if different */
 8009bb4:	687b      	ldr	r3, [r7, #4]
 8009bb6:	f8d3 232c 	ldr.w	r2, [r3, #812]	@ 0x32c
 8009bba:	687b      	ldr	r3, [r7, #4]
 8009bbc:	f8d3 3330 	ldr.w	r3, [r3, #816]	@ 0x330
 8009bc0:	429a      	cmp	r2, r3
 8009bc2:	d010      	beq.n	8009be6 <wolfSSL_ResourceFree+0x1a6>
        if (ssl->biowr != NULL && ssl->biowr->prev == NULL)
 8009bc4:	687b      	ldr	r3, [r7, #4]
 8009bc6:	f8d3 3330 	ldr.w	r3, [r3, #816]	@ 0x330
 8009bca:	2b00      	cmp	r3, #0
 8009bcc:	d00b      	beq.n	8009be6 <wolfSSL_ResourceFree+0x1a6>
 8009bce:	687b      	ldr	r3, [r7, #4]
 8009bd0:	f8d3 3330 	ldr.w	r3, [r3, #816]	@ 0x330
 8009bd4:	689b      	ldr	r3, [r3, #8]
 8009bd6:	2b00      	cmp	r3, #0
 8009bd8:	d105      	bne.n	8009be6 <wolfSSL_ResourceFree+0x1a6>
            wolfSSL_BIO_free(ssl->biowr);
 8009bda:	687b      	ldr	r3, [r7, #4]
 8009bdc:	f8d3 3330 	ldr.w	r3, [r3, #816]	@ 0x330
 8009be0:	4618      	mov	r0, r3
 8009be2:	f004 fa61 	bl	800e0a8 <wolfSSL_BIO_free>
    if (ssl->biord != NULL && ssl->biord->prev == NULL)
 8009be6:	687b      	ldr	r3, [r7, #4]
 8009be8:	f8d3 332c 	ldr.w	r3, [r3, #812]	@ 0x32c
 8009bec:	2b00      	cmp	r3, #0
 8009bee:	d00b      	beq.n	8009c08 <wolfSSL_ResourceFree+0x1c8>
 8009bf0:	687b      	ldr	r3, [r7, #4]
 8009bf2:	f8d3 332c 	ldr.w	r3, [r3, #812]	@ 0x32c
 8009bf6:	689b      	ldr	r3, [r3, #8]
 8009bf8:	2b00      	cmp	r3, #0
 8009bfa:	d105      	bne.n	8009c08 <wolfSSL_ResourceFree+0x1c8>
        wolfSSL_BIO_free(ssl->biord);
 8009bfc:	687b      	ldr	r3, [r7, #4]
 8009bfe:	f8d3 332c 	ldr.w	r3, [r3, #812]	@ 0x32c
 8009c02:	4618      	mov	r0, r3
 8009c04:	f004 fa50 	bl	800e0a8 <wolfSSL_BIO_free>
    ssl->biowr = NULL;
 8009c08:	687b      	ldr	r3, [r7, #4]
 8009c0a:	2200      	movs	r2, #0
 8009c0c:	f8c3 2330 	str.w	r2, [r3, #816]	@ 0x330
    ssl->biord = NULL;
 8009c10:	687b      	ldr	r3, [r7, #4]
 8009c12:	2200      	movs	r2, #0
 8009c14:	f8c3 232c 	str.w	r2, [r3, #812]	@ 0x32c
#endif
#ifdef HAVE_LIBZ
    FreeStreams(ssl);
#endif
#ifdef HAVE_ECC
    FreeKey(ssl, DYNAMIC_TYPE_ECC, (void**)&ssl->peerEccKey);
 8009c18:	687b      	ldr	r3, [r7, #4]
 8009c1a:	f503 7367 	add.w	r3, r3, #924	@ 0x39c
 8009c1e:	461a      	mov	r2, r3
 8009c20:	2125      	movs	r1, #37	@ 0x25
 8009c22:	6878      	ldr	r0, [r7, #4]
 8009c24:	f7ff fe2b 	bl	800987e <FreeKey>
    ssl->peerEccKeyPresent = 0;
 8009c28:	687b      	ldr	r3, [r7, #4]
 8009c2a:	2200      	movs	r2, #0
 8009c2c:	f883 2399 	strb.w	r2, [r3, #921]	@ 0x399
    FreeKey(ssl, DYNAMIC_TYPE_ECC, (void**)&ssl->peerEccDsaKey);
 8009c30:	687b      	ldr	r3, [r7, #4]
 8009c32:	f503 7368 	add.w	r3, r3, #928	@ 0x3a0
 8009c36:	461a      	mov	r2, r3
 8009c38:	2125      	movs	r1, #37	@ 0x25
 8009c3a:	6878      	ldr	r0, [r7, #4]
 8009c3c:	f7ff fe1f 	bl	800987e <FreeKey>
    ssl->peerEccDsaKeyPresent = 0;
 8009c40:	687b      	ldr	r3, [r7, #4]
 8009c42:	2200      	movs	r2, #0
 8009c44:	f883 23a6 	strb.w	r2, [r3, #934]	@ 0x3a6
#endif
#if defined(HAVE_ECC) || defined(HAVE_CURVE25519) ||defined(HAVE_CURVE448)
    {
        int dtype = 0;
 8009c48:	2300      	movs	r3, #0
 8009c4a:	60fb      	str	r3, [r7, #12]
    #ifdef HAVE_ECC
        dtype = DYNAMIC_TYPE_ECC;
 8009c4c:	2325      	movs	r3, #37	@ 0x25
 8009c4e:	60fb      	str	r3, [r7, #12]
           )
        {
            dtype = DYNAMIC_TYPE_CURVE448;
        }
    #endif /* HAVE_CURVE448 */
        FreeKey(ssl, dtype, (void**)&ssl->eccTempKey);
 8009c50:	687b      	ldr	r3, [r7, #4]
 8009c52:	f503 7365 	add.w	r3, r3, #916	@ 0x394
 8009c56:	461a      	mov	r2, r3
 8009c58:	68f9      	ldr	r1, [r7, #12]
 8009c5a:	6878      	ldr	r0, [r7, #4]
 8009c5c:	f7ff fe0f 	bl	800987e <FreeKey>
        ssl->eccTempKeyPresent = 0;
 8009c60:	687b      	ldr	r3, [r7, #4]
 8009c62:	2200      	movs	r2, #0
 8009c64:	f883 2398 	strb.w	r2, [r3, #920]	@ 0x398
        XFREE(ssl->buffers.peerRsaKey.buffer, ssl->heap, DYNAMIC_TYPE_RSA);
    #endif /* NO_RSA */
#endif /* HAVE_PK_CALLBACKS */
#ifdef HAVE_TLS_EXTENSIONS
#if !defined(NO_TLS)
    TLSX_FreeAll(ssl->extensions, ssl->heap);
 8009c68:	687b      	ldr	r3, [r7, #4]
 8009c6a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8009c6e:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
 8009c72:	687b      	ldr	r3, [r7, #4]
 8009c74:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8009c78:	4619      	mov	r1, r3
 8009c7a:	4610      	mov	r0, r2
 8009c7c:	f005 fbc8 	bl	800f410 <TLSX_FreeAll>
#ifdef HAVE_NETX
    if (ssl->nxCtx.nxPacket)
        nx_packet_release(ssl->nxCtx.nxPacket);
#endif
#if defined(OPENSSL_EXTRA) || defined(WOLFSSL_WPAS_SMALL)
    if (ssl->x509_store_pt)
 8009c80:	687b      	ldr	r3, [r7, #4]
 8009c82:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 8009c86:	2b00      	cmp	r3, #0
 8009c88:	d005      	beq.n	8009c96 <wolfSSL_ResourceFree+0x256>
        wolfSSL_X509_STORE_free(ssl->x509_store_pt);
 8009c8a:	687b      	ldr	r3, [r7, #4]
 8009c8c:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 8009c90:	4618      	mov	r0, r3
 8009c92:	f005 fa0e 	bl	800f0b2 <wolfSSL_X509_STORE_free>
#endif
#ifdef KEEP_PEER_CERT
    FreeX509(&ssl->peerCert);
 8009c96:	687b      	ldr	r3, [r7, #4]
 8009c98:	f503 736f 	add.w	r3, r3, #956	@ 0x3bc
 8009c9c:	4618      	mov	r0, r3
 8009c9e:	f7ff fc7c 	bl	800959a <FreeX509>
#endif

    if (ssl->session != NULL)
 8009ca2:	687b      	ldr	r3, [r7, #4]
 8009ca4:	f8d3 318c 	ldr.w	r3, [r3, #396]	@ 0x18c
 8009ca8:	2b00      	cmp	r3, #0
 8009caa:	d008      	beq.n	8009cbe <wolfSSL_ResourceFree+0x27e>
        wolfSSL_FreeSession(ssl->ctx, ssl->session);
 8009cac:	687b      	ldr	r3, [r7, #4]
 8009cae:	681a      	ldr	r2, [r3, #0]
 8009cb0:	687b      	ldr	r3, [r7, #4]
 8009cb2:	f8d3 318c 	ldr.w	r3, [r3, #396]	@ 0x18c
 8009cb6:	4619      	mov	r1, r3
 8009cb8:	4610      	mov	r0, r2
 8009cba:	f001 fdae 	bl	800b81a <wolfSSL_FreeSession>
    if (ssl->dupWrite) {
        FreeWriteDup(ssl);
    }
#endif
#ifdef OPENSSL_EXTRA
    XFREE(ssl->param, ssl->heap, DYNAMIC_TYPE_OPENSSL);
 8009cbe:	687b      	ldr	r3, [r7, #4]
 8009cc0:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 8009cc4:	60bb      	str	r3, [r7, #8]
 8009cc6:	68bb      	ldr	r3, [r7, #8]
 8009cc8:	2b00      	cmp	r3, #0
 8009cca:	d002      	beq.n	8009cd2 <wolfSSL_ResourceFree+0x292>
 8009ccc:	68b8      	ldr	r0, [r7, #8]
 8009cce:	f014 fef7 	bl	801eac0 <wolfSSL_Free>
    }
#endif /* WOLFSSL_STATIC_MEMORY */
#ifdef OPENSSL_EXTRA
    /* Enough to free stack structure since WOLFSSL_CIPHER
     * isn't allocated separately. */
    wolfSSL_sk_CIPHER_free(ssl->supportedCiphers);
 8009cd2:	687b      	ldr	r3, [r7, #4]
 8009cd4:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8009cd8:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 8009cdc:	4618      	mov	r0, r3
 8009cde:	f003 ff99 	bl	800dc14 <wolfSSL_sk_CIPHER_free>
    wolfSSL_sk_X509_pop_free(ssl->peerCertChain, NULL);
 8009ce2:	687b      	ldr	r3, [r7, #4]
 8009ce4:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8009ce8:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 8009cec:	2100      	movs	r1, #0
 8009cee:	4618      	mov	r0, r3
 8009cf0:	f004 fb34 	bl	800e35c <wolfSSL_sk_X509_pop_free>
    #ifdef KEEP_OUR_CERT
    wolfSSL_sk_X509_pop_free(ssl->ourCertChain, NULL);
    #endif
#endif
#if defined(OPENSSL_EXTRA) || defined(WOLFSSL_EXTRA) || defined(HAVE_LIGHTY)
    wolfSSL_sk_X509_NAME_pop_free(ssl->client_ca_names, NULL);
 8009cf4:	687b      	ldr	r3, [r7, #4]
 8009cf6:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8009cfa:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
 8009cfe:	2100      	movs	r1, #0
 8009d00:	4618      	mov	r0, r3
 8009d02:	f004 ff37 	bl	800eb74 <wolfSSL_sk_X509_NAME_pop_free>
    ssl->client_ca_names = NULL;
 8009d06:	687b      	ldr	r3, [r7, #4]
 8009d08:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8009d0c:	461a      	mov	r2, r3
 8009d0e:	2300      	movs	r3, #0
 8009d10:	f8c2 30ac 	str.w	r3, [r2, #172]	@ 0xac
    ssl->initial_ctx = NULL;
#endif
#ifdef WOLFSSL_DUAL_ALG_CERTS
    XFREE(ssl->peerSigSpec, ssl->heap, DYNAMIC_TYPE_TLSX);
#endif
}
 8009d14:	bf00      	nop
 8009d16:	3728      	adds	r7, #40	@ 0x28
 8009d18:	46bd      	mov	sp, r7
 8009d1a:	bd80      	pop	{r7, pc}

08009d1c <FreeSSL>:
}


/* heap argument is the heap hint used when creating SSL */
void FreeSSL(WOLFSSL* ssl, void* heap)
{
 8009d1c:	b580      	push	{r7, lr}
 8009d1e:	b084      	sub	sp, #16
 8009d20:	af00      	add	r7, sp, #0
 8009d22:	6078      	str	r0, [r7, #4]
 8009d24:	6039      	str	r1, [r7, #0]
    WOLFSSL_CTX* ctx = ssl->ctx;
 8009d26:	687b      	ldr	r3, [r7, #4]
 8009d28:	681b      	ldr	r3, [r3, #0]
 8009d2a:	60fb      	str	r3, [r7, #12]
    wolfSSL_ResourceFree(ssl);
 8009d2c:	6878      	ldr	r0, [r7, #4]
 8009d2e:	f7ff fe87 	bl	8009a40 <wolfSSL_ResourceFree>
    XFREE(ssl, heap, DYNAMIC_TYPE_SSL);
 8009d32:	687b      	ldr	r3, [r7, #4]
 8009d34:	60bb      	str	r3, [r7, #8]
 8009d36:	68bb      	ldr	r3, [r7, #8]
 8009d38:	2b00      	cmp	r3, #0
 8009d3a:	d002      	beq.n	8009d42 <FreeSSL+0x26>
 8009d3c:	68b8      	ldr	r0, [r7, #8]
 8009d3e:	f014 febf 	bl	801eac0 <wolfSSL_Free>
    if (ctx)
 8009d42:	68fb      	ldr	r3, [r7, #12]
 8009d44:	2b00      	cmp	r3, #0
 8009d46:	d002      	beq.n	8009d4e <FreeSSL+0x32>
        FreeSSL_Ctx(ctx); /* will decrement and free underlying CTX if 0 */
 8009d48:	68f8      	ldr	r0, [r7, #12]
 8009d4a:	f7fe ffe3 	bl	8008d14 <FreeSSL_Ctx>
    (void)heap;
#ifdef WOLFSSL_CHECK_MEM_ZERO
    wc_MemZero_Check(ssl, sizeof(*ssl));
#endif
}
 8009d4e:	bf00      	nop
 8009d50:	3710      	adds	r7, #16
 8009d52:	46bd      	mov	sp, r7
 8009d54:	bd80      	pop	{r7, pc}

08009d56 <ShrinkOutputBuffer>:
}


/* Switch dynamic output buffer back to static, buffer is assumed clear */
void ShrinkOutputBuffer(WOLFSSL* ssl)
{
 8009d56:	b580      	push	{r7, lr}
 8009d58:	b084      	sub	sp, #16
 8009d5a:	af00      	add	r7, sp, #0
 8009d5c:	6078      	str	r0, [r7, #4]
    WOLFSSL_MSG("Shrinking output buffer");
    XFREE(ssl->buffers.outputBuffer.buffer - ssl->buffers.outputBuffer.offset,
 8009d5e:	687b      	ldr	r3, [r7, #4]
 8009d60:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
 8009d64:	687b      	ldr	r3, [r7, #4]
 8009d66:	f893 3119 	ldrb.w	r3, [r3, #281]	@ 0x119
 8009d6a:	425b      	negs	r3, r3
 8009d6c:	4413      	add	r3, r2
 8009d6e:	60fb      	str	r3, [r7, #12]
 8009d70:	68fb      	ldr	r3, [r7, #12]
 8009d72:	2b00      	cmp	r3, #0
 8009d74:	d002      	beq.n	8009d7c <ShrinkOutputBuffer+0x26>
 8009d76:	68f8      	ldr	r0, [r7, #12]
 8009d78:	f014 fea2 	bl	801eac0 <wolfSSL_Free>
          ssl->heap, DYNAMIC_TYPE_OUT_BUFFER);
    ssl->buffers.outputBuffer.buffer = ssl->buffers.outputBuffer.staticBuffer;
 8009d7c:	687b      	ldr	r3, [r7, #4]
 8009d7e:	f503 7280 	add.w	r2, r3, #256	@ 0x100
 8009d82:	687b      	ldr	r3, [r7, #4]
 8009d84:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
    ssl->buffers.outputBuffer.bufferSize  = STATIC_BUFFER_LEN;
 8009d88:	687b      	ldr	r3, [r7, #4]
 8009d8a:	2205      	movs	r2, #5
 8009d8c:	f8c3 2114 	str.w	r2, [r3, #276]	@ 0x114
    ssl->buffers.outputBuffer.dynamicFlag = 0;
 8009d90:	687b      	ldr	r3, [r7, #4]
 8009d92:	2200      	movs	r2, #0
 8009d94:	f883 2118 	strb.w	r2, [r3, #280]	@ 0x118
    ssl->buffers.outputBuffer.offset      = 0;
 8009d98:	687b      	ldr	r3, [r7, #4]
 8009d9a:	2200      	movs	r2, #0
 8009d9c:	f883 2119 	strb.w	r2, [r3, #281]	@ 0x119
    /* idx and length are assumed to be 0. */
}
 8009da0:	bf00      	nop
 8009da2:	3710      	adds	r7, #16
 8009da4:	46bd      	mov	sp, r7
 8009da6:	bd80      	pop	{r7, pc}

08009da8 <ShrinkInputBuffer>:
/* forced free means cleaning up */
/* Be *CAREFUL* where this function is called. ProcessReply relies on
 * inputBuffer.idx *NOT* changing inside the ProcessReply function. ProcessReply
 * calls ShrinkInputBuffer itself when it is safe to do so. Don't overuse it. */
void ShrinkInputBuffer(WOLFSSL* ssl, int forcedFree)
{
 8009da8:	b580      	push	{r7, lr}
 8009daa:	b084      	sub	sp, #16
 8009dac:	af00      	add	r7, sp, #0
 8009dae:	6078      	str	r0, [r7, #4]
 8009db0:	6039      	str	r1, [r7, #0]
    int usedLength = (int)(ssl->buffers.inputBuffer.length -
 8009db2:	687b      	ldr	r3, [r7, #4]
 8009db4:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
                     ssl->buffers.inputBuffer.idx);
 8009db8:	687b      	ldr	r3, [r7, #4]
 8009dba:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
    int usedLength = (int)(ssl->buffers.inputBuffer.length -
 8009dbe:	1ad3      	subs	r3, r2, r3
 8009dc0:	60fb      	str	r3, [r7, #12]
    if (!forcedFree && (usedLength > STATIC_BUFFER_LEN ||
 8009dc2:	683b      	ldr	r3, [r7, #0]
 8009dc4:	2b00      	cmp	r3, #0
 8009dc6:	d107      	bne.n	8009dd8 <ShrinkInputBuffer+0x30>
 8009dc8:	68fb      	ldr	r3, [r7, #12]
 8009dca:	2b05      	cmp	r3, #5
 8009dcc:	dc4c      	bgt.n	8009e68 <ShrinkInputBuffer+0xc0>
            ssl->buffers.clearOutputBuffer.length > 0))
 8009dce:	687b      	ldr	r3, [r7, #4]
 8009dd0:	f8d3 3128 	ldr.w	r3, [r3, #296]	@ 0x128
    if (!forcedFree && (usedLength > STATIC_BUFFER_LEN ||
 8009dd4:	2b00      	cmp	r3, #0
 8009dd6:	d147      	bne.n	8009e68 <ShrinkInputBuffer+0xc0>
        return;

    WOLFSSL_MSG("Shrinking input buffer");

    if (!forcedFree && usedLength > 0) {
 8009dd8:	683b      	ldr	r3, [r7, #0]
 8009dda:	2b00      	cmp	r3, #0
 8009ddc:	d110      	bne.n	8009e00 <ShrinkInputBuffer+0x58>
 8009dde:	68fb      	ldr	r3, [r7, #12]
 8009de0:	2b00      	cmp	r3, #0
 8009de2:	dd0d      	ble.n	8009e00 <ShrinkInputBuffer+0x58>
        XMEMCPY(ssl->buffers.inputBuffer.staticBuffer,
 8009de4:	687b      	ldr	r3, [r7, #4]
 8009de6:	f103 00e4 	add.w	r0, r3, #228	@ 0xe4
 8009dea:	687b      	ldr	r3, [r7, #4]
 8009dec:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
 8009df0:	687b      	ldr	r3, [r7, #4]
 8009df2:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8009df6:	4413      	add	r3, r2
 8009df8:	68fa      	ldr	r2, [r7, #12]
 8009dfa:	4619      	mov	r1, r3
 8009dfc:	f01e fbce 	bl	802859c <memcpy>
               ssl->buffers.inputBuffer.buffer + ssl->buffers.inputBuffer.idx,
               usedLength);
    }

    ForceZero(ssl->buffers.inputBuffer.buffer,
 8009e00:	687b      	ldr	r3, [r7, #4]
 8009e02:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
 8009e06:	687b      	ldr	r3, [r7, #4]
 8009e08:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8009e0c:	4619      	mov	r1, r3
 8009e0e:	4610      	mov	r0, r2
 8009e10:	f7fe fd53 	bl	80088ba <ForceZero>
        ssl->buffers.inputBuffer.length);
    XFREE(ssl->buffers.inputBuffer.buffer - ssl->buffers.inputBuffer.offset,
 8009e14:	687b      	ldr	r3, [r7, #4]
 8009e16:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
 8009e1a:	687b      	ldr	r3, [r7, #4]
 8009e1c:	f893 30fd 	ldrb.w	r3, [r3, #253]	@ 0xfd
 8009e20:	425b      	negs	r3, r3
 8009e22:	4413      	add	r3, r2
 8009e24:	60bb      	str	r3, [r7, #8]
 8009e26:	68bb      	ldr	r3, [r7, #8]
 8009e28:	2b00      	cmp	r3, #0
 8009e2a:	d002      	beq.n	8009e32 <ShrinkInputBuffer+0x8a>
 8009e2c:	68b8      	ldr	r0, [r7, #8]
 8009e2e:	f014 fe47 	bl	801eac0 <wolfSSL_Free>
          ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
    ssl->buffers.inputBuffer.buffer = ssl->buffers.inputBuffer.staticBuffer;
 8009e32:	687b      	ldr	r3, [r7, #4]
 8009e34:	f103 02e4 	add.w	r2, r3, #228	@ 0xe4
 8009e38:	687b      	ldr	r3, [r7, #4]
 8009e3a:	f8c3 20ec 	str.w	r2, [r3, #236]	@ 0xec
    ssl->buffers.inputBuffer.bufferSize  = STATIC_BUFFER_LEN;
 8009e3e:	687b      	ldr	r3, [r7, #4]
 8009e40:	2205      	movs	r2, #5
 8009e42:	f8c3 20f8 	str.w	r2, [r3, #248]	@ 0xf8
    ssl->buffers.inputBuffer.dynamicFlag = 0;
 8009e46:	687b      	ldr	r3, [r7, #4]
 8009e48:	2200      	movs	r2, #0
 8009e4a:	f883 20fc 	strb.w	r2, [r3, #252]	@ 0xfc
    ssl->buffers.inputBuffer.offset      = 0;
 8009e4e:	687b      	ldr	r3, [r7, #4]
 8009e50:	2200      	movs	r2, #0
 8009e52:	f883 20fd 	strb.w	r2, [r3, #253]	@ 0xfd
    ssl->buffers.inputBuffer.idx = 0;
 8009e56:	687b      	ldr	r3, [r7, #4]
 8009e58:	2200      	movs	r2, #0
 8009e5a:	f8c3 20f4 	str.w	r2, [r3, #244]	@ 0xf4
    ssl->buffers.inputBuffer.length = (word32)usedLength;
 8009e5e:	68fa      	ldr	r2, [r7, #12]
 8009e60:	687b      	ldr	r3, [r7, #4]
 8009e62:	f8c3 20f0 	str.w	r2, [r3, #240]	@ 0xf0
 8009e66:	e000      	b.n	8009e6a <ShrinkInputBuffer+0xc2>
        return;
 8009e68:	bf00      	nop
}
 8009e6a:	3710      	adds	r7, #16
 8009e6c:	46bd      	mov	sp, r7
 8009e6e:	bd80      	pop	{r7, pc}

08009e70 <MatchDomainName>:
   to left-most name component, compatible with RFC 2830 identity checking.

   return 1 on success */
int MatchDomainName(const char* pattern, int patternLen, const char* str,
                    word32 strLen, unsigned int flags)
{
 8009e70:	b480      	push	{r7}
 8009e72:	b089      	sub	sp, #36	@ 0x24
 8009e74:	af00      	add	r7, sp, #0
 8009e76:	60f8      	str	r0, [r7, #12]
 8009e78:	60b9      	str	r1, [r7, #8]
 8009e7a:	607a      	str	r2, [r7, #4]
 8009e7c:	603b      	str	r3, [r7, #0]
    int ret = 0;
 8009e7e:	2300      	movs	r3, #0
 8009e80:	61fb      	str	r3, [r7, #28]
    byte wildcardEligible = 1;
 8009e82:	2301      	movs	r3, #1
 8009e84:	76fb      	strb	r3, [r7, #27]
    byte leftWildcardOnly = flags & WOLFSSL_LEFT_MOST_WILDCARD_ONLY;
 8009e86:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8009e88:	b2db      	uxtb	r3, r3
 8009e8a:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8009e8e:	767b      	strb	r3, [r7, #25]

    if (pattern == NULL || str == NULL || patternLen <= 0 || strLen == 0)
 8009e90:	68fb      	ldr	r3, [r7, #12]
 8009e92:	2b00      	cmp	r3, #0
 8009e94:	d009      	beq.n	8009eaa <MatchDomainName+0x3a>
 8009e96:	687b      	ldr	r3, [r7, #4]
 8009e98:	2b00      	cmp	r3, #0
 8009e9a:	d006      	beq.n	8009eaa <MatchDomainName+0x3a>
 8009e9c:	68bb      	ldr	r3, [r7, #8]
 8009e9e:	2b00      	cmp	r3, #0
 8009ea0:	dd03      	ble.n	8009eaa <MatchDomainName+0x3a>
 8009ea2:	683b      	ldr	r3, [r7, #0]
 8009ea4:	2b00      	cmp	r3, #0
 8009ea6:	f040 80b0 	bne.w	800a00a <MatchDomainName+0x19a>
        return 0;
 8009eaa:	2300      	movs	r3, #0
 8009eac:	e0bc      	b.n	800a028 <MatchDomainName+0x1b8>

    while (patternLen > 0) {
        /* Get the next pattern char to evaluate */
        char p = (char)XTOLOWER((unsigned char)*pattern);
 8009eae:	68fb      	ldr	r3, [r7, #12]
 8009eb0:	781b      	ldrb	r3, [r3, #0]
 8009eb2:	763b      	strb	r3, [r7, #24]
 8009eb4:	7e3b      	ldrb	r3, [r7, #24]
 8009eb6:	3301      	adds	r3, #1
 8009eb8:	4a5e      	ldr	r2, [pc, #376]	@ (800a034 <MatchDomainName+0x1c4>)
 8009eba:	4413      	add	r3, r2
 8009ebc:	781b      	ldrb	r3, [r3, #0]
 8009ebe:	f003 0303 	and.w	r3, r3, #3
 8009ec2:	2b01      	cmp	r3, #1
 8009ec4:	d102      	bne.n	8009ecc <MatchDomainName+0x5c>
 8009ec6:	7e3b      	ldrb	r3, [r7, #24]
 8009ec8:	3320      	adds	r3, #32
 8009eca:	e000      	b.n	8009ece <MatchDomainName+0x5e>
 8009ecc:	7e3b      	ldrb	r3, [r7, #24]
 8009ece:	76bb      	strb	r3, [r7, #26]
        if (p == '\0')
 8009ed0:	7ebb      	ldrb	r3, [r7, #26]
 8009ed2:	2b00      	cmp	r3, #0
 8009ed4:	f000 809e 	beq.w	800a014 <MatchDomainName+0x1a4>
            break;

        pattern++;
 8009ed8:	68fb      	ldr	r3, [r7, #12]
 8009eda:	3301      	adds	r3, #1
 8009edc:	60fb      	str	r3, [r7, #12]

        if ((p == '*') && wildcardEligible) {
 8009ede:	7ebb      	ldrb	r3, [r7, #26]
 8009ee0:	2b2a      	cmp	r3, #42	@ 0x2a
 8009ee2:	d16b      	bne.n	8009fbc <MatchDomainName+0x14c>
 8009ee4:	7efb      	ldrb	r3, [r7, #27]
 8009ee6:	2b00      	cmp	r3, #0
 8009ee8:	d068      	beq.n	8009fbc <MatchDomainName+0x14c>
            char s;
            /* We will always match '*' */
            patternLen--;
 8009eea:	68bb      	ldr	r3, [r7, #8]
 8009eec:	3b01      	subs	r3, #1
 8009eee:	60bb      	str	r3, [r7, #8]

            /* Only single wildcard allowed with strict left only */
            if (leftWildcardOnly) {
 8009ef0:	7e7b      	ldrb	r3, [r7, #25]
 8009ef2:	2b00      	cmp	r3, #0
 8009ef4:	d02c      	beq.n	8009f50 <MatchDomainName+0xe0>
                wildcardEligible = 0;
 8009ef6:	2300      	movs	r3, #0
 8009ef8:	76fb      	strb	r3, [r7, #27]
            }

            /* Consume any extra '*' chars until the next non '*' char. */
            while (patternLen > 0) {
 8009efa:	e029      	b.n	8009f50 <MatchDomainName+0xe0>
                p = (char)XTOLOWER((unsigned char)*pattern);
 8009efc:	68fb      	ldr	r3, [r7, #12]
 8009efe:	781b      	ldrb	r3, [r3, #0]
 8009f00:	75fb      	strb	r3, [r7, #23]
 8009f02:	7dfb      	ldrb	r3, [r7, #23]
 8009f04:	3301      	adds	r3, #1
 8009f06:	4a4b      	ldr	r2, [pc, #300]	@ (800a034 <MatchDomainName+0x1c4>)
 8009f08:	4413      	add	r3, r2
 8009f0a:	781b      	ldrb	r3, [r3, #0]
 8009f0c:	f003 0303 	and.w	r3, r3, #3
 8009f10:	2b01      	cmp	r3, #1
 8009f12:	d102      	bne.n	8009f1a <MatchDomainName+0xaa>
 8009f14:	7dfb      	ldrb	r3, [r7, #23]
 8009f16:	3320      	adds	r3, #32
 8009f18:	e000      	b.n	8009f1c <MatchDomainName+0xac>
 8009f1a:	7dfb      	ldrb	r3, [r7, #23]
 8009f1c:	76bb      	strb	r3, [r7, #26]
                pattern++;
 8009f1e:	68fb      	ldr	r3, [r7, #12]
 8009f20:	3301      	adds	r3, #1
 8009f22:	60fb      	str	r3, [r7, #12]
                if (p == '\0' && patternLen > 0)
 8009f24:	7ebb      	ldrb	r3, [r7, #26]
 8009f26:	2b00      	cmp	r3, #0
 8009f28:	d104      	bne.n	8009f34 <MatchDomainName+0xc4>
 8009f2a:	68bb      	ldr	r3, [r7, #8]
 8009f2c:	2b00      	cmp	r3, #0
 8009f2e:	dd01      	ble.n	8009f34 <MatchDomainName+0xc4>
                    return 0;
 8009f30:	2300      	movs	r3, #0
 8009f32:	e079      	b.n	800a028 <MatchDomainName+0x1b8>
                if (p != '*')
 8009f34:	7ebb      	ldrb	r3, [r7, #26]
 8009f36:	2b2a      	cmp	r3, #42	@ 0x2a
 8009f38:	d10e      	bne.n	8009f58 <MatchDomainName+0xe8>
                    break;
                if (leftWildcardOnly && (p == '*')) {
 8009f3a:	7e7b      	ldrb	r3, [r7, #25]
 8009f3c:	2b00      	cmp	r3, #0
 8009f3e:	d004      	beq.n	8009f4a <MatchDomainName+0xda>
 8009f40:	7ebb      	ldrb	r3, [r7, #26]
 8009f42:	2b2a      	cmp	r3, #42	@ 0x2a
 8009f44:	d101      	bne.n	8009f4a <MatchDomainName+0xda>
                    /* RFC2830 only allows single left-most wildcard */
                    return 0;
 8009f46:	2300      	movs	r3, #0
 8009f48:	e06e      	b.n	800a028 <MatchDomainName+0x1b8>
                }

                patternLen--;
 8009f4a:	68bb      	ldr	r3, [r7, #8]
 8009f4c:	3b01      	subs	r3, #1
 8009f4e:	60bb      	str	r3, [r7, #8]
            while (patternLen > 0) {
 8009f50:	68bb      	ldr	r3, [r7, #8]
 8009f52:	2b00      	cmp	r3, #0
 8009f54:	dcd2      	bgt.n	8009efc <MatchDomainName+0x8c>
 8009f56:	e02b      	b.n	8009fb0 <MatchDomainName+0x140>
                    break;
 8009f58:	bf00      	nop
            }

            /* Consume str until we reach next char in pattern after '*' or
             * end of string */
            while (strLen > 0) {
 8009f5a:	e029      	b.n	8009fb0 <MatchDomainName+0x140>
                s = (char)XTOLOWER((unsigned char) *str);
 8009f5c:	687b      	ldr	r3, [r7, #4]
 8009f5e:	781b      	ldrb	r3, [r3, #0]
 8009f60:	75bb      	strb	r3, [r7, #22]
 8009f62:	7dbb      	ldrb	r3, [r7, #22]
 8009f64:	3301      	adds	r3, #1
 8009f66:	4a33      	ldr	r2, [pc, #204]	@ (800a034 <MatchDomainName+0x1c4>)
 8009f68:	4413      	add	r3, r2
 8009f6a:	781b      	ldrb	r3, [r3, #0]
 8009f6c:	f003 0303 	and.w	r3, r3, #3
 8009f70:	2b01      	cmp	r3, #1
 8009f72:	d102      	bne.n	8009f7a <MatchDomainName+0x10a>
 8009f74:	7dbb      	ldrb	r3, [r7, #22]
 8009f76:	3320      	adds	r3, #32
 8009f78:	e000      	b.n	8009f7c <MatchDomainName+0x10c>
 8009f7a:	7dbb      	ldrb	r3, [r7, #22]
 8009f7c:	757b      	strb	r3, [r7, #21]
                str++;
 8009f7e:	687b      	ldr	r3, [r7, #4]
 8009f80:	3301      	adds	r3, #1
 8009f82:	607b      	str	r3, [r7, #4]
                strLen--;
 8009f84:	683b      	ldr	r3, [r7, #0]
 8009f86:	3b01      	subs	r3, #1
 8009f88:	603b      	str	r3, [r7, #0]

                /* p is next char in pattern after '*', or '*' if '*' is the
                 * last char in the pattern (in which case patternLen is 1) */
                if ( ((s == p) && (patternLen > 0))) {
 8009f8a:	7d7a      	ldrb	r2, [r7, #21]
 8009f8c:	7ebb      	ldrb	r3, [r7, #26]
 8009f8e:	429a      	cmp	r2, r3
 8009f90:	d106      	bne.n	8009fa0 <MatchDomainName+0x130>
 8009f92:	68bb      	ldr	r3, [r7, #8]
 8009f94:	2b00      	cmp	r3, #0
 8009f96:	dd03      	ble.n	8009fa0 <MatchDomainName+0x130>
                    /* We had already counted the '*' as matched, this means
                     * we also matched the next non '*' char in pattern */
                    patternLen--;
 8009f98:	68bb      	ldr	r3, [r7, #8]
 8009f9a:	3b01      	subs	r3, #1
 8009f9c:	60bb      	str	r3, [r7, #8]
                    break;
 8009f9e:	e00c      	b.n	8009fba <MatchDomainName+0x14a>
                }

                /* If strlen is 0, we have consumed the entire string. Count that
                 * as a match of '*' */
                if (strLen == 0) {
 8009fa0:	683b      	ldr	r3, [r7, #0]
 8009fa2:	2b00      	cmp	r3, #0
 8009fa4:	d008      	beq.n	8009fb8 <MatchDomainName+0x148>
                    break;
                }

                if (s == '.')
 8009fa6:	7d7b      	ldrb	r3, [r7, #21]
 8009fa8:	2b2e      	cmp	r3, #46	@ 0x2e
 8009faa:	d101      	bne.n	8009fb0 <MatchDomainName+0x140>
                    return 0;
 8009fac:	2300      	movs	r3, #0
 8009fae:	e03b      	b.n	800a028 <MatchDomainName+0x1b8>
            while (strLen > 0) {
 8009fb0:	683b      	ldr	r3, [r7, #0]
 8009fb2:	2b00      	cmp	r3, #0
 8009fb4:	d1d2      	bne.n	8009f5c <MatchDomainName+0xec>
        if ((p == '*') && wildcardEligible) {
 8009fb6:	e028      	b.n	800a00a <MatchDomainName+0x19a>
                    break;
 8009fb8:	bf00      	nop
        if ((p == '*') && wildcardEligible) {
 8009fba:	e026      	b.n	800a00a <MatchDomainName+0x19a>
            }
        }
        else {
            /* Past left-most wildcard location, not eligible if flag set*/
            if (leftWildcardOnly && wildcardEligible) {
 8009fbc:	7e7b      	ldrb	r3, [r7, #25]
 8009fbe:	2b00      	cmp	r3, #0
 8009fc0:	d004      	beq.n	8009fcc <MatchDomainName+0x15c>
 8009fc2:	7efb      	ldrb	r3, [r7, #27]
 8009fc4:	2b00      	cmp	r3, #0
 8009fc6:	d001      	beq.n	8009fcc <MatchDomainName+0x15c>
                wildcardEligible = 0;
 8009fc8:	2300      	movs	r3, #0
 8009fca:	76fb      	strb	r3, [r7, #27]
            }

            /* Simple case, pattern match exactly */
            if (p != (char)XTOLOWER((unsigned char) *str))
 8009fcc:	687b      	ldr	r3, [r7, #4]
 8009fce:	781b      	ldrb	r3, [r3, #0]
 8009fd0:	753b      	strb	r3, [r7, #20]
 8009fd2:	7d3b      	ldrb	r3, [r7, #20]
 8009fd4:	3301      	adds	r3, #1
 8009fd6:	4a17      	ldr	r2, [pc, #92]	@ (800a034 <MatchDomainName+0x1c4>)
 8009fd8:	4413      	add	r3, r2
 8009fda:	781b      	ldrb	r3, [r3, #0]
 8009fdc:	f003 0303 	and.w	r3, r3, #3
 8009fe0:	2b01      	cmp	r3, #1
 8009fe2:	d102      	bne.n	8009fea <MatchDomainName+0x17a>
 8009fe4:	7d3b      	ldrb	r3, [r7, #20]
 8009fe6:	3320      	adds	r3, #32
 8009fe8:	e000      	b.n	8009fec <MatchDomainName+0x17c>
 8009fea:	7d3b      	ldrb	r3, [r7, #20]
 8009fec:	b2db      	uxtb	r3, r3
 8009fee:	7eba      	ldrb	r2, [r7, #26]
 8009ff0:	429a      	cmp	r2, r3
 8009ff2:	d001      	beq.n	8009ff8 <MatchDomainName+0x188>
                return 0;
 8009ff4:	2300      	movs	r3, #0
 8009ff6:	e017      	b.n	800a028 <MatchDomainName+0x1b8>

            str++;
 8009ff8:	687b      	ldr	r3, [r7, #4]
 8009ffa:	3301      	adds	r3, #1
 8009ffc:	607b      	str	r3, [r7, #4]
            strLen--;
 8009ffe:	683b      	ldr	r3, [r7, #0]
 800a000:	3b01      	subs	r3, #1
 800a002:	603b      	str	r3, [r7, #0]
            patternLen--;
 800a004:	68bb      	ldr	r3, [r7, #8]
 800a006:	3b01      	subs	r3, #1
 800a008:	60bb      	str	r3, [r7, #8]
    while (patternLen > 0) {
 800a00a:	68bb      	ldr	r3, [r7, #8]
 800a00c:	2b00      	cmp	r3, #0
 800a00e:	f73f af4e 	bgt.w	8009eae <MatchDomainName+0x3e>
 800a012:	e000      	b.n	800a016 <MatchDomainName+0x1a6>
            break;
 800a014:	bf00      	nop
        }
    }

    if (strLen == 0 && patternLen == 0) {
 800a016:	683b      	ldr	r3, [r7, #0]
 800a018:	2b00      	cmp	r3, #0
 800a01a:	d104      	bne.n	800a026 <MatchDomainName+0x1b6>
 800a01c:	68bb      	ldr	r3, [r7, #8]
 800a01e:	2b00      	cmp	r3, #0
 800a020:	d101      	bne.n	800a026 <MatchDomainName+0x1b6>
        ret = 1; /* success */
 800a022:	2301      	movs	r3, #1
 800a024:	61fb      	str	r3, [r7, #28]
    }

    return ret;
 800a026:	69fb      	ldr	r3, [r7, #28]
}
 800a028:	4618      	mov	r0, r3
 800a02a:	3724      	adds	r7, #36	@ 0x24
 800a02c:	46bd      	mov	sp, r7
 800a02e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a032:	4770      	bx	lr
 800a034:	08033e08 	.word	0x08033e08

0800a038 <CheckForAltNames>:
 *           0 : no match found.
 *          -1 : No matches and wild pattern match failed.
 */
int CheckForAltNames(DecodedCert* dCert, const char* domain, word32 domainLen,
                     int* checkCN, unsigned int flags)
{
 800a038:	b580      	push	{r7, lr}
 800a03a:	b08a      	sub	sp, #40	@ 0x28
 800a03c:	af02      	add	r7, sp, #8
 800a03e:	60f8      	str	r0, [r7, #12]
 800a040:	60b9      	str	r1, [r7, #8]
 800a042:	607a      	str	r2, [r7, #4]
 800a044:	603b      	str	r3, [r7, #0]
    int match = 0;
 800a046:	2300      	movs	r3, #0
 800a048:	61fb      	str	r3, [r7, #28]
    DNS_entry* altName = NULL;
 800a04a:	2300      	movs	r3, #0
 800a04c:	61bb      	str	r3, [r7, #24]
    char *buf;
    word32 len;

    WOLFSSL_MSG("Checking AltNames");

    if (dCert)
 800a04e:	68fb      	ldr	r3, [r7, #12]
 800a050:	2b00      	cmp	r3, #0
 800a052:	d002      	beq.n	800a05a <CheckForAltNames+0x22>
        altName = dCert->altNames;
 800a054:	68fb      	ldr	r3, [r7, #12]
 800a056:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800a058:	61bb      	str	r3, [r7, #24]

    if (checkCN != NULL) {
 800a05a:	683b      	ldr	r3, [r7, #0]
 800a05c:	2b00      	cmp	r3, #0
 800a05e:	d033      	beq.n	800a0c8 <CheckForAltNames+0x90>
        *checkCN = (altName == NULL) ? 1 : 0;
 800a060:	69bb      	ldr	r3, [r7, #24]
 800a062:	2b00      	cmp	r3, #0
 800a064:	bf0c      	ite	eq
 800a066:	2301      	moveq	r3, #1
 800a068:	2300      	movne	r3, #0
 800a06a:	b2db      	uxtb	r3, r3
 800a06c:	461a      	mov	r2, r3
 800a06e:	683b      	ldr	r3, [r7, #0]
 800a070:	601a      	str	r2, [r3, #0]
    }

    while (altName) {
 800a072:	e029      	b.n	800a0c8 <CheckForAltNames+0x90>
            len = (word32)XSTRLEN(buf);
        }
        else
#endif /* WOLFSSL_IP_ALT_NAME */
        {
            buf = altName->name;
 800a074:	69bb      	ldr	r3, [r7, #24]
 800a076:	68db      	ldr	r3, [r3, #12]
 800a078:	617b      	str	r3, [r7, #20]
            len = (word32)altName->len;
 800a07a:	69bb      	ldr	r3, [r7, #24]
 800a07c:	689b      	ldr	r3, [r3, #8]
 800a07e:	613b      	str	r3, [r7, #16]
        }

        if (MatchDomainName(buf, (int)len, domain, domainLen, flags)) {
 800a080:	6939      	ldr	r1, [r7, #16]
 800a082:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800a084:	9300      	str	r3, [sp, #0]
 800a086:	687b      	ldr	r3, [r7, #4]
 800a088:	68ba      	ldr	r2, [r7, #8]
 800a08a:	6978      	ldr	r0, [r7, #20]
 800a08c:	f7ff fef0 	bl	8009e70 <MatchDomainName>
 800a090:	4603      	mov	r3, r0
 800a092:	2b00      	cmp	r3, #0
 800a094:	d008      	beq.n	800a0a8 <CheckForAltNames+0x70>
            match = 1;
 800a096:	2301      	movs	r3, #1
 800a098:	61fb      	str	r3, [r7, #28]
            if (checkCN != NULL) {
 800a09a:	683b      	ldr	r3, [r7, #0]
 800a09c:	2b00      	cmp	r3, #0
 800a09e:	d017      	beq.n	800a0d0 <CheckForAltNames+0x98>
                *checkCN = 0;
 800a0a0:	683b      	ldr	r3, [r7, #0]
 800a0a2:	2200      	movs	r2, #0
 800a0a4:	601a      	str	r2, [r3, #0]
            }
            WOLFSSL_MSG("\tmatch found");
            break;
 800a0a6:	e013      	b.n	800a0d0 <CheckForAltNames+0x98>
        }
        /* No matches and wild pattern match failed. */
        else if (buf && (len >=1) && (buf[0] == '*')) {
 800a0a8:	697b      	ldr	r3, [r7, #20]
 800a0aa:	2b00      	cmp	r3, #0
 800a0ac:	d009      	beq.n	800a0c2 <CheckForAltNames+0x8a>
 800a0ae:	693b      	ldr	r3, [r7, #16]
 800a0b0:	2b00      	cmp	r3, #0
 800a0b2:	d006      	beq.n	800a0c2 <CheckForAltNames+0x8a>
 800a0b4:	697b      	ldr	r3, [r7, #20]
 800a0b6:	781b      	ldrb	r3, [r3, #0]
 800a0b8:	2b2a      	cmp	r3, #42	@ 0x2a
 800a0ba:	d102      	bne.n	800a0c2 <CheckForAltNames+0x8a>
            match = -1;
 800a0bc:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800a0c0:	61fb      	str	r3, [r7, #28]
            WOLFSSL_MSG("\twildcard match failed");
        }

        altName = altName->next;
 800a0c2:	69bb      	ldr	r3, [r7, #24]
 800a0c4:	681b      	ldr	r3, [r3, #0]
 800a0c6:	61bb      	str	r3, [r7, #24]
    while (altName) {
 800a0c8:	69bb      	ldr	r3, [r7, #24]
 800a0ca:	2b00      	cmp	r3, #0
 800a0cc:	d1d2      	bne.n	800a074 <CheckForAltNames+0x3c>
 800a0ce:	e000      	b.n	800a0d2 <CheckForAltNames+0x9a>
            break;
 800a0d0:	bf00      	nop
    }

    return match;
 800a0d2:	69fb      	ldr	r3, [r7, #28]
}
 800a0d4:	4618      	mov	r0, r3
 800a0d6:	3720      	adds	r7, #32
 800a0d8:	46bd      	mov	sp, r7
 800a0da:	bd80      	pop	{r7, pc}

0800a0dc <CheckHostName>:
 * domainNameLen  The length of the domain name.
 * returns DOMAIN_NAME_MISMATCH when no match found and 0 on success.
 */
int CheckHostName(DecodedCert* dCert, const char *domainName,
                  size_t domainNameLen, unsigned int flags)
{
 800a0dc:	b580      	push	{r7, lr}
 800a0de:	b088      	sub	sp, #32
 800a0e0:	af02      	add	r7, sp, #8
 800a0e2:	60f8      	str	r0, [r7, #12]
 800a0e4:	60b9      	str	r1, [r7, #8]
 800a0e6:	607a      	str	r2, [r7, #4]
 800a0e8:	603b      	str	r3, [r7, #0]
    int checkCN;
    int ret = WC_NO_ERR_TRACE(DOMAIN_NAME_MISMATCH);
 800a0ea:	4b18      	ldr	r3, [pc, #96]	@ (800a14c <CheckHostName+0x70>)
 800a0ec:	617b      	str	r3, [r7, #20]

    if (CheckForAltNames(dCert, domainName, (word32)domainNameLen,
 800a0ee:	f107 0210 	add.w	r2, r7, #16
 800a0f2:	683b      	ldr	r3, [r7, #0]
 800a0f4:	9300      	str	r3, [sp, #0]
 800a0f6:	4613      	mov	r3, r2
 800a0f8:	687a      	ldr	r2, [r7, #4]
 800a0fa:	68b9      	ldr	r1, [r7, #8]
 800a0fc:	68f8      	ldr	r0, [r7, #12]
 800a0fe:	f7ff ff9b 	bl	800a038 <CheckForAltNames>
 800a102:	4603      	mov	r3, r0
 800a104:	2b01      	cmp	r3, #1
 800a106:	d002      	beq.n	800a10e <CheckHostName+0x32>
                                            &checkCN, flags) != 1) {
        ret = DOMAIN_NAME_MISMATCH;
 800a108:	4b10      	ldr	r3, [pc, #64]	@ (800a14c <CheckHostName+0x70>)
 800a10a:	617b      	str	r3, [r7, #20]
 800a10c:	e001      	b.n	800a112 <CheckHostName+0x36>
        WOLFSSL_MSG("DomainName match on alt names failed");
    }
    else {
        ret = 0;
 800a10e:	2300      	movs	r3, #0
 800a110:	617b      	str	r3, [r7, #20]
    }

#ifndef WOLFSSL_HOSTNAME_VERIFY_ALT_NAME_ONLY
    if (checkCN == 1) {
 800a112:	693b      	ldr	r3, [r7, #16]
 800a114:	2b01      	cmp	r3, #1
 800a116:	d113      	bne.n	800a140 <CheckHostName+0x64>
        if (MatchDomainName(dCert->subjectCN, dCert->subjectCNLen,
 800a118:	68fb      	ldr	r3, [r7, #12]
 800a11a:	f8d3 0084 	ldr.w	r0, [r3, #132]	@ 0x84
 800a11e:	68fb      	ldr	r3, [r7, #12]
 800a120:	f8d3 1088 	ldr.w	r1, [r3, #136]	@ 0x88
 800a124:	683b      	ldr	r3, [r7, #0]
 800a126:	9300      	str	r3, [sp, #0]
 800a128:	687b      	ldr	r3, [r7, #4]
 800a12a:	68ba      	ldr	r2, [r7, #8]
 800a12c:	f7ff fea0 	bl	8009e70 <MatchDomainName>
 800a130:	4603      	mov	r3, r0
 800a132:	2b01      	cmp	r3, #1
 800a134:	d102      	bne.n	800a13c <CheckHostName+0x60>
                            domainName, (word32)domainNameLen, flags) == 1) {
            ret = 0;
 800a136:	2300      	movs	r3, #0
 800a138:	617b      	str	r3, [r7, #20]
 800a13a:	e001      	b.n	800a140 <CheckHostName+0x64>
        }
        else {
            ret = DOMAIN_NAME_MISMATCH;
 800a13c:	4b03      	ldr	r3, [pc, #12]	@ (800a14c <CheckHostName+0x70>)
 800a13e:	617b      	str	r3, [r7, #20]
            WOLFSSL_MSG("DomainName match on common name failed");
        }
    }
#endif /* !WOLFSSL_HOSTNAME_VERIFY_ALT_NAME_ONLY */

    return ret;
 800a140:	697b      	ldr	r3, [r7, #20]
}
 800a142:	4618      	mov	r0, r3
 800a144:	3718      	adds	r7, #24
 800a146:	46bd      	mov	sp, r7
 800a148:	bd80      	pop	{r7, pc}
 800a14a:	bf00      	nop
 800a14c:	fffffebe 	.word	0xfffffebe

0800a150 <CheckIPAddr>:

int CheckIPAddr(DecodedCert* dCert, const char* ipasc)
{
 800a150:	b580      	push	{r7, lr}
 800a152:	b082      	sub	sp, #8
 800a154:	af00      	add	r7, sp, #0
 800a156:	6078      	str	r0, [r7, #4]
 800a158:	6039      	str	r1, [r7, #0]
    WOLFSSL_MSG("Checking IPAddr");

    return CheckHostName(dCert, ipasc, (size_t)XSTRLEN(ipasc), 0);
 800a15a:	6838      	ldr	r0, [r7, #0]
 800a15c:	f7f6 f842 	bl	80001e4 <strlen>
 800a160:	4602      	mov	r2, r0
 800a162:	2300      	movs	r3, #0
 800a164:	6839      	ldr	r1, [r7, #0]
 800a166:	6878      	ldr	r0, [r7, #4]
 800a168:	f7ff ffb8 	bl	800a0dc <CheckHostName>
 800a16c:	4603      	mov	r3, r0
}
 800a16e:	4618      	mov	r0, r3
 800a170:	3708      	adds	r7, #8
 800a172:	46bd      	mov	sp, r7
 800a174:	bd80      	pop	{r7, pc}

0800a176 <CopyAltNames>:

#if defined(KEEP_PEER_CERT) || defined(SESSION_CERTS) || \
    defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL) || \
    defined(WOLFSSL_ACERT)
    static int CopyAltNames(DNS_entry** to, DNS_entry* from, int type, void* heap)
{
 800a176:	b580      	push	{r7, lr}
 800a178:	b088      	sub	sp, #32
 800a17a:	af00      	add	r7, sp, #0
 800a17c:	60f8      	str	r0, [r7, #12]
 800a17e:	60b9      	str	r1, [r7, #8]
 800a180:	607a      	str	r2, [r7, #4]
 800a182:	603b      	str	r3, [r7, #0]
    /* Copy from to the beginning of to */
    DNS_entry** prev_next = to;
 800a184:	68fb      	ldr	r3, [r7, #12]
 800a186:	61fb      	str	r3, [r7, #28]
    DNS_entry* next;

    if (to == NULL) {
 800a188:	68fb      	ldr	r3, [r7, #12]
 800a18a:	2b00      	cmp	r3, #0
 800a18c:	d102      	bne.n	800a194 <CopyAltNames+0x1e>
        return BAD_FUNC_ARG;
 800a18e:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800a192:	e028      	b.n	800a1e6 <CopyAltNames+0x70>
    }

    next = *to;
 800a194:	68fb      	ldr	r3, [r7, #12]
 800a196:	681b      	ldr	r3, [r3, #0]
 800a198:	61bb      	str	r3, [r7, #24]

    for (; from != NULL; from = from->next) {
 800a19a:	e020      	b.n	800a1de <CopyAltNames+0x68>
        DNS_entry* dnsEntry;

        if (type != -1 && from->type != type)
 800a19c:	687b      	ldr	r3, [r7, #4]
 800a19e:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 800a1a2:	d004      	beq.n	800a1ae <CopyAltNames+0x38>
 800a1a4:	68bb      	ldr	r3, [r7, #8]
 800a1a6:	685b      	ldr	r3, [r3, #4]
 800a1a8:	687a      	ldr	r2, [r7, #4]
 800a1aa:	429a      	cmp	r2, r3
 800a1ac:	d113      	bne.n	800a1d6 <CopyAltNames+0x60>
            continue;

        dnsEntry = AltNameDup(from, heap);
 800a1ae:	6839      	ldr	r1, [r7, #0]
 800a1b0:	68b8      	ldr	r0, [r7, #8]
 800a1b2:	f00b f81b 	bl	80151ec <AltNameDup>
 800a1b6:	6178      	str	r0, [r7, #20]
        if (dnsEntry == NULL) {
 800a1b8:	697b      	ldr	r3, [r7, #20]
 800a1ba:	2b00      	cmp	r3, #0
 800a1bc:	d102      	bne.n	800a1c4 <CopyAltNames+0x4e>
            WOLFSSL_MSG("\tOut of Memory");
            return MEMORY_E;
 800a1be:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a1c2:	e010      	b.n	800a1e6 <CopyAltNames+0x70>
        }

        dnsEntry->next = next;
 800a1c4:	697b      	ldr	r3, [r7, #20]
 800a1c6:	69ba      	ldr	r2, [r7, #24]
 800a1c8:	601a      	str	r2, [r3, #0]
        *prev_next = dnsEntry;
 800a1ca:	69fb      	ldr	r3, [r7, #28]
 800a1cc:	697a      	ldr	r2, [r7, #20]
 800a1ce:	601a      	str	r2, [r3, #0]
        prev_next = &dnsEntry->next;
 800a1d0:	697b      	ldr	r3, [r7, #20]
 800a1d2:	61fb      	str	r3, [r7, #28]
 800a1d4:	e000      	b.n	800a1d8 <CopyAltNames+0x62>
            continue;
 800a1d6:	bf00      	nop
    for (; from != NULL; from = from->next) {
 800a1d8:	68bb      	ldr	r3, [r7, #8]
 800a1da:	681b      	ldr	r3, [r3, #0]
 800a1dc:	60bb      	str	r3, [r7, #8]
 800a1de:	68bb      	ldr	r3, [r7, #8]
 800a1e0:	2b00      	cmp	r3, #0
 800a1e2:	d1db      	bne.n	800a19c <CopyAltNames+0x26>
    }

    return 0;
 800a1e4:	2300      	movs	r3, #0
}
 800a1e6:	4618      	mov	r0, r3
 800a1e8:	3720      	adds	r7, #32
 800a1ea:	46bd      	mov	sp, r7
 800a1ec:	bd80      	pop	{r7, pc}

0800a1ee <CopyDecodedName>:


#if defined(KEEP_PEER_CERT) || defined(SESSION_CERTS) || \
    defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
void CopyDecodedName(WOLFSSL_X509_NAME* name, DecodedCert* dCert, int nameType)
{
 800a1ee:	b580      	push	{r7, lr}
 800a1f0:	b086      	sub	sp, #24
 800a1f2:	af00      	add	r7, sp, #0
 800a1f4:	60f8      	str	r0, [r7, #12]
 800a1f6:	60b9      	str	r1, [r7, #8]
 800a1f8:	607a      	str	r2, [r7, #4]
    if (name->dynamicName) {
 800a1fa:	68fb      	ldr	r3, [r7, #12]
 800a1fc:	685b      	ldr	r3, [r3, #4]
 800a1fe:	2b00      	cmp	r3, #0
 800a200:	d010      	beq.n	800a224 <CopyDecodedName+0x36>
        XFREE(name->name, name->heap, DYNAMIC_TYPE_X509);
 800a202:	68fb      	ldr	r3, [r7, #12]
 800a204:	681b      	ldr	r3, [r3, #0]
 800a206:	617b      	str	r3, [r7, #20]
 800a208:	697b      	ldr	r3, [r7, #20]
 800a20a:	2b00      	cmp	r3, #0
 800a20c:	d002      	beq.n	800a214 <CopyDecodedName+0x26>
 800a20e:	6978      	ldr	r0, [r7, #20]
 800a210:	f014 fc56 	bl	801eac0 <wolfSSL_Free>
        name->name = name->staticName;
 800a214:	68fb      	ldr	r3, [r7, #12]
 800a216:	f103 020c 	add.w	r2, r3, #12
 800a21a:	68fb      	ldr	r3, [r7, #12]
 800a21c:	601a      	str	r2, [r3, #0]
        name->dynamicName = 0;
 800a21e:	68fb      	ldr	r3, [r7, #12]
 800a220:	2200      	movs	r2, #0
 800a222:	605a      	str	r2, [r3, #4]
    }

    if (nameType == ASN_SUBJECT) {
 800a224:	687b      	ldr	r3, [r7, #4]
 800a226:	2b01      	cmp	r3, #1
 800a228:	d119      	bne.n	800a25e <CopyDecodedName+0x70>
        XSTRNCPY(name->name, dCert->subject, ASN_NAME_MAX);
 800a22a:	68fb      	ldr	r3, [r7, #12]
 800a22c:	6818      	ldr	r0, [r3, #0]
 800a22e:	68bb      	ldr	r3, [r7, #8]
 800a230:	f203 13f5 	addw	r3, r3, #501	@ 0x1f5
 800a234:	f44f 72b4 	mov.w	r2, #360	@ 0x168
 800a238:	4619      	mov	r1, r3
 800a23a:	f01e f95f 	bl	80284fc <strncpy>
        name->name[ASN_NAME_MAX - 1] = '\0';
 800a23e:	68fb      	ldr	r3, [r7, #12]
 800a240:	681b      	ldr	r3, [r3, #0]
 800a242:	f203 1367 	addw	r3, r3, #359	@ 0x167
 800a246:	2200      	movs	r2, #0
 800a248:	701a      	strb	r2, [r3, #0]
        name->sz = (int)XSTRLEN(name->name) + 1;
 800a24a:	68fb      	ldr	r3, [r7, #12]
 800a24c:	681b      	ldr	r3, [r3, #0]
 800a24e:	4618      	mov	r0, r3
 800a250:	f7f5 ffc8 	bl	80001e4 <strlen>
 800a254:	4603      	mov	r3, r0
 800a256:	1c5a      	adds	r2, r3, #1
 800a258:	68fb      	ldr	r3, [r7, #12]
 800a25a:	609a      	str	r2, [r3, #8]
        if (name->rawLen > 0) {
            XMEMCPY(name->raw, dCert->issuerRaw, name->rawLen);
        }
#endif
    }
}
 800a25c:	e017      	b.n	800a28e <CopyDecodedName+0xa0>
        XSTRNCPY(name->name, dCert->issuer, ASN_NAME_MAX);
 800a25e:	68fb      	ldr	r3, [r7, #12]
 800a260:	6818      	ldr	r0, [r3, #0]
 800a262:	68bb      	ldr	r3, [r7, #8]
 800a264:	338d      	adds	r3, #141	@ 0x8d
 800a266:	f44f 72b4 	mov.w	r2, #360	@ 0x168
 800a26a:	4619      	mov	r1, r3
 800a26c:	f01e f946 	bl	80284fc <strncpy>
        name->name[ASN_NAME_MAX - 1] = '\0';
 800a270:	68fb      	ldr	r3, [r7, #12]
 800a272:	681b      	ldr	r3, [r3, #0]
 800a274:	f203 1367 	addw	r3, r3, #359	@ 0x167
 800a278:	2200      	movs	r2, #0
 800a27a:	701a      	strb	r2, [r3, #0]
        name->sz = (int)XSTRLEN(name->name) + 1;
 800a27c:	68fb      	ldr	r3, [r7, #12]
 800a27e:	681b      	ldr	r3, [r3, #0]
 800a280:	4618      	mov	r0, r3
 800a282:	f7f5 ffaf 	bl	80001e4 <strlen>
 800a286:	4603      	mov	r3, r0
 800a288:	1c5a      	adds	r2, r3, #1
 800a28a:	68fb      	ldr	r3, [r7, #12]
 800a28c:	609a      	str	r2, [r3, #8]
}
 800a28e:	bf00      	nop
 800a290:	3718      	adds	r7, #24
 800a292:	46bd      	mov	sp, r7
 800a294:	bd80      	pop	{r7, pc}

0800a296 <CopyDecodedToX509>:
}
#endif /* WOLFSSL_CERT_REQ */

/* Copy parts X509 needs from Decoded cert, 0 on success */
int CopyDecodedToX509(WOLFSSL_X509* x509, DecodedCert* dCert)
{
 800a296:	b580      	push	{r7, lr}
 800a298:	b084      	sub	sp, #16
 800a29a:	af00      	add	r7, sp, #0
 800a29c:	6078      	str	r0, [r7, #4]
 800a29e:	6039      	str	r1, [r7, #0]
    int ret = 0;
 800a2a0:	2300      	movs	r3, #0
 800a2a2:	60fb      	str	r3, [r7, #12]
    int minSz;

    if (x509 == NULL || dCert == NULL ||
 800a2a4:	687b      	ldr	r3, [r7, #4]
 800a2a6:	2b00      	cmp	r3, #0
 800a2a8:	d007      	beq.n	800a2ba <CopyDecodedToX509+0x24>
 800a2aa:	683b      	ldr	r3, [r7, #0]
 800a2ac:	2b00      	cmp	r3, #0
 800a2ae:	d004      	beq.n	800a2ba <CopyDecodedToX509+0x24>
        dCert->subjectCNLen < 0)
 800a2b0:	683b      	ldr	r3, [r7, #0]
 800a2b2:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
    if (x509 == NULL || dCert == NULL ||
 800a2b6:	2b00      	cmp	r3, #0
 800a2b8:	da03      	bge.n	800a2c2 <CopyDecodedToX509+0x2c>
        return BAD_FUNC_ARG;
 800a2ba:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800a2be:	f000 bc03 	b.w	800aac8 <CopyDecodedToX509+0x832>

    if (x509->issuer.name == NULL || x509->subject.name == NULL) {
 800a2c2:	687b      	ldr	r3, [r7, #4]
 800a2c4:	f8d3 327c 	ldr.w	r3, [r3, #636]	@ 0x27c
 800a2c8:	2b00      	cmp	r3, #0
 800a2ca:	d004      	beq.n	800a2d6 <CopyDecodedToX509+0x40>
 800a2cc:	687b      	ldr	r3, [r7, #4]
 800a2ce:	f8d3 3788 	ldr.w	r3, [r3, #1928]	@ 0x788
 800a2d2:	2b00      	cmp	r3, #0
 800a2d4:	d102      	bne.n	800a2dc <CopyDecodedToX509+0x46>
        WOLFSSL_MSG("Either init was not called on X509 or programming error");
        WOLFSSL_ERROR_VERBOSE(BAD_FUNC_ARG);
        return BAD_FUNC_ARG;
 800a2d6:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800a2da:	e3f5      	b.n	800aac8 <CopyDecodedToX509+0x832>
    }

    x509->version = dCert->version + 1;
 800a2dc:	683b      	ldr	r3, [r7, #0]
 800a2de:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800a2e0:	1c5a      	adds	r2, r3, #1
 800a2e2:	687b      	ldr	r3, [r7, #4]
 800a2e4:	601a      	str	r2, [r3, #0]

    CopyDecodedName(&x509->issuer, dCert, ASN_ISSUER);
 800a2e6:	687b      	ldr	r3, [r7, #4]
 800a2e8:	f503 731f 	add.w	r3, r3, #636	@ 0x27c
 800a2ec:	2200      	movs	r2, #0
 800a2ee:	6839      	ldr	r1, [r7, #0]
 800a2f0:	4618      	mov	r0, r3
 800a2f2:	f7ff ff7c 	bl	800a1ee <CopyDecodedName>
#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
    if (dCert->issuerName != NULL) {
 800a2f6:	683b      	ldr	r3, [r7, #0]
 800a2f8:	f8d3 3464 	ldr.w	r3, [r3, #1124]	@ 0x464
 800a2fc:	2b00      	cmp	r3, #0
 800a2fe:	d00a      	beq.n	800a316 <CopyDecodedToX509+0x80>
        wolfSSL_X509_set_issuer_name(x509,
                (WOLFSSL_X509_NAME*)dCert->issuerName);
 800a300:	683b      	ldr	r3, [r7, #0]
 800a302:	f8d3 3464 	ldr.w	r3, [r3, #1124]	@ 0x464
        wolfSSL_X509_set_issuer_name(x509,
 800a306:	4619      	mov	r1, r3
 800a308:	6878      	ldr	r0, [r7, #4]
 800a30a:	f004 fce6 	bl	800ecda <wolfSSL_X509_set_issuer_name>
        x509->issuer.x509 = x509;
 800a30e:	687b      	ldr	r3, [r7, #4]
 800a310:	687a      	ldr	r2, [r7, #4]
 800a312:	f8c3 2610 	str.w	r2, [r3, #1552]	@ 0x610
    }
#endif /* OPENSSL_EXTRA || OPENSSL_EXTRA_X509_SMALL */
    CopyDecodedName(&x509->subject, dCert, ASN_SUBJECT);
 800a316:	687b      	ldr	r3, [r7, #4]
 800a318:	f503 63f1 	add.w	r3, r3, #1928	@ 0x788
 800a31c:	2201      	movs	r2, #1
 800a31e:	6839      	ldr	r1, [r7, #0]
 800a320:	4618      	mov	r0, r3
 800a322:	f7ff ff64 	bl	800a1ee <CopyDecodedName>
#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
    if (dCert->subjectName != NULL) {
 800a326:	683b      	ldr	r3, [r7, #0]
 800a328:	f8d3 3468 	ldr.w	r3, [r3, #1128]	@ 0x468
 800a32c:	2b00      	cmp	r3, #0
 800a32e:	d00a      	beq.n	800a346 <CopyDecodedToX509+0xb0>
        wolfSSL_X509_set_subject_name(x509,
                (WOLFSSL_X509_NAME*)dCert->subjectName);
 800a330:	683b      	ldr	r3, [r7, #0]
 800a332:	f8d3 3468 	ldr.w	r3, [r3, #1128]	@ 0x468
        wolfSSL_X509_set_subject_name(x509,
 800a336:	4619      	mov	r1, r3
 800a338:	6878      	ldr	r0, [r7, #4]
 800a33a:	f004 fc96 	bl	800ec6a <wolfSSL_X509_set_subject_name>
        x509->subject.x509 = x509;
 800a33e:	687b      	ldr	r3, [r7, #4]
 800a340:	687a      	ldr	r2, [r7, #4]
 800a342:	f8c3 2b1c 	str.w	r2, [r3, #2844]	@ 0xb1c
    }
#endif /* OPENSSL_EXTRA || OPENSSL_EXTRA_X509_SMALL */

    XMEMCPY(x509->serial, dCert->serial, EXTERNAL_SERIAL_SIZE);
 800a346:	687b      	ldr	r3, [r7, #4]
 800a348:	f103 00f4 	add.w	r0, r3, #244	@ 0xf4
 800a34c:	683b      	ldr	r3, [r7, #0]
 800a34e:	f503 735d 	add.w	r3, r3, #884	@ 0x374
 800a352:	2220      	movs	r2, #32
 800a354:	4619      	mov	r1, r3
 800a356:	f01e f921 	bl	802859c <memcpy>
    x509->serialSz = dCert->serialSz;
 800a35a:	683b      	ldr	r3, [r7, #0]
 800a35c:	f8d3 2394 	ldr.w	r2, [r3, #916]	@ 0x394
 800a360:	687b      	ldr	r3, [r7, #4]
 800a362:	605a      	str	r2, [r3, #4]
    if (dCert->subjectCN && dCert->subjectCNLen < ASN_NAME_MAX) {
 800a364:	683b      	ldr	r3, [r7, #0]
 800a366:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800a36a:	2b00      	cmp	r3, #0
 800a36c:	d01a      	beq.n	800a3a4 <CopyDecodedToX509+0x10e>
 800a36e:	683b      	ldr	r3, [r7, #0]
 800a370:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800a374:	f5b3 7fb4 	cmp.w	r3, #360	@ 0x168
 800a378:	da14      	bge.n	800a3a4 <CopyDecodedToX509+0x10e>
        XMEMCPY(x509->subjectCN, dCert->subjectCN, dCert->subjectCNLen);
 800a37a:	687b      	ldr	r3, [r7, #4]
 800a37c:	f503 708a 	add.w	r0, r3, #276	@ 0x114
 800a380:	683b      	ldr	r3, [r7, #0]
 800a382:	f8d3 1084 	ldr.w	r1, [r3, #132]	@ 0x84
 800a386:	683b      	ldr	r3, [r7, #0]
 800a388:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800a38c:	461a      	mov	r2, r3
 800a38e:	f01e f905 	bl	802859c <memcpy>
        x509->subjectCN[dCert->subjectCNLen] = '\0';
 800a392:	683b      	ldr	r3, [r7, #0]
 800a394:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800a398:	687a      	ldr	r2, [r7, #4]
 800a39a:	4413      	add	r3, r2
 800a39c:	2200      	movs	r2, #0
 800a39e:	f883 2114 	strb.w	r2, [r3, #276]	@ 0x114
 800a3a2:	e003      	b.n	800a3ac <CopyDecodedToX509+0x116>
    }
    else
        x509->subjectCN[0] = '\0';
 800a3a4:	687b      	ldr	r3, [r7, #4]
 800a3a6:	2200      	movs	r2, #0
 800a3a8:	f883 2114 	strb.w	r2, [r3, #276]	@ 0x114
    }
    else
        x509->hwSerialNumSz = 0;
#endif /* WOLFSSL_SEP */

    if (dCert->beforeDateLen > 0) {
 800a3ac:	683b      	ldr	r3, [r7, #0]
 800a3ae:	f8d3 3448 	ldr.w	r3, [r3, #1096]	@ 0x448
 800a3b2:	2b00      	cmp	r3, #0
 800a3b4:	dd20      	ble.n	800a3f8 <CopyDecodedToX509+0x162>
        minSz = (int)min(dCert->beforeDate[1], MAX_DATE_SZ);
 800a3b6:	683b      	ldr	r3, [r7, #0]
 800a3b8:	f8d3 3444 	ldr.w	r3, [r3, #1092]	@ 0x444
 800a3bc:	3301      	adds	r3, #1
 800a3be:	781b      	ldrb	r3, [r3, #0]
 800a3c0:	2120      	movs	r1, #32
 800a3c2:	4618      	mov	r0, r3
 800a3c4:	f7fe fa92 	bl	80088ec <min>
 800a3c8:	4603      	mov	r3, r0
 800a3ca:	60bb      	str	r3, [r7, #8]
        x509->notBefore.type = dCert->beforeDate[0];
 800a3cc:	683b      	ldr	r3, [r7, #0]
 800a3ce:	f8d3 3444 	ldr.w	r3, [r3, #1092]	@ 0x444
 800a3d2:	781b      	ldrb	r3, [r3, #0]
 800a3d4:	461a      	mov	r2, r3
 800a3d6:	687b      	ldr	r3, [r7, #4]
 800a3d8:	63da      	str	r2, [r3, #60]	@ 0x3c
        x509->notBefore.length = minSz;
 800a3da:	687b      	ldr	r3, [r7, #4]
 800a3dc:	68ba      	ldr	r2, [r7, #8]
 800a3de:	639a      	str	r2, [r3, #56]	@ 0x38
        XMEMCPY(x509->notBefore.data, &dCert->beforeDate[2], minSz);
 800a3e0:	687b      	ldr	r3, [r7, #4]
 800a3e2:	f103 0018 	add.w	r0, r3, #24
 800a3e6:	683b      	ldr	r3, [r7, #0]
 800a3e8:	f8d3 3444 	ldr.w	r3, [r3, #1092]	@ 0x444
 800a3ec:	3302      	adds	r3, #2
 800a3ee:	68ba      	ldr	r2, [r7, #8]
 800a3f0:	4619      	mov	r1, r3
 800a3f2:	f01e f8d3 	bl	802859c <memcpy>
 800a3f6:	e002      	b.n	800a3fe <CopyDecodedToX509+0x168>
    }
    else
        x509->notBefore.length = 0;
 800a3f8:	687b      	ldr	r3, [r7, #4]
 800a3fa:	2200      	movs	r2, #0
 800a3fc:	639a      	str	r2, [r3, #56]	@ 0x38
    if (dCert->afterDateLen > 0) {
 800a3fe:	683b      	ldr	r3, [r7, #0]
 800a400:	f8d3 3450 	ldr.w	r3, [r3, #1104]	@ 0x450
 800a404:	2b00      	cmp	r3, #0
 800a406:	dd20      	ble.n	800a44a <CopyDecodedToX509+0x1b4>
        minSz = (int)min(dCert->afterDate[1], MAX_DATE_SZ);
 800a408:	683b      	ldr	r3, [r7, #0]
 800a40a:	f8d3 344c 	ldr.w	r3, [r3, #1100]	@ 0x44c
 800a40e:	3301      	adds	r3, #1
 800a410:	781b      	ldrb	r3, [r3, #0]
 800a412:	2120      	movs	r1, #32
 800a414:	4618      	mov	r0, r3
 800a416:	f7fe fa69 	bl	80088ec <min>
 800a41a:	4603      	mov	r3, r0
 800a41c:	60bb      	str	r3, [r7, #8]
        x509->notAfter.type = dCert->afterDate[0];
 800a41e:	683b      	ldr	r3, [r7, #0]
 800a420:	f8d3 344c 	ldr.w	r3, [r3, #1100]	@ 0x44c
 800a424:	781b      	ldrb	r3, [r3, #0]
 800a426:	461a      	mov	r2, r3
 800a428:	687b      	ldr	r3, [r7, #4]
 800a42a:	665a      	str	r2, [r3, #100]	@ 0x64
        x509->notAfter.length = minSz;
 800a42c:	687b      	ldr	r3, [r7, #4]
 800a42e:	68ba      	ldr	r2, [r7, #8]
 800a430:	661a      	str	r2, [r3, #96]	@ 0x60
        XMEMCPY(x509->notAfter.data, &dCert->afterDate[2], minSz);
 800a432:	687b      	ldr	r3, [r7, #4]
 800a434:	f103 0040 	add.w	r0, r3, #64	@ 0x40
 800a438:	683b      	ldr	r3, [r7, #0]
 800a43a:	f8d3 344c 	ldr.w	r3, [r3, #1100]	@ 0x44c
 800a43e:	3302      	adds	r3, #2
 800a440:	68ba      	ldr	r2, [r7, #8]
 800a442:	4619      	mov	r1, r3
 800a444:	f01e f8aa 	bl	802859c <memcpy>
 800a448:	e002      	b.n	800a450 <CopyDecodedToX509+0x1ba>
    }
    else
        x509->notAfter.length = 0;
 800a44a:	687b      	ldr	r3, [r7, #4]
 800a44c:	2200      	movs	r2, #0
 800a44e:	661a      	str	r2, [r3, #96]	@ 0x60

    if (dCert->publicKey != NULL && dCert->pubKeySize != 0) {
 800a450:	683b      	ldr	r3, [r7, #0]
 800a452:	681b      	ldr	r3, [r3, #0]
 800a454:	2b00      	cmp	r3, #0
 800a456:	d026      	beq.n	800a4a6 <CopyDecodedToX509+0x210>
 800a458:	683b      	ldr	r3, [r7, #0]
 800a45a:	685b      	ldr	r3, [r3, #4]
 800a45c:	2b00      	cmp	r3, #0
 800a45e:	d022      	beq.n	800a4a6 <CopyDecodedToX509+0x210>
        x509->pubKey.buffer = (byte*)XMALLOC(
 800a460:	683b      	ldr	r3, [r7, #0]
 800a462:	685b      	ldr	r3, [r3, #4]
 800a464:	4618      	mov	r0, r3
 800a466:	f014 fb0f 	bl	801ea88 <wolfSSL_Malloc>
 800a46a:	4602      	mov	r2, r0
 800a46c:	687b      	ldr	r3, [r7, #4]
 800a46e:	679a      	str	r2, [r3, #120]	@ 0x78
                        dCert->pubKeySize, x509->heap, DYNAMIC_TYPE_PUBLIC_KEY);
        if (x509->pubKey.buffer != NULL) {
 800a470:	687b      	ldr	r3, [r7, #4]
 800a472:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 800a474:	2b00      	cmp	r3, #0
 800a476:	d013      	beq.n	800a4a0 <CopyDecodedToX509+0x20a>
            x509->pubKeyOID = (int)dCert->keyOID;
 800a478:	683b      	ldr	r3, [r7, #0]
 800a47a:	69db      	ldr	r3, [r3, #28]
 800a47c:	461a      	mov	r2, r3
 800a47e:	687b      	ldr	r3, [r7, #4]
 800a480:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
            x509->pubKey.length = dCert->pubKeySize;
 800a484:	683b      	ldr	r3, [r7, #0]
 800a486:	685a      	ldr	r2, [r3, #4]
 800a488:	687b      	ldr	r3, [r7, #4]
 800a48a:	67da      	str	r2, [r3, #124]	@ 0x7c
            XMEMCPY(x509->pubKey.buffer, dCert->publicKey, dCert->pubKeySize);
 800a48c:	687b      	ldr	r3, [r7, #4]
 800a48e:	6f98      	ldr	r0, [r3, #120]	@ 0x78
 800a490:	683b      	ldr	r3, [r7, #0]
 800a492:	6819      	ldr	r1, [r3, #0]
 800a494:	683b      	ldr	r3, [r7, #0]
 800a496:	685b      	ldr	r3, [r3, #4]
 800a498:	461a      	mov	r2, r3
 800a49a:	f01e f87f 	bl	802859c <memcpy>
 800a49e:	e002      	b.n	800a4a6 <CopyDecodedToX509+0x210>
        }
        else
            ret = MEMORY_E;
 800a4a0:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a4a4:	60fb      	str	r3, [r7, #12]
            }
        }
#endif
    }

    if (dCert->signature != NULL && dCert->sigLength != 0 &&
 800a4a6:	683b      	ldr	r3, [r7, #0]
 800a4a8:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 800a4ac:	2b00      	cmp	r3, #0
 800a4ae:	d02b      	beq.n	800a508 <CopyDecodedToX509+0x272>
 800a4b0:	683b      	ldr	r3, [r7, #0]
 800a4b2:	695b      	ldr	r3, [r3, #20]
 800a4b4:	2b00      	cmp	r3, #0
 800a4b6:	d027      	beq.n	800a508 <CopyDecodedToX509+0x272>
            dCert->sigLength <= MAX_ENCODED_SIG_SZ) {
 800a4b8:	683b      	ldr	r3, [r7, #0]
 800a4ba:	695b      	ldr	r3, [r3, #20]
    if (dCert->signature != NULL && dCert->sigLength != 0 &&
 800a4bc:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800a4c0:	d822      	bhi.n	800a508 <CopyDecodedToX509+0x272>
        x509->sig.buffer = (byte*)XMALLOC(
 800a4c2:	683b      	ldr	r3, [r7, #0]
 800a4c4:	695b      	ldr	r3, [r3, #20]
 800a4c6:	4618      	mov	r0, r3
 800a4c8:	f014 fade 	bl	801ea88 <wolfSSL_Malloc>
 800a4cc:	4602      	mov	r2, r0
 800a4ce:	687b      	ldr	r3, [r7, #4]
 800a4d0:	669a      	str	r2, [r3, #104]	@ 0x68
                          dCert->sigLength, x509->heap, DYNAMIC_TYPE_SIGNATURE);
        if (x509->sig.buffer == NULL) {
 800a4d2:	687b      	ldr	r3, [r7, #4]
 800a4d4:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 800a4d6:	2b00      	cmp	r3, #0
 800a4d8:	d103      	bne.n	800a4e2 <CopyDecodedToX509+0x24c>
            ret = MEMORY_E;
 800a4da:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a4de:	60fb      	str	r3, [r7, #12]
 800a4e0:	e012      	b.n	800a508 <CopyDecodedToX509+0x272>
        }
        else {
            XMEMCPY(x509->sig.buffer, dCert->signature, dCert->sigLength);
 800a4e2:	687b      	ldr	r3, [r7, #4]
 800a4e4:	6e98      	ldr	r0, [r3, #104]	@ 0x68
 800a4e6:	683b      	ldr	r3, [r7, #0]
 800a4e8:	f8d3 1080 	ldr.w	r1, [r3, #128]	@ 0x80
 800a4ec:	683b      	ldr	r3, [r7, #0]
 800a4ee:	695b      	ldr	r3, [r3, #20]
 800a4f0:	461a      	mov	r2, r3
 800a4f2:	f01e f853 	bl	802859c <memcpy>
            x509->sig.length = dCert->sigLength;
 800a4f6:	683b      	ldr	r3, [r7, #0]
 800a4f8:	695a      	ldr	r2, [r3, #20]
 800a4fa:	687b      	ldr	r3, [r7, #4]
 800a4fc:	66da      	str	r2, [r3, #108]	@ 0x6c
            x509->sigOID = (int)dCert->signatureOID;
 800a4fe:	683b      	ldr	r3, [r7, #0]
 800a500:	699b      	ldr	r3, [r3, #24]
 800a502:	461a      	mov	r2, r3
 800a504:	687b      	ldr	r3, [r7, #4]
 800a506:	671a      	str	r2, [r3, #112]	@ 0x70
#endif
    }

    /* if der contains original source buffer then store for potential
     * retrieval */
    if (dCert->source != NULL && dCert->maxIdx > 0) {
 800a508:	683b      	ldr	r3, [r7, #0]
 800a50a:	f8d3 3364 	ldr.w	r3, [r3, #868]	@ 0x364
 800a50e:	2b00      	cmp	r3, #0
 800a510:	d024      	beq.n	800a55c <CopyDecodedToX509+0x2c6>
 800a512:	683b      	ldr	r3, [r7, #0]
 800a514:	f8d3 336c 	ldr.w	r3, [r3, #876]	@ 0x36c
 800a518:	2b00      	cmp	r3, #0
 800a51a:	d01f      	beq.n	800a55c <CopyDecodedToX509+0x2c6>
        if (AllocDer(&x509->derCert, dCert->maxIdx, CERT_TYPE, x509->heap)
 800a51c:	687b      	ldr	r3, [r7, #4]
 800a51e:	f103 008c 	add.w	r0, r3, #140	@ 0x8c
 800a522:	683b      	ldr	r3, [r7, #0]
 800a524:	f8d3 136c 	ldr.w	r1, [r3, #876]	@ 0x36c
 800a528:	687b      	ldr	r3, [r7, #4]
 800a52a:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 800a52e:	2200      	movs	r2, #0
 800a530:	f00e fc4e 	bl	8018dd0 <AllocDer>
 800a534:	4603      	mov	r3, r0
 800a536:	2b00      	cmp	r3, #0
 800a538:	d10d      	bne.n	800a556 <CopyDecodedToX509+0x2c0>
                                                                         == 0) {
            XMEMCPY(x509->derCert->buffer, dCert->source, dCert->maxIdx);
 800a53a:	687b      	ldr	r3, [r7, #4]
 800a53c:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800a540:	6818      	ldr	r0, [r3, #0]
 800a542:	683b      	ldr	r3, [r7, #0]
 800a544:	f8d3 1364 	ldr.w	r1, [r3, #868]	@ 0x364
 800a548:	683b      	ldr	r3, [r7, #0]
 800a54a:	f8d3 336c 	ldr.w	r3, [r3, #876]	@ 0x36c
 800a54e:	461a      	mov	r2, r3
 800a550:	f01e f824 	bl	802859c <memcpy>
 800a554:	e002      	b.n	800a55c <CopyDecodedToX509+0x2c6>
        }
        else {
            ret = MEMORY_E;
 800a556:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a55a:	60fb      	str	r3, [r7, #12]
        }
    }

    /* add alt names from dCert to X509 */
    if (CopyAltNames(&x509->altNames, dCert->altNames, -1, x509->heap) != 0) {
 800a55c:	687b      	ldr	r3, [r7, #4]
 800a55e:	f103 0074 	add.w	r0, r3, #116	@ 0x74
 800a562:	683b      	ldr	r3, [r7, #0]
 800a564:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 800a566:	687b      	ldr	r3, [r7, #4]
 800a568:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 800a56c:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 800a570:	f7ff fe01 	bl	800a176 <CopyAltNames>
 800a574:	4603      	mov	r3, r0
 800a576:	2b00      	cmp	r3, #0
 800a578:	d002      	beq.n	800a580 <CopyDecodedToX509+0x2ea>
        return MEMORY_E;
 800a57a:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a57e:	e2a3      	b.n	800aac8 <CopyDecodedToX509+0x832>
    }
#if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) && \
    !defined(IGNORE_NAME_CONSTRAINTS)
    /* add copies of email names from dCert to X509 */
    if (CopyAltNames(&x509->altNames, dCert->altEmailNames,
 800a580:	687b      	ldr	r3, [r7, #4]
 800a582:	f103 0074 	add.w	r0, r3, #116	@ 0x74
 800a586:	683b      	ldr	r3, [r7, #0]
 800a588:	6b19      	ldr	r1, [r3, #48]	@ 0x30
 800a58a:	687b      	ldr	r3, [r7, #4]
 800a58c:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 800a590:	2201      	movs	r2, #1
 800a592:	f7ff fdf0 	bl	800a176 <CopyAltNames>
 800a596:	4603      	mov	r3, r0
 800a598:	2b00      	cmp	r3, #0
 800a59a:	d002      	beq.n	800a5a2 <CopyDecodedToX509+0x30c>
                ASN_RFC822_TYPE, x509->heap) != 0) {
        return MEMORY_E;
 800a59c:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a5a0:	e292      	b.n	800aac8 <CopyDecodedToX509+0x832>
    }
#endif /* OPENSSL_EXTRA || OPENSSL_EXTRA_X509_SMALL */
#if defined(OPENSSL_EXTRA) && !defined(IGNORE_NAME_CONSTRAINTS)
    /* add copies of alternate directory names from dCert to X509 */
    if (CopyAltNames(&x509->altNames, dCert->altDirNames,
 800a5a2:	687b      	ldr	r3, [r7, #4]
 800a5a4:	f103 0074 	add.w	r0, r3, #116	@ 0x74
 800a5a8:	683b      	ldr	r3, [r7, #0]
 800a5aa:	6b59      	ldr	r1, [r3, #52]	@ 0x34
 800a5ac:	687b      	ldr	r3, [r7, #4]
 800a5ae:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 800a5b2:	2204      	movs	r2, #4
 800a5b4:	f7ff fddf 	bl	800a176 <CopyAltNames>
 800a5b8:	4603      	mov	r3, r0
 800a5ba:	2b00      	cmp	r3, #0
 800a5bc:	d002      	beq.n	800a5c4 <CopyDecodedToX509+0x32e>
                ASN_DIR_TYPE, x509->heap) != 0) {
        return MEMORY_E;
 800a5be:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a5c2:	e281      	b.n	800aac8 <CopyDecodedToX509+0x832>
    }
#endif /* OPENSSL_EXTRA || OPENSSL_EXTRA_X509_SMALL */
    x509->altNamesNext   = x509->altNames;  /* index hint */
 800a5c4:	687b      	ldr	r3, [r7, #4]
 800a5c6:	6f5a      	ldr	r2, [r3, #116]	@ 0x74
 800a5c8:	687b      	ldr	r3, [r7, #4]
 800a5ca:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84

    x509->isCa = dCert->isCA;
 800a5ce:	683b      	ldr	r3, [r7, #0]
 800a5d0:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 800a5d4:	f3c3 1300 	ubfx	r3, r3, #4, #1
 800a5d8:	b2d9      	uxtb	r1, r3
 800a5da:	687a      	ldr	r2, [r7, #4]
 800a5dc:	f892 3095 	ldrb.w	r3, [r2, #149]	@ 0x95
 800a5e0:	f361 0300 	bfi	r3, r1, #0, #1
 800a5e4:	f882 3095 	strb.w	r3, [r2, #149]	@ 0x95
#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
    x509->pathLength = dCert->pathLength;
 800a5e8:	683b      	ldr	r3, [r7, #0]
 800a5ea:	f893 341c 	ldrb.w	r3, [r3, #1052]	@ 0x41c
 800a5ee:	461a      	mov	r2, r3
 800a5f0:	687b      	ldr	r3, [r7, #4]
 800a5f2:	f8c3 20c4 	str.w	r2, [r3, #196]	@ 0xc4
    x509->keyUsage = dCert->extKeyUsage;
 800a5f6:	683b      	ldr	r3, [r7, #0]
 800a5f8:	f8b3 2420 	ldrh.w	r2, [r3, #1056]	@ 0x420
 800a5fc:	687b      	ldr	r3, [r7, #4]
 800a5fe:	f8a3 20c8 	strh.w	r2, [r3, #200]	@ 0xc8

    x509->CRLdistSet = dCert->extCRLdistSet;
 800a602:	683b      	ldr	r3, [r7, #0]
 800a604:	f893 34b5 	ldrb.w	r3, [r3, #1205]	@ 0x4b5
 800a608:	f3c3 0340 	ubfx	r3, r3, #1, #1
 800a60c:	b2d9      	uxtb	r1, r3
 800a60e:	687a      	ldr	r2, [r7, #4]
 800a610:	f892 30f1 	ldrb.w	r3, [r2, #241]	@ 0xf1
 800a614:	f361 0300 	bfi	r3, r1, #0, #1
 800a618:	f882 30f1 	strb.w	r3, [r2, #241]	@ 0xf1
    x509->CRLdistCrit = dCert->extCRLdistCrit;
 800a61c:	683b      	ldr	r3, [r7, #0]
 800a61e:	f893 34b6 	ldrb.w	r3, [r3, #1206]	@ 0x4b6
 800a622:	f3c3 0380 	ubfx	r3, r3, #2, #1
 800a626:	b2d9      	uxtb	r1, r3
 800a628:	687a      	ldr	r2, [r7, #4]
 800a62a:	f892 30f1 	ldrb.w	r3, [r2, #241]	@ 0xf1
 800a62e:	f361 0341 	bfi	r3, r1, #1, #1
 800a632:	f882 30f1 	strb.w	r3, [r2, #241]	@ 0xf1
    if (dCert->extCrlInfoRaw != NULL && dCert->extCrlInfoRawSz > 0) {
 800a636:	683b      	ldr	r3, [r7, #0]
 800a638:	f8d3 33b4 	ldr.w	r3, [r3, #948]	@ 0x3b4
 800a63c:	2b00      	cmp	r3, #0
 800a63e:	d029      	beq.n	800a694 <CopyDecodedToX509+0x3fe>
 800a640:	683b      	ldr	r3, [r7, #0]
 800a642:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800a646:	2b00      	cmp	r3, #0
 800a648:	dd24      	ble.n	800a694 <CopyDecodedToX509+0x3fe>
        x509->rawCRLInfo = (byte*)XMALLOC(dCert->extCrlInfoRawSz, x509->heap,
 800a64a:	683b      	ldr	r3, [r7, #0]
 800a64c:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800a650:	4618      	mov	r0, r3
 800a652:	f014 fa19 	bl	801ea88 <wolfSSL_Malloc>
 800a656:	4602      	mov	r2, r0
 800a658:	687b      	ldr	r3, [r7, #4]
 800a65a:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0
            DYNAMIC_TYPE_X509_EXT);
        if (x509->rawCRLInfo != NULL) {
 800a65e:	687b      	ldr	r3, [r7, #4]
 800a660:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
 800a664:	2b00      	cmp	r3, #0
 800a666:	d012      	beq.n	800a68e <CopyDecodedToX509+0x3f8>
            XMEMCPY(x509->rawCRLInfo, dCert->extCrlInfoRaw, dCert->extCrlInfoRawSz);
 800a668:	687b      	ldr	r3, [r7, #4]
 800a66a:	f8d3 00b0 	ldr.w	r0, [r3, #176]	@ 0xb0
 800a66e:	683b      	ldr	r3, [r7, #0]
 800a670:	f8d3 13b4 	ldr.w	r1, [r3, #948]	@ 0x3b4
 800a674:	683b      	ldr	r3, [r7, #0]
 800a676:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800a67a:	461a      	mov	r2, r3
 800a67c:	f01d ff8e 	bl	802859c <memcpy>
            x509->rawCRLInfoSz = dCert->extCrlInfoRawSz;
 800a680:	683b      	ldr	r3, [r7, #0]
 800a682:	f8d3 23b8 	ldr.w	r2, [r3, #952]	@ 0x3b8
 800a686:	687b      	ldr	r3, [r7, #4]
 800a688:	f8c3 20cc 	str.w	r2, [r3, #204]	@ 0xcc
 800a68c:	e002      	b.n	800a694 <CopyDecodedToX509+0x3fe>
        }
        else {
            ret = MEMORY_E;
 800a68e:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a692:	60fb      	str	r3, [r7, #12]
        }
    }
    if (dCert->extCrlInfo != NULL && dCert->extCrlInfoSz > 0) {
 800a694:	683b      	ldr	r3, [r7, #0]
 800a696:	f8d3 33bc 	ldr.w	r3, [r3, #956]	@ 0x3bc
 800a69a:	2b00      	cmp	r3, #0
 800a69c:	d029      	beq.n	800a6f2 <CopyDecodedToX509+0x45c>
 800a69e:	683b      	ldr	r3, [r7, #0]
 800a6a0:	f8d3 33c0 	ldr.w	r3, [r3, #960]	@ 0x3c0
 800a6a4:	2b00      	cmp	r3, #0
 800a6a6:	dd24      	ble.n	800a6f2 <CopyDecodedToX509+0x45c>
        x509->CRLInfo = (byte*)XMALLOC(dCert->extCrlInfoSz, x509->heap,
 800a6a8:	683b      	ldr	r3, [r7, #0]
 800a6aa:	f8d3 33c0 	ldr.w	r3, [r3, #960]	@ 0x3c0
 800a6ae:	4618      	mov	r0, r3
 800a6b0:	f014 f9ea 	bl	801ea88 <wolfSSL_Malloc>
 800a6b4:	4602      	mov	r2, r0
 800a6b6:	687b      	ldr	r3, [r7, #4]
 800a6b8:	f8c3 20b4 	str.w	r2, [r3, #180]	@ 0xb4
            DYNAMIC_TYPE_X509_EXT);
        if (x509->CRLInfo != NULL) {
 800a6bc:	687b      	ldr	r3, [r7, #4]
 800a6be:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
 800a6c2:	2b00      	cmp	r3, #0
 800a6c4:	d012      	beq.n	800a6ec <CopyDecodedToX509+0x456>
            XMEMCPY(x509->CRLInfo, dCert->extCrlInfo, dCert->extCrlInfoSz);
 800a6c6:	687b      	ldr	r3, [r7, #4]
 800a6c8:	f8d3 00b4 	ldr.w	r0, [r3, #180]	@ 0xb4
 800a6cc:	683b      	ldr	r3, [r7, #0]
 800a6ce:	f8d3 13bc 	ldr.w	r1, [r3, #956]	@ 0x3bc
 800a6d2:	683b      	ldr	r3, [r7, #0]
 800a6d4:	f8d3 33c0 	ldr.w	r3, [r3, #960]	@ 0x3c0
 800a6d8:	461a      	mov	r2, r3
 800a6da:	f01d ff5f 	bl	802859c <memcpy>
            x509->CRLInfoSz = dCert->extCrlInfoSz;
 800a6de:	683b      	ldr	r3, [r7, #0]
 800a6e0:	f8d3 23c0 	ldr.w	r2, [r3, #960]	@ 0x3c0
 800a6e4:	687b      	ldr	r3, [r7, #4]
 800a6e6:	f8c3 20d0 	str.w	r2, [r3, #208]	@ 0xd0
 800a6ea:	e002      	b.n	800a6f2 <CopyDecodedToX509+0x45c>
        }
        else {
            ret = MEMORY_E;
 800a6ec:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a6f0:	60fb      	str	r3, [r7, #12]
        }
    }
    x509->authInfoSet = dCert->extAuthInfoSet;
 800a6f2:	683b      	ldr	r3, [r7, #0]
 800a6f4:	f893 34b5 	ldrb.w	r3, [r3, #1205]	@ 0x4b5
 800a6f8:	f3c3 0380 	ubfx	r3, r3, #2, #1
 800a6fc:	b2d9      	uxtb	r1, r3
 800a6fe:	687a      	ldr	r2, [r7, #4]
 800a700:	f892 30f1 	ldrb.w	r3, [r2, #241]	@ 0xf1
 800a704:	f361 0382 	bfi	r3, r1, #2, #1
 800a708:	f882 30f1 	strb.w	r3, [r2, #241]	@ 0xf1
    x509->authInfoCrit = dCert->extAuthInfoCrit;
 800a70c:	683b      	ldr	r3, [r7, #0]
 800a70e:	f893 34b6 	ldrb.w	r3, [r3, #1206]	@ 0x4b6
 800a712:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 800a716:	b2d9      	uxtb	r1, r3
 800a718:	687a      	ldr	r2, [r7, #4]
 800a71a:	f892 30f1 	ldrb.w	r3, [r2, #241]	@ 0xf1
 800a71e:	f361 03c3 	bfi	r3, r1, #3, #1
 800a722:	f882 30f1 	strb.w	r3, [r2, #241]	@ 0xf1
    if (dCert->extAuthInfo != NULL && dCert->extAuthInfoSz > 0) {
 800a726:	683b      	ldr	r3, [r7, #0]
 800a728:	f8d3 33a4 	ldr.w	r3, [r3, #932]	@ 0x3a4
 800a72c:	2b00      	cmp	r3, #0
 800a72e:	d029      	beq.n	800a784 <CopyDecodedToX509+0x4ee>
 800a730:	683b      	ldr	r3, [r7, #0]
 800a732:	f8d3 33a8 	ldr.w	r3, [r3, #936]	@ 0x3a8
 800a736:	2b00      	cmp	r3, #0
 800a738:	dd24      	ble.n	800a784 <CopyDecodedToX509+0x4ee>
        x509->authInfo = (byte*)XMALLOC(dCert->extAuthInfoSz, x509->heap,
 800a73a:	683b      	ldr	r3, [r7, #0]
 800a73c:	f8d3 33a8 	ldr.w	r3, [r3, #936]	@ 0x3a8
 800a740:	4618      	mov	r0, r3
 800a742:	f014 f9a1 	bl	801ea88 <wolfSSL_Malloc>
 800a746:	4602      	mov	r2, r0
 800a748:	687b      	ldr	r3, [r7, #4]
 800a74a:	f8c3 20b8 	str.w	r2, [r3, #184]	@ 0xb8
                DYNAMIC_TYPE_X509_EXT);
        if (x509->authInfo != NULL) {
 800a74e:	687b      	ldr	r3, [r7, #4]
 800a750:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
 800a754:	2b00      	cmp	r3, #0
 800a756:	d012      	beq.n	800a77e <CopyDecodedToX509+0x4e8>
            XMEMCPY(x509->authInfo, dCert->extAuthInfo, dCert->extAuthInfoSz);
 800a758:	687b      	ldr	r3, [r7, #4]
 800a75a:	f8d3 00b8 	ldr.w	r0, [r3, #184]	@ 0xb8
 800a75e:	683b      	ldr	r3, [r7, #0]
 800a760:	f8d3 13a4 	ldr.w	r1, [r3, #932]	@ 0x3a4
 800a764:	683b      	ldr	r3, [r7, #0]
 800a766:	f8d3 33a8 	ldr.w	r3, [r3, #936]	@ 0x3a8
 800a76a:	461a      	mov	r2, r3
 800a76c:	f01d ff16 	bl	802859c <memcpy>
            x509->authInfoSz = dCert->extAuthInfoSz;
 800a770:	683b      	ldr	r3, [r7, #0]
 800a772:	f8d3 23a8 	ldr.w	r2, [r3, #936]	@ 0x3a8
 800a776:	687b      	ldr	r3, [r7, #4]
 800a778:	f8c3 20d4 	str.w	r2, [r3, #212]	@ 0xd4
 800a77c:	e002      	b.n	800a784 <CopyDecodedToX509+0x4ee>
        }
        else {
            ret = MEMORY_E;
 800a77e:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a782:	60fb      	str	r3, [r7, #12]
        }
    }
    #ifdef WOLFSSL_ASN_CA_ISSUER
    if (dCert->extAuthInfoCaIssuer != NULL && dCert->extAuthInfoCaIssuerSz > 0) {
 800a784:	683b      	ldr	r3, [r7, #0]
 800a786:	f8d3 33ac 	ldr.w	r3, [r3, #940]	@ 0x3ac
 800a78a:	2b00      	cmp	r3, #0
 800a78c:	d029      	beq.n	800a7e2 <CopyDecodedToX509+0x54c>
 800a78e:	683b      	ldr	r3, [r7, #0]
 800a790:	f8d3 33b0 	ldr.w	r3, [r3, #944]	@ 0x3b0
 800a794:	2b00      	cmp	r3, #0
 800a796:	dd24      	ble.n	800a7e2 <CopyDecodedToX509+0x54c>
        x509->authInfoCaIssuer = (byte*)XMALLOC(dCert->extAuthInfoCaIssuerSz, x509->heap,
 800a798:	683b      	ldr	r3, [r7, #0]
 800a79a:	f8d3 33b0 	ldr.w	r3, [r3, #944]	@ 0x3b0
 800a79e:	4618      	mov	r0, r3
 800a7a0:	f014 f972 	bl	801ea88 <wolfSSL_Malloc>
 800a7a4:	4602      	mov	r2, r0
 800a7a6:	687b      	ldr	r3, [r7, #4]
 800a7a8:	f8c3 20bc 	str.w	r2, [r3, #188]	@ 0xbc
                DYNAMIC_TYPE_X509_EXT);
        if (x509->authInfoCaIssuer != NULL) {
 800a7ac:	687b      	ldr	r3, [r7, #4]
 800a7ae:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 800a7b2:	2b00      	cmp	r3, #0
 800a7b4:	d012      	beq.n	800a7dc <CopyDecodedToX509+0x546>
            XMEMCPY(x509->authInfoCaIssuer, dCert->extAuthInfoCaIssuer, dCert->extAuthInfoCaIssuerSz);
 800a7b6:	687b      	ldr	r3, [r7, #4]
 800a7b8:	f8d3 00bc 	ldr.w	r0, [r3, #188]	@ 0xbc
 800a7bc:	683b      	ldr	r3, [r7, #0]
 800a7be:	f8d3 13ac 	ldr.w	r1, [r3, #940]	@ 0x3ac
 800a7c2:	683b      	ldr	r3, [r7, #0]
 800a7c4:	f8d3 33b0 	ldr.w	r3, [r3, #944]	@ 0x3b0
 800a7c8:	461a      	mov	r2, r3
 800a7ca:	f01d fee7 	bl	802859c <memcpy>
            x509->authInfoCaIssuerSz = dCert->extAuthInfoCaIssuerSz;
 800a7ce:	683b      	ldr	r3, [r7, #0]
 800a7d0:	f8d3 23b0 	ldr.w	r2, [r3, #944]	@ 0x3b0
 800a7d4:	687b      	ldr	r3, [r7, #4]
 800a7d6:	f8c3 20c0 	str.w	r2, [r3, #192]	@ 0xc0
 800a7da:	e002      	b.n	800a7e2 <CopyDecodedToX509+0x54c>
        }
        else {
            ret = MEMORY_E;
 800a7dc:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a7e0:	60fb      	str	r3, [r7, #12]
        }
    }
    #endif
    x509->basicConstSet = dCert->extBasicConstSet;
 800a7e2:	683b      	ldr	r3, [r7, #0]
 800a7e4:	f893 34b5 	ldrb.w	r3, [r3, #1205]	@ 0x4b5
 800a7e8:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 800a7ec:	b2d9      	uxtb	r1, r3
 800a7ee:	687a      	ldr	r2, [r7, #4]
 800a7f0:	f892 30f2 	ldrb.w	r3, [r2, #242]	@ 0xf2
 800a7f4:	f361 0341 	bfi	r3, r1, #1, #1
 800a7f8:	f882 30f2 	strb.w	r3, [r2, #242]	@ 0xf2
    x509->basicConstCrit = dCert->extBasicConstCrit;
 800a7fc:	683b      	ldr	r3, [r7, #0]
 800a7fe:	f893 34b6 	ldrb.w	r3, [r3, #1206]	@ 0x4b6
 800a802:	f3c3 1300 	ubfx	r3, r3, #4, #1
 800a806:	b2d9      	uxtb	r1, r3
 800a808:	687a      	ldr	r2, [r7, #4]
 800a80a:	f892 30f2 	ldrb.w	r3, [r2, #242]	@ 0xf2
 800a80e:	f361 0382 	bfi	r3, r1, #2, #1
 800a812:	f882 30f2 	strb.w	r3, [r2, #242]	@ 0xf2
    x509->basicConstPlSet = dCert->pathLengthSet;
 800a816:	683b      	ldr	r3, [r7, #0]
 800a818:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 800a81c:	f3c3 1340 	ubfx	r3, r3, #5, #1
 800a820:	b2d9      	uxtb	r1, r3
 800a822:	687a      	ldr	r2, [r7, #4]
 800a824:	f892 30f2 	ldrb.w	r3, [r2, #242]	@ 0xf2
 800a828:	f361 03c3 	bfi	r3, r1, #3, #1
 800a82c:	f882 30f2 	strb.w	r3, [r2, #242]	@ 0xf2
    x509->subjAltNameSet = dCert->extSubjAltNameSet;
 800a830:	683b      	ldr	r3, [r7, #0]
 800a832:	f893 34b5 	ldrb.w	r3, [r3, #1205]	@ 0x4b5
 800a836:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 800a83a:	b2d9      	uxtb	r1, r3
 800a83c:	687a      	ldr	r2, [r7, #4]
 800a83e:	f892 30f2 	ldrb.w	r3, [r2, #242]	@ 0xf2
 800a842:	f361 1304 	bfi	r3, r1, #4, #1
 800a846:	f882 30f2 	strb.w	r3, [r2, #242]	@ 0xf2
    x509->subjAltNameCrit = dCert->extSubjAltNameCrit;
 800a84a:	683b      	ldr	r3, [r7, #0]
 800a84c:	f893 34b6 	ldrb.w	r3, [r3, #1206]	@ 0x4b6
 800a850:	f3c3 1380 	ubfx	r3, r3, #6, #1
 800a854:	b2d9      	uxtb	r1, r3
 800a856:	687a      	ldr	r2, [r7, #4]
 800a858:	f892 30f2 	ldrb.w	r3, [r2, #242]	@ 0xf2
 800a85c:	f361 1345 	bfi	r3, r1, #5, #1
 800a860:	f882 30f2 	strb.w	r3, [r2, #242]	@ 0xf2
    x509->authKeyIdSet = dCert->extAuthKeyIdSet;
 800a864:	683b      	ldr	r3, [r7, #0]
 800a866:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 800a86a:	f3c3 0380 	ubfx	r3, r3, #2, #1
 800a86e:	b2d9      	uxtb	r1, r3
 800a870:	687a      	ldr	r2, [r7, #4]
 800a872:	f892 30f2 	ldrb.w	r3, [r2, #242]	@ 0xf2
 800a876:	f361 1386 	bfi	r3, r1, #6, #1
 800a87a:	f882 30f2 	strb.w	r3, [r2, #242]	@ 0xf2
    x509->authKeyIdCrit = dCert->extAuthKeyIdCrit;
 800a87e:	683b      	ldr	r3, [r7, #0]
 800a880:	f893 34b6 	ldrb.w	r3, [r3, #1206]	@ 0x4b6
 800a884:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 800a888:	b2d9      	uxtb	r1, r3
 800a88a:	687a      	ldr	r2, [r7, #4]
 800a88c:	f892 30f2 	ldrb.w	r3, [r2, #242]	@ 0xf2
 800a890:	f361 13c7 	bfi	r3, r1, #7, #1
 800a894:	f882 30f2 	strb.w	r3, [r2, #242]	@ 0xf2
    if (dCert->extAuthKeyIdSrc != NULL && dCert->extAuthKeyIdSz != 0) {
 800a898:	683b      	ldr	r3, [r7, #0]
 800a89a:	f8d3 3438 	ldr.w	r3, [r3, #1080]	@ 0x438
 800a89e:	2b00      	cmp	r3, #0
 800a8a0:	d05a      	beq.n	800a958 <CopyDecodedToX509+0x6c2>
 800a8a2:	683b      	ldr	r3, [r7, #0]
 800a8a4:	f8d3 3408 	ldr.w	r3, [r3, #1032]	@ 0x408
 800a8a8:	2b00      	cmp	r3, #0
 800a8aa:	d055      	beq.n	800a958 <CopyDecodedToX509+0x6c2>
    #ifdef WOLFSSL_AKID_NAME
        if (dCert->extRawAuthKeyIdSrc != NULL &&
 800a8ac:	683b      	ldr	r3, [r7, #0]
 800a8ae:	f8d3 3430 	ldr.w	r3, [r3, #1072]	@ 0x430
 800a8b2:	2b00      	cmp	r3, #0
 800a8b4:	d04d      	beq.n	800a952 <CopyDecodedToX509+0x6bc>
                dCert->extAuthKeyIdSrc > dCert->extRawAuthKeyIdSrc &&
 800a8b6:	683b      	ldr	r3, [r7, #0]
 800a8b8:	f8d3 2438 	ldr.w	r2, [r3, #1080]	@ 0x438
 800a8bc:	683b      	ldr	r3, [r7, #0]
 800a8be:	f8d3 3430 	ldr.w	r3, [r3, #1072]	@ 0x430
        if (dCert->extRawAuthKeyIdSrc != NULL &&
 800a8c2:	429a      	cmp	r2, r3
 800a8c4:	d945      	bls.n	800a952 <CopyDecodedToX509+0x6bc>
                dCert->extAuthKeyIdSrc <
 800a8c6:	683b      	ldr	r3, [r7, #0]
 800a8c8:	f8d3 2438 	ldr.w	r2, [r3, #1080]	@ 0x438
                    (dCert->extRawAuthKeyIdSrc + dCert->extRawAuthKeyIdSz)) {
 800a8cc:	683b      	ldr	r3, [r7, #0]
 800a8ce:	f8d3 1430 	ldr.w	r1, [r3, #1072]	@ 0x430
 800a8d2:	683b      	ldr	r3, [r7, #0]
 800a8d4:	f8d3 3434 	ldr.w	r3, [r3, #1076]	@ 0x434
 800a8d8:	440b      	add	r3, r1
                dCert->extAuthKeyIdSrc > dCert->extRawAuthKeyIdSrc &&
 800a8da:	429a      	cmp	r2, r3
 800a8dc:	d239      	bcs.n	800a952 <CopyDecodedToX509+0x6bc>
            /* Confirmed: extAuthKeyIdSrc points inside extRawAuthKeyIdSrc */
            x509->authKeyIdSrc = (byte*)XMALLOC(dCert->extRawAuthKeyIdSz,
 800a8de:	683b      	ldr	r3, [r7, #0]
 800a8e0:	f8d3 3434 	ldr.w	r3, [r3, #1076]	@ 0x434
 800a8e4:	4618      	mov	r0, r3
 800a8e6:	f014 f8cf 	bl	801ea88 <wolfSSL_Malloc>
 800a8ea:	4602      	mov	r2, r0
 800a8ec:	687b      	ldr	r3, [r7, #4]
 800a8ee:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
                    x509->heap, DYNAMIC_TYPE_X509_EXT);
            if (x509->authKeyIdSrc != NULL) {
 800a8f2:	687b      	ldr	r3, [r7, #4]
 800a8f4:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
 800a8f8:	2b00      	cmp	r3, #0
 800a8fa:	d026      	beq.n	800a94a <CopyDecodedToX509+0x6b4>
                XMEMCPY(x509->authKeyIdSrc, dCert->extRawAuthKeyIdSrc,
 800a8fc:	687b      	ldr	r3, [r7, #4]
 800a8fe:	f8d3 00a0 	ldr.w	r0, [r3, #160]	@ 0xa0
 800a902:	683b      	ldr	r3, [r7, #0]
 800a904:	f8d3 1430 	ldr.w	r1, [r3, #1072]	@ 0x430
 800a908:	683b      	ldr	r3, [r7, #0]
 800a90a:	f8d3 3434 	ldr.w	r3, [r3, #1076]	@ 0x434
 800a90e:	461a      	mov	r2, r3
 800a910:	f01d fe44 	bl	802859c <memcpy>
                        dCert->extRawAuthKeyIdSz);
                x509->authKeyIdSrcSz = dCert->extRawAuthKeyIdSz;
 800a914:	683b      	ldr	r3, [r7, #0]
 800a916:	f8d3 2434 	ldr.w	r2, [r3, #1076]	@ 0x434
 800a91a:	687b      	ldr	r3, [r7, #4]
 800a91c:	f8c3 20dc 	str.w	r2, [r3, #220]	@ 0xdc
                /* Set authKeyId to same offset inside authKeyIdSrc */
                x509->authKeyId = x509->authKeyIdSrc +
 800a920:	687b      	ldr	r3, [r7, #4]
 800a922:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
                        (dCert->extAuthKeyIdSrc - dCert->extRawAuthKeyIdSrc);
 800a926:	683a      	ldr	r2, [r7, #0]
 800a928:	f8d2 1438 	ldr.w	r1, [r2, #1080]	@ 0x438
 800a92c:	683a      	ldr	r2, [r7, #0]
 800a92e:	f8d2 2430 	ldr.w	r2, [r2, #1072]	@ 0x430
 800a932:	1a8a      	subs	r2, r1, r2
                x509->authKeyId = x509->authKeyIdSrc +
 800a934:	441a      	add	r2, r3
 800a936:	687b      	ldr	r3, [r7, #4]
 800a938:	f8c3 209c 	str.w	r2, [r3, #156]	@ 0x9c
                x509->authKeyIdSz = dCert->extAuthKeyIdSz;
 800a93c:	683b      	ldr	r3, [r7, #0]
 800a93e:	f8d3 2408 	ldr.w	r2, [r3, #1032]	@ 0x408
 800a942:	687b      	ldr	r3, [r7, #4]
 800a944:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
            if (x509->authKeyIdSrc != NULL) {
 800a948:	e006      	b.n	800a958 <CopyDecodedToX509+0x6c2>
            }
            else
                ret = MEMORY_E;
 800a94a:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a94e:	60fb      	str	r3, [r7, #12]
            if (x509->authKeyIdSrc != NULL) {
 800a950:	e002      	b.n	800a958 <CopyDecodedToX509+0x6c2>
                                 dCert->extAuthKeyIdSrc, dCert->extAuthKeyIdSz);
            x509->authKeyIdSz = dCert->extAuthKeyIdSz;
        }
    #endif
        else
            ret = MEMORY_E;
 800a952:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a956:	60fb      	str	r3, [r7, #12]
    }
    x509->subjKeyIdSet = dCert->extSubjKeyIdSet;
 800a958:	683b      	ldr	r3, [r7, #0]
 800a95a:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 800a95e:	f3c3 0340 	ubfx	r3, r3, #1, #1
 800a962:	b2d9      	uxtb	r1, r3
 800a964:	687a      	ldr	r2, [r7, #4]
 800a966:	f892 30f1 	ldrb.w	r3, [r2, #241]	@ 0xf1
 800a96a:	f361 13c7 	bfi	r3, r1, #7, #1
 800a96e:	f882 30f1 	strb.w	r3, [r2, #241]	@ 0xf1
    x509->subjKeyIdCrit = dCert->extSubjKeyIdCrit;
 800a972:	683b      	ldr	r3, [r7, #0]
 800a974:	f893 34b7 	ldrb.w	r3, [r3, #1207]	@ 0x4b7
 800a978:	f3c3 0340 	ubfx	r3, r3, #1, #1
 800a97c:	b2d9      	uxtb	r1, r3
 800a97e:	687a      	ldr	r2, [r7, #4]
 800a980:	f892 30f2 	ldrb.w	r3, [r2, #242]	@ 0xf2
 800a984:	f361 0300 	bfi	r3, r1, #0, #1
 800a988:	f882 30f2 	strb.w	r3, [r2, #242]	@ 0xf2
    if (dCert->extSubjKeyIdSrc != NULL && dCert->extSubjKeyIdSz != 0) {
 800a98c:	683b      	ldr	r3, [r7, #0]
 800a98e:	f8d3 343c 	ldr.w	r3, [r3, #1084]	@ 0x43c
 800a992:	2b00      	cmp	r3, #0
 800a994:	d029      	beq.n	800a9ea <CopyDecodedToX509+0x754>
 800a996:	683b      	ldr	r3, [r7, #0]
 800a998:	f8d3 33e4 	ldr.w	r3, [r3, #996]	@ 0x3e4
 800a99c:	2b00      	cmp	r3, #0
 800a99e:	d024      	beq.n	800a9ea <CopyDecodedToX509+0x754>
        x509->subjKeyId = (byte*)XMALLOC(dCert->extSubjKeyIdSz, x509->heap,
 800a9a0:	683b      	ldr	r3, [r7, #0]
 800a9a2:	f8d3 33e4 	ldr.w	r3, [r3, #996]	@ 0x3e4
 800a9a6:	4618      	mov	r0, r3
 800a9a8:	f014 f86e 	bl	801ea88 <wolfSSL_Malloc>
 800a9ac:	4602      	mov	r2, r0
 800a9ae:	687b      	ldr	r3, [r7, #4]
 800a9b0:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4
                                         DYNAMIC_TYPE_X509_EXT);
        if (x509->subjKeyId != NULL) {
 800a9b4:	687b      	ldr	r3, [r7, #4]
 800a9b6:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 800a9ba:	2b00      	cmp	r3, #0
 800a9bc:	d012      	beq.n	800a9e4 <CopyDecodedToX509+0x74e>
            XMEMCPY(x509->subjKeyId,
 800a9be:	687b      	ldr	r3, [r7, #4]
 800a9c0:	f8d3 00a4 	ldr.w	r0, [r3, #164]	@ 0xa4
 800a9c4:	683b      	ldr	r3, [r7, #0]
 800a9c6:	f8d3 143c 	ldr.w	r1, [r3, #1084]	@ 0x43c
 800a9ca:	683b      	ldr	r3, [r7, #0]
 800a9cc:	f8d3 33e4 	ldr.w	r3, [r3, #996]	@ 0x3e4
 800a9d0:	461a      	mov	r2, r3
 800a9d2:	f01d fde3 	bl	802859c <memcpy>
                                 dCert->extSubjKeyIdSrc, dCert->extSubjKeyIdSz);
            x509->subjKeyIdSz = dCert->extSubjKeyIdSz;
 800a9d6:	683b      	ldr	r3, [r7, #0]
 800a9d8:	f8d3 23e4 	ldr.w	r2, [r3, #996]	@ 0x3e4
 800a9dc:	687b      	ldr	r3, [r7, #4]
 800a9de:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
 800a9e2:	e002      	b.n	800a9ea <CopyDecodedToX509+0x754>
        }
        else
            ret = MEMORY_E;
 800a9e4:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a9e8:	60fb      	str	r3, [r7, #12]
    }
    x509->keyUsageSet = dCert->extKeyUsageSet;
 800a9ea:	683b      	ldr	r3, [r7, #0]
 800a9ec:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 800a9f0:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 800a9f4:	b2d9      	uxtb	r1, r3
 800a9f6:	687a      	ldr	r2, [r7, #4]
 800a9f8:	f892 30f1 	ldrb.w	r3, [r2, #241]	@ 0xf1
 800a9fc:	f361 1304 	bfi	r3, r1, #4, #1
 800aa00:	f882 30f1 	strb.w	r3, [r2, #241]	@ 0xf1
    x509->keyUsageCrit = dCert->extKeyUsageCrit;
 800aa04:	683b      	ldr	r3, [r7, #0]
 800aa06:	f893 34b7 	ldrb.w	r3, [r3, #1207]	@ 0x4b7
 800aa0a:	f3c3 0380 	ubfx	r3, r3, #2, #1
 800aa0e:	b2d9      	uxtb	r1, r3
 800aa10:	687a      	ldr	r2, [r7, #4]
 800aa12:	f892 30f1 	ldrb.w	r3, [r2, #241]	@ 0xf1
 800aa16:	f361 1345 	bfi	r3, r1, #5, #1
 800aa1a:	f882 30f1 	strb.w	r3, [r2, #241]	@ 0xf1
    if (dCert->extExtKeyUsageSrc != NULL && dCert->extExtKeyUsageSz > 0) {
 800aa1e:	683b      	ldr	r3, [r7, #0]
 800aa20:	f8d3 3424 	ldr.w	r3, [r3, #1060]	@ 0x424
 800aa24:	2b00      	cmp	r3, #0
 800aa26:	d042      	beq.n	800aaae <CopyDecodedToX509+0x818>
 800aa28:	683b      	ldr	r3, [r7, #0]
 800aa2a:	f8d3 3428 	ldr.w	r3, [r3, #1064]	@ 0x428
 800aa2e:	2b00      	cmp	r3, #0
 800aa30:	d03d      	beq.n	800aaae <CopyDecodedToX509+0x818>
        x509->extKeyUsageSrc = (byte*)XMALLOC(dCert->extExtKeyUsageSz,
 800aa32:	683b      	ldr	r3, [r7, #0]
 800aa34:	f8d3 3428 	ldr.w	r3, [r3, #1064]	@ 0x428
 800aa38:	4618      	mov	r0, r3
 800aa3a:	f014 f825 	bl	801ea88 <wolfSSL_Malloc>
 800aa3e:	4602      	mov	r2, r0
 800aa40:	687b      	ldr	r3, [r7, #4]
 800aa42:	f8c3 20ac 	str.w	r2, [r3, #172]	@ 0xac
                x509->heap, DYNAMIC_TYPE_X509_EXT);
        if (x509->extKeyUsageSrc != NULL) {
 800aa46:	687b      	ldr	r3, [r7, #4]
 800aa48:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
 800aa4c:	2b00      	cmp	r3, #0
 800aa4e:	d02b      	beq.n	800aaa8 <CopyDecodedToX509+0x812>
            XMEMCPY(x509->extKeyUsageSrc, dCert->extExtKeyUsageSrc,
 800aa50:	687b      	ldr	r3, [r7, #4]
 800aa52:	f8d3 00ac 	ldr.w	r0, [r3, #172]	@ 0xac
 800aa56:	683b      	ldr	r3, [r7, #0]
 800aa58:	f8d3 1424 	ldr.w	r1, [r3, #1060]	@ 0x424
 800aa5c:	683b      	ldr	r3, [r7, #0]
 800aa5e:	f8d3 3428 	ldr.w	r3, [r3, #1064]	@ 0x428
 800aa62:	461a      	mov	r2, r3
 800aa64:	f01d fd9a 	bl	802859c <memcpy>
                                                       dCert->extExtKeyUsageSz);
            x509->extKeyUsage      = dCert->extExtKeyUsage;
 800aa68:	683b      	ldr	r3, [r7, #0]
 800aa6a:	f893 2422 	ldrb.w	r2, [r3, #1058]	@ 0x422
 800aa6e:	687b      	ldr	r3, [r7, #4]
 800aa70:	f883 20e4 	strb.w	r2, [r3, #228]	@ 0xe4
            x509->extKeyUsageSz    = dCert->extExtKeyUsageSz;
 800aa74:	683b      	ldr	r3, [r7, #0]
 800aa76:	f8d3 2428 	ldr.w	r2, [r3, #1064]	@ 0x428
 800aa7a:	687b      	ldr	r3, [r7, #4]
 800aa7c:	f8c3 20e8 	str.w	r2, [r3, #232]	@ 0xe8
            x509->extKeyUsageCrit  = dCert->extExtKeyUsageCrit;
 800aa80:	683b      	ldr	r3, [r7, #0]
 800aa82:	f893 34b7 	ldrb.w	r3, [r3, #1207]	@ 0x4b7
 800aa86:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 800aa8a:	b2d9      	uxtb	r1, r3
 800aa8c:	687a      	ldr	r2, [r7, #4]
 800aa8e:	f892 30f1 	ldrb.w	r3, [r2, #241]	@ 0xf1
 800aa92:	f361 1386 	bfi	r3, r1, #6, #1
 800aa96:	f882 30f1 	strb.w	r3, [r2, #241]	@ 0xf1
            x509->extKeyUsageCount = dCert->extExtKeyUsageCount;
 800aa9a:	683b      	ldr	r3, [r7, #0]
 800aa9c:	f8d3 242c 	ldr.w	r2, [r3, #1068]	@ 0x42c
 800aaa0:	687b      	ldr	r3, [r7, #4]
 800aaa2:	f8c3 20ec 	str.w	r2, [r3, #236]	@ 0xec
 800aaa6:	e002      	b.n	800aaae <CopyDecodedToX509+0x818>
        }
        else {
            ret = MEMORY_E;
 800aaa8:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800aaac:	60fb      	str	r3, [r7, #12]
        }
    }
    #ifndef IGNORE_NETSCAPE_CERT_TYPE
    x509->nsCertType = dCert->nsCertType;
 800aaae:	683b      	ldr	r3, [r7, #0]
 800aab0:	f893 246c 	ldrb.w	r2, [r3, #1132]	@ 0x46c
 800aab4:	687b      	ldr	r3, [r7, #4]
 800aab6:	f883 20f0 	strb.w	r2, [r3, #240]	@ 0xf0
        else
            ret = MEMORY_E;
    }
#endif
#if defined(HAVE_ECC) || defined(HAVE_ED25519) || defined(HAVE_ED448)
    x509->pkCurveOID = dCert->pkCurveOID;
 800aaba:	683b      	ldr	r3, [r7, #0]
 800aabc:	f8d3 2440 	ldr.w	r2, [r3, #1088]	@ 0x440
 800aac0:	687b      	ldr	r3, [r7, #4]
 800aac2:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
            ret = MEMORY_E;
        }
    }
#endif /* WOLFSSL_DUAL_ALG_CERTS */

    return ret;
 800aac6:	68fb      	ldr	r3, [r7, #12]
}
 800aac8:	4618      	mov	r0, r3
 800aaca:	3710      	adds	r7, #16
 800aacc:	46bd      	mov	sp, r7
 800aace:	bd80      	pop	{r7, pc}

0800aad0 <SetupStoreCtxCallback>:
}

int SetupStoreCtxCallback(WOLFSSL_X509_STORE_CTX** store_pt,
        WOLFSSL* ssl, WOLFSSL_CERT_MANAGER* cm, ProcPeerCertArgs* args,
        int cert_err, void* heap, int* x509Free)
{
 800aad0:	b580      	push	{r7, lr}
 800aad2:	b08a      	sub	sp, #40	@ 0x28
 800aad4:	af00      	add	r7, sp, #0
 800aad6:	60f8      	str	r0, [r7, #12]
 800aad8:	60b9      	str	r1, [r7, #8]
 800aada:	607a      	str	r2, [r7, #4]
 800aadc:	603b      	str	r3, [r7, #0]
    WOLFSSL_X509_STORE_CTX* store = NULL;
 800aade:	2300      	movs	r3, #0
 800aae0:	61bb      	str	r3, [r7, #24]
    char* domain = NULL;
 800aae2:	2300      	movs	r3, #0
 800aae4:	627b      	str	r3, [r7, #36]	@ 0x24
#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
    WOLFSSL_X509* x509 = NULL;
 800aae6:	2300      	movs	r3, #0
 800aae8:	623b      	str	r3, [r7, #32]
#endif

    *x509Free = 0;
 800aaea:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800aaec:	2200      	movs	r2, #0
 800aaee:	601a      	str	r2, [r3, #0]

    store = wolfSSL_X509_STORE_CTX_new_ex(heap);
 800aaf0:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 800aaf2:	f004 fa19 	bl	800ef28 <wolfSSL_X509_STORE_CTX_new_ex>
 800aaf6:	61b8      	str	r0, [r7, #24]
    if (store == NULL)
 800aaf8:	69bb      	ldr	r3, [r7, #24]
 800aafa:	2b00      	cmp	r3, #0
 800aafc:	f000 8177 	beq.w	800adee <SetupStoreCtxCallback+0x31e>
        goto mem_error;
    domain = (char*)XMALLOC(ASN_NAME_MAX, heap, DYNAMIC_TYPE_STRING);
 800ab00:	f44f 70b4 	mov.w	r0, #360	@ 0x168
 800ab04:	f013 ffc0 	bl	801ea88 <wolfSSL_Malloc>
 800ab08:	6278      	str	r0, [r7, #36]	@ 0x24
    if (domain == NULL)
 800ab0a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800ab0c:	2b00      	cmp	r3, #0
 800ab0e:	f000 8170 	beq.w	800adf2 <SetupStoreCtxCallback+0x322>
        goto mem_error;

    domain[0] = '\0';
 800ab12:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800ab14:	2200      	movs	r2, #0
 800ab16:	701a      	strb	r2, [r3, #0]

    /* build subject CN as string to return in store */
    if (args->dCertInit && args->dCert && args->dCert->subjectCN) {
 800ab18:	683b      	ldr	r3, [r7, #0]
 800ab1a:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 800ab1e:	f003 0304 	and.w	r3, r3, #4
 800ab22:	b2db      	uxtb	r3, r3
 800ab24:	2b00      	cmp	r3, #0
 800ab26:	d026      	beq.n	800ab76 <SetupStoreCtxCallback+0xa6>
 800ab28:	683b      	ldr	r3, [r7, #0]
 800ab2a:	689b      	ldr	r3, [r3, #8]
 800ab2c:	2b00      	cmp	r3, #0
 800ab2e:	d022      	beq.n	800ab76 <SetupStoreCtxCallback+0xa6>
 800ab30:	683b      	ldr	r3, [r7, #0]
 800ab32:	689b      	ldr	r3, [r3, #8]
 800ab34:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800ab38:	2b00      	cmp	r3, #0
 800ab3a:	d01c      	beq.n	800ab76 <SetupStoreCtxCallback+0xa6>
        int subjectCNLen = args->dCert->subjectCNLen;
 800ab3c:	683b      	ldr	r3, [r7, #0]
 800ab3e:	689b      	ldr	r3, [r3, #8]
 800ab40:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800ab44:	61fb      	str	r3, [r7, #28]
        if (subjectCNLen > ASN_NAME_MAX-1)
 800ab46:	69fb      	ldr	r3, [r7, #28]
 800ab48:	f5b3 7fb4 	cmp.w	r3, #360	@ 0x168
 800ab4c:	db02      	blt.n	800ab54 <SetupStoreCtxCallback+0x84>
            subjectCNLen = ASN_NAME_MAX-1;
 800ab4e:	f240 1367 	movw	r3, #359	@ 0x167
 800ab52:	61fb      	str	r3, [r7, #28]
        if (subjectCNLen > 0) {
 800ab54:	69fb      	ldr	r3, [r7, #28]
 800ab56:	2b00      	cmp	r3, #0
 800ab58:	dd0d      	ble.n	800ab76 <SetupStoreCtxCallback+0xa6>
            XMEMCPY(domain, args->dCert->subjectCN, subjectCNLen);
 800ab5a:	683b      	ldr	r3, [r7, #0]
 800ab5c:	689b      	ldr	r3, [r3, #8]
 800ab5e:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800ab62:	69fa      	ldr	r2, [r7, #28]
 800ab64:	4619      	mov	r1, r3
 800ab66:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800ab68:	f01d fd18 	bl	802859c <memcpy>
            domain[subjectCNLen] = '\0';
 800ab6c:	69fb      	ldr	r3, [r7, #28]
 800ab6e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800ab70:	4413      	add	r3, r2
 800ab72:	2200      	movs	r2, #0
 800ab74:	701a      	strb	r2, [r3, #0]
        }
    }

#ifndef OPENSSL_COMPATIBLE_DEFAULTS
    store->error = cert_err;
 800ab76:	69bb      	ldr	r3, [r7, #24]
 800ab78:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 800ab7a:	625a      	str	r2, [r3, #36]	@ 0x24
#else
    store->error = GetX509Error(cert_err);
#endif
    store->error_depth = args->certIdx;
 800ab7c:	683b      	ldr	r3, [r7, #0]
 800ab7e:	69da      	ldr	r2, [r3, #28]
 800ab80:	69bb      	ldr	r3, [r7, #24]
 800ab82:	629a      	str	r2, [r3, #40]	@ 0x28
    store->discardSessionCerts = 0;
 800ab84:	69bb      	ldr	r3, [r7, #24]
 800ab86:	2200      	movs	r2, #0
 800ab88:	62da      	str	r2, [r3, #44]	@ 0x2c
    store->domain = domain;
 800ab8a:	69bb      	ldr	r3, [r7, #24]
 800ab8c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800ab8e:	619a      	str	r2, [r3, #24]
    if (ssl != NULL) {
 800ab90:	68bb      	ldr	r3, [r7, #8]
 800ab92:	2b00      	cmp	r3, #0
 800ab94:	d011      	beq.n	800abba <SetupStoreCtxCallback+0xea>
        if (ssl->verifyCbCtx != NULL) {
 800ab96:	68bb      	ldr	r3, [r7, #8]
 800ab98:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800ab9c:	2b00      	cmp	r3, #0
 800ab9e:	d005      	beq.n	800abac <SetupStoreCtxCallback+0xdc>
            /* Use the WOLFSSL user context if set */
            store->userCtx = ssl->verifyCbCtx;
 800aba0:	68bb      	ldr	r3, [r7, #8]
 800aba2:	f8d3 2084 	ldr.w	r2, [r3, #132]	@ 0x84
 800aba6:	69bb      	ldr	r3, [r7, #24]
 800aba8:	621a      	str	r2, [r3, #32]
 800abaa:	e009      	b.n	800abc0 <SetupStoreCtxCallback+0xf0>
        }
        else {
            /* Else use the WOLFSSL_CTX user context */
            store->userCtx = ssl->ctx->verifyCbCtx;
 800abac:	68bb      	ldr	r3, [r7, #8]
 800abae:	681b      	ldr	r3, [r3, #0]
 800abb0:	f8d3 20b8 	ldr.w	r2, [r3, #184]	@ 0xb8
 800abb4:	69bb      	ldr	r3, [r7, #24]
 800abb6:	621a      	str	r2, [r3, #32]
 800abb8:	e002      	b.n	800abc0 <SetupStoreCtxCallback+0xf0>
        }
    }
    else {
        store->userCtx = cm;
 800abba:	69bb      	ldr	r3, [r7, #24]
 800abbc:	687a      	ldr	r2, [r7, #4]
 800abbe:	621a      	str	r2, [r3, #32]
    }
    store->certs = args->certs;
 800abc0:	683b      	ldr	r3, [r7, #0]
 800abc2:	681a      	ldr	r2, [r3, #0]
 800abc4:	69bb      	ldr	r3, [r7, #24]
 800abc6:	635a      	str	r2, [r3, #52]	@ 0x34
    store->totalCerts = args->totalCerts;
 800abc8:	683b      	ldr	r3, [r7, #0]
 800abca:	695a      	ldr	r2, [r3, #20]
 800abcc:	69bb      	ldr	r3, [r7, #24]
 800abce:	631a      	str	r2, [r3, #48]	@ 0x30
            != WOLFSSL_SUCCESS) {
        WOLFSSL_MSG("Failed to store ssl context in WOLFSSL_X509_STORE_CTX");
    }
#endif

    if (ssl != NULL) {
 800abd0:	68bb      	ldr	r3, [r7, #8]
 800abd2:	2b00      	cmp	r3, #0
 800abd4:	f000 8106 	beq.w	800ade4 <SetupStoreCtxCallback+0x314>
#if defined(OPENSSL_EXTRA) || defined(HAVE_WEBSERVER)
        store->store = SSL_STORE(ssl);
 800abd8:	68bb      	ldr	r3, [r7, #8]
 800abda:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800abde:	2b00      	cmp	r3, #0
 800abe0:	d003      	beq.n	800abea <SetupStoreCtxCallback+0x11a>
 800abe2:	68bb      	ldr	r3, [r7, #8]
 800abe4:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800abe8:	e00d      	b.n	800ac06 <SetupStoreCtxCallback+0x136>
 800abea:	68bb      	ldr	r3, [r7, #8]
 800abec:	681b      	ldr	r3, [r3, #0]
 800abee:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 800abf2:	2b00      	cmp	r3, #0
 800abf4:	d004      	beq.n	800ac00 <SetupStoreCtxCallback+0x130>
 800abf6:	68bb      	ldr	r3, [r7, #8]
 800abf8:	681b      	ldr	r3, [r3, #0]
 800abfa:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 800abfe:	e002      	b.n	800ac06 <SetupStoreCtxCallback+0x136>
 800ac00:	68bb      	ldr	r3, [r7, #8]
 800ac02:	681b      	ldr	r3, [r3, #0]
 800ac04:	33f4      	adds	r3, #244	@ 0xf4
 800ac06:	69ba      	ldr	r2, [r7, #24]
 800ac08:	6013      	str	r3, [r2, #0]
#if defined(OPENSSL_EXTRA)
        store->depth = args->count;
 800ac0a:	683b      	ldr	r3, [r7, #0]
 800ac0c:	699a      	ldr	r2, [r3, #24]
 800ac0e:	69bb      	ldr	r3, [r7, #24]
 800ac10:	61da      	str	r2, [r3, #28]
        /* Overwrite with non-default param values in SSL */
        if (ssl->param) {
 800ac12:	68bb      	ldr	r3, [r7, #8]
 800ac14:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800ac18:	2b00      	cmp	r3, #0
 800ac1a:	f000 80aa 	beq.w	800ad72 <SetupStoreCtxCallback+0x2a2>
            if (ssl->param->check_time)
 800ac1e:	68bb      	ldr	r3, [r7, #8]
 800ac20:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800ac24:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800ac28:	4313      	orrs	r3, r2
 800ac2a:	d008      	beq.n	800ac3e <SetupStoreCtxCallback+0x16e>
                store->param->check_time = ssl->param->check_time;
 800ac2c:	68bb      	ldr	r3, [r7, #8]
 800ac2e:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800ac32:	69ba      	ldr	r2, [r7, #24]
 800ac34:	6951      	ldr	r1, [r2, #20]
 800ac36:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800ac3a:	e9c1 2302 	strd	r2, r3, [r1, #8]

            if (ssl->param->flags)
 800ac3e:	68bb      	ldr	r3, [r7, #8]
 800ac40:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800ac44:	695b      	ldr	r3, [r3, #20]
 800ac46:	2b00      	cmp	r3, #0
 800ac48:	d007      	beq.n	800ac5a <SetupStoreCtxCallback+0x18a>
                store->param->flags = ssl->param->flags;
 800ac4a:	68bb      	ldr	r3, [r7, #8]
 800ac4c:	f8d3 2334 	ldr.w	r2, [r3, #820]	@ 0x334
 800ac50:	69bb      	ldr	r3, [r7, #24]
 800ac52:	695b      	ldr	r3, [r3, #20]
 800ac54:	6952      	ldr	r2, [r2, #20]
 800ac56:	615a      	str	r2, [r3, #20]
 800ac58:	e078      	b.n	800ad4c <SetupStoreCtxCallback+0x27c>
#ifdef WOLFSSL_LOCAL_X509_STORE
            else if (SSL_STORE(ssl) && SSL_STORE(ssl)->param &&
 800ac5a:	68bb      	ldr	r3, [r7, #8]
 800ac5c:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800ac60:	2b00      	cmp	r3, #0
 800ac62:	d008      	beq.n	800ac76 <SetupStoreCtxCallback+0x1a6>
 800ac64:	68bb      	ldr	r3, [r7, #8]
 800ac66:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800ac6a:	2b00      	cmp	r3, #0
 800ac6c:	bf14      	ite	ne
 800ac6e:	2301      	movne	r3, #1
 800ac70:	2300      	moveq	r3, #0
 800ac72:	b2db      	uxtb	r3, r3
 800ac74:	e017      	b.n	800aca6 <SetupStoreCtxCallback+0x1d6>
 800ac76:	68bb      	ldr	r3, [r7, #8]
 800ac78:	681b      	ldr	r3, [r3, #0]
 800ac7a:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 800ac7e:	2b00      	cmp	r3, #0
 800ac80:	d009      	beq.n	800ac96 <SetupStoreCtxCallback+0x1c6>
 800ac82:	68bb      	ldr	r3, [r7, #8]
 800ac84:	681b      	ldr	r3, [r3, #0]
 800ac86:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 800ac8a:	2b00      	cmp	r3, #0
 800ac8c:	bf14      	ite	ne
 800ac8e:	2301      	movne	r3, #1
 800ac90:	2300      	moveq	r3, #0
 800ac92:	b2db      	uxtb	r3, r3
 800ac94:	e007      	b.n	800aca6 <SetupStoreCtxCallback+0x1d6>
 800ac96:	68bb      	ldr	r3, [r7, #8]
 800ac98:	681b      	ldr	r3, [r3, #0]
 800ac9a:	33f4      	adds	r3, #244	@ 0xf4
 800ac9c:	2b00      	cmp	r3, #0
 800ac9e:	bf14      	ite	ne
 800aca0:	2301      	movne	r3, #1
 800aca2:	2300      	moveq	r3, #0
 800aca4:	b2db      	uxtb	r3, r3
 800aca6:	2b00      	cmp	r3, #0
 800aca8:	d050      	beq.n	800ad4c <SetupStoreCtxCallback+0x27c>
 800acaa:	68bb      	ldr	r3, [r7, #8]
 800acac:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800acb0:	2b00      	cmp	r3, #0
 800acb2:	d003      	beq.n	800acbc <SetupStoreCtxCallback+0x1ec>
 800acb4:	68bb      	ldr	r3, [r7, #8]
 800acb6:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800acba:	e00d      	b.n	800acd8 <SetupStoreCtxCallback+0x208>
 800acbc:	68bb      	ldr	r3, [r7, #8]
 800acbe:	681b      	ldr	r3, [r3, #0]
 800acc0:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 800acc4:	2b00      	cmp	r3, #0
 800acc6:	d004      	beq.n	800acd2 <SetupStoreCtxCallback+0x202>
 800acc8:	68bb      	ldr	r3, [r7, #8]
 800acca:	681b      	ldr	r3, [r3, #0]
 800accc:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 800acd0:	e002      	b.n	800acd8 <SetupStoreCtxCallback+0x208>
 800acd2:	68bb      	ldr	r3, [r7, #8]
 800acd4:	681b      	ldr	r3, [r3, #0]
 800acd6:	33f4      	adds	r3, #244	@ 0xf4
 800acd8:	699b      	ldr	r3, [r3, #24]
 800acda:	2b00      	cmp	r3, #0
 800acdc:	d036      	beq.n	800ad4c <SetupStoreCtxCallback+0x27c>
                    SSL_STORE(ssl)->param->flags)
 800acde:	68bb      	ldr	r3, [r7, #8]
 800ace0:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800ace4:	2b00      	cmp	r3, #0
 800ace6:	d003      	beq.n	800acf0 <SetupStoreCtxCallback+0x220>
 800ace8:	68bb      	ldr	r3, [r7, #8]
 800acea:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800acee:	e00d      	b.n	800ad0c <SetupStoreCtxCallback+0x23c>
 800acf0:	68bb      	ldr	r3, [r7, #8]
 800acf2:	681b      	ldr	r3, [r3, #0]
 800acf4:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 800acf8:	2b00      	cmp	r3, #0
 800acfa:	d004      	beq.n	800ad06 <SetupStoreCtxCallback+0x236>
 800acfc:	68bb      	ldr	r3, [r7, #8]
 800acfe:	681b      	ldr	r3, [r3, #0]
 800ad00:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 800ad04:	e002      	b.n	800ad0c <SetupStoreCtxCallback+0x23c>
 800ad06:	68bb      	ldr	r3, [r7, #8]
 800ad08:	681b      	ldr	r3, [r3, #0]
 800ad0a:	33f4      	adds	r3, #244	@ 0xf4
 800ad0c:	699b      	ldr	r3, [r3, #24]
 800ad0e:	695b      	ldr	r3, [r3, #20]
            else if (SSL_STORE(ssl) && SSL_STORE(ssl)->param &&
 800ad10:	2b00      	cmp	r3, #0
 800ad12:	d01b      	beq.n	800ad4c <SetupStoreCtxCallback+0x27c>
                store->param->flags = SSL_STORE(ssl)->param->flags;
 800ad14:	68bb      	ldr	r3, [r7, #8]
 800ad16:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800ad1a:	2b00      	cmp	r3, #0
 800ad1c:	d003      	beq.n	800ad26 <SetupStoreCtxCallback+0x256>
 800ad1e:	68bb      	ldr	r3, [r7, #8]
 800ad20:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800ad24:	e00d      	b.n	800ad42 <SetupStoreCtxCallback+0x272>
 800ad26:	68bb      	ldr	r3, [r7, #8]
 800ad28:	681b      	ldr	r3, [r3, #0]
 800ad2a:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 800ad2e:	2b00      	cmp	r3, #0
 800ad30:	d004      	beq.n	800ad3c <SetupStoreCtxCallback+0x26c>
 800ad32:	68bb      	ldr	r3, [r7, #8]
 800ad34:	681b      	ldr	r3, [r3, #0]
 800ad36:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 800ad3a:	e002      	b.n	800ad42 <SetupStoreCtxCallback+0x272>
 800ad3c:	68bb      	ldr	r3, [r7, #8]
 800ad3e:	681b      	ldr	r3, [r3, #0]
 800ad40:	33f4      	adds	r3, #244	@ 0xf4
 800ad42:	699a      	ldr	r2, [r3, #24]
 800ad44:	69bb      	ldr	r3, [r7, #24]
 800ad46:	695b      	ldr	r3, [r3, #20]
 800ad48:	6952      	ldr	r2, [r2, #20]
 800ad4a:	615a      	str	r2, [r3, #20]
#endif


            if (ssl->param->hostName[0])
 800ad4c:	68bb      	ldr	r3, [r7, #8]
 800ad4e:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800ad52:	7e1b      	ldrb	r3, [r3, #24]
 800ad54:	2b00      	cmp	r3, #0
 800ad56:	d00c      	beq.n	800ad72 <SetupStoreCtxCallback+0x2a2>
                XMEMCPY(store->param->hostName, ssl->param->hostName,
 800ad58:	69bb      	ldr	r3, [r7, #24]
 800ad5a:	695b      	ldr	r3, [r3, #20]
 800ad5c:	f103 0018 	add.w	r0, r3, #24
 800ad60:	68bb      	ldr	r3, [r7, #8]
 800ad62:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800ad66:	3318      	adds	r3, #24
 800ad68:	f44f 7280 	mov.w	r2, #256	@ 0x100
 800ad6c:	4619      	mov	r1, r3
 800ad6e:	f01d fc15 	bl	802859c <memcpy>
        }
#endif /* defined(OPENSSL_EXTRA) */
#endif /* defined(OPENSSL_EXTRA) || defined(HAVE_WEBSERVER)*/
#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
    #ifdef KEEP_PEER_CERT
        if (args->certIdx == 0) {
 800ad72:	683b      	ldr	r3, [r7, #0]
 800ad74:	69db      	ldr	r3, [r3, #28]
 800ad76:	2b00      	cmp	r3, #0
 800ad78:	d11e      	bne.n	800adb8 <SetupStoreCtxCallback+0x2e8>
            FreeX509(&ssl->peerCert);
 800ad7a:	68bb      	ldr	r3, [r7, #8]
 800ad7c:	f503 736f 	add.w	r3, r3, #956	@ 0x3bc
 800ad80:	4618      	mov	r0, r3
 800ad82:	f7fe fc0a 	bl	800959a <FreeX509>
            InitX509(&ssl->peerCert, 0, ssl->heap);
 800ad86:	68bb      	ldr	r3, [r7, #8]
 800ad88:	f503 706f 	add.w	r0, r3, #956	@ 0x3bc
 800ad8c:	68bb      	ldr	r3, [r7, #8]
 800ad8e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800ad92:	461a      	mov	r2, r3
 800ad94:	2100      	movs	r1, #0
 800ad96:	f7fe fbcd 	bl	8009534 <InitX509>
            if (CopyDecodedToX509(&ssl->peerCert, args->dCert) == 0)
 800ad9a:	68bb      	ldr	r3, [r7, #8]
 800ad9c:	f503 726f 	add.w	r2, r3, #956	@ 0x3bc
 800ada0:	683b      	ldr	r3, [r7, #0]
 800ada2:	689b      	ldr	r3, [r3, #8]
 800ada4:	4619      	mov	r1, r3
 800ada6:	4610      	mov	r0, r2
 800ada8:	f7ff fa75 	bl	800a296 <CopyDecodedToX509>
                WOLFSSL_MSG("Unable to copy to ssl->peerCert");
            store->current_cert = &ssl->peerCert; /* use existing X509 */
 800adac:	68bb      	ldr	r3, [r7, #8]
 800adae:	f503 726f 	add.w	r2, r3, #956	@ 0x3bc
 800adb2:	69bb      	ldr	r3, [r7, #24]
 800adb4:	605a      	str	r2, [r3, #4]
 800adb6:	e015      	b.n	800ade4 <SetupStoreCtxCallback+0x314>
        }
        else
    #endif
        {
            x509 = wolfSSL_X509_new_ex(heap);
 800adb8:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 800adba:	f003 fbc6 	bl	800e54a <wolfSSL_X509_new_ex>
 800adbe:	6238      	str	r0, [r7, #32]
            if (x509 == NULL)
 800adc0:	6a3b      	ldr	r3, [r7, #32]
 800adc2:	2b00      	cmp	r3, #0
 800adc4:	d017      	beq.n	800adf6 <SetupStoreCtxCallback+0x326>
                goto mem_error;
            if (CopyDecodedToX509(x509, args->dCert) == 0) {
 800adc6:	683b      	ldr	r3, [r7, #0]
 800adc8:	689b      	ldr	r3, [r3, #8]
 800adca:	4619      	mov	r1, r3
 800adcc:	6a38      	ldr	r0, [r7, #32]
 800adce:	f7ff fa62 	bl	800a296 <CopyDecodedToX509>
 800add2:	4603      	mov	r3, r0
 800add4:	2b00      	cmp	r3, #0
 800add6:	d110      	bne.n	800adfa <SetupStoreCtxCallback+0x32a>
                store->current_cert = x509;
 800add8:	69bb      	ldr	r3, [r7, #24]
 800adda:	6a3a      	ldr	r2, [r7, #32]
 800addc:	605a      	str	r2, [r3, #4]
                *x509Free = 1;
 800adde:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800ade0:	2201      	movs	r2, #1
 800ade2:	601a      	str	r2, [r3, #0]
#endif
#ifdef SESSION_CERTS
        store->sesChain = &ssl->session->chain;
#endif
    }
    *store_pt = store;
 800ade4:	68fb      	ldr	r3, [r7, #12]
 800ade6:	69ba      	ldr	r2, [r7, #24]
 800ade8:	601a      	str	r2, [r3, #0]
    return 0;
 800adea:	2300      	movs	r3, #0
 800adec:	e01c      	b.n	800ae28 <SetupStoreCtxCallback+0x358>
        goto mem_error;
 800adee:	bf00      	nop
 800adf0:	e004      	b.n	800adfc <SetupStoreCtxCallback+0x32c>
        goto mem_error;
 800adf2:	bf00      	nop
 800adf4:	e002      	b.n	800adfc <SetupStoreCtxCallback+0x32c>
                goto mem_error;
 800adf6:	bf00      	nop
 800adf8:	e000      	b.n	800adfc <SetupStoreCtxCallback+0x32c>
                goto mem_error;
 800adfa:	bf00      	nop
mem_error:
    if (store != NULL)
 800adfc:	69bb      	ldr	r3, [r7, #24]
 800adfe:	2b00      	cmp	r3, #0
 800ae00:	d002      	beq.n	800ae08 <SetupStoreCtxCallback+0x338>
        wolfSSL_X509_STORE_CTX_free(store);
 800ae02:	69b8      	ldr	r0, [r7, #24]
 800ae04:	f004 f8cc 	bl	800efa0 <wolfSSL_X509_STORE_CTX_free>
#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
    if (x509 != NULL)
 800ae08:	6a3b      	ldr	r3, [r7, #32]
 800ae0a:	2b00      	cmp	r3, #0
 800ae0c:	d002      	beq.n	800ae14 <SetupStoreCtxCallback+0x344>
        wolfSSL_X509_free(x509);
 800ae0e:	6a38      	ldr	r0, [r7, #32]
 800ae10:	f003 fa99 	bl	800e346 <wolfSSL_X509_free>
#endif
    XFREE(domain, heap, DYNAMIC_TYPE_STRING);
 800ae14:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800ae16:	617b      	str	r3, [r7, #20]
 800ae18:	697b      	ldr	r3, [r7, #20]
 800ae1a:	2b00      	cmp	r3, #0
 800ae1c:	d002      	beq.n	800ae24 <SetupStoreCtxCallback+0x354>
 800ae1e:	6978      	ldr	r0, [r7, #20]
 800ae20:	f013 fe4e 	bl	801eac0 <wolfSSL_Free>
    return MEMORY_E;
 800ae24:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
}
 800ae28:	4618      	mov	r0, r3
 800ae2a:	3728      	adds	r7, #40	@ 0x28
 800ae2c:	46bd      	mov	sp, r7
 800ae2e:	bd80      	pop	{r7, pc}

0800ae30 <CleanupStoreCtxCallback>:

void CleanupStoreCtxCallback(WOLFSSL_X509_STORE_CTX* store,
        WOLFSSL* ssl, void* heap, int x509Free)
{
 800ae30:	b580      	push	{r7, lr}
 800ae32:	b086      	sub	sp, #24
 800ae34:	af00      	add	r7, sp, #0
 800ae36:	60f8      	str	r0, [r7, #12]
 800ae38:	60b9      	str	r1, [r7, #8]
 800ae3a:	607a      	str	r2, [r7, #4]
 800ae3c:	603b      	str	r3, [r7, #0]
    #ifdef WOLFSSL_ALT_CERT_CHAINS
        ssl->session->altChain.count = 0;
    #endif
    }
#endif /* SESSION_CERTS */
    XFREE(store->domain, heap, DYNAMIC_TYPE_STRING);
 800ae3e:	68fb      	ldr	r3, [r7, #12]
 800ae40:	699b      	ldr	r3, [r3, #24]
 800ae42:	617b      	str	r3, [r7, #20]
 800ae44:	697b      	ldr	r3, [r7, #20]
 800ae46:	2b00      	cmp	r3, #0
 800ae48:	d002      	beq.n	800ae50 <CleanupStoreCtxCallback+0x20>
 800ae4a:	6978      	ldr	r0, [r7, #20]
 800ae4c:	f013 fe38 	bl	801eac0 <wolfSSL_Free>
    store->domain = NULL;
 800ae50:	68fb      	ldr	r3, [r7, #12]
 800ae52:	2200      	movs	r2, #0
 800ae54:	619a      	str	r2, [r3, #24]
#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
    if (x509Free)
 800ae56:	683b      	ldr	r3, [r7, #0]
 800ae58:	2b00      	cmp	r3, #0
 800ae5a:	d004      	beq.n	800ae66 <CleanupStoreCtxCallback+0x36>
        wolfSSL_X509_free(store->current_cert);
 800ae5c:	68fb      	ldr	r3, [r7, #12]
 800ae5e:	685b      	ldr	r3, [r3, #4]
 800ae60:	4618      	mov	r0, r3
 800ae62:	f003 fa70 	bl	800e346 <wolfSSL_X509_free>
    store->current_cert = NULL;
 800ae66:	68fb      	ldr	r3, [r7, #12]
 800ae68:	2200      	movs	r2, #0
 800ae6a:	605a      	str	r2, [r3, #4]
#endif
    wolfSSL_X509_STORE_CTX_free(store);
 800ae6c:	68f8      	ldr	r0, [r7, #12]
 800ae6e:	f004 f897 	bl	800efa0 <wolfSSL_X509_STORE_CTX_free>
}
 800ae72:	bf00      	nop
 800ae74:	3718      	adds	r7, #24
 800ae76:	46bd      	mov	sp, r7
 800ae78:	bd80      	pop	{r7, pc}
	...

0800ae7c <DoVerifyCallback>:
 * store->error_depth member to determine index (0=peer, >1 intermediates)
 */

int DoVerifyCallback(WOLFSSL_CERT_MANAGER* cm, WOLFSSL* ssl, int cert_err,
                                                        ProcPeerCertArgs* args)
{
 800ae7c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ae7e:	b091      	sub	sp, #68	@ 0x44
 800ae80:	af04      	add	r7, sp, #16
 800ae82:	60f8      	str	r0, [r7, #12]
 800ae84:	60b9      	str	r1, [r7, #8]
 800ae86:	607a      	str	r2, [r7, #4]
 800ae88:	603b      	str	r3, [r7, #0]
    int verify_ok = 0, use_cb = 0, ret = cert_err;
 800ae8a:	2300      	movs	r3, #0
 800ae8c:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800ae8e:	2300      	movs	r3, #0
 800ae90:	62bb      	str	r3, [r7, #40]	@ 0x28
 800ae92:	687b      	ldr	r3, [r7, #4]
 800ae94:	627b      	str	r3, [r7, #36]	@ 0x24
    void *heap;

    if (cm == NULL) {
 800ae96:	68fb      	ldr	r3, [r7, #12]
 800ae98:	2b00      	cmp	r3, #0
 800ae9a:	d102      	bne.n	800aea2 <DoVerifyCallback+0x26>
        return BAD_FUNC_ARG;
 800ae9c:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800aea0:	e139      	b.n	800b116 <DoVerifyCallback+0x29a>
    }

    heap = (ssl != NULL) ? ssl->heap : cm->heap;
 800aea2:	68bb      	ldr	r3, [r7, #8]
 800aea4:	2b00      	cmp	r3, #0
 800aea6:	d003      	beq.n	800aeb0 <DoVerifyCallback+0x34>
 800aea8:	68bb      	ldr	r3, [r7, #8]
 800aeaa:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800aeae:	e001      	b.n	800aeb4 <DoVerifyCallback+0x38>
 800aeb0:	68fb      	ldr	r3, [r7, #12]
 800aeb2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800aeb4:	61fb      	str	r3, [r7, #28]

    /* Determine if verify was okay */
    if (cert_err == 0) {
 800aeb6:	687b      	ldr	r3, [r7, #4]
 800aeb8:	2b00      	cmp	r3, #0
 800aeba:	d101      	bne.n	800aec0 <DoVerifyCallback+0x44>
        verify_ok = 1;
 800aebc:	2301      	movs	r3, #1
 800aebe:	62fb      	str	r3, [r7, #44]	@ 0x2c
    }

    /* Determine if verify callback should be used */
    if (cert_err != 0) {
 800aec0:	687b      	ldr	r3, [r7, #4]
 800aec2:	2b00      	cmp	r3, #0
 800aec4:	d00c      	beq.n	800aee0 <DoVerifyCallback+0x64>
        if ((ssl != NULL) && (!ssl->options.verifyNone)) {
 800aec6:	68bb      	ldr	r3, [r7, #8]
 800aec8:	2b00      	cmp	r3, #0
 800aeca:	d009      	beq.n	800aee0 <DoVerifyCallback+0x64>
 800aecc:	68bb      	ldr	r3, [r7, #8]
 800aece:	f893 32d1 	ldrb.w	r3, [r3, #721]	@ 0x2d1
 800aed2:	f003 0308 	and.w	r3, r3, #8
 800aed6:	b2db      	uxtb	r3, r3
 800aed8:	2b00      	cmp	r3, #0
 800aeda:	d101      	bne.n	800aee0 <DoVerifyCallback+0x64>
            use_cb = 1; /* always report errors */
 800aedc:	2301      	movs	r3, #1
 800aede:	62bb      	str	r3, [r7, #40]	@ 0x28
        }
    }
#ifdef WOLFSSL_ALWAYS_VERIFY_CB
    /* always use verify callback on peer leaf cert */
    if (args->certIdx == 0) {
 800aee0:	683b      	ldr	r3, [r7, #0]
 800aee2:	69db      	ldr	r3, [r3, #28]
 800aee4:	2b00      	cmp	r3, #0
 800aee6:	d101      	bne.n	800aeec <DoVerifyCallback+0x70>
        use_cb = 1;
 800aee8:	2301      	movs	r3, #1
 800aeea:	62bb      	str	r3, [r7, #40]	@ 0x28
    }
#endif
#ifdef WOLFSSL_VERIFY_CB_ALL_CERTS
    /* perform verify callback on other intermediate certs (not just peer) */
    if (args->certIdx > 0) {
 800aeec:	683b      	ldr	r3, [r7, #0]
 800aeee:	69db      	ldr	r3, [r3, #28]
 800aef0:	2b00      	cmp	r3, #0
 800aef2:	dd01      	ble.n	800aef8 <DoVerifyCallback+0x7c>
        use_cb = 1;
 800aef4:	2301      	movs	r3, #1
 800aef6:	62bb      	str	r3, [r7, #40]	@ 0x28
    }
#endif
#if defined(OPENSSL_EXTRA)
    /* Perform domain and IP check only for the leaf certificate */
    if (args->certIdx == 0) {
 800aef8:	683b      	ldr	r3, [r7, #0]
 800aefa:	69db      	ldr	r3, [r3, #28]
 800aefc:	2b00      	cmp	r3, #0
 800aefe:	f040 8098 	bne.w	800b032 <DoVerifyCallback+0x1b6>
        /* perform domain name check on the peer certificate */
        if (args->dCertInit && args->dCert && (ssl != NULL) &&
 800af02:	683b      	ldr	r3, [r7, #0]
 800af04:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 800af08:	f003 0304 	and.w	r3, r3, #4
 800af0c:	b2db      	uxtb	r3, r3
 800af0e:	2b00      	cmp	r3, #0
 800af10:	d05f      	beq.n	800afd2 <DoVerifyCallback+0x156>
 800af12:	683b      	ldr	r3, [r7, #0]
 800af14:	689b      	ldr	r3, [r3, #8]
 800af16:	2b00      	cmp	r3, #0
 800af18:	d05b      	beq.n	800afd2 <DoVerifyCallback+0x156>
 800af1a:	68bb      	ldr	r3, [r7, #8]
 800af1c:	2b00      	cmp	r3, #0
 800af1e:	d058      	beq.n	800afd2 <DoVerifyCallback+0x156>
                ssl->param && ssl->param->hostName[0]) {
 800af20:	68bb      	ldr	r3, [r7, #8]
 800af22:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
        if (args->dCertInit && args->dCert && (ssl != NULL) &&
 800af26:	2b00      	cmp	r3, #0
 800af28:	d053      	beq.n	800afd2 <DoVerifyCallback+0x156>
                ssl->param && ssl->param->hostName[0]) {
 800af2a:	68bb      	ldr	r3, [r7, #8]
 800af2c:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800af30:	7e1b      	ldrb	r3, [r3, #24]
 800af32:	2b00      	cmp	r3, #0
 800af34:	d04d      	beq.n	800afd2 <DoVerifyCallback+0x156>
            /* If altNames names is present, then subject common name is ignored */
            if (args->dCert->altNames != NULL) {
 800af36:	683b      	ldr	r3, [r7, #0]
 800af38:	689b      	ldr	r3, [r3, #8]
 800af3a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800af3c:	2b00      	cmp	r3, #0
 800af3e:	d01e      	beq.n	800af7e <DoVerifyCallback+0x102>
                if (CheckForAltNames(args->dCert, ssl->param->hostName,
 800af40:	683b      	ldr	r3, [r7, #0]
 800af42:	689c      	ldr	r4, [r3, #8]
 800af44:	68bb      	ldr	r3, [r7, #8]
 800af46:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800af4a:	f103 0518 	add.w	r5, r3, #24
                    (word32)XSTRLEN(ssl->param->hostName), NULL, 0) != 1) {
 800af4e:	68bb      	ldr	r3, [r7, #8]
 800af50:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800af54:	3318      	adds	r3, #24
 800af56:	4618      	mov	r0, r3
 800af58:	f7f5 f944 	bl	80001e4 <strlen>
 800af5c:	4602      	mov	r2, r0
                if (CheckForAltNames(args->dCert, ssl->param->hostName,
 800af5e:	2300      	movs	r3, #0
 800af60:	9300      	str	r3, [sp, #0]
 800af62:	2300      	movs	r3, #0
 800af64:	4629      	mov	r1, r5
 800af66:	4620      	mov	r0, r4
 800af68:	f7ff f866 	bl	800a038 <CheckForAltNames>
 800af6c:	4603      	mov	r3, r0
 800af6e:	2b01      	cmp	r3, #1
 800af70:	d02f      	beq.n	800afd2 <DoVerifyCallback+0x156>
                    if (cert_err == 0) {
 800af72:	687b      	ldr	r3, [r7, #4]
 800af74:	2b00      	cmp	r3, #0
 800af76:	d12c      	bne.n	800afd2 <DoVerifyCallback+0x156>
                        ret = DOMAIN_NAME_MISMATCH;
 800af78:	4b69      	ldr	r3, [pc, #420]	@ (800b120 <DoVerifyCallback+0x2a4>)
 800af7a:	627b      	str	r3, [r7, #36]	@ 0x24
 800af7c:	e029      	b.n	800afd2 <DoVerifyCallback+0x156>
                    }
                }
            }
        #ifndef WOLFSSL_HOSTNAME_VERIFY_ALT_NAME_ONLY
            else {
                if (args->dCert->subjectCN) {
 800af7e:	683b      	ldr	r3, [r7, #0]
 800af80:	689b      	ldr	r3, [r3, #8]
 800af82:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800af86:	2b00      	cmp	r3, #0
 800af88:	d023      	beq.n	800afd2 <DoVerifyCallback+0x156>
                    if (MatchDomainName(
                            args->dCert->subjectCN,
 800af8a:	683b      	ldr	r3, [r7, #0]
 800af8c:	689b      	ldr	r3, [r3, #8]
 800af8e:	f8d3 4084 	ldr.w	r4, [r3, #132]	@ 0x84
                            args->dCert->subjectCNLen,
 800af92:	683b      	ldr	r3, [r7, #0]
 800af94:	689b      	ldr	r3, [r3, #8]
                    if (MatchDomainName(
 800af96:	f8d3 5088 	ldr.w	r5, [r3, #136]	@ 0x88
                            ssl->param->hostName,
 800af9a:	68bb      	ldr	r3, [r7, #8]
 800af9c:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800afa0:	f103 0618 	add.w	r6, r3, #24
                            (word32)XSTRLEN(ssl->param->hostName), 0) == 0) {
 800afa4:	68bb      	ldr	r3, [r7, #8]
 800afa6:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800afaa:	3318      	adds	r3, #24
 800afac:	4618      	mov	r0, r3
 800afae:	f7f5 f919 	bl	80001e4 <strlen>
 800afb2:	4603      	mov	r3, r0
                    if (MatchDomainName(
 800afb4:	2200      	movs	r2, #0
 800afb6:	9200      	str	r2, [sp, #0]
 800afb8:	4632      	mov	r2, r6
 800afba:	4629      	mov	r1, r5
 800afbc:	4620      	mov	r0, r4
 800afbe:	f7fe ff57 	bl	8009e70 <MatchDomainName>
 800afc2:	4603      	mov	r3, r0
 800afc4:	2b00      	cmp	r3, #0
 800afc6:	d104      	bne.n	800afd2 <DoVerifyCallback+0x156>
                        if (cert_err == 0) {
 800afc8:	687b      	ldr	r3, [r7, #4]
 800afca:	2b00      	cmp	r3, #0
 800afcc:	d101      	bne.n	800afd2 <DoVerifyCallback+0x156>
                            ret = DOMAIN_NAME_MISMATCH;
 800afce:	4b54      	ldr	r3, [pc, #336]	@ (800b120 <DoVerifyCallback+0x2a4>)
 800afd0:	627b      	str	r3, [r7, #36]	@ 0x24
            }
        #endif /* !WOLFSSL_HOSTNAME_VERIFY_ALT_NAME_ONLY */
        }

        /* perform IP address check on the peer certificate */
        if ((args->dCertInit != 0) && (args->dCert != NULL) && (ssl != NULL) &&
 800afd2:	683b      	ldr	r3, [r7, #0]
 800afd4:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 800afd8:	f003 0304 	and.w	r3, r3, #4
 800afdc:	b2db      	uxtb	r3, r3
 800afde:	2b00      	cmp	r3, #0
 800afe0:	d027      	beq.n	800b032 <DoVerifyCallback+0x1b6>
 800afe2:	683b      	ldr	r3, [r7, #0]
 800afe4:	689b      	ldr	r3, [r3, #8]
 800afe6:	2b00      	cmp	r3, #0
 800afe8:	d023      	beq.n	800b032 <DoVerifyCallback+0x1b6>
 800afea:	68bb      	ldr	r3, [r7, #8]
 800afec:	2b00      	cmp	r3, #0
 800afee:	d020      	beq.n	800b032 <DoVerifyCallback+0x1b6>
            (ssl->param != NULL) && (XSTRLEN(ssl->param->ipasc) > 0)) {
 800aff0:	68bb      	ldr	r3, [r7, #8]
 800aff2:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
        if ((args->dCertInit != 0) && (args->dCert != NULL) && (ssl != NULL) &&
 800aff6:	2b00      	cmp	r3, #0
 800aff8:	d01b      	beq.n	800b032 <DoVerifyCallback+0x1b6>
            (ssl->param != NULL) && (XSTRLEN(ssl->param->ipasc) > 0)) {
 800affa:	68bb      	ldr	r3, [r7, #8]
 800affc:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800b000:	f503 738e 	add.w	r3, r3, #284	@ 0x11c
 800b004:	781b      	ldrb	r3, [r3, #0]
 800b006:	2b00      	cmp	r3, #0
 800b008:	d013      	beq.n	800b032 <DoVerifyCallback+0x1b6>
            if (CheckIPAddr(args->dCert, ssl->param->ipasc) != 0) {
 800b00a:	683b      	ldr	r3, [r7, #0]
 800b00c:	689a      	ldr	r2, [r3, #8]
 800b00e:	68bb      	ldr	r3, [r7, #8]
 800b010:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800b014:	f503 738e 	add.w	r3, r3, #284	@ 0x11c
 800b018:	4619      	mov	r1, r3
 800b01a:	4610      	mov	r0, r2
 800b01c:	f7ff f898 	bl	800a150 <CheckIPAddr>
 800b020:	4603      	mov	r3, r0
 800b022:	2b00      	cmp	r3, #0
 800b024:	d005      	beq.n	800b032 <DoVerifyCallback+0x1b6>
                if (cert_err == 0) {
 800b026:	687b      	ldr	r3, [r7, #4]
 800b028:	2b00      	cmp	r3, #0
 800b02a:	d102      	bne.n	800b032 <DoVerifyCallback+0x1b6>
                    ret = IPADDR_MISMATCH;
 800b02c:	f46f 73a2 	mvn.w	r3, #324	@ 0x144
 800b030:	627b      	str	r3, [r7, #36]	@ 0x24
            }
        }
    }
#endif
    /* if verify callback has been set */
    if ((use_cb && (ssl != NULL) && ((ssl->verifyCallback != NULL)
 800b032:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800b034:	2b00      	cmp	r3, #0
 800b036:	d007      	beq.n	800b048 <DoVerifyCallback+0x1cc>
 800b038:	68bb      	ldr	r3, [r7, #8]
 800b03a:	2b00      	cmp	r3, #0
 800b03c:	d004      	beq.n	800b048 <DoVerifyCallback+0x1cc>
 800b03e:	68bb      	ldr	r3, [r7, #8]
 800b040:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800b044:	2b00      	cmp	r3, #0
 800b046:	d103      	bne.n	800b050 <DoVerifyCallback+0x1d4>
        (defined(OPENSSL_ALL) || defined(WOLFSSL_QT))
        || (SSL_STORE(ssl) != NULL && SSL_STORE(ssl)->verify_cb != NULL)
    #endif
        ))
    #ifndef NO_WOLFSSL_CM_VERIFY
        || (cm->verifyCallback != NULL)
 800b048:	68fb      	ldr	r3, [r7, #12]
 800b04a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800b04c:	2b00      	cmp	r3, #0
 800b04e:	d061      	beq.n	800b114 <DoVerifyCallback+0x298>
    #endif
        ) {
        int verifyFail = 0;
 800b050:	2300      	movs	r3, #0
 800b052:	623b      	str	r3, [r7, #32]
        WOLFSSL_X509_STORE_CTX* store = NULL;
 800b054:	2300      	movs	r3, #0
 800b056:	617b      	str	r3, [r7, #20]
        int x509Free = 0;
 800b058:	2300      	movs	r3, #0
 800b05a:	613b      	str	r3, [r7, #16]
        int setupRet = SetupStoreCtxCallback(&store, ssl, cm, args, cert_err,
 800b05c:	f107 0014 	add.w	r0, r7, #20
 800b060:	f107 0310 	add.w	r3, r7, #16
 800b064:	9302      	str	r3, [sp, #8]
 800b066:	69fb      	ldr	r3, [r7, #28]
 800b068:	9301      	str	r3, [sp, #4]
 800b06a:	687b      	ldr	r3, [r7, #4]
 800b06c:	9300      	str	r3, [sp, #0]
 800b06e:	683b      	ldr	r3, [r7, #0]
 800b070:	68fa      	ldr	r2, [r7, #12]
 800b072:	68b9      	ldr	r1, [r7, #8]
 800b074:	f7ff fd2c 	bl	800aad0 <SetupStoreCtxCallback>
 800b078:	61b8      	str	r0, [r7, #24]
                heap, &x509Free);

        if (setupRet != 0)
 800b07a:	69bb      	ldr	r3, [r7, #24]
 800b07c:	2b00      	cmp	r3, #0
 800b07e:	d001      	beq.n	800b084 <DoVerifyCallback+0x208>
            return setupRet;
 800b080:	69bb      	ldr	r3, [r7, #24]
 800b082:	e048      	b.n	800b116 <DoVerifyCallback+0x29a>

    #ifndef NO_WOLFSSL_CM_VERIFY
        /* non-zero return code indicates failure override */
        if (cm->verifyCallback != NULL) {
 800b084:	68fb      	ldr	r3, [r7, #12]
 800b086:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800b088:	2b00      	cmp	r3, #0
 800b08a:	d013      	beq.n	800b0b4 <DoVerifyCallback+0x238>
            store->userCtx = cm;
 800b08c:	697b      	ldr	r3, [r7, #20]
 800b08e:	68fa      	ldr	r2, [r7, #12]
 800b090:	621a      	str	r2, [r3, #32]
            if (cm->verifyCallback(verify_ok, store)) {
 800b092:	68fb      	ldr	r3, [r7, #12]
 800b094:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800b096:	697a      	ldr	r2, [r7, #20]
 800b098:	4611      	mov	r1, r2
 800b09a:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 800b09c:	4798      	blx	r3
 800b09e:	4603      	mov	r3, r0
 800b0a0:	2b00      	cmp	r3, #0
 800b0a2:	d005      	beq.n	800b0b0 <DoVerifyCallback+0x234>
                if (cert_err != 0) {
 800b0a4:	687b      	ldr	r3, [r7, #4]
 800b0a6:	2b00      	cmp	r3, #0
 800b0a8:	d004      	beq.n	800b0b4 <DoVerifyCallback+0x238>
                    WOLFSSL_MSG("Verify CM callback overriding error!");
                    ret = 0;
 800b0aa:	2300      	movs	r3, #0
 800b0ac:	627b      	str	r3, [r7, #36]	@ 0x24
 800b0ae:	e001      	b.n	800b0b4 <DoVerifyCallback+0x238>
                }
            }
            else {
                verifyFail = 1;
 800b0b0:	2301      	movs	r3, #1
 800b0b2:	623b      	str	r3, [r7, #32]
            }
        }
    #endif

        if (ssl != NULL) {
 800b0b4:	68bb      	ldr	r3, [r7, #8]
 800b0b6:	2b00      	cmp	r3, #0
 800b0b8:	d016      	beq.n	800b0e8 <DoVerifyCallback+0x26c>
                    verifyFail = 1;
                }
            }
    #endif
            /* non-zero return code indicates failure override */
            if (ssl->verifyCallback) {
 800b0ba:	68bb      	ldr	r3, [r7, #8]
 800b0bc:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800b0c0:	2b00      	cmp	r3, #0
 800b0c2:	d011      	beq.n	800b0e8 <DoVerifyCallback+0x26c>
                if (ssl->verifyCallback(verify_ok, store)) {
 800b0c4:	68bb      	ldr	r3, [r7, #8]
 800b0c6:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800b0ca:	697a      	ldr	r2, [r7, #20]
 800b0cc:	4611      	mov	r1, r2
 800b0ce:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 800b0d0:	4798      	blx	r3
 800b0d2:	4603      	mov	r3, r0
 800b0d4:	2b00      	cmp	r3, #0
 800b0d6:	d005      	beq.n	800b0e4 <DoVerifyCallback+0x268>
                    if (cert_err != 0) {
 800b0d8:	687b      	ldr	r3, [r7, #4]
 800b0da:	2b00      	cmp	r3, #0
 800b0dc:	d004      	beq.n	800b0e8 <DoVerifyCallback+0x26c>
                        WOLFSSL_MSG("Verify callback overriding error!");
                        ret = 0;
 800b0de:	2300      	movs	r3, #0
 800b0e0:	627b      	str	r3, [r7, #36]	@ 0x24
 800b0e2:	e001      	b.n	800b0e8 <DoVerifyCallback+0x26c>
                    }
                }
                else {
                    verifyFail = 1;
 800b0e4:	2301      	movs	r3, #1
 800b0e6:	623b      	str	r3, [r7, #32]
                }
            }
#endif
        }

        if (verifyFail) {
 800b0e8:	6a3b      	ldr	r3, [r7, #32]
 800b0ea:	2b00      	cmp	r3, #0
 800b0ec:	d00c      	beq.n	800b108 <DoVerifyCallback+0x28c>
            /* induce error if one not present */
            if (cert_err == 0) {
 800b0ee:	687b      	ldr	r3, [r7, #4]
 800b0f0:	2b00      	cmp	r3, #0
 800b0f2:	d102      	bne.n	800b0fa <DoVerifyCallback+0x27e>
                ret = VERIFY_CERT_ERROR;
 800b0f4:	f46f 73a4 	mvn.w	r3, #328	@ 0x148
 800b0f8:	627b      	str	r3, [r7, #36]	@ 0x24
                WOLFSSL_ERROR_VERBOSE(ret);
            }

            /* mark as verify error */
            args->verifyErr = 1;
 800b0fa:	683a      	ldr	r2, [r7, #0]
 800b0fc:	f892 3026 	ldrb.w	r3, [r2, #38]	@ 0x26
 800b100:	f043 0302 	orr.w	r3, r3, #2
 800b104:	f882 3026 	strb.w	r3, [r2, #38]	@ 0x26
        }
        CleanupStoreCtxCallback(store, ssl, heap, x509Free);
 800b108:	6978      	ldr	r0, [r7, #20]
 800b10a:	693b      	ldr	r3, [r7, #16]
 800b10c:	69fa      	ldr	r2, [r7, #28]
 800b10e:	68b9      	ldr	r1, [r7, #8]
 800b110:	f7ff fe8e 	bl	800ae30 <CleanupStoreCtxCallback>
    }

    (void)heap;

    return ret;
 800b114:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 800b116:	4618      	mov	r0, r3
 800b118:	3734      	adds	r7, #52	@ 0x34
 800b11a:	46bd      	mov	sp, r7
 800b11c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800b11e:	bf00      	nop
 800b120:	fffffebe 	.word	0xfffffebe

0800b124 <wolfSSL_Atomic_Int_FetchSub>:
    static WC_INLINE int wolfSSL_Atomic_Int_FetchSub(int *c, int i) {
 800b124:	b480      	push	{r7}
 800b126:	b085      	sub	sp, #20
 800b128:	af00      	add	r7, sp, #0
 800b12a:	6078      	str	r0, [r7, #4]
 800b12c:	6039      	str	r1, [r7, #0]
        int ret = *c;
 800b12e:	687b      	ldr	r3, [r7, #4]
 800b130:	681b      	ldr	r3, [r3, #0]
 800b132:	60fb      	str	r3, [r7, #12]
        *c -= i;
 800b134:	687b      	ldr	r3, [r7, #4]
 800b136:	681a      	ldr	r2, [r3, #0]
 800b138:	683b      	ldr	r3, [r7, #0]
 800b13a:	1ad2      	subs	r2, r2, r3
 800b13c:	687b      	ldr	r3, [r7, #4]
 800b13e:	601a      	str	r2, [r3, #0]
        return ret;
 800b140:	68fb      	ldr	r3, [r7, #12]
    }
 800b142:	4618      	mov	r0, r3
 800b144:	3714      	adds	r7, #20
 800b146:	46bd      	mov	sp, r7
 800b148:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b14c:	4770      	bx	lr

0800b14e <ForceZero>:
{
 800b14e:	b480      	push	{r7}
 800b150:	b085      	sub	sp, #20
 800b152:	af00      	add	r7, sp, #0
 800b154:	6078      	str	r0, [r7, #4]
 800b156:	6039      	str	r1, [r7, #0]
    volatile byte* z = (volatile byte*)mem;
 800b158:	687b      	ldr	r3, [r7, #4]
 800b15a:	60fb      	str	r3, [r7, #12]
    while (len--) *z++ = 0;
 800b15c:	e004      	b.n	800b168 <ForceZero+0x1a>
 800b15e:	68fb      	ldr	r3, [r7, #12]
 800b160:	1c5a      	adds	r2, r3, #1
 800b162:	60fa      	str	r2, [r7, #12]
 800b164:	2200      	movs	r2, #0
 800b166:	701a      	strb	r2, [r3, #0]
 800b168:	683b      	ldr	r3, [r7, #0]
 800b16a:	1e5a      	subs	r2, r3, #1
 800b16c:	603a      	str	r2, [r7, #0]
 800b16e:	2b00      	cmp	r3, #0
 800b170:	d1f5      	bne.n	800b15e <ForceZero+0x10>
}
 800b172:	bf00      	nop
 800b174:	bf00      	nop
 800b176:	3714      	adds	r7, #20
 800b178:	46bd      	mov	sp, r7
 800b17a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b17e:	4770      	bx	lr

0800b180 <c32to24>:
#endif /* !WOLFSSL_HAVE_MAX */

#ifndef WOLFSSL_NO_INT_ENCODE
/* converts a 32 bit integer to 24 bit */
WC_MISC_STATIC WC_INLINE void c32to24(word32 in, word24 out)
{
 800b180:	b480      	push	{r7}
 800b182:	b083      	sub	sp, #12
 800b184:	af00      	add	r7, sp, #0
 800b186:	6078      	str	r0, [r7, #4]
 800b188:	6039      	str	r1, [r7, #0]
    out[0] = (byte)((in >> 16) & 0xff);
 800b18a:	687b      	ldr	r3, [r7, #4]
 800b18c:	0c1b      	lsrs	r3, r3, #16
 800b18e:	b2da      	uxtb	r2, r3
 800b190:	683b      	ldr	r3, [r7, #0]
 800b192:	701a      	strb	r2, [r3, #0]
    out[1] = (byte)((in >>  8) & 0xff);
 800b194:	687b      	ldr	r3, [r7, #4]
 800b196:	0a1a      	lsrs	r2, r3, #8
 800b198:	683b      	ldr	r3, [r7, #0]
 800b19a:	3301      	adds	r3, #1
 800b19c:	b2d2      	uxtb	r2, r2
 800b19e:	701a      	strb	r2, [r3, #0]
    out[2] =  (byte)(in        & 0xff);
 800b1a0:	683b      	ldr	r3, [r7, #0]
 800b1a2:	3302      	adds	r3, #2
 800b1a4:	687a      	ldr	r2, [r7, #4]
 800b1a6:	b2d2      	uxtb	r2, r2
 800b1a8:	701a      	strb	r2, [r3, #0]
}
 800b1aa:	bf00      	nop
 800b1ac:	370c      	adds	r7, #12
 800b1ae:	46bd      	mov	sp, r7
 800b1b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b1b4:	4770      	bx	lr

0800b1b6 <MakeWordFromHash>:

#if defined(HAVE_SESSION_TICKET) || !defined(NO_CERTS) || \
    !defined(NO_SESSION_CACHE)
/* Make a word from the front of random hash */
WC_MISC_STATIC WC_INLINE word32 MakeWordFromHash(const byte* hashID)
{
 800b1b6:	b480      	push	{r7}
 800b1b8:	b083      	sub	sp, #12
 800b1ba:	af00      	add	r7, sp, #0
 800b1bc:	6078      	str	r0, [r7, #4]
    return ((word32)hashID[0] << 24) | ((word32)hashID[1] << 16) |
 800b1be:	687b      	ldr	r3, [r7, #4]
 800b1c0:	781b      	ldrb	r3, [r3, #0]
 800b1c2:	061a      	lsls	r2, r3, #24
 800b1c4:	687b      	ldr	r3, [r7, #4]
 800b1c6:	3301      	adds	r3, #1
 800b1c8:	781b      	ldrb	r3, [r3, #0]
 800b1ca:	041b      	lsls	r3, r3, #16
 800b1cc:	431a      	orrs	r2, r3
           ((word32)hashID[2] <<  8) |  (word32)hashID[3];
 800b1ce:	687b      	ldr	r3, [r7, #4]
 800b1d0:	3302      	adds	r3, #2
 800b1d2:	781b      	ldrb	r3, [r3, #0]
 800b1d4:	021b      	lsls	r3, r3, #8
    return ((word32)hashID[0] << 24) | ((word32)hashID[1] << 16) |
 800b1d6:	4313      	orrs	r3, r2
           ((word32)hashID[2] <<  8) |  (word32)hashID[3];
 800b1d8:	687a      	ldr	r2, [r7, #4]
 800b1da:	3203      	adds	r2, #3
 800b1dc:	7812      	ldrb	r2, [r2, #0]
 800b1de:	4313      	orrs	r3, r2
}
 800b1e0:	4618      	mov	r0, r3
 800b1e2:	370c      	adds	r7, #12
 800b1e4:	46bd      	mov	sp, r7
 800b1e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b1ea:	4770      	bx	lr

0800b1ec <static_buffer_init>:
/* Initialize static buffer.
 *
 * @param [in, out] sb  Static buffer.
 */
static void static_buffer_init(StaticBuffer* sb)
{
 800b1ec:	b480      	push	{r7}
 800b1ee:	b083      	sub	sp, #12
 800b1f0:	af00      	add	r7, sp, #0
 800b1f2:	6078      	str	r0, [r7, #4]
    sb->buffer = NULL;
 800b1f4:	687b      	ldr	r3, [r7, #4]
 800b1f6:	2200      	movs	r2, #0
 800b1f8:	601a      	str	r2, [r3, #0]
    sb->sz = 0;
 800b1fa:	687b      	ldr	r3, [r7, #4]
 800b1fc:	2200      	movs	r2, #0
 800b1fe:	605a      	str	r2, [r3, #4]
}
 800b200:	bf00      	nop
 800b202:	370c      	adds	r7, #12
 800b204:	46bd      	mov	sp, r7
 800b206:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b20a:	4770      	bx	lr

0800b20c <static_buffer_set_size>:
 * @return  0 on success.
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
static int static_buffer_set_size(StaticBuffer* sb, word32 len, void* heap,
    int type)
{
 800b20c:	b580      	push	{r7, lr}
 800b20e:	b086      	sub	sp, #24
 800b210:	af00      	add	r7, sp, #0
 800b212:	60f8      	str	r0, [r7, #12]
 800b214:	60b9      	str	r1, [r7, #8]
 800b216:	607a      	str	r2, [r7, #4]
 800b218:	603b      	str	r3, [r7, #0]
    int ret = 0;
 800b21a:	2300      	movs	r3, #0
 800b21c:	617b      	str	r3, [r7, #20]

    (void)heap;
    (void)type;

    sb->buffer = (byte*)XMALLOC(len, heap, type);
 800b21e:	68b8      	ldr	r0, [r7, #8]
 800b220:	f013 fc32 	bl	801ea88 <wolfSSL_Malloc>
 800b224:	4602      	mov	r2, r0
 800b226:	68fb      	ldr	r3, [r7, #12]
 800b228:	601a      	str	r2, [r3, #0]
    if (sb->buffer == NULL) {
 800b22a:	68fb      	ldr	r3, [r7, #12]
 800b22c:	681b      	ldr	r3, [r3, #0]
 800b22e:	2b00      	cmp	r3, #0
 800b230:	d103      	bne.n	800b23a <static_buffer_set_size+0x2e>
        ret = MEMORY_E;
 800b232:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800b236:	617b      	str	r3, [r7, #20]
 800b238:	e002      	b.n	800b240 <static_buffer_set_size+0x34>
    }
    else {
        sb->sz = len;
 800b23a:	68fb      	ldr	r3, [r7, #12]
 800b23c:	68ba      	ldr	r2, [r7, #8]
 800b23e:	605a      	str	r2, [r3, #4]
    }

    return ret;
 800b240:	697b      	ldr	r3, [r7, #20]
}
 800b242:	4618      	mov	r0, r3
 800b244:	3718      	adds	r7, #24
 800b246:	46bd      	mov	sp, r7
 800b248:	bd80      	pop	{r7, pc}

0800b24a <static_buffer_free>:
 * @param [in] sb    Static buffer.
 * @param [in] heap  Dynamic memory allocation hint.
 * @param [in] type  Type of dynamic memory.
 */
static void static_buffer_free(StaticBuffer* sb, void* heap, int type)
{
 800b24a:	b580      	push	{r7, lr}
 800b24c:	b086      	sub	sp, #24
 800b24e:	af00      	add	r7, sp, #0
 800b250:	60f8      	str	r0, [r7, #12]
 800b252:	60b9      	str	r1, [r7, #8]
 800b254:	607a      	str	r2, [r7, #4]
    (void)heap;
    (void)type;
    XFREE(sb->buffer, heap, type);
 800b256:	68fb      	ldr	r3, [r7, #12]
 800b258:	681b      	ldr	r3, [r3, #0]
 800b25a:	617b      	str	r3, [r7, #20]
 800b25c:	697b      	ldr	r3, [r7, #20]
 800b25e:	2b00      	cmp	r3, #0
 800b260:	d002      	beq.n	800b268 <static_buffer_free+0x1e>
 800b262:	6978      	ldr	r0, [r7, #20]
 800b264:	f013 fc2c 	bl	801eac0 <wolfSSL_Free>
}
 800b268:	bf00      	nop
 800b26a:	3718      	adds	r7, #24
 800b26c:	46bd      	mov	sp, r7
 800b26e:	bd80      	pop	{r7, pc}

0800b270 <wolfSSL_EVP_PKEY_CTX_free>:
#if defined(OPENSSL_VERSION_NUMBER) && OPENSSL_VERSION_NUMBER >= 0x10100000L
void wolfSSL_EVP_PKEY_CTX_free(WOLFSSL_EVP_PKEY_CTX *ctx)
#else
int wolfSSL_EVP_PKEY_CTX_free(WOLFSSL_EVP_PKEY_CTX *ctx)
#endif
{
 800b270:	b580      	push	{r7, lr}
 800b272:	b084      	sub	sp, #16
 800b274:	af00      	add	r7, sp, #0
 800b276:	6078      	str	r0, [r7, #4]
    if (ctx == NULL)
 800b278:	687b      	ldr	r3, [r7, #4]
 800b27a:	2b00      	cmp	r3, #0
 800b27c:	d101      	bne.n	800b282 <wolfSSL_EVP_PKEY_CTX_free+0x12>
#if defined(OPENSSL_VERSION_NUMBER) && OPENSSL_VERSION_NUMBER >= 0x10100000L
        return;
#else
        return 0;
 800b27e:	2300      	movs	r3, #0
 800b280:	e01a      	b.n	800b2b8 <wolfSSL_EVP_PKEY_CTX_free+0x48>
#endif
    WOLFSSL_ENTER("wolfSSL_EVP_PKEY_CTX_free");
    if (ctx->pkey != NULL)
 800b282:	687b      	ldr	r3, [r7, #4]
 800b284:	681b      	ldr	r3, [r3, #0]
 800b286:	2b00      	cmp	r3, #0
 800b288:	d004      	beq.n	800b294 <wolfSSL_EVP_PKEY_CTX_free+0x24>
        wolfSSL_EVP_PKEY_free(ctx->pkey);
 800b28a:	687b      	ldr	r3, [r7, #4]
 800b28c:	681b      	ldr	r3, [r3, #0]
 800b28e:	4618      	mov	r0, r3
 800b290:	f000 f894 	bl	800b3bc <wolfSSL_EVP_PKEY_free>
    if (ctx->peerKey != NULL)
 800b294:	687b      	ldr	r3, [r7, #4]
 800b296:	685b      	ldr	r3, [r3, #4]
 800b298:	2b00      	cmp	r3, #0
 800b29a:	d004      	beq.n	800b2a6 <wolfSSL_EVP_PKEY_CTX_free+0x36>
        wolfSSL_EVP_PKEY_free(ctx->peerKey);
 800b29c:	687b      	ldr	r3, [r7, #4]
 800b29e:	685b      	ldr	r3, [r3, #4]
 800b2a0:	4618      	mov	r0, r3
 800b2a2:	f000 f88b 	bl	800b3bc <wolfSSL_EVP_PKEY_free>
    XFREE(ctx, NULL, DYNAMIC_TYPE_PUBLIC_KEY);
 800b2a6:	687b      	ldr	r3, [r7, #4]
 800b2a8:	60fb      	str	r3, [r7, #12]
 800b2aa:	68fb      	ldr	r3, [r7, #12]
 800b2ac:	2b00      	cmp	r3, #0
 800b2ae:	d002      	beq.n	800b2b6 <wolfSSL_EVP_PKEY_CTX_free+0x46>
 800b2b0:	68f8      	ldr	r0, [r7, #12]
 800b2b2:	f013 fc05 	bl	801eac0 <wolfSSL_Free>
#if !defined(OPENSSL_VERSION_NUMBER) || OPENSSL_VERSION_NUMBER < 0x10100000L
    return WOLFSSL_SUCCESS;
 800b2b6:	2301      	movs	r3, #1
#endif
}
 800b2b8:	4618      	mov	r0, r3
 800b2ba:	3710      	adds	r7, #16
 800b2bc:	46bd      	mov	sp, r7
 800b2be:	bd80      	pop	{r7, pc}

0800b2c0 <wolfSSL_EVP_init>:

    return NULL;
}

void wolfSSL_EVP_init(void)
{
 800b2c0:	b480      	push	{r7}
 800b2c2:	af00      	add	r7, sp, #0
    /* Does nothing. */
}
 800b2c4:	bf00      	nop
 800b2c6:	46bd      	mov	sp, r7
 800b2c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b2cc:	4770      	bx	lr

0800b2ce <wolfSSL_EVP_MD_CTX_free>:
        }
        return ctx;
    }

    void wolfSSL_EVP_MD_CTX_free(WOLFSSL_EVP_MD_CTX *ctx)
    {
 800b2ce:	b580      	push	{r7, lr}
 800b2d0:	b084      	sub	sp, #16
 800b2d2:	af00      	add	r7, sp, #0
 800b2d4:	6078      	str	r0, [r7, #4]
        if (ctx) {
 800b2d6:	687b      	ldr	r3, [r7, #4]
 800b2d8:	2b00      	cmp	r3, #0
 800b2da:	d00a      	beq.n	800b2f2 <wolfSSL_EVP_MD_CTX_free+0x24>
            WOLFSSL_ENTER("EVP_MD_CTX_free");
            wolfSSL_EVP_MD_CTX_cleanup(ctx);
 800b2dc:	6878      	ldr	r0, [r7, #4]
 800b2de:	f000 f80d 	bl	800b2fc <wolfSSL_EVP_MD_CTX_cleanup>
            XFREE(ctx, NULL, DYNAMIC_TYPE_OPENSSL);
 800b2e2:	687b      	ldr	r3, [r7, #4]
 800b2e4:	60fb      	str	r3, [r7, #12]
 800b2e6:	68fb      	ldr	r3, [r7, #12]
 800b2e8:	2b00      	cmp	r3, #0
 800b2ea:	d002      	beq.n	800b2f2 <wolfSSL_EVP_MD_CTX_free+0x24>
 800b2ec:	68f8      	ldr	r0, [r7, #12]
 800b2ee:	f013 fbe7 	bl	801eac0 <wolfSSL_Free>
        }
    }
 800b2f2:	bf00      	nop
 800b2f4:	3710      	adds	r7, #16
 800b2f6:	46bd      	mov	sp, r7
 800b2f8:	bd80      	pop	{r7, pc}
	...

0800b2fc <wolfSSL_EVP_MD_CTX_cleanup>:
                break;
        }
    }

    int wolfSSL_EVP_MD_CTX_cleanup(WOLFSSL_EVP_MD_CTX* ctx)
    {
 800b2fc:	b580      	push	{r7, lr}
 800b2fe:	b084      	sub	sp, #16
 800b300:	af00      	add	r7, sp, #0
 800b302:	6078      	str	r0, [r7, #4]
        int ret = WOLFSSL_SUCCESS;
 800b304:	2301      	movs	r3, #1
 800b306:	60fb      	str	r3, [r7, #12]
        WOLFSSL_ENTER("wolfSSL_EVP_MD_CTX_cleanup");
    #ifdef OPENSSL_EXTRA
        if (ctx->pctx != NULL)
 800b308:	687b      	ldr	r3, [r7, #4]
 800b30a:	f8d3 31ac 	ldr.w	r3, [r3, #428]	@ 0x1ac
 800b30e:	2b00      	cmp	r3, #0
 800b310:	d005      	beq.n	800b31e <wolfSSL_EVP_MD_CTX_cleanup+0x22>
            wolfSSL_EVP_PKEY_CTX_free(ctx->pctx);
 800b312:	687b      	ldr	r3, [r7, #4]
 800b314:	f8d3 31ac 	ldr.w	r3, [r3, #428]	@ 0x1ac
 800b318:	4618      	mov	r0, r3
 800b31a:	f7ff ffa9 	bl	800b270 <wolfSSL_EVP_PKEY_CTX_free>
    #endif

        if (ctx->isHMAC) {
 800b31e:	687b      	ldr	r3, [r7, #4]
 800b320:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 800b324:	2b00      	cmp	r3, #0
 800b326:	d004      	beq.n	800b332 <wolfSSL_EVP_MD_CTX_cleanup+0x36>
            wc_HmacFree(&ctx->hash.hmac);
 800b328:	687b      	ldr	r3, [r7, #4]
 800b32a:	4618      	mov	r0, r3
 800b32c:	f013 f935 	bl	801e59a <wc_HmacFree>
 800b330:	e035      	b.n	800b39e <wolfSSL_EVP_MD_CTX_cleanup+0xa2>
        }
        else {
            switch (ctx->macType) {
 800b332:	687b      	ldr	r3, [r7, #4]
 800b334:	f893 31a8 	ldrb.w	r3, [r3, #424]	@ 0x1a8
 800b338:	2b11      	cmp	r3, #17
 800b33a:	d82c      	bhi.n	800b396 <wolfSSL_EVP_MD_CTX_cleanup+0x9a>
 800b33c:	a201      	add	r2, pc, #4	@ (adr r2, 800b344 <wolfSSL_EVP_MD_CTX_cleanup+0x48>)
 800b33e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800b342:	bf00      	nop
 800b344:	0800b39d 	.word	0x0800b39d
 800b348:	0800b397 	.word	0x0800b397
 800b34c:	0800b397 	.word	0x0800b397
 800b350:	0800b39d 	.word	0x0800b39d
 800b354:	0800b39d 	.word	0x0800b39d
 800b358:	0800b39d 	.word	0x0800b39d
 800b35c:	0800b38d 	.word	0x0800b38d
 800b360:	0800b39d 	.word	0x0800b39d
 800b364:	0800b39d 	.word	0x0800b39d
 800b368:	0800b397 	.word	0x0800b397
 800b36c:	0800b39d 	.word	0x0800b39d
 800b370:	0800b39d 	.word	0x0800b39d
 800b374:	0800b39d 	.word	0x0800b39d
 800b378:	0800b39d 	.word	0x0800b39d
 800b37c:	0800b397 	.word	0x0800b397
 800b380:	0800b397 	.word	0x0800b397
 800b384:	0800b39d 	.word	0x0800b39d
 800b388:	0800b39d 	.word	0x0800b39d
                    wc_Sha224Free((wc_Sha224*)&ctx->hash.digest);
            #endif /* WOLFSSL_SHA224 */
                    break;
                case WC_HASH_TYPE_SHA256:
            #ifndef NO_SHA256
                    wc_Sha256Free((wc_Sha256*)&ctx->hash.digest);
 800b38c:	687b      	ldr	r3, [r7, #4]
 800b38e:	4618      	mov	r0, r3
 800b390:	f016 fe3b 	bl	802200a <wc_Sha256Free>
            #endif /* !NO_SHA256 */
                    break;
 800b394:	e003      	b.n	800b39e <wolfSSL_EVP_MD_CTX_cleanup+0xa2>
            #endif
            #if defined(WOLFSSL_SHA3) && defined(WOLFSSL_SHAKE256)
                case WC_HASH_TYPE_SHAKE256:
            #endif
                default:
                    ret = WOLFSSL_FAILURE;
 800b396:	2300      	movs	r3, #0
 800b398:	60fb      	str	r3, [r7, #12]
                    break;
 800b39a:	e000      	b.n	800b39e <wolfSSL_EVP_MD_CTX_cleanup+0xa2>
                    break;
 800b39c:	bf00      	nop
            }
        }
        ForceZero(ctx, sizeof(*ctx));
 800b39e:	f44f 71da 	mov.w	r1, #436	@ 0x1b4
 800b3a2:	6878      	ldr	r0, [r7, #4]
 800b3a4:	f7ff fed3 	bl	800b14e <ForceZero>
        ctx->macType = WC_HASH_TYPE_NONE;
 800b3a8:	687b      	ldr	r3, [r7, #4]
 800b3aa:	2200      	movs	r2, #0
 800b3ac:	f883 21a8 	strb.w	r2, [r3, #424]	@ 0x1a8
        return ret;
 800b3b0:	68fb      	ldr	r3, [r7, #12]
    }
 800b3b2:	4618      	mov	r0, r3
 800b3b4:	3710      	adds	r7, #16
 800b3b6:	46bd      	mov	sp, r7
 800b3b8:	bd80      	pop	{r7, pc}
 800b3ba:	bf00      	nop

0800b3bc <wolfSSL_EVP_PKEY_free>:

    return pkey;
}

void wolfSSL_EVP_PKEY_free(WOLFSSL_EVP_PKEY* key)
{
 800b3bc:	b580      	push	{r7, lr}
 800b3be:	b08a      	sub	sp, #40	@ 0x28
 800b3c0:	af00      	add	r7, sp, #0
 800b3c2:	6078      	str	r0, [r7, #4]
    int doFree = 0;
 800b3c4:	2300      	movs	r3, #0
 800b3c6:	60fb      	str	r3, [r7, #12]
    WOLFSSL_ENTER("wolfSSL_EVP_PKEY_free");
    if (key != NULL) {
 800b3c8:	687b      	ldr	r3, [r7, #4]
 800b3ca:	2b00      	cmp	r3, #0
 800b3cc:	f000 80b8 	beq.w	800b540 <wolfSSL_EVP_PKEY_free+0x184>
        int ret;
        wolfSSL_RefDec(&key->ref, &doFree, &ret);
 800b3d0:	687b      	ldr	r3, [r7, #4]
 800b3d2:	3310      	adds	r3, #16
 800b3d4:	2101      	movs	r1, #1
 800b3d6:	4618      	mov	r0, r3
 800b3d8:	f7ff fea4 	bl	800b124 <wolfSSL_Atomic_Int_FetchSub>
 800b3dc:	6278      	str	r0, [r7, #36]	@ 0x24
 800b3de:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800b3e0:	2b01      	cmp	r3, #1
 800b3e2:	bf0c      	ite	eq
 800b3e4:	2301      	moveq	r3, #1
 800b3e6:	2300      	movne	r3, #0
 800b3e8:	b2db      	uxtb	r3, r3
 800b3ea:	60fb      	str	r3, [r7, #12]
 800b3ec:	2300      	movs	r3, #0
 800b3ee:	60bb      	str	r3, [r7, #8]
        }
    #else
        (void)ret;
    #endif

        if (doFree) {
 800b3f0:	68fb      	ldr	r3, [r7, #12]
 800b3f2:	2b00      	cmp	r3, #0
 800b3f4:	f000 80a4 	beq.w	800b540 <wolfSSL_EVP_PKEY_free+0x184>
            wc_FreeRng(&key->rng);
 800b3f8:	687b      	ldr	r3, [r7, #4]
 800b3fa:	3324      	adds	r3, #36	@ 0x24
 800b3fc:	4618      	mov	r0, r3
 800b3fe:	f014 f96b 	bl	801f6d8 <wc_FreeRng>

            if (key->pkey.ptr != NULL) {
 800b402:	687b      	ldr	r3, [r7, #4]
 800b404:	695b      	ldr	r3, [r3, #20]
 800b406:	2b00      	cmp	r3, #0
 800b408:	d00b      	beq.n	800b422 <wolfSSL_EVP_PKEY_free+0x66>
                XFREE(key->pkey.ptr, key->heap, DYNAMIC_TYPE_PUBLIC_KEY);
 800b40a:	687b      	ldr	r3, [r7, #4]
 800b40c:	695b      	ldr	r3, [r3, #20]
 800b40e:	623b      	str	r3, [r7, #32]
 800b410:	6a3b      	ldr	r3, [r7, #32]
 800b412:	2b00      	cmp	r3, #0
 800b414:	d002      	beq.n	800b41c <wolfSSL_EVP_PKEY_free+0x60>
 800b416:	6a38      	ldr	r0, [r7, #32]
 800b418:	f013 fb52 	bl	801eac0 <wolfSSL_Free>
                key->pkey.ptr = NULL;
 800b41c:	687b      	ldr	r3, [r7, #4]
 800b41e:	2200      	movs	r2, #0
 800b420:	615a      	str	r2, [r3, #20]
            }
            switch(key->type)
 800b422:	687b      	ldr	r3, [r7, #4]
 800b424:	685b      	ldr	r3, [r3, #4]
 800b426:	f240 420c 	movw	r2, #1036	@ 0x40c
 800b42a:	4293      	cmp	r3, r2
 800b42c:	d04b      	beq.n	800b4c6 <wolfSSL_EVP_PKEY_free+0x10a>
 800b42e:	f240 420c 	movw	r2, #1036	@ 0x40c
 800b432:	4293      	cmp	r3, r2
 800b434:	dc75      	bgt.n	800b522 <wolfSSL_EVP_PKEY_free+0x166>
 800b436:	2b1c      	cmp	r3, #28
 800b438:	d030      	beq.n	800b49c <wolfSSL_EVP_PKEY_free+0xe0>
 800b43a:	2b1c      	cmp	r3, #28
 800b43c:	dc71      	bgt.n	800b522 <wolfSSL_EVP_PKEY_free+0x166>
 800b43e:	2b10      	cmp	r3, #16
 800b440:	d002      	beq.n	800b448 <wolfSSL_EVP_PKEY_free+0x8c>
 800b442:	2b12      	cmp	r3, #18
 800b444:	d015      	beq.n	800b472 <wolfSSL_EVP_PKEY_free+0xb6>
                    }
                    break;
                #endif /* defined(WOLFSSL_CMAC) ... */

                default:
                    break;
 800b446:	e06c      	b.n	800b522 <wolfSSL_EVP_PKEY_free+0x166>
                    if (key->rsa != NULL && key->ownRsa == 1) {
 800b448:	687b      	ldr	r3, [r7, #4]
 800b44a:	699b      	ldr	r3, [r3, #24]
 800b44c:	2b00      	cmp	r3, #0
 800b44e:	d06a      	beq.n	800b526 <wolfSSL_EVP_PKEY_free+0x16a>
 800b450:	687b      	ldr	r3, [r7, #4]
 800b452:	f893 305a 	ldrb.w	r3, [r3, #90]	@ 0x5a
 800b456:	f003 0308 	and.w	r3, r3, #8
 800b45a:	b2db      	uxtb	r3, r3
 800b45c:	2b00      	cmp	r3, #0
 800b45e:	d062      	beq.n	800b526 <wolfSSL_EVP_PKEY_free+0x16a>
                        wolfSSL_RSA_free(key->rsa);
 800b460:	687b      	ldr	r3, [r7, #4]
 800b462:	699b      	ldr	r3, [r3, #24]
 800b464:	4618      	mov	r0, r3
 800b466:	f000 fc9d 	bl	800bda4 <wolfSSL_RSA_free>
                        key->rsa = NULL;
 800b46a:	687b      	ldr	r3, [r7, #4]
 800b46c:	2200      	movs	r2, #0
 800b46e:	619a      	str	r2, [r3, #24]
                    break;
 800b470:	e059      	b.n	800b526 <wolfSSL_EVP_PKEY_free+0x16a>
                    if (key->ecc != NULL && key->ownEcc == 1) {
 800b472:	687b      	ldr	r3, [r7, #4]
 800b474:	69db      	ldr	r3, [r3, #28]
 800b476:	2b00      	cmp	r3, #0
 800b478:	d057      	beq.n	800b52a <wolfSSL_EVP_PKEY_free+0x16e>
 800b47a:	687b      	ldr	r3, [r7, #4]
 800b47c:	f893 305a 	ldrb.w	r3, [r3, #90]	@ 0x5a
 800b480:	f003 0302 	and.w	r3, r3, #2
 800b484:	b2db      	uxtb	r3, r3
 800b486:	2b00      	cmp	r3, #0
 800b488:	d04f      	beq.n	800b52a <wolfSSL_EVP_PKEY_free+0x16e>
                        wolfSSL_EC_KEY_free(key->ecc);
 800b48a:	687b      	ldr	r3, [r7, #4]
 800b48c:	69db      	ldr	r3, [r3, #28]
 800b48e:	4618      	mov	r0, r3
 800b490:	f000 fdca 	bl	800c028 <wolfSSL_EC_KEY_free>
                        key->ecc = NULL;
 800b494:	687b      	ldr	r3, [r7, #4]
 800b496:	2200      	movs	r2, #0
 800b498:	61da      	str	r2, [r3, #28]
                    break;
 800b49a:	e046      	b.n	800b52a <wolfSSL_EVP_PKEY_free+0x16e>
                    if (key->dh != NULL && key->ownDh == 1) {
 800b49c:	687b      	ldr	r3, [r7, #4]
 800b49e:	6a1b      	ldr	r3, [r3, #32]
 800b4a0:	2b00      	cmp	r3, #0
 800b4a2:	d044      	beq.n	800b52e <wolfSSL_EVP_PKEY_free+0x172>
 800b4a4:	687b      	ldr	r3, [r7, #4]
 800b4a6:	f893 305a 	ldrb.w	r3, [r3, #90]	@ 0x5a
 800b4aa:	f003 0301 	and.w	r3, r3, #1
 800b4ae:	b2db      	uxtb	r3, r3
 800b4b0:	2b00      	cmp	r3, #0
 800b4b2:	d03c      	beq.n	800b52e <wolfSSL_EVP_PKEY_free+0x172>
                        wolfSSL_DH_free(key->dh);
 800b4b4:	687b      	ldr	r3, [r7, #4]
 800b4b6:	6a1b      	ldr	r3, [r3, #32]
 800b4b8:	4618      	mov	r0, r3
 800b4ba:	f000 fd0d 	bl	800bed8 <wolfSSL_DH_free>
                        key->dh = NULL;
 800b4be:	687b      	ldr	r3, [r7, #4]
 800b4c0:	2200      	movs	r2, #0
 800b4c2:	621a      	str	r2, [r3, #32]
                    break;
 800b4c4:	e033      	b.n	800b52e <wolfSSL_EVP_PKEY_free+0x172>
                    XFREE(key->hkdfSalt, NULL, DYNAMIC_TYPE_SALT);
 800b4c6:	687b      	ldr	r3, [r7, #4]
 800b4c8:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800b4ca:	61fb      	str	r3, [r7, #28]
 800b4cc:	69fb      	ldr	r3, [r7, #28]
 800b4ce:	2b00      	cmp	r3, #0
 800b4d0:	d002      	beq.n	800b4d8 <wolfSSL_EVP_PKEY_free+0x11c>
 800b4d2:	69f8      	ldr	r0, [r7, #28]
 800b4d4:	f013 faf4 	bl	801eac0 <wolfSSL_Free>
                    key->hkdfSalt = NULL;
 800b4d8:	687b      	ldr	r3, [r7, #4]
 800b4da:	2200      	movs	r2, #0
 800b4dc:	639a      	str	r2, [r3, #56]	@ 0x38
                    XFREE(key->hkdfKey, NULL, DYNAMIC_TYPE_KEY);
 800b4de:	687b      	ldr	r3, [r7, #4]
 800b4e0:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800b4e2:	61bb      	str	r3, [r7, #24]
 800b4e4:	69bb      	ldr	r3, [r7, #24]
 800b4e6:	2b00      	cmp	r3, #0
 800b4e8:	d002      	beq.n	800b4f0 <wolfSSL_EVP_PKEY_free+0x134>
 800b4ea:	69b8      	ldr	r0, [r7, #24]
 800b4ec:	f013 fae8 	bl	801eac0 <wolfSSL_Free>
                    key->hkdfKey = NULL;
 800b4f0:	687b      	ldr	r3, [r7, #4]
 800b4f2:	2200      	movs	r2, #0
 800b4f4:	641a      	str	r2, [r3, #64]	@ 0x40
                    XFREE(key->hkdfInfo, NULL, DYNAMIC_TYPE_INFO);
 800b4f6:	687b      	ldr	r3, [r7, #4]
 800b4f8:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 800b4fa:	617b      	str	r3, [r7, #20]
 800b4fc:	697b      	ldr	r3, [r7, #20]
 800b4fe:	2b00      	cmp	r3, #0
 800b500:	d002      	beq.n	800b508 <wolfSSL_EVP_PKEY_free+0x14c>
 800b502:	6978      	ldr	r0, [r7, #20]
 800b504:	f013 fadc 	bl	801eac0 <wolfSSL_Free>
                    key->hkdfInfo = NULL;
 800b508:	687b      	ldr	r3, [r7, #4]
 800b50a:	2200      	movs	r2, #0
 800b50c:	649a      	str	r2, [r3, #72]	@ 0x48
                    key->hkdfSaltSz = 0;
 800b50e:	687b      	ldr	r3, [r7, #4]
 800b510:	2200      	movs	r2, #0
 800b512:	63da      	str	r2, [r3, #60]	@ 0x3c
                    key->hkdfKeySz = 0;
 800b514:	687b      	ldr	r3, [r7, #4]
 800b516:	2200      	movs	r2, #0
 800b518:	645a      	str	r2, [r3, #68]	@ 0x44
                    key->hkdfInfoSz = 0;
 800b51a:	687b      	ldr	r3, [r7, #4]
 800b51c:	2200      	movs	r2, #0
 800b51e:	64da      	str	r2, [r3, #76]	@ 0x4c
                    break;
 800b520:	e006      	b.n	800b530 <wolfSSL_EVP_PKEY_free+0x174>
                    break;
 800b522:	bf00      	nop
 800b524:	e004      	b.n	800b530 <wolfSSL_EVP_PKEY_free+0x174>
                    break;
 800b526:	bf00      	nop
 800b528:	e002      	b.n	800b530 <wolfSSL_EVP_PKEY_free+0x174>
                    break;
 800b52a:	bf00      	nop
 800b52c:	e000      	b.n	800b530 <wolfSSL_EVP_PKEY_free+0x174>
                    break;
 800b52e:	bf00      	nop
            }

            wolfSSL_RefFree(&key->ref);
            XFREE(key, key->heap, DYNAMIC_TYPE_PUBLIC_KEY);
 800b530:	687b      	ldr	r3, [r7, #4]
 800b532:	613b      	str	r3, [r7, #16]
 800b534:	693b      	ldr	r3, [r7, #16]
 800b536:	2b00      	cmp	r3, #0
 800b538:	d002      	beq.n	800b540 <wolfSSL_EVP_PKEY_free+0x184>
 800b53a:	6938      	ldr	r0, [r7, #16]
 800b53c:	f013 fac0 	bl	801eac0 <wolfSSL_Free>
        }
    }
}
 800b540:	bf00      	nop
 800b542:	3728      	adds	r7, #40	@ 0x28
 800b544:	46bd      	mov	sp, r7
 800b546:	bd80      	pop	{r7, pc}

0800b548 <wolfSSL_CertManagerNew_ex>:
 * @param [in] heap  Heap hint.
 * @return  Certificate manager object on success.
 * @return  NULL on failure.
 */
WOLFSSL_CERT_MANAGER* wolfSSL_CertManagerNew_ex(void* heap)
{
 800b548:	b580      	push	{r7, lr}
 800b54a:	b084      	sub	sp, #16
 800b54c:	af00      	add	r7, sp, #0
 800b54e:	6078      	str	r0, [r7, #4]
    int err = 0;
 800b550:	2300      	movs	r3, #0
 800b552:	60bb      	str	r3, [r7, #8]
    }
    WOLFSSL_MSG_EX("DYNAMIC_TYPE_CERT_MANAGER Allocating = %d bytes",
                    (word32)sizeof(WOLFSSL_CERT_MANAGER));

    /* Allocate memory for certificate manager. */
    cm = (WOLFSSL_CERT_MANAGER*)XMALLOC(sizeof(WOLFSSL_CERT_MANAGER), heap,
 800b554:	2070      	movs	r0, #112	@ 0x70
 800b556:	f013 fa97 	bl	801ea88 <wolfSSL_Malloc>
 800b55a:	60f8      	str	r0, [r7, #12]
        DYNAMIC_TYPE_CERT_MANAGER);
    if (cm == NULL) {
 800b55c:	68fb      	ldr	r3, [r7, #12]
 800b55e:	2b00      	cmp	r3, #0
 800b560:	d101      	bne.n	800b566 <wolfSSL_CertManagerNew_ex+0x1e>
        WOLFSSL_MSG_EX("XMALLOC failed to allocate WOLFSSL_CERT_MANAGER %d "
                    "bytes.", (int)sizeof(WOLFSSL_CERT_MANAGER));
        err = 1;
 800b562:	2301      	movs	r3, #1
 800b564:	60bb      	str	r3, [r7, #8]
    }
    if (!err) {
 800b566:	68bb      	ldr	r3, [r7, #8]
 800b568:	2b00      	cmp	r3, #0
 800b56a:	d10e      	bne.n	800b58a <wolfSSL_CertManagerNew_ex+0x42>
        /* Reset all fields. */
        XMEMSET(cm, 0, sizeof(WOLFSSL_CERT_MANAGER));
 800b56c:	2270      	movs	r2, #112	@ 0x70
 800b56e:	2100      	movs	r1, #0
 800b570:	68f8      	ldr	r0, [r7, #12]
 800b572:	f01c ffa9 	bl	80284c8 <memset>

        /* Create a mutex for use when modify table of stored CAs. */
        if (wc_InitMutex(&cm->caLock) != 0) {
 800b576:	68fb      	ldr	r3, [r7, #12]
 800b578:	335c      	adds	r3, #92	@ 0x5c
 800b57a:	4618      	mov	r0, r3
 800b57c:	f01b fefe 	bl	802737c <wc_InitMutex>
 800b580:	4603      	mov	r3, r0
 800b582:	2b00      	cmp	r3, #0
 800b584:	d001      	beq.n	800b58a <wolfSSL_CertManagerNew_ex+0x42>
            WOLFSSL_MSG("Bad mutex init");
            err = 1;
 800b586:	2301      	movs	r3, #1
 800b588:	60bb      	str	r3, [r7, #8]
        }
    }
    if (!err) {
 800b58a:	68bb      	ldr	r3, [r7, #8]
 800b58c:	2b00      	cmp	r3, #0
 800b58e:	d104      	bne.n	800b59a <wolfSSL_CertManagerNew_ex+0x52>
        /* Initialize reference count. */
        wolfSSL_RefInit(&cm->ref, &err);
 800b590:	68fb      	ldr	r3, [r7, #12]
 800b592:	2201      	movs	r2, #1
 800b594:	66da      	str	r2, [r3, #108]	@ 0x6c
 800b596:	2300      	movs	r3, #0
 800b598:	60bb      	str	r3, [r7, #8]
    if ((!err) && (wc_InitMutex(&cm->tpLock) != 0)) {
        WOLFSSL_MSG("Bad mutex init");
        err = 1;
    }
#endif
    if (!err) {
 800b59a:	68bb      	ldr	r3, [r7, #8]
 800b59c:	2b00      	cmp	r3, #0
 800b59e:	d10a      	bne.n	800b5b6 <wolfSSL_CertManagerNew_ex+0x6e>
        /* Set default minimum key sizes allowed. */
    #ifndef NO_RSA
        cm->minRsaKeySz = MIN_RSAKEY_SZ;
 800b5a0:	68fb      	ldr	r3, [r7, #12]
 800b5a2:	2280      	movs	r2, #128	@ 0x80
 800b5a4:	f8a3 2062 	strh.w	r2, [r3, #98]	@ 0x62
    #endif
    #ifdef HAVE_ECC
        cm->minEccKeySz = MIN_ECCKEY_SZ;
 800b5a8:	68fb      	ldr	r3, [r7, #12]
 800b5aa:	221c      	movs	r2, #28
 800b5ac:	f8a3 2064 	strh.w	r2, [r3, #100]	@ 0x64
    #ifdef HAVE_DILITHIUM
        cm->minDilithiumKeySz = MIN_DILITHIUMKEY_SZ;
    #endif /* HAVE_DILITHIUM */

        /* Set heap hint to use in certificate manager operations. */
        cm->heap = heap;
 800b5b0:	68fb      	ldr	r3, [r7, #12]
 800b5b2:	687a      	ldr	r2, [r7, #4]
 800b5b4:	62da      	str	r2, [r3, #44]	@ 0x2c
    }

    /* Dispose of certificate manager on error. */
    if (err && (cm != NULL)) {
 800b5b6:	68bb      	ldr	r3, [r7, #8]
 800b5b8:	2b00      	cmp	r3, #0
 800b5ba:	d007      	beq.n	800b5cc <wolfSSL_CertManagerNew_ex+0x84>
 800b5bc:	68fb      	ldr	r3, [r7, #12]
 800b5be:	2b00      	cmp	r3, #0
 800b5c0:	d004      	beq.n	800b5cc <wolfSSL_CertManagerNew_ex+0x84>
        wolfSSL_CertManagerFree(cm);
 800b5c2:	68f8      	ldr	r0, [r7, #12]
 800b5c4:	f000 f807 	bl	800b5d6 <wolfSSL_CertManagerFree>
        cm = NULL;
 800b5c8:	2300      	movs	r3, #0
 800b5ca:	60fb      	str	r3, [r7, #12]
    }
    return cm;
 800b5cc:	68fb      	ldr	r3, [r7, #12]
}
 800b5ce:	4618      	mov	r0, r3
 800b5d0:	3710      	adds	r7, #16
 800b5d2:	46bd      	mov	sp, r7
 800b5d4:	bd80      	pop	{r7, pc}

0800b5d6 <wolfSSL_CertManagerFree>:
/* Dispose of certificate manager.
 *
 * @param [in, out] cm  Certificate manager.
 */
void wolfSSL_CertManagerFree(WOLFSSL_CERT_MANAGER* cm)
{
 800b5d6:	b580      	push	{r7, lr}
 800b5d8:	b086      	sub	sp, #24
 800b5da:	af00      	add	r7, sp, #0
 800b5dc:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_CertManagerFree");

    /* Validate parameter. */
    if (cm != NULL) {
 800b5de:	687b      	ldr	r3, [r7, #4]
 800b5e0:	2b00      	cmp	r3, #0
 800b5e2:	d028      	beq.n	800b636 <wolfSSL_CertManagerFree+0x60>
        int doFree = 0;
 800b5e4:	2300      	movs	r3, #0
 800b5e6:	60fb      	str	r3, [r7, #12]
        int ret;

        /* Decrement reference count and check if value is 0. */
        wolfSSL_RefDec(&cm->ref, &doFree, &ret);
 800b5e8:	687b      	ldr	r3, [r7, #4]
 800b5ea:	336c      	adds	r3, #108	@ 0x6c
 800b5ec:	2101      	movs	r1, #1
 800b5ee:	4618      	mov	r0, r3
 800b5f0:	f7ff fd98 	bl	800b124 <wolfSSL_Atomic_Int_FetchSub>
 800b5f4:	6178      	str	r0, [r7, #20]
 800b5f6:	697b      	ldr	r3, [r7, #20]
 800b5f8:	2b01      	cmp	r3, #1
 800b5fa:	bf0c      	ite	eq
 800b5fc:	2301      	moveq	r3, #1
 800b5fe:	2300      	movne	r3, #0
 800b600:	b2db      	uxtb	r3, r3
 800b602:	60fb      	str	r3, [r7, #12]
 800b604:	2300      	movs	r3, #0
 800b606:	60bb      	str	r3, [r7, #8]
            WOLFSSL_MSG("Couldn't lock cm mutex");
        }
    #else
        (void)ret;
    #endif
        if (doFree) {
 800b608:	68fb      	ldr	r3, [r7, #12]
 800b60a:	2b00      	cmp	r3, #0
 800b60c:	d013      	beq.n	800b636 <wolfSSL_CertManagerFree+0x60>
            }
        #endif
    #endif /* HAVE_OCSP */

            /* Dispose of CA table and mutex. */
            FreeSignerTable(cm->caTable, CA_TABLE_SIZE, cm->heap);
 800b60e:	6878      	ldr	r0, [r7, #4]
 800b610:	687b      	ldr	r3, [r7, #4]
 800b612:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800b614:	461a      	mov	r2, r3
 800b616:	210b      	movs	r1, #11
 800b618:	f00d fbaa 	bl	8018d70 <FreeSignerTable>
            wc_FreeMutex(&cm->caLock);
 800b61c:	687b      	ldr	r3, [r7, #4]
 800b61e:	335c      	adds	r3, #92	@ 0x5c
 800b620:	4618      	mov	r0, r3
 800b622:	f01b feb6 	bl	8027392 <wc_FreeMutex>
        #endif

            /* Dispose of reference count. */
            wolfSSL_RefFree(&cm->ref);
            /* Dispose of certificate manager memory. */
            XFREE(cm, cm->heap, DYNAMIC_TYPE_CERT_MANAGER);
 800b626:	687b      	ldr	r3, [r7, #4]
 800b628:	613b      	str	r3, [r7, #16]
 800b62a:	693b      	ldr	r3, [r7, #16]
 800b62c:	2b00      	cmp	r3, #0
 800b62e:	d002      	beq.n	800b636 <wolfSSL_CertManagerFree+0x60>
 800b630:	6938      	ldr	r0, [r7, #16]
 800b632:	f013 fa45 	bl	801eac0 <wolfSSL_Free>
        }
    }
}
 800b636:	bf00      	nop
 800b638:	3718      	adds	r7, #24
 800b63a:	46bd      	mov	sp, r7
 800b63c:	bd80      	pop	{r7, pc}

0800b63e <CM_VerifyBuffer_ex>:
 * @return  NOT_COMPILED_IN when converting from PEM to DER is not a feature of
 *          the wolfSSL build.
 */
int CM_VerifyBuffer_ex(WOLFSSL_CERT_MANAGER* cm, const unsigned char* buff,
    long sz, int format, int prev_err)
{
 800b63e:	b580      	push	{r7, lr}
 800b640:	b092      	sub	sp, #72	@ 0x48
 800b642:	af04      	add	r7, sp, #16
 800b644:	60f8      	str	r0, [r7, #12]
 800b646:	60b9      	str	r1, [r7, #8]
 800b648:	607a      	str	r2, [r7, #4]
 800b64a:	603b      	str	r3, [r7, #0]
    int ret = 0;
 800b64c:	2300      	movs	r3, #0
 800b64e:	637b      	str	r3, [r7, #52]	@ 0x34
    int fatal = 0;
 800b650:	2300      	movs	r3, #0
 800b652:	633b      	str	r3, [r7, #48]	@ 0x30
    DerBuffer* der = NULL;
 800b654:	2300      	movs	r3, #0
 800b656:	61fb      	str	r3, [r7, #28]
#ifdef WOLFSSL_SMALL_STACK
    DecodedCert* cert = NULL;
 800b658:	2300      	movs	r3, #0
 800b65a:	62fb      	str	r3, [r7, #44]	@ 0x2c

    (void)prev_err;

#ifdef WOLFSSL_SMALL_STACK
    /* Allocate memory for decoded certificate. */
    cert = (DecodedCert*)XMALLOC(sizeof(DecodedCert), cm->heap,
 800b65c:	f44f 6097 	mov.w	r0, #1208	@ 0x4b8
 800b660:	f013 fa12 	bl	801ea88 <wolfSSL_Malloc>
 800b664:	62f8      	str	r0, [r7, #44]	@ 0x2c
         DYNAMIC_TYPE_DCERT);
    if (cert == NULL) {
 800b666:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800b668:	2b00      	cmp	r3, #0
 800b66a:	d104      	bne.n	800b676 <CM_VerifyBuffer_ex+0x38>
        ret = MEMORY_E;
 800b66c:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800b670:	637b      	str	r3, [r7, #52]	@ 0x34
        fatal = 1;
 800b672:	2301      	movs	r3, #1
 800b674:	633b      	str	r3, [r7, #48]	@ 0x30
    }
    if (ret == 0)
 800b676:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800b678:	2b00      	cmp	r3, #0
 800b67a:	d124      	bne.n	800b6c6 <CM_VerifyBuffer_ex+0x88>
#endif
    {
        /* Reset fields of decoded certificate. */
        XMEMSET(cert, 0, sizeof(DecodedCert));
 800b67c:	f44f 6297 	mov.w	r2, #1208	@ 0x4b8
 800b680:	2100      	movs	r1, #0
 800b682:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 800b684:	f01c ff20 	bl	80284c8 <memset>

        if (format == WOLFSSL_FILETYPE_PEM) {
 800b688:	683b      	ldr	r3, [r7, #0]
 800b68a:	2b01      	cmp	r3, #1
 800b68c:	d11b      	bne.n	800b6c6 <CM_VerifyBuffer_ex+0x88>
        #ifndef WOLFSSL_PEM_TO_DER
            ret = NOT_COMPILED_IN;
            fatal = 1;
        #else
            /* Convert to DER from PEM. */
            ret = PemToDer(buff, sz, CERT_TYPE, &der, cm->heap, NULL, NULL);
 800b68e:	68fb      	ldr	r3, [r7, #12]
 800b690:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800b692:	f107 021c 	add.w	r2, r7, #28
 800b696:	2100      	movs	r1, #0
 800b698:	9102      	str	r1, [sp, #8]
 800b69a:	2100      	movs	r1, #0
 800b69c:	9101      	str	r1, [sp, #4]
 800b69e:	9300      	str	r3, [sp, #0]
 800b6a0:	4613      	mov	r3, r2
 800b6a2:	2200      	movs	r2, #0
 800b6a4:	6879      	ldr	r1, [r7, #4]
 800b6a6:	68b8      	ldr	r0, [r7, #8]
 800b6a8:	f00d ff88 	bl	80195bc <PemToDer>
 800b6ac:	6378      	str	r0, [r7, #52]	@ 0x34
            if (ret != 0) {
 800b6ae:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800b6b0:	2b00      	cmp	r3, #0
 800b6b2:	d002      	beq.n	800b6ba <CM_VerifyBuffer_ex+0x7c>
                fatal = 1;
 800b6b4:	2301      	movs	r3, #1
 800b6b6:	633b      	str	r3, [r7, #48]	@ 0x30
 800b6b8:	e005      	b.n	800b6c6 <CM_VerifyBuffer_ex+0x88>
            }
            else {
                /* Replace buffer pointer and size with DER buffer. */
                buff = der->buffer;
 800b6ba:	69fb      	ldr	r3, [r7, #28]
 800b6bc:	681b      	ldr	r3, [r3, #0]
 800b6be:	60bb      	str	r3, [r7, #8]
                sz = (long)der->length;
 800b6c0:	69fb      	ldr	r3, [r7, #28]
 800b6c2:	689b      	ldr	r3, [r3, #8]
 800b6c4:	607b      	str	r3, [r7, #4]
            }
        #endif
        }
    }
    if (ret == 0) {
 800b6c6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800b6c8:	2b00      	cmp	r3, #0
 800b6ca:	d10f      	bne.n	800b6ec <CM_VerifyBuffer_ex+0xae>
        /* Create a decoded certificate with DER buffer. */
        InitDecodedCert(cert, buff, (word32)sz, cm->heap);
 800b6cc:	687a      	ldr	r2, [r7, #4]
 800b6ce:	68fb      	ldr	r3, [r7, #12]
 800b6d0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800b6d2:	68b9      	ldr	r1, [r7, #8]
 800b6d4:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 800b6d6:	f009 fd04 	bl	80150e2 <InitDecodedCert>
            wc_SetUnknownExtCallback(cert, cm->unknownExtCallback);
#endif

        /* Parse DER into decoded certificate fields and verify signature
         * against a known CA. */
        ret = ParseCertRelative(cert, CERT_TYPE, VERIFY, cm, NULL);
 800b6da:	2300      	movs	r3, #0
 800b6dc:	9300      	str	r3, [sp, #0]
 800b6de:	68fb      	ldr	r3, [r7, #12]
 800b6e0:	2201      	movs	r2, #1
 800b6e2:	2100      	movs	r1, #0
 800b6e4:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 800b6e6:	f00d f83c 	bl	8018762 <ParseCertRelative>
 800b6ea:	6378      	str	r0, [r7, #52]	@ 0x34

    (void)fatal;

#ifndef NO_WOLFSSL_CM_VERIFY
    /* Use callback to perform verification too if available. */
    if ((!fatal) && cm->verifyCallback) {
 800b6ec:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800b6ee:	2b00      	cmp	r3, #0
 800b6f0:	d140      	bne.n	800b774 <CM_VerifyBuffer_ex+0x136>
 800b6f2:	68fb      	ldr	r3, [r7, #12]
 800b6f4:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800b6f6:	2b00      	cmp	r3, #0
 800b6f8:	d03c      	beq.n	800b774 <CM_VerifyBuffer_ex+0x136>
    #endif
        buffer certBuf;

    #ifdef WOLFSSL_SMALL_STACK
        /* Allocate memory for object to hold arguments for callback. */
        args = (ProcPeerCertArgs*)XMALLOC(sizeof(ProcPeerCertArgs), cm->heap,
 800b6fa:	2028      	movs	r0, #40	@ 0x28
 800b6fc:	f013 f9c4 	bl	801ea88 <wolfSSL_Malloc>
 800b700:	62b8      	str	r0, [r7, #40]	@ 0x28
            DYNAMIC_TYPE_TMP_BUFFER);
        if (args == NULL) {
 800b702:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800b704:	2b00      	cmp	r3, #0
 800b706:	d104      	bne.n	800b712 <CM_VerifyBuffer_ex+0xd4>
            ret = MEMORY_E;
 800b708:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800b70c:	637b      	str	r3, [r7, #52]	@ 0x34
            fatal = 1;
 800b70e:	2301      	movs	r3, #1
 800b710:	633b      	str	r3, [r7, #48]	@ 0x30
        }
        if (!fatal)
 800b712:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800b714:	2b00      	cmp	r3, #0
 800b716:	d125      	bne.n	800b764 <CM_VerifyBuffer_ex+0x126>
    #endif
        {
            XMEMSET(args, 0, sizeof(ProcPeerCertArgs));
 800b718:	2228      	movs	r2, #40	@ 0x28
 800b71a:	2100      	movs	r1, #0
 800b71c:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 800b71e:	f01c fed3 	bl	80284c8 <memset>

            /* DER encoding. */
            certBuf.buffer = (byte*)buff;
 800b722:	68bb      	ldr	r3, [r7, #8]
 800b724:	617b      	str	r3, [r7, #20]
            certBuf.length = (unsigned int)sz;
 800b726:	687b      	ldr	r3, [r7, #4]
 800b728:	61bb      	str	r3, [r7, #24]

            /* One certificate available. */
            args->totalCerts = 1;
 800b72a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800b72c:	2201      	movs	r2, #1
 800b72e:	615a      	str	r2, [r3, #20]
            args->certs = &certBuf;
 800b730:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800b732:	f107 0214 	add.w	r2, r7, #20
 800b736:	601a      	str	r2, [r3, #0]
            args->dCert = cert;
 800b738:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800b73a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800b73c:	609a      	str	r2, [r3, #8]
            args->dCertInit = 1;
 800b73e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800b740:	f892 3026 	ldrb.w	r3, [r2, #38]	@ 0x26
 800b744:	f043 0304 	orr.w	r3, r3, #4
 800b748:	f882 3026 	strb.w	r3, [r2, #38]	@ 0x26

            /* Replace value in ret with an error value passed in. */
            if (prev_err != 0) {
 800b74c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800b74e:	2b00      	cmp	r3, #0
 800b750:	d001      	beq.n	800b756 <CM_VerifyBuffer_ex+0x118>
                ret = prev_err;
 800b752:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800b754:	637b      	str	r3, [r7, #52]	@ 0x34
            }
            /* Use callback to verify certificate. */
            ret = DoVerifyCallback(cm, NULL, ret, args);
 800b756:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800b758:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800b75a:	2100      	movs	r1, #0
 800b75c:	68f8      	ldr	r0, [r7, #12]
 800b75e:	f7ff fb8d 	bl	800ae7c <DoVerifyCallback>
 800b762:	6378      	str	r0, [r7, #52]	@ 0x34
        }
    #ifdef WOLFSSL_SMALL_STACK
        /* Dispose of allocated callback args. */
        XFREE(args, cm->heap, DYNAMIC_TYPE_TMP_BUFFER);
 800b764:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800b766:	627b      	str	r3, [r7, #36]	@ 0x24
 800b768:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800b76a:	2b00      	cmp	r3, #0
 800b76c:	d002      	beq.n	800b774 <CM_VerifyBuffer_ex+0x136>
 800b76e:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800b770:	f013 f9a6 	bl	801eac0 <wolfSSL_Free>
    #endif
    }
#endif

    /* Dispose of allocated memory. */
    FreeDecodedCert(cert);
 800b774:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 800b776:	f009 fd8d 	bl	8015294 <FreeDecodedCert>
    FreeDer(&der);
 800b77a:	f107 031c 	add.w	r3, r7, #28
 800b77e:	4618      	mov	r0, r3
 800b780:	f00d fbfc 	bl	8018f7c <FreeDer>
#ifdef WOLFSSL_SMALL_STACK
    XFREE(cert, cm->heap, DYNAMIC_TYPE_DCERT);
 800b784:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800b786:	623b      	str	r3, [r7, #32]
 800b788:	6a3b      	ldr	r3, [r7, #32]
 800b78a:	2b00      	cmp	r3, #0
 800b78c:	d002      	beq.n	800b794 <CM_VerifyBuffer_ex+0x156>
 800b78e:	6a38      	ldr	r0, [r7, #32]
 800b790:	f013 f996 	bl	801eac0 <wolfSSL_Free>
#endif

    /* Convert the ret value to a return value. */
    return (ret == 0) ? WOLFSSL_SUCCESS : ret;
 800b794:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800b796:	2b00      	cmp	r3, #0
 800b798:	d001      	beq.n	800b79e <CM_VerifyBuffer_ex+0x160>
 800b79a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800b79c:	e000      	b.n	800b7a0 <CM_VerifyBuffer_ex+0x162>
 800b79e:	2301      	movs	r3, #1
}
 800b7a0:	4618      	mov	r0, r3
 800b7a2:	3738      	adds	r7, #56	@ 0x38
 800b7a4:	46bd      	mov	sp, r7
 800b7a6:	bd80      	pop	{r7, pc}

0800b7a8 <wolfSSL_CertManagerVerifyBuffer>:
 * @return  NOT_COMPILED_IN when converting from PEM to DER is not a feature of
 *          the wolfSSL build.
 */
int wolfSSL_CertManagerVerifyBuffer(WOLFSSL_CERT_MANAGER* cm,
    const unsigned char* buff, long sz, int format)
{
 800b7a8:	b580      	push	{r7, lr}
 800b7aa:	b088      	sub	sp, #32
 800b7ac:	af02      	add	r7, sp, #8
 800b7ae:	60f8      	str	r0, [r7, #12]
 800b7b0:	60b9      	str	r1, [r7, #8]
 800b7b2:	607a      	str	r2, [r7, #4]
 800b7b4:	603b      	str	r3, [r7, #0]
    int ret;

    WOLFSSL_ENTER("wolfSSL_CertManagerVerifyBuffer");

    /* Validate parameters. */
    if ((cm == NULL) || (buff == NULL) || (sz <= 0)) {
 800b7b6:	68fb      	ldr	r3, [r7, #12]
 800b7b8:	2b00      	cmp	r3, #0
 800b7ba:	d005      	beq.n	800b7c8 <wolfSSL_CertManagerVerifyBuffer+0x20>
 800b7bc:	68bb      	ldr	r3, [r7, #8]
 800b7be:	2b00      	cmp	r3, #0
 800b7c0:	d002      	beq.n	800b7c8 <wolfSSL_CertManagerVerifyBuffer+0x20>
 800b7c2:	687b      	ldr	r3, [r7, #4]
 800b7c4:	2b00      	cmp	r3, #0
 800b7c6:	dc03      	bgt.n	800b7d0 <wolfSSL_CertManagerVerifyBuffer+0x28>
        ret = BAD_FUNC_ARG;
 800b7c8:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800b7cc:	617b      	str	r3, [r7, #20]
 800b7ce:	e011      	b.n	800b7f4 <wolfSSL_CertManagerVerifyBuffer+0x4c>
    }
    else if ((format != WOLFSSL_FILETYPE_ASN1) &&
 800b7d0:	683b      	ldr	r3, [r7, #0]
 800b7d2:	2b02      	cmp	r3, #2
 800b7d4:	d005      	beq.n	800b7e2 <wolfSSL_CertManagerVerifyBuffer+0x3a>
 800b7d6:	683b      	ldr	r3, [r7, #0]
 800b7d8:	2b01      	cmp	r3, #1
 800b7da:	d002      	beq.n	800b7e2 <wolfSSL_CertManagerVerifyBuffer+0x3a>
             (format != WOLFSSL_FILETYPE_PEM)) {
        ret = WOLFSSL_BAD_FILETYPE;
 800b7dc:	4b08      	ldr	r3, [pc, #32]	@ (800b800 <wolfSSL_CertManagerVerifyBuffer+0x58>)
 800b7de:	617b      	str	r3, [r7, #20]
 800b7e0:	e008      	b.n	800b7f4 <wolfSSL_CertManagerVerifyBuffer+0x4c>
    }
    else {
        /* No previous error. */
        ret = CM_VerifyBuffer_ex(cm, buff, sz, format, 0);
 800b7e2:	2300      	movs	r3, #0
 800b7e4:	9300      	str	r3, [sp, #0]
 800b7e6:	683b      	ldr	r3, [r7, #0]
 800b7e8:	687a      	ldr	r2, [r7, #4]
 800b7ea:	68b9      	ldr	r1, [r7, #8]
 800b7ec:	68f8      	ldr	r0, [r7, #12]
 800b7ee:	f7ff ff26 	bl	800b63e <CM_VerifyBuffer_ex>
 800b7f2:	6178      	str	r0, [r7, #20]
    }

    return ret;
 800b7f4:	697b      	ldr	r3, [r7, #20]
}
 800b7f6:	4618      	mov	r0, r3
 800b7f8:	3718      	adds	r7, #24
 800b7fa:	46bd      	mov	sp, r7
 800b7fc:	bd80      	pop	{r7, pc}
 800b7fe:	bf00      	nop
 800b800:	fffffe32 	.word	0xfffffe32

0800b804 <ClientSessionToSession>:
    #endif /* SESSION_STATS */

#else  /* NO_SESSION_CACHE */

WOLFSSL_SESSION* ClientSessionToSession(const WOLFSSL_SESSION* session)
{
 800b804:	b480      	push	{r7}
 800b806:	b083      	sub	sp, #12
 800b808:	af00      	add	r7, sp, #0
 800b80a:	6078      	str	r0, [r7, #4]
    return (WOLFSSL_SESSION*)session;
 800b80c:	687b      	ldr	r3, [r7, #4]
}
 800b80e:	4618      	mov	r0, r3
 800b810:	370c      	adds	r7, #12
 800b812:	46bd      	mov	sp, r7
 800b814:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b818:	4770      	bx	lr

0800b81a <wolfSSL_FreeSession>:
    }
    return copy;
}

void wolfSSL_FreeSession(WOLFSSL_CTX* ctx, WOLFSSL_SESSION* session)
{
 800b81a:	b580      	push	{r7, lr}
 800b81c:	b086      	sub	sp, #24
 800b81e:	af00      	add	r7, sp, #0
 800b820:	6078      	str	r0, [r7, #4]
 800b822:	6039      	str	r1, [r7, #0]
    session = ClientSessionToSession(session);
 800b824:	6838      	ldr	r0, [r7, #0]
 800b826:	f7ff ffed 	bl	800b804 <ClientSessionToSession>
 800b82a:	6038      	str	r0, [r7, #0]
    if (session == NULL)
 800b82c:	683b      	ldr	r3, [r7, #0]
 800b82e:	2b00      	cmp	r3, #0
 800b830:	d02f      	beq.n	800b892 <wolfSSL_FreeSession+0x78>

    (void)ctx;

    WOLFSSL_ENTER("wolfSSL_FreeSession");

    if (session->ref.count > 0) {
 800b832:	683b      	ldr	r3, [r7, #0]
 800b834:	685b      	ldr	r3, [r3, #4]
 800b836:	2b00      	cmp	r3, #0
 800b838:	dd12      	ble.n	800b860 <wolfSSL_FreeSession+0x46>
        int ret;
        int isZero;
        wolfSSL_RefDec(&session->ref, &isZero, &ret);
 800b83a:	683b      	ldr	r3, [r7, #0]
 800b83c:	3304      	adds	r3, #4
 800b83e:	2101      	movs	r1, #1
 800b840:	4618      	mov	r0, r3
 800b842:	f7ff fc6f 	bl	800b124 <wolfSSL_Atomic_Int_FetchSub>
 800b846:	6178      	str	r0, [r7, #20]
 800b848:	697b      	ldr	r3, [r7, #20]
 800b84a:	2b01      	cmp	r3, #1
 800b84c:	bf0c      	ite	eq
 800b84e:	2301      	moveq	r3, #1
 800b850:	2300      	movne	r3, #0
 800b852:	b2db      	uxtb	r3, r3
 800b854:	60bb      	str	r3, [r7, #8]
 800b856:	2300      	movs	r3, #0
 800b858:	60fb      	str	r3, [r7, #12]
        (void)ret;
        if (!isZero) {
 800b85a:	68bb      	ldr	r3, [r7, #8]
 800b85c:	2b00      	cmp	r3, #0
 800b85e:	d01a      	beq.n	800b896 <wolfSSL_FreeSession+0x7c>
#ifdef HAVE_EX_DATA_CLEANUP_HOOKS
    wolfSSL_CRYPTO_cleanup_ex_data(&session->ex_data);
#endif

    /* Make sure masterSecret is zeroed. */
    ForceZero(session->masterSecret, SECRET_LEN);
 800b860:	683b      	ldr	r3, [r7, #0]
 800b862:	3361      	adds	r3, #97	@ 0x61
 800b864:	2130      	movs	r1, #48	@ 0x30
 800b866:	4618      	mov	r0, r3
 800b868:	f7ff fc71 	bl	800b14e <ForceZero>
    /* Session ID is sensitive information too. */
    ForceZero(session->sessionID, ID_LEN);
 800b86c:	683b      	ldr	r3, [r7, #0]
 800b86e:	3340      	adds	r3, #64	@ 0x40
 800b870:	2120      	movs	r1, #32
 800b872:	4618      	mov	r0, r3
 800b874:	f7ff fc6b 	bl	800b14e <ForceZero>

    if (session->type == WOLFSSL_SESSION_TYPE_HEAP) {
 800b878:	683b      	ldr	r3, [r7, #0]
 800b87a:	781b      	ldrb	r3, [r3, #0]
 800b87c:	2b03      	cmp	r3, #3
 800b87e:	d10b      	bne.n	800b898 <wolfSSL_FreeSession+0x7e>
        XFREE(session, session->heap, DYNAMIC_TYPE_SESSION);
 800b880:	683b      	ldr	r3, [r7, #0]
 800b882:	613b      	str	r3, [r7, #16]
 800b884:	693b      	ldr	r3, [r7, #16]
 800b886:	2b00      	cmp	r3, #0
 800b888:	d006      	beq.n	800b898 <wolfSSL_FreeSession+0x7e>
 800b88a:	6938      	ldr	r0, [r7, #16]
 800b88c:	f013 f918 	bl	801eac0 <wolfSSL_Free>
 800b890:	e002      	b.n	800b898 <wolfSSL_FreeSession+0x7e>
        return;
 800b892:	bf00      	nop
 800b894:	e000      	b.n	800b898 <wolfSSL_FreeSession+0x7e>
            return;
 800b896:	bf00      	nop
    }
}
 800b898:	3718      	adds	r7, #24
 800b89a:	46bd      	mov	sp, r7
 800b89c:	bd80      	pop	{r7, pc}
	...

0800b8a0 <wolfssl_get_global_rng>:
#if defined(OPENSSL_EXTRA) && defined(HAVE_HASHDRBG)
static WOLFSSL_DRBG_CTX* gDrbgDefCtx = NULL;
#endif

WC_RNG* wolfssl_get_global_rng(void)
{
 800b8a0:	b480      	push	{r7}
 800b8a2:	b083      	sub	sp, #12
 800b8a4:	af00      	add	r7, sp, #0
    WC_RNG* ret = NULL;
 800b8a6:	2300      	movs	r3, #0
 800b8a8:	607b      	str	r3, [r7, #4]

    if (initGlobalRNG == 0)
 800b8aa:	4b06      	ldr	r3, [pc, #24]	@ (800b8c4 <wolfssl_get_global_rng+0x24>)
 800b8ac:	681b      	ldr	r3, [r3, #0]
 800b8ae:	2b00      	cmp	r3, #0
 800b8b0:	d001      	beq.n	800b8b6 <wolfssl_get_global_rng+0x16>
        WOLFSSL_MSG("Global RNG no Init");
    else
        ret = &globalRNG;
 800b8b2:	4b05      	ldr	r3, [pc, #20]	@ (800b8c8 <wolfssl_get_global_rng+0x28>)
 800b8b4:	607b      	str	r3, [r7, #4]

    return ret;
 800b8b6:	687b      	ldr	r3, [r7, #4]
}
 800b8b8:	4618      	mov	r0, r3
 800b8ba:	370c      	adds	r7, #12
 800b8bc:	46bd      	mov	sp, r7
 800b8be:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b8c2:	4770      	bx	lr
 800b8c4:	200028b8 	.word	0x200028b8
 800b8c8:	200028a8 	.word	0x200028a8

0800b8cc <wolfSSL_BN_free>:
 * bn is unusable after this call.
 *
 * @param [in, out] bn  Big number to free.
 */
void wolfSSL_BN_free(WOLFSSL_BIGNUM* bn)
{
 800b8cc:	b580      	push	{r7, lr}
 800b8ce:	b084      	sub	sp, #16
 800b8d0:	af00      	add	r7, sp, #0
 800b8d2:	6078      	str	r0, [r7, #4]
#ifdef WOLFSSL_DEBUG_OPENSSL
    WOLFSSL_ENTER("wolfSSL_BN_free");
#endif

    /* Validate parameter. */
    if (bn != NULL) {
 800b8d4:	687b      	ldr	r3, [r7, #4]
 800b8d6:	2b00      	cmp	r3, #0
 800b8d8:	d010      	beq.n	800b8fc <wolfSSL_BN_free+0x30>
        /* Cleanup any internal representation. */
        if (bn->internal != NULL) {
 800b8da:	687b      	ldr	r3, [r7, #4]
 800b8dc:	685b      	ldr	r3, [r3, #4]
 800b8de:	2b00      	cmp	r3, #0
 800b8e0:	d004      	beq.n	800b8ec <wolfSSL_BN_free+0x20>
            /* Free MP integer. */
            mp_free(&bn->mpi);
 800b8e2:	687b      	ldr	r3, [r7, #4]
 800b8e4:	3308      	adds	r3, #8
 800b8e6:	4618      	mov	r0, r3
 800b8e8:	f01a ff6c 	bl	80267c4 <mp_free>
        }
        /* Dispose of big number object. */
        XFREE(bn, NULL, DYNAMIC_TYPE_BIGINT);
 800b8ec:	687b      	ldr	r3, [r7, #4]
 800b8ee:	60fb      	str	r3, [r7, #12]
 800b8f0:	68fb      	ldr	r3, [r7, #12]
 800b8f2:	2b00      	cmp	r3, #0
 800b8f4:	d002      	beq.n	800b8fc <wolfSSL_BN_free+0x30>
 800b8f6:	68f8      	ldr	r0, [r7, #12]
 800b8f8:	f013 f8e2 	bl	801eac0 <wolfSSL_Free>
        /* bn = NULL, don't try to access or double free it */
    }
}
 800b8fc:	bf00      	nop
 800b8fe:	3710      	adds	r7, #16
 800b900:	46bd      	mov	sp, r7
 800b902:	bd80      	pop	{r7, pc}

0800b904 <wolfSSL_BN_clear_free>:
 * bn is unusable after this call.
 *
 * @param [in, out] bn  Big number to clear and free.
 */
void wolfSSL_BN_clear_free(WOLFSSL_BIGNUM* bn)
{
 800b904:	b580      	push	{r7, lr}
 800b906:	b082      	sub	sp, #8
 800b908:	af00      	add	r7, sp, #0
 800b90a:	6078      	str	r0, [r7, #4]
#ifdef WOLFSSL_DEBUG_OPENSSL
    WOLFSSL_ENTER("wolfSSL_BN_clear_free");
#endif

    /* Validate parameter. */
    if (bn != NULL) {
 800b90c:	687b      	ldr	r3, [r7, #4]
 800b90e:	2b00      	cmp	r3, #0
 800b910:	d00b      	beq.n	800b92a <wolfSSL_BN_clear_free+0x26>
        /* Check for internal representation. */
        if (bn->internal != NULL) {
 800b912:	687b      	ldr	r3, [r7, #4]
 800b914:	685b      	ldr	r3, [r3, #4]
 800b916:	2b00      	cmp	r3, #0
 800b918:	d004      	beq.n	800b924 <wolfSSL_BN_clear_free+0x20>
            /* Zeroize MP integer. */
            mp_forcezero((mp_int*)bn->internal);
 800b91a:	687b      	ldr	r3, [r7, #4]
 800b91c:	685b      	ldr	r3, [r3, #4]
 800b91e:	4618      	mov	r0, r3
 800b920:	f01a ff2c 	bl	802677c <mp_forcezero>
        }
        /* Dispose of big number. */
        wolfSSL_BN_free(bn);
 800b924:	6878      	ldr	r0, [r7, #4]
 800b926:	f7ff ffd1 	bl	800b8cc <wolfSSL_BN_free>
    }
}
 800b92a:	bf00      	nop
 800b92c:	3708      	adds	r7, #8
 800b92e:	46bd      	mov	sp, r7
 800b930:	bd80      	pop	{r7, pc}
	...

0800b934 <wolfSSL_BN_free_one>:
    }

    return one;
}

static void wolfSSL_BN_free_one(void) {
 800b934:	b580      	push	{r7, lr}
 800b936:	af00      	add	r7, sp, #0
    wolfSSL_BN_free(bn_one);
 800b938:	4b04      	ldr	r3, [pc, #16]	@ (800b94c <wolfSSL_BN_free_one+0x18>)
 800b93a:	681b      	ldr	r3, [r3, #0]
 800b93c:	4618      	mov	r0, r3
 800b93e:	f7ff ffc5 	bl	800b8cc <wolfSSL_BN_free>
    bn_one = NULL;
 800b942:	4b02      	ldr	r3, [pc, #8]	@ (800b94c <wolfSSL_BN_free_one+0x18>)
 800b944:	2200      	movs	r2, #0
 800b946:	601a      	str	r2, [r3, #0]
}
 800b948:	bf00      	nop
 800b94a:	bd80      	pop	{r7, pc}
 800b94c:	200028d4 	.word	0x200028d4

0800b950 <wolfSSL_ASN1_INTEGER_free>:
/* Free the ASN.1 INTEGER object and any dynamically allocated data.
 *
 * @param [in, out] in  ASN.1 INTEGER object.
 */
void wolfSSL_ASN1_INTEGER_free(WOLFSSL_ASN1_INTEGER* in)
{
 800b950:	b580      	push	{r7, lr}
 800b952:	b084      	sub	sp, #16
 800b954:	af00      	add	r7, sp, #0
 800b956:	6078      	str	r0, [r7, #4]
    if ((in != NULL) && (in->isDynamic)) {
 800b958:	687b      	ldr	r3, [r7, #4]
 800b95a:	2b00      	cmp	r3, #0
 800b95c:	d010      	beq.n	800b980 <wolfSSL_ASN1_INTEGER_free+0x30>
 800b95e:	687b      	ldr	r3, [r7, #4]
 800b960:	f893 3020 	ldrb.w	r3, [r3, #32]
 800b964:	f003 0301 	and.w	r3, r3, #1
 800b968:	b2db      	uxtb	r3, r3
 800b96a:	2b00      	cmp	r3, #0
 800b96c:	d008      	beq.n	800b980 <wolfSSL_ASN1_INTEGER_free+0x30>
        /* Dispose of any data allocated in INTEGER. */
        XFREE(in->data, NULL, DYNAMIC_TYPE_OPENSSL);
 800b96e:	687b      	ldr	r3, [r7, #4]
 800b970:	699b      	ldr	r3, [r3, #24]
 800b972:	60fb      	str	r3, [r7, #12]
 800b974:	68fb      	ldr	r3, [r7, #12]
 800b976:	2b00      	cmp	r3, #0
 800b978:	d002      	beq.n	800b980 <wolfSSL_ASN1_INTEGER_free+0x30>
 800b97a:	68f8      	ldr	r0, [r7, #12]
 800b97c:	f013 f8a0 	bl	801eac0 <wolfSSL_Free>
    }
    /* Dispose of the ASN.1 INTEGER object. */
    XFREE(in, NULL, DYNAMIC_TYPE_OPENSSL);
 800b980:	687b      	ldr	r3, [r7, #4]
 800b982:	60bb      	str	r3, [r7, #8]
 800b984:	68bb      	ldr	r3, [r7, #8]
 800b986:	2b00      	cmp	r3, #0
 800b988:	d002      	beq.n	800b990 <wolfSSL_ASN1_INTEGER_free+0x40>
 800b98a:	68b8      	ldr	r0, [r7, #8]
 800b98c:	f013 f898 	bl	801eac0 <wolfSSL_Free>
}
 800b990:	bf00      	nop
 800b992:	3710      	adds	r7, #16
 800b994:	46bd      	mov	sp, r7
 800b996:	bd80      	pop	{r7, pc}

0800b998 <wolfSSL_ASN1_OBJECT_new>:
 *
 * @return  ASN.1 OBJECT_ID object on success.
 * @return  NULL when dynamic memory allocation fails.
 */
WOLFSSL_ASN1_OBJECT* wolfSSL_ASN1_OBJECT_new(void)
{
 800b998:	b580      	push	{r7, lr}
 800b99a:	b082      	sub	sp, #8
 800b99c:	af00      	add	r7, sp, #0
    WOLFSSL_ASN1_OBJECT* obj;

    /* Allocate memory for new ASN.1 OBJECT. */
    obj = (WOLFSSL_ASN1_OBJECT*)XMALLOC(sizeof(WOLFSSL_ASN1_OBJECT), NULL,
 800b99e:	20b0      	movs	r0, #176	@ 0xb0
 800b9a0:	f013 f872 	bl	801ea88 <wolfSSL_Malloc>
 800b9a4:	6078      	str	r0, [r7, #4]
        DYNAMIC_TYPE_ASN1);
    if (obj != NULL) {
 800b9a6:	687b      	ldr	r3, [r7, #4]
 800b9a8:	2b00      	cmp	r3, #0
 800b9aa:	d013      	beq.n	800b9d4 <wolfSSL_ASN1_OBJECT_new+0x3c>
        XMEMSET(obj, 0, sizeof(WOLFSSL_ASN1_OBJECT));
 800b9ac:	22b0      	movs	r2, #176	@ 0xb0
 800b9ae:	2100      	movs	r1, #0
 800b9b0:	6878      	ldr	r0, [r7, #4]
 800b9b2:	f01c fd89 	bl	80284c8 <memset>
        /* Setup pointers. */
        obj->d.ia5 = &(obj->d.ia5_internal);
 800b9b6:	687b      	ldr	r3, [r7, #4]
 800b9b8:	f103 0250 	add.w	r2, r3, #80	@ 0x50
 800b9bc:	687b      	ldr	r3, [r7, #4]
 800b9be:	f8c3 20a8 	str.w	r2, [r3, #168]	@ 0xa8
    #if defined(OPENSSL_ALL)
        obj->d.iPAddress = &(obj->d.iPAddress_internal);
    #endif
        /* Object was allocated. */
        obj->dynamic |= WOLFSSL_ASN1_DYNAMIC;
 800b9c2:	687b      	ldr	r3, [r7, #4]
 800b9c4:	f893 3048 	ldrb.w	r3, [r3, #72]	@ 0x48
 800b9c8:	f043 0301 	orr.w	r3, r3, #1
 800b9cc:	b2da      	uxtb	r2, r3
 800b9ce:	687b      	ldr	r3, [r7, #4]
 800b9d0:	f883 2048 	strb.w	r2, [r3, #72]	@ 0x48
    }

    return obj;
 800b9d4:	687b      	ldr	r3, [r7, #4]
}
 800b9d6:	4618      	mov	r0, r3
 800b9d8:	3708      	adds	r7, #8
 800b9da:	46bd      	mov	sp, r7
 800b9dc:	bd80      	pop	{r7, pc}

0800b9de <wolfSSL_ASN1_OBJECT_free>:
 * Do not use obj after calling this function.
 *
 * @param [in, out] obj  ASN.1 OBJECT_ID object.
 */
void wolfSSL_ASN1_OBJECT_free(WOLFSSL_ASN1_OBJECT* obj)
{
 800b9de:	b580      	push	{r7, lr}
 800b9e0:	b084      	sub	sp, #16
 800b9e2:	af00      	add	r7, sp, #0
 800b9e4:	6078      	str	r0, [r7, #4]
    if (obj != NULL) {
 800b9e6:	687b      	ldr	r3, [r7, #4]
 800b9e8:	2b00      	cmp	r3, #0
 800b9ea:	d02d      	beq.n	800ba48 <wolfSSL_ASN1_OBJECT_free+0x6a>
        /* Check for dynamically allocated copy of encoded data. */
        if ((obj->dynamic & WOLFSSL_ASN1_DYNAMIC_DATA) != 0) {
 800b9ec:	687b      	ldr	r3, [r7, #4]
 800b9ee:	f893 3048 	ldrb.w	r3, [r3, #72]	@ 0x48
 800b9f2:	f003 0302 	and.w	r3, r3, #2
 800b9f6:	2b00      	cmp	r3, #0
 800b9f8:	d00b      	beq.n	800ba12 <wolfSSL_ASN1_OBJECT_free+0x34>
        #ifdef WOLFSSL_DEBUG_OPENSSL
            WOLFSSL_MSG("Freeing ASN1 data");
        #endif
            XFREE((void*)obj->obj, obj->heap, DYNAMIC_TYPE_ASN1);
 800b9fa:	687b      	ldr	r3, [r7, #4]
 800b9fc:	685b      	ldr	r3, [r3, #4]
 800b9fe:	60fb      	str	r3, [r7, #12]
 800ba00:	68fb      	ldr	r3, [r7, #12]
 800ba02:	2b00      	cmp	r3, #0
 800ba04:	d002      	beq.n	800ba0c <wolfSSL_ASN1_OBJECT_free+0x2e>
 800ba06:	68f8      	ldr	r0, [r7, #12]
 800ba08:	f013 f85a 	bl	801eac0 <wolfSSL_Free>
            obj->obj = NULL;
 800ba0c:	687b      	ldr	r3, [r7, #4]
 800ba0e:	2200      	movs	r2, #0
 800ba10:	605a      	str	r2, [r3, #4]
        }
    #if defined(OPENSSL_EXTRA)
        /* Check for path length ASN.1 INTEGER - X.509 extension. */
        if (obj->pathlen != NULL) {
 800ba12:	687b      	ldr	r3, [r7, #4]
 800ba14:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800ba16:	2b00      	cmp	r3, #0
 800ba18:	d007      	beq.n	800ba2a <wolfSSL_ASN1_OBJECT_free+0x4c>
            wolfSSL_ASN1_INTEGER_free(obj->pathlen);
 800ba1a:	687b      	ldr	r3, [r7, #4]
 800ba1c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800ba1e:	4618      	mov	r0, r3
 800ba20:	f7ff ff96 	bl	800b950 <wolfSSL_ASN1_INTEGER_free>
            obj->pathlen = NULL;
 800ba24:	687b      	ldr	r3, [r7, #4]
 800ba26:	2200      	movs	r2, #0
 800ba28:	645a      	str	r2, [r3, #68]	@ 0x44
        }
    #endif
        /* Check whether object was dynamically allocated. */
        if ((obj->dynamic & WOLFSSL_ASN1_DYNAMIC) != 0) {
 800ba2a:	687b      	ldr	r3, [r7, #4]
 800ba2c:	f893 3048 	ldrb.w	r3, [r3, #72]	@ 0x48
 800ba30:	f003 0301 	and.w	r3, r3, #1
 800ba34:	2b00      	cmp	r3, #0
 800ba36:	d007      	beq.n	800ba48 <wolfSSL_ASN1_OBJECT_free+0x6a>
    #ifdef WOLFSSL_DEBUG_OPENSSL
            WOLFSSL_MSG("Freeing ASN1 OBJECT");
    #endif
            XFREE(obj, NULL, DYNAMIC_TYPE_ASN1);
 800ba38:	687b      	ldr	r3, [r7, #4]
 800ba3a:	60bb      	str	r3, [r7, #8]
 800ba3c:	68bb      	ldr	r3, [r7, #8]
 800ba3e:	2b00      	cmp	r3, #0
 800ba40:	d002      	beq.n	800ba48 <wolfSSL_ASN1_OBJECT_free+0x6a>
 800ba42:	68b8      	ldr	r0, [r7, #8]
 800ba44:	f013 f83c 	bl	801eac0 <wolfSSL_Free>
        }
    }
}
 800ba48:	bf00      	nop
 800ba4a:	3710      	adds	r7, #16
 800ba4c:	46bd      	mov	sp, r7
 800ba4e:	bd80      	pop	{r7, pc}

0800ba50 <wolfSSL_ASN1_STRING_new>:
 *
 * @return  New ASN.1 STRING object on success.
 * @return  NULL when dynamic memory allocation fails.
 */
WOLFSSL_ASN1_STRING* wolfSSL_ASN1_STRING_new(void)
{
 800ba50:	b580      	push	{r7, lr}
 800ba52:	b082      	sub	sp, #8
 800ba54:	af00      	add	r7, sp, #0

#ifdef WOLFSSL_DEBUG_OPENSSL
    WOLFSSL_ENTER("wolfSSL_ASN1_STRING_new");
#endif

    asn1 = (WOLFSSL_ASN1_STRING*)XMALLOC(sizeof(WOLFSSL_ASN1_STRING), NULL,
 800ba56:	2058      	movs	r0, #88	@ 0x58
 800ba58:	f013 f816 	bl	801ea88 <wolfSSL_Malloc>
 800ba5c:	6078      	str	r0, [r7, #4]
        DYNAMIC_TYPE_OPENSSL);
    if (asn1 != NULL) {
 800ba5e:	687b      	ldr	r3, [r7, #4]
 800ba60:	2b00      	cmp	r3, #0
 800ba62:	d004      	beq.n	800ba6e <wolfSSL_ASN1_STRING_new+0x1e>
        XMEMSET(asn1, 0, sizeof(WOLFSSL_ASN1_STRING));
 800ba64:	2258      	movs	r2, #88	@ 0x58
 800ba66:	2100      	movs	r1, #0
 800ba68:	6878      	ldr	r0, [r7, #4]
 800ba6a:	f01c fd2d 	bl	80284c8 <memset>
    }

    return asn1;
 800ba6e:	687b      	ldr	r3, [r7, #4]
}
 800ba70:	4618      	mov	r0, r3
 800ba72:	3708      	adds	r7, #8
 800ba74:	46bd      	mov	sp, r7
 800ba76:	bd80      	pop	{r7, pc}

0800ba78 <wolfSSL_ASN1_STRING_type_new>:
 * @param [in] type  Encoding type.
 * @return  New ASN.1 STRING object on success.
 * @return  NULL when dynamic memory allocation fails.
 */
WOLFSSL_ASN1_STRING* wolfSSL_ASN1_STRING_type_new(int type)
{
 800ba78:	b580      	push	{r7, lr}
 800ba7a:	b084      	sub	sp, #16
 800ba7c:	af00      	add	r7, sp, #0
 800ba7e:	6078      	str	r0, [r7, #4]

#ifdef WOLFSSL_DEBUG_OPENSSL
    WOLFSSL_ENTER("wolfSSL_ASN1_STRING_type_new");
#endif

    asn1 = wolfSSL_ASN1_STRING_new();
 800ba80:	f7ff ffe6 	bl	800ba50 <wolfSSL_ASN1_STRING_new>
 800ba84:	60f8      	str	r0, [r7, #12]
    if (asn1 != NULL) {
 800ba86:	68fb      	ldr	r3, [r7, #12]
 800ba88:	2b00      	cmp	r3, #0
 800ba8a:	d002      	beq.n	800ba92 <wolfSSL_ASN1_STRING_type_new+0x1a>
        asn1->type = type;
 800ba8c:	68fb      	ldr	r3, [r7, #12]
 800ba8e:	687a      	ldr	r2, [r7, #4]
 800ba90:	645a      	str	r2, [r3, #68]	@ 0x44
    }

    return asn1;
 800ba92:	68fb      	ldr	r3, [r7, #12]
}
 800ba94:	4618      	mov	r0, r3
 800ba96:	3710      	adds	r7, #16
 800ba98:	46bd      	mov	sp, r7
 800ba9a:	bd80      	pop	{r7, pc}

0800ba9c <wolfSSL_ASN1_STRING_free>:
/* Dispose of ASN.1 STRING object.
 *
 * @param [in, out] asn1  ASN.1 STRING object.
 */
void wolfSSL_ASN1_STRING_free(WOLFSSL_ASN1_STRING* asn1)
{
 800ba9c:	b580      	push	{r7, lr}
 800ba9e:	b084      	sub	sp, #16
 800baa0:	af00      	add	r7, sp, #0
 800baa2:	6078      	str	r0, [r7, #4]
#ifdef WOLFSSL_DEBUG_OPENSSL
    WOLFSSL_ENTER("wolfSSL_ASN1_STRING_free");
#endif

    /* Check we have an object to free. */
    if (asn1 != NULL) {
 800baa4:	687b      	ldr	r3, [r7, #4]
 800baa6:	2b00      	cmp	r3, #0
 800baa8:	d014      	beq.n	800bad4 <wolfSSL_ASN1_STRING_free+0x38>
        /* Dispose of dynamic data. */
        if ((asn1->length > 0) && asn1->isDynamic) {
 800baaa:	687b      	ldr	r3, [r7, #4]
 800baac:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800baae:	2b00      	cmp	r3, #0
 800bab0:	dd10      	ble.n	800bad4 <wolfSSL_ASN1_STRING_free+0x38>
 800bab2:	687b      	ldr	r3, [r7, #4]
 800bab4:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
 800bab8:	f003 0301 	and.w	r3, r3, #1
 800babc:	b2db      	uxtb	r3, r3
 800babe:	2b00      	cmp	r3, #0
 800bac0:	d008      	beq.n	800bad4 <wolfSSL_ASN1_STRING_free+0x38>
            XFREE(asn1->data, NULL, DYNAMIC_TYPE_OPENSSL);
 800bac2:	687b      	ldr	r3, [r7, #4]
 800bac4:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800bac6:	60fb      	str	r3, [r7, #12]
 800bac8:	68fb      	ldr	r3, [r7, #12]
 800baca:	2b00      	cmp	r3, #0
 800bacc:	d002      	beq.n	800bad4 <wolfSSL_ASN1_STRING_free+0x38>
 800bace:	68f8      	ldr	r0, [r7, #12]
 800bad0:	f012 fff6 	bl	801eac0 <wolfSSL_Free>
        }
    }
    /* Dispose of ASN.1 STRING object. */
    XFREE(asn1, NULL, DYNAMIC_TYPE_OPENSSL);
 800bad4:	687b      	ldr	r3, [r7, #4]
 800bad6:	60bb      	str	r3, [r7, #8]
 800bad8:	68bb      	ldr	r3, [r7, #8]
 800bada:	2b00      	cmp	r3, #0
 800badc:	d002      	beq.n	800bae4 <wolfSSL_ASN1_STRING_free+0x48>
 800bade:	68b8      	ldr	r0, [r7, #8]
 800bae0:	f012 ffee 	bl	801eac0 <wolfSSL_Free>
}
 800bae4:	bf00      	nop
 800bae6:	3710      	adds	r7, #16
 800bae8:	46bd      	mov	sp, r7
 800baea:	bd80      	pop	{r7, pc}

0800baec <wolfSSL_ASN1_STRING_type>:
 * @param [in] asn1  ASN.1 STRING object.
 * @return  Encoding type on success.
 * @return  0 when asn1 is NULL or no encoding set.
 */
int wolfSSL_ASN1_STRING_type(const WOLFSSL_ASN1_STRING* asn1)
{
 800baec:	b480      	push	{r7}
 800baee:	b085      	sub	sp, #20
 800baf0:	af00      	add	r7, sp, #0
 800baf2:	6078      	str	r0, [r7, #4]
    int type = 0;
 800baf4:	2300      	movs	r3, #0
 800baf6:	60fb      	str	r3, [r7, #12]

#ifdef WOLFSSL_DEBUG_OPENSSL
    WOLFSSL_ENTER("wolfSSL_ASN1_STRING_type");
#endif

    if (asn1 != NULL) {
 800baf8:	687b      	ldr	r3, [r7, #4]
 800bafa:	2b00      	cmp	r3, #0
 800bafc:	d002      	beq.n	800bb04 <wolfSSL_ASN1_STRING_type+0x18>
        type = asn1->type;
 800bafe:	687b      	ldr	r3, [r7, #4]
 800bb00:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800bb02:	60fb      	str	r3, [r7, #12]
    }

    return type;
 800bb04:	68fb      	ldr	r3, [r7, #12]
}
 800bb06:	4618      	mov	r0, r3
 800bb08:	3714      	adds	r7, #20
 800bb0a:	46bd      	mov	sp, r7
 800bb0c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bb10:	4770      	bx	lr

0800bb12 <wolfSSL_ASN1_STRING_data>:
 * @param [in] asn  ASN.1 STRING object.
 * @return  Buffer with string on success.
 * @return  NULL when asn is NULL or no data set.
 */
unsigned char* wolfSSL_ASN1_STRING_data(WOLFSSL_ASN1_STRING* asn)
{
 800bb12:	b480      	push	{r7}
 800bb14:	b085      	sub	sp, #20
 800bb16:	af00      	add	r7, sp, #0
 800bb18:	6078      	str	r0, [r7, #4]
    char* data = NULL;
 800bb1a:	2300      	movs	r3, #0
 800bb1c:	60fb      	str	r3, [r7, #12]

#ifdef WOLFSSL_DEBUG_OPENSSL
    WOLFSSL_ENTER("wolfSSL_ASN1_STRING_data");
#endif

    if (asn != NULL) {
 800bb1e:	687b      	ldr	r3, [r7, #4]
 800bb20:	2b00      	cmp	r3, #0
 800bb22:	d002      	beq.n	800bb2a <wolfSSL_ASN1_STRING_data+0x18>
        data = asn->data;
 800bb24:	687b      	ldr	r3, [r7, #4]
 800bb26:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800bb28:	60fb      	str	r3, [r7, #12]
    }

    return (unsigned char*)data;
 800bb2a:	68fb      	ldr	r3, [r7, #12]
}
 800bb2c:	4618      	mov	r0, r3
 800bb2e:	3714      	adds	r7, #20
 800bb30:	46bd      	mov	sp, r7
 800bb32:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bb36:	4770      	bx	lr

0800bb38 <wolfSSL_ASN1_STRING_length>:
 * @param [in] asn  ASN.1 STRING object.
 * @return  String length on success.
 * @return  0 when asn is NULL or no data set.
 */
int wolfSSL_ASN1_STRING_length(const WOLFSSL_ASN1_STRING* asn)
{
 800bb38:	b480      	push	{r7}
 800bb3a:	b085      	sub	sp, #20
 800bb3c:	af00      	add	r7, sp, #0
 800bb3e:	6078      	str	r0, [r7, #4]
    int len = 0;
 800bb40:	2300      	movs	r3, #0
 800bb42:	60fb      	str	r3, [r7, #12]

#ifdef WOLFSSL_DEBUG_OPENSSL
    WOLFSSL_ENTER("wolfSSL_ASN1_STRING_length");
#endif

    if (asn) {
 800bb44:	687b      	ldr	r3, [r7, #4]
 800bb46:	2b00      	cmp	r3, #0
 800bb48:	d002      	beq.n	800bb50 <wolfSSL_ASN1_STRING_length+0x18>
        len = asn->length;
 800bb4a:	687b      	ldr	r3, [r7, #4]
 800bb4c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800bb4e:	60fb      	str	r3, [r7, #12]
    }

    return len;
 800bb50:	68fb      	ldr	r3, [r7, #12]
}
 800bb52:	4618      	mov	r0, r3
 800bb54:	3714      	adds	r7, #20
 800bb56:	46bd      	mov	sp, r7
 800bb58:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bb5c:	4770      	bx	lr

0800bb5e <wolfSSL_ASN1_STRING_set>:
 * @return  1 on success.
 * @return  0 when asn1 is NULL or data is NULL and sz is not zero.
 * @return  0 when dynamic memory allocation fails.
 */
int wolfSSL_ASN1_STRING_set(WOLFSSL_ASN1_STRING* asn1, const void* data, int sz)
{
 800bb5e:	b580      	push	{r7, lr}
 800bb60:	b086      	sub	sp, #24
 800bb62:	af00      	add	r7, sp, #0
 800bb64:	60f8      	str	r0, [r7, #12]
 800bb66:	60b9      	str	r1, [r7, #8]
 800bb68:	607a      	str	r2, [r7, #4]
    int ret = 1;
 800bb6a:	2301      	movs	r3, #1
 800bb6c:	617b      	str	r3, [r7, #20]
#ifdef WOLFSSL_DEBUG_OPENSSL
    WOLFSSL_ENTER("wolfSSL_ASN1_STRING_set");
#endif

    /* Validate parameters. */
    if ((asn1 == NULL) || ((data == NULL) && (sz != 0))) {
 800bb6e:	68fb      	ldr	r3, [r7, #12]
 800bb70:	2b00      	cmp	r3, #0
 800bb72:	d005      	beq.n	800bb80 <wolfSSL_ASN1_STRING_set+0x22>
 800bb74:	68bb      	ldr	r3, [r7, #8]
 800bb76:	2b00      	cmp	r3, #0
 800bb78:	d104      	bne.n	800bb84 <wolfSSL_ASN1_STRING_set+0x26>
 800bb7a:	687b      	ldr	r3, [r7, #4]
 800bb7c:	2b00      	cmp	r3, #0
 800bb7e:	d001      	beq.n	800bb84 <wolfSSL_ASN1_STRING_set+0x26>
        ret = 0;
 800bb80:	2300      	movs	r3, #0
 800bb82:	617b      	str	r3, [r7, #20]
    }

    /* Calculate size from data if not passed in. */
    if ((ret == 1) && (sz < 0)) {
 800bb84:	697b      	ldr	r3, [r7, #20]
 800bb86:	2b01      	cmp	r3, #1
 800bb88:	d10c      	bne.n	800bba4 <wolfSSL_ASN1_STRING_set+0x46>
 800bb8a:	687b      	ldr	r3, [r7, #4]
 800bb8c:	2b00      	cmp	r3, #0
 800bb8e:	da09      	bge.n	800bba4 <wolfSSL_ASN1_STRING_set+0x46>
        sz = (int)XSTRLEN((const char*)data);
 800bb90:	68b8      	ldr	r0, [r7, #8]
 800bb92:	f7f4 fb27 	bl	80001e4 <strlen>
 800bb96:	4603      	mov	r3, r0
 800bb98:	607b      	str	r3, [r7, #4]
        if (sz < 0) {
 800bb9a:	687b      	ldr	r3, [r7, #4]
 800bb9c:	2b00      	cmp	r3, #0
 800bb9e:	da01      	bge.n	800bba4 <wolfSSL_ASN1_STRING_set+0x46>
            ret = 0;
 800bba0:	2300      	movs	r3, #0
 800bba2:	617b      	str	r3, [r7, #20]
        }
    }

    if (ret == 1) {
 800bba4:	697b      	ldr	r3, [r7, #20]
 800bba6:	2b01      	cmp	r3, #1
 800bba8:	d13d      	bne.n	800bc26 <wolfSSL_ASN1_STRING_set+0xc8>
        /* Dispose of any existing dynamic data. */
        if (asn1->isDynamic) {
 800bbaa:	68fb      	ldr	r3, [r7, #12]
 800bbac:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
 800bbb0:	f003 0301 	and.w	r3, r3, #1
 800bbb4:	b2db      	uxtb	r3, r3
 800bbb6:	2b00      	cmp	r3, #0
 800bbb8:	d00b      	beq.n	800bbd2 <wolfSSL_ASN1_STRING_set+0x74>
            XFREE(asn1->data, NULL, DYNAMIC_TYPE_OPENSSL);
 800bbba:	68fb      	ldr	r3, [r7, #12]
 800bbbc:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800bbbe:	613b      	str	r3, [r7, #16]
 800bbc0:	693b      	ldr	r3, [r7, #16]
 800bbc2:	2b00      	cmp	r3, #0
 800bbc4:	d002      	beq.n	800bbcc <wolfSSL_ASN1_STRING_set+0x6e>
 800bbc6:	6938      	ldr	r0, [r7, #16]
 800bbc8:	f012 ff7a 	bl	801eac0 <wolfSSL_Free>
            asn1->data = NULL;
 800bbcc:	68fb      	ldr	r3, [r7, #12]
 800bbce:	2200      	movs	r2, #0
 800bbd0:	64da      	str	r2, [r3, #76]	@ 0x4c
        }

        /* Check string will fit - including NUL. */
        if (sz + 1 > CTC_NAME_SIZE) {
 800bbd2:	687b      	ldr	r3, [r7, #4]
 800bbd4:	2b3f      	cmp	r3, #63	@ 0x3f
 800bbd6:	dd16      	ble.n	800bc06 <wolfSSL_ASN1_STRING_set+0xa8>
            /* Allocate new buffer. */
            asn1->data = (char*)XMALLOC((size_t)(sz + 1), NULL,
 800bbd8:	687b      	ldr	r3, [r7, #4]
 800bbda:	3301      	adds	r3, #1
 800bbdc:	4618      	mov	r0, r3
 800bbde:	f012 ff53 	bl	801ea88 <wolfSSL_Malloc>
 800bbe2:	4602      	mov	r2, r0
 800bbe4:	68fb      	ldr	r3, [r7, #12]
 800bbe6:	64da      	str	r2, [r3, #76]	@ 0x4c
                DYNAMIC_TYPE_OPENSSL);
            if (asn1->data == NULL) {
 800bbe8:	68fb      	ldr	r3, [r7, #12]
 800bbea:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800bbec:	2b00      	cmp	r3, #0
 800bbee:	d102      	bne.n	800bbf6 <wolfSSL_ASN1_STRING_set+0x98>
                ret = 0;
 800bbf0:	2300      	movs	r3, #0
 800bbf2:	617b      	str	r3, [r7, #20]
 800bbf4:	e017      	b.n	800bc26 <wolfSSL_ASN1_STRING_set+0xc8>
            }
            else {
                /* Ensure buffer will be freed. */
                asn1->isDynamic = 1;
 800bbf6:	68fa      	ldr	r2, [r7, #12]
 800bbf8:	f892 3054 	ldrb.w	r3, [r2, #84]	@ 0x54
 800bbfc:	f043 0301 	orr.w	r3, r3, #1
 800bc00:	f882 3054 	strb.w	r3, [r2, #84]	@ 0x54
 800bc04:	e00f      	b.n	800bc26 <wolfSSL_ASN1_STRING_set+0xc8>
            }
        }
        else {
            /* Clear out fixed array and use it for data. */
            XMEMSET(asn1->strData, 0, CTC_NAME_SIZE);
 800bc06:	68fb      	ldr	r3, [r7, #12]
 800bc08:	2240      	movs	r2, #64	@ 0x40
 800bc0a:	2100      	movs	r1, #0
 800bc0c:	4618      	mov	r0, r3
 800bc0e:	f01c fc5b 	bl	80284c8 <memset>
            asn1->data = asn1->strData;
 800bc12:	68fa      	ldr	r2, [r7, #12]
 800bc14:	68fb      	ldr	r3, [r7, #12]
 800bc16:	64da      	str	r2, [r3, #76]	@ 0x4c
            asn1->isDynamic = 0;
 800bc18:	68fa      	ldr	r2, [r7, #12]
 800bc1a:	f892 3054 	ldrb.w	r3, [r2, #84]	@ 0x54
 800bc1e:	f023 0301 	bic.w	r3, r3, #1
 800bc22:	f882 3054 	strb.w	r3, [r2, #84]	@ 0x54
        }
    }
    if (ret == 1) {
 800bc26:	697b      	ldr	r3, [r7, #20]
 800bc28:	2b01      	cmp	r3, #1
 800bc2a:	d112      	bne.n	800bc52 <wolfSSL_ASN1_STRING_set+0xf4>
        /* Check if there is a string to copy. */
        if (data != NULL) {
 800bc2c:	68bb      	ldr	r3, [r7, #8]
 800bc2e:	2b00      	cmp	r3, #0
 800bc30:	d00c      	beq.n	800bc4c <wolfSSL_ASN1_STRING_set+0xee>
            /* Copy string and append NUL. */
            XMEMCPY(asn1->data, data, (size_t)sz);
 800bc32:	68fb      	ldr	r3, [r7, #12]
 800bc34:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800bc36:	687a      	ldr	r2, [r7, #4]
 800bc38:	68b9      	ldr	r1, [r7, #8]
 800bc3a:	4618      	mov	r0, r3
 800bc3c:	f01c fcae 	bl	802859c <memcpy>
            asn1->data[sz] = '\0';
 800bc40:	68fb      	ldr	r3, [r7, #12]
 800bc42:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 800bc44:	687b      	ldr	r3, [r7, #4]
 800bc46:	4413      	add	r3, r2
 800bc48:	2200      	movs	r2, #0
 800bc4a:	701a      	strb	r2, [r3, #0]
        }
        /* Set size of string. */
        asn1->length = sz;
 800bc4c:	68fb      	ldr	r3, [r7, #12]
 800bc4e:	687a      	ldr	r2, [r7, #4]
 800bc50:	641a      	str	r2, [r3, #64]	@ 0x40
    }

    return ret;
 800bc52:	697b      	ldr	r3, [r7, #20]
}
 800bc54:	4618      	mov	r0, r3
 800bc56:	3718      	adds	r7, #24
 800bc58:	46bd      	mov	sp, r7
 800bc5a:	bd80      	pop	{r7, pc}

0800bc5c <wolfssl_asn1_type_free_value>:
/* Free the ASN.1 TYPE object's value field.
 *
 * @param [in, out] at  ASN.1 TYPE object.
 */
static void wolfssl_asn1_type_free_value(WOLFSSL_ASN1_TYPE* at)
{
 800bc5c:	b580      	push	{r7, lr}
 800bc5e:	b082      	sub	sp, #8
 800bc60:	af00      	add	r7, sp, #0
 800bc62:	6078      	str	r0, [r7, #4]
    switch (at->type) {
 800bc64:	687b      	ldr	r3, [r7, #4]
 800bc66:	681b      	ldr	r3, [r3, #0]
 800bc68:	2b1c      	cmp	r3, #28
 800bc6a:	dc35      	bgt.n	800bcd8 <wolfssl_asn1_type_free_value+0x7c>
 800bc6c:	2b0c      	cmp	r3, #12
 800bc6e:	da08      	bge.n	800bc82 <wolfssl_asn1_type_free_value+0x26>
 800bc70:	2b06      	cmp	r3, #6
 800bc72:	d025      	beq.n	800bcc0 <wolfssl_asn1_type_free_value+0x64>
 800bc74:	2b06      	cmp	r3, #6
 800bc76:	dc2f      	bgt.n	800bcd8 <wolfssl_asn1_type_free_value+0x7c>
 800bc78:	2b04      	cmp	r3, #4
 800bc7a:	d027      	beq.n	800bccc <wolfssl_asn1_type_free_value+0x70>
 800bc7c:	2b05      	cmp	r3, #5
 800bc7e:	d02d      	beq.n	800bcdc <wolfssl_asn1_type_free_value+0x80>
        case WOLFSSL_V_ASN1_UNIVERSALSTRING:
        case WOLFSSL_V_ASN1_SEQUENCE:
            wolfSSL_ASN1_STRING_free(at->value.asn1_string);
            break;
        default:
            break;
 800bc80:	e02a      	b.n	800bcd8 <wolfssl_asn1_type_free_value+0x7c>
    switch (at->type) {
 800bc82:	461a      	mov	r2, r3
 800bc84:	2301      	movs	r3, #1
 800bc86:	4093      	lsls	r3, r2
 800bc88:	4a19      	ldr	r2, [pc, #100]	@ (800bcf0 <wolfssl_asn1_type_free_value+0x94>)
 800bc8a:	401a      	ands	r2, r3
 800bc8c:	2a00      	cmp	r2, #0
 800bc8e:	bf14      	ite	ne
 800bc90:	2201      	movne	r2, #1
 800bc92:	2200      	moveq	r2, #0
 800bc94:	b2d2      	uxtb	r2, r2
 800bc96:	2a00      	cmp	r2, #0
 800bc98:	d118      	bne.n	800bccc <wolfssl_asn1_type_free_value+0x70>
 800bc9a:	f003 7280 	and.w	r2, r3, #16777216	@ 0x1000000
 800bc9e:	2a00      	cmp	r2, #0
 800bca0:	bf14      	ite	ne
 800bca2:	2201      	movne	r2, #1
 800bca4:	2200      	moveq	r2, #0
 800bca6:	b2d2      	uxtb	r2, r2
 800bca8:	2a00      	cmp	r2, #0
 800bcaa:	d119      	bne.n	800bce0 <wolfssl_asn1_type_free_value+0x84>
 800bcac:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 800bcb0:	2b00      	cmp	r3, #0
 800bcb2:	bf14      	ite	ne
 800bcb4:	2301      	movne	r3, #1
 800bcb6:	2300      	moveq	r3, #0
 800bcb8:	b2db      	uxtb	r3, r3
 800bcba:	2b00      	cmp	r3, #0
 800bcbc:	d112      	bne.n	800bce4 <wolfssl_asn1_type_free_value+0x88>
            break;
 800bcbe:	e00b      	b.n	800bcd8 <wolfssl_asn1_type_free_value+0x7c>
            wolfSSL_ASN1_OBJECT_free(at->value.object);
 800bcc0:	687b      	ldr	r3, [r7, #4]
 800bcc2:	685b      	ldr	r3, [r3, #4]
 800bcc4:	4618      	mov	r0, r3
 800bcc6:	f7ff fe8a 	bl	800b9de <wolfSSL_ASN1_OBJECT_free>
            break;
 800bcca:	e00c      	b.n	800bce6 <wolfssl_asn1_type_free_value+0x8a>
            wolfSSL_ASN1_STRING_free(at->value.asn1_string);
 800bccc:	687b      	ldr	r3, [r7, #4]
 800bcce:	685b      	ldr	r3, [r3, #4]
 800bcd0:	4618      	mov	r0, r3
 800bcd2:	f7ff fee3 	bl	800ba9c <wolfSSL_ASN1_STRING_free>
            break;
 800bcd6:	e006      	b.n	800bce6 <wolfssl_asn1_type_free_value+0x8a>
            break;
 800bcd8:	bf00      	nop
 800bcda:	e004      	b.n	800bce6 <wolfssl_asn1_type_free_value+0x8a>
            break;
 800bcdc:	bf00      	nop
 800bcde:	e002      	b.n	800bce6 <wolfssl_asn1_type_free_value+0x8a>
            break;
 800bce0:	bf00      	nop
 800bce2:	e000      	b.n	800bce6 <wolfssl_asn1_type_free_value+0x8a>
            break;
 800bce4:	bf00      	nop
    }
}
 800bce6:	bf00      	nop
 800bce8:	3708      	adds	r7, #8
 800bcea:	46bd      	mov	sp, r7
 800bcec:	bd80      	pop	{r7, pc}
 800bcee:	bf00      	nop
 800bcf0:	10591000 	.word	0x10591000

0800bcf4 <wolfSSL_ASN1_TYPE_free>:
 * Free ASN.1 TYPE object and its value.
 *
 * @param [in, out] at  ASN.1 TYPE object.
 */
void wolfSSL_ASN1_TYPE_free(WOLFSSL_ASN1_TYPE* at)
{
 800bcf4:	b580      	push	{r7, lr}
 800bcf6:	b084      	sub	sp, #16
 800bcf8:	af00      	add	r7, sp, #0
 800bcfa:	6078      	str	r0, [r7, #4]
    if (at != NULL) {
 800bcfc:	687b      	ldr	r3, [r7, #4]
 800bcfe:	2b00      	cmp	r3, #0
 800bd00:	d002      	beq.n	800bd08 <wolfSSL_ASN1_TYPE_free+0x14>
        /* Dispose of value in ASN.1 TYPE object. */
        wolfssl_asn1_type_free_value(at);
 800bd02:	6878      	ldr	r0, [r7, #4]
 800bd04:	f7ff ffaa 	bl	800bc5c <wolfssl_asn1_type_free_value>
    }
    /* Dispose of ASN.1 TYPE object. */
    XFREE(at, NULL, DYNAMIC_TYPE_OPENSSL);
 800bd08:	687b      	ldr	r3, [r7, #4]
 800bd0a:	60fb      	str	r3, [r7, #12]
 800bd0c:	68fb      	ldr	r3, [r7, #12]
 800bd0e:	2b00      	cmp	r3, #0
 800bd10:	d002      	beq.n	800bd18 <wolfSSL_ASN1_TYPE_free+0x24>
 800bd12:	68f8      	ldr	r0, [r7, #12]
 800bd14:	f012 fed4 	bl	801eac0 <wolfSSL_Free>
}
 800bd18:	bf00      	nop
 800bd1a:	3710      	adds	r7, #16
 800bd1c:	46bd      	mov	sp, r7
 800bd1e:	bd80      	pop	{r7, pc}

0800bd20 <wolfssl_der_length>:
 * @param [in] len  Length of data in buffer (may be larger than SEQ).
 * @return  Size of complete DER encoding on success.
 * @return  0 on failure.
 */
static int wolfssl_der_length(const unsigned char* seq, int len)
{
 800bd20:	b580      	push	{r7, lr}
 800bd22:	b086      	sub	sp, #24
 800bd24:	af02      	add	r7, sp, #8
 800bd26:	6078      	str	r0, [r7, #4]
 800bd28:	6039      	str	r1, [r7, #0]
    int ret = 0;
 800bd2a:	2300      	movs	r3, #0
 800bd2c:	60fb      	str	r3, [r7, #12]
    word32 i = 0;
 800bd2e:	2300      	movs	r3, #0
 800bd30:	60bb      	str	r3, [r7, #8]

    /* Check it is a SEQUENCE and get the length of the underlying data.
     * i is updated to be after SEQUENCE header bytes.
     */
    if (GetSequence_ex(seq, &i, &ret, (word32)len, 0) >= 0) {
 800bd32:	683b      	ldr	r3, [r7, #0]
 800bd34:	f107 020c 	add.w	r2, r7, #12
 800bd38:	f107 0108 	add.w	r1, r7, #8
 800bd3c:	2000      	movs	r0, #0
 800bd3e:	9000      	str	r0, [sp, #0]
 800bd40:	6878      	ldr	r0, [r7, #4]
 800bd42:	f008 f935 	bl	8013fb0 <GetSequence_ex>
 800bd46:	4603      	mov	r3, r0
 800bd48:	2b00      	cmp	r3, #0
 800bd4a:	db03      	blt.n	800bd54 <wolfssl_der_length+0x34>
        /* Add SEQUENCE header length to underlying data length. */
        ret += (int)i;
 800bd4c:	68fb      	ldr	r3, [r7, #12]
 800bd4e:	68ba      	ldr	r2, [r7, #8]
 800bd50:	4413      	add	r3, r2
 800bd52:	60fb      	str	r3, [r7, #12]
    }

    return ret;
 800bd54:	68fb      	ldr	r3, [r7, #12]
}
 800bd56:	4618      	mov	r0, r3
 800bd58:	3710      	adds	r7, #16
 800bd5a:	46bd      	mov	sp, r7
 800bd5c:	bd80      	pop	{r7, pc}

0800bd5e <wolfSSL_RSA_meth_free>:
/* Dispose of RSA method and allocated data.
 *
 * @param [in] meth  RSA method to free.
 */
void wolfSSL_RSA_meth_free(WOLFSSL_RSA_METHOD *meth)
{
 800bd5e:	b580      	push	{r7, lr}
 800bd60:	b084      	sub	sp, #16
 800bd62:	af00      	add	r7, sp, #0
 800bd64:	6078      	str	r0, [r7, #4]
    /* Free method if available and dynamically allocated. */
    if ((meth != NULL) && meth->dynamic) {
 800bd66:	687b      	ldr	r3, [r7, #4]
 800bd68:	2b00      	cmp	r3, #0
 800bd6a:	d017      	beq.n	800bd9c <wolfSSL_RSA_meth_free+0x3e>
 800bd6c:	687b      	ldr	r3, [r7, #4]
 800bd6e:	7a1b      	ldrb	r3, [r3, #8]
 800bd70:	f003 0301 	and.w	r3, r3, #1
 800bd74:	b2db      	uxtb	r3, r3
 800bd76:	2b00      	cmp	r3, #0
 800bd78:	d010      	beq.n	800bd9c <wolfSSL_RSA_meth_free+0x3e>
        /* Name was duplicated and must be freed. */
        XFREE(meth->name, NULL, DYNAMIC_TYPE_OPENSSL);
 800bd7a:	687b      	ldr	r3, [r7, #4]
 800bd7c:	685b      	ldr	r3, [r3, #4]
 800bd7e:	60fb      	str	r3, [r7, #12]
 800bd80:	68fb      	ldr	r3, [r7, #12]
 800bd82:	2b00      	cmp	r3, #0
 800bd84:	d002      	beq.n	800bd8c <wolfSSL_RSA_meth_free+0x2e>
 800bd86:	68f8      	ldr	r0, [r7, #12]
 800bd88:	f012 fe9a 	bl	801eac0 <wolfSSL_Free>
        /* Dispose of RSA method. */
        XFREE(meth, NULL, DYNAMIC_TYPE_OPENSSL);
 800bd8c:	687b      	ldr	r3, [r7, #4]
 800bd8e:	60bb      	str	r3, [r7, #8]
 800bd90:	68bb      	ldr	r3, [r7, #8]
 800bd92:	2b00      	cmp	r3, #0
 800bd94:	d002      	beq.n	800bd9c <wolfSSL_RSA_meth_free+0x3e>
 800bd96:	68b8      	ldr	r0, [r7, #8]
 800bd98:	f012 fe92 	bl	801eac0 <wolfSSL_Free>
    }
}
 800bd9c:	bf00      	nop
 800bd9e:	3710      	adds	r7, #16
 800bda0:	46bd      	mov	sp, r7
 800bda2:	bd80      	pop	{r7, pc}

0800bda4 <wolfSSL_RSA_free>:
 * Cannot use rsa after this call.
 *
 * @param [in] rsa  RSA key to free.
 */
void wolfSSL_RSA_free(WOLFSSL_RSA* rsa)
{
 800bda4:	b580      	push	{r7, lr}
 800bda6:	b08a      	sub	sp, #40	@ 0x28
 800bda8:	af00      	add	r7, sp, #0
 800bdaa:	6078      	str	r0, [r7, #4]
    int doFree = 1;
 800bdac:	2301      	movs	r3, #1
 800bdae:	60fb      	str	r3, [r7, #12]

    WOLFSSL_ENTER("wolfSSL_RSA_free");

    /* Validate parameter. */
    if (rsa == NULL) {
 800bdb0:	687b      	ldr	r3, [r7, #4]
 800bdb2:	2b00      	cmp	r3, #0
 800bdb4:	d101      	bne.n	800bdba <wolfSSL_RSA_free+0x16>
        doFree = 0;
 800bdb6:	2300      	movs	r3, #0
 800bdb8:	60fb      	str	r3, [r7, #12]
    }
    if (doFree) {
 800bdba:	68fb      	ldr	r3, [r7, #12]
 800bdbc:	2b00      	cmp	r3, #0
 800bdbe:	d00f      	beq.n	800bde0 <wolfSSL_RSA_free+0x3c>
        int err;

        /* Decrement reference count. */
        wolfSSL_RefDec(&rsa->ref, &doFree, &err);
 800bdc0:	687b      	ldr	r3, [r7, #4]
 800bdc2:	332c      	adds	r3, #44	@ 0x2c
 800bdc4:	2101      	movs	r1, #1
 800bdc6:	4618      	mov	r0, r3
 800bdc8:	f7ff f9ac 	bl	800b124 <wolfSSL_Atomic_Int_FetchSub>
 800bdcc:	6278      	str	r0, [r7, #36]	@ 0x24
 800bdce:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800bdd0:	2b01      	cmp	r3, #1
 800bdd2:	bf0c      	ite	eq
 800bdd4:	2301      	moveq	r3, #1
 800bdd6:	2300      	movne	r3, #0
 800bdd8:	b2db      	uxtb	r3, r3
 800bdda:	60fb      	str	r3, [r7, #12]
 800bddc:	2300      	movs	r3, #0
 800bdde:	60bb      	str	r3, [r7, #8]
    #ifndef WOLFSSL_REFCNT_ERROR_RETURN
        (void)err;
    #endif
    }
    if (doFree) {
 800bde0:	68fb      	ldr	r3, [r7, #12]
 800bde2:	2b00      	cmp	r3, #0
 800bde4:	d074      	beq.n	800bed0 <wolfSSL_RSA_free+0x12c>
        void* heap = rsa->heap;
 800bde6:	687b      	ldr	r3, [r7, #4]
 800bde8:	6a1b      	ldr	r3, [r3, #32]
 800bdea:	623b      	str	r3, [r7, #32]

    #ifdef HAVE_EX_DATA_CLEANUP_HOOKS
        wolfSSL_CRYPTO_cleanup_ex_data(&rsa->ex_data);
    #endif

        if (rsa->internal != NULL) {
 800bdec:	687b      	ldr	r3, [r7, #4]
 800bdee:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800bdf0:	2b00      	cmp	r3, #0
 800bdf2:	d030      	beq.n	800be56 <wolfSSL_RSA_free+0xb2>
        #if !defined(HAVE_FIPS) && defined(WC_RSA_BLINDING)
            /* Check if RNG is owned before freeing it. */
            if (rsa->ownRng) {
 800bdf4:	687b      	ldr	r3, [r7, #4]
 800bdf6:	f893 3038 	ldrb.w	r3, [r3, #56]	@ 0x38
 800bdfa:	f003 0304 	and.w	r3, r3, #4
 800bdfe:	b2db      	uxtb	r3, r3
 800be00:	2b00      	cmp	r3, #0
 800be02:	d01a      	beq.n	800be3a <wolfSSL_RSA_free+0x96>
                WC_RNG* rng = ((RsaKey*)(rsa->internal))->rng;
 800be04:	687b      	ldr	r3, [r7, #4]
 800be06:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800be08:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 800be0c:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
 800be10:	61fb      	str	r3, [r7, #28]
                if ((rng != NULL) && (rng != wolfssl_get_global_rng())) {
 800be12:	69fb      	ldr	r3, [r7, #28]
 800be14:	2b00      	cmp	r3, #0
 800be16:	d010      	beq.n	800be3a <wolfSSL_RSA_free+0x96>
 800be18:	f7ff fd42 	bl	800b8a0 <wolfssl_get_global_rng>
 800be1c:	4602      	mov	r2, r0
 800be1e:	69fb      	ldr	r3, [r7, #28]
 800be20:	4293      	cmp	r3, r2
 800be22:	d00a      	beq.n	800be3a <wolfSSL_RSA_free+0x96>
                    wc_FreeRng(rng);
 800be24:	69f8      	ldr	r0, [r7, #28]
 800be26:	f013 fc57 	bl	801f6d8 <wc_FreeRng>
                    XFREE(rng, heap, DYNAMIC_TYPE_RNG);
 800be2a:	69fb      	ldr	r3, [r7, #28]
 800be2c:	61bb      	str	r3, [r7, #24]
 800be2e:	69bb      	ldr	r3, [r7, #24]
 800be30:	2b00      	cmp	r3, #0
 800be32:	d002      	beq.n	800be3a <wolfSSL_RSA_free+0x96>
 800be34:	69b8      	ldr	r0, [r7, #24]
 800be36:	f012 fe43 	bl	801eac0 <wolfSSL_Free>
                }
                /* RNG isn't freed by wolfCrypt RSA free. */
            }
        #endif
            /* Dispose of allocated data in wolfCrypt RSA key. */
            wc_FreeRsaKey((RsaKey*)rsa->internal);
 800be3a:	687b      	ldr	r3, [r7, #4]
 800be3c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800be3e:	4618      	mov	r0, r3
 800be40:	f014 f8a6 	bl	801ff90 <wc_FreeRsaKey>
            /* Dispose of memory for wolfCrypt RSA key. */
            XFREE(rsa->internal, heap, DYNAMIC_TYPE_RSA);
 800be44:	687b      	ldr	r3, [r7, #4]
 800be46:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800be48:	617b      	str	r3, [r7, #20]
 800be4a:	697b      	ldr	r3, [r7, #20]
 800be4c:	2b00      	cmp	r3, #0
 800be4e:	d002      	beq.n	800be56 <wolfSSL_RSA_free+0xb2>
 800be50:	6978      	ldr	r0, [r7, #20]
 800be52:	f012 fe35 	bl	801eac0 <wolfSSL_Free>
        }

        /* Dispose of external representation of RSA values. */
        wolfSSL_BN_clear_free(rsa->iqmp);
 800be56:	687b      	ldr	r3, [r7, #4]
 800be58:	69db      	ldr	r3, [r3, #28]
 800be5a:	4618      	mov	r0, r3
 800be5c:	f7ff fd52 	bl	800b904 <wolfSSL_BN_clear_free>
        wolfSSL_BN_clear_free(rsa->dmq1);
 800be60:	687b      	ldr	r3, [r7, #4]
 800be62:	699b      	ldr	r3, [r3, #24]
 800be64:	4618      	mov	r0, r3
 800be66:	f7ff fd4d 	bl	800b904 <wolfSSL_BN_clear_free>
        wolfSSL_BN_clear_free(rsa->dmp1);
 800be6a:	687b      	ldr	r3, [r7, #4]
 800be6c:	695b      	ldr	r3, [r3, #20]
 800be6e:	4618      	mov	r0, r3
 800be70:	f7ff fd48 	bl	800b904 <wolfSSL_BN_clear_free>
        wolfSSL_BN_clear_free(rsa->q);
 800be74:	687b      	ldr	r3, [r7, #4]
 800be76:	691b      	ldr	r3, [r3, #16]
 800be78:	4618      	mov	r0, r3
 800be7a:	f7ff fd43 	bl	800b904 <wolfSSL_BN_clear_free>
        wolfSSL_BN_clear_free(rsa->p);
 800be7e:	687b      	ldr	r3, [r7, #4]
 800be80:	68db      	ldr	r3, [r3, #12]
 800be82:	4618      	mov	r0, r3
 800be84:	f7ff fd3e 	bl	800b904 <wolfSSL_BN_clear_free>
        wolfSSL_BN_clear_free(rsa->d);
 800be88:	687b      	ldr	r3, [r7, #4]
 800be8a:	689b      	ldr	r3, [r3, #8]
 800be8c:	4618      	mov	r0, r3
 800be8e:	f7ff fd39 	bl	800b904 <wolfSSL_BN_clear_free>
        wolfSSL_BN_free(rsa->e);
 800be92:	687b      	ldr	r3, [r7, #4]
 800be94:	685b      	ldr	r3, [r3, #4]
 800be96:	4618      	mov	r0, r3
 800be98:	f7ff fd18 	bl	800b8cc <wolfSSL_BN_free>
        wolfSSL_BN_free(rsa->n);
 800be9c:	687b      	ldr	r3, [r7, #4]
 800be9e:	681b      	ldr	r3, [r3, #0]
 800bea0:	4618      	mov	r0, r3
 800bea2:	f7ff fd13 	bl	800b8cc <wolfSSL_BN_free>

    #if defined(OPENSSL_EXTRA)
        if (rsa->meth) {
 800bea6:	687b      	ldr	r3, [r7, #4]
 800bea8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800beaa:	2b00      	cmp	r3, #0
 800beac:	d004      	beq.n	800beb8 <wolfSSL_RSA_free+0x114>
            wolfSSL_RSA_meth_free((WOLFSSL_RSA_METHOD*)rsa->meth);
 800beae:	687b      	ldr	r3, [r7, #4]
 800beb0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800beb2:	4618      	mov	r0, r3
 800beb4:	f7ff ff53 	bl	800bd5e <wolfSSL_RSA_meth_free>
        }
    #endif

        /* Set back to NULLs for safety. */
        ForceZero(rsa, sizeof(*rsa));
 800beb8:	213c      	movs	r1, #60	@ 0x3c
 800beba:	6878      	ldr	r0, [r7, #4]
 800bebc:	f7ff f947 	bl	800b14e <ForceZero>

        XFREE(rsa, heap, DYNAMIC_TYPE_RSA);
 800bec0:	687b      	ldr	r3, [r7, #4]
 800bec2:	613b      	str	r3, [r7, #16]
 800bec4:	693b      	ldr	r3, [r7, #16]
 800bec6:	2b00      	cmp	r3, #0
 800bec8:	d002      	beq.n	800bed0 <wolfSSL_RSA_free+0x12c>
 800beca:	6938      	ldr	r0, [r7, #16]
 800becc:	f012 fdf8 	bl	801eac0 <wolfSSL_Free>
        (void)heap;
    }
}
 800bed0:	bf00      	nop
 800bed2:	3728      	adds	r7, #40	@ 0x28
 800bed4:	46bd      	mov	sp, r7
 800bed6:	bd80      	pop	{r7, pc}

0800bed8 <wolfSSL_DH_free>:
 * Cannot use dh after this call.
 *
 * @param [in] dh  DH key to free.
 */
void wolfSSL_DH_free(WOLFSSL_DH* dh)
{
 800bed8:	b580      	push	{r7, lr}
 800beda:	b088      	sub	sp, #32
 800bedc:	af00      	add	r7, sp, #0
 800bede:	6078      	str	r0, [r7, #4]
    int doFree = 0;
 800bee0:	2300      	movs	r3, #0
 800bee2:	613b      	str	r3, [r7, #16]

    WOLFSSL_ENTER("wolfSSL_DH_free");

    if (dh != NULL) {
 800bee4:	687b      	ldr	r3, [r7, #4]
 800bee6:	2b00      	cmp	r3, #0
 800bee8:	d00f      	beq.n	800bf0a <wolfSSL_DH_free+0x32>
        int err;

        /* Only free if all references to it are done */
        wolfSSL_RefDec(&dh->ref, &doFree, &err);
 800beea:	687b      	ldr	r3, [r7, #4]
 800beec:	3320      	adds	r3, #32
 800beee:	2101      	movs	r1, #1
 800bef0:	4618      	mov	r0, r3
 800bef2:	f7ff f917 	bl	800b124 <wolfSSL_Atomic_Int_FetchSub>
 800bef6:	61f8      	str	r0, [r7, #28]
 800bef8:	69fb      	ldr	r3, [r7, #28]
 800befa:	2b01      	cmp	r3, #1
 800befc:	bf0c      	ite	eq
 800befe:	2301      	moveq	r3, #1
 800bf00:	2300      	movne	r3, #0
 800bf02:	b2db      	uxtb	r3, r3
 800bf04:	613b      	str	r3, [r7, #16]
 800bf06:	2300      	movs	r3, #0
 800bf08:	60fb      	str	r3, [r7, #12]
        /* Ignore errors - doFree will be 0 on error. */
        (void)err;
    }
    if (doFree) {
 800bf0a:	693b      	ldr	r3, [r7, #16]
 800bf0c:	2b00      	cmp	r3, #0
 800bf0e:	d03a      	beq.n	800bf86 <wolfSSL_DH_free+0xae>
        /* Dispose of allocated reference counting data. */
        wolfSSL_RefFree(&dh->ref);

        /* Dispose of wolfSSL DH key. */
        if (dh->internal) {
 800bf10:	687b      	ldr	r3, [r7, #4]
 800bf12:	695b      	ldr	r3, [r3, #20]
 800bf14:	2b00      	cmp	r3, #0
 800bf16:	d010      	beq.n	800bf3a <wolfSSL_DH_free+0x62>
            wc_FreeDhKey((DhKey*)dh->internal);
 800bf18:	687b      	ldr	r3, [r7, #4]
 800bf1a:	695b      	ldr	r3, [r3, #20]
 800bf1c:	4618      	mov	r0, r3
 800bf1e:	f00e fc11 	bl	801a744 <wc_FreeDhKey>
            XFREE(dh->internal, NULL, DYNAMIC_TYPE_DH);
 800bf22:	687b      	ldr	r3, [r7, #4]
 800bf24:	695b      	ldr	r3, [r3, #20]
 800bf26:	61bb      	str	r3, [r7, #24]
 800bf28:	69bb      	ldr	r3, [r7, #24]
 800bf2a:	2b00      	cmp	r3, #0
 800bf2c:	d002      	beq.n	800bf34 <wolfSSL_DH_free+0x5c>
 800bf2e:	69b8      	ldr	r0, [r7, #24]
 800bf30:	f012 fdc6 	bl	801eac0 <wolfSSL_Free>
            dh->internal = NULL;
 800bf34:	687b      	ldr	r3, [r7, #4]
 800bf36:	2200      	movs	r2, #0
 800bf38:	615a      	str	r2, [r3, #20]
        }

        /* Dispose of any allocated BNs. */
        wolfSSL_BN_free(dh->priv_key);
 800bf3a:	687b      	ldr	r3, [r7, #4]
 800bf3c:	691b      	ldr	r3, [r3, #16]
 800bf3e:	4618      	mov	r0, r3
 800bf40:	f7ff fcc4 	bl	800b8cc <wolfSSL_BN_free>
        wolfSSL_BN_free(dh->pub_key);
 800bf44:	687b      	ldr	r3, [r7, #4]
 800bf46:	68db      	ldr	r3, [r3, #12]
 800bf48:	4618      	mov	r0, r3
 800bf4a:	f7ff fcbf 	bl	800b8cc <wolfSSL_BN_free>
        wolfSSL_BN_free(dh->g);
 800bf4e:	687b      	ldr	r3, [r7, #4]
 800bf50:	685b      	ldr	r3, [r3, #4]
 800bf52:	4618      	mov	r0, r3
 800bf54:	f7ff fcba 	bl	800b8cc <wolfSSL_BN_free>
        wolfSSL_BN_free(dh->p);
 800bf58:	687b      	ldr	r3, [r7, #4]
 800bf5a:	681b      	ldr	r3, [r3, #0]
 800bf5c:	4618      	mov	r0, r3
 800bf5e:	f7ff fcb5 	bl	800b8cc <wolfSSL_BN_free>
        wolfSSL_BN_free(dh->q);
 800bf62:	687b      	ldr	r3, [r7, #4]
 800bf64:	689b      	ldr	r3, [r3, #8]
 800bf66:	4618      	mov	r0, r3
 800bf68:	f7ff fcb0 	bl	800b8cc <wolfSSL_BN_free>
        /* Set back to NULLs for safety. */
        XMEMSET(dh, 0, sizeof(WOLFSSL_DH));
 800bf6c:	2224      	movs	r2, #36	@ 0x24
 800bf6e:	2100      	movs	r1, #0
 800bf70:	6878      	ldr	r0, [r7, #4]
 800bf72:	f01c faa9 	bl	80284c8 <memset>

        XFREE(dh, NULL, DYNAMIC_TYPE_DH);
 800bf76:	687b      	ldr	r3, [r7, #4]
 800bf78:	617b      	str	r3, [r7, #20]
 800bf7a:	697b      	ldr	r3, [r7, #20]
 800bf7c:	2b00      	cmp	r3, #0
 800bf7e:	d002      	beq.n	800bf86 <wolfSSL_DH_free+0xae>
 800bf80:	6978      	ldr	r0, [r7, #20]
 800bf82:	f012 fd9d 	bl	801eac0 <wolfSSL_Free>
    }
}
 800bf86:	bf00      	nop
 800bf88:	3720      	adds	r7, #32
 800bf8a:	46bd      	mov	sp, r7
 800bf8c:	bd80      	pop	{r7, pc}

0800bf8e <wolfSSL_EC_GROUP_free>:
 * Cannot use group after this call.
 *
 * @param [in] group  EC group to free.
 */
void wolfSSL_EC_GROUP_free(WOLFSSL_EC_GROUP *group)
{
 800bf8e:	b580      	push	{r7, lr}
 800bf90:	b084      	sub	sp, #16
 800bf92:	af00      	add	r7, sp, #0
 800bf94:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_EC_GROUP_free");

    /* Dispose of EC group. */
    XFREE(group, NULL, DYNAMIC_TYPE_ECC);
 800bf96:	687b      	ldr	r3, [r7, #4]
 800bf98:	60fb      	str	r3, [r7, #12]
 800bf9a:	68fb      	ldr	r3, [r7, #12]
 800bf9c:	2b00      	cmp	r3, #0
 800bf9e:	d002      	beq.n	800bfa6 <wolfSSL_EC_GROUP_free+0x18>
 800bfa0:	68f8      	ldr	r0, [r7, #12]
 800bfa2:	f012 fd8d 	bl	801eac0 <wolfSSL_Free>
}
 800bfa6:	bf00      	nop
 800bfa8:	3710      	adds	r7, #16
 800bfaa:	46bd      	mov	sp, r7
 800bfac:	bd80      	pop	{r7, pc}

0800bfae <wolfSSL_EC_POINT_free>:
 * Cannot use point after this call.
 *
 * @param [in, out] point  EC point to free.
 */
void wolfSSL_EC_POINT_free(WOLFSSL_EC_POINT *point)
{
 800bfae:	b580      	push	{r7, lr}
 800bfb0:	b084      	sub	sp, #16
 800bfb2:	af00      	add	r7, sp, #0
 800bfb4:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_EC_POINT_free");

    if (point != NULL) {
 800bfb6:	687b      	ldr	r3, [r7, #4]
 800bfb8:	2b00      	cmp	r3, #0
 800bfba:	d031      	beq.n	800c020 <wolfSSL_EC_POINT_free+0x72>
        if (point->internal != NULL) {
 800bfbc:	687b      	ldr	r3, [r7, #4]
 800bfbe:	68db      	ldr	r3, [r3, #12]
 800bfc0:	2b00      	cmp	r3, #0
 800bfc2:	d007      	beq.n	800bfd4 <wolfSSL_EC_POINT_free+0x26>
            wc_ecc_del_point((ecc_point*)point->internal);
 800bfc4:	687b      	ldr	r3, [r7, #4]
 800bfc6:	68db      	ldr	r3, [r3, #12]
 800bfc8:	4618      	mov	r0, r3
 800bfca:	f010 fd00 	bl	801c9ce <wc_ecc_del_point>
            point->internal = NULL;
 800bfce:	687b      	ldr	r3, [r7, #4]
 800bfd0:	2200      	movs	r2, #0
 800bfd2:	60da      	str	r2, [r3, #12]
        }

        /* Free ordinates. */
        wolfSSL_BN_free(point->X);
 800bfd4:	687b      	ldr	r3, [r7, #4]
 800bfd6:	681b      	ldr	r3, [r3, #0]
 800bfd8:	4618      	mov	r0, r3
 800bfda:	f7ff fc77 	bl	800b8cc <wolfSSL_BN_free>
        wolfSSL_BN_free(point->Y);
 800bfde:	687b      	ldr	r3, [r7, #4]
 800bfe0:	685b      	ldr	r3, [r3, #4]
 800bfe2:	4618      	mov	r0, r3
 800bfe4:	f7ff fc72 	bl	800b8cc <wolfSSL_BN_free>
        wolfSSL_BN_free(point->Z);
 800bfe8:	687b      	ldr	r3, [r7, #4]
 800bfea:	689b      	ldr	r3, [r3, #8]
 800bfec:	4618      	mov	r0, r3
 800bfee:	f7ff fc6d 	bl	800b8cc <wolfSSL_BN_free>
        /* Clear fields. */
        point->X = NULL;
 800bff2:	687b      	ldr	r3, [r7, #4]
 800bff4:	2200      	movs	r2, #0
 800bff6:	601a      	str	r2, [r3, #0]
        point->Y = NULL;
 800bff8:	687b      	ldr	r3, [r7, #4]
 800bffa:	2200      	movs	r2, #0
 800bffc:	605a      	str	r2, [r3, #4]
        point->Z = NULL;
 800bffe:	687b      	ldr	r3, [r7, #4]
 800c000:	2200      	movs	r2, #0
 800c002:	609a      	str	r2, [r3, #8]
        point->inSet = 0;
 800c004:	687b      	ldr	r3, [r7, #4]
 800c006:	2200      	movs	r2, #0
 800c008:	741a      	strb	r2, [r3, #16]
        point->exSet = 0;
 800c00a:	687b      	ldr	r3, [r7, #4]
 800c00c:	2200      	movs	r2, #0
 800c00e:	745a      	strb	r2, [r3, #17]

        /* Dispose of EC point. */
        XFREE(point, NULL, DYNAMIC_TYPE_ECC);
 800c010:	687b      	ldr	r3, [r7, #4]
 800c012:	60fb      	str	r3, [r7, #12]
 800c014:	68fb      	ldr	r3, [r7, #12]
 800c016:	2b00      	cmp	r3, #0
 800c018:	d002      	beq.n	800c020 <wolfSSL_EC_POINT_free+0x72>
 800c01a:	68f8      	ldr	r0, [r7, #12]
 800c01c:	f012 fd50 	bl	801eac0 <wolfSSL_Free>
    }
}
 800c020:	bf00      	nop
 800c022:	3710      	adds	r7, #16
 800c024:	46bd      	mov	sp, r7
 800c026:	bd80      	pop	{r7, pc}

0800c028 <wolfSSL_EC_KEY_free>:
 * Cannot use key after this call.
 *
 * @param [in] key  EC key to free.
 */
void wolfSSL_EC_KEY_free(WOLFSSL_EC_KEY *key)
{
 800c028:	b580      	push	{r7, lr}
 800c02a:	b088      	sub	sp, #32
 800c02c:	af00      	add	r7, sp, #0
 800c02e:	6078      	str	r0, [r7, #4]
    int doFree = 0;
 800c030:	2300      	movs	r3, #0
 800c032:	60fb      	str	r3, [r7, #12]

    (void)err;

    WOLFSSL_ENTER("wolfSSL_EC_KEY_free");

    if (key != NULL) {
 800c034:	687b      	ldr	r3, [r7, #4]
 800c036:	2b00      	cmp	r3, #0
 800c038:	d042      	beq.n	800c0c0 <wolfSSL_EC_KEY_free+0x98>
        void* heap = key->heap;
 800c03a:	687b      	ldr	r3, [r7, #4]
 800c03c:	691b      	ldr	r3, [r3, #16]
 800c03e:	61fb      	str	r3, [r7, #28]

        /* Decrement reference count. */
        wolfSSL_RefDec(&key->ref, &doFree, &err);
 800c040:	687b      	ldr	r3, [r7, #4]
 800c042:	331c      	adds	r3, #28
 800c044:	2101      	movs	r1, #1
 800c046:	4618      	mov	r0, r3
 800c048:	f7ff f86c 	bl	800b124 <wolfSSL_Atomic_Int_FetchSub>
 800c04c:	61b8      	str	r0, [r7, #24]
 800c04e:	69bb      	ldr	r3, [r7, #24]
 800c050:	2b01      	cmp	r3, #1
 800c052:	bf0c      	ite	eq
 800c054:	2301      	moveq	r3, #1
 800c056:	2300      	movne	r3, #0
 800c058:	b2db      	uxtb	r3, r3
 800c05a:	60fb      	str	r3, [r7, #12]
 800c05c:	2300      	movs	r3, #0
 800c05e:	60bb      	str	r3, [r7, #8]
        if (doFree) {
 800c060:	68fb      	ldr	r3, [r7, #12]
 800c062:	2b00      	cmp	r3, #0
 800c064:	d02c      	beq.n	800c0c0 <wolfSSL_EC_KEY_free+0x98>
            /* Dispose of allocated reference counting data. */
            wolfSSL_RefFree(&key->ref);

            /* Dispose of private key. */
            wolfSSL_BN_free(key->priv_key);
 800c066:	687b      	ldr	r3, [r7, #4]
 800c068:	689b      	ldr	r3, [r3, #8]
 800c06a:	4618      	mov	r0, r3
 800c06c:	f7ff fc2e 	bl	800b8cc <wolfSSL_BN_free>
            wolfSSL_EC_POINT_free(key->pub_key);
 800c070:	687b      	ldr	r3, [r7, #4]
 800c072:	685b      	ldr	r3, [r3, #4]
 800c074:	4618      	mov	r0, r3
 800c076:	f7ff ff9a 	bl	800bfae <wolfSSL_EC_POINT_free>
            wolfSSL_EC_GROUP_free(key->group);
 800c07a:	687b      	ldr	r3, [r7, #4]
 800c07c:	681b      	ldr	r3, [r3, #0]
 800c07e:	4618      	mov	r0, r3
 800c080:	f7ff ff85 	bl	800bf8e <wolfSSL_EC_GROUP_free>
            if (key->internal != NULL) {
 800c084:	687b      	ldr	r3, [r7, #4]
 800c086:	68db      	ldr	r3, [r3, #12]
 800c088:	2b00      	cmp	r3, #0
 800c08a:	d00d      	beq.n	800c0a8 <wolfSSL_EC_KEY_free+0x80>
                /* Dispose of wolfCrypt representation of EC key. */
                wc_ecc_free((ecc_key*)key->internal);
 800c08c:	687b      	ldr	r3, [r7, #4]
 800c08e:	68db      	ldr	r3, [r3, #12]
 800c090:	4618      	mov	r0, r3
 800c092:	f010 ff42 	bl	801cf1a <wc_ecc_free>
                XFREE(key->internal, heap, DYNAMIC_TYPE_ECC);
 800c096:	687b      	ldr	r3, [r7, #4]
 800c098:	68db      	ldr	r3, [r3, #12]
 800c09a:	617b      	str	r3, [r7, #20]
 800c09c:	697b      	ldr	r3, [r7, #20]
 800c09e:	2b00      	cmp	r3, #0
 800c0a0:	d002      	beq.n	800c0a8 <wolfSSL_EC_KEY_free+0x80>
 800c0a2:	6978      	ldr	r0, [r7, #20]
 800c0a4:	f012 fd0c 	bl	801eac0 <wolfSSL_Free>
            }

            /* Set back to NULLs for safety. */
            ForceZero(key, sizeof(*key));
 800c0a8:	2120      	movs	r1, #32
 800c0aa:	6878      	ldr	r0, [r7, #4]
 800c0ac:	f7ff f84f 	bl	800b14e <ForceZero>

            /* Dispose of the memory associated with the EC key. */
            XFREE(key, heap, DYNAMIC_TYPE_ECC);
 800c0b0:	687b      	ldr	r3, [r7, #4]
 800c0b2:	613b      	str	r3, [r7, #16]
 800c0b4:	693b      	ldr	r3, [r7, #16]
 800c0b6:	2b00      	cmp	r3, #0
 800c0b8:	d002      	beq.n	800c0c0 <wolfSSL_EC_KEY_free+0x98>
 800c0ba:	6938      	ldr	r0, [r7, #16]
 800c0bc:	f012 fd00 	bl	801eac0 <wolfSSL_Free>
            (void)heap;
        }
    }
}
 800c0c0:	bf00      	nop
 800c0c2:	3720      	adds	r7, #32
 800c0c4:	46bd      	mov	sp, r7
 800c0c6:	bd80      	pop	{r7, pc}

0800c0c8 <wolfSSL_CTX_new_ex>:
   WOLFSSL_METHOD pointer passed in is given to ctx to manage.
   This function frees the passed in WOLFSSL_METHOD struct on failure and on
   success is freed when ctx is freed.
 */
WOLFSSL_CTX* wolfSSL_CTX_new_ex(WOLFSSL_METHOD* method, void* heap)
{
 800c0c8:	b580      	push	{r7, lr}
 800c0ca:	b088      	sub	sp, #32
 800c0cc:	af00      	add	r7, sp, #0
 800c0ce:	6078      	str	r0, [r7, #4]
 800c0d0:	6039      	str	r1, [r7, #0]
    WOLFSSL_CTX* ctx = NULL;
 800c0d2:	2300      	movs	r3, #0
 800c0d4:	61fb      	str	r3, [r7, #28]

    WOLFSSL_ENTER("wolfSSL_CTX_new_ex");

    if (initRefCount == 0) {
 800c0d6:	4b1e      	ldr	r3, [pc, #120]	@ (800c150 <wolfSSL_CTX_new_ex+0x88>)
 800c0d8:	681b      	ldr	r3, [r3, #0]
 800c0da:	2b00      	cmp	r3, #0
 800c0dc:	d10f      	bne.n	800c0fe <wolfSSL_CTX_new_ex+0x36>
        /* user no longer forced to call Init themselves */
        int ret = wolfSSL_Init();
 800c0de:	f000 fb2f 	bl	800c740 <wolfSSL_Init>
 800c0e2:	61b8      	str	r0, [r7, #24]
        if (ret != WOLFSSL_SUCCESS) {
 800c0e4:	69bb      	ldr	r3, [r7, #24]
 800c0e6:	2b01      	cmp	r3, #1
 800c0e8:	d009      	beq.n	800c0fe <wolfSSL_CTX_new_ex+0x36>
            WOLFSSL_MSG("wolfSSL_Init failed");
            WOLFSSL_LEAVE("wolfSSL_CTX_new_ex", 0);
            XFREE(method, heap, DYNAMIC_TYPE_METHOD);
 800c0ea:	687b      	ldr	r3, [r7, #4]
 800c0ec:	617b      	str	r3, [r7, #20]
 800c0ee:	697b      	ldr	r3, [r7, #20]
 800c0f0:	2b00      	cmp	r3, #0
 800c0f2:	d002      	beq.n	800c0fa <wolfSSL_CTX_new_ex+0x32>
 800c0f4:	6978      	ldr	r0, [r7, #20]
 800c0f6:	f012 fce3 	bl	801eac0 <wolfSSL_Free>
            return NULL;
 800c0fa:	2300      	movs	r3, #0
 800c0fc:	e024      	b.n	800c148 <wolfSSL_CTX_new_ex+0x80>
        }
    }

#ifndef NO_TLS
    if (method == NULL)
 800c0fe:	687b      	ldr	r3, [r7, #4]
 800c100:	2b00      	cmp	r3, #0
 800c102:	d101      	bne.n	800c108 <wolfSSL_CTX_new_ex+0x40>
        return ctx;
 800c104:	69fb      	ldr	r3, [r7, #28]
 800c106:	e01f      	b.n	800c148 <wolfSSL_CTX_new_ex+0x80>
#else
    /* a blank TLS method */
    method = (WOLFSSL_METHOD*)&gNoTlsMethod;
#endif

    ctx = (WOLFSSL_CTX*)XMALLOC(sizeof(WOLFSSL_CTX), heap, DYNAMIC_TYPE_CTX);
 800c108:	f44f 70a8 	mov.w	r0, #336	@ 0x150
 800c10c:	f012 fcbc 	bl	801ea88 <wolfSSL_Malloc>
 800c110:	61f8      	str	r0, [r7, #28]
    if (ctx) {
 800c112:	69fb      	ldr	r3, [r7, #28]
 800c114:	2b00      	cmp	r3, #0
 800c116:	d00e      	beq.n	800c136 <wolfSSL_CTX_new_ex+0x6e>
        int ret;

        ret = InitSSL_Ctx(ctx, method, heap);
 800c118:	683a      	ldr	r2, [r7, #0]
 800c11a:	6879      	ldr	r1, [r7, #4]
 800c11c:	69f8      	ldr	r0, [r7, #28]
 800c11e:	f7fc fc20 	bl	8008962 <InitSSL_Ctx>
 800c122:	60f8      	str	r0, [r7, #12]
    #ifdef WOLFSSL_STATIC_MEMORY
        if (heap != NULL) {
            ctx->onHeapHint = 1; /* free the memory back to heap when done */
        }
    #endif
        if (ret < 0) {
 800c124:	68fb      	ldr	r3, [r7, #12]
 800c126:	2b00      	cmp	r3, #0
 800c128:	da0d      	bge.n	800c146 <wolfSSL_CTX_new_ex+0x7e>
            WOLFSSL_MSG("Init CTX failed");
            wolfSSL_CTX_free(ctx);
 800c12a:	69f8      	ldr	r0, [r7, #28]
 800c12c:	f000 f81f 	bl	800c16e <wolfSSL_CTX_free>
            ctx = NULL;
 800c130:	2300      	movs	r3, #0
 800c132:	61fb      	str	r3, [r7, #28]
 800c134:	e007      	b.n	800c146 <wolfSSL_CTX_new_ex+0x7e>
        }
#endif
    }
    else {
        WOLFSSL_MSG("Alloc CTX failed, method freed");
        XFREE(method, heap, DYNAMIC_TYPE_METHOD);
 800c136:	687b      	ldr	r3, [r7, #4]
 800c138:	613b      	str	r3, [r7, #16]
 800c13a:	693b      	ldr	r3, [r7, #16]
 800c13c:	2b00      	cmp	r3, #0
 800c13e:	d002      	beq.n	800c146 <wolfSSL_CTX_new_ex+0x7e>
 800c140:	6938      	ldr	r0, [r7, #16]
 800c142:	f012 fcbd 	bl	801eac0 <wolfSSL_Free>
        }
    }
#endif /* WOLFSSL_SYS_CRYPTO_POLICY */

    WOLFSSL_LEAVE("wolfSSL_CTX_new_ex", 0);
    return ctx;
 800c146:	69fb      	ldr	r3, [r7, #28]
}
 800c148:	4618      	mov	r0, r3
 800c14a:	3720      	adds	r7, #32
 800c14c:	46bd      	mov	sp, r7
 800c14e:	bd80      	pop	{r7, pc}
 800c150:	200028d8 	.word	0x200028d8

0800c154 <wolfSSL_CTX_new>:


WOLFSSL_ABI
WOLFSSL_CTX* wolfSSL_CTX_new(WOLFSSL_METHOD* method)
{
 800c154:	b580      	push	{r7, lr}
 800c156:	b082      	sub	sp, #8
 800c158:	af00      	add	r7, sp, #0
 800c15a:	6078      	str	r0, [r7, #4]
#ifdef WOLFSSL_HEAP_TEST
    /* if testing the heap hint then set top level CTX to have test value */
    return wolfSSL_CTX_new_ex(method, (void*)WOLFSSL_HEAP_TEST);
#else
    return wolfSSL_CTX_new_ex(method, NULL);
 800c15c:	2100      	movs	r1, #0
 800c15e:	6878      	ldr	r0, [r7, #4]
 800c160:	f7ff ffb2 	bl	800c0c8 <wolfSSL_CTX_new_ex>
 800c164:	4603      	mov	r3, r0
#endif
}
 800c166:	4618      	mov	r0, r3
 800c168:	3708      	adds	r7, #8
 800c16a:	46bd      	mov	sp, r7
 800c16c:	bd80      	pop	{r7, pc}

0800c16e <wolfSSL_CTX_free>:
#endif
}

WOLFSSL_ABI
void wolfSSL_CTX_free(WOLFSSL_CTX* ctx)
{
 800c16e:	b580      	push	{r7, lr}
 800c170:	b082      	sub	sp, #8
 800c172:	af00      	add	r7, sp, #0
 800c174:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_CTX_free");
    if (ctx) {
 800c176:	687b      	ldr	r3, [r7, #4]
 800c178:	2b00      	cmp	r3, #0
 800c17a:	d002      	beq.n	800c182 <wolfSSL_CTX_free+0x14>
            wc_SrpTerm(ctx->srp);
            XFREE(ctx->srp, ctx->heap, DYNAMIC_TYPE_SRP);
            ctx->srp = NULL;
        }
#endif
        FreeSSL_Ctx(ctx);
 800c17c:	6878      	ldr	r0, [r7, #4]
 800c17e:	f7fc fdc9 	bl	8008d14 <FreeSSL_Ctx>
    }

    WOLFSSL_LEAVE("wolfSSL_CTX_free", 0);
}
 800c182:	bf00      	nop
 800c184:	3708      	adds	r7, #8
 800c186:	46bd      	mov	sp, r7
 800c188:	bd80      	pop	{r7, pc}

0800c18a <wolfSSL_free>:
}


WOLFSSL_ABI
void wolfSSL_free(WOLFSSL* ssl)
{
 800c18a:	b580      	push	{r7, lr}
 800c18c:	b082      	sub	sp, #8
 800c18e:	af00      	add	r7, sp, #0
 800c190:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_free");

    if (ssl) {
 800c192:	687b      	ldr	r3, [r7, #4]
 800c194:	2b00      	cmp	r3, #0
 800c196:	d006      	beq.n	800c1a6 <wolfSSL_free+0x1c>
        WOLFSSL_MSG_EX("Free SSL: %p", (wc_ptr_t)ssl);
        FreeSSL(ssl, ssl->ctx->heap);
 800c198:	687b      	ldr	r3, [r7, #4]
 800c19a:	681b      	ldr	r3, [r3, #0]
 800c19c:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800c19e:	4619      	mov	r1, r3
 800c1a0:	6878      	ldr	r0, [r7, #4]
 800c1a2:	f7fd fdbb 	bl	8009d1c <FreeSSL>
    }
    else {
        WOLFSSL_MSG("Free SSL: wolfSSL_free already null");
    }
    WOLFSSL_LEAVE("wolfSSL_free", 0);
}
 800c1a6:	bf00      	nop
 800c1a8:	3708      	adds	r7, #8
 800c1aa:	46bd      	mov	sp, r7
 800c1ac:	bd80      	pop	{r7, pc}

0800c1ae <wolfSSL_CTX_GetDevId>:
}

/* helpers to get device id and heap */
WOLFSSL_ABI
int wolfSSL_CTX_GetDevId(WOLFSSL_CTX* ctx, WOLFSSL* ssl)
{
 800c1ae:	b480      	push	{r7}
 800c1b0:	b085      	sub	sp, #20
 800c1b2:	af00      	add	r7, sp, #0
 800c1b4:	6078      	str	r0, [r7, #4]
 800c1b6:	6039      	str	r1, [r7, #0]
    int devId = INVALID_DEVID;
 800c1b8:	f06f 0301 	mvn.w	r3, #1
 800c1bc:	60fb      	str	r3, [r7, #12]
    if (ssl != NULL)
 800c1be:	683b      	ldr	r3, [r7, #0]
 800c1c0:	2b00      	cmp	r3, #0
 800c1c2:	d005      	beq.n	800c1d0 <wolfSSL_CTX_GetDevId+0x22>
        devId = ssl->devId;
 800c1c4:	683b      	ldr	r3, [r7, #0]
 800c1c6:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 800c1ca:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 800c1ce:	60fb      	str	r3, [r7, #12]
    if (ctx != NULL && devId == INVALID_DEVID)
 800c1d0:	687b      	ldr	r3, [r7, #4]
 800c1d2:	2b00      	cmp	r3, #0
 800c1d4:	d007      	beq.n	800c1e6 <wolfSSL_CTX_GetDevId+0x38>
 800c1d6:	68fb      	ldr	r3, [r7, #12]
 800c1d8:	f113 0f02 	cmn.w	r3, #2
 800c1dc:	d103      	bne.n	800c1e6 <wolfSSL_CTX_GetDevId+0x38>
        devId = ctx->devId;
 800c1de:	687b      	ldr	r3, [r7, #4]
 800c1e0:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
 800c1e4:	60fb      	str	r3, [r7, #12]
    return devId;
 800c1e6:	68fb      	ldr	r3, [r7, #12]
}
 800c1e8:	4618      	mov	r0, r3
 800c1ea:	3714      	adds	r7, #20
 800c1ec:	46bd      	mov	sp, r7
 800c1ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c1f2:	4770      	bx	lr

0800c1f4 <wolfSSL_CTX_GetCertManager>:

#endif /* ATOMIC_USER */

#ifndef NO_CERTS
WOLFSSL_CERT_MANAGER* wolfSSL_CTX_GetCertManager(WOLFSSL_CTX* ctx)
{
 800c1f4:	b480      	push	{r7}
 800c1f6:	b085      	sub	sp, #20
 800c1f8:	af00      	add	r7, sp, #0
 800c1fa:	6078      	str	r0, [r7, #4]
    WOLFSSL_CERT_MANAGER* cm = NULL;
 800c1fc:	2300      	movs	r3, #0
 800c1fe:	60fb      	str	r3, [r7, #12]
    if (ctx)
 800c200:	687b      	ldr	r3, [r7, #4]
 800c202:	2b00      	cmp	r3, #0
 800c204:	d002      	beq.n	800c20c <wolfSSL_CTX_GetCertManager+0x18>
        cm = ctx->cm;
 800c206:	687b      	ldr	r3, [r7, #4]
 800c208:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800c20a:	60fb      	str	r3, [r7, #12]
    return cm;
 800c20c:	68fb      	ldr	r3, [r7, #12]
}
 800c20e:	4618      	mov	r0, r3
 800c210:	3714      	adds	r7, #20
 800c212:	46bd      	mov	sp, r7
 800c214:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c218:	4770      	bx	lr
	...

0800c21c <HashSigner>:

#ifndef NO_CERTS

/* hash is the SHA digest of name, just use first 32 bits as hash */
static WC_INLINE word32 HashSigner(const byte* hash)
{
 800c21c:	b580      	push	{r7, lr}
 800c21e:	b082      	sub	sp, #8
 800c220:	af00      	add	r7, sp, #0
 800c222:	6078      	str	r0, [r7, #4]
    return MakeWordFromHash(hash) % CA_TABLE_SIZE;
 800c224:	6878      	ldr	r0, [r7, #4]
 800c226:	f7fe ffc6 	bl	800b1b6 <MakeWordFromHash>
 800c22a:	4601      	mov	r1, r0
 800c22c:	4b07      	ldr	r3, [pc, #28]	@ (800c24c <HashSigner+0x30>)
 800c22e:	fba3 2301 	umull	r2, r3, r3, r1
 800c232:	08da      	lsrs	r2, r3, #3
 800c234:	4613      	mov	r3, r2
 800c236:	009b      	lsls	r3, r3, #2
 800c238:	4413      	add	r3, r2
 800c23a:	005b      	lsls	r3, r3, #1
 800c23c:	4413      	add	r3, r2
 800c23e:	1aca      	subs	r2, r1, r3
 800c240:	4613      	mov	r3, r2
}
 800c242:	4618      	mov	r0, r3
 800c244:	3708      	adds	r7, #8
 800c246:	46bd      	mov	sp, r7
 800c248:	bd80      	pop	{r7, pc}
 800c24a:	bf00      	nop
 800c24c:	ba2e8ba3 	.word	0xba2e8ba3

0800c250 <AlreadySigner>:


/* does CA already exist on signer list */
int AlreadySigner(WOLFSSL_CERT_MANAGER* cm, byte* hash)
{
 800c250:	b580      	push	{r7, lr}
 800c252:	b086      	sub	sp, #24
 800c254:	af00      	add	r7, sp, #0
 800c256:	6078      	str	r0, [r7, #4]
 800c258:	6039      	str	r1, [r7, #0]
    Signer* signers;
    int     ret = 0;
 800c25a:	2300      	movs	r3, #0
 800c25c:	613b      	str	r3, [r7, #16]
    word32  row;

    if (cm == NULL || hash == NULL) {
 800c25e:	687b      	ldr	r3, [r7, #4]
 800c260:	2b00      	cmp	r3, #0
 800c262:	d002      	beq.n	800c26a <AlreadySigner+0x1a>
 800c264:	683b      	ldr	r3, [r7, #0]
 800c266:	2b00      	cmp	r3, #0
 800c268:	d101      	bne.n	800c26e <AlreadySigner+0x1e>
        return ret;
 800c26a:	693b      	ldr	r3, [r7, #16]
 800c26c:	e02e      	b.n	800c2cc <AlreadySigner+0x7c>
    }

    row = HashSigner(hash);
 800c26e:	6838      	ldr	r0, [r7, #0]
 800c270:	f7ff ffd4 	bl	800c21c <HashSigner>
 800c274:	60f8      	str	r0, [r7, #12]

    if (wc_LockMutex(&cm->caLock) != 0) {
 800c276:	687b      	ldr	r3, [r7, #4]
 800c278:	335c      	adds	r3, #92	@ 0x5c
 800c27a:	4618      	mov	r0, r3
 800c27c:	f01b f894 	bl	80273a8 <wc_LockMutex>
 800c280:	4603      	mov	r3, r0
 800c282:	2b00      	cmp	r3, #0
 800c284:	d001      	beq.n	800c28a <AlreadySigner+0x3a>
        return ret;
 800c286:	693b      	ldr	r3, [r7, #16]
 800c288:	e020      	b.n	800c2cc <AlreadySigner+0x7c>
    }
    signers = cm->caTable[row];
 800c28a:	687b      	ldr	r3, [r7, #4]
 800c28c:	68fa      	ldr	r2, [r7, #12]
 800c28e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800c292:	617b      	str	r3, [r7, #20]
    while (signers) {
 800c294:	e011      	b.n	800c2ba <AlreadySigner+0x6a>
        byte* subjectHash;

    #ifndef NO_SKID
        subjectHash = signers->subjectKeyIdHash;
 800c296:	697b      	ldr	r3, [r7, #20]
 800c298:	3340      	adds	r3, #64	@ 0x40
 800c29a:	60bb      	str	r3, [r7, #8]
    #else
        subjectHash = signers->subjectNameHash;
    #endif

        if (XMEMCMP(hash, subjectHash, SIGNER_DIGEST_SIZE) == 0) {
 800c29c:	2220      	movs	r2, #32
 800c29e:	68b9      	ldr	r1, [r7, #8]
 800c2a0:	6838      	ldr	r0, [r7, #0]
 800c2a2:	f01c f8e7 	bl	8028474 <memcmp>
 800c2a6:	4603      	mov	r3, r0
 800c2a8:	2b00      	cmp	r3, #0
 800c2aa:	d102      	bne.n	800c2b2 <AlreadySigner+0x62>
            ret = 1; /* success */
 800c2ac:	2301      	movs	r3, #1
 800c2ae:	613b      	str	r3, [r7, #16]
            break;
 800c2b0:	e006      	b.n	800c2c0 <AlreadySigner+0x70>
        }
        signers = signers->next;
 800c2b2:	697b      	ldr	r3, [r7, #20]
 800c2b4:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800c2b8:	617b      	str	r3, [r7, #20]
    while (signers) {
 800c2ba:	697b      	ldr	r3, [r7, #20]
 800c2bc:	2b00      	cmp	r3, #0
 800c2be:	d1ea      	bne.n	800c296 <AlreadySigner+0x46>
    }
    wc_UnLockMutex(&cm->caLock);
 800c2c0:	687b      	ldr	r3, [r7, #4]
 800c2c2:	335c      	adds	r3, #92	@ 0x5c
 800c2c4:	4618      	mov	r0, r3
 800c2c6:	f01b f87a 	bl	80273be <wc_UnLockMutex>

    return ret;
 800c2ca:	693b      	ldr	r3, [r7, #16]
}
 800c2cc:	4618      	mov	r0, r3
 800c2ce:	3718      	adds	r7, #24
 800c2d0:	46bd      	mov	sp, r7
 800c2d2:	bd80      	pop	{r7, pc}

0800c2d4 <GetCA>:
#endif /* WOLFSSL_TRUST_PEER_CERT */


/* return CA if found, otherwise NULL */
Signer* GetCA(void* vp, byte* hash)
{
 800c2d4:	b580      	push	{r7, lr}
 800c2d6:	b088      	sub	sp, #32
 800c2d8:	af00      	add	r7, sp, #0
 800c2da:	6078      	str	r0, [r7, #4]
 800c2dc:	6039      	str	r1, [r7, #0]
    WOLFSSL_CERT_MANAGER* cm = (WOLFSSL_CERT_MANAGER*)vp;
 800c2de:	687b      	ldr	r3, [r7, #4]
 800c2e0:	617b      	str	r3, [r7, #20]
    Signer* ret = NULL;
 800c2e2:	2300      	movs	r3, #0
 800c2e4:	61fb      	str	r3, [r7, #28]
    Signer* signers;
    word32  row = 0;
 800c2e6:	2300      	movs	r3, #0
 800c2e8:	613b      	str	r3, [r7, #16]

    if (cm == NULL || hash == NULL)
 800c2ea:	697b      	ldr	r3, [r7, #20]
 800c2ec:	2b00      	cmp	r3, #0
 800c2ee:	d002      	beq.n	800c2f6 <GetCA+0x22>
 800c2f0:	683b      	ldr	r3, [r7, #0]
 800c2f2:	2b00      	cmp	r3, #0
 800c2f4:	d101      	bne.n	800c2fa <GetCA+0x26>
        return NULL;
 800c2f6:	2300      	movs	r3, #0
 800c2f8:	e02e      	b.n	800c358 <GetCA+0x84>

    row = HashSigner(hash);
 800c2fa:	6838      	ldr	r0, [r7, #0]
 800c2fc:	f7ff ff8e 	bl	800c21c <HashSigner>
 800c300:	6138      	str	r0, [r7, #16]

    if (wc_LockMutex(&cm->caLock) != 0)
 800c302:	697b      	ldr	r3, [r7, #20]
 800c304:	335c      	adds	r3, #92	@ 0x5c
 800c306:	4618      	mov	r0, r3
 800c308:	f01b f84e 	bl	80273a8 <wc_LockMutex>
 800c30c:	4603      	mov	r3, r0
 800c30e:	2b00      	cmp	r3, #0
 800c310:	d001      	beq.n	800c316 <GetCA+0x42>
        return ret;
 800c312:	69fb      	ldr	r3, [r7, #28]
 800c314:	e020      	b.n	800c358 <GetCA+0x84>

    signers = cm->caTable[row];
 800c316:	697b      	ldr	r3, [r7, #20]
 800c318:	693a      	ldr	r2, [r7, #16]
 800c31a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800c31e:	61bb      	str	r3, [r7, #24]
    while (signers) {
 800c320:	e011      	b.n	800c346 <GetCA+0x72>
        byte* subjectHash;
        #ifndef NO_SKID
            subjectHash = signers->subjectKeyIdHash;
 800c322:	69bb      	ldr	r3, [r7, #24]
 800c324:	3340      	adds	r3, #64	@ 0x40
 800c326:	60fb      	str	r3, [r7, #12]
        #else
            subjectHash = signers->subjectNameHash;
        #endif
        if (XMEMCMP(hash, subjectHash, SIGNER_DIGEST_SIZE) == 0) {
 800c328:	2220      	movs	r2, #32
 800c32a:	68f9      	ldr	r1, [r7, #12]
 800c32c:	6838      	ldr	r0, [r7, #0]
 800c32e:	f01c f8a1 	bl	8028474 <memcmp>
 800c332:	4603      	mov	r3, r0
 800c334:	2b00      	cmp	r3, #0
 800c336:	d102      	bne.n	800c33e <GetCA+0x6a>
            ret = signers;
 800c338:	69bb      	ldr	r3, [r7, #24]
 800c33a:	61fb      	str	r3, [r7, #28]
            break;
 800c33c:	e006      	b.n	800c34c <GetCA+0x78>
        }
        signers = signers->next;
 800c33e:	69bb      	ldr	r3, [r7, #24]
 800c340:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800c344:	61bb      	str	r3, [r7, #24]
    while (signers) {
 800c346:	69bb      	ldr	r3, [r7, #24]
 800c348:	2b00      	cmp	r3, #0
 800c34a:	d1ea      	bne.n	800c322 <GetCA+0x4e>
    }
    wc_UnLockMutex(&cm->caLock);
 800c34c:	697b      	ldr	r3, [r7, #20]
 800c34e:	335c      	adds	r3, #92	@ 0x5c
 800c350:	4618      	mov	r0, r3
 800c352:	f01b f834 	bl	80273be <wc_UnLockMutex>

    return ret;
 800c356:	69fb      	ldr	r3, [r7, #28]
}
 800c358:	4618      	mov	r0, r3
 800c35a:	3720      	adds	r7, #32
 800c35c:	46bd      	mov	sp, r7
 800c35e:	bd80      	pop	{r7, pc}

0800c360 <GetCAByAKID>:
}
#endif
#ifdef WOLFSSL_AKID_NAME
Signer* GetCAByAKID(void* vp, const byte* issuer, word32 issuerSz,
        const byte* serial, word32 serialSz)
{
 800c360:	b580      	push	{r7, lr}
 800c362:	b098      	sub	sp, #96	@ 0x60
 800c364:	af00      	add	r7, sp, #0
 800c366:	60f8      	str	r0, [r7, #12]
 800c368:	60b9      	str	r1, [r7, #8]
 800c36a:	607a      	str	r2, [r7, #4]
 800c36c:	603b      	str	r3, [r7, #0]
    WOLFSSL_CERT_MANAGER* cm = (WOLFSSL_CERT_MANAGER*)vp;
 800c36e:	68fb      	ldr	r3, [r7, #12]
 800c370:	653b      	str	r3, [r7, #80]	@ 0x50
    Signer* ret = NULL;
 800c372:	2300      	movs	r3, #0
 800c374:	65fb      	str	r3, [r7, #92]	@ 0x5c
    Signer* signers;
    byte nameHash[SIGNER_DIGEST_SIZE];
    byte serialHash[SIGNER_DIGEST_SIZE];
    word32 row;

    if (cm == NULL || issuer == NULL || issuerSz == 0 ||
 800c376:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800c378:	2b00      	cmp	r3, #0
 800c37a:	d00b      	beq.n	800c394 <GetCAByAKID+0x34>
 800c37c:	68bb      	ldr	r3, [r7, #8]
 800c37e:	2b00      	cmp	r3, #0
 800c380:	d008      	beq.n	800c394 <GetCAByAKID+0x34>
 800c382:	687b      	ldr	r3, [r7, #4]
 800c384:	2b00      	cmp	r3, #0
 800c386:	d005      	beq.n	800c394 <GetCAByAKID+0x34>
 800c388:	683b      	ldr	r3, [r7, #0]
 800c38a:	2b00      	cmp	r3, #0
 800c38c:	d002      	beq.n	800c394 <GetCAByAKID+0x34>
            serial == NULL || serialSz == 0)
 800c38e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 800c390:	2b00      	cmp	r3, #0
 800c392:	d101      	bne.n	800c398 <GetCAByAKID+0x38>
        return NULL;
 800c394:	2300      	movs	r3, #0
 800c396:	e057      	b.n	800c448 <GetCAByAKID+0xe8>

    if (CalcHashId(issuer, issuerSz, nameHash) != 0 ||
 800c398:	f107 0330 	add.w	r3, r7, #48	@ 0x30
 800c39c:	461a      	mov	r2, r3
 800c39e:	6879      	ldr	r1, [r7, #4]
 800c3a0:	68b8      	ldr	r0, [r7, #8]
 800c3a2:	f009 f9ac 	bl	80156fe <CalcHashId>
 800c3a6:	4603      	mov	r3, r0
 800c3a8:	2b00      	cmp	r3, #0
 800c3aa:	d109      	bne.n	800c3c0 <GetCAByAKID+0x60>
            CalcHashId(serial, serialSz, serialHash) != 0)
 800c3ac:	f107 0310 	add.w	r3, r7, #16
 800c3b0:	461a      	mov	r2, r3
 800c3b2:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 800c3b4:	6838      	ldr	r0, [r7, #0]
 800c3b6:	f009 f9a2 	bl	80156fe <CalcHashId>
 800c3ba:	4603      	mov	r3, r0
    if (CalcHashId(issuer, issuerSz, nameHash) != 0 ||
 800c3bc:	2b00      	cmp	r3, #0
 800c3be:	d001      	beq.n	800c3c4 <GetCAByAKID+0x64>
        return NULL;
 800c3c0:	2300      	movs	r3, #0
 800c3c2:	e041      	b.n	800c448 <GetCAByAKID+0xe8>

    if (wc_LockMutex(&cm->caLock) != 0)
 800c3c4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800c3c6:	335c      	adds	r3, #92	@ 0x5c
 800c3c8:	4618      	mov	r0, r3
 800c3ca:	f01a ffed 	bl	80273a8 <wc_LockMutex>
 800c3ce:	4603      	mov	r3, r0
 800c3d0:	2b00      	cmp	r3, #0
 800c3d2:	d001      	beq.n	800c3d8 <GetCAByAKID+0x78>
        return ret;
 800c3d4:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 800c3d6:	e037      	b.n	800c448 <GetCAByAKID+0xe8>

    /* Unfortunately we need to look through the entire table */
    for (row = 0; row < CA_TABLE_SIZE && ret == NULL; row++) {
 800c3d8:	2300      	movs	r3, #0
 800c3da:	657b      	str	r3, [r7, #84]	@ 0x54
 800c3dc:	e028      	b.n	800c430 <GetCAByAKID+0xd0>
        for (signers = cm->caTable[row]; signers != NULL;
 800c3de:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800c3e0:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 800c3e2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800c3e6:	65bb      	str	r3, [r7, #88]	@ 0x58
 800c3e8:	e01c      	b.n	800c424 <GetCAByAKID+0xc4>
                signers = signers->next) {
            if (XMEMCMP(signers->subjectNameHash, nameHash, SIGNER_DIGEST_SIZE)
 800c3ea:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 800c3ec:	3320      	adds	r3, #32
 800c3ee:	f107 0130 	add.w	r1, r7, #48	@ 0x30
 800c3f2:	2220      	movs	r2, #32
 800c3f4:	4618      	mov	r0, r3
 800c3f6:	f01c f83d 	bl	8028474 <memcmp>
 800c3fa:	4603      	mov	r3, r0
 800c3fc:	2b00      	cmp	r3, #0
 800c3fe:	d10d      	bne.n	800c41c <GetCAByAKID+0xbc>
                    == 0 && XMEMCMP(signers->serialHash, serialHash,
 800c400:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 800c402:	3360      	adds	r3, #96	@ 0x60
 800c404:	f107 0110 	add.w	r1, r7, #16
 800c408:	2220      	movs	r2, #32
 800c40a:	4618      	mov	r0, r3
 800c40c:	f01c f832 	bl	8028474 <memcmp>
 800c410:	4603      	mov	r3, r0
 800c412:	2b00      	cmp	r3, #0
 800c414:	d102      	bne.n	800c41c <GetCAByAKID+0xbc>
                                    SIGNER_DIGEST_SIZE) == 0) {
                ret = signers;
 800c416:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 800c418:	65fb      	str	r3, [r7, #92]	@ 0x5c
                break;
 800c41a:	e006      	b.n	800c42a <GetCAByAKID+0xca>
                signers = signers->next) {
 800c41c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 800c41e:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800c422:	65bb      	str	r3, [r7, #88]	@ 0x58
        for (signers = cm->caTable[row]; signers != NULL;
 800c424:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 800c426:	2b00      	cmp	r3, #0
 800c428:	d1df      	bne.n	800c3ea <GetCAByAKID+0x8a>
    for (row = 0; row < CA_TABLE_SIZE && ret == NULL; row++) {
 800c42a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800c42c:	3301      	adds	r3, #1
 800c42e:	657b      	str	r3, [r7, #84]	@ 0x54
 800c430:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800c432:	2b0a      	cmp	r3, #10
 800c434:	d802      	bhi.n	800c43c <GetCAByAKID+0xdc>
 800c436:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 800c438:	2b00      	cmp	r3, #0
 800c43a:	d0d0      	beq.n	800c3de <GetCAByAKID+0x7e>
            }
        }
    }

    wc_UnLockMutex(&cm->caLock);
 800c43c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800c43e:	335c      	adds	r3, #92	@ 0x5c
 800c440:	4618      	mov	r0, r3
 800c442:	f01a ffbc 	bl	80273be <wc_UnLockMutex>

    return ret;
 800c446:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
}
 800c448:	4618      	mov	r0, r3
 800c44a:	3760      	adds	r7, #96	@ 0x60
 800c44c:	46bd      	mov	sp, r7
 800c44e:	bd80      	pop	{r7, pc}

0800c450 <GetCAByName>:
#endif

#ifndef NO_SKID
/* return CA if found, otherwise NULL. Walk through hash table. */
Signer* GetCAByName(void* vp, byte* hash)
{
 800c450:	b580      	push	{r7, lr}
 800c452:	b086      	sub	sp, #24
 800c454:	af00      	add	r7, sp, #0
 800c456:	6078      	str	r0, [r7, #4]
 800c458:	6039      	str	r1, [r7, #0]
    WOLFSSL_CERT_MANAGER* cm = (WOLFSSL_CERT_MANAGER*)vp;
 800c45a:	687b      	ldr	r3, [r7, #4]
 800c45c:	60bb      	str	r3, [r7, #8]
    Signer* ret = NULL;
 800c45e:	2300      	movs	r3, #0
 800c460:	617b      	str	r3, [r7, #20]
    Signer* signers;
    word32  row;

    if (cm == NULL)
 800c462:	68bb      	ldr	r3, [r7, #8]
 800c464:	2b00      	cmp	r3, #0
 800c466:	d101      	bne.n	800c46c <GetCAByName+0x1c>
        return NULL;
 800c468:	2300      	movs	r3, #0
 800c46a:	e037      	b.n	800c4dc <GetCAByName+0x8c>

    if (wc_LockMutex(&cm->caLock) != 0)
 800c46c:	68bb      	ldr	r3, [r7, #8]
 800c46e:	335c      	adds	r3, #92	@ 0x5c
 800c470:	4618      	mov	r0, r3
 800c472:	f01a ff99 	bl	80273a8 <wc_LockMutex>
 800c476:	4603      	mov	r3, r0
 800c478:	2b00      	cmp	r3, #0
 800c47a:	d001      	beq.n	800c480 <GetCAByName+0x30>
        return ret;
 800c47c:	697b      	ldr	r3, [r7, #20]
 800c47e:	e02d      	b.n	800c4dc <GetCAByName+0x8c>

    for (row = 0; row < CA_TABLE_SIZE && ret == NULL; row++) {
 800c480:	2300      	movs	r3, #0
 800c482:	60fb      	str	r3, [r7, #12]
 800c484:	e01e      	b.n	800c4c4 <GetCAByName+0x74>
        signers = cm->caTable[row];
 800c486:	68bb      	ldr	r3, [r7, #8]
 800c488:	68fa      	ldr	r2, [r7, #12]
 800c48a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800c48e:	613b      	str	r3, [r7, #16]
        while (signers && ret == NULL) {
 800c490:	e00f      	b.n	800c4b2 <GetCAByName+0x62>
            if (XMEMCMP(hash, signers->subjectNameHash,
 800c492:	693b      	ldr	r3, [r7, #16]
 800c494:	3320      	adds	r3, #32
 800c496:	2220      	movs	r2, #32
 800c498:	4619      	mov	r1, r3
 800c49a:	6838      	ldr	r0, [r7, #0]
 800c49c:	f01b ffea 	bl	8028474 <memcmp>
 800c4a0:	4603      	mov	r3, r0
 800c4a2:	2b00      	cmp	r3, #0
 800c4a4:	d101      	bne.n	800c4aa <GetCAByName+0x5a>
                        SIGNER_DIGEST_SIZE) == 0) {
                ret = signers;
 800c4a6:	693b      	ldr	r3, [r7, #16]
 800c4a8:	617b      	str	r3, [r7, #20]
            }
            signers = signers->next;
 800c4aa:	693b      	ldr	r3, [r7, #16]
 800c4ac:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800c4b0:	613b      	str	r3, [r7, #16]
        while (signers && ret == NULL) {
 800c4b2:	693b      	ldr	r3, [r7, #16]
 800c4b4:	2b00      	cmp	r3, #0
 800c4b6:	d002      	beq.n	800c4be <GetCAByName+0x6e>
 800c4b8:	697b      	ldr	r3, [r7, #20]
 800c4ba:	2b00      	cmp	r3, #0
 800c4bc:	d0e9      	beq.n	800c492 <GetCAByName+0x42>
    for (row = 0; row < CA_TABLE_SIZE && ret == NULL; row++) {
 800c4be:	68fb      	ldr	r3, [r7, #12]
 800c4c0:	3301      	adds	r3, #1
 800c4c2:	60fb      	str	r3, [r7, #12]
 800c4c4:	68fb      	ldr	r3, [r7, #12]
 800c4c6:	2b0a      	cmp	r3, #10
 800c4c8:	d802      	bhi.n	800c4d0 <GetCAByName+0x80>
 800c4ca:	697b      	ldr	r3, [r7, #20]
 800c4cc:	2b00      	cmp	r3, #0
 800c4ce:	d0da      	beq.n	800c486 <GetCAByName+0x36>
        }
    }
    wc_UnLockMutex(&cm->caLock);
 800c4d0:	68bb      	ldr	r3, [r7, #8]
 800c4d2:	335c      	adds	r3, #92	@ 0x5c
 800c4d4:	4618      	mov	r0, r3
 800c4d6:	f01a ff72 	bl	80273be <wc_UnLockMutex>

    return ret;
 800c4da:	697b      	ldr	r3, [r7, #20]
}
 800c4dc:	4618      	mov	r0, r3
 800c4de:	3718      	adds	r7, #24
 800c4e0:	46bd      	mov	sp, r7
 800c4e2:	bd80      	pop	{r7, pc}

0800c4e4 <AddCA>:

/* owns der, internal now uses too */
/* type flag ids from user or from chain received during verify
   don't allow chain ones to be added w/o isCA extension */
int AddCA(WOLFSSL_CERT_MANAGER* cm, DerBuffer** pDer, int type, int verify)
{
 800c4e4:	b580      	push	{r7, lr}
 800c4e6:	b08c      	sub	sp, #48	@ 0x30
 800c4e8:	af00      	add	r7, sp, #0
 800c4ea:	60f8      	str	r0, [r7, #12]
 800c4ec:	60b9      	str	r1, [r7, #8]
 800c4ee:	607a      	str	r2, [r7, #4]
 800c4f0:	603b      	str	r3, [r7, #0]
    int         ret;
    Signer*     signer = NULL;
 800c4f2:	2300      	movs	r3, #0
 800c4f4:	62bb      	str	r3, [r7, #40]	@ 0x28
    word32      row;
    byte*       subjectHash;
#ifdef WOLFSSL_SMALL_STACK
    DecodedCert* cert = NULL;
 800c4f6:	2300      	movs	r3, #0
 800c4f8:	627b      	str	r3, [r7, #36]	@ 0x24
#else
    DecodedCert  cert[1];
#endif
    DerBuffer*   der = *pDer;
 800c4fa:	68bb      	ldr	r3, [r7, #8]
 800c4fc:	681b      	ldr	r3, [r3, #0]
 800c4fe:	623b      	str	r3, [r7, #32]

    WOLFSSL_MSG("Adding a CA");

    if (cm == NULL) {
 800c500:	68fb      	ldr	r3, [r7, #12]
 800c502:	2b00      	cmp	r3, #0
 800c504:	d105      	bne.n	800c512 <AddCA+0x2e>
        FreeDer(pDer);
 800c506:	68b8      	ldr	r0, [r7, #8]
 800c508:	f00c fd38 	bl	8018f7c <FreeDer>
        return BAD_FUNC_ARG;
 800c50c:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800c510:	e110      	b.n	800c734 <AddCA+0x250>
    }

#ifdef WOLFSSL_SMALL_STACK
    cert = (DecodedCert*)XMALLOC(sizeof(DecodedCert), NULL,
 800c512:	f44f 6097 	mov.w	r0, #1208	@ 0x4b8
 800c516:	f012 fab7 	bl	801ea88 <wolfSSL_Malloc>
 800c51a:	6278      	str	r0, [r7, #36]	@ 0x24
                                 DYNAMIC_TYPE_DCERT);
    if (cert == NULL) {
 800c51c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c51e:	2b00      	cmp	r3, #0
 800c520:	d105      	bne.n	800c52e <AddCA+0x4a>
        FreeDer(pDer);
 800c522:	68b8      	ldr	r0, [r7, #8]
 800c524:	f00c fd2a 	bl	8018f7c <FreeDer>
        return MEMORY_E;
 800c528:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800c52c:	e102      	b.n	800c734 <AddCA+0x250>
    }
#endif

    InitDecodedCert(cert, der->buffer, der->length, cm->heap);
 800c52e:	6a3b      	ldr	r3, [r7, #32]
 800c530:	6819      	ldr	r1, [r3, #0]
 800c532:	6a3b      	ldr	r3, [r7, #32]
 800c534:	689a      	ldr	r2, [r3, #8]
 800c536:	68fb      	ldr	r3, [r7, #12]
 800c538:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800c53a:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800c53c:	f008 fdd1 	bl	80150e2 <InitDecodedCert>
    if (cm->unknownExtCallback != NULL) {
        wc_SetUnknownExtCallback(cert, cm->unknownExtCallback);
    }
#endif

    ret = ParseCert(cert, CA_TYPE, verify, cm);
 800c540:	68fb      	ldr	r3, [r7, #12]
 800c542:	683a      	ldr	r2, [r7, #0]
 800c544:	2106      	movs	r1, #6
 800c546:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800c548:	f00c f893 	bl	8018672 <ParseCert>
 800c54c:	62f8      	str	r0, [r7, #44]	@ 0x2c
    WOLFSSL_MSG("\tParsed new CA");

#ifndef NO_SKID
    subjectHash = cert->extSubjKeyId;
 800c54e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c550:	f503 7371 	add.w	r3, r3, #964	@ 0x3c4
 800c554:	61fb      	str	r3, [r7, #28]
#else
    subjectHash = cert->subjectHash;
#endif

    /* check CA key size */
    if (verify) {
 800c556:	683b      	ldr	r3, [r7, #0]
 800c558:	2b00      	cmp	r3, #0
 800c55a:	d037      	beq.n	800c5cc <AddCA+0xe8>
        switch (cert->keyOID) {
 800c55c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c55e:	69db      	ldr	r3, [r3, #28]
 800c560:	f240 228e 	movw	r2, #654	@ 0x28e
 800c564:	4293      	cmp	r3, r2
 800c566:	d00b      	beq.n	800c580 <AddCA+0x9c>
 800c568:	f240 228e 	movw	r2, #654	@ 0x28e
 800c56c:	4293      	cmp	r3, r2
 800c56e:	d828      	bhi.n	800c5c2 <AddCA+0xde>
 800c570:	f240 2206 	movw	r2, #518	@ 0x206
 800c574:	4293      	cmp	r3, r2
 800c576:	d014      	beq.n	800c5a2 <AddCA+0xbe>
 800c578:	f240 2285 	movw	r2, #645	@ 0x285
 800c57c:	4293      	cmp	r3, r2
 800c57e:	d120      	bne.n	800c5c2 <AddCA+0xde>
        #ifndef NO_RSA
            #ifdef WC_RSA_PSS
            case RSAPSSk:
            #endif
            case RSAk:
                if (cm->minRsaKeySz < 0 ||
 800c580:	68fb      	ldr	r3, [r7, #12]
 800c582:	f9b3 3062 	ldrsh.w	r3, [r3, #98]	@ 0x62
 800c586:	2b00      	cmp	r3, #0
 800c588:	db07      	blt.n	800c59a <AddCA+0xb6>
                                   cert->pubKeySize < (word16)cm->minRsaKeySz) {
 800c58a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c58c:	685b      	ldr	r3, [r3, #4]
 800c58e:	68fa      	ldr	r2, [r7, #12]
 800c590:	f9b2 2062 	ldrsh.w	r2, [r2, #98]	@ 0x62
 800c594:	b292      	uxth	r2, r2
                if (cm->minRsaKeySz < 0 ||
 800c596:	4293      	cmp	r3, r2
 800c598:	d215      	bcs.n	800c5c6 <AddCA+0xe2>
                    ret = RSA_KEY_SIZE_E;
 800c59a:	f46f 73cc 	mvn.w	r3, #408	@ 0x198
 800c59e:	62fb      	str	r3, [r7, #44]	@ 0x2c
                    WOLFSSL_MSG("\tCA RSA key size error");
                }
                break;
 800c5a0:	e011      	b.n	800c5c6 <AddCA+0xe2>
        #endif /* !NO_RSA */
            #ifdef HAVE_ECC
            case ECDSAk:
                if (cm->minEccKeySz < 0 ||
 800c5a2:	68fb      	ldr	r3, [r7, #12]
 800c5a4:	f9b3 3064 	ldrsh.w	r3, [r3, #100]	@ 0x64
 800c5a8:	2b00      	cmp	r3, #0
 800c5aa:	db07      	blt.n	800c5bc <AddCA+0xd8>
                                   cert->pubKeySize < (word16)cm->minEccKeySz) {
 800c5ac:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c5ae:	685b      	ldr	r3, [r3, #4]
 800c5b0:	68fa      	ldr	r2, [r7, #12]
 800c5b2:	f9b2 2064 	ldrsh.w	r2, [r2, #100]	@ 0x64
 800c5b6:	b292      	uxth	r2, r2
                if (cm->minEccKeySz < 0 ||
 800c5b8:	4293      	cmp	r3, r2
 800c5ba:	d206      	bcs.n	800c5ca <AddCA+0xe6>
                    ret = ECC_KEY_SIZE_E;
 800c5bc:	4b5f      	ldr	r3, [pc, #380]	@ (800c73c <AddCA+0x258>)
 800c5be:	62fb      	str	r3, [r7, #44]	@ 0x2c
                    WOLFSSL_MSG("\tCA ECC key size error");
                }
                break;
 800c5c0:	e003      	b.n	800c5ca <AddCA+0xe6>
                break;
            #endif /* HAVE_DILITHIUM */

            default:
                WOLFSSL_MSG("\tNo key size check done on CA");
                break; /* no size check if key type is not in switch */
 800c5c2:	bf00      	nop
 800c5c4:	e002      	b.n	800c5cc <AddCA+0xe8>
                break;
 800c5c6:	bf00      	nop
 800c5c8:	e000      	b.n	800c5cc <AddCA+0xe8>
                break;
 800c5ca:	bf00      	nop
        }
    }

    if (ret == 0 && cert->isCA == 0 && type != WOLFSSL_USER_CA &&
 800c5cc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800c5ce:	2b00      	cmp	r3, #0
 800c5d0:	d111      	bne.n	800c5f6 <AddCA+0x112>
 800c5d2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c5d4:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 800c5d8:	f003 0310 	and.w	r3, r3, #16
 800c5dc:	b2db      	uxtb	r3, r3
 800c5de:	2b00      	cmp	r3, #0
 800c5e0:	d109      	bne.n	800c5f6 <AddCA+0x112>
 800c5e2:	687b      	ldr	r3, [r7, #4]
 800c5e4:	2b01      	cmp	r3, #1
 800c5e6:	d006      	beq.n	800c5f6 <AddCA+0x112>
 800c5e8:	687b      	ldr	r3, [r7, #4]
 800c5ea:	2b03      	cmp	r3, #3
 800c5ec:	d003      	beq.n	800c5f6 <AddCA+0x112>
        type != WOLFSSL_TEMP_CA) {
        WOLFSSL_MSG("\tCan't add as CA if not actually one");
        ret = NOT_CA_ERROR;
 800c5ee:	f46f 73b2 	mvn.w	r3, #356	@ 0x164
 800c5f2:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800c5f4:	e03e      	b.n	800c674 <AddCA+0x190>
    }
#ifndef ALLOW_INVALID_CERTSIGN
    else if (ret == 0 && cert->isCA == 1 && type != WOLFSSL_USER_CA &&
 800c5f6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800c5f8:	2b00      	cmp	r3, #0
 800c5fa:	d120      	bne.n	800c63e <AddCA+0x15a>
 800c5fc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c5fe:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 800c602:	f003 0310 	and.w	r3, r3, #16
 800c606:	b2db      	uxtb	r3, r3
 800c608:	2b00      	cmp	r3, #0
 800c60a:	d018      	beq.n	800c63e <AddCA+0x15a>
 800c60c:	687b      	ldr	r3, [r7, #4]
 800c60e:	2b01      	cmp	r3, #1
 800c610:	d015      	beq.n	800c63e <AddCA+0x15a>
 800c612:	687b      	ldr	r3, [r7, #4]
 800c614:	2b03      	cmp	r3, #3
 800c616:	d012      	beq.n	800c63e <AddCA+0x15a>
        type != WOLFSSL_TEMP_CA && !cert->selfSigned &&
 800c618:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c61a:	f893 34b6 	ldrb.w	r3, [r3, #1206]	@ 0x4b6
 800c61e:	f003 0302 	and.w	r3, r3, #2
 800c622:	b2db      	uxtb	r3, r3
 800c624:	2b00      	cmp	r3, #0
 800c626:	d10a      	bne.n	800c63e <AddCA+0x15a>
        (cert->extKeyUsage & KEYUSE_KEY_CERT_SIGN) == 0) {
 800c628:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c62a:	f8b3 3420 	ldrh.w	r3, [r3, #1056]	@ 0x420
 800c62e:	f003 0304 	and.w	r3, r3, #4
        type != WOLFSSL_TEMP_CA && !cert->selfSigned &&
 800c632:	2b00      	cmp	r3, #0
 800c634:	d103      	bne.n	800c63e <AddCA+0x15a>
        /* Intermediate CA certs are required to have the keyCertSign
        * extension set. User loaded root certs are not. */
        WOLFSSL_MSG("\tDoesn't have key usage certificate signing");
        ret = NOT_CA_ERROR;
 800c636:	f46f 73b2 	mvn.w	r3, #356	@ 0x164
 800c63a:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800c63c:	e01a      	b.n	800c674 <AddCA+0x190>
    }
#endif
    else if (ret == 0 && AlreadySigner(cm, subjectHash)) {
 800c63e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800c640:	2b00      	cmp	r3, #0
 800c642:	d106      	bne.n	800c652 <AddCA+0x16e>
 800c644:	69f9      	ldr	r1, [r7, #28]
 800c646:	68f8      	ldr	r0, [r7, #12]
 800c648:	f7ff fe02 	bl	800c250 <AlreadySigner>
 800c64c:	4603      	mov	r3, r0
 800c64e:	2b00      	cmp	r3, #0
 800c650:	d10f      	bne.n	800c672 <AddCA+0x18e>
        WOLFSSL_MSG("\tAlready have this CA, not adding again");
        (void)ret;
    }
    else if (ret == 0) {
 800c652:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800c654:	2b00      	cmp	r3, #0
 800c656:	d10d      	bne.n	800c674 <AddCA+0x190>
        /* take over signer parts */
        signer = MakeSigner(cm->heap);
 800c658:	68fb      	ldr	r3, [r7, #12]
 800c65a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800c65c:	4618      	mov	r0, r3
 800c65e:	f00c fb3b 	bl	8018cd8 <MakeSigner>
 800c662:	62b8      	str	r0, [r7, #40]	@ 0x28
        if (!signer)
 800c664:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800c666:	2b00      	cmp	r3, #0
 800c668:	d104      	bne.n	800c674 <AddCA+0x190>
            ret = MEMORY_ERROR;
 800c66a:	f46f 7397 	mvn.w	r3, #302	@ 0x12e
 800c66e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800c670:	e000      	b.n	800c674 <AddCA+0x190>
        (void)ret;
 800c672:	bf00      	nop
    }
    if (ret == 0 && signer != NULL) {
 800c674:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800c676:	2b00      	cmp	r3, #0
 800c678:	d13c      	bne.n	800c6f4 <AddCA+0x210>
 800c67a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800c67c:	2b00      	cmp	r3, #0
 800c67e:	d039      	beq.n	800c6f4 <AddCA+0x210>
        ret = FillSigner(signer, cert, type, der);
 800c680:	6a3b      	ldr	r3, [r7, #32]
 800c682:	687a      	ldr	r2, [r7, #4]
 800c684:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 800c686:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 800c688:	f00c fa83 	bl	8018b92 <FillSigner>
 800c68c:	62f8      	str	r0, [r7, #44]	@ 0x2c

    #ifndef NO_SKID
        row = HashSigner(signer->subjectKeyIdHash);
 800c68e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800c690:	3340      	adds	r3, #64	@ 0x40
 800c692:	4618      	mov	r0, r3
 800c694:	f7ff fdc2 	bl	800c21c <HashSigner>
 800c698:	61b8      	str	r0, [r7, #24]
                    WOLFSSL_MSG("Renesas_RootCertVerify() succeed or skipped");
            }
        }
    #endif /* TSIP or SCE */

        if (ret == 0 && wc_LockMutex(&cm->caLock) == 0) {
 800c69a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800c69c:	2b00      	cmp	r3, #0
 800c69e:	d126      	bne.n	800c6ee <AddCA+0x20a>
 800c6a0:	68fb      	ldr	r3, [r7, #12]
 800c6a2:	335c      	adds	r3, #92	@ 0x5c
 800c6a4:	4618      	mov	r0, r3
 800c6a6:	f01a fe7f 	bl	80273a8 <wc_LockMutex>
 800c6aa:	4603      	mov	r3, r0
 800c6ac:	2b00      	cmp	r3, #0
 800c6ae:	d11e      	bne.n	800c6ee <AddCA+0x20a>
            signer->next = cm->caTable[row];
 800c6b0:	68fb      	ldr	r3, [r7, #12]
 800c6b2:	69ba      	ldr	r2, [r7, #24]
 800c6b4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800c6b8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800c6ba:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
            cm->caTable[row] = signer;   /* takes ownership */
 800c6be:	68fb      	ldr	r3, [r7, #12]
 800c6c0:	69ba      	ldr	r2, [r7, #24]
 800c6c2:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 800c6c4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
            wc_UnLockMutex(&cm->caLock);
 800c6c8:	68fb      	ldr	r3, [r7, #12]
 800c6ca:	335c      	adds	r3, #92	@ 0x5c
 800c6cc:	4618      	mov	r0, r3
 800c6ce:	f01a fe76 	bl	80273be <wc_UnLockMutex>
            if (cm->caCacheCallback)
 800c6d2:	68fb      	ldr	r3, [r7, #12]
 800c6d4:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800c6d6:	2b00      	cmp	r3, #0
 800c6d8:	d00c      	beq.n	800c6f4 <AddCA+0x210>
                cm->caCacheCallback(der->buffer, (int)der->length, type);
 800c6da:	68fb      	ldr	r3, [r7, #12]
 800c6dc:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800c6de:	6a3a      	ldr	r2, [r7, #32]
 800c6e0:	6810      	ldr	r0, [r2, #0]
 800c6e2:	6a3a      	ldr	r2, [r7, #32]
 800c6e4:	6892      	ldr	r2, [r2, #8]
 800c6e6:	4611      	mov	r1, r2
 800c6e8:	687a      	ldr	r2, [r7, #4]
 800c6ea:	4798      	blx	r3
            if (cm->caCacheCallback)
 800c6ec:	e002      	b.n	800c6f4 <AddCA+0x210>
        }
        else {
            WOLFSSL_MSG("\tCA Mutex Lock failed");
            ret = BAD_MUTEX_E;
 800c6ee:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 800c6f2:	62fb      	str	r3, [r7, #44]	@ 0x2c
        }
    }

    WOLFSSL_MSG("\tFreeing Parsed CA");
    FreeDecodedCert(cert);
 800c6f4:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800c6f6:	f008 fdcd 	bl	8015294 <FreeDecodedCert>
    if (ret != 0 && signer != NULL)
 800c6fa:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800c6fc:	2b00      	cmp	r3, #0
 800c6fe:	d008      	beq.n	800c712 <AddCA+0x22e>
 800c700:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800c702:	2b00      	cmp	r3, #0
 800c704:	d005      	beq.n	800c712 <AddCA+0x22e>
        FreeSigner(signer, cm->heap);
 800c706:	68fb      	ldr	r3, [r7, #12]
 800c708:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800c70a:	4619      	mov	r1, r3
 800c70c:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 800c70e:	f00c faf8 	bl	8018d02 <FreeSigner>
#ifdef WOLFSSL_SMALL_STACK
    XFREE(cert, NULL, DYNAMIC_TYPE_DCERT);
 800c712:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c714:	617b      	str	r3, [r7, #20]
 800c716:	697b      	ldr	r3, [r7, #20]
 800c718:	2b00      	cmp	r3, #0
 800c71a:	d002      	beq.n	800c722 <AddCA+0x23e>
 800c71c:	6978      	ldr	r0, [r7, #20]
 800c71e:	f012 f9cf 	bl	801eac0 <wolfSSL_Free>
#endif
    WOLFSSL_MSG("\tFreeing der CA");
    FreeDer(pDer);
 800c722:	68b8      	ldr	r0, [r7, #8]
 800c724:	f00c fc2a 	bl	8018f7c <FreeDer>
    WOLFSSL_MSG("\t\tOK Freeing der CA");

    WOLFSSL_LEAVE("AddCA", ret);

    return ret == 0 ? WOLFSSL_SUCCESS : ret;
 800c728:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800c72a:	2b00      	cmp	r3, #0
 800c72c:	d001      	beq.n	800c732 <AddCA+0x24e>
 800c72e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800c730:	e000      	b.n	800c734 <AddCA+0x250>
 800c732:	2301      	movs	r3, #1
}
 800c734:	4618      	mov	r0, r3
 800c736:	3730      	adds	r7, #48	@ 0x30
 800c738:	46bd      	mov	sp, r7
 800c73a:	bd80      	pop	{r7, pc}
 800c73c:	fffffe66 	.word	0xfffffe66

0800c740 <wolfSSL_Init>:
}
#endif

WOLFSSL_ABI
int wolfSSL_Init(void)
{
 800c740:	b580      	push	{r7, lr}
 800c742:	b082      	sub	sp, #8
 800c744:	af00      	add	r7, sp, #0
    int ret = WOLFSSL_SUCCESS;
 800c746:	2301      	movs	r3, #1
 800c748:	607b      	str	r3, [r7, #4]
#endif

    WOLFSSL_ENTER("wolfSSL_Init");

#ifndef WOLFSSL_MUTEX_INITIALIZER
    if (inits_count_mutex_valid == 0) {
 800c74a:	4b34      	ldr	r3, [pc, #208]	@ (800c81c <wolfSSL_Init+0xdc>)
 800c74c:	681b      	ldr	r3, [r3, #0]
 800c74e:	2b00      	cmp	r3, #0
 800c750:	d10b      	bne.n	800c76a <wolfSSL_Init+0x2a>
            (void)wolfSSL_Atomic_Int_FetchSub(
                &inits_count_mutex_atomic_initing_flag, 1);
            return DEADLOCK_AVERTED_E;
        }
    #endif /* WOLFSSL_CLEANUP_THREADSAFE_BY_ATOMIC_OPS */
        if (wc_InitMutex(&inits_count_mutex) != 0) {
 800c752:	4833      	ldr	r0, [pc, #204]	@ (800c820 <wolfSSL_Init+0xe0>)
 800c754:	f01a fe12 	bl	802737c <wc_InitMutex>
 800c758:	4603      	mov	r3, r0
 800c75a:	2b00      	cmp	r3, #0
 800c75c:	d002      	beq.n	800c764 <wolfSSL_Init+0x24>
            WOLFSSL_MSG("Bad Init Mutex count");
    #if WOLFSSL_CLEANUP_THREADSAFE_BY_ATOMIC_OPS
            (void)wolfSSL_Atomic_Int_FetchSub(
                &inits_count_mutex_atomic_initing_flag, 1);
    #endif
            return BAD_MUTEX_E;
 800c75e:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 800c762:	e057      	b.n	800c814 <wolfSSL_Init+0xd4>
        }
        else {
            inits_count_mutex_valid = 1;
 800c764:	4b2d      	ldr	r3, [pc, #180]	@ (800c81c <wolfSSL_Init+0xdc>)
 800c766:	2201      	movs	r2, #1
 800c768:	601a      	str	r2, [r3, #0]
        }
    }
#endif /* !WOLFSSL_MUTEX_INITIALIZER */

    if (wc_LockMutex(&inits_count_mutex) != 0) {
 800c76a:	482d      	ldr	r0, [pc, #180]	@ (800c820 <wolfSSL_Init+0xe0>)
 800c76c:	f01a fe1c 	bl	80273a8 <wc_LockMutex>
 800c770:	4603      	mov	r3, r0
 800c772:	2b00      	cmp	r3, #0
 800c774:	d002      	beq.n	800c77c <wolfSSL_Init+0x3c>
        WOLFSSL_MSG("Bad Lock Mutex count");
        return BAD_MUTEX_E;
 800c776:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 800c77a:	e04b      	b.n	800c814 <wolfSSL_Init+0xd4>
        if (ret == 0)
            ret = WOLFSSL_SUCCESS;
    }
#endif

    if ((ret == WOLFSSL_SUCCESS) && (initRefCount == 0)) {
 800c77c:	687b      	ldr	r3, [r7, #4]
 800c77e:	2b01      	cmp	r3, #1
 800c780:	d133      	bne.n	800c7ea <wolfSSL_Init+0xaa>
 800c782:	4b28      	ldr	r3, [pc, #160]	@ (800c824 <wolfSSL_Init+0xe4>)
 800c784:	681b      	ldr	r3, [r3, #0]
 800c786:	2b00      	cmp	r3, #0
 800c788:	d12f      	bne.n	800c7ea <wolfSSL_Init+0xaa>
        /* Initialize crypto for use with TLS connection */

        if (wolfCrypt_Init() != 0) {
 800c78a:	f01a fd6b 	bl	8027264 <wolfCrypt_Init>
 800c78e:	4603      	mov	r3, r0
 800c790:	2b00      	cmp	r3, #0
 800c792:	d002      	beq.n	800c79a <wolfSSL_Init+0x5a>
            WOLFSSL_MSG("Bad wolfCrypt Init");
            ret = WC_INIT_E;
 800c794:	f06f 03e3 	mvn.w	r3, #227	@ 0xe3
 800c798:	607b      	str	r3, [r7, #4]
        }

#if defined(HAVE_GLOBAL_RNG) && !defined(WOLFSSL_MUTEX_INITIALIZER)
        if (ret == WOLFSSL_SUCCESS) {
 800c79a:	687b      	ldr	r3, [r7, #4]
 800c79c:	2b01      	cmp	r3, #1
 800c79e:	d10c      	bne.n	800c7ba <wolfSSL_Init+0x7a>
            if (wc_InitMutex(&globalRNGMutex) != 0) {
 800c7a0:	4821      	ldr	r0, [pc, #132]	@ (800c828 <wolfSSL_Init+0xe8>)
 800c7a2:	f01a fdeb 	bl	802737c <wc_InitMutex>
 800c7a6:	4603      	mov	r3, r0
 800c7a8:	2b00      	cmp	r3, #0
 800c7aa:	d003      	beq.n	800c7b4 <wolfSSL_Init+0x74>
                WOLFSSL_MSG("Bad Init Mutex rng");
                ret = BAD_MUTEX_E;
 800c7ac:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 800c7b0:	607b      	str	r3, [r7, #4]
 800c7b2:	e002      	b.n	800c7ba <wolfSSL_Init+0x7a>
            }
            else {
                globalRNGMutex_valid = 1;
 800c7b4:	4b1d      	ldr	r3, [pc, #116]	@ (800c82c <wolfSSL_Init+0xec>)
 800c7b6:	2201      	movs	r2, #1
 800c7b8:	601a      	str	r2, [r3, #0]
        wc_SetSeed_Cb(wc_GenerateSeed);
    #endif

#ifdef OPENSSL_EXTRA
    #ifndef WOLFSSL_NO_OPENSSL_RAND_CB
        if ((ret == WOLFSSL_SUCCESS) && (wolfSSL_RAND_InitMutex() != 0)) {
 800c7ba:	687b      	ldr	r3, [r7, #4]
 800c7bc:	2b01      	cmp	r3, #1
 800c7be:	d107      	bne.n	800c7d0 <wolfSSL_Init+0x90>
 800c7c0:	f002 faf0 	bl	800eda4 <wolfSSL_RAND_InitMutex>
 800c7c4:	4603      	mov	r3, r0
 800c7c6:	2b00      	cmp	r3, #0
 800c7c8:	d002      	beq.n	800c7d0 <wolfSSL_Init+0x90>
            ret = BAD_MUTEX_E;
 800c7ca:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 800c7ce:	607b      	str	r3, [r7, #4]
        }
    #endif
        if ((ret == WOLFSSL_SUCCESS) &&
 800c7d0:	687b      	ldr	r3, [r7, #4]
 800c7d2:	2b01      	cmp	r3, #1
 800c7d4:	d109      	bne.n	800c7ea <wolfSSL_Init+0xaa>
            (wolfSSL_RAND_seed(NULL, 0) != WOLFSSL_SUCCESS)) {
 800c7d6:	2100      	movs	r1, #0
 800c7d8:	2000      	movs	r0, #0
 800c7da:	f002 fb29 	bl	800ee30 <wolfSSL_RAND_seed>
 800c7de:	4603      	mov	r3, r0
        if ((ret == WOLFSSL_SUCCESS) &&
 800c7e0:	2b01      	cmp	r3, #1
 800c7e2:	d002      	beq.n	800c7ea <wolfSSL_Init+0xaa>
            WOLFSSL_MSG("wolfSSL_RAND_seed failed");
            ret = WC_INIT_E;
 800c7e4:	f06f 03e3 	mvn.w	r3, #227	@ 0xe3
 800c7e8:	607b      	str	r3, [r7, #4]
#if defined(WOLFSSL_SYS_CRYPTO_POLICY)
    /* System wide crypto policy disabled by default. */
    XMEMSET(&crypto_policy, 0, sizeof(crypto_policy));
#endif /* WOLFSSL_SYS_CRYPTO_POLICY */

    if (ret == WOLFSSL_SUCCESS) {
 800c7ea:	687b      	ldr	r3, [r7, #4]
 800c7ec:	2b01      	cmp	r3, #1
 800c7ee:	d105      	bne.n	800c7fc <wolfSSL_Init+0xbc>
        initRefCount++;
 800c7f0:	4b0c      	ldr	r3, [pc, #48]	@ (800c824 <wolfSSL_Init+0xe4>)
 800c7f2:	681b      	ldr	r3, [r3, #0]
 800c7f4:	3301      	adds	r3, #1
 800c7f6:	4a0b      	ldr	r2, [pc, #44]	@ (800c824 <wolfSSL_Init+0xe4>)
 800c7f8:	6013      	str	r3, [r2, #0]
 800c7fa:	e002      	b.n	800c802 <wolfSSL_Init+0xc2>
    }
    else {
        initRefCount = 1; /* Force cleanup */
 800c7fc:	4b09      	ldr	r3, [pc, #36]	@ (800c824 <wolfSSL_Init+0xe4>)
 800c7fe:	2201      	movs	r2, #1
 800c800:	601a      	str	r2, [r3, #0]
    }

    wc_UnLockMutex(&inits_count_mutex);
 800c802:	4807      	ldr	r0, [pc, #28]	@ (800c820 <wolfSSL_Init+0xe0>)
 800c804:	f01a fddb 	bl	80273be <wc_UnLockMutex>

    if (ret != WOLFSSL_SUCCESS) {
 800c808:	687b      	ldr	r3, [r7, #4]
 800c80a:	2b01      	cmp	r3, #1
 800c80c:	d001      	beq.n	800c812 <wolfSSL_Init+0xd2>
        (void)wolfSSL_Cleanup(); /* Ignore any error from cleanup */
 800c80e:	f001 f8a9 	bl	800d964 <wolfSSL_Cleanup>
    }

    return ret;
 800c812:	687b      	ldr	r3, [r7, #4]
}
 800c814:	4618      	mov	r0, r3
 800c816:	3708      	adds	r7, #8
 800c818:	46bd      	mov	sp, r7
 800c81a:	bd80      	pop	{r7, pc}
 800c81c:	200028e0 	.word	0x200028e0
 800c820:	200028dc 	.word	0x200028dc
 800c824:	200028d8 	.word	0x200028d8
 800c828:	200028bc 	.word	0x200028bc
 800c82c:	200028c0 	.word	0x200028c0

0800c830 <DataToDerBuffer>:
 * @return  ASN_PARSE_E when format is ASN.1 and invalid DER encoding.
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
static int DataToDerBuffer(const unsigned char* buff, word32 len, int format,
    int type, EncryptedInfo* info, void* heap, DerBuffer** der, int* algId)
{
 800c830:	b580      	push	{r7, lr}
 800c832:	b08a      	sub	sp, #40	@ 0x28
 800c834:	af04      	add	r7, sp, #16
 800c836:	60f8      	str	r0, [r7, #12]
 800c838:	60b9      	str	r1, [r7, #8]
 800c83a:	607a      	str	r2, [r7, #4]
 800c83c:	603b      	str	r3, [r7, #0]
    int ret;

    info->consumed = 0;
 800c83e:	6a3b      	ldr	r3, [r7, #32]
 800c840:	2200      	movs	r2, #0
 800c842:	601a      	str	r2, [r3, #0]

    /* Data in buffer has PEM format - extract DER data. */
    if (format == WOLFSSL_FILETYPE_PEM) {
 800c844:	687b      	ldr	r3, [r7, #4]
 800c846:	2b01      	cmp	r3, #1
 800c848:	d113      	bne.n	800c872 <DataToDerBuffer+0x42>
    #ifdef WOLFSSL_PEM_TO_DER
        ret = PemToDer(buff, len, type, der, heap, info, algId);
 800c84a:	68b9      	ldr	r1, [r7, #8]
 800c84c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800c84e:	9302      	str	r3, [sp, #8]
 800c850:	6a3b      	ldr	r3, [r7, #32]
 800c852:	9301      	str	r3, [sp, #4]
 800c854:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c856:	9300      	str	r3, [sp, #0]
 800c858:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800c85a:	683a      	ldr	r2, [r7, #0]
 800c85c:	68f8      	ldr	r0, [r7, #12]
 800c85e:	f00c fead 	bl	80195bc <PemToDer>
 800c862:	6178      	str	r0, [r7, #20]
        if (ret != 0) {
 800c864:	697b      	ldr	r3, [r7, #20]
 800c866:	2b00      	cmp	r3, #0
 800c868:	d02b      	beq.n	800c8c2 <DataToDerBuffer+0x92>
            FreeDer(der);
 800c86a:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 800c86c:	f00c fb86 	bl	8018f7c <FreeDer>
 800c870:	e027      	b.n	800c8c2 <DataToDerBuffer+0x92>
    #endif
    }
    /* Data in buffer is ASN.1 format - get first SEQ or OCT into der. */
    else {
        /* Get length of SEQ including header. */
        if ((info->consumed = wolfssl_der_length(buff, (int)len)) > 0) {
 800c872:	68bb      	ldr	r3, [r7, #8]
 800c874:	4619      	mov	r1, r3
 800c876:	68f8      	ldr	r0, [r7, #12]
 800c878:	f7ff fa52 	bl	800bd20 <wolfssl_der_length>
 800c87c:	4602      	mov	r2, r0
 800c87e:	6a3b      	ldr	r3, [r7, #32]
 800c880:	601a      	str	r2, [r3, #0]
 800c882:	6a3b      	ldr	r3, [r7, #32]
 800c884:	681b      	ldr	r3, [r3, #0]
 800c886:	2b00      	cmp	r3, #0
 800c888:	dd02      	ble.n	800c890 <DataToDerBuffer+0x60>
            ret = 0;
 800c88a:	2300      	movs	r3, #0
 800c88c:	617b      	str	r3, [r7, #20]
 800c88e:	e002      	b.n	800c896 <DataToDerBuffer+0x66>
        }
        else {
            ret = ASN_PARSE_E;
 800c890:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 800c894:	617b      	str	r3, [r7, #20]
        }

        if (info->consumed > (int)len) {
 800c896:	6a3b      	ldr	r3, [r7, #32]
 800c898:	681a      	ldr	r2, [r3, #0]
 800c89a:	68bb      	ldr	r3, [r7, #8]
 800c89c:	429a      	cmp	r2, r3
 800c89e:	dd02      	ble.n	800c8a6 <DataToDerBuffer+0x76>
            ret = ASN_PARSE_E;
 800c8a0:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 800c8a4:	617b      	str	r3, [r7, #20]
        }
        if (ret == 0) {
 800c8a6:	697b      	ldr	r3, [r7, #20]
 800c8a8:	2b00      	cmp	r3, #0
 800c8aa:	d10a      	bne.n	800c8c2 <DataToDerBuffer+0x92>
            ret = AllocCopyDer(der, buff, (word32)info->consumed, type, heap);
 800c8ac:	6a3b      	ldr	r3, [r7, #32]
 800c8ae:	681b      	ldr	r3, [r3, #0]
 800c8b0:	461a      	mov	r2, r3
 800c8b2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c8b4:	9300      	str	r3, [sp, #0]
 800c8b6:	683b      	ldr	r3, [r7, #0]
 800c8b8:	68f9      	ldr	r1, [r7, #12]
 800c8ba:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 800c8bc:	f00c fb40 	bl	8018f40 <AllocCopyDer>
 800c8c0:	6178      	str	r0, [r7, #20]
        }
    }

    return ret;
 800c8c2:	697b      	ldr	r3, [r7, #20]
}
 800c8c4:	4618      	mov	r0, r3
 800c8c6:	3718      	adds	r7, #24
 800c8c8:	46bd      	mov	sp, r7
 800c8ca:	bd80      	pop	{r7, pc}

0800c8cc <ProcessUserCert>:
 * @return  0 on success.
 * @return  BUFFER_E if chain buffer not big enough to hold certificate.
 */
static int ProcessUserCert(WOLFSSL_CERT_MANAGER* cm, DerBuffer** pDer,
    int type, int verify, byte* chainBuffer, word32* pIdx, word32 bufferSz)
{
 800c8cc:	b580      	push	{r7, lr}
 800c8ce:	b088      	sub	sp, #32
 800c8d0:	af00      	add	r7, sp, #0
 800c8d2:	60f8      	str	r0, [r7, #12]
 800c8d4:	60b9      	str	r1, [r7, #8]
 800c8d6:	607a      	str	r2, [r7, #4]
 800c8d8:	603b      	str	r3, [r7, #0]
    int ret = 0;
 800c8da:	2300      	movs	r3, #0
 800c8dc:	61fb      	str	r3, [r7, #28]
    word32 idx = *pIdx;
 800c8de:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800c8e0:	681b      	ldr	r3, [r3, #0]
 800c8e2:	61bb      	str	r3, [r7, #24]
    DerBuffer* der = *pDer;
 800c8e4:	68bb      	ldr	r3, [r7, #8]
 800c8e6:	681b      	ldr	r3, [r3, #0]
 800c8e8:	617b      	str	r3, [r7, #20]

    /* Check there is space for certificate in chainBuffer. */
    if ((ret == 0) && ((idx + der->length + CERT_HEADER_SZ) > bufferSz)) {
 800c8ea:	69fb      	ldr	r3, [r7, #28]
 800c8ec:	2b00      	cmp	r3, #0
 800c8ee:	d10a      	bne.n	800c906 <ProcessUserCert+0x3a>
 800c8f0:	697b      	ldr	r3, [r7, #20]
 800c8f2:	689a      	ldr	r2, [r3, #8]
 800c8f4:	69bb      	ldr	r3, [r7, #24]
 800c8f6:	4413      	add	r3, r2
 800c8f8:	3303      	adds	r3, #3
 800c8fa:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 800c8fc:	429a      	cmp	r2, r3
 800c8fe:	d202      	bcs.n	800c906 <ProcessUserCert+0x3a>
        WOLFSSL_MSG("   Cert Chain bigger than buffer. "
                    "Consider increasing MAX_CHAIN_DEPTH");
        ret = BUFFER_E;
 800c900:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 800c904:	61fb      	str	r3, [r7, #28]
    }
    if (ret == 0) {
 800c906:	69fb      	ldr	r3, [r7, #28]
 800c908:	2b00      	cmp	r3, #0
 800c90a:	d128      	bne.n	800c95e <ProcessUserCert+0x92>
        /* 3-byte length. */
        c32to24(der->length, &chainBuffer[idx]);
 800c90c:	697b      	ldr	r3, [r7, #20]
 800c90e:	6898      	ldr	r0, [r3, #8]
 800c910:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800c912:	69bb      	ldr	r3, [r7, #24]
 800c914:	4413      	add	r3, r2
 800c916:	4619      	mov	r1, r3
 800c918:	f7fe fc32 	bl	800b180 <c32to24>
        idx += CERT_HEADER_SZ;
 800c91c:	69bb      	ldr	r3, [r7, #24]
 800c91e:	3303      	adds	r3, #3
 800c920:	61bb      	str	r3, [r7, #24]
        /* Add complete DER encoded certificate. */
        XMEMCPY(&chainBuffer[idx], der->buffer, der->length);
 800c922:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800c924:	69bb      	ldr	r3, [r7, #24]
 800c926:	18d0      	adds	r0, r2, r3
 800c928:	697b      	ldr	r3, [r7, #20]
 800c92a:	6819      	ldr	r1, [r3, #0]
 800c92c:	697b      	ldr	r3, [r7, #20]
 800c92e:	689b      	ldr	r3, [r3, #8]
 800c930:	461a      	mov	r2, r3
 800c932:	f01b fe33 	bl	802859c <memcpy>
        idx += der->length;
 800c936:	697b      	ldr	r3, [r7, #20]
 800c938:	689b      	ldr	r3, [r3, #8]
 800c93a:	69ba      	ldr	r2, [r7, #24]
 800c93c:	4413      	add	r3, r2
 800c93e:	61bb      	str	r3, [r7, #24]

        if (type == CA_TYPE) {
 800c940:	687b      	ldr	r3, [r7, #4]
 800c942:	2b06      	cmp	r3, #6
 800c944:	d10b      	bne.n	800c95e <ProcessUserCert+0x92>
            /* Add CA to certificate manager */
            ret = AddCA(cm, pDer, WOLFSSL_USER_CA, verify);
 800c946:	683b      	ldr	r3, [r7, #0]
 800c948:	2201      	movs	r2, #1
 800c94a:	68b9      	ldr	r1, [r7, #8]
 800c94c:	68f8      	ldr	r0, [r7, #12]
 800c94e:	f7ff fdc9 	bl	800c4e4 <AddCA>
 800c952:	61f8      	str	r0, [r7, #28]
            if (ret == 1) {
 800c954:	69fb      	ldr	r3, [r7, #28]
 800c956:	2b01      	cmp	r3, #1
 800c958:	d101      	bne.n	800c95e <ProcessUserCert+0x92>
                ret = 0;
 800c95a:	2300      	movs	r3, #0
 800c95c:	61fb      	str	r3, [r7, #28]
            }
        }
    }

    /* Update the index into chainBuffer. */
    *pIdx = idx;
 800c95e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800c960:	69ba      	ldr	r2, [r7, #24]
 800c962:	601a      	str	r2, [r3, #0]
    return ret;
 800c964:	69fb      	ldr	r3, [r7, #28]
}
 800c966:	4618      	mov	r0, r3
 800c968:	3720      	adds	r7, #32
 800c96a:	46bd      	mov	sp, r7
 800c96c:	bd80      	pop	{r7, pc}

0800c96e <ProcessUserChainRetain>:
 * @return  0 on success.
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
static int ProcessUserChainRetain(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    const byte* chainBuffer, word32 len, int cnt, int type, void* heap)
{
 800c96e:	b580      	push	{r7, lr}
 800c970:	b088      	sub	sp, #32
 800c972:	af02      	add	r7, sp, #8
 800c974:	60f8      	str	r0, [r7, #12]
 800c976:	60b9      	str	r1, [r7, #8]
 800c978:	607a      	str	r2, [r7, #4]
 800c97a:	603b      	str	r3, [r7, #0]
    int ret = 0;
 800c97c:	2300      	movs	r3, #0
 800c97e:	617b      	str	r3, [r7, #20]

    (void)cnt;

    /* Store in SSL object if available. */
    if (ssl != NULL) {
 800c980:	68bb      	ldr	r3, [r7, #8]
 800c982:	2b00      	cmp	r3, #0
 800c984:	d024      	beq.n	800c9d0 <ProcessUserChainRetain+0x62>
        /* Dispose of old chain if not reference to context's. */
        if (ssl->buffers.weOwnCertChain) {
 800c986:	68bb      	ldr	r3, [r7, #8]
 800c988:	f893 3145 	ldrb.w	r3, [r3, #325]	@ 0x145
 800c98c:	2b00      	cmp	r3, #0
 800c98e:	d005      	beq.n	800c99c <ProcessUserChainRetain+0x2e>
            FreeDer(&ssl->buffers.certChain);
 800c990:	68bb      	ldr	r3, [r7, #8]
 800c992:	f503 73c0 	add.w	r3, r3, #384	@ 0x180
 800c996:	4618      	mov	r0, r3
 800c998:	f00c faf0 	bl	8018f7c <FreeDer>
        }
        /* Allocate and copy the buffer into SSL object. */
        ret = AllocCopyDer(&ssl->buffers.certChain, chainBuffer, len, type,
 800c99c:	68bb      	ldr	r3, [r7, #8]
 800c99e:	f503 70c0 	add.w	r0, r3, #384	@ 0x180
 800c9a2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800c9a4:	9300      	str	r3, [sp, #0]
 800c9a6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c9a8:	683a      	ldr	r2, [r7, #0]
 800c9aa:	6879      	ldr	r1, [r7, #4]
 800c9ac:	f00c fac8 	bl	8018f40 <AllocCopyDer>
 800c9b0:	6178      	str	r0, [r7, #20]
            heap);
        ssl->buffers.weOwnCertChain = (ret == 0);
 800c9b2:	697b      	ldr	r3, [r7, #20]
 800c9b4:	2b00      	cmp	r3, #0
 800c9b6:	bf0c      	ite	eq
 800c9b8:	2301      	moveq	r3, #1
 800c9ba:	2300      	movne	r3, #0
 800c9bc:	b2db      	uxtb	r3, r3
 800c9be:	461a      	mov	r2, r3
 800c9c0:	68bb      	ldr	r3, [r7, #8]
 800c9c2:	f883 2145 	strb.w	r2, [r3, #325]	@ 0x145
    #ifdef WOLFSSL_TLS13
        /* Update count of certificates in chain. */
        ssl->buffers.certChainCnt = cnt;
 800c9c6:	68bb      	ldr	r3, [r7, #8]
 800c9c8:	6a3a      	ldr	r2, [r7, #32]
 800c9ca:	f8c3 2184 	str.w	r2, [r3, #388]	@ 0x184
 800c9ce:	e015      	b.n	800c9fc <ProcessUserChainRetain+0x8e>
    #endif
    }
    /* Store in SSL context object if available. */
    else if (ctx != NULL) {
 800c9d0:	68fb      	ldr	r3, [r7, #12]
 800c9d2:	2b00      	cmp	r3, #0
 800c9d4:	d012      	beq.n	800c9fc <ProcessUserChainRetain+0x8e>
        /* Dispose of old chain and allocate and copy in new chain. */
        FreeDer(&ctx->certChain);
 800c9d6:	68fb      	ldr	r3, [r7, #12]
 800c9d8:	3324      	adds	r3, #36	@ 0x24
 800c9da:	4618      	mov	r0, r3
 800c9dc:	f00c face 	bl	8018f7c <FreeDer>
        /* Allocate and copy the buffer into SSL context object. */
        ret = AllocCopyDer(&ctx->certChain, chainBuffer, len, type, heap);
 800c9e0:	68fb      	ldr	r3, [r7, #12]
 800c9e2:	f103 0024 	add.w	r0, r3, #36	@ 0x24
 800c9e6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800c9e8:	9300      	str	r3, [sp, #0]
 800c9ea:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c9ec:	683a      	ldr	r2, [r7, #0]
 800c9ee:	6879      	ldr	r1, [r7, #4]
 800c9f0:	f00c faa6 	bl	8018f40 <AllocCopyDer>
 800c9f4:	6178      	str	r0, [r7, #20]
    #ifdef WOLFSSL_TLS13
        /* Update count of certificates in chain. */
        ctx->certChainCnt = cnt;
 800c9f6:	68fb      	ldr	r3, [r7, #12]
 800c9f8:	6a3a      	ldr	r2, [r7, #32]
 800c9fa:	63da      	str	r2, [r3, #60]	@ 0x3c
    #endif
    }

    return ret;
 800c9fc:	697b      	ldr	r3, [r7, #20]
}
 800c9fe:	4618      	mov	r0, r3
 800ca00:	3718      	adds	r7, #24
 800ca02:	46bd      	mov	sp, r7
 800ca04:	bd80      	pop	{r7, pc}

0800ca06 <ProcessUserChain>:
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
static int ProcessUserChain(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    const unsigned char* buff, long sz, int format, int type, long* used,
    EncryptedInfo* info, int verify)
{
 800ca06:	b580      	push	{r7, lr}
 800ca08:	b092      	sub	sp, #72	@ 0x48
 800ca0a:	af04      	add	r7, sp, #16
 800ca0c:	60f8      	str	r0, [r7, #12]
 800ca0e:	60b9      	str	r1, [r7, #8]
 800ca10:	607a      	str	r2, [r7, #4]
 800ca12:	603b      	str	r3, [r7, #0]
    int ret = 0;
 800ca14:	2300      	movs	r3, #0
 800ca16:	637b      	str	r3, [r7, #52]	@ 0x34
    void* heap = WOLFSSL_HEAP(ctx, ssl);
 800ca18:	68fb      	ldr	r3, [r7, #12]
 800ca1a:	2b00      	cmp	r3, #0
 800ca1c:	d002      	beq.n	800ca24 <ProcessUserChain+0x1e>
 800ca1e:	68fb      	ldr	r3, [r7, #12]
 800ca20:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800ca22:	e007      	b.n	800ca34 <ProcessUserChain+0x2e>
 800ca24:	68bb      	ldr	r3, [r7, #8]
 800ca26:	2b00      	cmp	r3, #0
 800ca28:	d003      	beq.n	800ca32 <ProcessUserChain+0x2c>
 800ca2a:	68bb      	ldr	r3, [r7, #8]
 800ca2c:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800ca30:	e000      	b.n	800ca34 <ProcessUserChain+0x2e>
 800ca32:	2300      	movs	r3, #0
 800ca34:	627b      	str	r3, [r7, #36]	@ 0x24

    WOLFSSL_ENTER("ProcessUserChain");

    /* Check we haven't consumed all the data. */
    if (info->consumed >= sz) {
 800ca36:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800ca38:	681b      	ldr	r3, [r3, #0]
 800ca3a:	683a      	ldr	r2, [r7, #0]
 800ca3c:	429a      	cmp	r2, r3
 800ca3e:	f340 8092 	ble.w	800cb66 <ProcessUserChain+0x160>
    else {
    #ifndef WOLFSSL_SMALL_STACK
        byte stackBuffer[FILE_BUFFER_SIZE];
    #endif
        StaticBuffer chain;
        long   consumed = info->consumed;
 800ca42:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800ca44:	681b      	ldr	r3, [r3, #0]
 800ca46:	633b      	str	r3, [r7, #48]	@ 0x30
        word32 idx = 0;
 800ca48:	2300      	movs	r3, #0
 800ca4a:	617b      	str	r3, [r7, #20]
        int    gotOne = 0;
 800ca4c:	2300      	movs	r3, #0
 800ca4e:	62fb      	str	r3, [r7, #44]	@ 0x2c
        int    cnt = 0;
 800ca50:	2300      	movs	r3, #0
 800ca52:	62bb      	str	r3, [r7, #40]	@ 0x28
        /* Calculate max possible size, including max headers */
        long   maxSz = (sz - consumed) + (CERT_HEADER_SZ * MAX_CHAIN_DEPTH);
 800ca54:	683a      	ldr	r2, [r7, #0]
 800ca56:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800ca58:	1ad3      	subs	r3, r2, r3
 800ca5a:	331b      	adds	r3, #27
 800ca5c:	623b      	str	r3, [r7, #32]

        /* Setup buffer to hold chain. */
    #ifdef WOLFSSL_SMALL_STACK
        static_buffer_init(&chain);
 800ca5e:	f107 0318 	add.w	r3, r7, #24
 800ca62:	4618      	mov	r0, r3
 800ca64:	f7fe fbc2 	bl	800b1ec <static_buffer_init>
    #else
        static_buffer_init(&chain, stackBuffer, FILE_BUFFER_SIZE);
    #endif
        /* Make buffer big enough to support maximum size. */
        ret = static_buffer_set_size(&chain, (word32)maxSz, heap,
 800ca68:	6a39      	ldr	r1, [r7, #32]
 800ca6a:	f107 0018 	add.w	r0, r7, #24
 800ca6e:	2304      	movs	r3, #4
 800ca70:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800ca72:	f7fe fbcb 	bl	800b20c <static_buffer_set_size>
 800ca76:	6378      	str	r0, [r7, #52]	@ 0x34
            DYNAMIC_TYPE_FILE);

        WOLFSSL_MSG("Processing Cert Chain");
        /* Keep parsing certificates will data available. */
        while ((ret == 0) && (consumed < sz)) {
 800ca78:	e04d      	b.n	800cb16 <ProcessUserChain+0x110>
            DerBuffer* part = NULL;
 800ca7a:	2300      	movs	r3, #0
 800ca7c:	613b      	str	r3, [r7, #16]

            /* Get a certificate as DER. */
            ret = DataToDerBuffer(buff + consumed, (word32)(sz - consumed),
 800ca7e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800ca80:	687a      	ldr	r2, [r7, #4]
 800ca82:	18d0      	adds	r0, r2, r3
 800ca84:	683a      	ldr	r2, [r7, #0]
 800ca86:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800ca88:	1ad3      	subs	r3, r2, r3
 800ca8a:	4619      	mov	r1, r3
 800ca8c:	2300      	movs	r3, #0
 800ca8e:	9303      	str	r3, [sp, #12]
 800ca90:	f107 0310 	add.w	r3, r7, #16
 800ca94:	9302      	str	r3, [sp, #8]
 800ca96:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800ca98:	9301      	str	r3, [sp, #4]
 800ca9a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800ca9c:	9300      	str	r3, [sp, #0]
 800ca9e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800caa0:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800caa2:	f7ff fec5 	bl	800c830 <DataToDerBuffer>
 800caa6:	6378      	str	r0, [r7, #52]	@ 0x34
                format, type, info, heap, &part, NULL);
            if (ret == 0) {
 800caa8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800caaa:	2b00      	cmp	r3, #0
 800caac:	d10f      	bne.n	800cace <ProcessUserChain+0xc8>
                /* Process the user certificate. */
                ret = ProcessUserCert(ctx->cm, &part, type, verify,
 800caae:	68fb      	ldr	r3, [r7, #12]
 800cab0:	6d18      	ldr	r0, [r3, #80]	@ 0x50
 800cab2:	69bb      	ldr	r3, [r7, #24]
 800cab4:	6a3a      	ldr	r2, [r7, #32]
 800cab6:	f107 0110 	add.w	r1, r7, #16
 800caba:	9202      	str	r2, [sp, #8]
 800cabc:	f107 0214 	add.w	r2, r7, #20
 800cac0:	9201      	str	r2, [sp, #4]
 800cac2:	9300      	str	r3, [sp, #0]
 800cac4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800cac6:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800cac8:	f7ff ff00 	bl	800c8cc <ProcessUserCert>
 800cacc:	6378      	str	r0, [r7, #52]	@ 0x34
                   chain.buffer, &idx, (word32)maxSz);
            }
            /* PEM may have trailing data that can be ignored. */
            if ((ret == WC_NO_ERR_TRACE(ASN_NO_PEM_HEADER)) && gotOne) {
 800cace:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800cad0:	f113 0fa2 	cmn.w	r3, #162	@ 0xa2
 800cad4:	d105      	bne.n	800cae2 <ProcessUserChain+0xdc>
 800cad6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800cad8:	2b00      	cmp	r3, #0
 800cada:	d002      	beq.n	800cae2 <ProcessUserChain+0xdc>
                WOLFSSL_MSG("We got one good cert, so stuff at end ok");
                ret = 0;
 800cadc:	2300      	movs	r3, #0
 800cade:	637b      	str	r3, [r7, #52]	@ 0x34
 800cae0:	e020      	b.n	800cb24 <ProcessUserChain+0x11e>
                break;
            }
            /* Certificate data handled. */
            FreeDer(&part);
 800cae2:	f107 0310 	add.w	r3, r7, #16
 800cae6:	4618      	mov	r0, r3
 800cae8:	f00c fa48 	bl	8018f7c <FreeDer>

            if (ret == 0) {
 800caec:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800caee:	2b00      	cmp	r3, #0
 800caf0:	d111      	bne.n	800cb16 <ProcessUserChain+0x110>
                /* Update consumed length. */
                consumed += info->consumed;
 800caf2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800caf4:	681b      	ldr	r3, [r3, #0]
 800caf6:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 800caf8:	4413      	add	r3, r2
 800cafa:	633b      	str	r3, [r7, #48]	@ 0x30
                WOLFSSL_MSG("   Consumed another Cert in Chain");
                /* Update whether we got a user certificate. */
                gotOne |= (type != CA_TYPE);
 800cafc:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800cafe:	2b06      	cmp	r3, #6
 800cb00:	bf14      	ite	ne
 800cb02:	2301      	movne	r3, #1
 800cb04:	2300      	moveq	r3, #0
 800cb06:	b2db      	uxtb	r3, r3
 800cb08:	461a      	mov	r2, r3
 800cb0a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800cb0c:	4313      	orrs	r3, r2
 800cb0e:	62fb      	str	r3, [r7, #44]	@ 0x2c
                /* Update count of certificates added to chain. */
                cnt++;
 800cb10:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800cb12:	3301      	adds	r3, #1
 800cb14:	62bb      	str	r3, [r7, #40]	@ 0x28
        while ((ret == 0) && (consumed < sz)) {
 800cb16:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800cb18:	2b00      	cmp	r3, #0
 800cb1a:	d103      	bne.n	800cb24 <ProcessUserChain+0x11e>
 800cb1c:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 800cb1e:	683b      	ldr	r3, [r7, #0]
 800cb20:	429a      	cmp	r2, r3
 800cb22:	dbaa      	blt.n	800ca7a <ProcessUserChain+0x74>
            }
        }
        if (used != NULL) {
 800cb24:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800cb26:	2b00      	cmp	r3, #0
 800cb28:	d002      	beq.n	800cb30 <ProcessUserChain+0x12a>
            /* Return the total consumed length. */
            *used = consumed;
 800cb2a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800cb2c:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 800cb2e:	601a      	str	r2, [r3, #0]
        }

        /* Check whether there is data in the chain buffer. */
        if ((ret == 0) && (idx > 0)) {
 800cb30:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800cb32:	2b00      	cmp	r3, #0
 800cb34:	d110      	bne.n	800cb58 <ProcessUserChain+0x152>
 800cb36:	697b      	ldr	r3, [r7, #20]
 800cb38:	2b00      	cmp	r3, #0
 800cb3a:	d00d      	beq.n	800cb58 <ProcessUserChain+0x152>
            /* Put the chain buffer against the SSL or SSL context object. */
            ret = ProcessUserChainRetain(ctx, ssl, chain.buffer, idx, cnt, type,
 800cb3c:	69ba      	ldr	r2, [r7, #24]
 800cb3e:	6979      	ldr	r1, [r7, #20]
 800cb40:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800cb42:	9302      	str	r3, [sp, #8]
 800cb44:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800cb46:	9301      	str	r3, [sp, #4]
 800cb48:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800cb4a:	9300      	str	r3, [sp, #0]
 800cb4c:	460b      	mov	r3, r1
 800cb4e:	68b9      	ldr	r1, [r7, #8]
 800cb50:	68f8      	ldr	r0, [r7, #12]
 800cb52:	f7ff ff0c 	bl	800c96e <ProcessUserChainRetain>
 800cb56:	6378      	str	r0, [r7, #52]	@ 0x34
                heap);
        }

        /* Dispose of chain buffer. */
        static_buffer_free(&chain, heap, DYNAMIC_TYPE_FILE);
 800cb58:	f107 0318 	add.w	r3, r7, #24
 800cb5c:	2204      	movs	r2, #4
 800cb5e:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 800cb60:	4618      	mov	r0, r3
 800cb62:	f7fe fb72 	bl	800b24a <static_buffer_free>
    }

    WOLFSSL_LEAVE("ProcessUserChain", ret);
    return ret;
 800cb66:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
 800cb68:	4618      	mov	r0, r3
 800cb6a:	3738      	adds	r7, #56	@ 0x38
 800cb6c:	46bd      	mov	sp, r7
 800cb6e:	bd80      	pop	{r7, pc}

0800cb70 <ProcessBufferTryDecodeRsa>:
 * @return  0 on success or not an RSA key and format unknown.
 * @return  RSA_KEY_SIZE_E when key size doesn't meet minimum required.
 */
static int ProcessBufferTryDecodeRsa(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    DerBuffer* der, int* keyFormat, int devId, byte* keyType, int* keySize)
{
 800cb70:	b580      	push	{r7, lr}
 800cb72:	b088      	sub	sp, #32
 800cb74:	af00      	add	r7, sp, #0
 800cb76:	60f8      	str	r0, [r7, #12]
 800cb78:	60b9      	str	r1, [r7, #8]
 800cb7a:	607a      	str	r2, [r7, #4]
 800cb7c:	603b      	str	r3, [r7, #0]
    int ret;
    word32 idx;
    int keySz = 0;
 800cb7e:	2300      	movs	r3, #0
 800cb80:	613b      	str	r3, [r7, #16]

    (void)devId;

    /* Validate we have an RSA private key and get key size. */
    idx = 0;
 800cb82:	2300      	movs	r3, #0
 800cb84:	617b      	str	r3, [r7, #20]
    ret = wc_RsaPrivateKeyValidate(der->buffer, &idx, &keySz, der->length);
 800cb86:	687b      	ldr	r3, [r7, #4]
 800cb88:	6818      	ldr	r0, [r3, #0]
 800cb8a:	687b      	ldr	r3, [r7, #4]
 800cb8c:	689b      	ldr	r3, [r3, #8]
 800cb8e:	f107 0210 	add.w	r2, r7, #16
 800cb92:	f107 0114 	add.w	r1, r7, #20
 800cb96:	f008 f84f 	bl	8014c38 <wc_RsaPrivateKeyValidate>
 800cb9a:	61f8      	str	r0, [r7, #28]
        if (ret == 0) {
            keySz = (int)nSz;
        }
    }
#endif
    if (ret == 0) {
 800cb9c:	69fb      	ldr	r3, [r7, #28]
 800cb9e:	2b00      	cmp	r3, #0
 800cba0:	d12e      	bne.n	800cc00 <ProcessBufferTryDecodeRsa+0x90>
        /* Get the minimum RSA key size from SSL or SSL context object. */
        int minRsaSz = ssl ? ssl->options.minRsaKeySz : ctx->minRsaKeySz;
 800cba2:	68bb      	ldr	r3, [r7, #8]
 800cba4:	2b00      	cmp	r3, #0
 800cba6:	d003      	beq.n	800cbb0 <ProcessBufferTryDecodeRsa+0x40>
 800cba8:	68bb      	ldr	r3, [r7, #8]
 800cbaa:	f9b3 32f4 	ldrsh.w	r3, [r3, #756]	@ 0x2f4
 800cbae:	e002      	b.n	800cbb6 <ProcessBufferTryDecodeRsa+0x46>
 800cbb0:	68fb      	ldr	r3, [r7, #12]
 800cbb2:	f9b3 3066 	ldrsh.w	r3, [r3, #102]	@ 0x66
 800cbb6:	61bb      	str	r3, [r7, #24]

        /* Format, type and size are known. */
        *keyFormat = RSAk;
 800cbb8:	683b      	ldr	r3, [r7, #0]
 800cbba:	f240 2285 	movw	r2, #645	@ 0x285
 800cbbe:	601a      	str	r2, [r3, #0]
        *keyType = rsa_sa_algo;
 800cbc0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800cbc2:	2201      	movs	r2, #1
 800cbc4:	701a      	strb	r2, [r3, #0]
        *keySize = keySz;
 800cbc6:	693a      	ldr	r2, [r7, #16]
 800cbc8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800cbca:	601a      	str	r2, [r3, #0]

        /* Check that the size of the RSA key is enough. */
        if (keySz < minRsaSz) {
 800cbcc:	693b      	ldr	r3, [r7, #16]
 800cbce:	69ba      	ldr	r2, [r7, #24]
 800cbd0:	429a      	cmp	r2, r3
 800cbd2:	dd02      	ble.n	800cbda <ProcessBufferTryDecodeRsa+0x6a>
            WOLFSSL_MSG("Private Key size too small");
            ret = RSA_KEY_SIZE_E;
 800cbd4:	f46f 73cc 	mvn.w	r3, #408	@ 0x198
 800cbd8:	61fb      	str	r3, [r7, #28]
        }
         /* No static ECC key possible. */
        if ((ssl != NULL) && (ssl->options.side == WOLFSSL_SERVER_END)) {
 800cbda:	68bb      	ldr	r3, [r7, #8]
 800cbdc:	2b00      	cmp	r3, #0
 800cbde:	d015      	beq.n	800cc0c <ProcessBufferTryDecodeRsa+0x9c>
 800cbe0:	68bb      	ldr	r3, [r7, #8]
 800cbe2:	f893 32d1 	ldrb.w	r3, [r3, #721]	@ 0x2d1
 800cbe6:	f003 0303 	and.w	r3, r3, #3
 800cbea:	b2db      	uxtb	r3, r3
 800cbec:	2b00      	cmp	r3, #0
 800cbee:	d10d      	bne.n	800cc0c <ProcessBufferTryDecodeRsa+0x9c>
             ssl->options.haveStaticECC = 0;
 800cbf0:	68ba      	ldr	r2, [r7, #8]
 800cbf2:	f892 32d3 	ldrb.w	r3, [r2, #723]	@ 0x2d3
 800cbf6:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 800cbfa:	f882 32d3 	strb.w	r3, [r2, #723]	@ 0x2d3
 800cbfe:	e005      	b.n	800cc0c <ProcessBufferTryDecodeRsa+0x9c>
        }
    }
    /* Not an RSA key but check whether we know what it is. */
    else if (*keyFormat == 0) {
 800cc00:	683b      	ldr	r3, [r7, #0]
 800cc02:	681b      	ldr	r3, [r3, #0]
 800cc04:	2b00      	cmp	r3, #0
 800cc06:	d101      	bne.n	800cc0c <ProcessBufferTryDecodeRsa+0x9c>
        WOLFSSL_MSG("Not an RSA key");
        /* Format unknown so keep trying. */
        ret = 0;
 800cc08:	2300      	movs	r3, #0
 800cc0a:	61fb      	str	r3, [r7, #28]
    }

    return ret;
 800cc0c:	69fb      	ldr	r3, [r7, #28]
}
 800cc0e:	4618      	mov	r0, r3
 800cc10:	3720      	adds	r7, #32
 800cc12:	46bd      	mov	sp, r7
 800cc14:	bd80      	pop	{r7, pc}
	...

0800cc18 <ProcessBufferTryDecodeEcc>:
 * @return  ECC_KEY_SIZE_E when ECC key size doesn't meet minimum required.
 */
static int ProcessBufferTryDecodeEcc(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    DerBuffer* der, int* keyFormat, void* heap, int devId, byte* keyType,
    int* keySize)
{
 800cc18:	b580      	push	{r7, lr}
 800cc1a:	b08a      	sub	sp, #40	@ 0x28
 800cc1c:	af00      	add	r7, sp, #0
 800cc1e:	60f8      	str	r0, [r7, #12]
 800cc20:	60b9      	str	r1, [r7, #8]
 800cc22:	607a      	str	r2, [r7, #4]
 800cc24:	603b      	str	r3, [r7, #0]
    int ret = 0;
 800cc26:	2300      	movs	r3, #0
 800cc28:	627b      	str	r3, [r7, #36]	@ 0x24
    ecc_key  key[1];
#endif

#ifdef WOLFSSL_SMALL_STACK
    /* Allocate an ECC key to parse into. */
    key = (ecc_key*)XMALLOC(sizeof(ecc_key), heap, DYNAMIC_TYPE_ECC);
 800cc2a:	f44f 70b8 	mov.w	r0, #368	@ 0x170
 800cc2e:	f011 ff2b 	bl	801ea88 <wolfSSL_Malloc>
 800cc32:	6238      	str	r0, [r7, #32]
    if (key == NULL)
 800cc34:	6a3b      	ldr	r3, [r7, #32]
 800cc36:	2b00      	cmp	r3, #0
 800cc38:	d102      	bne.n	800cc40 <ProcessBufferTryDecodeEcc+0x28>
        return MEMORY_E;
 800cc3a:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800cc3e:	e05a      	b.n	800ccf6 <ProcessBufferTryDecodeEcc+0xde>
#endif

    /* Initialize ECC key. */
    if (wc_ecc_init_ex(key, heap, devId) == 0) {
 800cc40:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800cc42:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 800cc44:	6a38      	ldr	r0, [r7, #32]
 800cc46:	f010 f8cd 	bl	801cde4 <wc_ecc_init_ex>
 800cc4a:	4603      	mov	r3, r0
 800cc4c:	2b00      	cmp	r3, #0
 800cc4e:	d149      	bne.n	800cce4 <ProcessBufferTryDecodeEcc+0xcc>
        /* Decode as an ECC private key. */
        idx = 0;
 800cc50:	2300      	movs	r3, #0
 800cc52:	613b      	str	r3, [r7, #16]
        ret = wc_EccPrivateKeyDecode(der->buffer, &idx, key, der->length);
 800cc54:	687b      	ldr	r3, [r7, #4]
 800cc56:	6818      	ldr	r0, [r3, #0]
 800cc58:	687b      	ldr	r3, [r7, #4]
 800cc5a:	689b      	ldr	r3, [r3, #8]
 800cc5c:	f107 0110 	add.w	r1, r7, #16
 800cc60:	6a3a      	ldr	r2, [r7, #32]
 800cc62:	f00d f8b5 	bl	8019dd0 <wc_EccPrivateKeyDecode>
 800cc66:	6278      	str	r0, [r7, #36]	@ 0x24
        if (*keyFormat == SM2k) {
            ret = wc_ecc_set_curve(key, WOLFSSL_SM2_KEY_BITS / 8,
                ECC_SM2P256V1);
        }
    #endif
        if (ret == 0) {
 800cc68:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800cc6a:	2b00      	cmp	r3, #0
 800cc6c:	d131      	bne.n	800ccd2 <ProcessBufferTryDecodeEcc+0xba>
            /* Get the minimum ECC key size from SSL or SSL context object. */
            int minKeySz = ssl ? ssl->options.minEccKeySz : ctx->minEccKeySz;
 800cc6e:	68bb      	ldr	r3, [r7, #8]
 800cc70:	2b00      	cmp	r3, #0
 800cc72:	d003      	beq.n	800cc7c <ProcessBufferTryDecodeEcc+0x64>
 800cc74:	68bb      	ldr	r3, [r7, #8]
 800cc76:	f9b3 32f6 	ldrsh.w	r3, [r3, #758]	@ 0x2f6
 800cc7a:	e002      	b.n	800cc82 <ProcessBufferTryDecodeEcc+0x6a>
 800cc7c:	68fb      	ldr	r3, [r7, #12]
 800cc7e:	f9b3 3068 	ldrsh.w	r3, [r3, #104]	@ 0x68
 800cc82:	61fb      	str	r3, [r7, #28]
            int keySz = wc_ecc_size(key);
 800cc84:	6a38      	ldr	r0, [r7, #32]
 800cc86:	f011 fac7 	bl	801e218 <wc_ecc_size>
 800cc8a:	61b8      	str	r0, [r7, #24]

            /* Format is known. */
            *keyFormat = ECDSAk;
 800cc8c:	683b      	ldr	r3, [r7, #0]
 800cc8e:	f240 2206 	movw	r2, #518	@ 0x206
 800cc92:	601a      	str	r2, [r3, #0]
                *keyType = sm2_sa_algo;
            }
            else
        #endif
            {
                *keyType = ecc_dsa_sa_algo;
 800cc94:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800cc96:	2203      	movs	r2, #3
 800cc98:	701a      	strb	r2, [r3, #0]
            }
            *keySize = keySz;
 800cc9a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800cc9c:	69ba      	ldr	r2, [r7, #24]
 800cc9e:	601a      	str	r2, [r3, #0]

            /* Check that the size of the ECC key is enough. */
            if (keySz < minKeySz) {
 800cca0:	69ba      	ldr	r2, [r7, #24]
 800cca2:	69fb      	ldr	r3, [r7, #28]
 800cca4:	429a      	cmp	r2, r3
 800cca6:	da01      	bge.n	800ccac <ProcessBufferTryDecodeEcc+0x94>
                WOLFSSL_MSG("ECC private key too small");
                ret = ECC_KEY_SIZE_E;
 800cca8:	4b15      	ldr	r3, [pc, #84]	@ (800cd00 <ProcessBufferTryDecodeEcc+0xe8>)
 800ccaa:	627b      	str	r3, [r7, #36]	@ 0x24
            }
            /* Static ECC key possible. */
            if (ssl) {
 800ccac:	68bb      	ldr	r3, [r7, #8]
 800ccae:	2b00      	cmp	r3, #0
 800ccb0:	d007      	beq.n	800ccc2 <ProcessBufferTryDecodeEcc+0xaa>
                ssl->options.haveStaticECC = 1;
 800ccb2:	68ba      	ldr	r2, [r7, #8]
 800ccb4:	f892 32d3 	ldrb.w	r3, [r2, #723]	@ 0x2d3
 800ccb8:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 800ccbc:	f882 32d3 	strb.w	r3, [r2, #723]	@ 0x2d3
 800ccc0:	e00d      	b.n	800ccde <ProcessBufferTryDecodeEcc+0xc6>
            }
            else {
                ctx->haveStaticECC = 1;
 800ccc2:	68fa      	ldr	r2, [r7, #12]
 800ccc4:	f892 305f 	ldrb.w	r3, [r2, #95]	@ 0x5f
 800ccc8:	f043 0301 	orr.w	r3, r3, #1
 800cccc:	f882 305f 	strb.w	r3, [r2, #95]	@ 0x5f
 800ccd0:	e005      	b.n	800ccde <ProcessBufferTryDecodeEcc+0xc6>
            }
        }
        /* Not an ECC key but check whether we know what it is. */
        else if (*keyFormat == 0) {
 800ccd2:	683b      	ldr	r3, [r7, #0]
 800ccd4:	681b      	ldr	r3, [r3, #0]
 800ccd6:	2b00      	cmp	r3, #0
 800ccd8:	d101      	bne.n	800ccde <ProcessBufferTryDecodeEcc+0xc6>
            WOLFSSL_MSG("Not an ECC key");
            /* Format unknown so keep trying. */
            ret = 0;
 800ccda:	2300      	movs	r3, #0
 800ccdc:	627b      	str	r3, [r7, #36]	@ 0x24
        }

        /* Free dynamically allocated data in key. */
        wc_ecc_free(key);
 800ccde:	6a38      	ldr	r0, [r7, #32]
 800cce0:	f010 f91b 	bl	801cf1a <wc_ecc_free>
    }

#ifdef WOLFSSL_SMALL_STACK
    /* Dispose of allocated key. */
    XFREE(key, heap, DYNAMIC_TYPE_ECC);
 800cce4:	6a3b      	ldr	r3, [r7, #32]
 800cce6:	617b      	str	r3, [r7, #20]
 800cce8:	697b      	ldr	r3, [r7, #20]
 800ccea:	2b00      	cmp	r3, #0
 800ccec:	d002      	beq.n	800ccf4 <ProcessBufferTryDecodeEcc+0xdc>
 800ccee:	6978      	ldr	r0, [r7, #20]
 800ccf0:	f011 fee6 	bl	801eac0 <wolfSSL_Free>
#endif
    return ret;
 800ccf4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 800ccf6:	4618      	mov	r0, r3
 800ccf8:	3728      	adds	r7, #40	@ 0x28
 800ccfa:	46bd      	mov	sp, r7
 800ccfc:	bd80      	pop	{r7, pc}
 800ccfe:	bf00      	nop
 800cd00:	fffffe66 	.word	0xfffffe66

0800cd04 <ProcessBufferTryDecode>:
 * @return  BAD_FUNC_ARG when ctx and ssl are NULL.
 * @return  WOLFSSL_BAD_FILE when unable to identify the key format.
 */
static int ProcessBufferTryDecode(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    DerBuffer* der, int* keyFormat, void* heap, int type)
{
 800cd04:	b580      	push	{r7, lr}
 800cd06:	b08c      	sub	sp, #48	@ 0x30
 800cd08:	af04      	add	r7, sp, #16
 800cd0a:	60f8      	str	r0, [r7, #12]
 800cd0c:	60b9      	str	r1, [r7, #8]
 800cd0e:	607a      	str	r2, [r7, #4]
 800cd10:	603b      	str	r3, [r7, #0]
    int ret = 0;
 800cd12:	2300      	movs	r3, #0
 800cd14:	61fb      	str	r3, [r7, #28]
    int devId = wolfSSL_CTX_GetDevId(ctx, ssl);
 800cd16:	68b9      	ldr	r1, [r7, #8]
 800cd18:	68f8      	ldr	r0, [r7, #12]
 800cd1a:	f7ff fa48 	bl	800c1ae <wolfSSL_CTX_GetDevId>
 800cd1e:	6138      	str	r0, [r7, #16]
    byte* keyType = NULL;
 800cd20:	2300      	movs	r3, #0
 800cd22:	61bb      	str	r3, [r7, #24]
    int* keySz = NULL;
 800cd24:	2300      	movs	r3, #0
 800cd26:	617b      	str	r3, [r7, #20]
    (void)heap;
    (void)devId;
    (void)type;

    /* Validate parameters. */
    if ((der == NULL) || (keyFormat == NULL)) {
 800cd28:	687b      	ldr	r3, [r7, #4]
 800cd2a:	2b00      	cmp	r3, #0
 800cd2c:	d002      	beq.n	800cd34 <ProcessBufferTryDecode+0x30>
 800cd2e:	683b      	ldr	r3, [r7, #0]
 800cd30:	2b00      	cmp	r3, #0
 800cd32:	d102      	bne.n	800cd3a <ProcessBufferTryDecode+0x36>
        ret = BAD_FUNC_ARG;
 800cd34:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800cd38:	61fb      	str	r3, [r7, #28]
    }
    /* Must have an SSL context or SSL object to use. */
    if ((ret == 0) && (ctx == NULL) && (ssl == NULL)) {
 800cd3a:	69fb      	ldr	r3, [r7, #28]
 800cd3c:	2b00      	cmp	r3, #0
 800cd3e:	d108      	bne.n	800cd52 <ProcessBufferTryDecode+0x4e>
 800cd40:	68fb      	ldr	r3, [r7, #12]
 800cd42:	2b00      	cmp	r3, #0
 800cd44:	d105      	bne.n	800cd52 <ProcessBufferTryDecode+0x4e>
 800cd46:	68bb      	ldr	r3, [r7, #8]
 800cd48:	2b00      	cmp	r3, #0
 800cd4a:	d102      	bne.n	800cd52 <ProcessBufferTryDecode+0x4e>
        ret = BAD_FUNC_ARG;
 800cd4c:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800cd50:	61fb      	str	r3, [r7, #28]
    }

    if (ret == 0) {
 800cd52:	69fb      	ldr	r3, [r7, #28]
 800cd54:	2b00      	cmp	r3, #0
 800cd56:	d111      	bne.n	800cd7c <ProcessBufferTryDecode+0x78>
            }
        }
        else
    #endif
        /* Type is PRIVATEKEY_TYPE. */
        if (ssl != NULL) {
 800cd58:	68bb      	ldr	r3, [r7, #8]
 800cd5a:	2b00      	cmp	r3, #0
 800cd5c:	d008      	beq.n	800cd70 <ProcessBufferTryDecode+0x6c>
            keyType = &ssl->buffers.keyType;
 800cd5e:	68bb      	ldr	r3, [r7, #8]
 800cd60:	f503 73ba 	add.w	r3, r3, #372	@ 0x174
 800cd64:	61bb      	str	r3, [r7, #24]
            keySz = &ssl->buffers.keySz;
 800cd66:	68bb      	ldr	r3, [r7, #8]
 800cd68:	f503 73bc 	add.w	r3, r3, #376	@ 0x178
 800cd6c:	617b      	str	r3, [r7, #20]
 800cd6e:	e005      	b.n	800cd7c <ProcessBufferTryDecode+0x78>
        }
        else {
            keyType = &ctx->privateKeyType;
 800cd70:	68fb      	ldr	r3, [r7, #12]
 800cd72:	3344      	adds	r3, #68	@ 0x44
 800cd74:	61bb      	str	r3, [r7, #24]
            keySz = &ctx->privateKeySz;
 800cd76:	68fb      	ldr	r3, [r7, #12]
 800cd78:	3348      	adds	r3, #72	@ 0x48
 800cd7a:	617b      	str	r3, [r7, #20]
        }
    }

#ifndef NO_RSA
    /* Try RSA if key format is RSA or yet unknown. */
    if ((ret == 0) && ((*keyFormat == 0) || (*keyFormat == RSAk))) {
 800cd7c:	69fb      	ldr	r3, [r7, #28]
 800cd7e:	2b00      	cmp	r3, #0
 800cd80:	d116      	bne.n	800cdb0 <ProcessBufferTryDecode+0xac>
 800cd82:	683b      	ldr	r3, [r7, #0]
 800cd84:	681b      	ldr	r3, [r3, #0]
 800cd86:	2b00      	cmp	r3, #0
 800cd88:	d005      	beq.n	800cd96 <ProcessBufferTryDecode+0x92>
 800cd8a:	683b      	ldr	r3, [r7, #0]
 800cd8c:	681b      	ldr	r3, [r3, #0]
 800cd8e:	f240 2285 	movw	r2, #645	@ 0x285
 800cd92:	4293      	cmp	r3, r2
 800cd94:	d10c      	bne.n	800cdb0 <ProcessBufferTryDecode+0xac>
#if !defined(HAVE_FIPS) || (defined(HAVE_FIPS_VERSION) && \
    (HAVE_FIPS_VERSION > 2))
        ret = ProcessBufferTryDecodeRsa(ctx, ssl, der, keyFormat, devId,
 800cd96:	697b      	ldr	r3, [r7, #20]
 800cd98:	9302      	str	r3, [sp, #8]
 800cd9a:	69bb      	ldr	r3, [r7, #24]
 800cd9c:	9301      	str	r3, [sp, #4]
 800cd9e:	693b      	ldr	r3, [r7, #16]
 800cda0:	9300      	str	r3, [sp, #0]
 800cda2:	683b      	ldr	r3, [r7, #0]
 800cda4:	687a      	ldr	r2, [r7, #4]
 800cda6:	68b9      	ldr	r1, [r7, #8]
 800cda8:	68f8      	ldr	r0, [r7, #12]
 800cdaa:	f7ff fee1 	bl	800cb70 <ProcessBufferTryDecodeRsa>
 800cdae:	61f8      	str	r0, [r7, #28]
#endif
    }
#endif
#ifdef HAVE_ECC
    /* Try ECC if key format is ECDSA or SM2, or yet unknown. */
    if ((ret == 0) && ((*keyFormat == 0) || (*keyFormat == ECDSAk)
 800cdb0:	69fb      	ldr	r3, [r7, #28]
 800cdb2:	2b00      	cmp	r3, #0
 800cdb4:	d118      	bne.n	800cde8 <ProcessBufferTryDecode+0xe4>
 800cdb6:	683b      	ldr	r3, [r7, #0]
 800cdb8:	681b      	ldr	r3, [r3, #0]
 800cdba:	2b00      	cmp	r3, #0
 800cdbc:	d005      	beq.n	800cdca <ProcessBufferTryDecode+0xc6>
 800cdbe:	683b      	ldr	r3, [r7, #0]
 800cdc0:	681b      	ldr	r3, [r3, #0]
 800cdc2:	f240 2206 	movw	r2, #518	@ 0x206
 800cdc6:	4293      	cmp	r3, r2
 800cdc8:	d10e      	bne.n	800cde8 <ProcessBufferTryDecode+0xe4>
    #ifdef WOLFSSL_SM2
        || (*keyFormat == SM2k)
    #endif
        )) {
        ret = ProcessBufferTryDecodeEcc(ctx, ssl, der, keyFormat, heap, devId,
 800cdca:	697b      	ldr	r3, [r7, #20]
 800cdcc:	9303      	str	r3, [sp, #12]
 800cdce:	69bb      	ldr	r3, [r7, #24]
 800cdd0:	9302      	str	r3, [sp, #8]
 800cdd2:	693b      	ldr	r3, [r7, #16]
 800cdd4:	9301      	str	r3, [sp, #4]
 800cdd6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800cdd8:	9300      	str	r3, [sp, #0]
 800cdda:	683b      	ldr	r3, [r7, #0]
 800cddc:	687a      	ldr	r2, [r7, #4]
 800cdde:	68b9      	ldr	r1, [r7, #8]
 800cde0:	68f8      	ldr	r0, [r7, #12]
 800cde2:	f7ff ff19 	bl	800cc18 <ProcessBufferTryDecodeEcc>
 800cde6:	61f8      	str	r0, [r7, #28]
            keyType, keySz);
    }
#endif /* HAVE_DILITHIUM */

    /* Check we know the format. */
    if ((ret == 0) && (*keyFormat == 0)) {
 800cde8:	69fb      	ldr	r3, [r7, #28]
 800cdea:	2b00      	cmp	r3, #0
 800cdec:	d106      	bne.n	800cdfc <ProcessBufferTryDecode+0xf8>
 800cdee:	683b      	ldr	r3, [r7, #0]
 800cdf0:	681b      	ldr	r3, [r3, #0]
 800cdf2:	2b00      	cmp	r3, #0
 800cdf4:	d102      	bne.n	800cdfc <ProcessBufferTryDecode+0xf8>
        WOLFSSL_MSG("Not a supported key type");
        /* Not supported key format. */
        ret = WOLFSSL_BAD_FILE;
 800cdf6:	f46f 73e7 	mvn.w	r3, #462	@ 0x1ce
 800cdfa:	61fb      	str	r3, [r7, #28]
    }

    return ret;
 800cdfc:	69fb      	ldr	r3, [r7, #28]
}
 800cdfe:	4618      	mov	r0, r3
 800ce00:	3720      	adds	r7, #32
 800ce02:	46bd      	mov	sp, r7
 800ce04:	bd80      	pop	{r7, pc}

0800ce06 <ProcessBufferPrivKeyHandleDer>:
 * @param [in]      der  DER encoding.
 * @return  0 on success.
 */
static int ProcessBufferPrivKeyHandleDer(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    DerBuffer** der, int type)
{
 800ce06:	b580      	push	{r7, lr}
 800ce08:	b086      	sub	sp, #24
 800ce0a:	af00      	add	r7, sp, #0
 800ce0c:	60f8      	str	r0, [r7, #12]
 800ce0e:	60b9      	str	r1, [r7, #8]
 800ce10:	607a      	str	r2, [r7, #4]
 800ce12:	603b      	str	r3, [r7, #0]
    int ret = 0;
 800ce14:	2300      	movs	r3, #0
 800ce16:	617b      	str	r3, [r7, #20]
        #endif
        }
    }
    else
#endif /* WOLFSSL_DUAL_ALG_CERTS */
    if (ssl != NULL) {
 800ce18:	68bb      	ldr	r3, [r7, #8]
 800ce1a:	2b00      	cmp	r3, #0
 800ce1c:	d027      	beq.n	800ce6e <ProcessBufferPrivKeyHandleDer+0x68>
        /* Dispose of previous key if not context's. */
        if (ssl->buffers.weOwnKey) {
 800ce1e:	68bb      	ldr	r3, [r7, #8]
 800ce20:	f893 3146 	ldrb.w	r3, [r3, #326]	@ 0x146
 800ce24:	2b00      	cmp	r3, #0
 800ce26:	d005      	beq.n	800ce34 <ProcessBufferPrivKeyHandleDer+0x2e>
            FreeDer(&ssl->buffers.key);
 800ce28:	68bb      	ldr	r3, [r7, #8]
 800ce2a:	f503 73b8 	add.w	r3, r3, #368	@ 0x170
 800ce2e:	4618      	mov	r0, r3
 800ce30:	f00c f8a4 	bl	8018f7c <FreeDer>
        #ifdef WOLFSSL_BLIND_PRIVATE_KEY
            FreeDer(&ssl->buffers.keyMask);
        #endif
        }
        ssl->buffers.keyId = 0;
 800ce34:	68ba      	ldr	r2, [r7, #8]
 800ce36:	f892 3175 	ldrb.w	r3, [r2, #373]	@ 0x175
 800ce3a:	f023 0301 	bic.w	r3, r3, #1
 800ce3e:	f882 3175 	strb.w	r3, [r2, #373]	@ 0x175
        ssl->buffers.keyLabel = 0;
 800ce42:	68ba      	ldr	r2, [r7, #8]
 800ce44:	f892 3175 	ldrb.w	r3, [r2, #373]	@ 0x175
 800ce48:	f023 0302 	bic.w	r3, r3, #2
 800ce4c:	f882 3175 	strb.w	r3, [r2, #373]	@ 0x175
        ssl->buffers.keyDevId = INVALID_DEVID;
 800ce50:	68bb      	ldr	r3, [r7, #8]
 800ce52:	f06f 0201 	mvn.w	r2, #1
 800ce56:	f8c3 217c 	str.w	r2, [r3, #380]	@ 0x17c
        /* Store key by reference and own it. */
        ssl->buffers.key = *der;
 800ce5a:	687b      	ldr	r3, [r7, #4]
 800ce5c:	681a      	ldr	r2, [r3, #0]
 800ce5e:	68bb      	ldr	r3, [r7, #8]
 800ce60:	f8c3 2170 	str.w	r2, [r3, #368]	@ 0x170
    #ifdef WOLFSSL_CHECK_MEM_ZERO
        wc_MemZero_Add("SSL Buffers key", (*der)->buffer, (*der)->length);
    #endif
        ssl->buffers.weOwnKey = 1;
 800ce64:	68bb      	ldr	r3, [r7, #8]
 800ce66:	2201      	movs	r2, #1
 800ce68:	f883 2146 	strb.w	r2, [r3, #326]	@ 0x146
 800ce6c:	e01d      	b.n	800ceaa <ProcessBufferPrivKeyHandleDer+0xa4>
    }
    else if (ctx != NULL) {
 800ce6e:	68fb      	ldr	r3, [r7, #12]
 800ce70:	2b00      	cmp	r3, #0
 800ce72:	d01a      	beq.n	800ceaa <ProcessBufferPrivKeyHandleDer+0xa4>
        /* Dispose of previous key. */
        FreeDer(&ctx->privateKey);
 800ce74:	68fb      	ldr	r3, [r7, #12]
 800ce76:	3340      	adds	r3, #64	@ 0x40
 800ce78:	4618      	mov	r0, r3
 800ce7a:	f00c f87f 	bl	8018f7c <FreeDer>
        ctx->privateKeyId = 0;
 800ce7e:	68fa      	ldr	r2, [r7, #12]
 800ce80:	f892 3045 	ldrb.w	r3, [r2, #69]	@ 0x45
 800ce84:	f023 0301 	bic.w	r3, r3, #1
 800ce88:	f882 3045 	strb.w	r3, [r2, #69]	@ 0x45
        ctx->privateKeyLabel = 0;
 800ce8c:	68fa      	ldr	r2, [r7, #12]
 800ce8e:	f892 3045 	ldrb.w	r3, [r2, #69]	@ 0x45
 800ce92:	f023 0302 	bic.w	r3, r3, #2
 800ce96:	f882 3045 	strb.w	r3, [r2, #69]	@ 0x45
        ctx->privateKeyDevId = INVALID_DEVID;
 800ce9a:	68fb      	ldr	r3, [r7, #12]
 800ce9c:	f06f 0201 	mvn.w	r2, #1
 800cea0:	64da      	str	r2, [r3, #76]	@ 0x4c
        /* Store key by reference. */
        ctx->privateKey = *der;
 800cea2:	687b      	ldr	r3, [r7, #4]
 800cea4:	681a      	ldr	r2, [r3, #0]
 800cea6:	68fb      	ldr	r3, [r7, #12]
 800cea8:	641a      	str	r2, [r3, #64]	@ 0x40
    #ifdef WOLFSSL_CHECK_MEM_ZERO
        wc_MemZero_Add("CTX private key", (*der)->buffer, (*der)->length);
    #endif
    }

    return ret;
 800ceaa:	697b      	ldr	r3, [r7, #20]
}
 800ceac:	4618      	mov	r0, r3
 800ceae:	3718      	adds	r7, #24
 800ceb0:	46bd      	mov	sp, r7
 800ceb2:	bd80      	pop	{r7, pc}

0800ceb4 <ProcessBufferPrivateKey>:
 * @return  WOLFSSL_BAD_FILE when not able to decode.
 */
static int ProcessBufferPrivateKey(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    DerBuffer* der, int format, EncryptedInfo* info, void* heap, int type,
    int algId)
{
 800ceb4:	b580      	push	{r7, lr}
 800ceb6:	b088      	sub	sp, #32
 800ceb8:	af02      	add	r7, sp, #8
 800ceba:	60f8      	str	r0, [r7, #12]
 800cebc:	60b9      	str	r1, [r7, #8]
 800cebe:	607a      	str	r2, [r7, #4]
 800cec0:	603b      	str	r3, [r7, #0]

    (void)info;
    (void)format;

    /* Put the data into the SSL or SSL context object. */
    ret = ProcessBufferPrivKeyHandleDer(ctx, ssl, &der, type);
 800cec2:	1d3a      	adds	r2, r7, #4
 800cec4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800cec6:	68b9      	ldr	r1, [r7, #8]
 800cec8:	68f8      	ldr	r0, [r7, #12]
 800ceca:	f7ff ff9c 	bl	800ce06 <ProcessBufferPrivKeyHandleDer>
 800cece:	6178      	str	r0, [r7, #20]
    if (ret == 0) {
 800ced0:	697b      	ldr	r3, [r7, #20]
 800ced2:	2b00      	cmp	r3, #0
 800ced4:	d10c      	bne.n	800cef0 <ProcessBufferPrivateKey+0x3c>
        /* Try to decode the DER data. */
        ret = ProcessBufferTryDecode(ctx, ssl, der, &algId, heap, type);
 800ced6:	687a      	ldr	r2, [r7, #4]
 800ced8:	f107 012c 	add.w	r1, r7, #44	@ 0x2c
 800cedc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800cede:	9301      	str	r3, [sp, #4]
 800cee0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800cee2:	9300      	str	r3, [sp, #0]
 800cee4:	460b      	mov	r3, r1
 800cee6:	68b9      	ldr	r1, [r7, #8]
 800cee8:	68f8      	ldr	r0, [r7, #12]
 800ceea:	f7ff ff0b 	bl	800cd04 <ProcessBufferTryDecode>
 800ceee:	6178      	str	r0, [r7, #20]
            &ctx->privateKeyMask);
    }
#endif

    /* Check if we were able to determine algorithm id. */
    if ((ret == 0) && (algId == 0)) {
 800cef0:	697b      	ldr	r3, [r7, #20]
 800cef2:	2b00      	cmp	r3, #0
 800cef4:	d11d      	bne.n	800cf32 <ProcessBufferPrivateKey+0x7e>
 800cef6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800cef8:	2b00      	cmp	r3, #0
 800cefa:	d11a      	bne.n	800cf32 <ProcessBufferPrivateKey+0x7e>
    #ifdef OPENSSL_EXTRA
        /* Decryption password is probably wrong. */
        if (info->passwd_cb) {
 800cefc:	6a3b      	ldr	r3, [r7, #32]
 800cefe:	685b      	ldr	r3, [r3, #4]
 800cf00:	2b00      	cmp	r3, #0
 800cf02:	d009      	beq.n	800cf18 <ProcessBufferPrivateKey+0x64>
            WOLFSSL_EVPerr(0, -WOLFSSL_EVP_R_BAD_DECRYPT_E);
 800cf04:	f44f 63af 	mov.w	r3, #1400	@ 0x578
 800cf08:	9300      	str	r3, [sp, #0]
 800cf0a:	4b0c      	ldr	r3, [pc, #48]	@ (800cf3c <ProcessBufferPrivateKey+0x88>)
 800cf0c:	f44f 7200 	mov.w	r2, #512	@ 0x200
 800cf10:	2100      	movs	r1, #0
 800cf12:	200b      	movs	r0, #11
 800cf14:	f000 fe68 	bl	800dbe8 <wolfSSL_ERR_put_error>
        }
    #endif
        WOLFSSL_ERROR(WOLFSSL_BAD_FILE);
 800cf18:	2300      	movs	r3, #0
 800cf1a:	9300      	str	r3, [sp, #0]
 800cf1c:	4b07      	ldr	r3, [pc, #28]	@ (800cf3c <ProcessBufferPrivateKey+0x88>)
 800cf1e:	f240 527b 	movw	r2, #1403	@ 0x57b
 800cf22:	4907      	ldr	r1, [pc, #28]	@ (800cf40 <ProcessBufferPrivateKey+0x8c>)
 800cf24:	f46f 70e7 	mvn.w	r0, #462	@ 0x1ce
 800cf28:	f011 fd62 	bl	801e9f0 <WOLFSSL_ERROR_LINE>
        /* Unable to decode DER data. */
        ret = WOLFSSL_BAD_FILE;
 800cf2c:	f46f 73e7 	mvn.w	r3, #462	@ 0x1ce
 800cf30:	617b      	str	r3, [r7, #20]
    }

    return ret;
 800cf32:	697b      	ldr	r3, [r7, #20]
}
 800cf34:	4618      	mov	r0, r3
 800cf36:	3718      	adds	r7, #24
 800cf38:	46bd      	mov	sp, r7
 800cf3a:	bd80      	pop	{r7, pc}
 800cf3c:	08029f2c 	.word	0x08029f2c
 800cf40:	08031440 	.word	0x08031440

0800cf44 <wolfssl_set_have_from_key_oid>:
 * @param [in, out] ssl     SSL object.
 * @param [in]      keyOID  OID for public/private key.
 */
static void wolfssl_set_have_from_key_oid(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    int keyOID)
{
 800cf44:	b480      	push	{r7}
 800cf46:	b085      	sub	sp, #20
 800cf48:	af00      	add	r7, sp, #0
 800cf4a:	60f8      	str	r0, [r7, #12]
 800cf4c:	60b9      	str	r1, [r7, #8]
 800cf4e:	607a      	str	r2, [r7, #4]
    /* Set which private key algorithm available based on key OID. */
    switch (keyOID) {
 800cf50:	687b      	ldr	r3, [r7, #4]
 800cf52:	f240 228e 	movw	r2, #654	@ 0x28e
 800cf56:	4293      	cmp	r3, r2
 800cf58:	d022      	beq.n	800cfa0 <wolfssl_set_have_from_key_oid+0x5c>
 800cf5a:	687b      	ldr	r3, [r7, #4]
 800cf5c:	f240 228e 	movw	r2, #654	@ 0x28e
 800cf60:	4293      	cmp	r3, r2
 800cf62:	dc30      	bgt.n	800cfc6 <wolfssl_set_have_from_key_oid+0x82>
 800cf64:	687b      	ldr	r3, [r7, #4]
 800cf66:	f240 2206 	movw	r2, #518	@ 0x206
 800cf6a:	4293      	cmp	r3, r2
 800cf6c:	d005      	beq.n	800cf7a <wolfssl_set_have_from_key_oid+0x36>
 800cf6e:	687b      	ldr	r3, [r7, #4]
 800cf70:	f240 2285 	movw	r2, #645	@ 0x285
 800cf74:	4293      	cmp	r3, r2
 800cf76:	d013      	beq.n	800cfa0 <wolfssl_set_have_from_key_oid+0x5c>
            }
            break;
    #endif /* HAVE_DILITHIUM */
        default:
            WOLFSSL_MSG("Cert key not supported");
            break;
 800cf78:	e025      	b.n	800cfc6 <wolfssl_set_have_from_key_oid+0x82>
            if (ssl != NULL) {
 800cf7a:	68bb      	ldr	r3, [r7, #8]
 800cf7c:	2b00      	cmp	r3, #0
 800cf7e:	d007      	beq.n	800cf90 <wolfssl_set_have_from_key_oid+0x4c>
                ssl->options.haveECC = 1;
 800cf80:	68ba      	ldr	r2, [r7, #8]
 800cf82:	f892 32d3 	ldrb.w	r3, [r2, #723]	@ 0x2d3
 800cf86:	f043 0310 	orr.w	r3, r3, #16
 800cf8a:	f882 32d3 	strb.w	r3, [r2, #723]	@ 0x2d3
            break;
 800cf8e:	e01b      	b.n	800cfc8 <wolfssl_set_have_from_key_oid+0x84>
                ctx->haveECC = 1;
 800cf90:	68fa      	ldr	r2, [r7, #12]
 800cf92:	f892 305e 	ldrb.w	r3, [r2, #94]	@ 0x5e
 800cf96:	f043 0308 	orr.w	r3, r3, #8
 800cf9a:	f882 305e 	strb.w	r3, [r2, #94]	@ 0x5e
            break;
 800cf9e:	e013      	b.n	800cfc8 <wolfssl_set_have_from_key_oid+0x84>
            if (ssl != NULL) {
 800cfa0:	68bb      	ldr	r3, [r7, #8]
 800cfa2:	2b00      	cmp	r3, #0
 800cfa4:	d007      	beq.n	800cfb6 <wolfssl_set_have_from_key_oid+0x72>
                ssl->options.haveRSA = 1;
 800cfa6:	68ba      	ldr	r2, [r7, #8]
 800cfa8:	f892 32d3 	ldrb.w	r3, [r2, #723]	@ 0x2d3
 800cfac:	f043 0308 	orr.w	r3, r3, #8
 800cfb0:	f882 32d3 	strb.w	r3, [r2, #723]	@ 0x2d3
            break;
 800cfb4:	e008      	b.n	800cfc8 <wolfssl_set_have_from_key_oid+0x84>
                ctx->haveRSA = 1;
 800cfb6:	68fa      	ldr	r2, [r7, #12]
 800cfb8:	f892 305e 	ldrb.w	r3, [r2, #94]	@ 0x5e
 800cfbc:	f043 0304 	orr.w	r3, r3, #4
 800cfc0:	f882 305e 	strb.w	r3, [r2, #94]	@ 0x5e
            break;
 800cfc4:	e000      	b.n	800cfc8 <wolfssl_set_have_from_key_oid+0x84>
            break;
 800cfc6:	bf00      	nop
        }
}
 800cfc8:	bf00      	nop
 800cfca:	3714      	adds	r7, #20
 800cfcc:	46bd      	mov	sp, r7
 800cfce:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cfd2:	4770      	bx	lr

0800cfd4 <ProcessBufferCertSetHave>:
 * @param [in, out] ssl     SSL object.
 * @param [in]      cert    Decode certificate.
 */
static void ProcessBufferCertSetHave(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    DecodedCert* cert)
{
 800cfd4:	b580      	push	{r7, lr}
 800cfd6:	b084      	sub	sp, #16
 800cfd8:	af00      	add	r7, sp, #0
 800cfda:	60f8      	str	r0, [r7, #12]
 800cfdc:	60b9      	str	r1, [r7, #8]
 800cfde:	607a      	str	r2, [r7, #4]
    if (ssl != NULL) {
 800cfe0:	68bb      	ldr	r3, [r7, #8]
 800cfe2:	2b00      	cmp	r3, #0
 800cfe4:	d014      	beq.n	800d010 <ProcessBufferCertSetHave+0x3c>
        /* Reset signatures we have in SSL. */
        ssl->options.haveECDSAsig = 0;
 800cfe6:	68ba      	ldr	r2, [r7, #8]
 800cfe8:	f892 32d3 	ldrb.w	r3, [r2, #723]	@ 0x2d3
 800cfec:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 800cff0:	f882 32d3 	strb.w	r3, [r2, #723]	@ 0x2d3
        ssl->options.haveFalconSig = 0;
 800cff4:	68ba      	ldr	r2, [r7, #8]
 800cff6:	f892 32d4 	ldrb.w	r3, [r2, #724]	@ 0x2d4
 800cffa:	f023 0301 	bic.w	r3, r3, #1
 800cffe:	f882 32d4 	strb.w	r3, [r2, #724]	@ 0x2d4
        ssl->options.haveDilithiumSig = 0;
 800d002:	68ba      	ldr	r2, [r7, #8]
 800d004:	f892 32d4 	ldrb.w	r3, [r2, #724]	@ 0x2d4
 800d008:	f023 0302 	bic.w	r3, r3, #2
 800d00c:	f882 32d4 	strb.w	r3, [r2, #724]	@ 0x2d4
    }

    /* Set which signature we have based on the type in the cert. */
    switch (cert->signatureOID) {
 800d010:	687b      	ldr	r3, [r7, #4]
 800d012:	699b      	ldr	r3, [r3, #24]
 800d014:	f5b3 7f02 	cmp.w	r3, #520	@ 0x208
 800d018:	d006      	beq.n	800d028 <ProcessBufferCertSetHave+0x54>
 800d01a:	f5b3 7f02 	cmp.w	r3, #520	@ 0x208
 800d01e:	d319      	bcc.n	800d054 <ProcessBufferCertSetHave+0x80>
 800d020:	f5a3 7303 	sub.w	r3, r3, #524	@ 0x20c
 800d024:	2b02      	cmp	r3, #2
 800d026:	d815      	bhi.n	800d054 <ProcessBufferCertSetHave+0x80>
    #endif
    #if defined(WOLFSSL_SM2) && defined(WOLFSSL_SM3)
        case CTC_SM3wSM2:
    #endif
            WOLFSSL_MSG("ECDSA/ED25519/ED448 cert signature");
            if (ssl) {
 800d028:	68bb      	ldr	r3, [r7, #8]
 800d02a:	2b00      	cmp	r3, #0
 800d02c:	d007      	beq.n	800d03e <ProcessBufferCertSetHave+0x6a>
                ssl->options.haveECDSAsig = 1;
 800d02e:	68ba      	ldr	r2, [r7, #8]
 800d030:	f892 32d3 	ldrb.w	r3, [r2, #723]	@ 0x2d3
 800d034:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 800d038:	f882 32d3 	strb.w	r3, [r2, #723]	@ 0x2d3
            }
            else if (ctx) {
                ctx->haveECDSAsig = 1;
            }
            break;
 800d03c:	e00c      	b.n	800d058 <ProcessBufferCertSetHave+0x84>
            else if (ctx) {
 800d03e:	68fb      	ldr	r3, [r7, #12]
 800d040:	2b00      	cmp	r3, #0
 800d042:	d009      	beq.n	800d058 <ProcessBufferCertSetHave+0x84>
                ctx->haveECDSAsig = 1;
 800d044:	68fa      	ldr	r2, [r7, #12]
 800d046:	f892 305e 	ldrb.w	r3, [r2, #94]	@ 0x5e
 800d04a:	f043 0320 	orr.w	r3, r3, #32
 800d04e:	f882 305e 	strb.w	r3, [r2, #94]	@ 0x5e
            break;
 800d052:	e001      	b.n	800d058 <ProcessBufferCertSetHave+0x84>
            }
            break;
    #endif
        default:
            WOLFSSL_MSG("Cert signature not supported");
            break;
 800d054:	bf00      	nop
 800d056:	e000      	b.n	800d05a <ProcessBufferCertSetHave+0x86>
            break;
 800d058:	bf00      	nop

#if defined(HAVE_ECC) || defined(HAVE_ED25519) || defined(HAVE_ED448) || \
    defined(HAVE_FALCON) || defined(HAVE_DILITHIUM) || !defined(NO_RSA)
    #if defined(HAVE_ECC) || defined(HAVE_ED25519) || defined(HAVE_ED448)
    /* Set the private key curve OID. */
    if (ssl != NULL) {
 800d05a:	68bb      	ldr	r3, [r7, #8]
 800d05c:	2b00      	cmp	r3, #0
 800d05e:	d006      	beq.n	800d06e <ProcessBufferCertSetHave+0x9a>
        ssl->pkCurveOID = cert->pkCurveOID;
 800d060:	687b      	ldr	r3, [r7, #4]
 800d062:	f8d3 2440 	ldr.w	r2, [r3, #1088]	@ 0x440
 800d066:	68bb      	ldr	r3, [r7, #8]
 800d068:	f8c3 23a8 	str.w	r2, [r3, #936]	@ 0x3a8
 800d06c:	e008      	b.n	800d080 <ProcessBufferCertSetHave+0xac>
    }
    else if (ctx) {
 800d06e:	68fb      	ldr	r3, [r7, #12]
 800d070:	2b00      	cmp	r3, #0
 800d072:	d005      	beq.n	800d080 <ProcessBufferCertSetHave+0xac>
        ctx->pkCurveOID = cert->pkCurveOID;
 800d074:	687b      	ldr	r3, [r7, #4]
 800d076:	f8d3 2440 	ldr.w	r2, [r3, #1088]	@ 0x440
 800d07a:	68fb      	ldr	r3, [r7, #12]
 800d07c:	f8c3 20d0 	str.w	r2, [r3, #208]	@ 0xd0
    }
    #endif
#ifndef WC_STRICT_SIG
    if ((ctx != NULL) || (ssl != NULL)) {
 800d080:	68fb      	ldr	r3, [r7, #12]
 800d082:	2b00      	cmp	r3, #0
 800d084:	d102      	bne.n	800d08c <ProcessBufferCertSetHave+0xb8>
 800d086:	68bb      	ldr	r3, [r7, #8]
 800d088:	2b00      	cmp	r3, #0
 800d08a:	d006      	beq.n	800d09a <ProcessBufferCertSetHave+0xc6>
        wolfssl_set_have_from_key_oid(ctx, ssl, (int)cert->keyOID);
 800d08c:	687b      	ldr	r3, [r7, #4]
 800d08e:	69db      	ldr	r3, [r3, #28]
 800d090:	461a      	mov	r2, r3
 800d092:	68b9      	ldr	r1, [r7, #8]
 800d094:	68f8      	ldr	r0, [r7, #12]
 800d096:	f7ff ff55 	bl	800cf44 <wolfssl_set_have_from_key_oid>
    else if (ctx) {
        ctx->haveECC = ctx->haveECDSAsig;
    }
#endif /* !WC_STRICT_SIG */
#endif
}
 800d09a:	bf00      	nop
 800d09c:	3710      	adds	r7, #16
 800d09e:	46bd      	mov	sp, r7
 800d0a0:	bd80      	pop	{r7, pc}
	...

0800d0a4 <ProcessBufferCertPublicKey>:
 * @return  0 on success.
 * @return  Non-zero when an error occurred.
 */
static int ProcessBufferCertPublicKey(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    DecodedCert* cert, int checkKeySz)
{
 800d0a4:	b580      	push	{r7, lr}
 800d0a6:	b08c      	sub	sp, #48	@ 0x30
 800d0a8:	af04      	add	r7, sp, #16
 800d0aa:	60f8      	str	r0, [r7, #12]
 800d0ac:	60b9      	str	r1, [r7, #8]
 800d0ae:	607a      	str	r2, [r7, #4]
 800d0b0:	603b      	str	r3, [r7, #0]
    int ret = 0;
 800d0b2:	2300      	movs	r3, #0
 800d0b4:	61fb      	str	r3, [r7, #28]
    byte keyType = 0;
 800d0b6:	2300      	movs	r3, #0
 800d0b8:	76fb      	strb	r3, [r7, #27]
    int keySz = 0;
 800d0ba:	2300      	movs	r3, #0
 800d0bc:	617b      	str	r3, [r7, #20]
#ifndef NO_RSA
    word32 idx;
#endif

    /* Get key size and check unless not verifying. */
    switch (cert->keyOID) {
 800d0be:	687b      	ldr	r3, [r7, #4]
 800d0c0:	69db      	ldr	r3, [r3, #28]
 800d0c2:	f240 228e 	movw	r2, #654	@ 0x28e
 800d0c6:	4293      	cmp	r3, r2
 800d0c8:	d00c      	beq.n	800d0e4 <ProcessBufferCertPublicKey+0x40>
 800d0ca:	f240 228e 	movw	r2, #654	@ 0x28e
 800d0ce:	4293      	cmp	r3, r2
 800d0d0:	f200 8082 	bhi.w	800d1d8 <ProcessBufferCertPublicKey+0x134>
 800d0d4:	f240 2206 	movw	r2, #518	@ 0x206
 800d0d8:	4293      	cmp	r3, r2
 800d0da:	d045      	beq.n	800d168 <ProcessBufferCertPublicKey+0xc4>
 800d0dc:	f240 2285 	movw	r2, #645	@ 0x285
 800d0e0:	4293      	cmp	r3, r2
 800d0e2:	d179      	bne.n	800d1d8 <ProcessBufferCertPublicKey+0x134>
#ifndef NO_RSA
    #ifdef WC_RSA_PSS
        case RSAPSSk:
    #endif
        case RSAk:
            keyType = rsa_sa_algo;
 800d0e4:	2301      	movs	r3, #1
 800d0e6:	76fb      	strb	r3, [r7, #27]
            /* Determine RSA key size by parsing public key */
            idx = 0;
 800d0e8:	2300      	movs	r3, #0
 800d0ea:	613b      	str	r3, [r7, #16]
            ret = wc_RsaPublicKeyDecode_ex(cert->publicKey, &idx,
 800d0ec:	687b      	ldr	r3, [r7, #4]
 800d0ee:	6818      	ldr	r0, [r3, #0]
 800d0f0:	687b      	ldr	r3, [r7, #4]
 800d0f2:	685a      	ldr	r2, [r3, #4]
 800d0f4:	f107 0110 	add.w	r1, r7, #16
 800d0f8:	2300      	movs	r3, #0
 800d0fa:	9302      	str	r3, [sp, #8]
 800d0fc:	2300      	movs	r3, #0
 800d0fe:	9301      	str	r3, [sp, #4]
 800d100:	f107 0314 	add.w	r3, r7, #20
 800d104:	9300      	str	r3, [sp, #0]
 800d106:	2300      	movs	r3, #0
 800d108:	f007 fed0 	bl	8014eac <wc_RsaPublicKeyDecode_ex>
 800d10c:	61f8      	str	r0, [r7, #28]
                cert->pubKeySize, NULL, (word32*)&keySz, NULL, NULL);
            if ((ret == 0) && checkKeySz) {
 800d10e:	69fb      	ldr	r3, [r7, #28]
 800d110:	2b00      	cmp	r3, #0
 800d112:	d163      	bne.n	800d1dc <ProcessBufferCertPublicKey+0x138>
 800d114:	683b      	ldr	r3, [r7, #0]
 800d116:	2b00      	cmp	r3, #0
 800d118:	d060      	beq.n	800d1dc <ProcessBufferCertPublicKey+0x138>
                ret = CHECK_KEY_SZ(ssl ? ssl->options.minRsaKeySz :
 800d11a:	68bb      	ldr	r3, [r7, #8]
 800d11c:	2b00      	cmp	r3, #0
 800d11e:	d005      	beq.n	800d12c <ProcessBufferCertPublicKey+0x88>
 800d120:	68bb      	ldr	r3, [r7, #8]
 800d122:	f9b3 32f4 	ldrsh.w	r3, [r3, #756]	@ 0x2f4
 800d126:	2b00      	cmp	r3, #0
 800d128:	db18      	blt.n	800d15c <ProcessBufferCertPublicKey+0xb8>
 800d12a:	e004      	b.n	800d136 <ProcessBufferCertPublicKey+0x92>
 800d12c:	68fb      	ldr	r3, [r7, #12]
 800d12e:	f9b3 3066 	ldrsh.w	r3, [r3, #102]	@ 0x66
 800d132:	2b00      	cmp	r3, #0
 800d134:	db12      	blt.n	800d15c <ProcessBufferCertPublicKey+0xb8>
 800d136:	68bb      	ldr	r3, [r7, #8]
 800d138:	2b00      	cmp	r3, #0
 800d13a:	d004      	beq.n	800d146 <ProcessBufferCertPublicKey+0xa2>
 800d13c:	68bb      	ldr	r3, [r7, #8]
 800d13e:	f9b3 32f4 	ldrsh.w	r3, [r3, #756]	@ 0x2f4
 800d142:	461a      	mov	r2, r3
 800d144:	e003      	b.n	800d14e <ProcessBufferCertPublicKey+0xaa>
 800d146:	68fb      	ldr	r3, [r7, #12]
 800d148:	f9b3 3066 	ldrsh.w	r3, [r3, #102]	@ 0x66
 800d14c:	461a      	mov	r2, r3
 800d14e:	697b      	ldr	r3, [r7, #20]
 800d150:	429a      	cmp	r2, r3
 800d152:	dc03      	bgt.n	800d15c <ProcessBufferCertPublicKey+0xb8>
 800d154:	697b      	ldr	r3, [r7, #20]
 800d156:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800d15a:	dd02      	ble.n	800d162 <ProcessBufferCertPublicKey+0xbe>
 800d15c:	f46f 73cc 	mvn.w	r3, #408	@ 0x198
 800d160:	e000      	b.n	800d164 <ProcessBufferCertPublicKey+0xc0>
 800d162:	2300      	movs	r3, #0
 800d164:	61fb      	str	r3, [r7, #28]
                    ctx->minRsaKeySz, RSA_MAX_SIZE / 8, keySz, RSA_KEY_SIZE_E);
            }
            break;
 800d166:	e039      	b.n	800d1dc <ProcessBufferCertPublicKey+0x138>
#endif /* !NO_RSA */
    #ifdef HAVE_ECC
        case ECDSAk:
            keyType = ecc_dsa_sa_algo;
 800d168:	2303      	movs	r3, #3
 800d16a:	76fb      	strb	r3, [r7, #27]
                keySz = cert->pkCurveSize;
            }
            else
        #endif
            {
                keySz = wc_ecc_get_curve_size_from_id(wc_ecc_get_oid(
 800d16c:	687b      	ldr	r3, [r7, #4]
 800d16e:	f8d3 3440 	ldr.w	r3, [r3, #1088]	@ 0x440
 800d172:	2200      	movs	r2, #0
 800d174:	2100      	movs	r1, #0
 800d176:	4618      	mov	r0, r3
 800d178:	f011 f89e 	bl	801e2b8 <wc_ecc_get_oid>
 800d17c:	4603      	mov	r3, r0
 800d17e:	4618      	mov	r0, r3
 800d180:	f00f fcd0 	bl	801cb24 <wc_ecc_get_curve_size_from_id>
 800d184:	4603      	mov	r3, r0
 800d186:	617b      	str	r3, [r7, #20]
                    cert->pkCurveOID, NULL, NULL));
            }

            if (checkKeySz) {
 800d188:	683b      	ldr	r3, [r7, #0]
 800d18a:	2b00      	cmp	r3, #0
 800d18c:	d028      	beq.n	800d1e0 <ProcessBufferCertPublicKey+0x13c>
                ret = CHECK_KEY_SZ(ssl ? ssl->options.minEccKeySz :
 800d18e:	68bb      	ldr	r3, [r7, #8]
 800d190:	2b00      	cmp	r3, #0
 800d192:	d005      	beq.n	800d1a0 <ProcessBufferCertPublicKey+0xfc>
 800d194:	68bb      	ldr	r3, [r7, #8]
 800d196:	f9b3 32f6 	ldrsh.w	r3, [r3, #758]	@ 0x2f6
 800d19a:	2b00      	cmp	r3, #0
 800d19c:	db17      	blt.n	800d1ce <ProcessBufferCertPublicKey+0x12a>
 800d19e:	e004      	b.n	800d1aa <ProcessBufferCertPublicKey+0x106>
 800d1a0:	68fb      	ldr	r3, [r7, #12]
 800d1a2:	f9b3 3068 	ldrsh.w	r3, [r3, #104]	@ 0x68
 800d1a6:	2b00      	cmp	r3, #0
 800d1a8:	db11      	blt.n	800d1ce <ProcessBufferCertPublicKey+0x12a>
 800d1aa:	68bb      	ldr	r3, [r7, #8]
 800d1ac:	2b00      	cmp	r3, #0
 800d1ae:	d004      	beq.n	800d1ba <ProcessBufferCertPublicKey+0x116>
 800d1b0:	68bb      	ldr	r3, [r7, #8]
 800d1b2:	f9b3 32f6 	ldrsh.w	r3, [r3, #758]	@ 0x2f6
 800d1b6:	461a      	mov	r2, r3
 800d1b8:	e003      	b.n	800d1c2 <ProcessBufferCertPublicKey+0x11e>
 800d1ba:	68fb      	ldr	r3, [r7, #12]
 800d1bc:	f9b3 3068 	ldrsh.w	r3, [r3, #104]	@ 0x68
 800d1c0:	461a      	mov	r2, r3
 800d1c2:	697b      	ldr	r3, [r7, #20]
 800d1c4:	429a      	cmp	r2, r3
 800d1c6:	dc02      	bgt.n	800d1ce <ProcessBufferCertPublicKey+0x12a>
 800d1c8:	697b      	ldr	r3, [r7, #20]
 800d1ca:	2b20      	cmp	r3, #32
 800d1cc:	dd01      	ble.n	800d1d2 <ProcessBufferCertPublicKey+0x12e>
 800d1ce:	4b11      	ldr	r3, [pc, #68]	@ (800d214 <ProcessBufferCertPublicKey+0x170>)
 800d1d0:	e000      	b.n	800d1d4 <ProcessBufferCertPublicKey+0x130>
 800d1d2:	2300      	movs	r3, #0
 800d1d4:	61fb      	str	r3, [r7, #28]
                     ctx->minEccKeySz, (MAX_ECC_BITS + 7) / 8, keySz,
                     ECC_KEY_SIZE_E);
            }
            break;
 800d1d6:	e003      	b.n	800d1e0 <ProcessBufferCertPublicKey+0x13c>
            break;
    #endif /* HAVE_DILITHIUM */

        default:
            WOLFSSL_MSG("No key size check done on public key in certificate");
            break;
 800d1d8:	bf00      	nop
 800d1da:	e002      	b.n	800d1e2 <ProcessBufferCertPublicKey+0x13e>
            break;
 800d1dc:	bf00      	nop
 800d1de:	e000      	b.n	800d1e2 <ProcessBufferCertPublicKey+0x13e>
            break;
 800d1e0:	bf00      	nop
    }

    /* Store the type and key size as there may not be a private key set. */
    if (ssl != NULL) {
 800d1e2:	68bb      	ldr	r3, [r7, #8]
 800d1e4:	2b00      	cmp	r3, #0
 800d1e6:	d008      	beq.n	800d1fa <ProcessBufferCertPublicKey+0x156>
        ssl->buffers.keyType = keyType;
 800d1e8:	68bb      	ldr	r3, [r7, #8]
 800d1ea:	7efa      	ldrb	r2, [r7, #27]
 800d1ec:	f883 2174 	strb.w	r2, [r3, #372]	@ 0x174
        ssl->buffers.keySz = keySz;
 800d1f0:	697a      	ldr	r2, [r7, #20]
 800d1f2:	68bb      	ldr	r3, [r7, #8]
 800d1f4:	f8c3 2178 	str.w	r2, [r3, #376]	@ 0x178
 800d1f8:	e006      	b.n	800d208 <ProcessBufferCertPublicKey+0x164>
    }
    else {
        ctx->privateKeyType = keyType;
 800d1fa:	68fb      	ldr	r3, [r7, #12]
 800d1fc:	7efa      	ldrb	r2, [r7, #27]
 800d1fe:	f883 2044 	strb.w	r2, [r3, #68]	@ 0x44
        ctx->privateKeySz = keySz;
 800d202:	697a      	ldr	r2, [r7, #20]
 800d204:	68fb      	ldr	r3, [r7, #12]
 800d206:	649a      	str	r2, [r3, #72]	@ 0x48
    }

    return ret;
 800d208:	69fb      	ldr	r3, [r7, #28]
}
 800d20a:	4618      	mov	r0, r3
 800d20c:	3720      	adds	r7, #32
 800d20e:	46bd      	mov	sp, r7
 800d210:	bd80      	pop	{r7, pc}
 800d212:	bf00      	nop
 800d214:	fffffe66 	.word	0xfffffe66

0800d218 <ProcessBufferCert>:
 * @return  0 on success.
 * @return  MEMORY_E when dynamic memory allocation fails.
 * @return  WOLFSSL_BAD_FILE when decoding certificate fails.
 */
static int ProcessBufferCert(WOLFSSL_CTX* ctx, WOLFSSL* ssl, DerBuffer* der)
{
 800d218:	b580      	push	{r7, lr}
 800d21a:	b08c      	sub	sp, #48	@ 0x30
 800d21c:	af02      	add	r7, sp, #8
 800d21e:	60f8      	str	r0, [r7, #12]
 800d220:	60b9      	str	r1, [r7, #8]
 800d222:	607a      	str	r2, [r7, #4]
    int ret = 0;
 800d224:	2300      	movs	r3, #0
 800d226:	627b      	str	r3, [r7, #36]	@ 0x24
    void* heap = WOLFSSL_HEAP(ctx, ssl);
 800d228:	68fb      	ldr	r3, [r7, #12]
 800d22a:	2b00      	cmp	r3, #0
 800d22c:	d002      	beq.n	800d234 <ProcessBufferCert+0x1c>
 800d22e:	68fb      	ldr	r3, [r7, #12]
 800d230:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800d232:	e007      	b.n	800d244 <ProcessBufferCert+0x2c>
 800d234:	68bb      	ldr	r3, [r7, #8]
 800d236:	2b00      	cmp	r3, #0
 800d238:	d003      	beq.n	800d242 <ProcessBufferCert+0x2a>
 800d23a:	68bb      	ldr	r3, [r7, #8]
 800d23c:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800d240:	e000      	b.n	800d244 <ProcessBufferCert+0x2c>
 800d242:	2300      	movs	r3, #0
 800d244:	61fb      	str	r3, [r7, #28]
    DecodedCert  cert[1];
#endif

#ifdef WOLFSSL_SMALL_STACK
    /* Allocate memory for certificate to be decoded into. */
    cert = (DecodedCert*)XMALLOC(sizeof(DecodedCert), heap, DYNAMIC_TYPE_DCERT);
 800d246:	f44f 6097 	mov.w	r0, #1208	@ 0x4b8
 800d24a:	f011 fc1d 	bl	801ea88 <wolfSSL_Malloc>
 800d24e:	61b8      	str	r0, [r7, #24]
    if (cert == NULL) {
 800d250:	69bb      	ldr	r3, [r7, #24]
 800d252:	2b00      	cmp	r3, #0
 800d254:	d102      	bne.n	800d25c <ProcessBufferCert+0x44>
        ret = MEMORY_E;
 800d256:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800d25a:	627b      	str	r3, [r7, #36]	@ 0x24
    }

    if (ret == 0)
 800d25c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800d25e:	2b00      	cmp	r3, #0
 800d260:	d144      	bne.n	800d2ec <ProcessBufferCert+0xd4>
#endif
    {
        /* Get device id from SSL context or SSL object. */
        int devId = wolfSSL_CTX_GetDevId(ctx, ssl);
 800d262:	68b9      	ldr	r1, [r7, #8]
 800d264:	68f8      	ldr	r0, [r7, #12]
 800d266:	f7fe ffa2 	bl	800c1ae <wolfSSL_CTX_GetDevId>
 800d26a:	6178      	str	r0, [r7, #20]

        WOLFSSL_MSG("Checking cert signature type");
        /* Initialize certificate object. */
        InitDecodedCert_ex(cert, der->buffer, der->length, heap, devId);
 800d26c:	687b      	ldr	r3, [r7, #4]
 800d26e:	6819      	ldr	r1, [r3, #0]
 800d270:	687b      	ldr	r3, [r7, #4]
 800d272:	689a      	ldr	r2, [r3, #8]
 800d274:	697b      	ldr	r3, [r7, #20]
 800d276:	9300      	str	r3, [sp, #0]
 800d278:	69fb      	ldr	r3, [r7, #28]
 800d27a:	69b8      	ldr	r0, [r7, #24]
 800d27c:	f007 ff45 	bl	801510a <InitDecodedCert_ex>

        /* Decode up to and including public key. */
        if (DecodeToKey(cert, 0) < 0) {
 800d280:	2100      	movs	r1, #0
 800d282:	69b8      	ldr	r0, [r7, #24]
 800d284:	f008 fddc 	bl	8015e40 <DecodeToKey>
 800d288:	4603      	mov	r3, r0
 800d28a:	2b00      	cmp	r3, #0
 800d28c:	da02      	bge.n	800d294 <ProcessBufferCert+0x7c>
            WOLFSSL_MSG("Decode to key failed");
            ret = WOLFSSL_BAD_FILE;
 800d28e:	f46f 73e7 	mvn.w	r3, #462	@ 0x1ce
 800d292:	627b      	str	r3, [r7, #36]	@ 0x24
        }
        if (ret == 0) {
 800d294:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800d296:	2b00      	cmp	r3, #0
 800d298:	d128      	bne.n	800d2ec <ProcessBufferCert+0xd4>
            int checkKeySz = 1;
 800d29a:	2301      	movs	r3, #1
 800d29c:	623b      	str	r3, [r7, #32]
            /* Store whether the crtificate is a raw public key. */
            rpkState->isRPKLoaded = cert->isRPK;
        #endif /* HAVE_RPK */

            /* Set which private key algorithm we have. */
            ProcessBufferCertSetHave(ctx, ssl, cert);
 800d29e:	69ba      	ldr	r2, [r7, #24]
 800d2a0:	68b9      	ldr	r1, [r7, #8]
 800d2a2:	68f8      	ldr	r0, [r7, #12]
 800d2a4:	f7ff fe96 	bl	800cfd4 <ProcessBufferCertSetHave>

            /* Don't check if verification is disabled for SSL. */
            if ((ssl != NULL) && ssl->options.verifyNone) {
 800d2a8:	68bb      	ldr	r3, [r7, #8]
 800d2aa:	2b00      	cmp	r3, #0
 800d2ac:	d00a      	beq.n	800d2c4 <ProcessBufferCert+0xac>
 800d2ae:	68bb      	ldr	r3, [r7, #8]
 800d2b0:	f893 32d1 	ldrb.w	r3, [r3, #721]	@ 0x2d1
 800d2b4:	f003 0308 	and.w	r3, r3, #8
 800d2b8:	b2db      	uxtb	r3, r3
 800d2ba:	2b00      	cmp	r3, #0
 800d2bc:	d002      	beq.n	800d2c4 <ProcessBufferCert+0xac>
                checkKeySz = 0;
 800d2be:	2300      	movs	r3, #0
 800d2c0:	623b      	str	r3, [r7, #32]
 800d2c2:	e00c      	b.n	800d2de <ProcessBufferCert+0xc6>
            }
            /* Don't check if no SSL object verification is disabled for SSL
             * context. */
            else if ((ssl == NULL) && ctx->verifyNone) {
 800d2c4:	68bb      	ldr	r3, [r7, #8]
 800d2c6:	2b00      	cmp	r3, #0
 800d2c8:	d109      	bne.n	800d2de <ProcessBufferCert+0xc6>
 800d2ca:	68fb      	ldr	r3, [r7, #12]
 800d2cc:	f893 305d 	ldrb.w	r3, [r3, #93]	@ 0x5d
 800d2d0:	f003 0302 	and.w	r3, r3, #2
 800d2d4:	b2db      	uxtb	r3, r3
 800d2d6:	2b00      	cmp	r3, #0
 800d2d8:	d001      	beq.n	800d2de <ProcessBufferCert+0xc6>
                checkKeySz = 0;
 800d2da:	2300      	movs	r3, #0
 800d2dc:	623b      	str	r3, [r7, #32]
            }

            /* Check public key size. */
            ret = ProcessBufferCertPublicKey(ctx, ssl, cert, checkKeySz);
 800d2de:	6a3b      	ldr	r3, [r7, #32]
 800d2e0:	69ba      	ldr	r2, [r7, #24]
 800d2e2:	68b9      	ldr	r1, [r7, #8]
 800d2e4:	68f8      	ldr	r0, [r7, #12]
 800d2e6:	f7ff fedd 	bl	800d0a4 <ProcessBufferCertPublicKey>
 800d2ea:	6278      	str	r0, [r7, #36]	@ 0x24
        #endif
        }
    }

    /* Dispose of dynamic memory in certificate object. */
    FreeDecodedCert(cert);
 800d2ec:	69b8      	ldr	r0, [r7, #24]
 800d2ee:	f007 ffd1 	bl	8015294 <FreeDecodedCert>
#ifdef WOLFSSL_SMALL_STACK
    /* Dispose of certificate object. */
    XFREE(cert, heap, DYNAMIC_TYPE_DCERT);
 800d2f2:	69bb      	ldr	r3, [r7, #24]
 800d2f4:	613b      	str	r3, [r7, #16]
 800d2f6:	693b      	ldr	r3, [r7, #16]
 800d2f8:	2b00      	cmp	r3, #0
 800d2fa:	d002      	beq.n	800d302 <ProcessBufferCert+0xea>
 800d2fc:	6938      	ldr	r0, [r7, #16]
 800d2fe:	f011 fbdf 	bl	801eac0 <wolfSSL_Free>
#endif
    return ret;
 800d302:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 800d304:	4618      	mov	r0, r3
 800d306:	3728      	adds	r7, #40	@ 0x28
 800d308:	46bd      	mov	sp, r7
 800d30a:	bd80      	pop	{r7, pc}

0800d30c <ProcessBufferCertHandleDer>:
 * @return  BAD_FUNC_ARG when type is CA_TYPE and ctx is NULL.
 * @return  WOLFSSL_BAD_CERTTYPE when data type is not supported.
 */
static int ProcessBufferCertHandleDer(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    DerBuffer* der, int type, int verify)
{
 800d30c:	b580      	push	{r7, lr}
 800d30e:	b086      	sub	sp, #24
 800d310:	af00      	add	r7, sp, #0
 800d312:	60f8      	str	r0, [r7, #12]
 800d314:	60b9      	str	r1, [r7, #8]
 800d316:	607a      	str	r2, [r7, #4]
 800d318:	603b      	str	r3, [r7, #0]
    int ret = 0;
 800d31a:	2300      	movs	r3, #0
 800d31c:	617b      	str	r3, [r7, #20]

    /* CA certificate to verify with. */
    if (type == CA_TYPE) {
 800d31e:	683b      	ldr	r3, [r7, #0]
 800d320:	2b06      	cmp	r3, #6
 800d322:	d10d      	bne.n	800d340 <ProcessBufferCertHandleDer+0x34>
        /* verify CA unless user set to no verify */
        ret = AddCA(ctx->cm, &der, WOLFSSL_USER_CA, verify);
 800d324:	68fb      	ldr	r3, [r7, #12]
 800d326:	6d18      	ldr	r0, [r3, #80]	@ 0x50
 800d328:	1d39      	adds	r1, r7, #4
 800d32a:	6a3b      	ldr	r3, [r7, #32]
 800d32c:	2201      	movs	r2, #1
 800d32e:	f7ff f8d9 	bl	800c4e4 <AddCA>
 800d332:	6178      	str	r0, [r7, #20]
        if (ret == 1) {
 800d334:	697b      	ldr	r3, [r7, #20]
 800d336:	2b01      	cmp	r3, #1
 800d338:	d12f      	bne.n	800d39a <ProcessBufferCertHandleDer+0x8e>
            ret = 0;
 800d33a:	2300      	movs	r3, #0
 800d33c:	617b      	str	r3, [r7, #20]
 800d33e:	e02c      	b.n	800d39a <ProcessBufferCertHandleDer+0x8e>
            WOLFSSL_MSG("Error adding trusted peer");
        }
    }
#endif /* WOLFSSL_TRUST_PEER_CERT */
    /* Leaf certificate - our certificate. */
    else if (type == CERT_TYPE) {
 800d340:	683b      	ldr	r3, [r7, #0]
 800d342:	2b00      	cmp	r3, #0
 800d344:	d122      	bne.n	800d38c <ProcessBufferCertHandleDer+0x80>
        if (ssl != NULL) {
 800d346:	68bb      	ldr	r3, [r7, #8]
 800d348:	2b00      	cmp	r3, #0
 800d34a:	d013      	beq.n	800d374 <ProcessBufferCertHandleDer+0x68>
            /* Free previous certificate if we own it. */
            if (ssl->buffers.weOwnCert) {
 800d34c:	68bb      	ldr	r3, [r7, #8]
 800d34e:	f893 3144 	ldrb.w	r3, [r3, #324]	@ 0x144
 800d352:	2b00      	cmp	r3, #0
 800d354:	d005      	beq.n	800d362 <ProcessBufferCertHandleDer+0x56>
                FreeDer(&ssl->buffers.certificate);
 800d356:	68bb      	ldr	r3, [r7, #8]
 800d358:	f503 73b6 	add.w	r3, r3, #364	@ 0x16c
 800d35c:	4618      	mov	r0, r3
 800d35e:	f00b fe0d 	bl	8018f7c <FreeDer>
                wolfSSL_X509_free(ssl->ourCert);
                ssl->ourCert = NULL;
            #endif
            }
            /* Store certificate as ours. */
            ssl->buffers.certificate = der;
 800d362:	687a      	ldr	r2, [r7, #4]
 800d364:	68bb      	ldr	r3, [r7, #8]
 800d366:	f8c3 216c 	str.w	r2, [r3, #364]	@ 0x16c
        #ifdef KEEP_OUR_CERT
            ssl->keepCert = 1; /* hold cert for ssl lifetime */
        #endif
            /* We have to free the certificate buffer. */
            ssl->buffers.weOwnCert = 1;
 800d36a:	68bb      	ldr	r3, [r7, #8]
 800d36c:	2201      	movs	r2, #1
 800d36e:	f883 2144 	strb.w	r2, [r3, #324]	@ 0x144
 800d372:	e012      	b.n	800d39a <ProcessBufferCertHandleDer+0x8e>
            /* ourCert is created on demand. */
        }
        else if (ctx != NULL) {
 800d374:	68fb      	ldr	r3, [r7, #12]
 800d376:	2b00      	cmp	r3, #0
 800d378:	d00f      	beq.n	800d39a <ProcessBufferCertHandleDer+0x8e>
            /* Free previous certificate. */
            FreeDer(&ctx->certificate); /* Make sure previous is free'd */
 800d37a:	68fb      	ldr	r3, [r7, #12]
 800d37c:	3320      	adds	r3, #32
 800d37e:	4618      	mov	r0, r3
 800d380:	f00b fdfc 	bl	8018f7c <FreeDer>
                wolfSSL_X509_free(ctx->ourCert);
            }
            ctx->ourCert = NULL;
        #endif
            /* Store certificate as ours. */
            ctx->certificate = der;
 800d384:	687a      	ldr	r2, [r7, #4]
 800d386:	68fb      	ldr	r3, [r7, #12]
 800d388:	621a      	str	r2, [r3, #32]
 800d38a:	e006      	b.n	800d39a <ProcessBufferCertHandleDer+0x8e>
            /* ourCert is created on demand. */
        }
    }
    else {
        /* Dispose of DER buffer. */
        FreeDer(&der);
 800d38c:	1d3b      	adds	r3, r7, #4
 800d38e:	4618      	mov	r0, r3
 800d390:	f00b fdf4 	bl	8018f7c <FreeDer>
        /* Not a certificate type supported. */
        ret = WOLFSSL_BAD_CERTTYPE;
 800d394:	f46f 73e5 	mvn.w	r3, #458	@ 0x1ca
 800d398:	617b      	str	r3, [r7, #20]
    }

    return ret;
 800d39a:	697b      	ldr	r3, [r7, #20]
}
 800d39c:	4618      	mov	r0, r3
 800d39e:	3718      	adds	r7, #24
 800d3a0:	46bd      	mov	sp, r7
 800d3a2:	bd80      	pop	{r7, pc}

0800d3a4 <ProcessBufferCertTypes>:
 * @return  WOLFSSL_FATAL_ERROR on failure.
 */
static int ProcessBufferCertTypes(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    const unsigned char* buff, long sz, DerBuffer* der, int format, int type,
    int verify)
{
 800d3a4:	b580      	push	{r7, lr}
 800d3a6:	b088      	sub	sp, #32
 800d3a8:	af02      	add	r7, sp, #8
 800d3aa:	60f8      	str	r0, [r7, #12]
 800d3ac:	60b9      	str	r1, [r7, #8]
 800d3ae:	607a      	str	r2, [r7, #4]
 800d3b0:	603b      	str	r3, [r7, #0]

    (void)buff;
    (void)sz;
    (void)format;

    ret = ProcessBufferCertHandleDer(ctx, ssl, der, type, verify);
 800d3b2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800d3b4:	9300      	str	r3, [sp, #0]
 800d3b6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d3b8:	6a3a      	ldr	r2, [r7, #32]
 800d3ba:	68b9      	ldr	r1, [r7, #8]
 800d3bc:	68f8      	ldr	r0, [r7, #12]
 800d3be:	f7ff ffa5 	bl	800d30c <ProcessBufferCertHandleDer>
 800d3c2:	6178      	str	r0, [r7, #20]
    if ((ret == 0) && (type == CERT_TYPE)) {
 800d3c4:	697b      	ldr	r3, [r7, #20]
 800d3c6:	2b00      	cmp	r3, #0
 800d3c8:	d108      	bne.n	800d3dc <ProcessBufferCertTypes+0x38>
 800d3ca:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d3cc:	2b00      	cmp	r3, #0
 800d3ce:	d105      	bne.n	800d3dc <ProcessBufferCertTypes+0x38>
        /* Process leaf certificate. */
        ret = ProcessBufferCert(ctx, ssl, der);
 800d3d0:	6a3a      	ldr	r2, [r7, #32]
 800d3d2:	68b9      	ldr	r1, [r7, #8]
 800d3d4:	68f8      	ldr	r0, [r7, #12]
 800d3d6:	f7ff ff1f 	bl	800d218 <ProcessBufferCert>
 800d3da:	6178      	str	r0, [r7, #20]
    }
#if !defined(NO_WOLFSSL_CM_VERIFY) && (!defined(NO_WOLFSSL_CLIENT) || \
    !defined(WOLFSSL_NO_CLIENT_AUTH))
    /* Hand bad CA or user certificate to callback. */
    if ((ret < 0) && ((type == CA_TYPE) || (type == CERT_TYPE))) {
 800d3dc:	697b      	ldr	r3, [r7, #20]
 800d3de:	2b00      	cmp	r3, #0
 800d3e0:	da26      	bge.n	800d430 <ProcessBufferCertTypes+0x8c>
 800d3e2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d3e4:	2b06      	cmp	r3, #6
 800d3e6:	d002      	beq.n	800d3ee <ProcessBufferCertTypes+0x4a>
 800d3e8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d3ea:	2b00      	cmp	r3, #0
 800d3ec:	d120      	bne.n	800d430 <ProcessBufferCertTypes+0x8c>
        /* Check for verification callback that may override error. */
        if ((ctx != NULL) && (ctx->cm != NULL) &&
 800d3ee:	68fb      	ldr	r3, [r7, #12]
 800d3f0:	2b00      	cmp	r3, #0
 800d3f2:	d01d      	beq.n	800d430 <ProcessBufferCertTypes+0x8c>
 800d3f4:	68fb      	ldr	r3, [r7, #12]
 800d3f6:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800d3f8:	2b00      	cmp	r3, #0
 800d3fa:	d019      	beq.n	800d430 <ProcessBufferCertTypes+0x8c>
                (ctx->cm->verifyCallback != NULL)) {
 800d3fc:	68fb      	ldr	r3, [r7, #12]
 800d3fe:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800d400:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
        if ((ctx != NULL) && (ctx->cm != NULL) &&
 800d402:	2b00      	cmp	r3, #0
 800d404:	d014      	beq.n	800d430 <ProcessBufferCertTypes+0x8c>
            /* Verify and use callback. */
            ret = CM_VerifyBuffer_ex(ctx->cm, buff, sz, format, ret);
 800d406:	68fb      	ldr	r3, [r7, #12]
 800d408:	6d18      	ldr	r0, [r3, #80]	@ 0x50
 800d40a:	697b      	ldr	r3, [r7, #20]
 800d40c:	9300      	str	r3, [sp, #0]
 800d40e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800d410:	683a      	ldr	r2, [r7, #0]
 800d412:	6879      	ldr	r1, [r7, #4]
 800d414:	f7fe f913 	bl	800b63e <CM_VerifyBuffer_ex>
 800d418:	6178      	str	r0, [r7, #20]
            /* Convert error. */
            if (ret == 0) {
 800d41a:	697b      	ldr	r3, [r7, #20]
 800d41c:	2b00      	cmp	r3, #0
 800d41e:	d102      	bne.n	800d426 <ProcessBufferCertTypes+0x82>
                ret = WOLFSSL_FATAL_ERROR;
 800d420:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800d424:	617b      	str	r3, [r7, #20]
            }
            if (ret == 1) {
 800d426:	697b      	ldr	r3, [r7, #20]
 800d428:	2b01      	cmp	r3, #1
 800d42a:	d101      	bne.n	800d430 <ProcessBufferCertTypes+0x8c>
                ret = 0;
 800d42c:	2300      	movs	r3, #0
 800d42e:	617b      	str	r3, [r7, #20]
            }
        }
    }
#endif /* NO_WOLFSSL_CM_VERIFY */

    return ret;
 800d430:	697b      	ldr	r3, [r7, #20]
}
 800d432:	4618      	mov	r0, r3
 800d434:	3718      	adds	r7, #24
 800d436:	46bd      	mov	sp, r7
 800d438:	bd80      	pop	{r7, pc}

0800d43a <ProcessBufferResetSuites>:
 * @param [in]      type    Type of certificate.
 * @return  0 on success.
 * @return  WOLFSSL_FATAL_ERROR when allocation fails.
 */
static int ProcessBufferResetSuites(WOLFSSL_CTX* ctx, WOLFSSL* ssl, int type)
{
 800d43a:	b5f0      	push	{r4, r5, r6, r7, lr}
 800d43c:	b095      	sub	sp, #84	@ 0x54
 800d43e:	af0c      	add	r7, sp, #48	@ 0x30
 800d440:	6178      	str	r0, [r7, #20]
 800d442:	6139      	str	r1, [r7, #16]
 800d444:	60fa      	str	r2, [r7, #12]
    int ret = 0;
 800d446:	2300      	movs	r3, #0
 800d448:	61fb      	str	r3, [r7, #28]

    /* Reset suites of SSL object. */
    if (ssl != NULL) {
 800d44a:	693b      	ldr	r3, [r7, #16]
 800d44c:	2b00      	cmp	r3, #0
 800d44e:	d05f      	beq.n	800d510 <ProcessBufferResetSuites+0xd6>
        if (ssl->options.side == WOLFSSL_SERVER_END) {
 800d450:	693b      	ldr	r3, [r7, #16]
 800d452:	f893 32d1 	ldrb.w	r3, [r3, #721]	@ 0x2d1
 800d456:	f003 0303 	and.w	r3, r3, #3
 800d45a:	b2db      	uxtb	r3, r3
 800d45c:	2b00      	cmp	r3, #0
 800d45e:	f040 80ad 	bne.w	800d5bc <ProcessBufferResetSuites+0x182>
            /* Allocate memory for suites. */
            if (AllocateSuites(ssl) != 0) {
 800d462:	6938      	ldr	r0, [r7, #16]
 800d464:	f7fb fdc0 	bl	8008fe8 <AllocateSuites>
 800d468:	4603      	mov	r3, r0
 800d46a:	2b00      	cmp	r3, #0
 800d46c:	d003      	beq.n	800d476 <ProcessBufferResetSuites+0x3c>
                ret = WOLFSSL_FATAL_ERROR;
 800d46e:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800d472:	61fb      	str	r3, [r7, #28]
 800d474:	e0a2      	b.n	800d5bc <ProcessBufferResetSuites+0x182>
            }
            else {
                /* Determine cipher suites based on what we have. */
                InitSuites(ssl->suites, ssl->version, ssl->buffers.keySz,
 800d476:	693b      	ldr	r3, [r7, #16]
 800d478:	6858      	ldr	r0, [r3, #4]
 800d47a:	693b      	ldr	r3, [r7, #16]
 800d47c:	f8d3 2178 	ldr.w	r2, [r3, #376]	@ 0x178
                    WOLFSSL_HAVE_RSA, SSL_HAVE_PSK(ssl), ssl->options.haveDH,
 800d480:	693b      	ldr	r3, [r7, #16]
 800d482:	f893 32d3 	ldrb.w	r3, [r3, #723]	@ 0x2d3
 800d486:	f3c3 1340 	ubfx	r3, r3, #5, #1
 800d48a:	b2db      	uxtb	r3, r3
                InitSuites(ssl->suites, ssl->version, ssl->buffers.keySz,
 800d48c:	461c      	mov	r4, r3
                    ssl->options.haveECDSAsig, ssl->options.haveECC, TRUE,
 800d48e:	693b      	ldr	r3, [r7, #16]
 800d490:	f893 32d3 	ldrb.w	r3, [r3, #723]	@ 0x2d3
 800d494:	f3c3 1380 	ubfx	r3, r3, #6, #1
 800d498:	b2db      	uxtb	r3, r3
                InitSuites(ssl->suites, ssl->version, ssl->buffers.keySz,
 800d49a:	461d      	mov	r5, r3
                    ssl->options.haveECDSAsig, ssl->options.haveECC, TRUE,
 800d49c:	693b      	ldr	r3, [r7, #16]
 800d49e:	f893 32d3 	ldrb.w	r3, [r3, #723]	@ 0x2d3
 800d4a2:	f3c3 1300 	ubfx	r3, r3, #4, #1
 800d4a6:	b2db      	uxtb	r3, r3
                InitSuites(ssl->suites, ssl->version, ssl->buffers.keySz,
 800d4a8:	461e      	mov	r6, r3
                    ssl->options.haveStaticECC,
 800d4aa:	693b      	ldr	r3, [r7, #16]
 800d4ac:	f893 32d3 	ldrb.w	r3, [r3, #723]	@ 0x2d3
 800d4b0:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 800d4b4:	b2db      	uxtb	r3, r3
                InitSuites(ssl->suites, ssl->version, ssl->buffers.keySz,
 800d4b6:	60bb      	str	r3, [r7, #8]
                    ssl->options.useAnon, TRUE,
 800d4b8:	693b      	ldr	r3, [r7, #16]
 800d4ba:	f893 32d5 	ldrb.w	r3, [r3, #725]	@ 0x2d5
 800d4be:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 800d4c2:	b2db      	uxtb	r3, r3
                InitSuites(ssl->suites, ssl->version, ssl->buffers.keySz,
 800d4c4:	607b      	str	r3, [r7, #4]
                    TRUE, TRUE, TRUE, ssl->options.side);
 800d4c6:	693b      	ldr	r3, [r7, #16]
 800d4c8:	f893 32d1 	ldrb.w	r3, [r3, #721]	@ 0x2d1
 800d4cc:	f3c3 0301 	ubfx	r3, r3, #0, #2
 800d4d0:	b2db      	uxtb	r3, r3
                InitSuites(ssl->suites, ssl->version, ssl->buffers.keySz,
 800d4d2:	4619      	mov	r1, r3
 800d4d4:	693b      	ldr	r3, [r7, #16]
 800d4d6:	910b      	str	r1, [sp, #44]	@ 0x2c
 800d4d8:	2101      	movs	r1, #1
 800d4da:	910a      	str	r1, [sp, #40]	@ 0x28
 800d4dc:	2101      	movs	r1, #1
 800d4de:	9109      	str	r1, [sp, #36]	@ 0x24
 800d4e0:	2101      	movs	r1, #1
 800d4e2:	9108      	str	r1, [sp, #32]
 800d4e4:	2101      	movs	r1, #1
 800d4e6:	9107      	str	r1, [sp, #28]
 800d4e8:	6879      	ldr	r1, [r7, #4]
 800d4ea:	9106      	str	r1, [sp, #24]
 800d4ec:	68b9      	ldr	r1, [r7, #8]
 800d4ee:	9105      	str	r1, [sp, #20]
 800d4f0:	2101      	movs	r1, #1
 800d4f2:	9104      	str	r1, [sp, #16]
 800d4f4:	9603      	str	r6, [sp, #12]
 800d4f6:	9502      	str	r5, [sp, #8]
 800d4f8:	9401      	str	r4, [sp, #4]
 800d4fa:	2100      	movs	r1, #0
 800d4fc:	9100      	str	r1, [sp, #0]
 800d4fe:	f8b3 31da 	ldrh.w	r3, [r3, #474]	@ 0x1da
 800d502:	2100      	movs	r1, #0
 800d504:	f363 010f 	bfi	r1, r3, #0, #16
 800d508:	2301      	movs	r3, #1
 800d50a:	f7fb fda4 	bl	8009056 <InitSuites>
 800d50e:	e055      	b.n	800d5bc <ProcessBufferResetSuites+0x182>
            }
        }
    }
    /* Reset suites of SSL context object. */
    else if ((type == CERT_TYPE) && (ctx->method->side == WOLFSSL_SERVER_END)) {
 800d510:	68fb      	ldr	r3, [r7, #12]
 800d512:	2b00      	cmp	r3, #0
 800d514:	d152      	bne.n	800d5bc <ProcessBufferResetSuites+0x182>
 800d516:	697b      	ldr	r3, [r7, #20]
 800d518:	681b      	ldr	r3, [r3, #0]
 800d51a:	789b      	ldrb	r3, [r3, #2]
 800d51c:	2b00      	cmp	r3, #0
 800d51e:	d14d      	bne.n	800d5bc <ProcessBufferResetSuites+0x182>
        /* Allocate memory for suites. */
        if (AllocateCtxSuites(ctx) != 0) {
 800d520:	6978      	ldr	r0, [r7, #20]
 800d522:	f7fb fd3e 	bl	8008fa2 <AllocateCtxSuites>
 800d526:	4603      	mov	r3, r0
 800d528:	2b00      	cmp	r3, #0
 800d52a:	d003      	beq.n	800d534 <ProcessBufferResetSuites+0xfa>
            ret = WOLFSSL_FATAL_ERROR;
 800d52c:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800d530:	61fb      	str	r3, [r7, #28]
 800d532:	e043      	b.n	800d5bc <ProcessBufferResetSuites+0x182>
        }
        else {
            /* Determine cipher suites based on what we have. */
            InitSuites(ctx->suites, ctx->method->version, ctx->privateKeySz,
 800d534:	697b      	ldr	r3, [r7, #20]
 800d536:	6d58      	ldr	r0, [r3, #84]	@ 0x54
 800d538:	697b      	ldr	r3, [r7, #20]
 800d53a:	681b      	ldr	r3, [r3, #0]
 800d53c:	697a      	ldr	r2, [r7, #20]
 800d53e:	6c94      	ldr	r4, [r2, #72]	@ 0x48
                WOLFSSL_HAVE_RSA, CTX_HAVE_PSK(ctx), ctx->haveDH,
 800d540:	697a      	ldr	r2, [r7, #20]
 800d542:	f892 205e 	ldrb.w	r2, [r2, #94]	@ 0x5e
 800d546:	f3c2 1200 	ubfx	r2, r2, #4, #1
 800d54a:	b2d2      	uxtb	r2, r2
            InitSuites(ctx->suites, ctx->method->version, ctx->privateKeySz,
 800d54c:	4611      	mov	r1, r2
                ctx->haveECDSAsig, ctx->haveECC, TRUE, ctx->haveStaticECC,
 800d54e:	697a      	ldr	r2, [r7, #20]
 800d550:	f892 205e 	ldrb.w	r2, [r2, #94]	@ 0x5e
 800d554:	f3c2 1240 	ubfx	r2, r2, #5, #1
 800d558:	b2d2      	uxtb	r2, r2
            InitSuites(ctx->suites, ctx->method->version, ctx->privateKeySz,
 800d55a:	4615      	mov	r5, r2
                ctx->haveECDSAsig, ctx->haveECC, TRUE, ctx->haveStaticECC,
 800d55c:	697a      	ldr	r2, [r7, #20]
 800d55e:	f892 205e 	ldrb.w	r2, [r2, #94]	@ 0x5e
 800d562:	f3c2 02c0 	ubfx	r2, r2, #3, #1
 800d566:	b2d2      	uxtb	r2, r2
            InitSuites(ctx->suites, ctx->method->version, ctx->privateKeySz,
 800d568:	4616      	mov	r6, r2
                ctx->haveECDSAsig, ctx->haveECC, TRUE, ctx->haveStaticECC,
 800d56a:	697a      	ldr	r2, [r7, #20]
 800d56c:	f892 205f 	ldrb.w	r2, [r2, #95]	@ 0x5f
 800d570:	f3c2 0200 	ubfx	r2, r2, #0, #1
 800d574:	b2d2      	uxtb	r2, r2
            InitSuites(ctx->suites, ctx->method->version, ctx->privateKeySz,
 800d576:	60ba      	str	r2, [r7, #8]
                CTX_USE_ANON(ctx),
                TRUE, TRUE, TRUE, TRUE, ctx->method->side);
 800d578:	697a      	ldr	r2, [r7, #20]
 800d57a:	6812      	ldr	r2, [r2, #0]
 800d57c:	7892      	ldrb	r2, [r2, #2]
            InitSuites(ctx->suites, ctx->method->version, ctx->privateKeySz,
 800d57e:	920b      	str	r2, [sp, #44]	@ 0x2c
 800d580:	2201      	movs	r2, #1
 800d582:	920a      	str	r2, [sp, #40]	@ 0x28
 800d584:	2201      	movs	r2, #1
 800d586:	9209      	str	r2, [sp, #36]	@ 0x24
 800d588:	2201      	movs	r2, #1
 800d58a:	9208      	str	r2, [sp, #32]
 800d58c:	2201      	movs	r2, #1
 800d58e:	9207      	str	r2, [sp, #28]
 800d590:	2200      	movs	r2, #0
 800d592:	9206      	str	r2, [sp, #24]
 800d594:	68ba      	ldr	r2, [r7, #8]
 800d596:	9205      	str	r2, [sp, #20]
 800d598:	2201      	movs	r2, #1
 800d59a:	9204      	str	r2, [sp, #16]
 800d59c:	9603      	str	r6, [sp, #12]
 800d59e:	9502      	str	r5, [sp, #8]
 800d5a0:	9101      	str	r1, [sp, #4]
 800d5a2:	2200      	movs	r2, #0
 800d5a4:	9200      	str	r2, [sp, #0]
 800d5a6:	781a      	ldrb	r2, [r3, #0]
 800d5a8:	785b      	ldrb	r3, [r3, #1]
 800d5aa:	021b      	lsls	r3, r3, #8
 800d5ac:	4313      	orrs	r3, r2
 800d5ae:	2100      	movs	r1, #0
 800d5b0:	f363 010f 	bfi	r1, r3, #0, #16
 800d5b4:	2301      	movs	r3, #1
 800d5b6:	4622      	mov	r2, r4
 800d5b8:	f7fb fd4d 	bl	8009056 <InitSuites>
        }
    }

    return ret;
 800d5bc:	69fb      	ldr	r3, [r7, #28]
}
 800d5be:	4618      	mov	r0, r3
 800d5c0:	3724      	adds	r7, #36	@ 0x24
 800d5c2:	46bd      	mov	sp, r7
 800d5c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

0800d5c8 <ProcessBuffer>:
 * @return  1 on success.
 * @return  Less than 1 on failure.
 */
int ProcessBuffer(WOLFSSL_CTX* ctx, const unsigned char* buff, long sz,
    int format, int type, WOLFSSL* ssl, long* used, int userChain, int verify)
{
 800d5c8:	b580      	push	{r7, lr}
 800d5ca:	b094      	sub	sp, #80	@ 0x50
 800d5cc:	af06      	add	r7, sp, #24
 800d5ce:	60f8      	str	r0, [r7, #12]
 800d5d0:	60b9      	str	r1, [r7, #8]
 800d5d2:	607a      	str	r2, [r7, #4]
 800d5d4:	603b      	str	r3, [r7, #0]
    DerBuffer*    der = NULL;
 800d5d6:	2300      	movs	r3, #0
 800d5d8:	61bb      	str	r3, [r7, #24]
    int           ret = 0;
 800d5da:	2300      	movs	r3, #0
 800d5dc:	637b      	str	r3, [r7, #52]	@ 0x34
    void*         heap = WOLFSSL_HEAP(ctx, ssl);
 800d5de:	68fb      	ldr	r3, [r7, #12]
 800d5e0:	2b00      	cmp	r3, #0
 800d5e2:	d002      	beq.n	800d5ea <ProcessBuffer+0x22>
 800d5e4:	68fb      	ldr	r3, [r7, #12]
 800d5e6:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800d5e8:	e007      	b.n	800d5fa <ProcessBuffer+0x32>
 800d5ea:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800d5ec:	2b00      	cmp	r3, #0
 800d5ee:	d003      	beq.n	800d5f8 <ProcessBuffer+0x30>
 800d5f0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800d5f2:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800d5f6:	e000      	b.n	800d5fa <ProcessBuffer+0x32>
 800d5f8:	2300      	movs	r3, #0
 800d5fa:	62fb      	str	r3, [r7, #44]	@ 0x2c
#ifdef WOLFSSL_SMALL_STACK
    EncryptedInfo* info = NULL;
 800d5fc:	2300      	movs	r3, #0
 800d5fe:	633b      	str	r3, [r7, #48]	@ 0x30
#else
    EncryptedInfo  info[1];
#endif
    int           algId = 0;
 800d600:	2300      	movs	r3, #0
 800d602:	617b      	str	r3, [r7, #20]

    WOLFSSL_ENTER("ProcessBuffer");

    /* Check data format is supported. */
    if ((format != WOLFSSL_FILETYPE_ASN1) && (format != WOLFSSL_FILETYPE_PEM)) {
 800d604:	683b      	ldr	r3, [r7, #0]
 800d606:	2b02      	cmp	r3, #2
 800d608:	d004      	beq.n	800d614 <ProcessBuffer+0x4c>
 800d60a:	683b      	ldr	r3, [r7, #0]
 800d60c:	2b01      	cmp	r3, #1
 800d60e:	d001      	beq.n	800d614 <ProcessBuffer+0x4c>
        ret = WOLFSSL_BAD_FILETYPE;
 800d610:	4b77      	ldr	r3, [pc, #476]	@ (800d7f0 <ProcessBuffer+0x228>)
 800d612:	637b      	str	r3, [r7, #52]	@ 0x34
    }
    /* Need an object to store certificate into. */
    if ((ret == 0) && (ctx == NULL) && (ssl == NULL)) {
 800d614:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d616:	2b00      	cmp	r3, #0
 800d618:	d108      	bne.n	800d62c <ProcessBuffer+0x64>
 800d61a:	68fb      	ldr	r3, [r7, #12]
 800d61c:	2b00      	cmp	r3, #0
 800d61e:	d105      	bne.n	800d62c <ProcessBuffer+0x64>
 800d620:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800d622:	2b00      	cmp	r3, #0
 800d624:	d102      	bne.n	800d62c <ProcessBuffer+0x64>
        ret = BAD_FUNC_ARG;
 800d626:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800d62a:	637b      	str	r3, [r7, #52]	@ 0x34
    }
    /* CA certificates go into the SSL context object. */
    if ((ret == 0) && (ctx == NULL) && (type == CA_TYPE)) {
 800d62c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d62e:	2b00      	cmp	r3, #0
 800d630:	d108      	bne.n	800d644 <ProcessBuffer+0x7c>
 800d632:	68fb      	ldr	r3, [r7, #12]
 800d634:	2b00      	cmp	r3, #0
 800d636:	d105      	bne.n	800d644 <ProcessBuffer+0x7c>
 800d638:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800d63a:	2b06      	cmp	r3, #6
 800d63c:	d102      	bne.n	800d644 <ProcessBuffer+0x7c>
        ret = BAD_FUNC_ARG;
 800d63e:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800d642:	637b      	str	r3, [r7, #52]	@ 0x34
    }
    /* This API does not handle CHAIN_CERT_TYPE */
    if ((ret == 0) && (type == CHAIN_CERT_TYPE)) {
 800d644:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d646:	2b00      	cmp	r3, #0
 800d648:	d105      	bne.n	800d656 <ProcessBuffer+0x8e>
 800d64a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800d64c:	2b2a      	cmp	r3, #42	@ 0x2a
 800d64e:	d102      	bne.n	800d656 <ProcessBuffer+0x8e>
        ret = BAD_FUNC_ARG;
 800d650:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800d654:	637b      	str	r3, [r7, #52]	@ 0x34
    }

#ifdef WOLFSSL_SMALL_STACK
    if (ret == 0) {
 800d656:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d658:	2b00      	cmp	r3, #0
 800d65a:	d109      	bne.n	800d670 <ProcessBuffer+0xa8>
        /* Allocate memory for encryption information. */
        info = (EncryptedInfo*)XMALLOC(sizeof(EncryptedInfo), heap,
 800d65c:	208c      	movs	r0, #140	@ 0x8c
 800d65e:	f011 fa13 	bl	801ea88 <wolfSSL_Malloc>
 800d662:	6338      	str	r0, [r7, #48]	@ 0x30
            DYNAMIC_TYPE_ENCRYPTEDINFO);
        if (info == NULL) {
 800d664:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800d666:	2b00      	cmp	r3, #0
 800d668:	d102      	bne.n	800d670 <ProcessBuffer+0xa8>
            ret = MEMORY_E;
 800d66a:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800d66e:	637b      	str	r3, [r7, #52]	@ 0x34
        }
    }
#endif
    if (ret == 0) {
 800d670:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d672:	2b00      	cmp	r3, #0
 800d674:	d127      	bne.n	800d6c6 <ProcessBuffer+0xfe>
        /* Initialize encryption information. */
        XMEMSET(info, 0, sizeof(EncryptedInfo));
 800d676:	228c      	movs	r2, #140	@ 0x8c
 800d678:	2100      	movs	r1, #0
 800d67a:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 800d67c:	f01a ff24 	bl	80284c8 <memset>
            info->passwd_userdata = ctx->passwd_userdata;
        }
    #endif

        /* Get the DER data for a private key or certificate. */
        ret = DataToDerBuffer(buff, (word32)sz, format, type, info, heap, &der,
 800d680:	6879      	ldr	r1, [r7, #4]
 800d682:	f107 0314 	add.w	r3, r7, #20
 800d686:	9303      	str	r3, [sp, #12]
 800d688:	f107 0318 	add.w	r3, r7, #24
 800d68c:	9302      	str	r3, [sp, #8]
 800d68e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800d690:	9301      	str	r3, [sp, #4]
 800d692:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800d694:	9300      	str	r3, [sp, #0]
 800d696:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800d698:	683a      	ldr	r2, [r7, #0]
 800d69a:	68b8      	ldr	r0, [r7, #8]
 800d69c:	f7ff f8c8 	bl	800c830 <DataToDerBuffer>
 800d6a0:	6378      	str	r0, [r7, #52]	@ 0x34
            &algId);
        if (used != NULL) {
 800d6a2:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800d6a4:	2b00      	cmp	r3, #0
 800d6a6:	d003      	beq.n	800d6b0 <ProcessBuffer+0xe8>
            /* Update to amount used/consumed. */
            *used = info->consumed;
 800d6a8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800d6aa:	681a      	ldr	r2, [r3, #0]
 800d6ac:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800d6ae:	601a      	str	r2, [r3, #0]
        }
    #ifdef WOLFSSL_SMALL_STACK
        if (ret != 0) {
 800d6b0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d6b2:	2b00      	cmp	r3, #0
 800d6b4:	d007      	beq.n	800d6c6 <ProcessBuffer+0xfe>
             /* Info no longer needed as loading failed. */
             XFREE(info, heap, DYNAMIC_TYPE_ENCRYPTEDINFO);
 800d6b6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800d6b8:	62bb      	str	r3, [r7, #40]	@ 0x28
 800d6ba:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d6bc:	2b00      	cmp	r3, #0
 800d6be:	d002      	beq.n	800d6c6 <ProcessBuffer+0xfe>
 800d6c0:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 800d6c2:	f011 f9fd 	bl	801eac0 <wolfSSL_Free>
        }
    #endif
    }

    if ((ret == 0) && IS_PRIVKEY_TYPE(type)) {
 800d6c6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d6c8:	2b00      	cmp	r3, #0
 800d6ca:	d11a      	bne.n	800d702 <ProcessBuffer+0x13a>
 800d6cc:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800d6ce:	2b01      	cmp	r3, #1
 800d6d0:	d117      	bne.n	800d702 <ProcessBuffer+0x13a>
        /* Process the private key. */
        ret = ProcessBufferPrivateKey(ctx, ssl, der, format, info, heap, type,
 800d6d2:	69ba      	ldr	r2, [r7, #24]
 800d6d4:	697b      	ldr	r3, [r7, #20]
 800d6d6:	9303      	str	r3, [sp, #12]
 800d6d8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800d6da:	9302      	str	r3, [sp, #8]
 800d6dc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800d6de:	9301      	str	r3, [sp, #4]
 800d6e0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800d6e2:	9300      	str	r3, [sp, #0]
 800d6e4:	683b      	ldr	r3, [r7, #0]
 800d6e6:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 800d6e8:	68f8      	ldr	r0, [r7, #12]
 800d6ea:	f7ff fbe3 	bl	800ceb4 <ProcessBufferPrivateKey>
 800d6ee:	6378      	str	r0, [r7, #52]	@ 0x34
            algId);
    #ifdef WOLFSSL_SMALL_STACK
        /* Info no longer needed - keep max memory usage down. */
        XFREE(info, heap, DYNAMIC_TYPE_ENCRYPTEDINFO);
 800d6f0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800d6f2:	627b      	str	r3, [r7, #36]	@ 0x24
 800d6f4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800d6f6:	2b00      	cmp	r3, #0
 800d6f8:	d058      	beq.n	800d7ac <ProcessBuffer+0x1e4>
 800d6fa:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800d6fc:	f011 f9e0 	bl	801eac0 <wolfSSL_Free>
 800d700:	e054      	b.n	800d7ac <ProcessBuffer+0x1e4>
    #endif
    }
    else if (ret == 0) {
 800d702:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d704:	2b00      	cmp	r3, #0
 800d706:	d152      	bne.n	800d7ae <ProcessBuffer+0x1e6>
        /* Processing a certificate. */
        if (userChain) {
 800d708:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800d70a:	2b00      	cmp	r3, #0
 800d70c:	d02d      	beq.n	800d76a <ProcessBuffer+0x1a2>
            /* Take original buffer and add to user chain to send in TLS
             * handshake. */
            ret = ProcessUserChain(ctx, ssl, buff, sz, format, type, used, info,
 800d70e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800d710:	9304      	str	r3, [sp, #16]
 800d712:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800d714:	9303      	str	r3, [sp, #12]
 800d716:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800d718:	9302      	str	r3, [sp, #8]
 800d71a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800d71c:	9301      	str	r3, [sp, #4]
 800d71e:	683b      	ldr	r3, [r7, #0]
 800d720:	9300      	str	r3, [sp, #0]
 800d722:	687b      	ldr	r3, [r7, #4]
 800d724:	68ba      	ldr	r2, [r7, #8]
 800d726:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 800d728:	68f8      	ldr	r0, [r7, #12]
 800d72a:	f7ff f96c 	bl	800ca06 <ProcessUserChain>
 800d72e:	6378      	str	r0, [r7, #52]	@ 0x34
                verify);
            /* Additional chain is optional */
            if (ret == WC_NO_ERR_TRACE(ASN_NO_PEM_HEADER)) {
 800d730:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d732:	f113 0fa2 	cmn.w	r3, #162	@ 0xa2
 800d736:	d118      	bne.n	800d76a <ProcessBuffer+0x1a2>
                unsigned long pemErr = 0;
 800d738:	2300      	movs	r3, #0
 800d73a:	623b      	str	r3, [r7, #32]
                CLEAR_ASN_NO_PEM_HEADER_ERROR(pemErr);
 800d73c:	f000 fc88 	bl	800e050 <wolfSSL_ERR_peek_last_error>
 800d740:	6238      	str	r0, [r7, #32]
 800d742:	6a38      	ldr	r0, [r7, #32]
 800d744:	f000 fa71 	bl	800dc2a <wolfSSL_ERR_GET_LIB>
 800d748:	4603      	mov	r3, r0
 800d74a:	2b09      	cmp	r3, #9
 800d74c:	d10b      	bne.n	800d766 <ProcessBuffer+0x19e>
 800d74e:	6a38      	ldr	r0, [r7, #32]
 800d750:	f000 faa2 	bl	800dc98 <wolfSSL_ERR_GET_REASON>
 800d754:	4603      	mov	r3, r0
 800d756:	f240 12fb 	movw	r2, #507	@ 0x1fb
 800d75a:	4293      	cmp	r3, r2
 800d75c:	d103      	bne.n	800d766 <ProcessBuffer+0x19e>
 800d75e:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 800d762:	f011 f8eb 	bl	801e93c <wc_RemoveErrorNode>
                ret = 0;
 800d766:	2300      	movs	r3, #0
 800d768:	637b      	str	r3, [r7, #52]	@ 0x34
            }
        }

    #ifdef WOLFSSL_SMALL_STACK
        /* Info no longer needed - keep max memory usage down. */
        XFREE(info, heap, DYNAMIC_TYPE_ENCRYPTEDINFO);
 800d76a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800d76c:	61fb      	str	r3, [r7, #28]
 800d76e:	69fb      	ldr	r3, [r7, #28]
 800d770:	2b00      	cmp	r3, #0
 800d772:	d002      	beq.n	800d77a <ProcessBuffer+0x1b2>
 800d774:	69f8      	ldr	r0, [r7, #28]
 800d776:	f011 f9a3 	bl	801eac0 <wolfSSL_Free>
    #endif

        if (ret == 0) {
 800d77a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d77c:	2b00      	cmp	r3, #0
 800d77e:	d10f      	bne.n	800d7a0 <ProcessBuffer+0x1d8>
            /* Process the different types of certificates. */
            ret = ProcessBufferCertTypes(ctx, ssl, buff, sz, der, format, type,
 800d780:	69bb      	ldr	r3, [r7, #24]
 800d782:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800d784:	9203      	str	r2, [sp, #12]
 800d786:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800d788:	9202      	str	r2, [sp, #8]
 800d78a:	683a      	ldr	r2, [r7, #0]
 800d78c:	9201      	str	r2, [sp, #4]
 800d78e:	9300      	str	r3, [sp, #0]
 800d790:	687b      	ldr	r3, [r7, #4]
 800d792:	68ba      	ldr	r2, [r7, #8]
 800d794:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 800d796:	68f8      	ldr	r0, [r7, #12]
 800d798:	f7ff fe04 	bl	800d3a4 <ProcessBufferCertTypes>
 800d79c:	6378      	str	r0, [r7, #52]	@ 0x34
 800d79e:	e006      	b.n	800d7ae <ProcessBuffer+0x1e6>
                verify);
        }
        else {
            FreeDer(&der);
 800d7a0:	f107 0318 	add.w	r3, r7, #24
 800d7a4:	4618      	mov	r0, r3
 800d7a6:	f00b fbe9 	bl	8018f7c <FreeDer>
 800d7aa:	e000      	b.n	800d7ae <ProcessBuffer+0x1e6>
        XFREE(info, heap, DYNAMIC_TYPE_ENCRYPTEDINFO);
 800d7ac:	bf00      	nop
        }
    }

    /* Reset suites if this is a private key or user certificate. */
    if ((ret == 0) && ((type == PRIVATEKEY_TYPE) || (type == CERT_TYPE))) {
 800d7ae:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d7b0:	2b00      	cmp	r3, #0
 800d7b2:	d10b      	bne.n	800d7cc <ProcessBuffer+0x204>
 800d7b4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800d7b6:	2b01      	cmp	r3, #1
 800d7b8:	d002      	beq.n	800d7c0 <ProcessBuffer+0x1f8>
 800d7ba:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800d7bc:	2b00      	cmp	r3, #0
 800d7be:	d105      	bne.n	800d7cc <ProcessBuffer+0x204>
        ret = ProcessBufferResetSuites(ctx, ssl, type);
 800d7c0:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800d7c2:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 800d7c4:	68f8      	ldr	r0, [r7, #12]
 800d7c6:	f7ff fe38 	bl	800d43a <ProcessBufferResetSuites>
 800d7ca:	6378      	str	r0, [r7, #52]	@ 0x34
    }

    /* Convert return code. */
    if (ret == 0) {
 800d7cc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d7ce:	2b00      	cmp	r3, #0
 800d7d0:	d102      	bne.n	800d7d8 <ProcessBuffer+0x210>
        ret = 1;
 800d7d2:	2301      	movs	r3, #1
 800d7d4:	637b      	str	r3, [r7, #52]	@ 0x34
 800d7d6:	e005      	b.n	800d7e4 <ProcessBuffer+0x21c>
    }
    else if (ret == WC_NO_ERR_TRACE(WOLFSSL_FATAL_ERROR)) {
 800d7d8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d7da:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 800d7de:	d101      	bne.n	800d7e4 <ProcessBuffer+0x21c>
        ret = 0;
 800d7e0:	2300      	movs	r3, #0
 800d7e2:	637b      	str	r3, [r7, #52]	@ 0x34
    }
    WOLFSSL_LEAVE("ProcessBuffer", ret);
    return ret;
 800d7e4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
 800d7e6:	4618      	mov	r0, r3
 800d7e8:	3738      	adds	r7, #56	@ 0x38
 800d7ea:	46bd      	mov	sp, r7
 800d7ec:	bd80      	pop	{r7, pc}
 800d7ee:	bf00      	nop
 800d7f0:	fffffe32 	.word	0xfffffe32

0800d7f4 <ProcessChainBuffer>:
 * @return  0 on failure.
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
static int ProcessChainBuffer(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    const unsigned char* buff, long sz, int type, int verify)
{
 800d7f4:	b580      	push	{r7, lr}
 800d7f6:	b08e      	sub	sp, #56	@ 0x38
 800d7f8:	af06      	add	r7, sp, #24
 800d7fa:	60f8      	str	r0, [r7, #12]
 800d7fc:	60b9      	str	r1, [r7, #8]
 800d7fe:	607a      	str	r2, [r7, #4]
 800d800:	603b      	str	r3, [r7, #0]
    int  ret    = 0;
 800d802:	2300      	movs	r3, #0
 800d804:	61fb      	str	r3, [r7, #28]
    long used   = 0;
 800d806:	2300      	movs	r3, #0
 800d808:	61bb      	str	r3, [r7, #24]
    int  gotOne = 0;
 800d80a:	2300      	movs	r3, #0
 800d80c:	617b      	str	r3, [r7, #20]

    WOLFSSL_MSG("Processing CA PEM file");
    /* Keep processing file while no errors and data to parse. */
    while ((ret >= 0) && (used < sz)) {
 800d80e:	e03c      	b.n	800d88a <ProcessChainBuffer+0x96>
        long consumed = 0;
 800d810:	2300      	movs	r3, #0
 800d812:	613b      	str	r3, [r7, #16]

        /* Process the buffer. */
        ret = ProcessBuffer(ctx, buff + used, sz - used, WOLFSSL_FILETYPE_PEM,
 800d814:	69bb      	ldr	r3, [r7, #24]
 800d816:	687a      	ldr	r2, [r7, #4]
 800d818:	18d1      	adds	r1, r2, r3
 800d81a:	683a      	ldr	r2, [r7, #0]
 800d81c:	69bb      	ldr	r3, [r7, #24]
 800d81e:	1ad2      	subs	r2, r2, r3
 800d820:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800d822:	9304      	str	r3, [sp, #16]
 800d824:	2300      	movs	r3, #0
 800d826:	9303      	str	r3, [sp, #12]
 800d828:	f107 0310 	add.w	r3, r7, #16
 800d82c:	9302      	str	r3, [sp, #8]
 800d82e:	68bb      	ldr	r3, [r7, #8]
 800d830:	9301      	str	r3, [sp, #4]
 800d832:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d834:	9300      	str	r3, [sp, #0]
 800d836:	2301      	movs	r3, #1
 800d838:	68f8      	ldr	r0, [r7, #12]
 800d83a:	f7ff fec5 	bl	800d5c8 <ProcessBuffer>
 800d83e:	61f8      	str	r0, [r7, #28]
            type, ssl, &consumed, 0, verify);
        /* Memory allocation failure is fatal. */
        if (ret == WC_NO_ERR_TRACE(MEMORY_E)) {
 800d840:	69fb      	ldr	r3, [r7, #28]
 800d842:	f113 0f7d 	cmn.w	r3, #125	@ 0x7d
 800d846:	d102      	bne.n	800d84e <ProcessChainBuffer+0x5a>
            gotOne = 0;
 800d848:	2300      	movs	r3, #0
 800d84a:	617b      	str	r3, [r7, #20]
 800d84c:	e019      	b.n	800d882 <ProcessChainBuffer+0x8e>
        }
        /* Other error parsing. */
        else if (ret < 0) {
 800d84e:	69fb      	ldr	r3, [r7, #28]
 800d850:	2b00      	cmp	r3, #0
 800d852:	da14      	bge.n	800d87e <ProcessChainBuffer+0x8a>
                ret = 0;
            }
            else
#endif
            /* Check whether we made progress. */
            if (consumed > 0) {
 800d854:	693b      	ldr	r3, [r7, #16]
 800d856:	2b00      	cmp	r3, #0
 800d858:	dd13      	ble.n	800d882 <ProcessChainBuffer+0x8e>
                WOLFSSL_ERROR(ret);
 800d85a:	2300      	movs	r3, #0
 800d85c:	9300      	str	r3, [sp, #0]
 800d85e:	4b13      	ldr	r3, [pc, #76]	@ (800d8ac <ProcessChainBuffer+0xb8>)
 800d860:	f640 1295 	movw	r2, #2453	@ 0x995
 800d864:	4912      	ldr	r1, [pc, #72]	@ (800d8b0 <ProcessChainBuffer+0xbc>)
 800d866:	69f8      	ldr	r0, [r7, #28]
 800d868:	f011 f8c2 	bl	801e9f0 <WOLFSSL_ERROR_LINE>
                WOLFSSL_MSG("CA Parse failed, with progress in file.");
                WOLFSSL_MSG("Search for other certs in file");
                /* Check if we have more data to parse to recover. */
                if (used + consumed < sz) {
 800d86c:	693a      	ldr	r2, [r7, #16]
 800d86e:	69bb      	ldr	r3, [r7, #24]
 800d870:	4413      	add	r3, r2
 800d872:	683a      	ldr	r2, [r7, #0]
 800d874:	429a      	cmp	r2, r3
 800d876:	dd04      	ble.n	800d882 <ProcessChainBuffer+0x8e>
                    ret = 0;
 800d878:	2300      	movs	r3, #0
 800d87a:	61fb      	str	r3, [r7, #28]
 800d87c:	e001      	b.n	800d882 <ProcessChainBuffer+0x8e>
            }
        }
        else {
            /* Got a certificate out. */
            WOLFSSL_MSG("   Processed a CA");
            gotOne = 1;
 800d87e:	2301      	movs	r3, #1
 800d880:	617b      	str	r3, [r7, #20]
        }
        /* Update used count. */
        used += consumed;
 800d882:	693b      	ldr	r3, [r7, #16]
 800d884:	69ba      	ldr	r2, [r7, #24]
 800d886:	4413      	add	r3, r2
 800d888:	61bb      	str	r3, [r7, #24]
    while ((ret >= 0) && (used < sz)) {
 800d88a:	69fb      	ldr	r3, [r7, #28]
 800d88c:	2b00      	cmp	r3, #0
 800d88e:	db03      	blt.n	800d898 <ProcessChainBuffer+0xa4>
 800d890:	69ba      	ldr	r2, [r7, #24]
 800d892:	683b      	ldr	r3, [r7, #0]
 800d894:	429a      	cmp	r2, r3
 800d896:	dbbb      	blt.n	800d810 <ProcessChainBuffer+0x1c>
    }

    /* May have other unparsable data but did we get a certificate? */
    if (gotOne) {
 800d898:	697b      	ldr	r3, [r7, #20]
 800d89a:	2b00      	cmp	r3, #0
 800d89c:	d001      	beq.n	800d8a2 <ProcessChainBuffer+0xae>
        WOLFSSL_MSG("Processed at least one valid CA. Other stuff OK");
        ret = 1;
 800d89e:	2301      	movs	r3, #1
 800d8a0:	61fb      	str	r3, [r7, #28]
    }
    return ret;
 800d8a2:	69fb      	ldr	r3, [r7, #28]
}
 800d8a4:	4618      	mov	r0, r3
 800d8a6:	3720      	adds	r7, #32
 800d8a8:	46bd      	mov	sp, r7
 800d8aa:	bd80      	pop	{r7, pc}
 800d8ac:	08029f2c 	.word	0x08029f2c
 800d8b0:	08031458 	.word	0x08031458

0800d8b4 <wolfSSL_CTX_load_verify_buffer_ex>:
 * @return  0 on failure.
 * @return  Negative on error.
 */
int wolfSSL_CTX_load_verify_buffer_ex(WOLFSSL_CTX* ctx, const unsigned char* in,
    long sz, int format, int userChain, word32 flags)
{
 800d8b4:	b580      	push	{r7, lr}
 800d8b6:	b08c      	sub	sp, #48	@ 0x30
 800d8b8:	af06      	add	r7, sp, #24
 800d8ba:	60f8      	str	r0, [r7, #12]
 800d8bc:	60b9      	str	r1, [r7, #8]
 800d8be:	607a      	str	r2, [r7, #4]
 800d8c0:	603b      	str	r3, [r7, #0]
    int verify;

    WOLFSSL_ENTER("wolfSSL_CTX_load_verify_buffer_ex");

    /* Get setting on how to verify certificates. */
    verify = GET_VERIFY_SETTING_CTX(ctx);
 800d8c2:	68fb      	ldr	r3, [r7, #12]
 800d8c4:	2b00      	cmp	r3, #0
 800d8c6:	d007      	beq.n	800d8d8 <wolfSSL_CTX_load_verify_buffer_ex+0x24>
 800d8c8:	68fb      	ldr	r3, [r7, #12]
 800d8ca:	f893 305d 	ldrb.w	r3, [r3, #93]	@ 0x5d
 800d8ce:	f003 0302 	and.w	r3, r3, #2
 800d8d2:	b2db      	uxtb	r3, r3
 800d8d4:	2b00      	cmp	r3, #0
 800d8d6:	d101      	bne.n	800d8dc <wolfSSL_CTX_load_verify_buffer_ex+0x28>
 800d8d8:	2301      	movs	r3, #1
 800d8da:	e000      	b.n	800d8de <wolfSSL_CTX_load_verify_buffer_ex+0x2a>
 800d8dc:	2300      	movs	r3, #0
 800d8de:	613b      	str	r3, [r7, #16]
    /* Overwrite setting when flag set. */
    if (flags & WOLFSSL_LOAD_FLAG_DATE_ERR_OKAY) {
 800d8e0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800d8e2:	f003 0302 	and.w	r3, r3, #2
 800d8e6:	2b00      	cmp	r3, #0
 800d8e8:	d001      	beq.n	800d8ee <wolfSSL_CTX_load_verify_buffer_ex+0x3a>
        verify = VERIFY_SKIP_DATE;
 800d8ea:	2305      	movs	r3, #5
 800d8ec:	613b      	str	r3, [r7, #16]
    }

    /* When PEM, treat as certificate chain of CA certificates. */
    if (format == WOLFSSL_FILETYPE_PEM) {
 800d8ee:	683b      	ldr	r3, [r7, #0]
 800d8f0:	2b01      	cmp	r3, #1
 800d8f2:	d10b      	bne.n	800d90c <wolfSSL_CTX_load_verify_buffer_ex+0x58>
        ret = ProcessChainBuffer(ctx, NULL, in, sz, CA_TYPE, verify);
 800d8f4:	693b      	ldr	r3, [r7, #16]
 800d8f6:	9301      	str	r3, [sp, #4]
 800d8f8:	2306      	movs	r3, #6
 800d8fa:	9300      	str	r3, [sp, #0]
 800d8fc:	687b      	ldr	r3, [r7, #4]
 800d8fe:	68ba      	ldr	r2, [r7, #8]
 800d900:	2100      	movs	r1, #0
 800d902:	68f8      	ldr	r0, [r7, #12]
 800d904:	f7ff ff76 	bl	800d7f4 <ProcessChainBuffer>
 800d908:	6178      	str	r0, [r7, #20]
 800d90a:	e010      	b.n	800d92e <wolfSSL_CTX_load_verify_buffer_ex+0x7a>
    }
    /* When DER, load the CA certificate. */
    else {
        ret = ProcessBuffer(ctx, in, sz, format, CA_TYPE, NULL, NULL,
 800d90c:	693b      	ldr	r3, [r7, #16]
 800d90e:	9304      	str	r3, [sp, #16]
 800d910:	6a3b      	ldr	r3, [r7, #32]
 800d912:	9303      	str	r3, [sp, #12]
 800d914:	2300      	movs	r3, #0
 800d916:	9302      	str	r3, [sp, #8]
 800d918:	2300      	movs	r3, #0
 800d91a:	9301      	str	r3, [sp, #4]
 800d91c:	2306      	movs	r3, #6
 800d91e:	9300      	str	r3, [sp, #0]
 800d920:	683b      	ldr	r3, [r7, #0]
 800d922:	687a      	ldr	r2, [r7, #4]
 800d924:	68b9      	ldr	r1, [r7, #8]
 800d926:	68f8      	ldr	r0, [r7, #12]
 800d928:	f7ff fe4e 	bl	800d5c8 <ProcessBuffer>
 800d92c:	6178      	str	r0, [r7, #20]
        ret = wolfSSL_CTX_trust_peer_buffer(ctx, in, sz, format);
    }
#endif

    WOLFSSL_LEAVE("wolfSSL_CTX_load_verify_buffer_ex", ret);
    return ret;
 800d92e:	697b      	ldr	r3, [r7, #20]
}
 800d930:	4618      	mov	r0, r3
 800d932:	3718      	adds	r7, #24
 800d934:	46bd      	mov	sp, r7
 800d936:	bd80      	pop	{r7, pc}

0800d938 <wolfSSL_CTX_load_verify_buffer>:
 * @return  0 on failure.
 * @return  Negative on error.
 */
int wolfSSL_CTX_load_verify_buffer(WOLFSSL_CTX* ctx, const unsigned char* in,
    long sz, int format)
{
 800d938:	b580      	push	{r7, lr}
 800d93a:	b086      	sub	sp, #24
 800d93c:	af02      	add	r7, sp, #8
 800d93e:	60f8      	str	r0, [r7, #12]
 800d940:	60b9      	str	r1, [r7, #8]
 800d942:	607a      	str	r2, [r7, #4]
 800d944:	603b      	str	r3, [r7, #0]
    return wolfSSL_CTX_load_verify_buffer_ex(ctx, in, sz, format, 0,
 800d946:	2300      	movs	r3, #0
 800d948:	9301      	str	r3, [sp, #4]
 800d94a:	2300      	movs	r3, #0
 800d94c:	9300      	str	r3, [sp, #0]
 800d94e:	683b      	ldr	r3, [r7, #0]
 800d950:	687a      	ldr	r2, [r7, #4]
 800d952:	68b9      	ldr	r1, [r7, #8]
 800d954:	68f8      	ldr	r0, [r7, #12]
 800d956:	f7ff ffad 	bl	800d8b4 <wolfSSL_CTX_load_verify_buffer_ex>
 800d95a:	4603      	mov	r3, r0
        WOLFSSL_LOAD_VERIFY_DEFAULT_FLAGS);
}
 800d95c:	4618      	mov	r0, r3
 800d95e:	3710      	adds	r7, #16
 800d960:	46bd      	mov	sp, r7
 800d962:	bd80      	pop	{r7, pc}

0800d964 <wolfSSL_Cleanup>:

#endif /* NO_HANDSHAKE_DONE_CB */

WOLFSSL_ABI
int wolfSSL_Cleanup(void)
{
 800d964:	b580      	push	{r7, lr}
 800d966:	b082      	sub	sp, #8
 800d968:	af00      	add	r7, sp, #0
    int ret = WOLFSSL_SUCCESS; /* Only the first error will be returned */
 800d96a:	2301      	movs	r3, #1
 800d96c:	607b      	str	r3, [r7, #4]
    int release = 0;
 800d96e:	2300      	movs	r3, #0
 800d970:	603b      	str	r3, [r7, #0]
#endif

    WOLFSSL_ENTER("wolfSSL_Cleanup");

#ifndef WOLFSSL_MUTEX_INITIALIZER
    if (inits_count_mutex_valid == 1) {
 800d972:	4b35      	ldr	r3, [pc, #212]	@ (800da48 <wolfSSL_Cleanup+0xe4>)
 800d974:	681b      	ldr	r3, [r3, #0]
 800d976:	2b01      	cmp	r3, #1
 800d978:	d108      	bne.n	800d98c <wolfSSL_Cleanup+0x28>
#endif
        if (wc_LockMutex(&inits_count_mutex) != 0) {
 800d97a:	4834      	ldr	r0, [pc, #208]	@ (800da4c <wolfSSL_Cleanup+0xe8>)
 800d97c:	f019 fd14 	bl	80273a8 <wc_LockMutex>
 800d980:	4603      	mov	r3, r0
 800d982:	2b00      	cmp	r3, #0
 800d984:	d002      	beq.n	800d98c <wolfSSL_Cleanup+0x28>
            WOLFSSL_MSG("Bad Lock Mutex count");
            return BAD_MUTEX_E;
 800d986:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 800d98a:	e058      	b.n	800da3e <wolfSSL_Cleanup+0xda>
        }
#ifndef WOLFSSL_MUTEX_INITIALIZER
    }
#endif

    if (initRefCount > 0) {
 800d98c:	4b30      	ldr	r3, [pc, #192]	@ (800da50 <wolfSSL_Cleanup+0xec>)
 800d98e:	681b      	ldr	r3, [r3, #0]
 800d990:	2b00      	cmp	r3, #0
 800d992:	dd0a      	ble.n	800d9aa <wolfSSL_Cleanup+0x46>
        --initRefCount;
 800d994:	4b2e      	ldr	r3, [pc, #184]	@ (800da50 <wolfSSL_Cleanup+0xec>)
 800d996:	681b      	ldr	r3, [r3, #0]
 800d998:	3b01      	subs	r3, #1
 800d99a:	4a2d      	ldr	r2, [pc, #180]	@ (800da50 <wolfSSL_Cleanup+0xec>)
 800d99c:	6013      	str	r3, [r2, #0]
        if (initRefCount == 0)
 800d99e:	4b2c      	ldr	r3, [pc, #176]	@ (800da50 <wolfSSL_Cleanup+0xec>)
 800d9a0:	681b      	ldr	r3, [r3, #0]
 800d9a2:	2b00      	cmp	r3, #0
 800d9a4:	d101      	bne.n	800d9aa <wolfSSL_Cleanup+0x46>
            release = 1;
 800d9a6:	2301      	movs	r3, #1
 800d9a8:	603b      	str	r3, [r7, #0]
    }

#ifndef WOLFSSL_MUTEX_INITIALIZER
    if (inits_count_mutex_valid == 1) {
 800d9aa:	4b27      	ldr	r3, [pc, #156]	@ (800da48 <wolfSSL_Cleanup+0xe4>)
 800d9ac:	681b      	ldr	r3, [r3, #0]
 800d9ae:	2b01      	cmp	r3, #1
 800d9b0:	d102      	bne.n	800d9b8 <wolfSSL_Cleanup+0x54>
#endif
        wc_UnLockMutex(&inits_count_mutex);
 800d9b2:	4826      	ldr	r0, [pc, #152]	@ (800da4c <wolfSSL_Cleanup+0xe8>)
 800d9b4:	f019 fd03 	bl	80273be <wc_UnLockMutex>
#ifndef WOLFSSL_MUTEX_INITIALIZER
    }
#endif

    if (!release)
 800d9b8:	683b      	ldr	r3, [r7, #0]
 800d9ba:	2b00      	cmp	r3, #0
 800d9bc:	d101      	bne.n	800d9c2 <wolfSSL_Cleanup+0x5e>
        return ret;
 800d9be:	687b      	ldr	r3, [r7, #4]
 800d9c0:	e03d      	b.n	800da3e <wolfSSL_Cleanup+0xda>
#if defined(WOLFSSL_SYS_CRYPTO_POLICY)
    wolfSSL_crypto_policy_disable();
#endif /* WOLFSSL_SYS_CRYPTO_POLICY */

#ifdef OPENSSL_EXTRA
    wolfSSL_BN_free_one();
 800d9c2:	f7fd ffb7 	bl	800b934 <wolfSSL_BN_free_one>
    #endif
#endif /* !NO_SESSION_CACHE */

#if !defined(WOLFSSL_MUTEX_INITIALIZER) && \
      !WOLFSSL_CLEANUP_THREADSAFE_BY_ATOMIC_OPS
    if ((inits_count_mutex_valid == 1) &&
 800d9c6:	4b20      	ldr	r3, [pc, #128]	@ (800da48 <wolfSSL_Cleanup+0xe4>)
 800d9c8:	681b      	ldr	r3, [r3, #0]
 800d9ca:	2b01      	cmp	r3, #1
 800d9cc:	d10b      	bne.n	800d9e6 <wolfSSL_Cleanup+0x82>
            (wc_FreeMutex(&inits_count_mutex) != 0)) {
 800d9ce:	481f      	ldr	r0, [pc, #124]	@ (800da4c <wolfSSL_Cleanup+0xe8>)
 800d9d0:	f019 fcdf 	bl	8027392 <wc_FreeMutex>
 800d9d4:	4603      	mov	r3, r0
    if ((inits_count_mutex_valid == 1) &&
 800d9d6:	2b00      	cmp	r3, #0
 800d9d8:	d005      	beq.n	800d9e6 <wolfSSL_Cleanup+0x82>
        if (ret == WOLFSSL_SUCCESS)
 800d9da:	687b      	ldr	r3, [r7, #4]
 800d9dc:	2b01      	cmp	r3, #1
 800d9de:	d102      	bne.n	800d9e6 <wolfSSL_Cleanup+0x82>
            ret = BAD_MUTEX_E;
 800d9e0:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 800d9e4:	607b      	str	r3, [r7, #4]
    }
    inits_count_mutex_valid = 0;
 800d9e6:	4b18      	ldr	r3, [pc, #96]	@ (800da48 <wolfSSL_Cleanup+0xe4>)
 800d9e8:	2200      	movs	r2, #0
 800d9ea:	601a      	str	r2, [r3, #0]
#endif

#ifdef OPENSSL_EXTRA
    wolfSSL_RAND_Cleanup();
 800d9ec:	f001 fa54 	bl	800ee98 <wolfSSL_RAND_Cleanup>
#endif

    if (wolfCrypt_Cleanup() != 0) {
 800d9f0:	f019 fc60 	bl	80272b4 <wolfCrypt_Cleanup>
 800d9f4:	4603      	mov	r3, r0
 800d9f6:	2b00      	cmp	r3, #0
 800d9f8:	d005      	beq.n	800da06 <wolfSSL_Cleanup+0xa2>
        WOLFSSL_MSG("Error with wolfCrypt_Cleanup call");
        if (ret == WOLFSSL_SUCCESS)
 800d9fa:	687b      	ldr	r3, [r7, #4]
 800d9fc:	2b01      	cmp	r3, #1
 800d9fe:	d102      	bne.n	800da06 <wolfSSL_Cleanup+0xa2>
            ret = WC_CLEANUP_E;
 800da00:	f06f 03f0 	mvn.w	r3, #240	@ 0xf0
 800da04:	607b      	str	r3, [r7, #4]
    }
#endif

#ifdef HAVE_GLOBAL_RNG
#ifndef WOLFSSL_MUTEX_INITIALIZER
    if ((globalRNGMutex_valid == 1) && (wc_FreeMutex(&globalRNGMutex) != 0)) {
 800da06:	4b13      	ldr	r3, [pc, #76]	@ (800da54 <wolfSSL_Cleanup+0xf0>)
 800da08:	681b      	ldr	r3, [r3, #0]
 800da0a:	2b01      	cmp	r3, #1
 800da0c:	d10b      	bne.n	800da26 <wolfSSL_Cleanup+0xc2>
 800da0e:	4812      	ldr	r0, [pc, #72]	@ (800da58 <wolfSSL_Cleanup+0xf4>)
 800da10:	f019 fcbf 	bl	8027392 <wc_FreeMutex>
 800da14:	4603      	mov	r3, r0
 800da16:	2b00      	cmp	r3, #0
 800da18:	d005      	beq.n	800da26 <wolfSSL_Cleanup+0xc2>
        if (ret == WOLFSSL_SUCCESS)
 800da1a:	687b      	ldr	r3, [r7, #4]
 800da1c:	2b01      	cmp	r3, #1
 800da1e:	d102      	bne.n	800da26 <wolfSSL_Cleanup+0xc2>
            ret = BAD_MUTEX_E;
 800da20:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 800da24:	607b      	str	r3, [r7, #4]
    }
    globalRNGMutex_valid = 0;
 800da26:	4b0b      	ldr	r3, [pc, #44]	@ (800da54 <wolfSSL_Cleanup+0xf0>)
 800da28:	2200      	movs	r2, #0
 800da2a:	601a      	str	r2, [r3, #0]
#endif /* !WOLFSSL_MUTEX_INITIALIZER */

    #if defined(OPENSSL_EXTRA) && defined(HAVE_HASHDRBG)
    wolfSSL_FIPS_drbg_free(gDrbgDefCtx);
 800da2c:	4b0b      	ldr	r3, [pc, #44]	@ (800da5c <wolfSSL_Cleanup+0xf8>)
 800da2e:	681b      	ldr	r3, [r3, #0]
 800da30:	4618      	mov	r0, r3
 800da32:	f001 fbdb 	bl	800f1ec <wolfSSL_FIPS_drbg_free>
    gDrbgDefCtx = NULL;
 800da36:	4b09      	ldr	r3, [pc, #36]	@ (800da5c <wolfSSL_Cleanup+0xf8>)
 800da38:	2200      	movs	r2, #0
 800da3a:	601a      	str	r2, [r3, #0]

#ifdef WOLFSSL_MEM_FAIL_COUNT
    wc_MemFailCount_Free();
#endif

    return ret;
 800da3c:	687b      	ldr	r3, [r7, #4]
}
 800da3e:	4618      	mov	r0, r3
 800da40:	3708      	adds	r7, #8
 800da42:	46bd      	mov	sp, r7
 800da44:	bd80      	pop	{r7, pc}
 800da46:	bf00      	nop
 800da48:	200028e0 	.word	0x200028e0
 800da4c:	200028dc 	.word	0x200028dc
 800da50:	200028d8 	.word	0x200028d8
 800da54:	200028c0 	.word	0x200028c0
 800da58:	200028bc 	.word	0x200028bc
 800da5c:	200028c4 	.word	0x200028c4

0800da60 <wolfSSL_UnloadCertsKeys>:
#ifndef NO_CERTS

    /* unload any certs or keys that SSL owns, leave CTX as is
       WOLFSSL_SUCCESS on ok */
    int wolfSSL_UnloadCertsKeys(WOLFSSL* ssl)
    {
 800da60:	b580      	push	{r7, lr}
 800da62:	b082      	sub	sp, #8
 800da64:	af00      	add	r7, sp, #0
 800da66:	6078      	str	r0, [r7, #4]
        if (ssl == NULL) {
 800da68:	687b      	ldr	r3, [r7, #4]
 800da6a:	2b00      	cmp	r3, #0
 800da6c:	d102      	bne.n	800da74 <wolfSSL_UnloadCertsKeys+0x14>
            WOLFSSL_MSG("Null function arg");
            return BAD_FUNC_ARG;
 800da6e:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800da72:	e040      	b.n	800daf6 <wolfSSL_UnloadCertsKeys+0x96>
        }

        if (ssl->buffers.weOwnCert && !ssl->keepCert) {
 800da74:	687b      	ldr	r3, [r7, #4]
 800da76:	f893 3144 	ldrb.w	r3, [r3, #324]	@ 0x144
 800da7a:	2b00      	cmp	r3, #0
 800da7c:	d010      	beq.n	800daa0 <wolfSSL_UnloadCertsKeys+0x40>
 800da7e:	687b      	ldr	r3, [r7, #4]
 800da80:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 800da84:	f893 3090 	ldrb.w	r3, [r3, #144]	@ 0x90
 800da88:	2b00      	cmp	r3, #0
 800da8a:	d109      	bne.n	800daa0 <wolfSSL_UnloadCertsKeys+0x40>
            WOLFSSL_MSG("Unloading cert");
            FreeDer(&ssl->buffers.certificate);
 800da8c:	687b      	ldr	r3, [r7, #4]
 800da8e:	f503 73b6 	add.w	r3, r3, #364	@ 0x16c
 800da92:	4618      	mov	r0, r3
 800da94:	f00b fa72 	bl	8018f7c <FreeDer>
            #ifdef KEEP_OUR_CERT
            wolfSSL_X509_free(ssl->ourCert);
            ssl->ourCert = NULL;
            #endif
            ssl->buffers.weOwnCert = 0;
 800da98:	687b      	ldr	r3, [r7, #4]
 800da9a:	2200      	movs	r2, #0
 800da9c:	f883 2144 	strb.w	r2, [r3, #324]	@ 0x144
        }

        if (ssl->buffers.weOwnCertChain) {
 800daa0:	687b      	ldr	r3, [r7, #4]
 800daa2:	f893 3145 	ldrb.w	r3, [r3, #325]	@ 0x145
 800daa6:	2b00      	cmp	r3, #0
 800daa8:	d009      	beq.n	800dabe <wolfSSL_UnloadCertsKeys+0x5e>
            WOLFSSL_MSG("Unloading cert chain");
            FreeDer(&ssl->buffers.certChain);
 800daaa:	687b      	ldr	r3, [r7, #4]
 800daac:	f503 73c0 	add.w	r3, r3, #384	@ 0x180
 800dab0:	4618      	mov	r0, r3
 800dab2:	f00b fa63 	bl	8018f7c <FreeDer>
            ssl->buffers.weOwnCertChain = 0;
 800dab6:	687b      	ldr	r3, [r7, #4]
 800dab8:	2200      	movs	r2, #0
 800daba:	f883 2145 	strb.w	r2, [r3, #325]	@ 0x145
        }

        if (ssl->buffers.weOwnKey) {
 800dabe:	687b      	ldr	r3, [r7, #4]
 800dac0:	f893 3146 	ldrb.w	r3, [r3, #326]	@ 0x146
 800dac4:	2b00      	cmp	r3, #0
 800dac6:	d015      	beq.n	800daf4 <wolfSSL_UnloadCertsKeys+0x94>
            WOLFSSL_MSG("Unloading key");
            ForceZero(ssl->buffers.key->buffer, ssl->buffers.key->length);
 800dac8:	687b      	ldr	r3, [r7, #4]
 800daca:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
 800dace:	681a      	ldr	r2, [r3, #0]
 800dad0:	687b      	ldr	r3, [r7, #4]
 800dad2:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
 800dad6:	689b      	ldr	r3, [r3, #8]
 800dad8:	4619      	mov	r1, r3
 800dada:	4610      	mov	r0, r2
 800dadc:	f7fd fb37 	bl	800b14e <ForceZero>
            FreeDer(&ssl->buffers.key);
 800dae0:	687b      	ldr	r3, [r7, #4]
 800dae2:	f503 73b8 	add.w	r3, r3, #368	@ 0x170
 800dae6:	4618      	mov	r0, r3
 800dae8:	f00b fa48 	bl	8018f7c <FreeDer>
        #ifdef WOLFSSL_BLIND_PRIVATE_KEY
            FreeDer(&ssl->buffers.keyMask);
        #endif
            ssl->buffers.weOwnKey = 0;
 800daec:	687b      	ldr	r3, [r7, #4]
 800daee:	2200      	movs	r2, #0
 800daf0:	f883 2146 	strb.w	r2, [r3, #326]	@ 0x146
        #endif
            ssl->buffers.weOwnAltKey = 0;
        }
#endif /* WOLFSSL_DUAL_ALG_CERTS */

        return WOLFSSL_SUCCESS;
 800daf4:	2301      	movs	r3, #1
    }
 800daf6:	4618      	mov	r0, r3
 800daf8:	3708      	adds	r7, #8
 800dafa:	46bd      	mov	sp, r7
 800dafc:	bd80      	pop	{r7, pc}
	...

0800db00 <wolfSSL_ERR_sys_func>:
    static const char WOLFSSL_SYS_SETSOCKOPT_T[]    = "setsockopt";
    static const char WOLFSSL_SYS_SOCKET_T[]        = "socket";

    /* switch with int mapped to function name for compatibility */
    static const char* wolfSSL_ERR_sys_func(int fun)
    {
 800db00:	b480      	push	{r7}
 800db02:	b083      	sub	sp, #12
 800db04:	af00      	add	r7, sp, #0
 800db06:	6078      	str	r0, [r7, #4]
        switch (fun) {
 800db08:	687b      	ldr	r3, [r7, #4]
 800db0a:	2b0f      	cmp	r3, #15
 800db0c:	d842      	bhi.n	800db94 <wolfSSL_ERR_sys_func+0x94>
 800db0e:	a201      	add	r2, pc, #4	@ (adr r2, 800db14 <wolfSSL_ERR_sys_func+0x14>)
 800db10:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800db14:	0800db55 	.word	0x0800db55
 800db18:	0800db59 	.word	0x0800db59
 800db1c:	0800db5d 	.word	0x0800db5d
 800db20:	0800db61 	.word	0x0800db61
 800db24:	0800db65 	.word	0x0800db65
 800db28:	0800db69 	.word	0x0800db69
 800db2c:	0800db6d 	.word	0x0800db6d
 800db30:	0800db71 	.word	0x0800db71
 800db34:	0800db75 	.word	0x0800db75
 800db38:	0800db79 	.word	0x0800db79
 800db3c:	0800db7d 	.word	0x0800db7d
 800db40:	0800db81 	.word	0x0800db81
 800db44:	0800db85 	.word	0x0800db85
 800db48:	0800db89 	.word	0x0800db89
 800db4c:	0800db8d 	.word	0x0800db8d
 800db50:	0800db91 	.word	0x0800db91
            case WOLFSSL_SYS_ACCEPT:      return WOLFSSL_SYS_ACCEPT_T;
 800db54:	4b13      	ldr	r3, [pc, #76]	@ (800dba4 <wolfSSL_ERR_sys_func+0xa4>)
 800db56:	e01e      	b.n	800db96 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_BIND:        return WOLFSSL_SYS_BIND_T;
 800db58:	4b13      	ldr	r3, [pc, #76]	@ (800dba8 <wolfSSL_ERR_sys_func+0xa8>)
 800db5a:	e01c      	b.n	800db96 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_CONNECT:     return WOLFSSL_SYS_CONNECT_T;
 800db5c:	4b13      	ldr	r3, [pc, #76]	@ (800dbac <wolfSSL_ERR_sys_func+0xac>)
 800db5e:	e01a      	b.n	800db96 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_FOPEN:       return WOLFSSL_SYS_FOPEN_T;
 800db60:	4b13      	ldr	r3, [pc, #76]	@ (800dbb0 <wolfSSL_ERR_sys_func+0xb0>)
 800db62:	e018      	b.n	800db96 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_FREAD:       return WOLFSSL_SYS_FREAD_T;
 800db64:	4b13      	ldr	r3, [pc, #76]	@ (800dbb4 <wolfSSL_ERR_sys_func+0xb4>)
 800db66:	e016      	b.n	800db96 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_GETADDRINFO: return WOLFSSL_SYS_GETADDRINFO_T;
 800db68:	4b13      	ldr	r3, [pc, #76]	@ (800dbb8 <wolfSSL_ERR_sys_func+0xb8>)
 800db6a:	e014      	b.n	800db96 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_GETSOCKOPT:  return WOLFSSL_SYS_GETSOCKOPT_T;
 800db6c:	4b13      	ldr	r3, [pc, #76]	@ (800dbbc <wolfSSL_ERR_sys_func+0xbc>)
 800db6e:	e012      	b.n	800db96 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_GETSOCKNAME: return WOLFSSL_SYS_GETSOCKNAME_T;
 800db70:	4b13      	ldr	r3, [pc, #76]	@ (800dbc0 <wolfSSL_ERR_sys_func+0xc0>)
 800db72:	e010      	b.n	800db96 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_GETHOSTBYNAME: return WOLFSSL_SYS_GETHOSTBYNAME_T;
 800db74:	4b13      	ldr	r3, [pc, #76]	@ (800dbc4 <wolfSSL_ERR_sys_func+0xc4>)
 800db76:	e00e      	b.n	800db96 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_GETNAMEINFO: return WOLFSSL_SYS_GETNAMEINFO_T;
 800db78:	4b13      	ldr	r3, [pc, #76]	@ (800dbc8 <wolfSSL_ERR_sys_func+0xc8>)
 800db7a:	e00c      	b.n	800db96 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_GETSERVBYNAME: return WOLFSSL_SYS_GETSERVBYNAME_T;
 800db7c:	4b13      	ldr	r3, [pc, #76]	@ (800dbcc <wolfSSL_ERR_sys_func+0xcc>)
 800db7e:	e00a      	b.n	800db96 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_IOCTLSOCKET: return WOLFSSL_SYS_IOCTLSOCKET_T;
 800db80:	4b13      	ldr	r3, [pc, #76]	@ (800dbd0 <wolfSSL_ERR_sys_func+0xd0>)
 800db82:	e008      	b.n	800db96 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_LISTEN:      return WOLFSSL_SYS_LISTEN_T;
 800db84:	4b13      	ldr	r3, [pc, #76]	@ (800dbd4 <wolfSSL_ERR_sys_func+0xd4>)
 800db86:	e006      	b.n	800db96 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_OPENDIR:     return WOLFSSL_SYS_OPENDIR_T;
 800db88:	4b13      	ldr	r3, [pc, #76]	@ (800dbd8 <wolfSSL_ERR_sys_func+0xd8>)
 800db8a:	e004      	b.n	800db96 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_SETSOCKOPT:  return WOLFSSL_SYS_SETSOCKOPT_T;
 800db8c:	4b13      	ldr	r3, [pc, #76]	@ (800dbdc <wolfSSL_ERR_sys_func+0xdc>)
 800db8e:	e002      	b.n	800db96 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_SOCKET:      return WOLFSSL_SYS_SOCKET_T;
 800db90:	4b13      	ldr	r3, [pc, #76]	@ (800dbe0 <wolfSSL_ERR_sys_func+0xe0>)
 800db92:	e000      	b.n	800db96 <wolfSSL_ERR_sys_func+0x96>
            default:
                return "NULL";
 800db94:	4b13      	ldr	r3, [pc, #76]	@ (800dbe4 <wolfSSL_ERR_sys_func+0xe4>)
        }
    }
 800db96:	4618      	mov	r0, r3
 800db98:	370c      	adds	r7, #12
 800db9a:	46bd      	mov	sp, r7
 800db9c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dba0:	4770      	bx	lr
 800dba2:	bf00      	nop
 800dba4:	08030d44 	.word	0x08030d44
 800dba8:	08030d4c 	.word	0x08030d4c
 800dbac:	08030d54 	.word	0x08030d54
 800dbb0:	08030d5c 	.word	0x08030d5c
 800dbb4:	08030d64 	.word	0x08030d64
 800dbb8:	08030d6c 	.word	0x08030d6c
 800dbbc:	08030d78 	.word	0x08030d78
 800dbc0:	08030d84 	.word	0x08030d84
 800dbc4:	08030d90 	.word	0x08030d90
 800dbc8:	08030da0 	.word	0x08030da0
 800dbcc:	08030dac 	.word	0x08030dac
 800dbd0:	08030dbc 	.word	0x08030dbc
 800dbd4:	08030dc8 	.word	0x08030dc8
 800dbd8:	08030dd0 	.word	0x08030dd0
 800dbdc:	08030dd8 	.word	0x08030dd8
 800dbe0:	08030de4 	.word	0x08030de4
 800dbe4:	08029fbc 	.word	0x08029fbc

0800dbe8 <wolfSSL_ERR_put_error>:
#endif /* DEBUG_WOLFSSL */


    void wolfSSL_ERR_put_error(int lib, int fun, int err, const char* file,
            int line)
    {
 800dbe8:	b580      	push	{r7, lr}
 800dbea:	b086      	sub	sp, #24
 800dbec:	af02      	add	r7, sp, #8
 800dbee:	60f8      	str	r0, [r7, #12]
 800dbf0:	60b9      	str	r1, [r7, #8]
 800dbf2:	607a      	str	r2, [r7, #4]
 800dbf4:	603b      	str	r3, [r7, #0]
        (void)fun;
        (void)file;
        (void)line;
        WOLFSSL_ERROR(err);
        #else
        WOLFSSL_ERROR_LINE(err, wolfSSL_ERR_sys_func(fun), (unsigned int)line,
 800dbf6:	68b8      	ldr	r0, [r7, #8]
 800dbf8:	f7ff ff82 	bl	800db00 <wolfSSL_ERR_sys_func>
 800dbfc:	4601      	mov	r1, r0
 800dbfe:	69ba      	ldr	r2, [r7, #24]
 800dc00:	2300      	movs	r3, #0
 800dc02:	9300      	str	r3, [sp, #0]
 800dc04:	683b      	ldr	r3, [r7, #0]
 800dc06:	6878      	ldr	r0, [r7, #4]
 800dc08:	f010 fef2 	bl	801e9f0 <WOLFSSL_ERROR_LINE>
            file, NULL);
        #endif
        (void)lib;
    }
 800dc0c:	bf00      	nop
 800dc0e:	3710      	adds	r7, #16
 800dc10:	46bd      	mov	sp, r7
 800dc12:	bd80      	pop	{r7, pc}

0800dc14 <wolfSSL_sk_CIPHER_free>:
/* Free the structure for WOLFSSL_CIPHER stack
 *
 * sk  stack to free nodes in
 */
void wolfSSL_sk_CIPHER_free(WOLF_STACK_OF(WOLFSSL_CIPHER)* sk)
{
 800dc14:	b580      	push	{r7, lr}
 800dc16:	b082      	sub	sp, #8
 800dc18:	af00      	add	r7, sp, #0
 800dc1a:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_sk_CIPHER_free");

    wolfSSL_sk_free(sk);
 800dc1c:	6878      	ldr	r0, [r7, #4]
 800dc1e:	f000 f867 	bl	800dcf0 <wolfSSL_sk_free>
}
 800dc22:	bf00      	nop
 800dc24:	3708      	adds	r7, #8
 800dc26:	46bd      	mov	sp, r7
 800dc28:	bd80      	pop	{r7, pc}

0800dc2a <wolfSSL_ERR_GET_LIB>:
#ifdef WOLFSSL_DEBUG_TRACE_ERROR_CODES_H
#include <wolfssl/debug-untrace-error-codes.h>
#endif

int wolfSSL_ERR_GET_LIB(unsigned long err)
{
 800dc2a:	b480      	push	{r7}
 800dc2c:	b085      	sub	sp, #20
 800dc2e:	af00      	add	r7, sp, #0
 800dc30:	6078      	str	r0, [r7, #4]
    unsigned long value;

    value = (err & 0xFFFFFFL);
 800dc32:	687b      	ldr	r3, [r7, #4]
 800dc34:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
 800dc38:	60fb      	str	r3, [r7, #12]
    switch (value) {
 800dc3a:	68fb      	ldr	r3, [r7, #12]
 800dc3c:	f5b3 7f01 	cmp.w	r3, #516	@ 0x204
 800dc40:	d223      	bcs.n	800dc8a <wolfSSL_ERR_GET_LIB+0x60>
 800dc42:	68fb      	ldr	r3, [r7, #12]
 800dc44:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800dc48:	d21b      	bcs.n	800dc82 <wolfSSL_ERR_GET_LIB+0x58>
 800dc4a:	68fb      	ldr	r3, [r7, #12]
 800dc4c:	f240 12ff 	movw	r2, #511	@ 0x1ff
 800dc50:	4293      	cmp	r3, r2
 800dc52:	d018      	beq.n	800dc86 <wolfSSL_ERR_GET_LIB+0x5c>
 800dc54:	68fb      	ldr	r3, [r7, #12]
 800dc56:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800dc5a:	d216      	bcs.n	800dc8a <wolfSSL_ERR_GET_LIB+0x60>
 800dc5c:	68fb      	ldr	r3, [r7, #12]
 800dc5e:	f5b3 7fff 	cmp.w	r3, #510	@ 0x1fe
 800dc62:	d812      	bhi.n	800dc8a <wolfSSL_ERR_GET_LIB+0x60>
 800dc64:	68fb      	ldr	r3, [r7, #12]
 800dc66:	f5b3 7ffd 	cmp.w	r3, #506	@ 0x1fa
 800dc6a:	d808      	bhi.n	800dc7e <wolfSSL_ERR_GET_LIB+0x54>
 800dc6c:	68fb      	ldr	r3, [r7, #12]
 800dc6e:	2ba2      	cmp	r3, #162	@ 0xa2
 800dc70:	d005      	beq.n	800dc7e <wolfSSL_ERR_GET_LIB+0x54>
 800dc72:	68fb      	ldr	r3, [r7, #12]
 800dc74:	f5b3 7f99 	cmp.w	r3, #306	@ 0x132
 800dc78:	d107      	bne.n	800dc8a <wolfSSL_ERR_GET_LIB+0x60>
    case -PARSE_ERROR:
        return WOLFSSL_ERR_LIB_SSL;
 800dc7a:	2314      	movs	r3, #20
 800dc7c:	e006      	b.n	800dc8c <wolfSSL_ERR_GET_LIB+0x62>
    case -ASN_NO_PEM_HEADER:
    case -WOLFSSL_PEM_R_NO_START_LINE_E:
    case -WOLFSSL_PEM_R_PROBLEMS_GETTING_PASSWORD_E:
    case -WOLFSSL_PEM_R_BAD_PASSWORD_READ_E:
    case -WOLFSSL_PEM_R_BAD_DECRYPT_E:
        return WOLFSSL_ERR_LIB_PEM;
 800dc7e:	2309      	movs	r3, #9
 800dc80:	e004      	b.n	800dc8c <wolfSSL_ERR_GET_LIB+0x62>
    case -WOLFSSL_EVP_R_BAD_DECRYPT_E:
    case -WOLFSSL_EVP_R_BN_DECODE_ERROR:
    case -WOLFSSL_EVP_R_DECODE_ERROR:
    case -WOLFSSL_EVP_R_PRIVATE_KEY_DECODE_ERROR:
        return WOLFSSL_ERR_LIB_EVP;
 800dc82:	230b      	movs	r3, #11
 800dc84:	e002      	b.n	800dc8c <wolfSSL_ERR_GET_LIB+0x62>
    case -WOLFSSL_ASN1_R_HEADER_TOO_LONG_E:
        return WOLFSSL_ERR_LIB_ASN1;
 800dc86:	230c      	movs	r3, #12
 800dc88:	e000      	b.n	800dc8c <wolfSSL_ERR_GET_LIB+0x62>
    default:
        return 0;
 800dc8a:	2300      	movs	r3, #0
    }
}
 800dc8c:	4618      	mov	r0, r3
 800dc8e:	3714      	adds	r7, #20
 800dc90:	46bd      	mov	sp, r7
 800dc92:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dc96:	4770      	bx	lr

0800dc98 <wolfSSL_ERR_GET_REASON>:
 * error values are typically negative.
 *
 * Returns the error reason
 */
int wolfSSL_ERR_GET_REASON(unsigned long err)
{
 800dc98:	b480      	push	{r7}
 800dc9a:	b085      	sub	sp, #20
 800dc9c:	af00      	add	r7, sp, #0
 800dc9e:	6078      	str	r0, [r7, #4]
    int ret = (int)err;
 800dca0:	687b      	ldr	r3, [r7, #4]
 800dca2:	60fb      	str	r3, [r7, #12]
    if (err == ((ERR_LIB_ASN1 << 24) | ASN1_R_HEADER_TOO_LONG))
        return ASN1_R_HEADER_TOO_LONG;
#endif

    /* check if error value is in range of wolfCrypt or wolfSSL errors */
    ret = 0 - ret; /* setting as negative value */
 800dca4:	68fb      	ldr	r3, [r7, #12]
 800dca6:	425b      	negs	r3, r3
 800dca8:	60fb      	str	r3, [r7, #12]

    if ((ret <= WC_SPAN1_FIRST_E && ret >= WC_SPAN1_LAST_E) ||
 800dcaa:	68fb      	ldr	r3, [r7, #12]
 800dcac:	f113 0f60 	cmn.w	r3, #96	@ 0x60
 800dcb0:	da03      	bge.n	800dcba <wolfSSL_ERR_GET_REASON+0x22>
 800dcb2:	68fb      	ldr	r3, [r7, #12]
 800dcb4:	f513 7f96 	cmn.w	r3, #300	@ 0x12c
 800dcb8:	dc0f      	bgt.n	800dcda <wolfSSL_ERR_GET_REASON+0x42>
 800dcba:	68fb      	ldr	r3, [r7, #12]
 800dcbc:	f513 7f7a 	cmn.w	r3, #1000	@ 0x3e8
 800dcc0:	dc03      	bgt.n	800dcca <wolfSSL_ERR_GET_REASON+0x32>
        (ret <= WC_SPAN2_FIRST_E && ret >= WC_SPAN2_LAST_E) ||
 800dcc2:	68fb      	ldr	r3, [r7, #12]
 800dcc4:	f513 7f7a 	cmn.w	r3, #1000	@ 0x3e8
 800dcc8:	da07      	bge.n	800dcda <wolfSSL_ERR_GET_REASON+0x42>
 800dcca:	68fb      	ldr	r3, [r7, #12]
 800dccc:	f513 7f96 	cmn.w	r3, #300	@ 0x12c
 800dcd0:	da05      	bge.n	800dcde <wolfSSL_ERR_GET_REASON+0x46>
        (ret <= WOLFSSL_FIRST_E && ret >= WOLFSSL_LAST_E))
 800dcd2:	68fb      	ldr	r3, [r7, #12]
 800dcd4:	f513 7f01 	cmn.w	r3, #516	@ 0x204
 800dcd8:	db01      	blt.n	800dcde <wolfSSL_ERR_GET_REASON+0x46>
    {
        return ret;
 800dcda:	68fb      	ldr	r3, [r7, #12]
 800dcdc:	e002      	b.n	800dce4 <wolfSSL_ERR_GET_REASON+0x4c>
    }
    else {
        WOLFSSL_MSG("Not in range of typical error values");
        ret = (int)err;
 800dcde:	687b      	ldr	r3, [r7, #4]
 800dce0:	60fb      	str	r3, [r7, #12]
    }

    return ret;
 800dce2:	68fb      	ldr	r3, [r7, #12]
}
 800dce4:	4618      	mov	r0, r3
 800dce6:	3714      	adds	r7, #20
 800dce8:	46bd      	mov	sp, r7
 800dcea:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dcee:	4770      	bx	lr

0800dcf0 <wolfSSL_sk_free>:
    return NULL;
}

/* Free the just the stack structure */
void wolfSSL_sk_free(WOLFSSL_STACK* sk)
{
 800dcf0:	b580      	push	{r7, lr}
 800dcf2:	b084      	sub	sp, #16
 800dcf4:	af00      	add	r7, sp, #0
 800dcf6:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_sk_free");

    while (sk != NULL) {
 800dcf8:	e00c      	b.n	800dd14 <wolfSSL_sk_free+0x24>
        WOLFSSL_STACK* next = sk->next;
 800dcfa:	687b      	ldr	r3, [r7, #4]
 800dcfc:	691b      	ldr	r3, [r3, #16]
 800dcfe:	60fb      	str	r3, [r7, #12]
        XFREE(sk, NULL, DYNAMIC_TYPE_OPENSSL);
 800dd00:	687b      	ldr	r3, [r7, #4]
 800dd02:	60bb      	str	r3, [r7, #8]
 800dd04:	68bb      	ldr	r3, [r7, #8]
 800dd06:	2b00      	cmp	r3, #0
 800dd08:	d002      	beq.n	800dd10 <wolfSSL_sk_free+0x20>
 800dd0a:	68b8      	ldr	r0, [r7, #8]
 800dd0c:	f010 fed8 	bl	801eac0 <wolfSSL_Free>
        sk = next;
 800dd10:	68fb      	ldr	r3, [r7, #12]
 800dd12:	607b      	str	r3, [r7, #4]
    while (sk != NULL) {
 800dd14:	687b      	ldr	r3, [r7, #4]
 800dd16:	2b00      	cmp	r3, #0
 800dd18:	d1ef      	bne.n	800dcfa <wolfSSL_sk_free+0xa>
    }
}
 800dd1a:	bf00      	nop
 800dd1c:	bf00      	nop
 800dd1e:	3710      	adds	r7, #16
 800dd20:	46bd      	mov	sp, r7
 800dd22:	bd80      	pop	{r7, pc}

0800dd24 <wolfSSL_sk_pop_free>:
}

/* Free all nodes in a stack including the pushed objects */
void wolfSSL_sk_pop_free(WOLF_STACK_OF(WOLFSSL_ASN1_OBJECT)* sk,
                                                       wolfSSL_sk_freefunc func)
{
 800dd24:	b580      	push	{r7, lr}
 800dd26:	b084      	sub	sp, #16
 800dd28:	af00      	add	r7, sp, #0
 800dd2a:	6078      	str	r0, [r7, #4]
 800dd2c:	6039      	str	r1, [r7, #0]
    WOLFSSL_ENTER("wolfSSL_sk_pop_free");

    if (sk == NULL) {
 800dd2e:	687b      	ldr	r3, [r7, #4]
 800dd30:	2b00      	cmp	r3, #0
 800dd32:	d069      	beq.n	800de08 <wolfSSL_sk_pop_free+0xe4>
    */
    if (sk->type == STACK_TYPE_ACCESS_DESCRIPTION) {
        func = (wolfSSL_sk_freefunc)wolfSSL_ACCESS_DESCRIPTION_free;
    }
    #endif
    if (func == NULL) {
 800dd34:	683b      	ldr	r3, [r7, #0]
 800dd36:	2b00      	cmp	r3, #0
 800dd38:	d162      	bne.n	800de00 <wolfSSL_sk_pop_free+0xdc>
        switch(sk->type) {
 800dd3a:	687b      	ldr	r3, [r7, #4]
 800dd3c:	7d1b      	ldrb	r3, [r3, #20]
 800dd3e:	2b12      	cmp	r3, #18
 800dd40:	d843      	bhi.n	800ddca <wolfSSL_sk_pop_free+0xa6>
 800dd42:	a201      	add	r2, pc, #4	@ (adr r2, 800dd48 <wolfSSL_sk_pop_free+0x24>)
 800dd44:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800dd48:	0800dd95 	.word	0x0800dd95
 800dd4c:	0800dda7 	.word	0x0800dda7
 800dd50:	0800ddc5 	.word	0x0800ddc5
 800dd54:	0800dd9b 	.word	0x0800dd9b
 800dd58:	0800ddad 	.word	0x0800ddad
 800dd5c:	0800ddcb 	.word	0x0800ddcb
 800dd60:	0800ddcb 	.word	0x0800ddcb
 800dd64:	0800ddbf 	.word	0x0800ddbf
 800dd68:	0800ddcb 	.word	0x0800ddcb
 800dd6c:	0800ddb3 	.word	0x0800ddb3
 800dd70:	0800ddcb 	.word	0x0800ddcb
 800dd74:	0800ddcb 	.word	0x0800ddcb
 800dd78:	0800ddcb 	.word	0x0800ddcb
 800dd7c:	0800ddcb 	.word	0x0800ddcb
 800dd80:	0800ddcb 	.word	0x0800ddcb
 800dd84:	0800dda1 	.word	0x0800dda1
 800dd88:	0800ddcb 	.word	0x0800ddcb
 800dd8c:	0800ddb9 	.word	0x0800ddb9
 800dd90:	0800ddcb 	.word	0x0800ddcb
            #if defined(OPENSSL_ALL)
                func = (wolfSSL_sk_freefunc)wolfSSL_ACCESS_DESCRIPTION_free;
            #endif
                break;
            case STACK_TYPE_X509:
                func = (wolfSSL_sk_freefunc)wolfSSL_X509_free;
 800dd94:	4b1e      	ldr	r3, [pc, #120]	@ (800de10 <wolfSSL_sk_pop_free+0xec>)
 800dd96:	603b      	str	r3, [r7, #0]
                break;
 800dd98:	e018      	b.n	800ddcc <wolfSSL_sk_pop_free+0xa8>
            #ifdef OPENSSL_ALL
                func = (wolfSSL_sk_freefunc)wolfSSL_X509_OBJECT_free;
            #endif
                break;
            case STACK_TYPE_OBJ:
                func = (wolfSSL_sk_freefunc)wolfSSL_ASN1_OBJECT_free;
 800dd9a:	4b1e      	ldr	r3, [pc, #120]	@ (800de14 <wolfSSL_sk_pop_free+0xf0>)
 800dd9c:	603b      	str	r3, [r7, #0]
                break;
 800dd9e:	e015      	b.n	800ddcc <wolfSSL_sk_pop_free+0xa8>
            case STACK_TYPE_DIST_POINT:
            #ifdef OPENSSL_EXTRA
                func = (wolfSSL_sk_freefunc)wolfSSL_DIST_POINT_free;
 800dda0:	4b1d      	ldr	r3, [pc, #116]	@ (800de18 <wolfSSL_sk_pop_free+0xf4>)
 800dda2:	603b      	str	r3, [r7, #0]
            #endif
                break;
 800dda4:	e012      	b.n	800ddcc <wolfSSL_sk_pop_free+0xa8>
            case STACK_TYPE_GEN_NAME:
                func = (wolfSSL_sk_freefunc)wolfSSL_GENERAL_NAME_free;
 800dda6:	4b1d      	ldr	r3, [pc, #116]	@ (800de1c <wolfSSL_sk_pop_free+0xf8>)
 800dda8:	603b      	str	r3, [r7, #0]
                break;
 800ddaa:	e00f      	b.n	800ddcc <wolfSSL_sk_pop_free+0xa8>
            case STACK_TYPE_STRING:
            #if defined(WOLFSSL_NGINX) || defined(WOLFSSL_HAPROXY) || \
                defined(OPENSSL_EXTRA) || defined(OPENSSL_ALL)
                func = (wolfSSL_sk_freefunc)wolfSSL_WOLFSSL_STRING_free;
 800ddac:	4b1c      	ldr	r3, [pc, #112]	@ (800de20 <wolfSSL_sk_pop_free+0xfc>)
 800ddae:	603b      	str	r3, [r7, #0]
            #endif
                break;
 800ddb0:	e00c      	b.n	800ddcc <wolfSSL_sk_pop_free+0xa8>
            case STACK_TYPE_X509_NAME:
            #if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) \
                && !defined(WOLFCRYPT_ONLY)
                func = (wolfSSL_sk_freefunc)wolfSSL_X509_NAME_free;
 800ddb2:	4b1c      	ldr	r3, [pc, #112]	@ (800de24 <wolfSSL_sk_pop_free+0x100>)
 800ddb4:	603b      	str	r3, [r7, #0]
            #endif
                break;
 800ddb6:	e009      	b.n	800ddcc <wolfSSL_sk_pop_free+0xa8>
            case STACK_TYPE_X509_NAME_ENTRY:
            #if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) \
                && !defined(WOLFCRYPT_ONLY)
                func = (wolfSSL_sk_freefunc)wolfSSL_X509_NAME_ENTRY_free;
 800ddb8:	4b1b      	ldr	r3, [pc, #108]	@ (800de28 <wolfSSL_sk_pop_free+0x104>)
 800ddba:	603b      	str	r3, [r7, #0]
            #endif
                break;
 800ddbc:	e006      	b.n	800ddcc <wolfSSL_sk_pop_free+0xa8>
            case STACK_TYPE_X509_EXT:
            #if defined(OPENSSL_ALL) || defined(OPENSSL_EXTRA)
                func = (wolfSSL_sk_freefunc)wolfSSL_X509_EXTENSION_free;
 800ddbe:	4b1b      	ldr	r3, [pc, #108]	@ (800de2c <wolfSSL_sk_pop_free+0x108>)
 800ddc0:	603b      	str	r3, [r7, #0]
            #endif
                break;
 800ddc2:	e003      	b.n	800ddcc <wolfSSL_sk_pop_free+0xa8>
                func = (wolfSSL_sk_freefunc)wolfSSL_X509_INFO_free;
            #endif
                break;
            case STACK_TYPE_BIO:
#if !defined(NO_BIO) && defined(OPENSSL_EXTRA)
                func = (wolfSSL_sk_freefunc)wolfSSL_BIO_vfree;
 800ddc4:	4b1a      	ldr	r3, [pc, #104]	@ (800de30 <wolfSSL_sk_pop_free+0x10c>)
 800ddc6:	603b      	str	r3, [r7, #0]
#endif
                break;
 800ddc8:	e000      	b.n	800ddcc <wolfSSL_sk_pop_free+0xa8>
#endif
                break;
            case STACK_TYPE_CIPHER:
            case STACK_TYPE_NULL:
            default:
                break;
 800ddca:	bf00      	nop
        }
    }

    while (sk != NULL) {
 800ddcc:	e018      	b.n	800de00 <wolfSSL_sk_pop_free+0xdc>
        WOLFSSL_STACK* next = sk->next;
 800ddce:	687b      	ldr	r3, [r7, #4]
 800ddd0:	691b      	ldr	r3, [r3, #16]
 800ddd2:	60fb      	str	r3, [r7, #12]

        if (func != NULL) {
 800ddd4:	683b      	ldr	r3, [r7, #0]
 800ddd6:	2b00      	cmp	r3, #0
 800ddd8:	d008      	beq.n	800ddec <wolfSSL_sk_pop_free+0xc8>
            if (sk->type != STACK_TYPE_CIPHER)
 800ddda:	687b      	ldr	r3, [r7, #4]
 800dddc:	7d1b      	ldrb	r3, [r3, #20]
 800ddde:	2b05      	cmp	r3, #5
 800dde0:	d004      	beq.n	800ddec <wolfSSL_sk_pop_free+0xc8>
                func(sk->data.generic);
 800dde2:	687b      	ldr	r3, [r7, #4]
 800dde4:	685a      	ldr	r2, [r3, #4]
 800dde6:	683b      	ldr	r3, [r7, #0]
 800dde8:	4610      	mov	r0, r2
 800ddea:	4798      	blx	r3
        }
        XFREE(sk, NULL, DYNAMIC_TYPE_OPENSSL);
 800ddec:	687b      	ldr	r3, [r7, #4]
 800ddee:	60bb      	str	r3, [r7, #8]
 800ddf0:	68bb      	ldr	r3, [r7, #8]
 800ddf2:	2b00      	cmp	r3, #0
 800ddf4:	d002      	beq.n	800ddfc <wolfSSL_sk_pop_free+0xd8>
 800ddf6:	68b8      	ldr	r0, [r7, #8]
 800ddf8:	f010 fe62 	bl	801eac0 <wolfSSL_Free>
        sk = next;
 800ddfc:	68fb      	ldr	r3, [r7, #12]
 800ddfe:	607b      	str	r3, [r7, #4]
    while (sk != NULL) {
 800de00:	687b      	ldr	r3, [r7, #4]
 800de02:	2b00      	cmp	r3, #0
 800de04:	d1e3      	bne.n	800ddce <wolfSSL_sk_pop_free+0xaa>
 800de06:	e000      	b.n	800de0a <wolfSSL_sk_pop_free+0xe6>
        return;
 800de08:	bf00      	nop
    }
}
 800de0a:	3710      	adds	r7, #16
 800de0c:	46bd      	mov	sp, r7
 800de0e:	bd80      	pop	{r7, pc}
 800de10:	0800e347 	.word	0x0800e347
 800de14:	0800b9df 	.word	0x0800b9df
 800de18:	0800e3c7 	.word	0x0800e3c7
 800de1c:	0800e505 	.word	0x0800e505
 800de20:	0800e089 	.word	0x0800e089
 800de24:	0800e577 	.word	0x0800e577
 800de28:	0800e5cf 	.word	0x0800e5cf
 800de2c:	0800e295 	.word	0x0800e295
 800de30:	0800e235 	.word	0x0800e235

0800de34 <wolfSSL_OBJ_nid2obj_ex>:
    }


    WOLFSSL_LOCAL WOLFSSL_ASN1_OBJECT* wolfSSL_OBJ_nid2obj_ex(int id,
                                                WOLFSSL_ASN1_OBJECT* arg_obj)
    {
 800de34:	b590      	push	{r4, r7, lr}
 800de36:	b097      	sub	sp, #92	@ 0x5c
 800de38:	af00      	add	r7, sp, #0
 800de3a:	6078      	str	r0, [r7, #4]
 800de3c:	6039      	str	r1, [r7, #0]
        word32 oidSz = 0;
 800de3e:	2300      	movs	r3, #0
 800de40:	63bb      	str	r3, [r7, #56]	@ 0x38
        int nid = 0;
 800de42:	2300      	movs	r3, #0
 800de44:	657b      	str	r3, [r7, #84]	@ 0x54
        const byte* oid;
        word32 type = 0;
 800de46:	2300      	movs	r3, #0
 800de48:	653b      	str	r3, [r7, #80]	@ 0x50
        WOLFSSL_ASN1_OBJECT* obj = arg_obj;
 800de4a:	683b      	ldr	r3, [r7, #0]
 800de4c:	64fb      	str	r3, [r7, #76]	@ 0x4c
        byte objBuf[MAX_OID_SZ + MAX_LENGTH_SZ + 1]; /* +1 for object tag */
        word32 objSz = 0;
 800de4e:	2300      	movs	r3, #0
 800de50:	64bb      	str	r3, [r7, #72]	@ 0x48
        const char* sName = NULL;
 800de52:	2300      	movs	r3, #0
 800de54:	647b      	str	r3, [r7, #68]	@ 0x44

#ifdef WOLFSSL_DEBUG_OPENSSL
        WOLFSSL_ENTER("wolfSSL_OBJ_nid2obj");
#endif

        for (i = 0; i < (int)WOLFSSL_OBJECT_INFO_SZ; i++) {
 800de56:	2300      	movs	r3, #0
 800de58:	643b      	str	r3, [r7, #64]	@ 0x40
 800de5a:	e02e      	b.n	800deba <wolfSSL_OBJ_nid2obj_ex+0x86>
            if (wolfssl_object_info[i].nid == id) {
 800de5c:	497b      	ldr	r1, [pc, #492]	@ (800e04c <wolfSSL_OBJ_nid2obj_ex+0x218>)
 800de5e:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800de60:	4613      	mov	r3, r2
 800de62:	009b      	lsls	r3, r3, #2
 800de64:	4413      	add	r3, r2
 800de66:	009b      	lsls	r3, r3, #2
 800de68:	440b      	add	r3, r1
 800de6a:	681b      	ldr	r3, [r3, #0]
 800de6c:	687a      	ldr	r2, [r7, #4]
 800de6e:	429a      	cmp	r2, r3
 800de70:	d120      	bne.n	800deb4 <wolfSSL_OBJ_nid2obj_ex+0x80>
                nid = id;
 800de72:	687b      	ldr	r3, [r7, #4]
 800de74:	657b      	str	r3, [r7, #84]	@ 0x54
                id = wolfssl_object_info[i].id;
 800de76:	4975      	ldr	r1, [pc, #468]	@ (800e04c <wolfSSL_OBJ_nid2obj_ex+0x218>)
 800de78:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800de7a:	4613      	mov	r3, r2
 800de7c:	009b      	lsls	r3, r3, #2
 800de7e:	4413      	add	r3, r2
 800de80:	009b      	lsls	r3, r3, #2
 800de82:	440b      	add	r3, r1
 800de84:	3304      	adds	r3, #4
 800de86:	681b      	ldr	r3, [r3, #0]
 800de88:	607b      	str	r3, [r7, #4]
                sName = wolfssl_object_info[i].sName;
 800de8a:	4970      	ldr	r1, [pc, #448]	@ (800e04c <wolfSSL_OBJ_nid2obj_ex+0x218>)
 800de8c:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800de8e:	4613      	mov	r3, r2
 800de90:	009b      	lsls	r3, r3, #2
 800de92:	4413      	add	r3, r2
 800de94:	009b      	lsls	r3, r3, #2
 800de96:	440b      	add	r3, r1
 800de98:	330c      	adds	r3, #12
 800de9a:	681b      	ldr	r3, [r3, #0]
 800de9c:	647b      	str	r3, [r7, #68]	@ 0x44
                type = wolfssl_object_info[i].type;
 800de9e:	496b      	ldr	r1, [pc, #428]	@ (800e04c <wolfSSL_OBJ_nid2obj_ex+0x218>)
 800dea0:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800dea2:	4613      	mov	r3, r2
 800dea4:	009b      	lsls	r3, r3, #2
 800dea6:	4413      	add	r3, r2
 800dea8:	009b      	lsls	r3, r3, #2
 800deaa:	440b      	add	r3, r1
 800deac:	3308      	adds	r3, #8
 800deae:	681b      	ldr	r3, [r3, #0]
 800deb0:	653b      	str	r3, [r7, #80]	@ 0x50
                break;
 800deb2:	e005      	b.n	800dec0 <wolfSSL_OBJ_nid2obj_ex+0x8c>
        for (i = 0; i < (int)WOLFSSL_OBJECT_INFO_SZ; i++) {
 800deb4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800deb6:	3301      	adds	r3, #1
 800deb8:	643b      	str	r3, [r7, #64]	@ 0x40
 800deba:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800debc:	2b50      	cmp	r3, #80	@ 0x50
 800debe:	ddcd      	ble.n	800de5c <wolfSSL_OBJ_nid2obj_ex+0x28>
            }
        }
        if (i == (int)WOLFSSL_OBJECT_INFO_SZ) {
 800dec0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800dec2:	2b51      	cmp	r3, #81	@ 0x51
 800dec4:	d101      	bne.n	800deca <wolfSSL_OBJ_nid2obj_ex+0x96>
            WOLFSSL_MSG("NID not in table");
        #ifdef WOLFSSL_QT
            sName = NULL;
            type = (word32)id;
        #else
            return NULL;
 800dec6:	2300      	movs	r3, #0
 800dec8:	e0bc      	b.n	800e044 <wolfSSL_OBJ_nid2obj_ex+0x210>
        #endif
        }

    #ifdef HAVE_ECC
         if (type == 0 && wc_ecc_get_oid((word32)id, &oid, &oidSz) > 0) {
 800deca:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800decc:	2b00      	cmp	r3, #0
 800dece:	d10c      	bne.n	800deea <wolfSSL_OBJ_nid2obj_ex+0xb6>
 800ded0:	687b      	ldr	r3, [r7, #4]
 800ded2:	f107 0238 	add.w	r2, r7, #56	@ 0x38
 800ded6:	f107 0134 	add.w	r1, r7, #52	@ 0x34
 800deda:	4618      	mov	r0, r3
 800dedc:	f010 f9ec 	bl	801e2b8 <wc_ecc_get_oid>
 800dee0:	4603      	mov	r3, r0
 800dee2:	2b00      	cmp	r3, #0
 800dee4:	dd01      	ble.n	800deea <wolfSSL_OBJ_nid2obj_ex+0xb6>
             type = oidCurveType;
 800dee6:	2303      	movs	r3, #3
 800dee8:	653b      	str	r3, [r7, #80]	@ 0x50
         }
    #endif /* HAVE_ECC */

        if (sName != NULL) {
 800deea:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800deec:	2b00      	cmp	r3, #0
 800deee:	d007      	beq.n	800df00 <wolfSSL_OBJ_nid2obj_ex+0xcc>
            if (XSTRLEN(sName) > WOLFSSL_MAX_SNAME - 1) {
 800def0:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 800def2:	f7f2 f977 	bl	80001e4 <strlen>
 800def6:	4603      	mov	r3, r0
 800def8:	2b27      	cmp	r3, #39	@ 0x27
 800defa:	d901      	bls.n	800df00 <wolfSSL_OBJ_nid2obj_ex+0xcc>
                WOLFSSL_MSG("Attempted short name is too large");
                return NULL;
 800defc:	2300      	movs	r3, #0
 800defe:	e0a1      	b.n	800e044 <wolfSSL_OBJ_nid2obj_ex+0x210>
            }
        }

        oid = OidFromId((word32)id, type, &oidSz);
 800df00:	687b      	ldr	r3, [r7, #4]
 800df02:	f107 0238 	add.w	r2, r7, #56	@ 0x38
 800df06:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 800df08:	4618      	mov	r0, r3
 800df0a:	f006 f8c1 	bl	8014090 <OidFromId>
 800df0e:	4603      	mov	r3, r0
 800df10:	637b      	str	r3, [r7, #52]	@ 0x34

        /* set object ID to buffer */
        if (obj == NULL){
 800df12:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800df14:	2b00      	cmp	r3, #0
 800df16:	d107      	bne.n	800df28 <wolfSSL_OBJ_nid2obj_ex+0xf4>
            obj = wolfSSL_ASN1_OBJECT_new();
 800df18:	f7fd fd3e 	bl	800b998 <wolfSSL_ASN1_OBJECT_new>
 800df1c:	64f8      	str	r0, [r7, #76]	@ 0x4c
            if (obj == NULL) {
 800df1e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800df20:	2b00      	cmp	r3, #0
 800df22:	d101      	bne.n	800df28 <wolfSSL_OBJ_nid2obj_ex+0xf4>
                WOLFSSL_MSG("Issue creating WOLFSSL_ASN1_OBJECT struct");
                return NULL;
 800df24:	2300      	movs	r3, #0
 800df26:	e08d      	b.n	800e044 <wolfSSL_OBJ_nid2obj_ex+0x210>
            }
        }
        obj->nid     = nid;
 800df28:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800df2a:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 800df2c:	639a      	str	r2, [r3, #56]	@ 0x38
        obj->type    = id;
 800df2e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800df30:	687a      	ldr	r2, [r7, #4]
 800df32:	631a      	str	r2, [r3, #48]	@ 0x30
        obj->grp     = (int)type;
 800df34:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800df36:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800df38:	635a      	str	r2, [r3, #52]	@ 0x34

        obj->sName[0] = '\0';
 800df3a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800df3c:	2200      	movs	r2, #0
 800df3e:	721a      	strb	r2, [r3, #8]
        if (sName != NULL) {
 800df40:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800df42:	2b00      	cmp	r3, #0
 800df44:	d00b      	beq.n	800df5e <wolfSSL_OBJ_nid2obj_ex+0x12a>
            XMEMCPY(obj->sName, (char*)sName, XSTRLEN((char*)sName));
 800df46:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800df48:	f103 0408 	add.w	r4, r3, #8
 800df4c:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 800df4e:	f7f2 f949 	bl	80001e4 <strlen>
 800df52:	4603      	mov	r3, r0
 800df54:	461a      	mov	r2, r3
 800df56:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 800df58:	4620      	mov	r0, r4
 800df5a:	f01a fb1f 	bl	802859c <memcpy>
        }

        objBuf[0] = ASN_OBJECT_ID; objSz++;
 800df5e:	2306      	movs	r3, #6
 800df60:	733b      	strb	r3, [r7, #12]
 800df62:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800df64:	3301      	adds	r3, #1
 800df66:	64bb      	str	r3, [r7, #72]	@ 0x48
        objSz += SetLength(oidSz, objBuf + 1);
 800df68:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800df6a:	f107 030c 	add.w	r3, r7, #12
 800df6e:	3301      	adds	r3, #1
 800df70:	4619      	mov	r1, r3
 800df72:	4610      	mov	r0, r2
 800df74:	f007 ff81 	bl	8015e7a <SetLength>
 800df78:	4602      	mov	r2, r0
 800df7a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800df7c:	4413      	add	r3, r2
 800df7e:	64bb      	str	r3, [r7, #72]	@ 0x48
        if (oidSz) {
 800df80:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800df82:	2b00      	cmp	r3, #0
 800df84:	d00c      	beq.n	800dfa0 <wolfSSL_OBJ_nid2obj_ex+0x16c>
            XMEMCPY(objBuf + objSz, oid, oidSz);
 800df86:	f107 020c 	add.w	r2, r7, #12
 800df8a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800df8c:	4413      	add	r3, r2
 800df8e:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 800df90:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800df92:	4618      	mov	r0, r3
 800df94:	f01a fb02 	bl	802859c <memcpy>
            objSz     += oidSz;
 800df98:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800df9a:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800df9c:	4413      	add	r3, r2
 800df9e:	64bb      	str	r3, [r7, #72]	@ 0x48
        }

        if (obj->objSz == 0 || objSz != obj->objSz) {
 800dfa0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800dfa2:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800dfa4:	2b00      	cmp	r3, #0
 800dfa6:	d004      	beq.n	800dfb2 <wolfSSL_OBJ_nid2obj_ex+0x17e>
 800dfa8:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800dfaa:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800dfac:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800dfae:	429a      	cmp	r2, r3
 800dfb0:	d03e      	beq.n	800e030 <wolfSSL_OBJ_nid2obj_ex+0x1fc>
            obj->objSz = objSz;
 800dfb2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800dfb4:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800dfb6:	63da      	str	r2, [r3, #60]	@ 0x3c
            if(((obj->dynamic & WOLFSSL_ASN1_DYNAMIC_DATA) != 0) ||
 800dfb8:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800dfba:	f893 3048 	ldrb.w	r3, [r3, #72]	@ 0x48
 800dfbe:	f003 0302 	and.w	r3, r3, #2
 800dfc2:	2b00      	cmp	r3, #0
 800dfc4:	d103      	bne.n	800dfce <wolfSSL_OBJ_nid2obj_ex+0x19a>
                                                           (obj->obj == NULL)) {
 800dfc6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800dfc8:	685b      	ldr	r3, [r3, #4]
            if(((obj->dynamic & WOLFSSL_ASN1_DYNAMIC_DATA) != 0) ||
 800dfca:	2b00      	cmp	r3, #0
 800dfcc:	d127      	bne.n	800e01e <wolfSSL_OBJ_nid2obj_ex+0x1ea>
                if (obj->obj != NULL)
 800dfce:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800dfd0:	685b      	ldr	r3, [r3, #4]
 800dfd2:	2b00      	cmp	r3, #0
 800dfd4:	d008      	beq.n	800dfe8 <wolfSSL_OBJ_nid2obj_ex+0x1b4>
                    XFREE((byte*)obj->obj, NULL, DYNAMIC_TYPE_ASN1);
 800dfd6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800dfd8:	685b      	ldr	r3, [r3, #4]
 800dfda:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800dfdc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800dfde:	2b00      	cmp	r3, #0
 800dfe0:	d002      	beq.n	800dfe8 <wolfSSL_OBJ_nid2obj_ex+0x1b4>
 800dfe2:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 800dfe4:	f010 fd6c 	bl	801eac0 <wolfSSL_Free>
                obj->obj = (byte*)XMALLOC(obj->objSz, NULL, DYNAMIC_TYPE_ASN1);
 800dfe8:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800dfea:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800dfec:	4618      	mov	r0, r3
 800dfee:	f010 fd4b 	bl	801ea88 <wolfSSL_Malloc>
 800dff2:	4602      	mov	r2, r0
 800dff4:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800dff6:	605a      	str	r2, [r3, #4]
                if (obj->obj == NULL) {
 800dff8:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800dffa:	685b      	ldr	r3, [r3, #4]
 800dffc:	2b00      	cmp	r3, #0
 800dffe:	d104      	bne.n	800e00a <wolfSSL_OBJ_nid2obj_ex+0x1d6>
                    wolfSSL_ASN1_OBJECT_free(obj);
 800e000:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 800e002:	f7fd fcec 	bl	800b9de <wolfSSL_ASN1_OBJECT_free>
                    return NULL;
 800e006:	2300      	movs	r3, #0
 800e008:	e01c      	b.n	800e044 <wolfSSL_OBJ_nid2obj_ex+0x210>
                }
                obj->dynamic |= WOLFSSL_ASN1_DYNAMIC_DATA;
 800e00a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e00c:	f893 3048 	ldrb.w	r3, [r3, #72]	@ 0x48
 800e010:	f043 0302 	orr.w	r3, r3, #2
 800e014:	b2da      	uxtb	r2, r3
 800e016:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e018:	f883 2048 	strb.w	r2, [r3, #72]	@ 0x48
 800e01c:	e008      	b.n	800e030 <wolfSSL_OBJ_nid2obj_ex+0x1fc>
            }
            else {
                obj->dynamic &= ~WOLFSSL_ASN1_DYNAMIC_DATA;
 800e01e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e020:	f893 3048 	ldrb.w	r3, [r3, #72]	@ 0x48
 800e024:	f023 0302 	bic.w	r3, r3, #2
 800e028:	b2da      	uxtb	r2, r3
 800e02a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e02c:	f883 2048 	strb.w	r2, [r3, #72]	@ 0x48
            }
        }
        XMEMCPY((byte*)obj->obj, objBuf, obj->objSz);
 800e030:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e032:	6858      	ldr	r0, [r3, #4]
 800e034:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e036:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 800e038:	f107 030c 	add.w	r3, r7, #12
 800e03c:	4619      	mov	r1, r3
 800e03e:	f01a faad 	bl	802859c <memcpy>

        (void)type;

        return obj;
 800e042:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
    }
 800e044:	4618      	mov	r0, r3
 800e046:	375c      	adds	r7, #92	@ 0x5c
 800e048:	46bd      	mov	sp, r7
 800e04a:	bd90      	pop	{r4, r7, pc}
 800e04c:	08030dec 	.word	0x08030dec

0800e050 <wolfSSL_ERR_peek_last_error>:
        return 0;
    return ConstantCompare((const byte*)a, (const byte*)b, (int)size);
}

unsigned long wolfSSL_ERR_peek_last_error(void)
{
 800e050:	b580      	push	{r7, lr}
 800e052:	b082      	sub	sp, #8
 800e054:	af00      	add	r7, sp, #0

#ifdef WOLFSSL_HAVE_ERROR_QUEUE
    {
        int ret;

        if ((ret = wc_PeekErrorNode(-1, NULL, NULL, NULL)) < 0) {
 800e056:	2300      	movs	r3, #0
 800e058:	2200      	movs	r2, #0
 800e05a:	2100      	movs	r1, #0
 800e05c:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 800e060:	f010 fb3e 	bl	801e6e0 <wc_PeekErrorNode>
 800e064:	6078      	str	r0, [r7, #4]
 800e066:	687b      	ldr	r3, [r7, #4]
 800e068:	2b00      	cmp	r3, #0
 800e06a:	da01      	bge.n	800e070 <wolfSSL_ERR_peek_last_error+0x20>
            WOLFSSL_MSG("Issue peeking at error node in queue");
            return 0;
 800e06c:	2300      	movs	r3, #0
 800e06e:	e005      	b.n	800e07c <wolfSSL_ERR_peek_last_error+0x2c>
        }
        if (ret == -WC_NO_ERR_TRACE(ASN_NO_PEM_HEADER))
 800e070:	687b      	ldr	r3, [r7, #4]
 800e072:	2ba2      	cmp	r3, #162	@ 0xa2
 800e074:	d101      	bne.n	800e07a <wolfSSL_ERR_peek_last_error+0x2a>
            return (WOLFSSL_ERR_LIB_PEM << 24) | -WC_NO_ERR_TRACE(WOLFSSL_PEM_R_NO_START_LINE_E);
 800e076:	4b03      	ldr	r3, [pc, #12]	@ (800e084 <wolfSSL_ERR_peek_last_error+0x34>)
 800e078:	e000      	b.n	800e07c <wolfSSL_ERR_peek_last_error+0x2c>
    #if defined(WOLFSSL_PYTHON)
        if (ret == WC_NO_ERR_TRACE(ASN1_R_HEADER_TOO_LONG))
            return (WOLFSSL_ERR_LIB_ASN1 << 24) | -WC_NO_ERR_TRACE(WOLFSSL_ASN1_R_HEADER_TOO_LONG_E);
    #endif
        return (unsigned long)ret;
 800e07a:	687b      	ldr	r3, [r7, #4]
    }
#else
    return (unsigned long)(0 - NOT_COMPILED_IN);
#endif
}
 800e07c:	4618      	mov	r0, r3
 800e07e:	3708      	adds	r7, #8
 800e080:	46bd      	mov	sp, r7
 800e082:	bd80      	pop	{r7, pc}
 800e084:	090001fb 	.word	0x090001fb

0800e088 <wolfSSL_WOLFSSL_STRING_free>:

    return ret;
}

void wolfSSL_WOLFSSL_STRING_free(WOLFSSL_STRING s)
{
 800e088:	b580      	push	{r7, lr}
 800e08a:	b084      	sub	sp, #16
 800e08c:	af00      	add	r7, sp, #0
 800e08e:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_WOLFSSL_STRING_free");

    XFREE(s, NULL, DYNAMIC_TYPE_OPENSSL);
 800e090:	687b      	ldr	r3, [r7, #4]
 800e092:	60fb      	str	r3, [r7, #12]
 800e094:	68fb      	ldr	r3, [r7, #12]
 800e096:	2b00      	cmp	r3, #0
 800e098:	d002      	beq.n	800e0a0 <wolfSSL_WOLFSSL_STRING_free+0x18>
 800e09a:	68f8      	ldr	r0, [r7, #12]
 800e09c:	f010 fd10 	bl	801eac0 <wolfSSL_Free>
}
 800e0a0:	bf00      	nop
 800e0a2:	3710      	adds	r7, #16
 800e0a4:	46bd      	mov	sp, r7
 800e0a6:	bd80      	pop	{r7, pc}

0800e0a8 <wolfSSL_BIO_free>:
     * Note : If the flag BIO_NOCLOSE is set then freeing memory buffers is up
     *        to the application.
     * Returns 1 on success, 0 on failure
     */
    int wolfSSL_BIO_free(WOLFSSL_BIO* bio)
    {
 800e0a8:	b590      	push	{r4, r7, lr}
 800e0aa:	b08d      	sub	sp, #52	@ 0x34
 800e0ac:	af02      	add	r7, sp, #8
 800e0ae:	6078      	str	r0, [r7, #4]
        int ret;
    #if defined(OPENSSL_ALL) || defined(OPENSSL_EXTRA)
        int doFree = 0;
 800e0b0:	2300      	movs	r3, #0
 800e0b2:	60fb      	str	r3, [r7, #12]
    #endif

        /* unchain?, doesn't matter in goahead since from free all */
        WOLFSSL_ENTER("wolfSSL_BIO_free");
        if (bio) {
 800e0b4:	687b      	ldr	r3, [r7, #4]
 800e0b6:	2b00      	cmp	r3, #0
 800e0b8:	f000 80b7 	beq.w	800e22a <wolfSSL_BIO_free+0x182>

            if (bio->infoCb) {
 800e0bc:	687b      	ldr	r3, [r7, #4]
 800e0be:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800e0c0:	2b00      	cmp	r3, #0
 800e0c2:	d011      	beq.n	800e0e8 <wolfSSL_BIO_free+0x40>
                /* info callback is called before free */
                ret = (int)bio->infoCb(bio, WOLFSSL_BIO_CB_FREE, NULL, 0, 0, 1);
 800e0c4:	687b      	ldr	r3, [r7, #4]
 800e0c6:	6adc      	ldr	r4, [r3, #44]	@ 0x2c
 800e0c8:	2301      	movs	r3, #1
 800e0ca:	9301      	str	r3, [sp, #4]
 800e0cc:	2300      	movs	r3, #0
 800e0ce:	9300      	str	r3, [sp, #0]
 800e0d0:	2300      	movs	r3, #0
 800e0d2:	2200      	movs	r2, #0
 800e0d4:	2101      	movs	r1, #1
 800e0d6:	6878      	ldr	r0, [r7, #4]
 800e0d8:	47a0      	blx	r4
 800e0da:	4603      	mov	r3, r0
 800e0dc:	613b      	str	r3, [r7, #16]
                if (ret <= 0) {
 800e0de:	693b      	ldr	r3, [r7, #16]
 800e0e0:	2b00      	cmp	r3, #0
 800e0e2:	dc01      	bgt.n	800e0e8 <wolfSSL_BIO_free+0x40>
                    return ret;
 800e0e4:	693b      	ldr	r3, [r7, #16]
 800e0e6:	e0a1      	b.n	800e22c <wolfSSL_BIO_free+0x184>
                }
            }

    #if defined(OPENSSL_ALL) || defined(OPENSSL_EXTRA)
            wolfSSL_RefDec(&bio->ref, &doFree, &ret);
 800e0e8:	687b      	ldr	r3, [r7, #4]
 800e0ea:	3368      	adds	r3, #104	@ 0x68
 800e0ec:	2101      	movs	r1, #1
 800e0ee:	4618      	mov	r0, r3
 800e0f0:	f7fd f818 	bl	800b124 <wolfSSL_Atomic_Int_FetchSub>
 800e0f4:	6278      	str	r0, [r7, #36]	@ 0x24
 800e0f6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e0f8:	2b01      	cmp	r3, #1
 800e0fa:	bf0c      	ite	eq
 800e0fc:	2301      	moveq	r3, #1
 800e0fe:	2300      	movne	r3, #0
 800e100:	b2db      	uxtb	r3, r3
 800e102:	60fb      	str	r3, [r7, #12]
 800e104:	2300      	movs	r3, #0
 800e106:	613b      	str	r3, [r7, #16]

            if (!doFree) {
 800e108:	68fb      	ldr	r3, [r7, #12]
 800e10a:	2b00      	cmp	r3, #0
 800e10c:	d101      	bne.n	800e112 <wolfSSL_BIO_free+0x6a>
                /* return success if BIO ref count is not 1 yet */
            #ifdef WOLFSSL_REFCNT_ERROR_RETURN
                return (ret == 0) ? WOLFSSL_SUCCESS : WOLFSSL_FAILURE ;
            #else
                (void)ret;
                return WOLFSSL_SUCCESS;
 800e10e:	2301      	movs	r3, #1
 800e110:	e08c      	b.n	800e22c <wolfSSL_BIO_free+0x184>
        #ifdef HAVE_EX_DATA_CLEANUP_HOOKS
            wolfSSL_CRYPTO_cleanup_ex_data(&bio->ex_data);
        #endif

            /* call custom set free callback */
            if (bio->method && bio->method->freeCb) {
 800e112:	687b      	ldr	r3, [r7, #4]
 800e114:	685b      	ldr	r3, [r3, #4]
 800e116:	2b00      	cmp	r3, #0
 800e118:	d00b      	beq.n	800e132 <wolfSSL_BIO_free+0x8a>
 800e11a:	687b      	ldr	r3, [r7, #4]
 800e11c:	685b      	ldr	r3, [r3, #4]
 800e11e:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
 800e122:	2b00      	cmp	r3, #0
 800e124:	d005      	beq.n	800e132 <wolfSSL_BIO_free+0x8a>
                bio->method->freeCb(bio);
 800e126:	687b      	ldr	r3, [r7, #4]
 800e128:	685b      	ldr	r3, [r3, #4]
 800e12a:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
 800e12e:	6878      	ldr	r0, [r7, #4]
 800e130:	4798      	blx	r3
            }

            /* remove from pair by setting the paired bios pair to NULL */
            if (bio->pair != NULL) {
 800e132:	687b      	ldr	r3, [r7, #4]
 800e134:	691b      	ldr	r3, [r3, #16]
 800e136:	2b00      	cmp	r3, #0
 800e138:	d003      	beq.n	800e142 <wolfSSL_BIO_free+0x9a>
                bio->pair->pair = NULL;
 800e13a:	687b      	ldr	r3, [r7, #4]
 800e13c:	691b      	ldr	r3, [r3, #16]
 800e13e:	2200      	movs	r2, #0
 800e140:	611a      	str	r2, [r3, #16]
            }

            XFREE(bio->ip, bio->heap, DYNAMIC_TYPE_OPENSSL);
 800e142:	687b      	ldr	r3, [r7, #4]
 800e144:	6a1b      	ldr	r3, [r3, #32]
 800e146:	623b      	str	r3, [r7, #32]
 800e148:	6a3b      	ldr	r3, [r7, #32]
 800e14a:	2b00      	cmp	r3, #0
 800e14c:	d002      	beq.n	800e154 <wolfSSL_BIO_free+0xac>
 800e14e:	6a38      	ldr	r0, [r7, #32]
 800e150:	f010 fcb6 	bl	801eac0 <wolfSSL_Free>

            if (bio->shutdown) {
 800e154:	687b      	ldr	r3, [r7, #4]
 800e156:	f893 3051 	ldrb.w	r3, [r3, #81]	@ 0x51
 800e15a:	f003 0302 	and.w	r3, r3, #2
 800e15e:	b2db      	uxtb	r3, r3
 800e160:	2b00      	cmp	r3, #0
 800e162:	d00d      	beq.n	800e180 <wolfSSL_BIO_free+0xd8>
                if (bio->type == WOLFSSL_BIO_SSL && bio->ptr.ssl)
 800e164:	687b      	ldr	r3, [r7, #4]
 800e166:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
 800e16a:	2b03      	cmp	r3, #3
 800e16c:	d108      	bne.n	800e180 <wolfSSL_BIO_free+0xd8>
 800e16e:	687b      	ldr	r3, [r7, #4]
 800e170:	699b      	ldr	r3, [r3, #24]
 800e172:	2b00      	cmp	r3, #0
 800e174:	d004      	beq.n	800e180 <wolfSSL_BIO_free+0xd8>
                    wolfSSL_free(bio->ptr.ssl);
 800e176:	687b      	ldr	r3, [r7, #4]
 800e178:	699b      	ldr	r3, [r3, #24]
 800e17a:	4618      	mov	r0, r3
 800e17c:	f7fe f805 	bl	800c18a <wolfSSL_free>
                }
            #endif
            }
        #endif

            if (bio->shutdown != WOLFSSL_BIO_NOCLOSE) {
 800e180:	687b      	ldr	r3, [r7, #4]
 800e182:	f893 3051 	ldrb.w	r3, [r3, #81]	@ 0x51
 800e186:	f003 0302 	and.w	r3, r3, #2
 800e18a:	b2db      	uxtb	r3, r3
 800e18c:	2b00      	cmp	r3, #0
 800e18e:	d038      	beq.n	800e202 <wolfSSL_BIO_free+0x15a>
                if (bio->type == WOLFSSL_BIO_MEMORY &&
 800e190:	687b      	ldr	r3, [r7, #4]
 800e192:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
 800e196:	2b04      	cmp	r3, #4
 800e198:	d127      	bne.n	800e1ea <wolfSSL_BIO_free+0x142>
                    bio->ptr.mem_buf_data != NULL)
 800e19a:	687b      	ldr	r3, [r7, #4]
 800e19c:	699b      	ldr	r3, [r3, #24]
                if (bio->type == WOLFSSL_BIO_MEMORY &&
 800e19e:	2b00      	cmp	r3, #0
 800e1a0:	d023      	beq.n	800e1ea <wolfSSL_BIO_free+0x142>
                {
                    if (bio->mem_buf != NULL) {
 800e1a2:	687b      	ldr	r3, [r7, #4]
 800e1a4:	681b      	ldr	r3, [r3, #0]
 800e1a6:	2b00      	cmp	r3, #0
 800e1a8:	d013      	beq.n	800e1d2 <wolfSSL_BIO_free+0x12a>
                        if ((byte *)bio->mem_buf->data != bio->ptr.mem_buf_data)
 800e1aa:	687b      	ldr	r3, [r7, #4]
 800e1ac:	681b      	ldr	r3, [r3, #0]
 800e1ae:	681a      	ldr	r2, [r3, #0]
 800e1b0:	687b      	ldr	r3, [r7, #4]
 800e1b2:	699b      	ldr	r3, [r3, #24]
 800e1b4:	429a      	cmp	r2, r3
 800e1b6:	d018      	beq.n	800e1ea <wolfSSL_BIO_free+0x142>
                        {
                            XFREE(bio->ptr.mem_buf_data, bio->heap,
 800e1b8:	687b      	ldr	r3, [r7, #4]
 800e1ba:	699b      	ldr	r3, [r3, #24]
 800e1bc:	61bb      	str	r3, [r7, #24]
 800e1be:	69bb      	ldr	r3, [r7, #24]
 800e1c0:	2b00      	cmp	r3, #0
 800e1c2:	d002      	beq.n	800e1ca <wolfSSL_BIO_free+0x122>
 800e1c4:	69b8      	ldr	r0, [r7, #24]
 800e1c6:	f010 fc7b 	bl	801eac0 <wolfSSL_Free>
                                  DYNAMIC_TYPE_OPENSSL);
                            bio->ptr.mem_buf_data = NULL;
 800e1ca:	687b      	ldr	r3, [r7, #4]
 800e1cc:	2200      	movs	r2, #0
 800e1ce:	619a      	str	r2, [r3, #24]
 800e1d0:	e00b      	b.n	800e1ea <wolfSSL_BIO_free+0x142>
                        }
                    }
                    else {
                        XFREE(bio->ptr.mem_buf_data, bio->heap,
 800e1d2:	687b      	ldr	r3, [r7, #4]
 800e1d4:	699b      	ldr	r3, [r3, #24]
 800e1d6:	61fb      	str	r3, [r7, #28]
 800e1d8:	69fb      	ldr	r3, [r7, #28]
 800e1da:	2b00      	cmp	r3, #0
 800e1dc:	d002      	beq.n	800e1e4 <wolfSSL_BIO_free+0x13c>
 800e1de:	69f8      	ldr	r0, [r7, #28]
 800e1e0:	f010 fc6e 	bl	801eac0 <wolfSSL_Free>
                              DYNAMIC_TYPE_OPENSSL);
                        bio->ptr.mem_buf_data = NULL;
 800e1e4:	687b      	ldr	r3, [r7, #4]
 800e1e6:	2200      	movs	r2, #0
 800e1e8:	619a      	str	r2, [r3, #24]
                    }
                }
                if (bio->mem_buf != NULL) {
 800e1ea:	687b      	ldr	r3, [r7, #4]
 800e1ec:	681b      	ldr	r3, [r3, #0]
 800e1ee:	2b00      	cmp	r3, #0
 800e1f0:	d007      	beq.n	800e202 <wolfSSL_BIO_free+0x15a>
                    wolfSSL_BUF_MEM_free(bio->mem_buf);
 800e1f2:	687b      	ldr	r3, [r7, #4]
 800e1f4:	681b      	ldr	r3, [r3, #0]
 800e1f6:	4618      	mov	r0, r3
 800e1f8:	f000 fdae 	bl	800ed58 <wolfSSL_BUF_MEM_free>
                    bio->mem_buf = NULL;
 800e1fc:	687b      	ldr	r3, [r7, #4]
 800e1fe:	2200      	movs	r2, #0
 800e200:	601a      	str	r2, [r3, #0]
                }
            }

            if (bio->type == WOLFSSL_BIO_MD) {
 800e202:	687b      	ldr	r3, [r7, #4]
 800e204:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
 800e208:	2b08      	cmp	r3, #8
 800e20a:	d104      	bne.n	800e216 <wolfSSL_BIO_free+0x16e>
                wolfSSL_EVP_MD_CTX_free(bio->ptr.md_ctx);
 800e20c:	687b      	ldr	r3, [r7, #4]
 800e20e:	699b      	ldr	r3, [r3, #24]
 800e210:	4618      	mov	r0, r3
 800e212:	f7fd f85c 	bl	800b2ce <wolfSSL_EVP_MD_CTX_free>
            }

            XFREE(bio, 0, DYNAMIC_TYPE_OPENSSL);
 800e216:	687b      	ldr	r3, [r7, #4]
 800e218:	617b      	str	r3, [r7, #20]
 800e21a:	697b      	ldr	r3, [r7, #20]
 800e21c:	2b00      	cmp	r3, #0
 800e21e:	d002      	beq.n	800e226 <wolfSSL_BIO_free+0x17e>
 800e220:	6978      	ldr	r0, [r7, #20]
 800e222:	f010 fc4d 	bl	801eac0 <wolfSSL_Free>
            return WOLFSSL_SUCCESS;
 800e226:	2301      	movs	r3, #1
 800e228:	e000      	b.n	800e22c <wolfSSL_BIO_free+0x184>
        }
        return WOLFSSL_FAILURE;
 800e22a:	2300      	movs	r3, #0
    }
 800e22c:	4618      	mov	r0, r3
 800e22e:	372c      	adds	r7, #44	@ 0x2c
 800e230:	46bd      	mov	sp, r7
 800e232:	bd90      	pop	{r4, r7, pc}

0800e234 <wolfSSL_BIO_vfree>:

    /* like BIO_free, but no return value */
    void wolfSSL_BIO_vfree(WOLFSSL_BIO* bio)
    {
 800e234:	b580      	push	{r7, lr}
 800e236:	b082      	sub	sp, #8
 800e238:	af00      	add	r7, sp, #0
 800e23a:	6078      	str	r0, [r7, #4]
        wolfSSL_BIO_free(bio);
 800e23c:	6878      	ldr	r0, [r7, #4]
 800e23e:	f7ff ff33 	bl	800e0a8 <wolfSSL_BIO_free>
    }
 800e242:	bf00      	nop
 800e244:	3708      	adds	r7, #8
 800e246:	46bd      	mov	sp, r7
 800e248:	bd80      	pop	{r7, pc}

0800e24a <wolfSSL_ASN1_STRING_clear>:
/* Clear out and free internal pointers of ASN.1 STRING object.
 *
 * @param [in] asn1  ASN.1 STRING object.
 */
static void wolfSSL_ASN1_STRING_clear(WOLFSSL_ASN1_STRING* asn1)
{
 800e24a:	b580      	push	{r7, lr}
 800e24c:	b084      	sub	sp, #16
 800e24e:	af00      	add	r7, sp, #0
 800e250:	6078      	str	r0, [r7, #4]
    /* Check we have an object to free. */
    if (asn1 != NULL) {
 800e252:	687b      	ldr	r3, [r7, #4]
 800e254:	2b00      	cmp	r3, #0
 800e256:	d019      	beq.n	800e28c <wolfSSL_ASN1_STRING_clear+0x42>
        /* Dispose of dynamic data. */
        if ((asn1->length > 0) && asn1->isDynamic) {
 800e258:	687b      	ldr	r3, [r7, #4]
 800e25a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800e25c:	2b00      	cmp	r3, #0
 800e25e:	dd10      	ble.n	800e282 <wolfSSL_ASN1_STRING_clear+0x38>
 800e260:	687b      	ldr	r3, [r7, #4]
 800e262:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
 800e266:	f003 0301 	and.w	r3, r3, #1
 800e26a:	b2db      	uxtb	r3, r3
 800e26c:	2b00      	cmp	r3, #0
 800e26e:	d008      	beq.n	800e282 <wolfSSL_ASN1_STRING_clear+0x38>
            XFREE(asn1->data, NULL, DYNAMIC_TYPE_OPENSSL);
 800e270:	687b      	ldr	r3, [r7, #4]
 800e272:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800e274:	60fb      	str	r3, [r7, #12]
 800e276:	68fb      	ldr	r3, [r7, #12]
 800e278:	2b00      	cmp	r3, #0
 800e27a:	d002      	beq.n	800e282 <wolfSSL_ASN1_STRING_clear+0x38>
 800e27c:	68f8      	ldr	r0, [r7, #12]
 800e27e:	f010 fc1f 	bl	801eac0 <wolfSSL_Free>
        }
        XMEMSET(asn1, 0, sizeof(WOLFSSL_ASN1_STRING));
 800e282:	2258      	movs	r2, #88	@ 0x58
 800e284:	2100      	movs	r1, #0
 800e286:	6878      	ldr	r0, [r7, #4]
 800e288:	f01a f91e 	bl	80284c8 <memset>
    }
}
 800e28c:	bf00      	nop
 800e28e:	3710      	adds	r7, #16
 800e290:	46bd      	mov	sp, r7
 800e292:	bd80      	pop	{r7, pc}

0800e294 <wolfSSL_X509_EXTENSION_free>:


void wolfSSL_X509_EXTENSION_free(WOLFSSL_X509_EXTENSION* x)
{
 800e294:	b580      	push	{r7, lr}
 800e296:	b084      	sub	sp, #16
 800e298:	af00      	add	r7, sp, #0
 800e29a:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_X509_EXTENSION_free");
    if (x == NULL)
 800e29c:	687b      	ldr	r3, [r7, #4]
 800e29e:	2b00      	cmp	r3, #0
 800e2a0:	d01d      	beq.n	800e2de <wolfSSL_X509_EXTENSION_free+0x4a>
        return;

    if (x->obj != NULL) {
 800e2a2:	687b      	ldr	r3, [r7, #4]
 800e2a4:	681b      	ldr	r3, [r3, #0]
 800e2a6:	2b00      	cmp	r3, #0
 800e2a8:	d004      	beq.n	800e2b4 <wolfSSL_X509_EXTENSION_free+0x20>
        wolfSSL_ASN1_OBJECT_free(x->obj);
 800e2aa:	687b      	ldr	r3, [r7, #4]
 800e2ac:	681b      	ldr	r3, [r3, #0]
 800e2ae:	4618      	mov	r0, r3
 800e2b0:	f7fd fb95 	bl	800b9de <wolfSSL_ASN1_OBJECT_free>
    }

    wolfSSL_ASN1_STRING_clear(&x->value);
 800e2b4:	687b      	ldr	r3, [r7, #4]
 800e2b6:	3308      	adds	r3, #8
 800e2b8:	4618      	mov	r0, r3
 800e2ba:	f7ff ffc6 	bl	800e24a <wolfSSL_ASN1_STRING_clear>
    wolfSSL_sk_pop_free(x->ext_sk, NULL);
 800e2be:	687b      	ldr	r3, [r7, #4]
 800e2c0:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 800e2c4:	2100      	movs	r1, #0
 800e2c6:	4618      	mov	r0, r3
 800e2c8:	f7ff fd2c 	bl	800dd24 <wolfSSL_sk_pop_free>

    XFREE(x, NULL, DYNAMIC_TYPE_X509_EXT);
 800e2cc:	687b      	ldr	r3, [r7, #4]
 800e2ce:	60fb      	str	r3, [r7, #12]
 800e2d0:	68fb      	ldr	r3, [r7, #12]
 800e2d2:	2b00      	cmp	r3, #0
 800e2d4:	d004      	beq.n	800e2e0 <wolfSSL_X509_EXTENSION_free+0x4c>
 800e2d6:	68f8      	ldr	r0, [r7, #12]
 800e2d8:	f010 fbf2 	bl	801eac0 <wolfSSL_Free>
 800e2dc:	e000      	b.n	800e2e0 <wolfSSL_X509_EXTENSION_free+0x4c>
        return;
 800e2de:	bf00      	nop
}
 800e2e0:	3710      	adds	r7, #16
 800e2e2:	46bd      	mov	sp, r7
 800e2e4:	bd80      	pop	{r7, pc}

0800e2e6 <ExternalFreeX509>:
    defined(OPENSSL_EXTRA)  || defined(OPENSSL_EXTRA_X509_SMALL)

/* user externally called free X509, if dynamic go ahead with free, otherwise
 * don't */
static void ExternalFreeX509(WOLFSSL_X509* x509)
{
 800e2e6:	b580      	push	{r7, lr}
 800e2e8:	b086      	sub	sp, #24
 800e2ea:	af00      	add	r7, sp, #0
 800e2ec:	6078      	str	r0, [r7, #4]
#if defined(OPENSSL_EXTRA_X509_SMALL) || defined(OPENSSL_EXTRA)
    int doFree = 0;
 800e2ee:	2300      	movs	r3, #0
 800e2f0:	60fb      	str	r3, [r7, #12]
#endif

    WOLFSSL_ENTER("ExternalFreeX509");
    if (x509) {
 800e2f2:	687b      	ldr	r3, [r7, #4]
 800e2f4:	2b00      	cmp	r3, #0
 800e2f6:	d022      	beq.n	800e33e <ExternalFreeX509+0x58>
#ifdef HAVE_EX_DATA_CLEANUP_HOOKS
        wolfSSL_CRYPTO_cleanup_ex_data(&x509->ex_data);
#endif
        if (x509->dynamicMemory) {
 800e2f8:	687b      	ldr	r3, [r7, #4]
 800e2fa:	f893 3094 	ldrb.w	r3, [r3, #148]	@ 0x94
 800e2fe:	2b00      	cmp	r3, #0
 800e300:	d01d      	beq.n	800e33e <ExternalFreeX509+0x58>
        #if defined(OPENSSL_EXTRA_X509_SMALL) || defined(OPENSSL_EXTRA)
            int ret;
            wolfSSL_RefDec(&x509->ref, &doFree, &ret);
 800e302:	687b      	ldr	r3, [r7, #4]
 800e304:	3398      	adds	r3, #152	@ 0x98
 800e306:	2101      	movs	r1, #1
 800e308:	4618      	mov	r0, r3
 800e30a:	f7fc ff0b 	bl	800b124 <wolfSSL_Atomic_Int_FetchSub>
 800e30e:	6178      	str	r0, [r7, #20]
 800e310:	697b      	ldr	r3, [r7, #20]
 800e312:	2b01      	cmp	r3, #1
 800e314:	bf0c      	ite	eq
 800e316:	2301      	moveq	r3, #1
 800e318:	2300      	movne	r3, #0
 800e31a:	b2db      	uxtb	r3, r3
 800e31c:	60fb      	str	r3, [r7, #12]
 800e31e:	2300      	movs	r3, #0
 800e320:	60bb      	str	r3, [r7, #8]
            if (ret != 0) {
                WOLFSSL_MSG("Couldn't lock x509 mutex");
            }
            if (doFree)
 800e322:	68fb      	ldr	r3, [r7, #12]
 800e324:	2b00      	cmp	r3, #0
 800e326:	d00a      	beq.n	800e33e <ExternalFreeX509+0x58>
        #endif /* OPENSSL_EXTRA_X509_SMALL || OPENSSL_EXTRA */
            {
                FreeX509(x509);
 800e328:	6878      	ldr	r0, [r7, #4]
 800e32a:	f7fb f936 	bl	800959a <FreeX509>
                XFREE(x509, x509->heap, DYNAMIC_TYPE_X509);
 800e32e:	687b      	ldr	r3, [r7, #4]
 800e330:	613b      	str	r3, [r7, #16]
 800e332:	693b      	ldr	r3, [r7, #16]
 800e334:	2b00      	cmp	r3, #0
 800e336:	d002      	beq.n	800e33e <ExternalFreeX509+0x58>
 800e338:	6938      	ldr	r0, [r7, #16]
 800e33a:	f010 fbc1 	bl	801eac0 <wolfSSL_Free>
        }
        else {
            WOLFSSL_MSG("free called on non dynamic object, not freeing");
        }
    }
}
 800e33e:	bf00      	nop
 800e340:	3718      	adds	r7, #24
 800e342:	46bd      	mov	sp, r7
 800e344:	bd80      	pop	{r7, pc}

0800e346 <wolfSSL_X509_free>:

/* Frees an external WOLFSSL_X509 structure */
WOLFSSL_ABI
void wolfSSL_X509_free(WOLFSSL_X509* x509)
{
 800e346:	b580      	push	{r7, lr}
 800e348:	b082      	sub	sp, #8
 800e34a:	af00      	add	r7, sp, #0
 800e34c:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_X509_free");
    ExternalFreeX509(x509);
 800e34e:	6878      	ldr	r0, [r7, #4]
 800e350:	f7ff ffc9 	bl	800e2e6 <ExternalFreeX509>
}
 800e354:	bf00      	nop
 800e356:	3708      	adds	r7, #8
 800e358:	46bd      	mov	sp, r7
 800e35a:	bd80      	pop	{r7, pc}

0800e35c <wolfSSL_sk_X509_pop_free>:
 * sk  stack to free nodes in
 * f   X509 free function
 */
void wolfSSL_sk_X509_pop_free(WOLF_STACK_OF(WOLFSSL_X509)* sk,
    void (*f) (WOLFSSL_X509*))
{
 800e35c:	b580      	push	{r7, lr}
 800e35e:	b082      	sub	sp, #8
 800e360:	af00      	add	r7, sp, #0
 800e362:	6078      	str	r0, [r7, #4]
 800e364:	6039      	str	r1, [r7, #0]
    WOLFSSL_ENTER("wolfSSL_sk_X509_pop_free");
    wolfSSL_sk_pop_free(sk, (wolfSSL_sk_freefunc)f);
 800e366:	6839      	ldr	r1, [r7, #0]
 800e368:	6878      	ldr	r0, [r7, #4]
 800e36a:	f7ff fcdb 	bl	800dd24 <wolfSSL_sk_pop_free>
}
 800e36e:	bf00      	nop
 800e370:	3708      	adds	r7, #8
 800e372:	46bd      	mov	sp, r7
 800e374:	bd80      	pop	{r7, pc}

0800e376 <wolfSSL_sk_X509_free>:


/* free just the stack structure */
void wolfSSL_sk_X509_free(WOLF_STACK_OF(WOLFSSL_X509)* sk)
{
 800e376:	b580      	push	{r7, lr}
 800e378:	b082      	sub	sp, #8
 800e37a:	af00      	add	r7, sp, #0
 800e37c:	6078      	str	r0, [r7, #4]
    wolfSSL_sk_free(sk);
 800e37e:	6878      	ldr	r0, [r7, #4]
 800e380:	f7ff fcb6 	bl	800dcf0 <wolfSSL_sk_free>
}
 800e384:	bf00      	nop
 800e386:	3708      	adds	r7, #8
 800e388:	46bd      	mov	sp, r7
 800e38a:	bd80      	pop	{r7, pc}

0800e38c <wolfSSL_DIST_POINT_NAME_free>:
}
#endif /* OPENSSL_EXTRA || WOLFSSL_WPAS_SMALL */

#ifdef OPENSSL_EXTRA
static void wolfSSL_DIST_POINT_NAME_free(WOLFSSL_DIST_POINT_NAME* dpn)
{
 800e38c:	b580      	push	{r7, lr}
 800e38e:	b084      	sub	sp, #16
 800e390:	af00      	add	r7, sp, #0
 800e392:	6078      	str	r0, [r7, #4]
    if (dpn != NULL) {
 800e394:	687b      	ldr	r3, [r7, #4]
 800e396:	2b00      	cmp	r3, #0
 800e398:	d011      	beq.n	800e3be <wolfSSL_DIST_POINT_NAME_free+0x32>
        if (dpn->name.fullname != NULL) {
 800e39a:	687b      	ldr	r3, [r7, #4]
 800e39c:	685b      	ldr	r3, [r3, #4]
 800e39e:	2b00      	cmp	r3, #0
 800e3a0:	d005      	beq.n	800e3ae <wolfSSL_DIST_POINT_NAME_free+0x22>
            wolfSSL_sk_X509_pop_free(dpn->name.fullname, NULL);
 800e3a2:	687b      	ldr	r3, [r7, #4]
 800e3a4:	685b      	ldr	r3, [r3, #4]
 800e3a6:	2100      	movs	r1, #0
 800e3a8:	4618      	mov	r0, r3
 800e3aa:	f7ff ffd7 	bl	800e35c <wolfSSL_sk_X509_pop_free>
        }
        XFREE(dpn, NULL, DYNAMIC_TYPE_OPENSSL);
 800e3ae:	687b      	ldr	r3, [r7, #4]
 800e3b0:	60fb      	str	r3, [r7, #12]
 800e3b2:	68fb      	ldr	r3, [r7, #12]
 800e3b4:	2b00      	cmp	r3, #0
 800e3b6:	d002      	beq.n	800e3be <wolfSSL_DIST_POINT_NAME_free+0x32>
 800e3b8:	68f8      	ldr	r0, [r7, #12]
 800e3ba:	f010 fb81 	bl	801eac0 <wolfSSL_Free>
    }
}
 800e3be:	bf00      	nop
 800e3c0:	3710      	adds	r7, #16
 800e3c2:	46bd      	mov	sp, r7
 800e3c4:	bd80      	pop	{r7, pc}

0800e3c6 <wolfSSL_DIST_POINT_free>:


/* Frees DIST_POINT objects.
*/
void wolfSSL_DIST_POINT_free(WOLFSSL_DIST_POINT* dp)
{
 800e3c6:	b580      	push	{r7, lr}
 800e3c8:	b084      	sub	sp, #16
 800e3ca:	af00      	add	r7, sp, #0
 800e3cc:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_DIST_POINT_free");
    if (dp != NULL) {
 800e3ce:	687b      	ldr	r3, [r7, #4]
 800e3d0:	2b00      	cmp	r3, #0
 800e3d2:	d00c      	beq.n	800e3ee <wolfSSL_DIST_POINT_free+0x28>
        wolfSSL_DIST_POINT_NAME_free(dp->distpoint);
 800e3d4:	687b      	ldr	r3, [r7, #4]
 800e3d6:	681b      	ldr	r3, [r3, #0]
 800e3d8:	4618      	mov	r0, r3
 800e3da:	f7ff ffd7 	bl	800e38c <wolfSSL_DIST_POINT_NAME_free>
        XFREE(dp, NULL, DYNAMIC_TYPE_OPENSSL);
 800e3de:	687b      	ldr	r3, [r7, #4]
 800e3e0:	60fb      	str	r3, [r7, #12]
 800e3e2:	68fb      	ldr	r3, [r7, #12]
 800e3e4:	2b00      	cmp	r3, #0
 800e3e6:	d002      	beq.n	800e3ee <wolfSSL_DIST_POINT_free+0x28>
 800e3e8:	68f8      	ldr	r0, [r7, #12]
 800e3ea:	f010 fb69 	bl	801eac0 <wolfSSL_Free>
    }
}
 800e3ee:	bf00      	nop
 800e3f0:	3710      	adds	r7, #16
 800e3f2:	46bd      	mov	sp, r7
 800e3f4:	bd80      	pop	{r7, pc}
	...

0800e3f8 <wolfSSL_GENERAL_NAME_type_free>:
#endif /* OPENSSL_EXTRA */

#if defined(OPENSSL_EXTRA) || defined(WOLFSSL_WPAS_SMALL)
/* free's the internal type for the general name */
static void wolfSSL_GENERAL_NAME_type_free(WOLFSSL_GENERAL_NAME* name)
{
 800e3f8:	b580      	push	{r7, lr}
 800e3fa:	b084      	sub	sp, #16
 800e3fc:	af00      	add	r7, sp, #0
 800e3fe:	6078      	str	r0, [r7, #4]
    if (name != NULL) {
 800e400:	687b      	ldr	r3, [r7, #4]
 800e402:	2b00      	cmp	r3, #0
 800e404:	d079      	beq.n	800e4fa <wolfSSL_GENERAL_NAME_type_free+0x102>
        switch (name->type) {
 800e406:	687b      	ldr	r3, [r7, #4]
 800e408:	681b      	ldr	r3, [r3, #0]
 800e40a:	2b09      	cmp	r3, #9
 800e40c:	d872      	bhi.n	800e4f4 <wolfSSL_GENERAL_NAME_type_free+0xfc>
 800e40e:	a201      	add	r2, pc, #4	@ (adr r2, 800e414 <wolfSSL_GENERAL_NAME_type_free+0x1c>)
 800e410:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800e414:	0800e4bb 	.word	0x0800e4bb
 800e418:	0800e44f 	.word	0x0800e44f
 800e41c:	0800e461 	.word	0x0800e461
 800e420:	0800e4f5 	.word	0x0800e4f5
 800e424:	0800e473 	.word	0x0800e473
 800e428:	0800e4f5 	.word	0x0800e4f5
 800e42c:	0800e485 	.word	0x0800e485
 800e430:	0800e497 	.word	0x0800e497
 800e434:	0800e4a9 	.word	0x0800e4a9
 800e438:	0800e43d 	.word	0x0800e43d
        case WOLFSSL_GEN_IA5:
            wolfSSL_ASN1_STRING_free(name->d.ia5);
 800e43c:	687b      	ldr	r3, [r7, #4]
 800e43e:	685b      	ldr	r3, [r3, #4]
 800e440:	4618      	mov	r0, r3
 800e442:	f7fd fb2b 	bl	800ba9c <wolfSSL_ASN1_STRING_free>
            name->d.ia5 = NULL;
 800e446:	687b      	ldr	r3, [r7, #4]
 800e448:	2200      	movs	r2, #0
 800e44a:	605a      	str	r2, [r3, #4]
            break;
 800e44c:	e055      	b.n	800e4fa <wolfSSL_GENERAL_NAME_type_free+0x102>
        case WOLFSSL_GEN_EMAIL:
            wolfSSL_ASN1_STRING_free(name->d.rfc822Name);
 800e44e:	687b      	ldr	r3, [r7, #4]
 800e450:	685b      	ldr	r3, [r3, #4]
 800e452:	4618      	mov	r0, r3
 800e454:	f7fd fb22 	bl	800ba9c <wolfSSL_ASN1_STRING_free>
            name->d.rfc822Name = NULL;
 800e458:	687b      	ldr	r3, [r7, #4]
 800e45a:	2200      	movs	r2, #0
 800e45c:	605a      	str	r2, [r3, #4]
            break;
 800e45e:	e04c      	b.n	800e4fa <wolfSSL_GENERAL_NAME_type_free+0x102>
        case WOLFSSL_GEN_DNS:
            wolfSSL_ASN1_STRING_free(name->d.dNSName);
 800e460:	687b      	ldr	r3, [r7, #4]
 800e462:	685b      	ldr	r3, [r3, #4]
 800e464:	4618      	mov	r0, r3
 800e466:	f7fd fb19 	bl	800ba9c <wolfSSL_ASN1_STRING_free>
            name->d.dNSName = NULL;
 800e46a:	687b      	ldr	r3, [r7, #4]
 800e46c:	2200      	movs	r2, #0
 800e46e:	605a      	str	r2, [r3, #4]
            break;
 800e470:	e043      	b.n	800e4fa <wolfSSL_GENERAL_NAME_type_free+0x102>
        case WOLFSSL_GEN_DIRNAME:
            wolfSSL_X509_NAME_free(name->d.dirn);
 800e472:	687b      	ldr	r3, [r7, #4]
 800e474:	685b      	ldr	r3, [r3, #4]
 800e476:	4618      	mov	r0, r3
 800e478:	f000 f87d 	bl	800e576 <wolfSSL_X509_NAME_free>
            name->d.dirn = NULL;
 800e47c:	687b      	ldr	r3, [r7, #4]
 800e47e:	2200      	movs	r2, #0
 800e480:	605a      	str	r2, [r3, #4]
            break;
 800e482:	e03a      	b.n	800e4fa <wolfSSL_GENERAL_NAME_type_free+0x102>
        case WOLFSSL_GEN_URI:
            wolfSSL_ASN1_STRING_free(name->d.uniformResourceIdentifier);
 800e484:	687b      	ldr	r3, [r7, #4]
 800e486:	685b      	ldr	r3, [r3, #4]
 800e488:	4618      	mov	r0, r3
 800e48a:	f7fd fb07 	bl	800ba9c <wolfSSL_ASN1_STRING_free>
            name->d.uniformResourceIdentifier = NULL;
 800e48e:	687b      	ldr	r3, [r7, #4]
 800e490:	2200      	movs	r2, #0
 800e492:	605a      	str	r2, [r3, #4]
            break;
 800e494:	e031      	b.n	800e4fa <wolfSSL_GENERAL_NAME_type_free+0x102>
        case WOLFSSL_GEN_IPADD:
            wolfSSL_ASN1_STRING_free(name->d.iPAddress);
 800e496:	687b      	ldr	r3, [r7, #4]
 800e498:	685b      	ldr	r3, [r3, #4]
 800e49a:	4618      	mov	r0, r3
 800e49c:	f7fd fafe 	bl	800ba9c <wolfSSL_ASN1_STRING_free>
            name->d.iPAddress = NULL;
 800e4a0:	687b      	ldr	r3, [r7, #4]
 800e4a2:	2200      	movs	r2, #0
 800e4a4:	605a      	str	r2, [r3, #4]
            break;
 800e4a6:	e028      	b.n	800e4fa <wolfSSL_GENERAL_NAME_type_free+0x102>
        case WOLFSSL_GEN_RID:
            wolfSSL_ASN1_OBJECT_free(name->d.registeredID);
 800e4a8:	687b      	ldr	r3, [r7, #4]
 800e4aa:	685b      	ldr	r3, [r3, #4]
 800e4ac:	4618      	mov	r0, r3
 800e4ae:	f7fd fa96 	bl	800b9de <wolfSSL_ASN1_OBJECT_free>
            name->d.registeredID = NULL;
 800e4b2:	687b      	ldr	r3, [r7, #4]
 800e4b4:	2200      	movs	r2, #0
 800e4b6:	605a      	str	r2, [r3, #4]
            break;
 800e4b8:	e01f      	b.n	800e4fa <wolfSSL_GENERAL_NAME_type_free+0x102>
        case WOLFSSL_GEN_OTHERNAME:
            if (name->d.otherName != NULL) {
 800e4ba:	687b      	ldr	r3, [r7, #4]
 800e4bc:	685b      	ldr	r3, [r3, #4]
 800e4be:	2b00      	cmp	r3, #0
 800e4c0:	d01a      	beq.n	800e4f8 <wolfSSL_GENERAL_NAME_type_free+0x100>
                wolfSSL_ASN1_OBJECT_free(name->d.otherName->type_id);
 800e4c2:	687b      	ldr	r3, [r7, #4]
 800e4c4:	685b      	ldr	r3, [r3, #4]
 800e4c6:	681b      	ldr	r3, [r3, #0]
 800e4c8:	4618      	mov	r0, r3
 800e4ca:	f7fd fa88 	bl	800b9de <wolfSSL_ASN1_OBJECT_free>
                wolfSSL_ASN1_TYPE_free(name->d.otherName->value);
 800e4ce:	687b      	ldr	r3, [r7, #4]
 800e4d0:	685b      	ldr	r3, [r3, #4]
 800e4d2:	685b      	ldr	r3, [r3, #4]
 800e4d4:	4618      	mov	r0, r3
 800e4d6:	f7fd fc0d 	bl	800bcf4 <wolfSSL_ASN1_TYPE_free>
                XFREE(name->d.otherName, NULL, DYNAMIC_TYPE_ASN1);
 800e4da:	687b      	ldr	r3, [r7, #4]
 800e4dc:	685b      	ldr	r3, [r3, #4]
 800e4de:	60fb      	str	r3, [r7, #12]
 800e4e0:	68fb      	ldr	r3, [r7, #12]
 800e4e2:	2b00      	cmp	r3, #0
 800e4e4:	d002      	beq.n	800e4ec <wolfSSL_GENERAL_NAME_type_free+0xf4>
 800e4e6:	68f8      	ldr	r0, [r7, #12]
 800e4e8:	f010 faea 	bl	801eac0 <wolfSSL_Free>
                name->d.otherName = NULL;
 800e4ec:	687b      	ldr	r3, [r7, #4]
 800e4ee:	2200      	movs	r2, #0
 800e4f0:	605a      	str	r2, [r3, #4]
            }
            break;
 800e4f2:	e001      	b.n	800e4f8 <wolfSSL_GENERAL_NAME_type_free+0x100>
            /* Unsupported: fall through */
        case WOLFSSL_GEN_EDIPARTY:
            /* Unsupported: fall through */
        default:
            WOLFSSL_MSG("wolfSSL_GENERAL_NAME_type_free: possible leak");
            break;
 800e4f4:	bf00      	nop
 800e4f6:	e000      	b.n	800e4fa <wolfSSL_GENERAL_NAME_type_free+0x102>
            break;
 800e4f8:	bf00      	nop
        }
    }
}
 800e4fa:	bf00      	nop
 800e4fc:	3710      	adds	r7, #16
 800e4fe:	46bd      	mov	sp, r7
 800e500:	bd80      	pop	{r7, pc}
 800e502:	bf00      	nop

0800e504 <wolfSSL_GENERAL_NAME_free>:
}

/* Frees GENERAL_NAME objects.
*/
void wolfSSL_GENERAL_NAME_free(WOLFSSL_GENERAL_NAME* name)
{
 800e504:	b580      	push	{r7, lr}
 800e506:	b084      	sub	sp, #16
 800e508:	af00      	add	r7, sp, #0
 800e50a:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_GENERAL_NAME_Free");
    if (name != NULL) {
 800e50c:	687b      	ldr	r3, [r7, #4]
 800e50e:	2b00      	cmp	r3, #0
 800e510:	d00a      	beq.n	800e528 <wolfSSL_GENERAL_NAME_free+0x24>
        wolfSSL_GENERAL_NAME_type_free(name);
 800e512:	6878      	ldr	r0, [r7, #4]
 800e514:	f7ff ff70 	bl	800e3f8 <wolfSSL_GENERAL_NAME_type_free>
        XFREE(name, NULL, DYNAMIC_TYPE_OPENSSL);
 800e518:	687b      	ldr	r3, [r7, #4]
 800e51a:	60fb      	str	r3, [r7, #12]
 800e51c:	68fb      	ldr	r3, [r7, #12]
 800e51e:	2b00      	cmp	r3, #0
 800e520:	d002      	beq.n	800e528 <wolfSSL_GENERAL_NAME_free+0x24>
 800e522:	68f8      	ldr	r0, [r7, #12]
 800e524:	f010 facc 	bl	801eac0 <wolfSSL_Free>
    }
}
 800e528:	bf00      	nop
 800e52a:	3710      	adds	r7, #16
 800e52c:	46bd      	mov	sp, r7
 800e52e:	bd80      	pop	{r7, pc}

0800e530 <wolfSSL_sk_X509_EXTENSION_pop_free>:

/* frees all of the nodes and the values in stack */
void wolfSSL_sk_X509_EXTENSION_pop_free(
        WOLF_STACK_OF(WOLFSSL_X509_EXTENSION)* sk,
        void (*f) (WOLFSSL_X509_EXTENSION*))
{
 800e530:	b580      	push	{r7, lr}
 800e532:	b082      	sub	sp, #8
 800e534:	af00      	add	r7, sp, #0
 800e536:	6078      	str	r0, [r7, #4]
 800e538:	6039      	str	r1, [r7, #0]
    wolfSSL_sk_pop_free(sk, (wolfSSL_sk_freefunc)f);
 800e53a:	6839      	ldr	r1, [r7, #0]
 800e53c:	6878      	ldr	r0, [r7, #4]
 800e53e:	f7ff fbf1 	bl	800dd24 <wolfSSL_sk_pop_free>
}
 800e542:	bf00      	nop
 800e544:	3708      	adds	r7, #8
 800e546:	46bd      	mov	sp, r7
 800e548:	bd80      	pop	{r7, pc}

0800e54a <wolfSSL_X509_new_ex>:

/* returns a pointer to a new WOLFSSL_X509 structure on success and NULL on
 * fail
 */
WOLFSSL_X509* wolfSSL_X509_new_ex(void* heap)
{
 800e54a:	b580      	push	{r7, lr}
 800e54c:	b084      	sub	sp, #16
 800e54e:	af00      	add	r7, sp, #0
 800e550:	6078      	str	r0, [r7, #4]
    WOLFSSL_X509* x509;

    x509 = (WOLFSSL_X509*)XMALLOC(sizeof(WOLFSSL_X509), heap,
 800e552:	f640 40d4 	movw	r0, #3284	@ 0xcd4
 800e556:	f010 fa97 	bl	801ea88 <wolfSSL_Malloc>
 800e55a:	60f8      	str	r0, [r7, #12]
            DYNAMIC_TYPE_X509);
    if (x509 != NULL) {
 800e55c:	68fb      	ldr	r3, [r7, #12]
 800e55e:	2b00      	cmp	r3, #0
 800e560:	d004      	beq.n	800e56c <wolfSSL_X509_new_ex+0x22>
        InitX509(x509, 1, heap);
 800e562:	687a      	ldr	r2, [r7, #4]
 800e564:	2101      	movs	r1, #1
 800e566:	68f8      	ldr	r0, [r7, #12]
 800e568:	f7fa ffe4 	bl	8009534 <InitX509>
    }

    return x509;
 800e56c:	68fb      	ldr	r3, [r7, #12]
}
 800e56e:	4618      	mov	r0, r3
 800e570:	3710      	adds	r7, #16
 800e572:	46bd      	mov	sp, r7
 800e574:	bd80      	pop	{r7, pc}

0800e576 <wolfSSL_X509_NAME_free>:
}
#endif

#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
    void wolfSSL_X509_NAME_free(WOLFSSL_X509_NAME *name)
    {
 800e576:	b580      	push	{r7, lr}
 800e578:	b084      	sub	sp, #16
 800e57a:	af00      	add	r7, sp, #0
 800e57c:	6078      	str	r0, [r7, #4]
        WOLFSSL_ENTER("wolfSSL_X509_NAME_free");
        FreeX509Name(name);
 800e57e:	6878      	ldr	r0, [r7, #4]
 800e580:	f7fa ff73 	bl	800946a <FreeX509Name>
        if (name != NULL) {
 800e584:	687b      	ldr	r3, [r7, #4]
 800e586:	2b00      	cmp	r3, #0
 800e588:	d007      	beq.n	800e59a <wolfSSL_X509_NAME_free+0x24>
            XFREE(name, name->heap, DYNAMIC_TYPE_X509);
 800e58a:	687b      	ldr	r3, [r7, #4]
 800e58c:	60fb      	str	r3, [r7, #12]
 800e58e:	68fb      	ldr	r3, [r7, #12]
 800e590:	2b00      	cmp	r3, #0
 800e592:	d002      	beq.n	800e59a <wolfSSL_X509_NAME_free+0x24>
 800e594:	68f8      	ldr	r0, [r7, #12]
 800e596:	f010 fa93 	bl	801eac0 <wolfSSL_Free>
        }
    }
 800e59a:	bf00      	nop
 800e59c:	3710      	adds	r7, #16
 800e59e:	46bd      	mov	sp, r7
 800e5a0:	bd80      	pop	{r7, pc}

0800e5a2 <wolfSSL_X509_NAME_new_ex>:
    /* Malloc's a new WOLFSSL_X509_NAME structure
     *
     * returns NULL on failure, otherwise returns a new structure.
     */
    WOLFSSL_X509_NAME* wolfSSL_X509_NAME_new_ex(void *heap)
    {
 800e5a2:	b580      	push	{r7, lr}
 800e5a4:	b084      	sub	sp, #16
 800e5a6:	af00      	add	r7, sp, #0
 800e5a8:	6078      	str	r0, [r7, #4]
        WOLFSSL_X509_NAME* name;

        WOLFSSL_ENTER("wolfSSL_X509_NAME_new_ex");

        name = (WOLFSSL_X509_NAME*)XMALLOC(sizeof(WOLFSSL_X509_NAME), heap,
 800e5aa:	f240 500c 	movw	r0, #1292	@ 0x50c
 800e5ae:	f010 fa6b 	bl	801ea88 <wolfSSL_Malloc>
 800e5b2:	60f8      	str	r0, [r7, #12]
                DYNAMIC_TYPE_X509);
        if (name != NULL) {
 800e5b4:	68fb      	ldr	r3, [r7, #12]
 800e5b6:	2b00      	cmp	r3, #0
 800e5b8:	d004      	beq.n	800e5c4 <wolfSSL_X509_NAME_new_ex+0x22>
            InitX509Name(name, 1, heap);
 800e5ba:	687a      	ldr	r2, [r7, #4]
 800e5bc:	2101      	movs	r1, #1
 800e5be:	68f8      	ldr	r0, [r7, #12]
 800e5c0:	f7fa ff34 	bl	800942c <InitX509Name>
        }
        return name;
 800e5c4:	68fb      	ldr	r3, [r7, #12]
    }
 800e5c6:	4618      	mov	r0, r3
 800e5c8:	3710      	adds	r7, #16
 800e5ca:	46bd      	mov	sp, r7
 800e5cc:	bd80      	pop	{r7, pc}

0800e5ce <wolfSSL_X509_NAME_ENTRY_free>:
    }
#endif /* !NO_BIO */
#endif /* OPENSSL_ALL */

    void wolfSSL_X509_NAME_ENTRY_free(WOLFSSL_X509_NAME_ENTRY* ne)
    {
 800e5ce:	b580      	push	{r7, lr}
 800e5d0:	b084      	sub	sp, #16
 800e5d2:	af00      	add	r7, sp, #0
 800e5d4:	6078      	str	r0, [r7, #4]
        WOLFSSL_ENTER("wolfSSL_X509_NAME_ENTRY_free");
        if (ne != NULL) {
 800e5d6:	687b      	ldr	r3, [r7, #4]
 800e5d8:	2b00      	cmp	r3, #0
 800e5da:	d015      	beq.n	800e608 <wolfSSL_X509_NAME_ENTRY_free+0x3a>
            wolfSSL_ASN1_OBJECT_free(ne->object);
 800e5dc:	687b      	ldr	r3, [r7, #4]
 800e5de:	681b      	ldr	r3, [r3, #0]
 800e5e0:	4618      	mov	r0, r3
 800e5e2:	f7fd f9fc 	bl	800b9de <wolfSSL_ASN1_OBJECT_free>
            if (ne->value != NULL) {
 800e5e6:	687b      	ldr	r3, [r7, #4]
 800e5e8:	685b      	ldr	r3, [r3, #4]
 800e5ea:	2b00      	cmp	r3, #0
 800e5ec:	d004      	beq.n	800e5f8 <wolfSSL_X509_NAME_ENTRY_free+0x2a>
                wolfSSL_ASN1_STRING_free(ne->value);
 800e5ee:	687b      	ldr	r3, [r7, #4]
 800e5f0:	685b      	ldr	r3, [r3, #4]
 800e5f2:	4618      	mov	r0, r3
 800e5f4:	f7fd fa52 	bl	800ba9c <wolfSSL_ASN1_STRING_free>
            }
            XFREE(ne, NULL, DYNAMIC_TYPE_NAME_ENTRY);
 800e5f8:	687b      	ldr	r3, [r7, #4]
 800e5fa:	60fb      	str	r3, [r7, #12]
 800e5fc:	68fb      	ldr	r3, [r7, #12]
 800e5fe:	2b00      	cmp	r3, #0
 800e600:	d002      	beq.n	800e608 <wolfSSL_X509_NAME_ENTRY_free+0x3a>
 800e602:	68f8      	ldr	r0, [r7, #12]
 800e604:	f010 fa5c 	bl	801eac0 <wolfSSL_Free>
        }
    }
 800e608:	bf00      	nop
 800e60a:	3710      	adds	r7, #16
 800e60c:	46bd      	mov	sp, r7
 800e60e:	bd80      	pop	{r7, pc}

0800e610 <wolfSSL_X509_NAME_ENTRY_new>:


    WOLFSSL_X509_NAME_ENTRY* wolfSSL_X509_NAME_ENTRY_new(void)
    {
 800e610:	b580      	push	{r7, lr}
 800e612:	b082      	sub	sp, #8
 800e614:	af00      	add	r7, sp, #0
        WOLFSSL_X509_NAME_ENTRY* ne;

        ne = (WOLFSSL_X509_NAME_ENTRY*)XMALLOC(sizeof(WOLFSSL_X509_NAME_ENTRY),
 800e616:	2014      	movs	r0, #20
 800e618:	f010 fa36 	bl	801ea88 <wolfSSL_Malloc>
 800e61c:	6078      	str	r0, [r7, #4]
                NULL, DYNAMIC_TYPE_NAME_ENTRY);
        if (ne != NULL) {
 800e61e:	687b      	ldr	r3, [r7, #4]
 800e620:	2b00      	cmp	r3, #0
 800e622:	d004      	beq.n	800e62e <wolfSSL_X509_NAME_ENTRY_new+0x1e>
            XMEMSET(ne, 0, sizeof(WOLFSSL_X509_NAME_ENTRY));
 800e624:	2214      	movs	r2, #20
 800e626:	2100      	movs	r1, #0
 800e628:	6878      	ldr	r0, [r7, #4]
 800e62a:	f019 ff4d 	bl	80284c8 <memset>
        }

        return ne;
 800e62e:	687b      	ldr	r3, [r7, #4]
    }
 800e630:	4618      	mov	r0, r3
 800e632:	3708      	adds	r7, #8
 800e634:	46bd      	mov	sp, r7
 800e636:	bd80      	pop	{r7, pc}

0800e638 <wolfssl_x509_name_entry_set>:

    static void wolfssl_x509_name_entry_set(WOLFSSL_X509_NAME_ENTRY* ne,
        int nid, int type, const unsigned char *data, int dataSz)
    {
 800e638:	b580      	push	{r7, lr}
 800e63a:	b084      	sub	sp, #16
 800e63c:	af00      	add	r7, sp, #0
 800e63e:	60f8      	str	r0, [r7, #12]
 800e640:	60b9      	str	r1, [r7, #8]
 800e642:	607a      	str	r2, [r7, #4]
 800e644:	603b      	str	r3, [r7, #0]
        ne->nid = nid;
 800e646:	68fb      	ldr	r3, [r7, #12]
 800e648:	68ba      	ldr	r2, [r7, #8]
 800e64a:	609a      	str	r2, [r3, #8]
        /* Reuse the object if already available. */
        ne->object = wolfSSL_OBJ_nid2obj_ex(nid, ne->object);
 800e64c:	68fb      	ldr	r3, [r7, #12]
 800e64e:	681b      	ldr	r3, [r3, #0]
 800e650:	4619      	mov	r1, r3
 800e652:	68b8      	ldr	r0, [r7, #8]
 800e654:	f7ff fbee 	bl	800de34 <wolfSSL_OBJ_nid2obj_ex>
 800e658:	4602      	mov	r2, r0
 800e65a:	68fb      	ldr	r3, [r7, #12]
 800e65c:	601a      	str	r2, [r3, #0]
        if (ne->value == NULL) {
 800e65e:	68fb      	ldr	r3, [r7, #12]
 800e660:	685b      	ldr	r3, [r3, #4]
 800e662:	2b00      	cmp	r3, #0
 800e664:	d105      	bne.n	800e672 <wolfssl_x509_name_entry_set+0x3a>
            ne->value = wolfSSL_ASN1_STRING_type_new(type);
 800e666:	6878      	ldr	r0, [r7, #4]
 800e668:	f7fd fa06 	bl	800ba78 <wolfSSL_ASN1_STRING_type_new>
 800e66c:	4602      	mov	r2, r0
 800e66e:	68fb      	ldr	r3, [r7, #12]
 800e670:	605a      	str	r2, [r3, #4]
        }
        if (ne->value != NULL) {
 800e672:	68fb      	ldr	r3, [r7, #12]
 800e674:	685b      	ldr	r3, [r3, #4]
 800e676:	2b00      	cmp	r3, #0
 800e678:	d015      	beq.n	800e6a6 <wolfssl_x509_name_entry_set+0x6e>
            if (wolfSSL_ASN1_STRING_set(ne->value, (const void*)data,
 800e67a:	68fb      	ldr	r3, [r7, #12]
 800e67c:	685b      	ldr	r3, [r3, #4]
 800e67e:	69ba      	ldr	r2, [r7, #24]
 800e680:	6839      	ldr	r1, [r7, #0]
 800e682:	4618      	mov	r0, r3
 800e684:	f7fd fa6b 	bl	800bb5e <wolfSSL_ASN1_STRING_set>
 800e688:	4603      	mov	r3, r0
 800e68a:	2b01      	cmp	r3, #1
 800e68c:	d103      	bne.n	800e696 <wolfssl_x509_name_entry_set+0x5e>
                                            dataSz) == WOLFSSL_SUCCESS) {
                ne->set = 1;
 800e68e:	68fb      	ldr	r3, [r7, #12]
 800e690:	2201      	movs	r2, #1
 800e692:	60da      	str	r2, [r3, #12]
                /* Free the ASN1_STRING if it is not set. */
                wolfSSL_ASN1_STRING_free(ne->value);
                ne->value = NULL;
            }
        }
    }
 800e694:	e007      	b.n	800e6a6 <wolfssl_x509_name_entry_set+0x6e>
                wolfSSL_ASN1_STRING_free(ne->value);
 800e696:	68fb      	ldr	r3, [r7, #12]
 800e698:	685b      	ldr	r3, [r3, #4]
 800e69a:	4618      	mov	r0, r3
 800e69c:	f7fd f9fe 	bl	800ba9c <wolfSSL_ASN1_STRING_free>
                ne->value = NULL;
 800e6a0:	68fb      	ldr	r3, [r7, #12]
 800e6a2:	2200      	movs	r2, #0
 800e6a4:	605a      	str	r2, [r3, #4]
    }
 800e6a6:	bf00      	nop
 800e6a8:	3710      	adds	r7, #16
 800e6aa:	46bd      	mov	sp, r7
 800e6ac:	bd80      	pop	{r7, pc}

0800e6ae <wolfSSL_X509_NAME_ENTRY_create_by_NID>:
     * returns a pointer to WOLFSSL_X509_NAME_ENTRY on success and NULL on fail
     */
    WOLFSSL_X509_NAME_ENTRY* wolfSSL_X509_NAME_ENTRY_create_by_NID(
            WOLFSSL_X509_NAME_ENTRY** out, int nid, int type,
            const unsigned char* data, int dataSz)
    {
 800e6ae:	b580      	push	{r7, lr}
 800e6b0:	b088      	sub	sp, #32
 800e6b2:	af02      	add	r7, sp, #8
 800e6b4:	60f8      	str	r0, [r7, #12]
 800e6b6:	60b9      	str	r1, [r7, #8]
 800e6b8:	607a      	str	r2, [r7, #4]
 800e6ba:	603b      	str	r3, [r7, #0]

#ifdef WOLFSSL_DEBUG_OPENSSL
        WOLFSSL_ENTER("wolfSSL_X509_NAME_ENTRY_create_by_NID");
#endif

        if (!data) {
 800e6bc:	683b      	ldr	r3, [r7, #0]
 800e6be:	2b00      	cmp	r3, #0
 800e6c0:	d101      	bne.n	800e6c6 <wolfSSL_X509_NAME_ENTRY_create_by_NID+0x18>
            WOLFSSL_MSG("Bad parameter");
            return NULL;
 800e6c2:	2300      	movs	r3, #0
 800e6c4:	e021      	b.n	800e70a <wolfSSL_X509_NAME_ENTRY_create_by_NID+0x5c>
        }

        if (out == NULL || *out == NULL) {
 800e6c6:	68fb      	ldr	r3, [r7, #12]
 800e6c8:	2b00      	cmp	r3, #0
 800e6ca:	d003      	beq.n	800e6d4 <wolfSSL_X509_NAME_ENTRY_create_by_NID+0x26>
 800e6cc:	68fb      	ldr	r3, [r7, #12]
 800e6ce:	681b      	ldr	r3, [r3, #0]
 800e6d0:	2b00      	cmp	r3, #0
 800e6d2:	d10e      	bne.n	800e6f2 <wolfSSL_X509_NAME_ENTRY_create_by_NID+0x44>
            ne = wolfSSL_X509_NAME_ENTRY_new();
 800e6d4:	f7ff ff9c 	bl	800e610 <wolfSSL_X509_NAME_ENTRY_new>
 800e6d8:	6178      	str	r0, [r7, #20]
            if (ne == NULL) {
 800e6da:	697b      	ldr	r3, [r7, #20]
 800e6dc:	2b00      	cmp	r3, #0
 800e6de:	d101      	bne.n	800e6e4 <wolfSSL_X509_NAME_ENTRY_create_by_NID+0x36>
                return NULL;
 800e6e0:	2300      	movs	r3, #0
 800e6e2:	e012      	b.n	800e70a <wolfSSL_X509_NAME_ENTRY_create_by_NID+0x5c>
            }
            if (out != NULL) {
 800e6e4:	68fb      	ldr	r3, [r7, #12]
 800e6e6:	2b00      	cmp	r3, #0
 800e6e8:	d006      	beq.n	800e6f8 <wolfSSL_X509_NAME_ENTRY_create_by_NID+0x4a>
                *out = ne;
 800e6ea:	68fb      	ldr	r3, [r7, #12]
 800e6ec:	697a      	ldr	r2, [r7, #20]
 800e6ee:	601a      	str	r2, [r3, #0]
            if (out != NULL) {
 800e6f0:	e002      	b.n	800e6f8 <wolfSSL_X509_NAME_ENTRY_create_by_NID+0x4a>
            }
        }
        else {
            ne = *out;
 800e6f2:	68fb      	ldr	r3, [r7, #12]
 800e6f4:	681b      	ldr	r3, [r3, #0]
 800e6f6:	617b      	str	r3, [r7, #20]
        }

        wolfssl_x509_name_entry_set(ne, nid, type, data, dataSz);
 800e6f8:	6a3b      	ldr	r3, [r7, #32]
 800e6fa:	9300      	str	r3, [sp, #0]
 800e6fc:	683b      	ldr	r3, [r7, #0]
 800e6fe:	687a      	ldr	r2, [r7, #4]
 800e700:	68b9      	ldr	r1, [r7, #8]
 800e702:	6978      	ldr	r0, [r7, #20]
 800e704:	f7ff ff98 	bl	800e638 <wolfssl_x509_name_entry_set>

        return ne;
 800e708:	697b      	ldr	r3, [r7, #20]
    }
 800e70a:	4618      	mov	r0, r3
 800e70c:	3718      	adds	r7, #24
 800e70e:	46bd      	mov	sp, r7
 800e710:	bd80      	pop	{r7, pc}

0800e712 <wolfSSL_X509_NAME_ENTRY_get_object>:
    defined(HAVE_LIGHTY) || defined(WOLFSSL_MYSQL_COMPATIBLE) || \
    defined(HAVE_STUNNEL) || defined(WOLFSSL_NGINX) || \
    defined(HAVE_POCO_LIB) || defined(WOLFSSL_HAPROXY)
WOLFSSL_ASN1_OBJECT* wolfSSL_X509_NAME_ENTRY_get_object(
    WOLFSSL_X509_NAME_ENTRY *ne)
{
 800e712:	b580      	push	{r7, lr}
 800e714:	b084      	sub	sp, #16
 800e716:	af00      	add	r7, sp, #0
 800e718:	6078      	str	r0, [r7, #4]
    WOLFSSL_ASN1_OBJECT* object = NULL;
 800e71a:	2300      	movs	r3, #0
 800e71c:	60fb      	str	r3, [r7, #12]

#ifdef WOLFSSL_DEBUG_OPENSSL
    WOLFSSL_ENTER("wolfSSL_X509_NAME_ENTRY_get_object");
#endif

    if (ne != NULL) {
 800e71e:	687b      	ldr	r3, [r7, #4]
 800e720:	2b00      	cmp	r3, #0
 800e722:	d00e      	beq.n	800e742 <wolfSSL_X509_NAME_ENTRY_get_object+0x30>
        /* Create object from nid - reuse existing object if possible. */
        object = wolfSSL_OBJ_nid2obj_ex(ne->nid, ne->object);
 800e724:	687b      	ldr	r3, [r7, #4]
 800e726:	689a      	ldr	r2, [r3, #8]
 800e728:	687b      	ldr	r3, [r7, #4]
 800e72a:	681b      	ldr	r3, [r3, #0]
 800e72c:	4619      	mov	r1, r3
 800e72e:	4610      	mov	r0, r2
 800e730:	f7ff fb80 	bl	800de34 <wolfSSL_OBJ_nid2obj_ex>
 800e734:	60f8      	str	r0, [r7, #12]
        if (object != NULL) {
 800e736:	68fb      	ldr	r3, [r7, #12]
 800e738:	2b00      	cmp	r3, #0
 800e73a:	d002      	beq.n	800e742 <wolfSSL_X509_NAME_ENTRY_get_object+0x30>
            /* Set the object when no error. */
            ne->object = object;
 800e73c:	687b      	ldr	r3, [r7, #4]
 800e73e:	68fa      	ldr	r2, [r7, #12]
 800e740:	601a      	str	r2, [r3, #0]
        }
    }

    return object;
 800e742:	68fb      	ldr	r3, [r7, #12]
}
 800e744:	4618      	mov	r0, r3
 800e746:	3710      	adds	r7, #16
 800e748:	46bd      	mov	sp, r7
 800e74a:	bd80      	pop	{r7, pc}

0800e74c <AddAllEntry>:
     * since number of entries is small, a brute force search is used here
     * returns the number of entries added
     */
    static int AddAllEntry(WOLFSSL_X509_NAME* name, char* fullName,
            int fullNameSz, int* idx)
    {
 800e74c:	b580      	push	{r7, lr}
 800e74e:	b08a      	sub	sp, #40	@ 0x28
 800e750:	af00      	add	r7, sp, #0
 800e752:	60f8      	str	r0, [r7, #12]
 800e754:	60b9      	str	r1, [r7, #8]
 800e756:	607a      	str	r2, [r7, #4]
 800e758:	603b      	str	r3, [r7, #0]
        int i;
        int ret = 0;
 800e75a:	2300      	movs	r3, #0
 800e75c:	623b      	str	r3, [r7, #32]

        for (i = 0; i < MAX_NAME_ENTRIES; i++) {
 800e75e:	2300      	movs	r3, #0
 800e760:	627b      	str	r3, [r7, #36]	@ 0x24
 800e762:	e07a      	b.n	800e85a <AddAllEntry+0x10e>
            if (name->entry[i].set) {
 800e764:	68f9      	ldr	r1, [r7, #12]
 800e766:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800e768:	4613      	mov	r3, r2
 800e76a:	009b      	lsls	r3, r3, #2
 800e76c:	4413      	add	r3, r2
 800e76e:	009b      	lsls	r3, r3, #2
 800e770:	440b      	add	r3, r1
 800e772:	f503 7318 	add.w	r3, r3, #608	@ 0x260
 800e776:	681b      	ldr	r3, [r3, #0]
 800e778:	2b00      	cmp	r3, #0
 800e77a:	d06b      	beq.n	800e854 <AddAllEntry+0x108>
                WOLFSSL_ASN1_OBJECT* obj;

                int sz;
                unsigned char* data;

                e = &name->entry[i];
 800e77c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800e77e:	4613      	mov	r3, r2
 800e780:	009b      	lsls	r3, r3, #2
 800e782:	4413      	add	r3, r2
 800e784:	009b      	lsls	r3, r3, #2
 800e786:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 800e78a:	68fa      	ldr	r2, [r7, #12]
 800e78c:	4413      	add	r3, r2
 800e78e:	3304      	adds	r3, #4
 800e790:	61fb      	str	r3, [r7, #28]
                obj = wolfSSL_X509_NAME_ENTRY_get_object(e);
 800e792:	69f8      	ldr	r0, [r7, #28]
 800e794:	f7ff ffbd 	bl	800e712 <wolfSSL_X509_NAME_ENTRY_get_object>
 800e798:	61b8      	str	r0, [r7, #24]
                if (obj == NULL) {
 800e79a:	69bb      	ldr	r3, [r7, #24]
 800e79c:	2b00      	cmp	r3, #0
 800e79e:	d102      	bne.n	800e7a6 <AddAllEntry+0x5a>
                    return BAD_FUNC_ARG;
 800e7a0:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800e7a4:	e05d      	b.n	800e862 <AddAllEntry+0x116>
                }

                XMEMCPY(fullName + *idx, "/", 1); *idx = *idx + 1;
 800e7a6:	683b      	ldr	r3, [r7, #0]
 800e7a8:	681b      	ldr	r3, [r3, #0]
 800e7aa:	461a      	mov	r2, r3
 800e7ac:	68bb      	ldr	r3, [r7, #8]
 800e7ae:	4413      	add	r3, r2
 800e7b0:	2201      	movs	r2, #1
 800e7b2:	492e      	ldr	r1, [pc, #184]	@ (800e86c <AddAllEntry+0x120>)
 800e7b4:	4618      	mov	r0, r3
 800e7b6:	f019 fef1 	bl	802859c <memcpy>
 800e7ba:	683b      	ldr	r3, [r7, #0]
 800e7bc:	681b      	ldr	r3, [r3, #0]
 800e7be:	1c5a      	adds	r2, r3, #1
 800e7c0:	683b      	ldr	r3, [r7, #0]
 800e7c2:	601a      	str	r2, [r3, #0]
                sz = (int)XSTRLEN(obj->sName);
 800e7c4:	69bb      	ldr	r3, [r7, #24]
 800e7c6:	3308      	adds	r3, #8
 800e7c8:	4618      	mov	r0, r3
 800e7ca:	f7f1 fd0b 	bl	80001e4 <strlen>
 800e7ce:	4603      	mov	r3, r0
 800e7d0:	617b      	str	r3, [r7, #20]
                XMEMCPY(fullName + *idx, obj->sName, sz);
 800e7d2:	683b      	ldr	r3, [r7, #0]
 800e7d4:	681b      	ldr	r3, [r3, #0]
 800e7d6:	461a      	mov	r2, r3
 800e7d8:	68bb      	ldr	r3, [r7, #8]
 800e7da:	1898      	adds	r0, r3, r2
 800e7dc:	69bb      	ldr	r3, [r7, #24]
 800e7de:	3308      	adds	r3, #8
 800e7e0:	697a      	ldr	r2, [r7, #20]
 800e7e2:	4619      	mov	r1, r3
 800e7e4:	f019 feda 	bl	802859c <memcpy>
                *idx += sz;
 800e7e8:	683b      	ldr	r3, [r7, #0]
 800e7ea:	681a      	ldr	r2, [r3, #0]
 800e7ec:	697b      	ldr	r3, [r7, #20]
 800e7ee:	441a      	add	r2, r3
 800e7f0:	683b      	ldr	r3, [r7, #0]
 800e7f2:	601a      	str	r2, [r3, #0]
                XMEMCPY(fullName + *idx, "=", 1); *idx = *idx + 1;
 800e7f4:	683b      	ldr	r3, [r7, #0]
 800e7f6:	681b      	ldr	r3, [r3, #0]
 800e7f8:	461a      	mov	r2, r3
 800e7fa:	68bb      	ldr	r3, [r7, #8]
 800e7fc:	4413      	add	r3, r2
 800e7fe:	2201      	movs	r2, #1
 800e800:	491b      	ldr	r1, [pc, #108]	@ (800e870 <AddAllEntry+0x124>)
 800e802:	4618      	mov	r0, r3
 800e804:	f019 feca 	bl	802859c <memcpy>
 800e808:	683b      	ldr	r3, [r7, #0]
 800e80a:	681b      	ldr	r3, [r3, #0]
 800e80c:	1c5a      	adds	r2, r3, #1
 800e80e:	683b      	ldr	r3, [r7, #0]
 800e810:	601a      	str	r2, [r3, #0]

                data = wolfSSL_ASN1_STRING_data(e->value);
 800e812:	69fb      	ldr	r3, [r7, #28]
 800e814:	685b      	ldr	r3, [r3, #4]
 800e816:	4618      	mov	r0, r3
 800e818:	f7fd f97b 	bl	800bb12 <wolfSSL_ASN1_STRING_data>
 800e81c:	6138      	str	r0, [r7, #16]
                if (data != NULL) {
 800e81e:	693b      	ldr	r3, [r7, #16]
 800e820:	2b00      	cmp	r3, #0
 800e822:	d014      	beq.n	800e84e <AddAllEntry+0x102>
                    sz = (int)XSTRLEN((const char*)data);
 800e824:	6938      	ldr	r0, [r7, #16]
 800e826:	f7f1 fcdd 	bl	80001e4 <strlen>
 800e82a:	4603      	mov	r3, r0
 800e82c:	617b      	str	r3, [r7, #20]
                    XMEMCPY(fullName + *idx, data, sz);
 800e82e:	683b      	ldr	r3, [r7, #0]
 800e830:	681b      	ldr	r3, [r3, #0]
 800e832:	461a      	mov	r2, r3
 800e834:	68bb      	ldr	r3, [r7, #8]
 800e836:	4413      	add	r3, r2
 800e838:	697a      	ldr	r2, [r7, #20]
 800e83a:	6939      	ldr	r1, [r7, #16]
 800e83c:	4618      	mov	r0, r3
 800e83e:	f019 fead 	bl	802859c <memcpy>
                    *idx += sz;
 800e842:	683b      	ldr	r3, [r7, #0]
 800e844:	681a      	ldr	r2, [r3, #0]
 800e846:	697b      	ldr	r3, [r7, #20]
 800e848:	441a      	add	r2, r3
 800e84a:	683b      	ldr	r3, [r7, #0]
 800e84c:	601a      	str	r2, [r3, #0]
                }

                ret++;
 800e84e:	6a3b      	ldr	r3, [r7, #32]
 800e850:	3301      	adds	r3, #1
 800e852:	623b      	str	r3, [r7, #32]
        for (i = 0; i < MAX_NAME_ENTRIES; i++) {
 800e854:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e856:	3301      	adds	r3, #1
 800e858:	627b      	str	r3, [r7, #36]	@ 0x24
 800e85a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e85c:	2b0f      	cmp	r3, #15
 800e85e:	dd81      	ble.n	800e764 <AddAllEntry+0x18>
            }
        }
        (void)fullNameSz;
        return ret;
 800e860:	6a3b      	ldr	r3, [r7, #32]
    }
 800e862:	4618      	mov	r0, r3
 800e864:	3728      	adds	r7, #40	@ 0x28
 800e866:	46bd      	mov	sp, r7
 800e868:	bd80      	pop	{r7, pc}
 800e86a:	bf00      	nop
 800e86c:	0802a0fc 	.word	0x0802a0fc
 800e870:	0802ae28 	.word	0x0802ae28

0800e874 <RebuildFullName>:


    /* Converts a list of entries in WOLFSSL_X509_NAME struct into a string
     * returns 0 on success */
    static int RebuildFullName(WOLFSSL_X509_NAME* name)
    {
 800e874:	b580      	push	{r7, lr}
 800e876:	b08a      	sub	sp, #40	@ 0x28
 800e878:	af00      	add	r7, sp, #0
 800e87a:	6078      	str	r0, [r7, #4]
        int totalLen = 0, i, idx, entryCount = 0;
 800e87c:	2300      	movs	r3, #0
 800e87e:	627b      	str	r3, [r7, #36]	@ 0x24
 800e880:	2300      	movs	r3, #0
 800e882:	61fb      	str	r3, [r7, #28]

        if (name == NULL)
 800e884:	687b      	ldr	r3, [r7, #4]
 800e886:	2b00      	cmp	r3, #0
 800e888:	d102      	bne.n	800e890 <RebuildFullName+0x1c>
            return BAD_FUNC_ARG;
 800e88a:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800e88e:	e086      	b.n	800e99e <RebuildFullName+0x12a>

        for (i = 0; i < MAX_NAME_ENTRIES; i++) {
 800e890:	2300      	movs	r3, #0
 800e892:	623b      	str	r3, [r7, #32]
 800e894:	e036      	b.n	800e904 <RebuildFullName+0x90>
            if (name->entry[i].set) {
 800e896:	6879      	ldr	r1, [r7, #4]
 800e898:	6a3a      	ldr	r2, [r7, #32]
 800e89a:	4613      	mov	r3, r2
 800e89c:	009b      	lsls	r3, r3, #2
 800e89e:	4413      	add	r3, r2
 800e8a0:	009b      	lsls	r3, r3, #2
 800e8a2:	440b      	add	r3, r1
 800e8a4:	f503 7318 	add.w	r3, r3, #608	@ 0x260
 800e8a8:	681b      	ldr	r3, [r3, #0]
 800e8aa:	2b00      	cmp	r3, #0
 800e8ac:	d027      	beq.n	800e8fe <RebuildFullName+0x8a>
                WOLFSSL_X509_NAME_ENTRY* e;
                WOLFSSL_ASN1_OBJECT* obj;

                e = &name->entry[i];
 800e8ae:	6a3a      	ldr	r2, [r7, #32]
 800e8b0:	4613      	mov	r3, r2
 800e8b2:	009b      	lsls	r3, r3, #2
 800e8b4:	4413      	add	r3, r2
 800e8b6:	009b      	lsls	r3, r3, #2
 800e8b8:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 800e8bc:	687a      	ldr	r2, [r7, #4]
 800e8be:	4413      	add	r3, r2
 800e8c0:	3304      	adds	r3, #4
 800e8c2:	617b      	str	r3, [r7, #20]
                obj = wolfSSL_X509_NAME_ENTRY_get_object(e);
 800e8c4:	6978      	ldr	r0, [r7, #20]
 800e8c6:	f7ff ff24 	bl	800e712 <wolfSSL_X509_NAME_ENTRY_get_object>
 800e8ca:	6138      	str	r0, [r7, #16]
                if (obj == NULL)
 800e8cc:	693b      	ldr	r3, [r7, #16]
 800e8ce:	2b00      	cmp	r3, #0
 800e8d0:	d102      	bne.n	800e8d8 <RebuildFullName+0x64>
                    return BAD_FUNC_ARG;
 800e8d2:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800e8d6:	e062      	b.n	800e99e <RebuildFullName+0x12a>

                totalLen += (int)XSTRLEN(obj->sName) + 2;/*+2 for '/' and '=' */
 800e8d8:	693b      	ldr	r3, [r7, #16]
 800e8da:	3308      	adds	r3, #8
 800e8dc:	4618      	mov	r0, r3
 800e8de:	f7f1 fc81 	bl	80001e4 <strlen>
 800e8e2:	4603      	mov	r3, r0
 800e8e4:	3302      	adds	r3, #2
 800e8e6:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800e8e8:	4413      	add	r3, r2
 800e8ea:	627b      	str	r3, [r7, #36]	@ 0x24
                totalLen += wolfSSL_ASN1_STRING_length(e->value);
 800e8ec:	697b      	ldr	r3, [r7, #20]
 800e8ee:	685b      	ldr	r3, [r3, #4]
 800e8f0:	4618      	mov	r0, r3
 800e8f2:	f7fd f921 	bl	800bb38 <wolfSSL_ASN1_STRING_length>
 800e8f6:	4602      	mov	r2, r0
 800e8f8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e8fa:	4413      	add	r3, r2
 800e8fc:	627b      	str	r3, [r7, #36]	@ 0x24
        for (i = 0; i < MAX_NAME_ENTRIES; i++) {
 800e8fe:	6a3b      	ldr	r3, [r7, #32]
 800e900:	3301      	adds	r3, #1
 800e902:	623b      	str	r3, [r7, #32]
 800e904:	6a3b      	ldr	r3, [r7, #32]
 800e906:	2b0f      	cmp	r3, #15
 800e908:	ddc5      	ble.n	800e896 <RebuildFullName+0x22>
            }
        }

        if (name->dynamicName) {
 800e90a:	687b      	ldr	r3, [r7, #4]
 800e90c:	685b      	ldr	r3, [r3, #4]
 800e90e:	2b00      	cmp	r3, #0
 800e910:	d010      	beq.n	800e934 <RebuildFullName+0xc0>
            XFREE(name->name, name->heap, DYNAMIC_TYPE_X509);
 800e912:	687b      	ldr	r3, [r7, #4]
 800e914:	681b      	ldr	r3, [r3, #0]
 800e916:	61bb      	str	r3, [r7, #24]
 800e918:	69bb      	ldr	r3, [r7, #24]
 800e91a:	2b00      	cmp	r3, #0
 800e91c:	d002      	beq.n	800e924 <RebuildFullName+0xb0>
 800e91e:	69b8      	ldr	r0, [r7, #24]
 800e920:	f010 f8ce 	bl	801eac0 <wolfSSL_Free>
            name->name = name->staticName;
 800e924:	687b      	ldr	r3, [r7, #4]
 800e926:	f103 020c 	add.w	r2, r3, #12
 800e92a:	687b      	ldr	r3, [r7, #4]
 800e92c:	601a      	str	r2, [r3, #0]
            name->dynamicName = 0;
 800e92e:	687b      	ldr	r3, [r7, #4]
 800e930:	2200      	movs	r2, #0
 800e932:	605a      	str	r2, [r3, #4]
        }

        if (totalLen >= ASN_NAME_MAX) {
 800e934:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e936:	f5b3 7fb4 	cmp.w	r3, #360	@ 0x168
 800e93a:	db11      	blt.n	800e960 <RebuildFullName+0xec>
            name->name = (char*)XMALLOC(totalLen + 1, name->heap,
 800e93c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e93e:	3301      	adds	r3, #1
 800e940:	4618      	mov	r0, r3
 800e942:	f010 f8a1 	bl	801ea88 <wolfSSL_Malloc>
 800e946:	4602      	mov	r2, r0
 800e948:	687b      	ldr	r3, [r7, #4]
 800e94a:	601a      	str	r2, [r3, #0]
                    DYNAMIC_TYPE_X509);
            if (name->name == NULL)
 800e94c:	687b      	ldr	r3, [r7, #4]
 800e94e:	681b      	ldr	r3, [r3, #0]
 800e950:	2b00      	cmp	r3, #0
 800e952:	d102      	bne.n	800e95a <RebuildFullName+0xe6>
                return MEMORY_E;
 800e954:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800e958:	e021      	b.n	800e99e <RebuildFullName+0x12a>
            name->dynamicName = 1;
 800e95a:	687b      	ldr	r3, [r7, #4]
 800e95c:	2201      	movs	r2, #1
 800e95e:	605a      	str	r2, [r3, #4]
        }

        idx = 0;
 800e960:	2300      	movs	r3, #0
 800e962:	60fb      	str	r3, [r7, #12]
        entryCount = AddAllEntry(name, name->name, totalLen, &idx);
 800e964:	687b      	ldr	r3, [r7, #4]
 800e966:	6819      	ldr	r1, [r3, #0]
 800e968:	f107 030c 	add.w	r3, r7, #12
 800e96c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800e96e:	6878      	ldr	r0, [r7, #4]
 800e970:	f7ff feec 	bl	800e74c <AddAllEntry>
 800e974:	61f8      	str	r0, [r7, #28]
        if (entryCount < 0)
 800e976:	69fb      	ldr	r3, [r7, #28]
 800e978:	2b00      	cmp	r3, #0
 800e97a:	da01      	bge.n	800e980 <RebuildFullName+0x10c>
            return entryCount;
 800e97c:	69fb      	ldr	r3, [r7, #28]
 800e97e:	e00e      	b.n	800e99e <RebuildFullName+0x12a>

        name->name[idx] = '\0';
 800e980:	687b      	ldr	r3, [r7, #4]
 800e982:	681b      	ldr	r3, [r3, #0]
 800e984:	68fa      	ldr	r2, [r7, #12]
 800e986:	4413      	add	r3, r2
 800e988:	2200      	movs	r2, #0
 800e98a:	701a      	strb	r2, [r3, #0]
        name->sz = idx + 1; /* size includes null terminator */
 800e98c:	68fb      	ldr	r3, [r7, #12]
 800e98e:	1c5a      	adds	r2, r3, #1
 800e990:	687b      	ldr	r3, [r7, #4]
 800e992:	609a      	str	r2, [r3, #8]
        name->entrySz = entryCount;
 800e994:	687b      	ldr	r3, [r7, #4]
 800e996:	69fa      	ldr	r2, [r7, #28]
 800e998:	f8c3 2250 	str.w	r2, [r3, #592]	@ 0x250

        return 0;
 800e99c:	2300      	movs	r3, #0
    }
 800e99e:	4618      	mov	r0, r3
 800e9a0:	3728      	adds	r7, #40	@ 0x28
 800e9a2:	46bd      	mov	sp, r7
 800e9a4:	bd80      	pop	{r7, pc}

0800e9a6 <wolfSSL_X509_NAME_add_entry>:
    /* Copies entry into name. With it being copied freeing entry becomes the
     * callers responsibility.
     * returns 1 for success and 0 for error */
    int wolfSSL_X509_NAME_add_entry(WOLFSSL_X509_NAME* name,
            WOLFSSL_X509_NAME_ENTRY* entry, int idx, int set)
    {
 800e9a6:	b5f0      	push	{r4, r5, r6, r7, lr}
 800e9a8:	b08b      	sub	sp, #44	@ 0x2c
 800e9aa:	af02      	add	r7, sp, #8
 800e9ac:	60f8      	str	r0, [r7, #12]
 800e9ae:	60b9      	str	r1, [r7, #8]
 800e9b0:	607a      	str	r2, [r7, #4]
 800e9b2:	603b      	str	r3, [r7, #0]
        WOLFSSL_X509_NAME_ENTRY* current = NULL;
 800e9b4:	2300      	movs	r3, #0
 800e9b6:	617b      	str	r3, [r7, #20]

#ifdef WOLFSSL_DEBUG_OPENSSL
        WOLFSSL_ENTER("wolfSSL_X509_NAME_add_entry");
#endif

        if (name == NULL || entry == NULL || entry->value == NULL) {
 800e9b8:	68fb      	ldr	r3, [r7, #12]
 800e9ba:	2b00      	cmp	r3, #0
 800e9bc:	d006      	beq.n	800e9cc <wolfSSL_X509_NAME_add_entry+0x26>
 800e9be:	68bb      	ldr	r3, [r7, #8]
 800e9c0:	2b00      	cmp	r3, #0
 800e9c2:	d003      	beq.n	800e9cc <wolfSSL_X509_NAME_add_entry+0x26>
 800e9c4:	68bb      	ldr	r3, [r7, #8]
 800e9c6:	685b      	ldr	r3, [r3, #4]
 800e9c8:	2b00      	cmp	r3, #0
 800e9ca:	d101      	bne.n	800e9d0 <wolfSSL_X509_NAME_add_entry+0x2a>
            WOLFSSL_MSG("NULL argument passed in");
            return WOLFSSL_FAILURE;
 800e9cc:	2300      	movs	r3, #0
 800e9ce:	e079      	b.n	800eac4 <wolfSSL_X509_NAME_add_entry+0x11e>
        }

        if (idx >= 0) {
 800e9d0:	687b      	ldr	r3, [r7, #4]
 800e9d2:	2b00      	cmp	r3, #0
 800e9d4:	db07      	blt.n	800e9e6 <wolfSSL_X509_NAME_add_entry+0x40>
            /* place in specific index */

            if (idx >= MAX_NAME_ENTRIES) {
 800e9d6:	687b      	ldr	r3, [r7, #4]
 800e9d8:	2b0f      	cmp	r3, #15
 800e9da:	dd01      	ble.n	800e9e0 <wolfSSL_X509_NAME_add_entry+0x3a>
                WOLFSSL_MSG("Error index to insert entry is larger than array");
                return WOLFSSL_FAILURE;
 800e9dc:	2300      	movs	r3, #0
 800e9de:	e071      	b.n	800eac4 <wolfSSL_X509_NAME_add_entry+0x11e>
            }
            i = idx;
 800e9e0:	687b      	ldr	r3, [r7, #4]
 800e9e2:	61bb      	str	r3, [r7, #24]
 800e9e4:	e01b      	b.n	800ea1e <wolfSSL_X509_NAME_add_entry+0x78>
        }
        else {
            /* iterate through and find first open spot */
            for (i = 0; i < MAX_NAME_ENTRIES; i++) {
 800e9e6:	2300      	movs	r3, #0
 800e9e8:	61bb      	str	r3, [r7, #24]
 800e9ea:	e00e      	b.n	800ea0a <wolfSSL_X509_NAME_add_entry+0x64>
                if (name->entry[i].set != 1) { /* not set so overwritten */
 800e9ec:	68f9      	ldr	r1, [r7, #12]
 800e9ee:	69ba      	ldr	r2, [r7, #24]
 800e9f0:	4613      	mov	r3, r2
 800e9f2:	009b      	lsls	r3, r3, #2
 800e9f4:	4413      	add	r3, r2
 800e9f6:	009b      	lsls	r3, r3, #2
 800e9f8:	440b      	add	r3, r1
 800e9fa:	f503 7318 	add.w	r3, r3, #608	@ 0x260
 800e9fe:	681b      	ldr	r3, [r3, #0]
 800ea00:	2b01      	cmp	r3, #1
 800ea02:	d106      	bne.n	800ea12 <wolfSSL_X509_NAME_add_entry+0x6c>
            for (i = 0; i < MAX_NAME_ENTRIES; i++) {
 800ea04:	69bb      	ldr	r3, [r7, #24]
 800ea06:	3301      	adds	r3, #1
 800ea08:	61bb      	str	r3, [r7, #24]
 800ea0a:	69bb      	ldr	r3, [r7, #24]
 800ea0c:	2b0f      	cmp	r3, #15
 800ea0e:	dded      	ble.n	800e9ec <wolfSSL_X509_NAME_add_entry+0x46>
 800ea10:	e000      	b.n	800ea14 <wolfSSL_X509_NAME_add_entry+0x6e>
                    WOLFSSL_MSG("Found place for name entry");
                    break;
 800ea12:	bf00      	nop
                }
            }

            if (i == MAX_NAME_ENTRIES) {
 800ea14:	69bb      	ldr	r3, [r7, #24]
 800ea16:	2b10      	cmp	r3, #16
 800ea18:	d101      	bne.n	800ea1e <wolfSSL_X509_NAME_add_entry+0x78>
                WOLFSSL_MSG("No spot found for name entry");
                return WOLFSSL_FAILURE;
 800ea1a:	2300      	movs	r3, #0
 800ea1c:	e052      	b.n	800eac4 <wolfSSL_X509_NAME_add_entry+0x11e>
            }
        }

        current = &name->entry[i];
 800ea1e:	69ba      	ldr	r2, [r7, #24]
 800ea20:	4613      	mov	r3, r2
 800ea22:	009b      	lsls	r3, r3, #2
 800ea24:	4413      	add	r3, r2
 800ea26:	009b      	lsls	r3, r3, #2
 800ea28:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 800ea2c:	68fa      	ldr	r2, [r7, #12]
 800ea2e:	4413      	add	r3, r2
 800ea30:	3304      	adds	r3, #4
 800ea32:	617b      	str	r3, [r7, #20]
        if (current->set == 0)
 800ea34:	697b      	ldr	r3, [r7, #20]
 800ea36:	68db      	ldr	r3, [r3, #12]
 800ea38:	2b00      	cmp	r3, #0
 800ea3a:	d106      	bne.n	800ea4a <wolfSSL_X509_NAME_add_entry+0xa4>
            name->entrySz++;
 800ea3c:	68fb      	ldr	r3, [r7, #12]
 800ea3e:	f8d3 3250 	ldr.w	r3, [r3, #592]	@ 0x250
 800ea42:	1c5a      	adds	r2, r3, #1
 800ea44:	68fb      	ldr	r3, [r7, #12]
 800ea46:	f8c3 2250 	str.w	r2, [r3, #592]	@ 0x250

        if (wolfSSL_X509_NAME_ENTRY_create_by_NID(&current,
 800ea4a:	68bb      	ldr	r3, [r7, #8]
 800ea4c:	689c      	ldr	r4, [r3, #8]
                            entry->nid,
                            wolfSSL_ASN1_STRING_type(entry->value),
 800ea4e:	68bb      	ldr	r3, [r7, #8]
 800ea50:	685b      	ldr	r3, [r3, #4]
        if (wolfSSL_X509_NAME_ENTRY_create_by_NID(&current,
 800ea52:	4618      	mov	r0, r3
 800ea54:	f7fd f84a 	bl	800baec <wolfSSL_ASN1_STRING_type>
 800ea58:	4605      	mov	r5, r0
                            wolfSSL_ASN1_STRING_data(entry->value),
 800ea5a:	68bb      	ldr	r3, [r7, #8]
 800ea5c:	685b      	ldr	r3, [r3, #4]
 800ea5e:	4618      	mov	r0, r3
 800ea60:	f7fd f857 	bl	800bb12 <wolfSSL_ASN1_STRING_data>
 800ea64:	4606      	mov	r6, r0
                            wolfSSL_ASN1_STRING_length(entry->value)) != NULL)
 800ea66:	68bb      	ldr	r3, [r7, #8]
 800ea68:	685b      	ldr	r3, [r3, #4]
        if (wolfSSL_X509_NAME_ENTRY_create_by_NID(&current,
 800ea6a:	4618      	mov	r0, r3
 800ea6c:	f7fd f864 	bl	800bb38 <wolfSSL_ASN1_STRING_length>
 800ea70:	4603      	mov	r3, r0
 800ea72:	f107 0014 	add.w	r0, r7, #20
 800ea76:	9300      	str	r3, [sp, #0]
 800ea78:	4633      	mov	r3, r6
 800ea7a:	462a      	mov	r2, r5
 800ea7c:	4621      	mov	r1, r4
 800ea7e:	f7ff fe16 	bl	800e6ae <wolfSSL_X509_NAME_ENTRY_create_by_NID>
 800ea82:	4603      	mov	r3, r0
 800ea84:	2b00      	cmp	r3, #0
 800ea86:	d002      	beq.n	800ea8e <wolfSSL_X509_NAME_add_entry+0xe8>
        {
            ret = WOLFSSL_SUCCESS;
 800ea88:	2301      	movs	r3, #1
 800ea8a:	61fb      	str	r3, [r7, #28]
 800ea8c:	e001      	b.n	800ea92 <wolfSSL_X509_NAME_add_entry+0xec>
                ret = WOLFSSL_FAILURE;
            }
        #endif
        }
        else {
            ret = WOLFSSL_FAILURE;
 800ea8e:	2300      	movs	r3, #0
 800ea90:	61fb      	str	r3, [r7, #28]
        }

        if (ret != WOLFSSL_SUCCESS) {
 800ea92:	69fb      	ldr	r3, [r7, #28]
 800ea94:	2b01      	cmp	r3, #1
 800ea96:	d00c      	beq.n	800eab2 <wolfSSL_X509_NAME_add_entry+0x10c>
            WOLFSSL_MSG("Error adding the name entry");
            if (current->set == 0)
 800ea98:	697b      	ldr	r3, [r7, #20]
 800ea9a:	68db      	ldr	r3, [r3, #12]
 800ea9c:	2b00      	cmp	r3, #0
 800ea9e:	d106      	bne.n	800eaae <wolfSSL_X509_NAME_add_entry+0x108>
                name->entrySz--;
 800eaa0:	68fb      	ldr	r3, [r7, #12]
 800eaa2:	f8d3 3250 	ldr.w	r3, [r3, #592]	@ 0x250
 800eaa6:	1e5a      	subs	r2, r3, #1
 800eaa8:	68fb      	ldr	r3, [r7, #12]
 800eaaa:	f8c3 2250 	str.w	r2, [r3, #592]	@ 0x250
            return WOLFSSL_FAILURE;
 800eaae:	2300      	movs	r3, #0
 800eab0:	e008      	b.n	800eac4 <wolfSSL_X509_NAME_add_entry+0x11e>
        }

        if (RebuildFullName(name) != 0)
 800eab2:	68f8      	ldr	r0, [r7, #12]
 800eab4:	f7ff fede 	bl	800e874 <RebuildFullName>
 800eab8:	4603      	mov	r3, r0
 800eaba:	2b00      	cmp	r3, #0
 800eabc:	d001      	beq.n	800eac2 <wolfSSL_X509_NAME_add_entry+0x11c>
            return WOLFSSL_FAILURE;
 800eabe:	2300      	movs	r3, #0
 800eac0:	e000      	b.n	800eac4 <wolfSSL_X509_NAME_add_entry+0x11e>

        (void)set;
        return WOLFSSL_SUCCESS;
 800eac2:	2301      	movs	r3, #1
    }
 800eac4:	4618      	mov	r0, r3
 800eac6:	3724      	adds	r7, #36	@ 0x24
 800eac8:	46bd      	mov	sp, r7
 800eaca:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800eacc <wolfSSL_X509_NAME_add_entry_by_NID>:
    }

    int wolfSSL_X509_NAME_add_entry_by_NID(WOLFSSL_X509_NAME *name, int nid,
                                           int type, const unsigned char *bytes,
                                           int len, int loc, int set)
    {
 800eacc:	b580      	push	{r7, lr}
 800eace:	b088      	sub	sp, #32
 800ead0:	af02      	add	r7, sp, #8
 800ead2:	60f8      	str	r0, [r7, #12]
 800ead4:	60b9      	str	r1, [r7, #8]
 800ead6:	607a      	str	r2, [r7, #4]
 800ead8:	603b      	str	r3, [r7, #0]
        int ret;
        WOLFSSL_X509_NAME_ENTRY* entry;
        WOLFSSL_ENTER("wolfSSL_X509_NAME_add_entry_by_NID");
        entry = wolfSSL_X509_NAME_ENTRY_create_by_NID(NULL, nid, type, bytes,
 800eada:	6a3b      	ldr	r3, [r7, #32]
 800eadc:	9300      	str	r3, [sp, #0]
 800eade:	683b      	ldr	r3, [r7, #0]
 800eae0:	687a      	ldr	r2, [r7, #4]
 800eae2:	68b9      	ldr	r1, [r7, #8]
 800eae4:	2000      	movs	r0, #0
 800eae6:	f7ff fde2 	bl	800e6ae <wolfSSL_X509_NAME_ENTRY_create_by_NID>
 800eaea:	6178      	str	r0, [r7, #20]
                len);
        if (entry == NULL)
 800eaec:	697b      	ldr	r3, [r7, #20]
 800eaee:	2b00      	cmp	r3, #0
 800eaf0:	d101      	bne.n	800eaf6 <wolfSSL_X509_NAME_add_entry_by_NID+0x2a>
            return WOLFSSL_FAILURE;
 800eaf2:	2300      	movs	r3, #0
 800eaf4:	e00a      	b.n	800eb0c <wolfSSL_X509_NAME_add_entry_by_NID+0x40>
        ret = wolfSSL_X509_NAME_add_entry(name, entry, loc, set);
 800eaf6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800eaf8:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800eafa:	6979      	ldr	r1, [r7, #20]
 800eafc:	68f8      	ldr	r0, [r7, #12]
 800eafe:	f7ff ff52 	bl	800e9a6 <wolfSSL_X509_NAME_add_entry>
 800eb02:	6138      	str	r0, [r7, #16]
        wolfSSL_X509_NAME_ENTRY_free(entry);
 800eb04:	6978      	ldr	r0, [r7, #20]
 800eb06:	f7ff fd62 	bl	800e5ce <wolfSSL_X509_NAME_ENTRY_free>
        return ret;
 800eb0a:	693b      	ldr	r3, [r7, #16]
    }
 800eb0c:	4618      	mov	r0, r3
 800eb0e:	3718      	adds	r7, #24
 800eb10:	46bd      	mov	sp, r7
 800eb12:	bd80      	pop	{r7, pc}

0800eb14 <wolfSSL_X509_NAME_get_entry>:

    /* returns a pointer to the internal entry at location 'loc' on success,
     * a null pointer is returned in fail cases */
    WOLFSSL_X509_NAME_ENTRY *wolfSSL_X509_NAME_get_entry(
                                             WOLFSSL_X509_NAME *name, int loc)
    {
 800eb14:	b480      	push	{r7}
 800eb16:	b083      	sub	sp, #12
 800eb18:	af00      	add	r7, sp, #0
 800eb1a:	6078      	str	r0, [r7, #4]
 800eb1c:	6039      	str	r1, [r7, #0]
#ifdef WOLFSSL_DEBUG_OPENSSL
        WOLFSSL_ENTER("wolfSSL_X509_NAME_get_entry");
#endif

        if (name == NULL) {
 800eb1e:	687b      	ldr	r3, [r7, #4]
 800eb20:	2b00      	cmp	r3, #0
 800eb22:	d101      	bne.n	800eb28 <wolfSSL_X509_NAME_get_entry+0x14>
            return NULL;
 800eb24:	2300      	movs	r3, #0
 800eb26:	e01f      	b.n	800eb68 <wolfSSL_X509_NAME_get_entry+0x54>
        }

        if (loc < 0 || loc >= MAX_NAME_ENTRIES) {
 800eb28:	683b      	ldr	r3, [r7, #0]
 800eb2a:	2b00      	cmp	r3, #0
 800eb2c:	db02      	blt.n	800eb34 <wolfSSL_X509_NAME_get_entry+0x20>
 800eb2e:	683b      	ldr	r3, [r7, #0]
 800eb30:	2b0f      	cmp	r3, #15
 800eb32:	dd01      	ble.n	800eb38 <wolfSSL_X509_NAME_get_entry+0x24>
            WOLFSSL_MSG("Bad argument");
            return NULL;
 800eb34:	2300      	movs	r3, #0
 800eb36:	e017      	b.n	800eb68 <wolfSSL_X509_NAME_get_entry+0x54>
        }

        if (name->entry[loc].set) {
 800eb38:	6879      	ldr	r1, [r7, #4]
 800eb3a:	683a      	ldr	r2, [r7, #0]
 800eb3c:	4613      	mov	r3, r2
 800eb3e:	009b      	lsls	r3, r3, #2
 800eb40:	4413      	add	r3, r2
 800eb42:	009b      	lsls	r3, r3, #2
 800eb44:	440b      	add	r3, r1
 800eb46:	f503 7318 	add.w	r3, r3, #608	@ 0x260
 800eb4a:	681b      	ldr	r3, [r3, #0]
 800eb4c:	2b00      	cmp	r3, #0
 800eb4e:	d00a      	beq.n	800eb66 <wolfSSL_X509_NAME_get_entry+0x52>
            *  updating "set" by position + 1. "plus 1" means to avoid "not set"
            *  zero.
            */
            name->entry[loc].set = loc + 1;
#endif
            return &name->entry[loc];
 800eb50:	683a      	ldr	r2, [r7, #0]
 800eb52:	4613      	mov	r3, r2
 800eb54:	009b      	lsls	r3, r3, #2
 800eb56:	4413      	add	r3, r2
 800eb58:	009b      	lsls	r3, r3, #2
 800eb5a:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 800eb5e:	687a      	ldr	r2, [r7, #4]
 800eb60:	4413      	add	r3, r2
 800eb62:	3304      	adds	r3, #4
 800eb64:	e000      	b.n	800eb68 <wolfSSL_X509_NAME_get_entry+0x54>
        }
        else {
            return NULL;
 800eb66:	2300      	movs	r3, #0
        }
    }
 800eb68:	4618      	mov	r0, r3
 800eb6a:	370c      	adds	r7, #12
 800eb6c:	46bd      	mov	sp, r7
 800eb6e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800eb72:	4770      	bx	lr

0800eb74 <wolfSSL_sk_X509_NAME_pop_free>:
    return name;
}

void wolfSSL_sk_X509_NAME_pop_free(WOLF_STACK_OF(WOLFSSL_X509_NAME)* sk,
    void (*f) (WOLFSSL_X509_NAME*))
{
 800eb74:	b580      	push	{r7, lr}
 800eb76:	b082      	sub	sp, #8
 800eb78:	af00      	add	r7, sp, #0
 800eb7a:	6078      	str	r0, [r7, #4]
 800eb7c:	6039      	str	r1, [r7, #0]
    WOLFSSL_ENTER("wolfSSL_sk_X509_NAME_pop_free");
    wolfSSL_sk_pop_free(sk, (wolfSSL_sk_freefunc)f);
 800eb7e:	6839      	ldr	r1, [r7, #0]
 800eb80:	6878      	ldr	r0, [r7, #4]
 800eb82:	f7ff f8cf 	bl	800dd24 <wolfSSL_sk_pop_free>
}
 800eb86:	bf00      	nop
 800eb88:	3708      	adds	r7, #8
 800eb8a:	46bd      	mov	sp, r7
 800eb8c:	bd80      	pop	{r7, pc}

0800eb8e <wolfSSL_sk_X509_new_null>:
    (void)cb;
    return wolfSSL_sk_X509_new_null();
}

WOLFSSL_STACK* wolfSSL_sk_X509_new_null(void)
{
 800eb8e:	b580      	push	{r7, lr}
 800eb90:	b082      	sub	sp, #8
 800eb92:	af00      	add	r7, sp, #0
    WOLFSSL_STACK* s = (WOLFSSL_STACK*)XMALLOC(sizeof(WOLFSSL_STACK), NULL,
 800eb94:	2018      	movs	r0, #24
 800eb96:	f00f ff77 	bl	801ea88 <wolfSSL_Malloc>
 800eb9a:	6078      	str	r0, [r7, #4]
            DYNAMIC_TYPE_OPENSSL);
    if (s != NULL) {
 800eb9c:	687b      	ldr	r3, [r7, #4]
 800eb9e:	2b00      	cmp	r3, #0
 800eba0:	d007      	beq.n	800ebb2 <wolfSSL_sk_X509_new_null+0x24>
        XMEMSET(s, 0, sizeof(*s));
 800eba2:	2218      	movs	r2, #24
 800eba4:	2100      	movs	r1, #0
 800eba6:	6878      	ldr	r0, [r7, #4]
 800eba8:	f019 fc8e 	bl	80284c8 <memset>
        s->type = STACK_TYPE_X509;
 800ebac:	687b      	ldr	r3, [r7, #4]
 800ebae:	2200      	movs	r2, #0
 800ebb0:	751a      	strb	r2, [r3, #20]
    }

    return s;
 800ebb2:	687b      	ldr	r3, [r7, #4]
}
 800ebb4:	4618      	mov	r0, r3
 800ebb6:	3708      	adds	r7, #8
 800ebb8:	46bd      	mov	sp, r7
 800ebba:	bd80      	pop	{r7, pc}

0800ebbc <wolfSSL_X509_NAME_copy>:
#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
/* unlike wolfSSL_X509_NAME_dup this does not malloc a duplicate, only deep
 * copy. "to" is expected to be a fresh blank name, if not pointers could be
 * lost */
int wolfSSL_X509_NAME_copy(WOLFSSL_X509_NAME* from, WOLFSSL_X509_NAME* to)
{
 800ebbc:	b580      	push	{r7, lr}
 800ebbe:	b084      	sub	sp, #16
 800ebc0:	af00      	add	r7, sp, #0
 800ebc2:	6078      	str	r0, [r7, #4]
 800ebc4:	6039      	str	r1, [r7, #0]
    int i;

    WOLFSSL_ENTER("wolfSSL_X509_NAME_copy");

    if (from == NULL || to == NULL) {
 800ebc6:	687b      	ldr	r3, [r7, #4]
 800ebc8:	2b00      	cmp	r3, #0
 800ebca:	d002      	beq.n	800ebd2 <wolfSSL_X509_NAME_copy+0x16>
 800ebcc:	683b      	ldr	r3, [r7, #0]
 800ebce:	2b00      	cmp	r3, #0
 800ebd0:	d102      	bne.n	800ebd8 <wolfSSL_X509_NAME_copy+0x1c>
        WOLFSSL_MSG("NULL parameter");
        return BAD_FUNC_ARG;
 800ebd2:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800ebd6:	e044      	b.n	800ec62 <wolfSSL_X509_NAME_copy+0xa6>
        XMEMCPY(to->raw, from->raw, from->rawLen);
        to->rawLen = from->rawLen;
    }
#endif

    if (from->dynamicName) {
 800ebd8:	687b      	ldr	r3, [r7, #4]
 800ebda:	685b      	ldr	r3, [r3, #4]
 800ebdc:	2b00      	cmp	r3, #0
 800ebde:	d010      	beq.n	800ec02 <wolfSSL_X509_NAME_copy+0x46>
        to->name = (char*)XMALLOC(from->sz, to->heap, DYNAMIC_TYPE_SUBJECT_CN);
 800ebe0:	687b      	ldr	r3, [r7, #4]
 800ebe2:	689b      	ldr	r3, [r3, #8]
 800ebe4:	4618      	mov	r0, r3
 800ebe6:	f00f ff4f 	bl	801ea88 <wolfSSL_Malloc>
 800ebea:	4602      	mov	r2, r0
 800ebec:	683b      	ldr	r3, [r7, #0]
 800ebee:	601a      	str	r2, [r3, #0]
        if (to->name == NULL)
 800ebf0:	683b      	ldr	r3, [r7, #0]
 800ebf2:	681b      	ldr	r3, [r3, #0]
 800ebf4:	2b00      	cmp	r3, #0
 800ebf6:	d101      	bne.n	800ebfc <wolfSSL_X509_NAME_copy+0x40>
            return WOLFSSL_FAILURE;
 800ebf8:	2300      	movs	r3, #0
 800ebfa:	e032      	b.n	800ec62 <wolfSSL_X509_NAME_copy+0xa6>
        to->dynamicName = 1;
 800ebfc:	683b      	ldr	r3, [r7, #0]
 800ebfe:	2201      	movs	r2, #1
 800ec00:	605a      	str	r2, [r3, #4]
    }
    XMEMCPY(to->name, from->name, from->sz);
 800ec02:	683b      	ldr	r3, [r7, #0]
 800ec04:	6818      	ldr	r0, [r3, #0]
 800ec06:	687b      	ldr	r3, [r7, #4]
 800ec08:	6819      	ldr	r1, [r3, #0]
 800ec0a:	687b      	ldr	r3, [r7, #4]
 800ec0c:	689b      	ldr	r3, [r3, #8]
 800ec0e:	461a      	mov	r2, r3
 800ec10:	f019 fcc4 	bl	802859c <memcpy>
    to->sz = from->sz;
 800ec14:	687b      	ldr	r3, [r7, #4]
 800ec16:	689a      	ldr	r2, [r3, #8]
 800ec18:	683b      	ldr	r3, [r7, #0]
 800ec1a:	609a      	str	r2, [r3, #8]

    for (i = 0; i < MAX_NAME_ENTRIES; i++) {
 800ec1c:	2300      	movs	r3, #0
 800ec1e:	60fb      	str	r3, [r7, #12]
 800ec20:	e015      	b.n	800ec4e <wolfSSL_X509_NAME_copy+0x92>
        WOLFSSL_X509_NAME_ENTRY* ne = wolfSSL_X509_NAME_get_entry(from, i);
 800ec22:	68f9      	ldr	r1, [r7, #12]
 800ec24:	6878      	ldr	r0, [r7, #4]
 800ec26:	f7ff ff75 	bl	800eb14 <wolfSSL_X509_NAME_get_entry>
 800ec2a:	60b8      	str	r0, [r7, #8]
        if (ne != NULL) {
 800ec2c:	68bb      	ldr	r3, [r7, #8]
 800ec2e:	2b00      	cmp	r3, #0
 800ec30:	d00a      	beq.n	800ec48 <wolfSSL_X509_NAME_copy+0x8c>
            if (wolfSSL_X509_NAME_add_entry(to, ne, i, 1) != WOLFSSL_SUCCESS) {
 800ec32:	2301      	movs	r3, #1
 800ec34:	68fa      	ldr	r2, [r7, #12]
 800ec36:	68b9      	ldr	r1, [r7, #8]
 800ec38:	6838      	ldr	r0, [r7, #0]
 800ec3a:	f7ff feb4 	bl	800e9a6 <wolfSSL_X509_NAME_add_entry>
 800ec3e:	4603      	mov	r3, r0
 800ec40:	2b01      	cmp	r3, #1
 800ec42:	d001      	beq.n	800ec48 <wolfSSL_X509_NAME_copy+0x8c>
                return WOLFSSL_FAILURE;
 800ec44:	2300      	movs	r3, #0
 800ec46:	e00c      	b.n	800ec62 <wolfSSL_X509_NAME_copy+0xa6>
    for (i = 0; i < MAX_NAME_ENTRIES; i++) {
 800ec48:	68fb      	ldr	r3, [r7, #12]
 800ec4a:	3301      	adds	r3, #1
 800ec4c:	60fb      	str	r3, [r7, #12]
 800ec4e:	68fb      	ldr	r3, [r7, #12]
 800ec50:	2b0f      	cmp	r3, #15
 800ec52:	dde6      	ble.n	800ec22 <wolfSSL_X509_NAME_copy+0x66>
            }
        }
    }
    to->entrySz = from->entrySz;
 800ec54:	687b      	ldr	r3, [r7, #4]
 800ec56:	f8d3 2250 	ldr.w	r2, [r3, #592]	@ 0x250
 800ec5a:	683b      	ldr	r3, [r7, #0]
 800ec5c:	f8c3 2250 	str.w	r2, [r3, #592]	@ 0x250
    return WOLFSSL_SUCCESS;
 800ec60:	2301      	movs	r3, #1
}
 800ec62:	4618      	mov	r0, r3
 800ec64:	3710      	adds	r7, #16
 800ec66:	46bd      	mov	sp, r7
 800ec68:	bd80      	pop	{r7, pc}

0800ec6a <wolfSSL_X509_set_subject_name>:


/* copies over information from "name" to the "cert" subject name
 * returns WOLFSSL_SUCCESS on success */
int wolfSSL_X509_set_subject_name(WOLFSSL_X509 *cert, WOLFSSL_X509_NAME *name)
{
 800ec6a:	b580      	push	{r7, lr}
 800ec6c:	b082      	sub	sp, #8
 800ec6e:	af00      	add	r7, sp, #0
 800ec70:	6078      	str	r0, [r7, #4]
 800ec72:	6039      	str	r1, [r7, #0]
    WOLFSSL_ENTER("wolfSSL_X509_set_subject_name");
    if (cert == NULL || name == NULL)
 800ec74:	687b      	ldr	r3, [r7, #4]
 800ec76:	2b00      	cmp	r3, #0
 800ec78:	d002      	beq.n	800ec80 <wolfSSL_X509_set_subject_name+0x16>
 800ec7a:	683b      	ldr	r3, [r7, #0]
 800ec7c:	2b00      	cmp	r3, #0
 800ec7e:	d101      	bne.n	800ec84 <wolfSSL_X509_set_subject_name+0x1a>
        return WOLFSSL_FAILURE;
 800ec80:	2300      	movs	r3, #0
 800ec82:	e026      	b.n	800ecd2 <wolfSSL_X509_set_subject_name+0x68>

    FreeX509Name(&cert->subject);
 800ec84:	687b      	ldr	r3, [r7, #4]
 800ec86:	f503 63f1 	add.w	r3, r3, #1928	@ 0x788
 800ec8a:	4618      	mov	r0, r3
 800ec8c:	f7fa fbed 	bl	800946a <FreeX509Name>
    InitX509Name(&cert->subject, 0, cert->heap);
 800ec90:	687b      	ldr	r3, [r7, #4]
 800ec92:	f503 60f1 	add.w	r0, r3, #1928	@ 0x788
 800ec96:	687b      	ldr	r3, [r7, #4]
 800ec98:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 800ec9c:	461a      	mov	r2, r3
 800ec9e:	2100      	movs	r1, #0
 800eca0:	f7fa fbc4 	bl	800942c <InitX509Name>

    if (wolfSSL_X509_NAME_copy(name, &cert->subject) != WOLFSSL_SUCCESS) {
 800eca4:	687b      	ldr	r3, [r7, #4]
 800eca6:	f503 63f1 	add.w	r3, r3, #1928	@ 0x788
 800ecaa:	4619      	mov	r1, r3
 800ecac:	6838      	ldr	r0, [r7, #0]
 800ecae:	f7ff ff85 	bl	800ebbc <wolfSSL_X509_NAME_copy>
 800ecb2:	4603      	mov	r3, r0
 800ecb4:	2b01      	cmp	r3, #1
 800ecb6:	d007      	beq.n	800ecc8 <wolfSSL_X509_set_subject_name+0x5e>
        FreeX509Name(&cert->subject);
 800ecb8:	687b      	ldr	r3, [r7, #4]
 800ecba:	f503 63f1 	add.w	r3, r3, #1928	@ 0x788
 800ecbe:	4618      	mov	r0, r3
 800ecc0:	f7fa fbd3 	bl	800946a <FreeX509Name>
        return WOLFSSL_FAILURE;
 800ecc4:	2300      	movs	r3, #0
 800ecc6:	e004      	b.n	800ecd2 <wolfSSL_X509_set_subject_name+0x68>
    }

    cert->subject.x509 = cert;
 800ecc8:	687b      	ldr	r3, [r7, #4]
 800ecca:	687a      	ldr	r2, [r7, #4]
 800eccc:	f8c3 2b1c 	str.w	r2, [r3, #2844]	@ 0xb1c
    return WOLFSSL_SUCCESS;
 800ecd0:	2301      	movs	r3, #1
}
 800ecd2:	4618      	mov	r0, r3
 800ecd4:	3708      	adds	r7, #8
 800ecd6:	46bd      	mov	sp, r7
 800ecd8:	bd80      	pop	{r7, pc}

0800ecda <wolfSSL_X509_set_issuer_name>:


/* copies over information from "name" to the "cert" issuer name
 * returns WOLFSSL_SUCCESS on success */
int wolfSSL_X509_set_issuer_name(WOLFSSL_X509 *cert, WOLFSSL_X509_NAME *name)
{
 800ecda:	b580      	push	{r7, lr}
 800ecdc:	b082      	sub	sp, #8
 800ecde:	af00      	add	r7, sp, #0
 800ece0:	6078      	str	r0, [r7, #4]
 800ece2:	6039      	str	r1, [r7, #0]
    WOLFSSL_ENTER("wolfSSL_X509_set_issuer_name");
    if (cert == NULL || name == NULL)
 800ece4:	687b      	ldr	r3, [r7, #4]
 800ece6:	2b00      	cmp	r3, #0
 800ece8:	d002      	beq.n	800ecf0 <wolfSSL_X509_set_issuer_name+0x16>
 800ecea:	683b      	ldr	r3, [r7, #0]
 800ecec:	2b00      	cmp	r3, #0
 800ecee:	d101      	bne.n	800ecf4 <wolfSSL_X509_set_issuer_name+0x1a>
        return WOLFSSL_FAILURE;
 800ecf0:	2300      	movs	r3, #0
 800ecf2:	e02d      	b.n	800ed50 <wolfSSL_X509_set_issuer_name+0x76>

    FreeX509Name(&cert->issuer);
 800ecf4:	687b      	ldr	r3, [r7, #4]
 800ecf6:	f503 731f 	add.w	r3, r3, #636	@ 0x27c
 800ecfa:	4618      	mov	r0, r3
 800ecfc:	f7fa fbb5 	bl	800946a <FreeX509Name>
    InitX509Name(&cert->issuer, 0, cert->heap);
 800ed00:	687b      	ldr	r3, [r7, #4]
 800ed02:	f503 701f 	add.w	r0, r3, #636	@ 0x27c
 800ed06:	687b      	ldr	r3, [r7, #4]
 800ed08:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 800ed0c:	461a      	mov	r2, r3
 800ed0e:	2100      	movs	r1, #0
 800ed10:	f7fa fb8c 	bl	800942c <InitX509Name>

    if (wolfSSL_X509_NAME_copy(name, &cert->issuer) != WOLFSSL_SUCCESS) {
 800ed14:	687b      	ldr	r3, [r7, #4]
 800ed16:	f503 731f 	add.w	r3, r3, #636	@ 0x27c
 800ed1a:	4619      	mov	r1, r3
 800ed1c:	6838      	ldr	r0, [r7, #0]
 800ed1e:	f7ff ff4d 	bl	800ebbc <wolfSSL_X509_NAME_copy>
 800ed22:	4603      	mov	r3, r0
 800ed24:	2b01      	cmp	r3, #1
 800ed26:	d007      	beq.n	800ed38 <wolfSSL_X509_set_issuer_name+0x5e>
        FreeX509Name(&cert->issuer);
 800ed28:	687b      	ldr	r3, [r7, #4]
 800ed2a:	f503 731f 	add.w	r3, r3, #636	@ 0x27c
 800ed2e:	4618      	mov	r0, r3
 800ed30:	f7fa fb9b 	bl	800946a <FreeX509Name>
        return WOLFSSL_FAILURE;
 800ed34:	2300      	movs	r3, #0
 800ed36:	e00b      	b.n	800ed50 <wolfSSL_X509_set_issuer_name+0x76>
    }

    cert->issuer.x509 = cert;
 800ed38:	687b      	ldr	r3, [r7, #4]
 800ed3a:	687a      	ldr	r2, [r7, #4]
 800ed3c:	f8c3 2610 	str.w	r2, [r3, #1552]	@ 0x610
    cert->issuerSet = 1;
 800ed40:	687a      	ldr	r2, [r7, #4]
 800ed42:	f892 30f3 	ldrb.w	r3, [r2, #243]	@ 0xf3
 800ed46:	f043 0301 	orr.w	r3, r3, #1
 800ed4a:	f882 30f3 	strb.w	r3, [r2, #243]	@ 0xf3

    return WOLFSSL_SUCCESS;
 800ed4e:	2301      	movs	r3, #1
}
 800ed50:	4618      	mov	r0, r3
 800ed52:	3708      	adds	r7, #8
 800ed54:	46bd      	mov	sp, r7
 800ed56:	bd80      	pop	{r7, pc}

0800ed58 <wolfSSL_BUF_MEM_free>:

    return (int)len;
}

void wolfSSL_BUF_MEM_free(WOLFSSL_BUF_MEM* buf)
{
 800ed58:	b580      	push	{r7, lr}
 800ed5a:	b084      	sub	sp, #16
 800ed5c:	af00      	add	r7, sp, #0
 800ed5e:	6078      	str	r0, [r7, #4]
    if (buf) {
 800ed60:	687b      	ldr	r3, [r7, #4]
 800ed62:	2b00      	cmp	r3, #0
 800ed64:	d019      	beq.n	800ed9a <wolfSSL_BUF_MEM_free+0x42>
        XFREE(buf->data, NULL, DYNAMIC_TYPE_OPENSSL);
 800ed66:	687b      	ldr	r3, [r7, #4]
 800ed68:	681b      	ldr	r3, [r3, #0]
 800ed6a:	60fb      	str	r3, [r7, #12]
 800ed6c:	68fb      	ldr	r3, [r7, #12]
 800ed6e:	2b00      	cmp	r3, #0
 800ed70:	d002      	beq.n	800ed78 <wolfSSL_BUF_MEM_free+0x20>
 800ed72:	68f8      	ldr	r0, [r7, #12]
 800ed74:	f00f fea4 	bl	801eac0 <wolfSSL_Free>
        buf->data = NULL;
 800ed78:	687b      	ldr	r3, [r7, #4]
 800ed7a:	2200      	movs	r2, #0
 800ed7c:	601a      	str	r2, [r3, #0]
        buf->max = 0;
 800ed7e:	687b      	ldr	r3, [r7, #4]
 800ed80:	2200      	movs	r2, #0
 800ed82:	609a      	str	r2, [r3, #8]
        buf->length = 0;
 800ed84:	687b      	ldr	r3, [r7, #4]
 800ed86:	2200      	movs	r2, #0
 800ed88:	605a      	str	r2, [r3, #4]
        XFREE(buf, NULL, DYNAMIC_TYPE_OPENSSL);
 800ed8a:	687b      	ldr	r3, [r7, #4]
 800ed8c:	60bb      	str	r3, [r7, #8]
 800ed8e:	68bb      	ldr	r3, [r7, #8]
 800ed90:	2b00      	cmp	r3, #0
 800ed92:	d002      	beq.n	800ed9a <wolfSSL_BUF_MEM_free+0x42>
 800ed94:	68b8      	ldr	r0, [r7, #8]
 800ed96:	f00f fe93 	bl	801eac0 <wolfSSL_Free>
    }
}
 800ed9a:	bf00      	nop
 800ed9c:	3710      	adds	r7, #16
 800ed9e:	46bd      	mov	sp, r7
 800eda0:	bd80      	pop	{r7, pc}
	...

0800eda4 <wolfSSL_RAND_InitMutex>:
 * START OF RAND API
 ******************************************************************************/

#if defined(OPENSSL_EXTRA) && !defined(WOLFSSL_NO_OPENSSL_RAND_CB)
static int wolfSSL_RAND_InitMutex(void)
{
 800eda4:	b580      	push	{r7, lr}
 800eda6:	af00      	add	r7, sp, #0
#ifndef WOLFSSL_MUTEX_INITIALIZER
    if (gRandMethodsInit == 0) {
 800eda8:	4b09      	ldr	r3, [pc, #36]	@ (800edd0 <wolfSSL_RAND_InitMutex+0x2c>)
 800edaa:	681b      	ldr	r3, [r3, #0]
 800edac:	2b00      	cmp	r3, #0
 800edae:	d10b      	bne.n	800edc8 <wolfSSL_RAND_InitMutex+0x24>
        if (wc_InitMutex(&gRandMethodMutex) != 0) {
 800edb0:	4808      	ldr	r0, [pc, #32]	@ (800edd4 <wolfSSL_RAND_InitMutex+0x30>)
 800edb2:	f018 fae3 	bl	802737c <wc_InitMutex>
 800edb6:	4603      	mov	r3, r0
 800edb8:	2b00      	cmp	r3, #0
 800edba:	d002      	beq.n	800edc2 <wolfSSL_RAND_InitMutex+0x1e>
            WOLFSSL_MSG("Bad Init Mutex rand methods");
            return BAD_MUTEX_E;
 800edbc:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 800edc0:	e003      	b.n	800edca <wolfSSL_RAND_InitMutex+0x26>
        }
        gRandMethodsInit = 1;
 800edc2:	4b03      	ldr	r3, [pc, #12]	@ (800edd0 <wolfSSL_RAND_InitMutex+0x2c>)
 800edc4:	2201      	movs	r2, #1
 800edc6:	601a      	str	r2, [r3, #0]
    }
#endif
    return 0;
 800edc8:	2300      	movs	r3, #0
}
 800edca:	4618      	mov	r0, r3
 800edcc:	bd80      	pop	{r7, pc}
 800edce:	bf00      	nop
 800edd0:	200028d0 	.word	0x200028d0
 800edd4:	200028cc 	.word	0x200028cc

0800edd8 <wolfSSL_RAND_Init>:
/* Checks if the global RNG has been created. If not then one is created.
 *
 * Returns WOLFSSL_SUCCESS when no error is encountered.
 */
int wolfSSL_RAND_Init(void)
{
 800edd8:	b580      	push	{r7, lr}
 800edda:	b082      	sub	sp, #8
 800eddc:	af00      	add	r7, sp, #0
    int ret = WC_NO_ERR_TRACE(WOLFSSL_FAILURE);
 800edde:	2300      	movs	r3, #0
 800ede0:	607b      	str	r3, [r7, #4]
#ifdef HAVE_GLOBAL_RNG
    if (wc_LockMutex(&globalRNGMutex) == 0) {
 800ede2:	4810      	ldr	r0, [pc, #64]	@ (800ee24 <wolfSSL_RAND_Init+0x4c>)
 800ede4:	f018 fae0 	bl	80273a8 <wc_LockMutex>
 800ede8:	4603      	mov	r3, r0
 800edea:	2b00      	cmp	r3, #0
 800edec:	d115      	bne.n	800ee1a <wolfSSL_RAND_Init+0x42>
        if (initGlobalRNG == 0) {
 800edee:	4b0e      	ldr	r3, [pc, #56]	@ (800ee28 <wolfSSL_RAND_Init+0x50>)
 800edf0:	681b      	ldr	r3, [r3, #0]
 800edf2:	2b00      	cmp	r3, #0
 800edf4:	d10c      	bne.n	800ee10 <wolfSSL_RAND_Init+0x38>
            ret = wc_InitRng(&globalRNG);
 800edf6:	480d      	ldr	r0, [pc, #52]	@ (800ee2c <wolfSSL_RAND_Init+0x54>)
 800edf8:	f010 fbbb 	bl	801f572 <wc_InitRng>
 800edfc:	6078      	str	r0, [r7, #4]
            if (ret == 0) {
 800edfe:	687b      	ldr	r3, [r7, #4]
 800ee00:	2b00      	cmp	r3, #0
 800ee02:	d107      	bne.n	800ee14 <wolfSSL_RAND_Init+0x3c>
                initGlobalRNG = 1;
 800ee04:	4b08      	ldr	r3, [pc, #32]	@ (800ee28 <wolfSSL_RAND_Init+0x50>)
 800ee06:	2201      	movs	r2, #1
 800ee08:	601a      	str	r2, [r3, #0]
                ret = WOLFSSL_SUCCESS;
 800ee0a:	2301      	movs	r3, #1
 800ee0c:	607b      	str	r3, [r7, #4]
 800ee0e:	e001      	b.n	800ee14 <wolfSSL_RAND_Init+0x3c>
            }
        }
        else {
            /* GlobalRNG is already initialized */
            ret = WOLFSSL_SUCCESS;
 800ee10:	2301      	movs	r3, #1
 800ee12:	607b      	str	r3, [r7, #4]
        }

        wc_UnLockMutex(&globalRNGMutex);
 800ee14:	4803      	ldr	r0, [pc, #12]	@ (800ee24 <wolfSSL_RAND_Init+0x4c>)
 800ee16:	f018 fad2 	bl	80273be <wc_UnLockMutex>
    }
#endif
    return ret;
 800ee1a:	687b      	ldr	r3, [r7, #4]
}
 800ee1c:	4618      	mov	r0, r3
 800ee1e:	3708      	adds	r7, #8
 800ee20:	46bd      	mov	sp, r7
 800ee22:	bd80      	pop	{r7, pc}
 800ee24:	200028bc 	.word	0x200028bc
 800ee28:	200028b8 	.word	0x200028b8
 800ee2c:	200028a8 	.word	0x200028a8

0800ee30 <wolfSSL_RAND_seed>:


/* WOLFSSL_SUCCESS on ok */
int wolfSSL_RAND_seed(const void* seed, int len)
{
 800ee30:	b580      	push	{r7, lr}
 800ee32:	b084      	sub	sp, #16
 800ee34:	af00      	add	r7, sp, #0
 800ee36:	6078      	str	r0, [r7, #4]
 800ee38:	6039      	str	r1, [r7, #0]
#ifndef WOLFSSL_NO_OPENSSL_RAND_CB
    if (wolfSSL_RAND_InitMutex() == 0 && wc_LockMutex(&gRandMethodMutex) == 0) {
 800ee3a:	f7ff ffb3 	bl	800eda4 <wolfSSL_RAND_InitMutex>
 800ee3e:	4603      	mov	r3, r0
 800ee40:	2b00      	cmp	r3, #0
 800ee42:	d11d      	bne.n	800ee80 <wolfSSL_RAND_seed+0x50>
 800ee44:	4812      	ldr	r0, [pc, #72]	@ (800ee90 <wolfSSL_RAND_seed+0x60>)
 800ee46:	f018 faaf 	bl	80273a8 <wc_LockMutex>
 800ee4a:	4603      	mov	r3, r0
 800ee4c:	2b00      	cmp	r3, #0
 800ee4e:	d117      	bne.n	800ee80 <wolfSSL_RAND_seed+0x50>
        if (gRandMethods && gRandMethods->seed) {
 800ee50:	4b10      	ldr	r3, [pc, #64]	@ (800ee94 <wolfSSL_RAND_seed+0x64>)
 800ee52:	681b      	ldr	r3, [r3, #0]
 800ee54:	2b00      	cmp	r3, #0
 800ee56:	d010      	beq.n	800ee7a <wolfSSL_RAND_seed+0x4a>
 800ee58:	4b0e      	ldr	r3, [pc, #56]	@ (800ee94 <wolfSSL_RAND_seed+0x64>)
 800ee5a:	681b      	ldr	r3, [r3, #0]
 800ee5c:	681b      	ldr	r3, [r3, #0]
 800ee5e:	2b00      	cmp	r3, #0
 800ee60:	d00b      	beq.n	800ee7a <wolfSSL_RAND_seed+0x4a>
            int ret = gRandMethods->seed(seed, len);
 800ee62:	4b0c      	ldr	r3, [pc, #48]	@ (800ee94 <wolfSSL_RAND_seed+0x64>)
 800ee64:	681b      	ldr	r3, [r3, #0]
 800ee66:	681b      	ldr	r3, [r3, #0]
 800ee68:	6839      	ldr	r1, [r7, #0]
 800ee6a:	6878      	ldr	r0, [r7, #4]
 800ee6c:	4798      	blx	r3
 800ee6e:	60f8      	str	r0, [r7, #12]
            wc_UnLockMutex(&gRandMethodMutex);
 800ee70:	4807      	ldr	r0, [pc, #28]	@ (800ee90 <wolfSSL_RAND_seed+0x60>)
 800ee72:	f018 faa4 	bl	80273be <wc_UnLockMutex>
            return ret;
 800ee76:	68fb      	ldr	r3, [r7, #12]
 800ee78:	e005      	b.n	800ee86 <wolfSSL_RAND_seed+0x56>
        }
        wc_UnLockMutex(&gRandMethodMutex);
 800ee7a:	4805      	ldr	r0, [pc, #20]	@ (800ee90 <wolfSSL_RAND_seed+0x60>)
 800ee7c:	f018 fa9f 	bl	80273be <wc_UnLockMutex>
    (void)seed;
    (void)len;
#endif

    /* Make sure global shared RNG (globalRNG) is initialized */
    return wolfSSL_RAND_Init();
 800ee80:	f7ff ffaa 	bl	800edd8 <wolfSSL_RAND_Init>
 800ee84:	4603      	mov	r3, r0
}
 800ee86:	4618      	mov	r0, r3
 800ee88:	3710      	adds	r7, #16
 800ee8a:	46bd      	mov	sp, r7
 800ee8c:	bd80      	pop	{r7, pc}
 800ee8e:	bf00      	nop
 800ee90:	200028cc 	.word	0x200028cc
 800ee94:	200028c8 	.word	0x200028c8

0800ee98 <wolfSSL_RAND_Cleanup>:
}

#endif /* !FREERTOS_TCP */

void wolfSSL_RAND_Cleanup(void)
{
 800ee98:	b580      	push	{r7, lr}
 800ee9a:	af00      	add	r7, sp, #0
#ifndef WOLFSSL_NO_OPENSSL_RAND_CB
    if (wolfSSL_RAND_InitMutex() == 0 && wc_LockMutex(&gRandMethodMutex) == 0) {
 800ee9c:	f7ff ff82 	bl	800eda4 <wolfSSL_RAND_InitMutex>
 800eea0:	4603      	mov	r3, r0
 800eea2:	2b00      	cmp	r3, #0
 800eea4:	d115      	bne.n	800eed2 <wolfSSL_RAND_Cleanup+0x3a>
 800eea6:	481a      	ldr	r0, [pc, #104]	@ (800ef10 <wolfSSL_RAND_Cleanup+0x78>)
 800eea8:	f018 fa7e 	bl	80273a8 <wc_LockMutex>
 800eeac:	4603      	mov	r3, r0
 800eeae:	2b00      	cmp	r3, #0
 800eeb0:	d10f      	bne.n	800eed2 <wolfSSL_RAND_Cleanup+0x3a>
        if (gRandMethods && gRandMethods->cleanup)
 800eeb2:	4b18      	ldr	r3, [pc, #96]	@ (800ef14 <wolfSSL_RAND_Cleanup+0x7c>)
 800eeb4:	681b      	ldr	r3, [r3, #0]
 800eeb6:	2b00      	cmp	r3, #0
 800eeb8:	d008      	beq.n	800eecc <wolfSSL_RAND_Cleanup+0x34>
 800eeba:	4b16      	ldr	r3, [pc, #88]	@ (800ef14 <wolfSSL_RAND_Cleanup+0x7c>)
 800eebc:	681b      	ldr	r3, [r3, #0]
 800eebe:	689b      	ldr	r3, [r3, #8]
 800eec0:	2b00      	cmp	r3, #0
 800eec2:	d003      	beq.n	800eecc <wolfSSL_RAND_Cleanup+0x34>
            gRandMethods->cleanup();
 800eec4:	4b13      	ldr	r3, [pc, #76]	@ (800ef14 <wolfSSL_RAND_Cleanup+0x7c>)
 800eec6:	681b      	ldr	r3, [r3, #0]
 800eec8:	689b      	ldr	r3, [r3, #8]
 800eeca:	4798      	blx	r3
        wc_UnLockMutex(&gRandMethodMutex);
 800eecc:	4810      	ldr	r0, [pc, #64]	@ (800ef10 <wolfSSL_RAND_Cleanup+0x78>)
 800eece:	f018 fa76 	bl	80273be <wc_UnLockMutex>
    }

    #ifndef WOLFSSL_MUTEX_INITIALIZER
    if (wc_FreeMutex(&gRandMethodMutex) == 0)
 800eed2:	480f      	ldr	r0, [pc, #60]	@ (800ef10 <wolfSSL_RAND_Cleanup+0x78>)
 800eed4:	f018 fa5d 	bl	8027392 <wc_FreeMutex>
 800eed8:	4603      	mov	r3, r0
 800eeda:	2b00      	cmp	r3, #0
 800eedc:	d102      	bne.n	800eee4 <wolfSSL_RAND_Cleanup+0x4c>
        gRandMethodsInit = 0;
 800eede:	4b0e      	ldr	r3, [pc, #56]	@ (800ef18 <wolfSSL_RAND_Cleanup+0x80>)
 800eee0:	2200      	movs	r2, #0
 800eee2:	601a      	str	r2, [r3, #0]
    #endif
#endif
#ifdef HAVE_GLOBAL_RNG
    if (wc_LockMutex(&globalRNGMutex) == 0) {
 800eee4:	480d      	ldr	r0, [pc, #52]	@ (800ef1c <wolfSSL_RAND_Cleanup+0x84>)
 800eee6:	f018 fa5f 	bl	80273a8 <wc_LockMutex>
 800eeea:	4603      	mov	r3, r0
 800eeec:	2b00      	cmp	r3, #0
 800eeee:	d10c      	bne.n	800ef0a <wolfSSL_RAND_Cleanup+0x72>
        if (initGlobalRNG) {
 800eef0:	4b0b      	ldr	r3, [pc, #44]	@ (800ef20 <wolfSSL_RAND_Cleanup+0x88>)
 800eef2:	681b      	ldr	r3, [r3, #0]
 800eef4:	2b00      	cmp	r3, #0
 800eef6:	d005      	beq.n	800ef04 <wolfSSL_RAND_Cleanup+0x6c>
            wc_FreeRng(&globalRNG);
 800eef8:	480a      	ldr	r0, [pc, #40]	@ (800ef24 <wolfSSL_RAND_Cleanup+0x8c>)
 800eefa:	f010 fbed 	bl	801f6d8 <wc_FreeRng>
            initGlobalRNG = 0;
 800eefe:	4b08      	ldr	r3, [pc, #32]	@ (800ef20 <wolfSSL_RAND_Cleanup+0x88>)
 800ef00:	2200      	movs	r2, #0
 800ef02:	601a      	str	r2, [r3, #0]
        }
        wc_UnLockMutex(&globalRNGMutex);
 800ef04:	4805      	ldr	r0, [pc, #20]	@ (800ef1c <wolfSSL_RAND_Cleanup+0x84>)
 800ef06:	f018 fa5a 	bl	80273be <wc_UnLockMutex>
    }
#endif
}
 800ef0a:	bf00      	nop
 800ef0c:	bd80      	pop	{r7, pc}
 800ef0e:	bf00      	nop
 800ef10:	200028cc 	.word	0x200028cc
 800ef14:	200028c8 	.word	0x200028c8
 800ef18:	200028d0 	.word	0x200028d0
 800ef1c:	200028bc 	.word	0x200028bc
 800ef20:	200028b8 	.word	0x200028b8
 800ef24:	200028a8 	.word	0x200028a8

0800ef28 <wolfSSL_X509_STORE_CTX_new_ex>:
 *****************************************************************************/

/* This API is necessary outside of OPENSSL_EXTRA because it is used in
 * SetupStoreCtxCallback */
WOLFSSL_X509_STORE_CTX* wolfSSL_X509_STORE_CTX_new_ex(void* heap)
{
 800ef28:	b580      	push	{r7, lr}
 800ef2a:	b084      	sub	sp, #16
 800ef2c:	af00      	add	r7, sp, #0
 800ef2e:	6078      	str	r0, [r7, #4]
    WOLFSSL_X509_STORE_CTX* ctx;
    WOLFSSL_ENTER("wolfSSL_X509_STORE_CTX_new_ex");

    ctx = (WOLFSSL_X509_STORE_CTX*)XMALLOC(sizeof(WOLFSSL_X509_STORE_CTX), heap,
 800ef30:	2050      	movs	r0, #80	@ 0x50
 800ef32:	f00f fda9 	bl	801ea88 <wolfSSL_Malloc>
 800ef36:	60f8      	str	r0, [r7, #12]
                                    DYNAMIC_TYPE_X509_CTX);
    if (ctx != NULL) {
 800ef38:	68fb      	ldr	r3, [r7, #12]
 800ef3a:	2b00      	cmp	r3, #0
 800ef3c:	d02b      	beq.n	800ef96 <wolfSSL_X509_STORE_CTX_new_ex+0x6e>
        XMEMSET(ctx, 0, sizeof(WOLFSSL_X509_STORE_CTX));
 800ef3e:	2250      	movs	r2, #80	@ 0x50
 800ef40:	2100      	movs	r1, #0
 800ef42:	68f8      	ldr	r0, [r7, #12]
 800ef44:	f019 fac0 	bl	80284c8 <memset>
        ctx->heap = heap;
 800ef48:	68fb      	ldr	r3, [r7, #12]
 800ef4a:	687a      	ldr	r2, [r7, #4]
 800ef4c:	63da      	str	r2, [r3, #60]	@ 0x3c
#ifdef OPENSSL_EXTRA
        if ((ctx->owned = wolfSSL_sk_X509_new_null()) == NULL) {
 800ef4e:	f7ff fe1e 	bl	800eb8e <wolfSSL_sk_X509_new_null>
 800ef52:	4602      	mov	r2, r0
 800ef54:	68fb      	ldr	r3, [r7, #12]
 800ef56:	645a      	str	r2, [r3, #68]	@ 0x44
 800ef58:	68fb      	ldr	r3, [r7, #12]
 800ef5a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800ef5c:	2b00      	cmp	r3, #0
 800ef5e:	d109      	bne.n	800ef74 <wolfSSL_X509_STORE_CTX_new_ex+0x4c>
            XFREE(ctx, heap, DYNAMIC_TYPE_X509_CTX);
 800ef60:	68fb      	ldr	r3, [r7, #12]
 800ef62:	60bb      	str	r3, [r7, #8]
 800ef64:	68bb      	ldr	r3, [r7, #8]
 800ef66:	2b00      	cmp	r3, #0
 800ef68:	d002      	beq.n	800ef70 <wolfSSL_X509_STORE_CTX_new_ex+0x48>
 800ef6a:	68b8      	ldr	r0, [r7, #8]
 800ef6c:	f00f fda8 	bl	801eac0 <wolfSSL_Free>
            ctx = NULL;
 800ef70:	2300      	movs	r3, #0
 800ef72:	60fb      	str	r3, [r7, #12]
        }
        if (ctx != NULL &&
 800ef74:	68fb      	ldr	r3, [r7, #12]
 800ef76:	2b00      	cmp	r3, #0
 800ef78:	d00d      	beq.n	800ef96 <wolfSSL_X509_STORE_CTX_new_ex+0x6e>
            wolfSSL_X509_STORE_CTX_init(ctx, NULL, NULL, NULL) !=
 800ef7a:	2300      	movs	r3, #0
 800ef7c:	2200      	movs	r2, #0
 800ef7e:	2100      	movs	r1, #0
 800ef80:	68f8      	ldr	r0, [r7, #12]
 800ef82:	f000 f848 	bl	800f016 <wolfSSL_X509_STORE_CTX_init>
 800ef86:	4603      	mov	r3, r0
        if (ctx != NULL &&
 800ef88:	2b01      	cmp	r3, #1
 800ef8a:	d004      	beq.n	800ef96 <wolfSSL_X509_STORE_CTX_new_ex+0x6e>
                WOLFSSL_SUCCESS) {
            wolfSSL_X509_STORE_CTX_free(ctx);
 800ef8c:	68f8      	ldr	r0, [r7, #12]
 800ef8e:	f000 f807 	bl	800efa0 <wolfSSL_X509_STORE_CTX_free>
            ctx = NULL;
 800ef92:	2300      	movs	r3, #0
 800ef94:	60fb      	str	r3, [r7, #12]
        }
#endif
    }

    return ctx;
 800ef96:	68fb      	ldr	r3, [r7, #12]
}
 800ef98:	4618      	mov	r0, r3
 800ef9a:	3710      	adds	r7, #16
 800ef9c:	46bd      	mov	sp, r7
 800ef9e:	bd80      	pop	{r7, pc}

0800efa0 <wolfSSL_X509_STORE_CTX_free>:

/* This API is necessary outside of OPENSSL_EXTRA because it is used in
 * SetupStoreCtxCallback */
/* free's extra data */
void wolfSSL_X509_STORE_CTX_free(WOLFSSL_X509_STORE_CTX* ctx)
{
 800efa0:	b580      	push	{r7, lr}
 800efa2:	b084      	sub	sp, #16
 800efa4:	af00      	add	r7, sp, #0
 800efa6:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_X509_STORE_CTX_free");
    if (ctx != NULL) {
 800efa8:	687b      	ldr	r3, [r7, #4]
 800efaa:	2b00      	cmp	r3, #0
 800efac:	d02f      	beq.n	800f00e <wolfSSL_X509_STORE_CTX_free+0x6e>
#ifdef HAVE_EX_DATA_CLEANUP_HOOKS
        wolfSSL_CRYPTO_cleanup_ex_data(&ctx->ex_data);
#endif

#ifdef OPENSSL_EXTRA
        XFREE(ctx->param, ctx->heap, DYNAMIC_TYPE_OPENSSL);
 800efae:	687b      	ldr	r3, [r7, #4]
 800efb0:	695b      	ldr	r3, [r3, #20]
 800efb2:	60fb      	str	r3, [r7, #12]
 800efb4:	68fb      	ldr	r3, [r7, #12]
 800efb6:	2b00      	cmp	r3, #0
 800efb8:	d002      	beq.n	800efc0 <wolfSSL_X509_STORE_CTX_free+0x20>
 800efba:	68f8      	ldr	r0, [r7, #12]
 800efbc:	f00f fd80 	bl	801eac0 <wolfSSL_Free>
        ctx->param = NULL;
 800efc0:	687b      	ldr	r3, [r7, #4]
 800efc2:	2200      	movs	r2, #0
 800efc4:	615a      	str	r2, [r3, #20]

        if (ctx->chain != NULL) {
 800efc6:	687b      	ldr	r3, [r7, #4]
 800efc8:	691b      	ldr	r3, [r3, #16]
 800efca:	2b00      	cmp	r3, #0
 800efcc:	d004      	beq.n	800efd8 <wolfSSL_X509_STORE_CTX_free+0x38>
            wolfSSL_sk_X509_free(ctx->chain);
 800efce:	687b      	ldr	r3, [r7, #4]
 800efd0:	691b      	ldr	r3, [r3, #16]
 800efd2:	4618      	mov	r0, r3
 800efd4:	f7ff f9cf 	bl	800e376 <wolfSSL_sk_X509_free>
        }
        if (ctx->owned != NULL) {
 800efd8:	687b      	ldr	r3, [r7, #4]
 800efda:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800efdc:	2b00      	cmp	r3, #0
 800efde:	d005      	beq.n	800efec <wolfSSL_X509_STORE_CTX_free+0x4c>
            wolfSSL_sk_X509_pop_free(ctx->owned, NULL);
 800efe0:	687b      	ldr	r3, [r7, #4]
 800efe2:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800efe4:	2100      	movs	r1, #0
 800efe6:	4618      	mov	r0, r3
 800efe8:	f7ff f9b8 	bl	800e35c <wolfSSL_sk_X509_pop_free>
        }

        if (ctx->current_issuer != NULL) {
 800efec:	687b      	ldr	r3, [r7, #4]
 800efee:	689b      	ldr	r3, [r3, #8]
 800eff0:	2b00      	cmp	r3, #0
 800eff2:	d004      	beq.n	800effe <wolfSSL_X509_STORE_CTX_free+0x5e>
            wolfSSL_X509_free(ctx->current_issuer);
 800eff4:	687b      	ldr	r3, [r7, #4]
 800eff6:	689b      	ldr	r3, [r3, #8]
 800eff8:	4618      	mov	r0, r3
 800effa:	f7ff f9a4 	bl	800e346 <wolfSSL_X509_free>
        }
#endif

        XFREE(ctx, ctx->heap, DYNAMIC_TYPE_X509_CTX);
 800effe:	687b      	ldr	r3, [r7, #4]
 800f000:	60bb      	str	r3, [r7, #8]
 800f002:	68bb      	ldr	r3, [r7, #8]
 800f004:	2b00      	cmp	r3, #0
 800f006:	d002      	beq.n	800f00e <wolfSSL_X509_STORE_CTX_free+0x6e>
 800f008:	68b8      	ldr	r0, [r7, #8]
 800f00a:	f00f fd59 	bl	801eac0 <wolfSSL_Free>
    }
}
 800f00e:	bf00      	nop
 800f010:	3710      	adds	r7, #16
 800f012:	46bd      	mov	sp, r7
 800f014:	bd80      	pop	{r7, pc}

0800f016 <wolfSSL_X509_STORE_CTX_init>:
}

int wolfSSL_X509_STORE_CTX_init(WOLFSSL_X509_STORE_CTX* ctx,
     WOLFSSL_X509_STORE* store, WOLFSSL_X509* x509,
     WOLF_STACK_OF(WOLFSSL_X509)* sk)
{
 800f016:	b580      	push	{r7, lr}
 800f018:	b084      	sub	sp, #16
 800f01a:	af00      	add	r7, sp, #0
 800f01c:	60f8      	str	r0, [r7, #12]
 800f01e:	60b9      	str	r1, [r7, #8]
 800f020:	607a      	str	r2, [r7, #4]
 800f022:	603b      	str	r3, [r7, #0]
    WOLFSSL_ENTER("wolfSSL_X509_STORE_CTX_init");

    if (ctx != NULL) {
 800f024:	68fb      	ldr	r3, [r7, #12]
 800f026:	2b00      	cmp	r3, #0
 800f028:	d03e      	beq.n	800f0a8 <wolfSSL_X509_STORE_CTX_init+0x92>
        ctx->store = store;
 800f02a:	68fb      	ldr	r3, [r7, #12]
 800f02c:	68ba      	ldr	r2, [r7, #8]
 800f02e:	601a      	str	r2, [r3, #0]
        #ifndef WOLFSSL_X509_STORE_CERTS
        ctx->current_cert = x509;
 800f030:	68fb      	ldr	r3, [r7, #12]
 800f032:	687a      	ldr	r2, [r7, #4]
 800f034:	605a      	str	r2, [r3, #4]
                return WOLFSSL_FAILURE;
        } else
            ctx->current_cert = NULL;
        #endif

        ctx->ctxIntermediates = sk;
 800f036:	68fb      	ldr	r3, [r7, #12]
 800f038:	683a      	ldr	r2, [r7, #0]
 800f03a:	649a      	str	r2, [r3, #72]	@ 0x48
        if (ctx->chain != NULL) {
 800f03c:	68fb      	ldr	r3, [r7, #12]
 800f03e:	691b      	ldr	r3, [r3, #16]
 800f040:	2b00      	cmp	r3, #0
 800f042:	d007      	beq.n	800f054 <wolfSSL_X509_STORE_CTX_init+0x3e>
            wolfSSL_sk_X509_free(ctx->chain);
 800f044:	68fb      	ldr	r3, [r7, #12]
 800f046:	691b      	ldr	r3, [r3, #16]
 800f048:	4618      	mov	r0, r3
 800f04a:	f7ff f994 	bl	800e376 <wolfSSL_sk_X509_free>
            ctx->chain = NULL;
 800f04e:	68fb      	ldr	r3, [r7, #12]
 800f050:	2200      	movs	r2, #0
 800f052:	611a      	str	r2, [r3, #16]
        }
#ifdef SESSION_CERTS
        ctx->sesChain = NULL;
#endif
        ctx->domain = NULL;
 800f054:	68fb      	ldr	r3, [r7, #12]
 800f056:	2200      	movs	r2, #0
 800f058:	619a      	str	r2, [r3, #24]
#ifdef HAVE_EX_DATA
        XMEMSET(&ctx->ex_data, 0, sizeof(ctx->ex_data));
#endif
        ctx->userCtx = NULL;
 800f05a:	68fb      	ldr	r3, [r7, #12]
 800f05c:	2200      	movs	r2, #0
 800f05e:	621a      	str	r2, [r3, #32]
        ctx->error = 0;
 800f060:	68fb      	ldr	r3, [r7, #12]
 800f062:	2200      	movs	r2, #0
 800f064:	625a      	str	r2, [r3, #36]	@ 0x24
        ctx->error_depth = 0;
 800f066:	68fb      	ldr	r3, [r7, #12]
 800f068:	2200      	movs	r2, #0
 800f06a:	629a      	str	r2, [r3, #40]	@ 0x28
        ctx->discardSessionCerts = 0;
 800f06c:	68fb      	ldr	r3, [r7, #12]
 800f06e:	2200      	movs	r2, #0
 800f070:	62da      	str	r2, [r3, #44]	@ 0x2c

        if (ctx->param == NULL) {
 800f072:	68fb      	ldr	r3, [r7, #12]
 800f074:	695b      	ldr	r3, [r3, #20]
 800f076:	2b00      	cmp	r3, #0
 800f078:	d114      	bne.n	800f0a4 <wolfSSL_X509_STORE_CTX_init+0x8e>
            ctx->param = (WOLFSSL_X509_VERIFY_PARAM*)XMALLOC(
 800f07a:	f44f 70a8 	mov.w	r0, #336	@ 0x150
 800f07e:	f00f fd03 	bl	801ea88 <wolfSSL_Malloc>
 800f082:	4602      	mov	r2, r0
 800f084:	68fb      	ldr	r3, [r7, #12]
 800f086:	615a      	str	r2, [r3, #20]
                           sizeof(WOLFSSL_X509_VERIFY_PARAM),
                           ctx->heap, DYNAMIC_TYPE_OPENSSL);
            if (ctx->param == NULL){
 800f088:	68fb      	ldr	r3, [r7, #12]
 800f08a:	695b      	ldr	r3, [r3, #20]
 800f08c:	2b00      	cmp	r3, #0
 800f08e:	d101      	bne.n	800f094 <wolfSSL_X509_STORE_CTX_init+0x7e>
                WOLFSSL_MSG("wolfSSL_X509_STORE_CTX_init failed");
                return WOLFSSL_FAILURE;
 800f090:	2300      	movs	r3, #0
 800f092:	e00a      	b.n	800f0aa <wolfSSL_X509_STORE_CTX_init+0x94>
            }
            XMEMSET(ctx->param, 0, sizeof(*ctx->param));
 800f094:	68fb      	ldr	r3, [r7, #12]
 800f096:	695b      	ldr	r3, [r3, #20]
 800f098:	f44f 72a8 	mov.w	r2, #336	@ 0x150
 800f09c:	2100      	movs	r1, #0
 800f09e:	4618      	mov	r0, r3
 800f0a0:	f019 fa12 	bl	80284c8 <memset>
        }

        return WOLFSSL_SUCCESS;
 800f0a4:	2301      	movs	r3, #1
 800f0a6:	e000      	b.n	800f0aa <wolfSSL_X509_STORE_CTX_init+0x94>
    }
    return WOLFSSL_FAILURE;
 800f0a8:	2300      	movs	r3, #0
}
 800f0aa:	4618      	mov	r0, r3
 800f0ac:	3710      	adds	r7, #16
 800f0ae:	46bd      	mov	sp, r7
 800f0b0:	bd80      	pop	{r7, pc}

0800f0b2 <wolfSSL_X509_STORE_free>:
    wolfSSL_sk_X509_OBJECT_pop_free(objs, NULL);
}
#endif

void wolfSSL_X509_STORE_free(WOLFSSL_X509_STORE* store)
{
 800f0b2:	b580      	push	{r7, lr}
 800f0b4:	b088      	sub	sp, #32
 800f0b6:	af00      	add	r7, sp, #0
 800f0b8:	6078      	str	r0, [r7, #4]
    int doFree = 0;
 800f0ba:	2300      	movs	r3, #0
 800f0bc:	60fb      	str	r3, [r7, #12]
    if (store != NULL && store->isDynamic) {
 800f0be:	687b      	ldr	r3, [r7, #4]
 800f0c0:	2b00      	cmp	r3, #0
 800f0c2:	d073      	beq.n	800f1ac <wolfSSL_X509_STORE_free+0xfa>
 800f0c4:	687b      	ldr	r3, [r7, #4]
 800f0c6:	695b      	ldr	r3, [r3, #20]
 800f0c8:	2b00      	cmp	r3, #0
 800f0ca:	d06f      	beq.n	800f1ac <wolfSSL_X509_STORE_free+0xfa>
        int ret;
        wolfSSL_RefDec(&store->ref, &doFree, &ret);
 800f0cc:	687b      	ldr	r3, [r7, #4]
 800f0ce:	331c      	adds	r3, #28
 800f0d0:	2101      	movs	r1, #1
 800f0d2:	4618      	mov	r0, r3
 800f0d4:	f7fc f826 	bl	800b124 <wolfSSL_Atomic_Int_FetchSub>
 800f0d8:	61f8      	str	r0, [r7, #28]
 800f0da:	69fb      	ldr	r3, [r7, #28]
 800f0dc:	2b01      	cmp	r3, #1
 800f0de:	bf0c      	ite	eq
 800f0e0:	2301      	moveq	r3, #1
 800f0e2:	2300      	movne	r3, #0
 800f0e4:	b2db      	uxtb	r3, r3
 800f0e6:	60fb      	str	r3, [r7, #12]
 800f0e8:	2300      	movs	r3, #0
 800f0ea:	60bb      	str	r3, [r7, #8]
        }
    #else
        (void)ret;
    #endif

        if (doFree) {
 800f0ec:	68fb      	ldr	r3, [r7, #12]
 800f0ee:	2b00      	cmp	r3, #0
 800f0f0:	d05c      	beq.n	800f1ac <wolfSSL_X509_STORE_free+0xfa>
#ifdef HAVE_EX_DATA_CLEANUP_HOOKS
            wolfSSL_CRYPTO_cleanup_ex_data(&store->ex_data);
#endif
            if (store->cm != NULL) {
 800f0f2:	687b      	ldr	r3, [r7, #4]
 800f0f4:	685b      	ldr	r3, [r3, #4]
 800f0f6:	2b00      	cmp	r3, #0
 800f0f8:	d007      	beq.n	800f10a <wolfSSL_X509_STORE_free+0x58>
                wolfSSL_CertManagerFree(store->cm);
 800f0fa:	687b      	ldr	r3, [r7, #4]
 800f0fc:	685b      	ldr	r3, [r3, #4]
 800f0fe:	4618      	mov	r0, r3
 800f100:	f7fc fa69 	bl	800b5d6 <wolfSSL_CertManagerFree>
                store->cm = NULL;
 800f104:	687b      	ldr	r3, [r7, #4]
 800f106:	2200      	movs	r2, #0
 800f108:	605a      	str	r2, [r3, #4]
            }
#if defined(OPENSSL_EXTRA)
            if (store->certs != NULL) {
 800f10a:	687b      	ldr	r3, [r7, #4]
 800f10c:	6a1b      	ldr	r3, [r3, #32]
 800f10e:	2b00      	cmp	r3, #0
 800f110:	d008      	beq.n	800f124 <wolfSSL_X509_STORE_free+0x72>
                wolfSSL_sk_X509_pop_free(store->certs, NULL);
 800f112:	687b      	ldr	r3, [r7, #4]
 800f114:	6a1b      	ldr	r3, [r3, #32]
 800f116:	2100      	movs	r1, #0
 800f118:	4618      	mov	r0, r3
 800f11a:	f7ff f91f 	bl	800e35c <wolfSSL_sk_X509_pop_free>
                store->certs = NULL;
 800f11e:	687b      	ldr	r3, [r7, #4]
 800f120:	2200      	movs	r2, #0
 800f122:	621a      	str	r2, [r3, #32]
            }
            if (store->owned != NULL) {
 800f124:	687b      	ldr	r3, [r7, #4]
 800f126:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800f128:	2b00      	cmp	r3, #0
 800f12a:	d008      	beq.n	800f13e <wolfSSL_X509_STORE_free+0x8c>
                wolfSSL_sk_X509_pop_free(store->owned, NULL);
 800f12c:	687b      	ldr	r3, [r7, #4]
 800f12e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800f130:	2100      	movs	r1, #0
 800f132:	4618      	mov	r0, r3
 800f134:	f7ff f912 	bl	800e35c <wolfSSL_sk_X509_pop_free>
                store->owned = NULL;
 800f138:	687b      	ldr	r3, [r7, #4]
 800f13a:	2200      	movs	r2, #0
 800f13c:	629a      	str	r2, [r3, #40]	@ 0x28
            }
            if (store->trusted != NULL) {
 800f13e:	687b      	ldr	r3, [r7, #4]
 800f140:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800f142:	2b00      	cmp	r3, #0
 800f144:	d008      	beq.n	800f158 <wolfSSL_X509_STORE_free+0xa6>
                wolfSSL_sk_X509_pop_free(store->trusted, NULL);
 800f146:	687b      	ldr	r3, [r7, #4]
 800f148:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800f14a:	2100      	movs	r1, #0
 800f14c:	4618      	mov	r0, r3
 800f14e:	f7ff f905 	bl	800e35c <wolfSSL_sk_X509_pop_free>
                store->trusted = NULL;
 800f152:	687b      	ldr	r3, [r7, #4]
 800f154:	2200      	movs	r2, #0
 800f156:	625a      	str	r2, [r3, #36]	@ 0x24
            if (store->objs != NULL) {
                X509StoreFreeObjList(store, store->objs);
            }
#endif
#if defined(OPENSSL_EXTRA) || defined(WOLFSSL_WPAS_SMALL)
            XFREE(store->param, NULL, DYNAMIC_TYPE_OPENSSL);
 800f158:	687b      	ldr	r3, [r7, #4]
 800f15a:	699b      	ldr	r3, [r3, #24]
 800f15c:	61bb      	str	r3, [r7, #24]
 800f15e:	69bb      	ldr	r3, [r7, #24]
 800f160:	2b00      	cmp	r3, #0
 800f162:	d002      	beq.n	800f16a <wolfSSL_X509_STORE_free+0xb8>
 800f164:	69b8      	ldr	r0, [r7, #24]
 800f166:	f00f fcab 	bl	801eac0 <wolfSSL_Free>
            store->param = NULL;
 800f16a:	687b      	ldr	r3, [r7, #4]
 800f16c:	2200      	movs	r2, #0
 800f16e:	619a      	str	r2, [r3, #24]

            if (store->lookup.dirs != NULL) {
 800f170:	687b      	ldr	r3, [r7, #4]
 800f172:	691b      	ldr	r3, [r3, #16]
 800f174:	2b00      	cmp	r3, #0
 800f176:	d011      	beq.n	800f19c <wolfSSL_X509_STORE_free+0xea>
                if (store->lookup.dirs->dir_entry) {
                    wolfSSL_sk_BY_DIR_entry_free(
                        store->lookup.dirs->dir_entry);
                }
#endif
                wc_FreeMutex(&store->lookup.dirs->lock);
 800f178:	687b      	ldr	r3, [r7, #4]
 800f17a:	691b      	ldr	r3, [r3, #16]
 800f17c:	3304      	adds	r3, #4
 800f17e:	4618      	mov	r0, r3
 800f180:	f018 f907 	bl	8027392 <wc_FreeMutex>
                XFREE(store->lookup.dirs, NULL, DYNAMIC_TYPE_OPENSSL);
 800f184:	687b      	ldr	r3, [r7, #4]
 800f186:	691b      	ldr	r3, [r3, #16]
 800f188:	617b      	str	r3, [r7, #20]
 800f18a:	697b      	ldr	r3, [r7, #20]
 800f18c:	2b00      	cmp	r3, #0
 800f18e:	d002      	beq.n	800f196 <wolfSSL_X509_STORE_free+0xe4>
 800f190:	6978      	ldr	r0, [r7, #20]
 800f192:	f00f fc95 	bl	801eac0 <wolfSSL_Free>
                store->lookup.dirs = NULL;
 800f196:	687b      	ldr	r3, [r7, #4]
 800f198:	2200      	movs	r2, #0
 800f19a:	611a      	str	r2, [r3, #16]
            }
#endif
            wolfSSL_RefFree(&store->ref);
            XFREE(store, NULL, DYNAMIC_TYPE_X509_STORE);
 800f19c:	687b      	ldr	r3, [r7, #4]
 800f19e:	613b      	str	r3, [r7, #16]
 800f1a0:	693b      	ldr	r3, [r7, #16]
 800f1a2:	2b00      	cmp	r3, #0
 800f1a4:	d002      	beq.n	800f1ac <wolfSSL_X509_STORE_free+0xfa>
 800f1a6:	6938      	ldr	r0, [r7, #16]
 800f1a8:	f00f fc8a 	bl	801eac0 <wolfSSL_Free>
        }
    }
}
 800f1ac:	bf00      	nop
 800f1ae:	3720      	adds	r7, #32
 800f1b0:	46bd      	mov	sp, r7
 800f1b2:	bd80      	pop	{r7, pc}

0800f1b4 <wolfSSL_FIPS_drbg_uninstantiate>:
    (void)adin;
    (void)adinlen;
    return ret;
}
int wolfSSL_FIPS_drbg_uninstantiate(WOLFSSL_DRBG_CTX *ctx)
{
 800f1b4:	b580      	push	{r7, lr}
 800f1b6:	b082      	sub	sp, #8
 800f1b8:	af00      	add	r7, sp, #0
 800f1ba:	6078      	str	r0, [r7, #4]
    if (ctx != NULL && ctx->rng != NULL) {
 800f1bc:	687b      	ldr	r3, [r7, #4]
 800f1be:	2b00      	cmp	r3, #0
 800f1c0:	d00e      	beq.n	800f1e0 <wolfSSL_FIPS_drbg_uninstantiate+0x2c>
 800f1c2:	687b      	ldr	r3, [r7, #4]
 800f1c4:	681b      	ldr	r3, [r3, #0]
 800f1c6:	2b00      	cmp	r3, #0
 800f1c8:	d00a      	beq.n	800f1e0 <wolfSSL_FIPS_drbg_uninstantiate+0x2c>
    #if !defined(HAVE_SELFTEST) && (!defined(HAVE_FIPS) || \
        (defined(HAVE_FIPS) && FIPS_VERSION_GE(5,0)))
        wc_rng_free(ctx->rng);
 800f1ca:	687b      	ldr	r3, [r7, #4]
 800f1cc:	681b      	ldr	r3, [r3, #0]
 800f1ce:	4618      	mov	r0, r3
 800f1d0:	f010 f9b2 	bl	801f538 <wc_rng_free>
    #else
        wc_FreeRng(ctx->rng);
        XFREE(ctx->rng, NULL, DYNAMIC_TYPE_RNG);
    #endif
        ctx->rng = NULL;
 800f1d4:	687b      	ldr	r3, [r7, #4]
 800f1d6:	2200      	movs	r2, #0
 800f1d8:	601a      	str	r2, [r3, #0]
        ctx->status = DRBG_STATUS_UNINITIALISED;
 800f1da:	687b      	ldr	r3, [r7, #4]
 800f1dc:	2200      	movs	r2, #0
 800f1de:	61da      	str	r2, [r3, #28]
    }
    return WOLFSSL_SUCCESS;
 800f1e0:	2301      	movs	r3, #1
}
 800f1e2:	4618      	mov	r0, r3
 800f1e4:	3708      	adds	r7, #8
 800f1e6:	46bd      	mov	sp, r7
 800f1e8:	bd80      	pop	{r7, pc}
	...

0800f1ec <wolfSSL_FIPS_drbg_free>:
void wolfSSL_FIPS_drbg_free(WOLFSSL_DRBG_CTX *ctx)
{
 800f1ec:	b580      	push	{r7, lr}
 800f1ee:	b084      	sub	sp, #16
 800f1f0:	af00      	add	r7, sp, #0
 800f1f2:	6078      	str	r0, [r7, #4]
    if (ctx != NULL) {
 800f1f4:	687b      	ldr	r3, [r7, #4]
 800f1f6:	2b00      	cmp	r3, #0
 800f1f8:	d012      	beq.n	800f220 <wolfSSL_FIPS_drbg_free+0x34>
        /* As safety check if free'ing the default drbg, then mark global NULL.
         * Technically the user should not call free on the default drbg. */
        if (ctx == gDrbgDefCtx) {
 800f1fa:	4b0b      	ldr	r3, [pc, #44]	@ (800f228 <wolfSSL_FIPS_drbg_free+0x3c>)
 800f1fc:	681b      	ldr	r3, [r3, #0]
 800f1fe:	687a      	ldr	r2, [r7, #4]
 800f200:	429a      	cmp	r2, r3
 800f202:	d102      	bne.n	800f20a <wolfSSL_FIPS_drbg_free+0x1e>
            gDrbgDefCtx = NULL;
 800f204:	4b08      	ldr	r3, [pc, #32]	@ (800f228 <wolfSSL_FIPS_drbg_free+0x3c>)
 800f206:	2200      	movs	r2, #0
 800f208:	601a      	str	r2, [r3, #0]
        }
        wolfSSL_FIPS_drbg_uninstantiate(ctx);
 800f20a:	6878      	ldr	r0, [r7, #4]
 800f20c:	f7ff ffd2 	bl	800f1b4 <wolfSSL_FIPS_drbg_uninstantiate>
        XFREE(ctx, NULL, DYNAMIC_TYPE_OPENSSL);
 800f210:	687b      	ldr	r3, [r7, #4]
 800f212:	60fb      	str	r3, [r7, #12]
 800f214:	68fb      	ldr	r3, [r7, #12]
 800f216:	2b00      	cmp	r3, #0
 800f218:	d002      	beq.n	800f220 <wolfSSL_FIPS_drbg_free+0x34>
 800f21a:	68f8      	ldr	r0, [r7, #12]
 800f21c:	f00f fc50 	bl	801eac0 <wolfSSL_Free>
    }
}
 800f220:	bf00      	nop
 800f222:	3710      	adds	r7, #16
 800f224:	46bd      	mov	sp, r7
 800f226:	bd80      	pop	{r7, pc}
 800f228:	200028c4 	.word	0x200028c4

0800f22c <MakeTLSv1_2>:


#ifndef WOLFSSL_NO_TLS12

ProtocolVersion MakeTLSv1_2(void)
{
 800f22c:	b480      	push	{r7}
 800f22e:	b083      	sub	sp, #12
 800f230:	af00      	add	r7, sp, #0
    ProtocolVersion pv;
    pv.major = SSLv3_MAJOR;
 800f232:	2303      	movs	r3, #3
 800f234:	703b      	strb	r3, [r7, #0]
    pv.minor = TLSv1_2_MINOR;
 800f236:	2303      	movs	r3, #3
 800f238:	707b      	strb	r3, [r7, #1]

    return pv;
 800f23a:	883b      	ldrh	r3, [r7, #0]
 800f23c:	80bb      	strh	r3, [r7, #4]
 800f23e:	2300      	movs	r3, #0
 800f240:	793a      	ldrb	r2, [r7, #4]
 800f242:	f362 0307 	bfi	r3, r2, #0, #8
 800f246:	797a      	ldrb	r2, [r7, #5]
 800f248:	f362 230f 	bfi	r3, r2, #8, #8
}
 800f24c:	4618      	mov	r0, r3
 800f24e:	370c      	adds	r7, #12
 800f250:	46bd      	mov	sp, r7
 800f252:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f256:	4770      	bx	lr

0800f258 <TLSX_SNI_Free>:
    return sni;
}

/** Releases a SNI object. */
static void TLSX_SNI_Free(SNI* sni, void* heap)
{
 800f258:	b580      	push	{r7, lr}
 800f25a:	b084      	sub	sp, #16
 800f25c:	af00      	add	r7, sp, #0
 800f25e:	6078      	str	r0, [r7, #4]
 800f260:	6039      	str	r1, [r7, #0]
    if (sni) {
 800f262:	687b      	ldr	r3, [r7, #4]
 800f264:	2b00      	cmp	r3, #0
 800f266:	d015      	beq.n	800f294 <TLSX_SNI_Free+0x3c>
        switch (sni->type) {
 800f268:	687b      	ldr	r3, [r7, #4]
 800f26a:	781b      	ldrb	r3, [r3, #0]
 800f26c:	2b00      	cmp	r3, #0
 800f26e:	d109      	bne.n	800f284 <TLSX_SNI_Free+0x2c>
            case WOLFSSL_SNI_HOST_NAME:
                XFREE(sni->data.host_name, heap, DYNAMIC_TYPE_TLSX);
 800f270:	687b      	ldr	r3, [r7, #4]
 800f272:	685b      	ldr	r3, [r3, #4]
 800f274:	60fb      	str	r3, [r7, #12]
 800f276:	68fb      	ldr	r3, [r7, #12]
 800f278:	2b00      	cmp	r3, #0
 800f27a:	d002      	beq.n	800f282 <TLSX_SNI_Free+0x2a>
 800f27c:	68f8      	ldr	r0, [r7, #12]
 800f27e:	f00f fc1f 	bl	801eac0 <wolfSSL_Free>
            break;
 800f282:	bf00      	nop
        }

        XFREE(sni, heap, DYNAMIC_TYPE_TLSX);
 800f284:	687b      	ldr	r3, [r7, #4]
 800f286:	60bb      	str	r3, [r7, #8]
 800f288:	68bb      	ldr	r3, [r7, #8]
 800f28a:	2b00      	cmp	r3, #0
 800f28c:	d002      	beq.n	800f294 <TLSX_SNI_Free+0x3c>
 800f28e:	68b8      	ldr	r0, [r7, #8]
 800f290:	f00f fc16 	bl	801eac0 <wolfSSL_Free>
    }
    (void)heap;
}
 800f294:	bf00      	nop
 800f296:	3710      	adds	r7, #16
 800f298:	46bd      	mov	sp, r7
 800f29a:	bd80      	pop	{r7, pc}

0800f29c <TLSX_SNI_FreeAll>:

/** Releases all SNI objects in the provided list. */
static void TLSX_SNI_FreeAll(SNI* list, void* heap)
{
 800f29c:	b580      	push	{r7, lr}
 800f29e:	b084      	sub	sp, #16
 800f2a0:	af00      	add	r7, sp, #0
 800f2a2:	6078      	str	r0, [r7, #4]
 800f2a4:	6039      	str	r1, [r7, #0]
    SNI* sni;

    while ((sni = list)) {
 800f2a6:	e006      	b.n	800f2b6 <TLSX_SNI_FreeAll+0x1a>
        list = sni->next;
 800f2a8:	68fb      	ldr	r3, [r7, #12]
 800f2aa:	689b      	ldr	r3, [r3, #8]
 800f2ac:	607b      	str	r3, [r7, #4]
        TLSX_SNI_Free(sni, heap);
 800f2ae:	6839      	ldr	r1, [r7, #0]
 800f2b0:	68f8      	ldr	r0, [r7, #12]
 800f2b2:	f7ff ffd1 	bl	800f258 <TLSX_SNI_Free>
    while ((sni = list)) {
 800f2b6:	687b      	ldr	r3, [r7, #4]
 800f2b8:	60fb      	str	r3, [r7, #12]
 800f2ba:	68fb      	ldr	r3, [r7, #12]
 800f2bc:	2b00      	cmp	r3, #0
 800f2be:	d1f3      	bne.n	800f2a8 <TLSX_SNI_FreeAll+0xc>
    }
}
 800f2c0:	bf00      	nop
 800f2c2:	bf00      	nop
 800f2c4:	3710      	adds	r7, #16
 800f2c6:	46bd      	mov	sp, r7
 800f2c8:	bd80      	pop	{r7, pc}

0800f2ca <TLSX_SupportedCurve_FreeAll>:

    return 0;
}

static void TLSX_SupportedCurve_FreeAll(SupportedCurve* list, void* heap)
{
 800f2ca:	b580      	push	{r7, lr}
 800f2cc:	b084      	sub	sp, #16
 800f2ce:	af00      	add	r7, sp, #0
 800f2d0:	6078      	str	r0, [r7, #4]
 800f2d2:	6039      	str	r1, [r7, #0]
    SupportedCurve* curve;

    while ((curve = list)) {
 800f2d4:	e00a      	b.n	800f2ec <TLSX_SupportedCurve_FreeAll+0x22>
        list = curve->next;
 800f2d6:	68fb      	ldr	r3, [r7, #12]
 800f2d8:	685b      	ldr	r3, [r3, #4]
 800f2da:	607b      	str	r3, [r7, #4]
        XFREE(curve, heap, DYNAMIC_TYPE_TLSX);
 800f2dc:	68fb      	ldr	r3, [r7, #12]
 800f2de:	60bb      	str	r3, [r7, #8]
 800f2e0:	68bb      	ldr	r3, [r7, #8]
 800f2e2:	2b00      	cmp	r3, #0
 800f2e4:	d002      	beq.n	800f2ec <TLSX_SupportedCurve_FreeAll+0x22>
 800f2e6:	68b8      	ldr	r0, [r7, #8]
 800f2e8:	f00f fbea 	bl	801eac0 <wolfSSL_Free>
    while ((curve = list)) {
 800f2ec:	687b      	ldr	r3, [r7, #4]
 800f2ee:	60fb      	str	r3, [r7, #12]
 800f2f0:	68fb      	ldr	r3, [r7, #12]
 800f2f2:	2b00      	cmp	r3, #0
 800f2f4:	d1ef      	bne.n	800f2d6 <TLSX_SupportedCurve_FreeAll+0xc>
    }
    (void)heap;
}
 800f2f6:	bf00      	nop
 800f2f8:	bf00      	nop
 800f2fa:	3710      	adds	r7, #16
 800f2fc:	46bd      	mov	sp, r7
 800f2fe:	bd80      	pop	{r7, pc}

0800f300 <TLSX_PointFormat_FreeAll>:

static void TLSX_PointFormat_FreeAll(PointFormat* list, void* heap)
{
 800f300:	b580      	push	{r7, lr}
 800f302:	b084      	sub	sp, #16
 800f304:	af00      	add	r7, sp, #0
 800f306:	6078      	str	r0, [r7, #4]
 800f308:	6039      	str	r1, [r7, #0]
    PointFormat* point;

    while ((point = list)) {
 800f30a:	e00a      	b.n	800f322 <TLSX_PointFormat_FreeAll+0x22>
        list = point->next;
 800f30c:	68fb      	ldr	r3, [r7, #12]
 800f30e:	685b      	ldr	r3, [r3, #4]
 800f310:	607b      	str	r3, [r7, #4]
        XFREE(point, heap, DYNAMIC_TYPE_TLSX);
 800f312:	68fb      	ldr	r3, [r7, #12]
 800f314:	60bb      	str	r3, [r7, #8]
 800f316:	68bb      	ldr	r3, [r7, #8]
 800f318:	2b00      	cmp	r3, #0
 800f31a:	d002      	beq.n	800f322 <TLSX_PointFormat_FreeAll+0x22>
 800f31c:	68b8      	ldr	r0, [r7, #8]
 800f31e:	f00f fbcf 	bl	801eac0 <wolfSSL_Free>
    while ((point = list)) {
 800f322:	687b      	ldr	r3, [r7, #4]
 800f324:	60fb      	str	r3, [r7, #12]
 800f326:	68fb      	ldr	r3, [r7, #12]
 800f328:	2b00      	cmp	r3, #0
 800f32a:	d1ef      	bne.n	800f30c <TLSX_PointFormat_FreeAll+0xc>
    }
    (void)heap;
}
 800f32c:	bf00      	nop
 800f32e:	bf00      	nop
 800f330:	3710      	adds	r7, #16
 800f332:	46bd      	mov	sp, r7
 800f334:	bd80      	pop	{r7, pc}

0800f336 <TLSX_SignatureAlgorithms_FreeAll>:
    return sa;
}

void TLSX_SignatureAlgorithms_FreeAll(SignatureAlgorithms* sa,
                                             void* heap)
{
 800f336:	b580      	push	{r7, lr}
 800f338:	b084      	sub	sp, #16
 800f33a:	af00      	add	r7, sp, #0
 800f33c:	6078      	str	r0, [r7, #4]
 800f33e:	6039      	str	r1, [r7, #0]
    XFREE(sa, heap, DYNAMIC_TYPE_TLSX);
 800f340:	687b      	ldr	r3, [r7, #4]
 800f342:	60fb      	str	r3, [r7, #12]
 800f344:	68fb      	ldr	r3, [r7, #12]
 800f346:	2b00      	cmp	r3, #0
 800f348:	d002      	beq.n	800f350 <TLSX_SignatureAlgorithms_FreeAll+0x1a>
 800f34a:	68f8      	ldr	r0, [r7, #12]
 800f34c:	f00f fbb8 	bl	801eac0 <wolfSSL_Free>
    (void)heap;
}
 800f350:	bf00      	nop
 800f352:	3710      	adds	r7, #16
 800f354:	46bd      	mov	sp, r7
 800f356:	bd80      	pop	{r7, pc}

0800f358 <TLSX_KeyShare_FreeAll>:
 *
 * list  The linked list of key share entry objects.
 * heap  The heap used for allocation.
 */
static void TLSX_KeyShare_FreeAll(KeyShareEntry* list, void* heap)
{
 800f358:	b580      	push	{r7, lr}
 800f35a:	b088      	sub	sp, #32
 800f35c:	af00      	add	r7, sp, #0
 800f35e:	6078      	str	r0, [r7, #4]
 800f360:	6039      	str	r1, [r7, #0]
    KeyShareEntry* current;

    while ((current = list) != NULL) {
 800f362:	e04a      	b.n	800f3fa <TLSX_KeyShare_FreeAll+0xa2>
        list = current->next;
 800f364:	69fb      	ldr	r3, [r7, #28]
 800f366:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800f368:	607b      	str	r3, [r7, #4]
        if (WOLFSSL_NAMED_GROUP_IS_FFHDE(current->group)) {
 800f36a:	69fb      	ldr	r3, [r7, #28]
 800f36c:	881b      	ldrh	r3, [r3, #0]
 800f36e:	2bff      	cmp	r3, #255	@ 0xff
 800f370:	d90a      	bls.n	800f388 <TLSX_KeyShare_FreeAll+0x30>
 800f372:	69fb      	ldr	r3, [r7, #28]
 800f374:	881b      	ldrh	r3, [r3, #0]
 800f376:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800f37a:	d205      	bcs.n	800f388 <TLSX_KeyShare_FreeAll+0x30>
#ifndef NO_DH
            wc_FreeDhKey((DhKey*)current->key);
 800f37c:	69fb      	ldr	r3, [r7, #28]
 800f37e:	68db      	ldr	r3, [r3, #12]
 800f380:	4618      	mov	r0, r3
 800f382:	f00b f9df 	bl	801a744 <wc_FreeDhKey>
 800f386:	e00c      	b.n	800f3a2 <TLSX_KeyShare_FreeAll+0x4a>
#endif
        }
        else if (current->group == WOLFSSL_ECC_X25519) {
 800f388:	69fb      	ldr	r3, [r7, #28]
 800f38a:	881b      	ldrh	r3, [r3, #0]
 800f38c:	2b1d      	cmp	r3, #29
 800f38e:	d008      	beq.n	800f3a2 <TLSX_KeyShare_FreeAll+0x4a>
#ifdef HAVE_CURVE25519
            wc_curve25519_free((curve25519_key*)current->key);
#endif
        }
        else if (current->group == WOLFSSL_ECC_X448) {
 800f390:	69fb      	ldr	r3, [r7, #28]
 800f392:	881b      	ldrh	r3, [r3, #0]
 800f394:	2b1e      	cmp	r3, #30
 800f396:	d004      	beq.n	800f3a2 <TLSX_KeyShare_FreeAll+0x4a>
            }
        }
#endif
        else {
#ifdef HAVE_ECC
            wc_ecc_free((ecc_key*)current->key);
 800f398:	69fb      	ldr	r3, [r7, #28]
 800f39a:	68db      	ldr	r3, [r3, #12]
 800f39c:	4618      	mov	r0, r3
 800f39e:	f00d fdbc 	bl	801cf1a <wc_ecc_free>
#endif
        }
        XFREE(current->key, heap, DYNAMIC_TYPE_PRIVATE_KEY);
 800f3a2:	69fb      	ldr	r3, [r7, #28]
 800f3a4:	68db      	ldr	r3, [r3, #12]
 800f3a6:	61bb      	str	r3, [r7, #24]
 800f3a8:	69bb      	ldr	r3, [r7, #24]
 800f3aa:	2b00      	cmp	r3, #0
 800f3ac:	d002      	beq.n	800f3b4 <TLSX_KeyShare_FreeAll+0x5c>
 800f3ae:	69b8      	ldr	r0, [r7, #24]
 800f3b0:	f00f fb86 	bl	801eac0 <wolfSSL_Free>
    #if !defined(NO_DH) && (!defined(NO_CERTS) || !defined(NO_PSK))
        XFREE(current->privKey, heap, DYNAMIC_TYPE_PRIVATE_KEY);
 800f3b4:	69fb      	ldr	r3, [r7, #28]
 800f3b6:	69db      	ldr	r3, [r3, #28]
 800f3b8:	617b      	str	r3, [r7, #20]
 800f3ba:	697b      	ldr	r3, [r7, #20]
 800f3bc:	2b00      	cmp	r3, #0
 800f3be:	d002      	beq.n	800f3c6 <TLSX_KeyShare_FreeAll+0x6e>
 800f3c0:	6978      	ldr	r0, [r7, #20]
 800f3c2:	f00f fb7d 	bl	801eac0 <wolfSSL_Free>
    #endif
        XFREE(current->pubKey, heap, DYNAMIC_TYPE_PUBLIC_KEY);
 800f3c6:	69fb      	ldr	r3, [r7, #28]
 800f3c8:	695b      	ldr	r3, [r3, #20]
 800f3ca:	613b      	str	r3, [r7, #16]
 800f3cc:	693b      	ldr	r3, [r7, #16]
 800f3ce:	2b00      	cmp	r3, #0
 800f3d0:	d002      	beq.n	800f3d8 <TLSX_KeyShare_FreeAll+0x80>
 800f3d2:	6938      	ldr	r0, [r7, #16]
 800f3d4:	f00f fb74 	bl	801eac0 <wolfSSL_Free>
        XFREE(current->ke, heap, DYNAMIC_TYPE_PUBLIC_KEY);
 800f3d8:	69fb      	ldr	r3, [r7, #28]
 800f3da:	685b      	ldr	r3, [r3, #4]
 800f3dc:	60fb      	str	r3, [r7, #12]
 800f3de:	68fb      	ldr	r3, [r7, #12]
 800f3e0:	2b00      	cmp	r3, #0
 800f3e2:	d002      	beq.n	800f3ea <TLSX_KeyShare_FreeAll+0x92>
 800f3e4:	68f8      	ldr	r0, [r7, #12]
 800f3e6:	f00f fb6b 	bl	801eac0 <wolfSSL_Free>
        XFREE(current, heap, DYNAMIC_TYPE_TLSX);
 800f3ea:	69fb      	ldr	r3, [r7, #28]
 800f3ec:	60bb      	str	r3, [r7, #8]
 800f3ee:	68bb      	ldr	r3, [r7, #8]
 800f3f0:	2b00      	cmp	r3, #0
 800f3f2:	d002      	beq.n	800f3fa <TLSX_KeyShare_FreeAll+0xa2>
 800f3f4:	68b8      	ldr	r0, [r7, #8]
 800f3f6:	f00f fb63 	bl	801eac0 <wolfSSL_Free>
    while ((current = list) != NULL) {
 800f3fa:	687b      	ldr	r3, [r7, #4]
 800f3fc:	61fb      	str	r3, [r7, #28]
 800f3fe:	69fb      	ldr	r3, [r7, #28]
 800f400:	2b00      	cmp	r3, #0
 800f402:	d1af      	bne.n	800f364 <TLSX_KeyShare_FreeAll+0xc>
    }

    (void)heap;
}
 800f404:	bf00      	nop
 800f406:	bf00      	nop
 800f408:	3720      	adds	r7, #32
 800f40a:	46bd      	mov	sp, r7
 800f40c:	bd80      	pop	{r7, pc}
	...

0800f410 <TLSX_FreeAll>:

#endif

/** Releases all extensions in the provided list. */
void TLSX_FreeAll(TLSX* list, void* heap)
{
 800f410:	b580      	push	{r7, lr}
 800f412:	b084      	sub	sp, #16
 800f414:	af00      	add	r7, sp, #0
 800f416:	6078      	str	r0, [r7, #4]
 800f418:	6039      	str	r1, [r7, #0]
    TLSX* extension;

    while ((extension = list)) {
 800f41a:	e0aa      	b.n	800f572 <TLSX_FreeAll+0x162>
        list = extension->next;
 800f41c:	68fb      	ldr	r3, [r7, #12]
 800f41e:	691b      	ldr	r3, [r3, #16]
 800f420:	607b      	str	r3, [r7, #4]

        switch (extension->type) {
 800f422:	68fb      	ldr	r3, [r7, #12]
 800f424:	881b      	ldrh	r3, [r3, #0]
 800f426:	2b33      	cmp	r3, #51	@ 0x33
 800f428:	dc70      	bgt.n	800f50c <TLSX_FreeAll+0xfc>
 800f42a:	2b00      	cmp	r3, #0
 800f42c:	f2c0 8096 	blt.w	800f55c <TLSX_FreeAll+0x14c>
 800f430:	2b33      	cmp	r3, #51	@ 0x33
 800f432:	f200 8093 	bhi.w	800f55c <TLSX_FreeAll+0x14c>
 800f436:	a201      	add	r2, pc, #4	@ (adr r2, 800f43c <TLSX_FreeAll+0x2c>)
 800f438:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800f43c:	0800f517 	.word	0x0800f517
 800f440:	0800f55d 	.word	0x0800f55d
 800f444:	0800f55d 	.word	0x0800f55d
 800f448:	0800f55d 	.word	0x0800f55d
 800f44c:	0800f55d 	.word	0x0800f55d
 800f450:	0800f55d 	.word	0x0800f55d
 800f454:	0800f55d 	.word	0x0800f55d
 800f458:	0800f55d 	.word	0x0800f55d
 800f45c:	0800f55d 	.word	0x0800f55d
 800f460:	0800f55d 	.word	0x0800f55d
 800f464:	0800f525 	.word	0x0800f525
 800f468:	0800f533 	.word	0x0800f533
 800f46c:	0800f55d 	.word	0x0800f55d
 800f470:	0800f541 	.word	0x0800f541
 800f474:	0800f55d 	.word	0x0800f55d
 800f478:	0800f55d 	.word	0x0800f55d
 800f47c:	0800f55d 	.word	0x0800f55d
 800f480:	0800f55d 	.word	0x0800f55d
 800f484:	0800f55d 	.word	0x0800f55d
 800f488:	0800f55d 	.word	0x0800f55d
 800f48c:	0800f55d 	.word	0x0800f55d
 800f490:	0800f55d 	.word	0x0800f55d
 800f494:	0800f55d 	.word	0x0800f55d
 800f498:	0800f55d 	.word	0x0800f55d
 800f49c:	0800f55d 	.word	0x0800f55d
 800f4a0:	0800f55d 	.word	0x0800f55d
 800f4a4:	0800f55d 	.word	0x0800f55d
 800f4a8:	0800f55d 	.word	0x0800f55d
 800f4ac:	0800f55d 	.word	0x0800f55d
 800f4b0:	0800f55d 	.word	0x0800f55d
 800f4b4:	0800f55d 	.word	0x0800f55d
 800f4b8:	0800f55d 	.word	0x0800f55d
 800f4bc:	0800f55d 	.word	0x0800f55d
 800f4c0:	0800f55d 	.word	0x0800f55d
 800f4c4:	0800f55d 	.word	0x0800f55d
 800f4c8:	0800f55d 	.word	0x0800f55d
 800f4cc:	0800f55d 	.word	0x0800f55d
 800f4d0:	0800f55d 	.word	0x0800f55d
 800f4d4:	0800f55d 	.word	0x0800f55d
 800f4d8:	0800f55d 	.word	0x0800f55d
 800f4dc:	0800f55d 	.word	0x0800f55d
 800f4e0:	0800f55d 	.word	0x0800f55d
 800f4e4:	0800f55d 	.word	0x0800f55d
 800f4e8:	0800f55d 	.word	0x0800f55d
 800f4ec:	0800f55d 	.word	0x0800f55d
 800f4f0:	0800f55d 	.word	0x0800f55d
 800f4f4:	0800f55d 	.word	0x0800f55d
 800f4f8:	0800f55d 	.word	0x0800f55d
 800f4fc:	0800f55d 	.word	0x0800f55d
 800f500:	0800f55d 	.word	0x0800f55d
 800f504:	0800f55d 	.word	0x0800f55d
 800f508:	0800f54f 	.word	0x0800f54f
 800f50c:	f64f 7201 	movw	r2, #65281	@ 0xff01
 800f510:	4293      	cmp	r3, r2
 800f512:	d025      	beq.n	800f560 <TLSX_FreeAll+0x150>
                WOLFSSL_MSG("CKS extension free");
                /* nothing to do */
                break;
#endif
            default:
                break;
 800f514:	e022      	b.n	800f55c <TLSX_FreeAll+0x14c>
                SNI_FREE_ALL((SNI*)extension->data, heap);
 800f516:	68fb      	ldr	r3, [r7, #12]
 800f518:	685b      	ldr	r3, [r3, #4]
 800f51a:	6839      	ldr	r1, [r7, #0]
 800f51c:	4618      	mov	r0, r3
 800f51e:	f7ff febd 	bl	800f29c <TLSX_SNI_FreeAll>
                break;
 800f522:	e01e      	b.n	800f562 <TLSX_FreeAll+0x152>
                EC_FREE_ALL((SupportedCurve*)extension->data, heap);
 800f524:	68fb      	ldr	r3, [r7, #12]
 800f526:	685b      	ldr	r3, [r3, #4]
 800f528:	6839      	ldr	r1, [r7, #0]
 800f52a:	4618      	mov	r0, r3
 800f52c:	f7ff fecd 	bl	800f2ca <TLSX_SupportedCurve_FreeAll>
                break;
 800f530:	e017      	b.n	800f562 <TLSX_FreeAll+0x152>
                PF_FREE_ALL((PointFormat*)extension->data, heap);
 800f532:	68fb      	ldr	r3, [r7, #12]
 800f534:	685b      	ldr	r3, [r3, #4]
 800f536:	6839      	ldr	r1, [r7, #0]
 800f538:	4618      	mov	r0, r3
 800f53a:	f7ff fee1 	bl	800f300 <TLSX_PointFormat_FreeAll>
                break;
 800f53e:	e010      	b.n	800f562 <TLSX_FreeAll+0x152>
                SA_FREE_ALL((SignatureAlgorithms*)extension->data, heap);
 800f540:	68fb      	ldr	r3, [r7, #12]
 800f542:	685b      	ldr	r3, [r3, #4]
 800f544:	6839      	ldr	r1, [r7, #0]
 800f546:	4618      	mov	r0, r3
 800f548:	f7ff fef5 	bl	800f336 <TLSX_SignatureAlgorithms_FreeAll>
                break;
 800f54c:	e009      	b.n	800f562 <TLSX_FreeAll+0x152>
                KS_FREE_ALL((KeyShareEntry*)extension->data, heap);
 800f54e:	68fb      	ldr	r3, [r7, #12]
 800f550:	685b      	ldr	r3, [r3, #4]
 800f552:	6839      	ldr	r1, [r7, #0]
 800f554:	4618      	mov	r0, r3
 800f556:	f7ff feff 	bl	800f358 <TLSX_KeyShare_FreeAll>
                break;
 800f55a:	e002      	b.n	800f562 <TLSX_FreeAll+0x152>
                break;
 800f55c:	bf00      	nop
 800f55e:	e000      	b.n	800f562 <TLSX_FreeAll+0x152>
                break;
 800f560:	bf00      	nop
        }

        XFREE(extension, heap, DYNAMIC_TYPE_TLSX);
 800f562:	68fb      	ldr	r3, [r7, #12]
 800f564:	60bb      	str	r3, [r7, #8]
 800f566:	68bb      	ldr	r3, [r7, #8]
 800f568:	2b00      	cmp	r3, #0
 800f56a:	d002      	beq.n	800f572 <TLSX_FreeAll+0x162>
 800f56c:	68b8      	ldr	r0, [r7, #8]
 800f56e:	f00f faa7 	bl	801eac0 <wolfSSL_Free>
    while ((extension = list)) {
 800f572:	687b      	ldr	r3, [r7, #4]
 800f574:	60fb      	str	r3, [r7, #12]
 800f576:	68fb      	ldr	r3, [r7, #12]
 800f578:	2b00      	cmp	r3, #0
 800f57a:	f47f af4f 	bne.w	800f41c <TLSX_FreeAll+0xc>
    }

    (void)heap;
}
 800f57e:	bf00      	nop
 800f580:	bf00      	nop
 800f582:	3710      	adds	r7, #16
 800f584:	46bd      	mov	sp, r7
 800f586:	bd80      	pop	{r7, pc}

0800f588 <wolfTLSv1_2_client_method>:
#endif /* !NO_OLD_TLS */

#ifndef WOLFSSL_NO_TLS12
    WOLFSSL_ABI
    WOLFSSL_METHOD* wolfTLSv1_2_client_method(void)
    {
 800f588:	b580      	push	{r7, lr}
 800f58a:	af00      	add	r7, sp, #0
        return wolfTLSv1_2_client_method_ex(NULL);
 800f58c:	2000      	movs	r0, #0
 800f58e:	f000 f803 	bl	800f598 <wolfTLSv1_2_client_method_ex>
 800f592:	4603      	mov	r3, r0
    }
 800f594:	4618      	mov	r0, r3
 800f596:	bd80      	pop	{r7, pc}

0800f598 <wolfTLSv1_2_client_method_ex>:
    WOLFSSL_METHOD* wolfTLSv1_2_client_method_ex(void* heap)
    {
 800f598:	b580      	push	{r7, lr}
 800f59a:	b084      	sub	sp, #16
 800f59c:	af00      	add	r7, sp, #0
 800f59e:	6078      	str	r0, [r7, #4]
        WOLFSSL_METHOD* method =
                              (WOLFSSL_METHOD*) XMALLOC(sizeof(WOLFSSL_METHOD),
 800f5a0:	2004      	movs	r0, #4
 800f5a2:	f00f fa71 	bl	801ea88 <wolfSSL_Malloc>
 800f5a6:	60f8      	str	r0, [r7, #12]
                                                     heap, DYNAMIC_TYPE_METHOD);
        (void)heap;
        WOLFSSL_ENTER("TLSv1_2_client_method_ex");
        if (method)
 800f5a8:	68fb      	ldr	r3, [r7, #12]
 800f5aa:	2b00      	cmp	r3, #0
 800f5ac:	d007      	beq.n	800f5be <wolfTLSv1_2_client_method_ex+0x26>
            InitSSL_Method(method, MakeTLSv1_2());
 800f5ae:	f7ff fe3d 	bl	800f22c <MakeTLSv1_2>
 800f5b2:	4603      	mov	r3, r0
 800f5b4:	813b      	strh	r3, [r7, #8]
 800f5b6:	68b9      	ldr	r1, [r7, #8]
 800f5b8:	68f8      	ldr	r0, [r7, #12]
 800f5ba:	f7f9 f9bc 	bl	8008936 <InitSSL_Method>
        return method;
 800f5be:	68fb      	ldr	r3, [r7, #12]
    }
 800f5c0:	4618      	mov	r0, r3
 800f5c2:	3710      	adds	r7, #16
 800f5c4:	46bd      	mov	sp, r7
 800f5c6:	bd80      	pop	{r7, pc}

0800f5c8 <rotlFixed>:
    {
 800f5c8:	b480      	push	{r7}
 800f5ca:	b083      	sub	sp, #12
 800f5cc:	af00      	add	r7, sp, #0
 800f5ce:	6078      	str	r0, [r7, #4]
 800f5d0:	6039      	str	r1, [r7, #0]
        return (x << y) | (x >> (sizeof(x) * 8 - y));
 800f5d2:	687a      	ldr	r2, [r7, #4]
 800f5d4:	683b      	ldr	r3, [r7, #0]
 800f5d6:	f1c3 0320 	rsb	r3, r3, #32
 800f5da:	fa62 f303 	ror.w	r3, r2, r3
    }
 800f5de:	4618      	mov	r0, r3
 800f5e0:	370c      	adds	r7, #12
 800f5e2:	46bd      	mov	sp, r7
 800f5e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f5e8:	4770      	bx	lr

0800f5ea <ByteReverseWord32>:
{
 800f5ea:	b580      	push	{r7, lr}
 800f5ec:	b082      	sub	sp, #8
 800f5ee:	af00      	add	r7, sp, #0
 800f5f0:	6078      	str	r0, [r7, #4]
    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
 800f5f2:	687b      	ldr	r3, [r7, #4]
 800f5f4:	0a1b      	lsrs	r3, r3, #8
 800f5f6:	f003 12ff 	and.w	r2, r3, #16711935	@ 0xff00ff
 800f5fa:	687b      	ldr	r3, [r7, #4]
 800f5fc:	021b      	lsls	r3, r3, #8
 800f5fe:	f003 23ff 	and.w	r3, r3, #4278255360	@ 0xff00ff00
 800f602:	4313      	orrs	r3, r2
 800f604:	607b      	str	r3, [r7, #4]
    return rotlFixed(value, 16U);
 800f606:	2110      	movs	r1, #16
 800f608:	6878      	ldr	r0, [r7, #4]
 800f60a:	f7ff ffdd 	bl	800f5c8 <rotlFixed>
 800f60e:	4603      	mov	r3, r0
}
 800f610:	4618      	mov	r0, r3
 800f612:	3708      	adds	r7, #8
 800f614:	46bd      	mov	sp, r7
 800f616:	bd80      	pop	{r7, pc}

0800f618 <ByteReverseWords>:
{
 800f618:	b590      	push	{r4, r7, lr}
 800f61a:	b087      	sub	sp, #28
 800f61c:	af00      	add	r7, sp, #0
 800f61e:	60f8      	str	r0, [r7, #12]
 800f620:	60b9      	str	r1, [r7, #8]
 800f622:	607a      	str	r2, [r7, #4]
        word32 count = byteCount/(word32)sizeof(word32);
 800f624:	687b      	ldr	r3, [r7, #4]
 800f626:	089b      	lsrs	r3, r3, #2
 800f628:	613b      	str	r3, [r7, #16]
        for (i = 0; i < count; i++)
 800f62a:	2300      	movs	r3, #0
 800f62c:	617b      	str	r3, [r7, #20]
 800f62e:	e010      	b.n	800f652 <ByteReverseWords+0x3a>
            out[i] = ByteReverseWord32(in[i]);
 800f630:	697b      	ldr	r3, [r7, #20]
 800f632:	009b      	lsls	r3, r3, #2
 800f634:	68ba      	ldr	r2, [r7, #8]
 800f636:	4413      	add	r3, r2
 800f638:	6819      	ldr	r1, [r3, #0]
 800f63a:	697b      	ldr	r3, [r7, #20]
 800f63c:	009b      	lsls	r3, r3, #2
 800f63e:	68fa      	ldr	r2, [r7, #12]
 800f640:	18d4      	adds	r4, r2, r3
 800f642:	4608      	mov	r0, r1
 800f644:	f7ff ffd1 	bl	800f5ea <ByteReverseWord32>
 800f648:	4603      	mov	r3, r0
 800f64a:	6023      	str	r3, [r4, #0]
        for (i = 0; i < count; i++)
 800f64c:	697b      	ldr	r3, [r7, #20]
 800f64e:	3301      	adds	r3, #1
 800f650:	617b      	str	r3, [r7, #20]
 800f652:	697a      	ldr	r2, [r7, #20]
 800f654:	693b      	ldr	r3, [r7, #16]
 800f656:	429a      	cmp	r2, r3
 800f658:	d3ea      	bcc.n	800f630 <ByteReverseWords+0x18>
}
 800f65a:	bf00      	nop
 800f65c:	bf00      	nop
 800f65e:	371c      	adds	r7, #28
 800f660:	46bd      	mov	sp, r7
 800f662:	bd90      	pop	{r4, r7, pc}

0800f664 <XorWords>:
{
 800f664:	b480      	push	{r7}
 800f666:	b087      	sub	sp, #28
 800f668:	af00      	add	r7, sp, #0
 800f66a:	60f8      	str	r0, [r7, #12]
 800f66c:	60b9      	str	r1, [r7, #8]
 800f66e:	607a      	str	r2, [r7, #4]
    for (i = 0; i < n; i++)
 800f670:	2300      	movs	r3, #0
 800f672:	617b      	str	r3, [r7, #20]
 800f674:	e010      	b.n	800f698 <XorWords+0x34>
        *((*r)++) ^= *((*a)++);
 800f676:	68bb      	ldr	r3, [r7, #8]
 800f678:	681b      	ldr	r3, [r3, #0]
 800f67a:	1d19      	adds	r1, r3, #4
 800f67c:	68ba      	ldr	r2, [r7, #8]
 800f67e:	6011      	str	r1, [r2, #0]
 800f680:	6819      	ldr	r1, [r3, #0]
 800f682:	68fb      	ldr	r3, [r7, #12]
 800f684:	681b      	ldr	r3, [r3, #0]
 800f686:	1d18      	adds	r0, r3, #4
 800f688:	68fa      	ldr	r2, [r7, #12]
 800f68a:	6010      	str	r0, [r2, #0]
 800f68c:	681a      	ldr	r2, [r3, #0]
 800f68e:	404a      	eors	r2, r1
 800f690:	601a      	str	r2, [r3, #0]
    for (i = 0; i < n; i++)
 800f692:	697b      	ldr	r3, [r7, #20]
 800f694:	3301      	adds	r3, #1
 800f696:	617b      	str	r3, [r7, #20]
 800f698:	697a      	ldr	r2, [r7, #20]
 800f69a:	687b      	ldr	r3, [r7, #4]
 800f69c:	429a      	cmp	r2, r3
 800f69e:	d3ea      	bcc.n	800f676 <XorWords+0x12>
}
 800f6a0:	bf00      	nop
 800f6a2:	bf00      	nop
 800f6a4:	371c      	adds	r7, #28
 800f6a6:	46bd      	mov	sp, r7
 800f6a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f6ac:	4770      	bx	lr

0800f6ae <xorbuf>:
{
 800f6ae:	b580      	push	{r7, lr}
 800f6b0:	b08a      	sub	sp, #40	@ 0x28
 800f6b2:	af00      	add	r7, sp, #0
 800f6b4:	60f8      	str	r0, [r7, #12]
 800f6b6:	60b9      	str	r1, [r7, #8]
 800f6b8:	607a      	str	r2, [r7, #4]
    b = (byte*)buf;
 800f6ba:	68fb      	ldr	r3, [r7, #12]
 800f6bc:	623b      	str	r3, [r7, #32]
    m = (const byte*)mask;
 800f6be:	68bb      	ldr	r3, [r7, #8]
 800f6c0:	61fb      	str	r3, [r7, #28]
    if (((wc_ptr_t)b) % WOLFSSL_WORD_SIZE ==
 800f6c2:	6a3a      	ldr	r2, [r7, #32]
            ((wc_ptr_t)m) % WOLFSSL_WORD_SIZE) {
 800f6c4:	69fb      	ldr	r3, [r7, #28]
    if (((wc_ptr_t)b) % WOLFSSL_WORD_SIZE ==
 800f6c6:	4053      	eors	r3, r2
 800f6c8:	f003 0303 	and.w	r3, r3, #3
 800f6cc:	2b00      	cmp	r3, #0
 800f6ce:	d12b      	bne.n	800f728 <xorbuf+0x7a>
        while (((wc_ptr_t)buf) % WOLFSSL_WORD_SIZE != 0 && count > 0) {
 800f6d0:	e00d      	b.n	800f6ee <xorbuf+0x40>
            *(b++) ^= *(m++);
 800f6d2:	69fb      	ldr	r3, [r7, #28]
 800f6d4:	1c5a      	adds	r2, r3, #1
 800f6d6:	61fa      	str	r2, [r7, #28]
 800f6d8:	7819      	ldrb	r1, [r3, #0]
 800f6da:	6a3b      	ldr	r3, [r7, #32]
 800f6dc:	1c5a      	adds	r2, r3, #1
 800f6de:	623a      	str	r2, [r7, #32]
 800f6e0:	781a      	ldrb	r2, [r3, #0]
 800f6e2:	404a      	eors	r2, r1
 800f6e4:	b2d2      	uxtb	r2, r2
 800f6e6:	701a      	strb	r2, [r3, #0]
            count--;
 800f6e8:	687b      	ldr	r3, [r7, #4]
 800f6ea:	3b01      	subs	r3, #1
 800f6ec:	607b      	str	r3, [r7, #4]
        while (((wc_ptr_t)buf) % WOLFSSL_WORD_SIZE != 0 && count > 0) {
 800f6ee:	68fb      	ldr	r3, [r7, #12]
 800f6f0:	f003 0303 	and.w	r3, r3, #3
 800f6f4:	2b00      	cmp	r3, #0
 800f6f6:	d002      	beq.n	800f6fe <xorbuf+0x50>
 800f6f8:	687b      	ldr	r3, [r7, #4]
 800f6fa:	2b00      	cmp	r3, #0
 800f6fc:	d1e9      	bne.n	800f6d2 <xorbuf+0x24>
        tpb.bp = b;
 800f6fe:	6a3b      	ldr	r3, [r7, #32]
 800f700:	61bb      	str	r3, [r7, #24]
        tpm.bp = m;
 800f702:	69fb      	ldr	r3, [r7, #28]
 800f704:	617b      	str	r3, [r7, #20]
        XorWords( &tpb.wp, &tpm.wp, count / WOLFSSL_WORD_SIZE);
 800f706:	687b      	ldr	r3, [r7, #4]
 800f708:	089a      	lsrs	r2, r3, #2
 800f70a:	f107 0114 	add.w	r1, r7, #20
 800f70e:	f107 0318 	add.w	r3, r7, #24
 800f712:	4618      	mov	r0, r3
 800f714:	f7ff ffa6 	bl	800f664 <XorWords>
        b = tpb.bp;
 800f718:	69bb      	ldr	r3, [r7, #24]
 800f71a:	623b      	str	r3, [r7, #32]
        m = tpm.bp;
 800f71c:	697b      	ldr	r3, [r7, #20]
 800f71e:	61fb      	str	r3, [r7, #28]
        count %= WOLFSSL_WORD_SIZE;
 800f720:	687b      	ldr	r3, [r7, #4]
 800f722:	f003 0303 	and.w	r3, r3, #3
 800f726:	607b      	str	r3, [r7, #4]
    for (i = 0; i < count; i++)
 800f728:	2300      	movs	r3, #0
 800f72a:	627b      	str	r3, [r7, #36]	@ 0x24
 800f72c:	e010      	b.n	800f750 <xorbuf+0xa2>
        b[i] ^= m[i];
 800f72e:	6a3a      	ldr	r2, [r7, #32]
 800f730:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f732:	4413      	add	r3, r2
 800f734:	7819      	ldrb	r1, [r3, #0]
 800f736:	69fa      	ldr	r2, [r7, #28]
 800f738:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f73a:	4413      	add	r3, r2
 800f73c:	781a      	ldrb	r2, [r3, #0]
 800f73e:	6a38      	ldr	r0, [r7, #32]
 800f740:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f742:	4403      	add	r3, r0
 800f744:	404a      	eors	r2, r1
 800f746:	b2d2      	uxtb	r2, r2
 800f748:	701a      	strb	r2, [r3, #0]
    for (i = 0; i < count; i++)
 800f74a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f74c:	3301      	adds	r3, #1
 800f74e:	627b      	str	r3, [r7, #36]	@ 0x24
 800f750:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800f752:	687b      	ldr	r3, [r7, #4]
 800f754:	429a      	cmp	r2, r3
 800f756:	d3ea      	bcc.n	800f72e <xorbuf+0x80>
}
 800f758:	bf00      	nop
 800f75a:	bf00      	nop
 800f75c:	3728      	adds	r7, #40	@ 0x28
 800f75e:	46bd      	mov	sp, r7
 800f760:	bd80      	pop	{r7, pc}

0800f762 <ForceZero>:
{
 800f762:	b480      	push	{r7}
 800f764:	b085      	sub	sp, #20
 800f766:	af00      	add	r7, sp, #0
 800f768:	6078      	str	r0, [r7, #4]
 800f76a:	6039      	str	r1, [r7, #0]
    volatile byte* z = (volatile byte*)mem;
 800f76c:	687b      	ldr	r3, [r7, #4]
 800f76e:	60fb      	str	r3, [r7, #12]
    while (len--) *z++ = 0;
 800f770:	e004      	b.n	800f77c <ForceZero+0x1a>
 800f772:	68fb      	ldr	r3, [r7, #12]
 800f774:	1c5a      	adds	r2, r3, #1
 800f776:	60fa      	str	r2, [r7, #12]
 800f778:	2200      	movs	r2, #0
 800f77a:	701a      	strb	r2, [r3, #0]
 800f77c:	683b      	ldr	r3, [r7, #0]
 800f77e:	1e5a      	subs	r2, r3, #1
 800f780:	603a      	str	r2, [r7, #0]
 800f782:	2b00      	cmp	r3, #0
 800f784:	d1f5      	bne.n	800f772 <ForceZero+0x10>
}
 800f786:	bf00      	nop
 800f788:	bf00      	nop
 800f78a:	3714      	adds	r7, #20
 800f78c:	46bd      	mov	sp, r7
 800f78e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f792:	4770      	bx	lr

0800f794 <PreFetchTe>:
#endif

#ifndef WOLFSSL_AES_SMALL_TABLES
/* load 4 Te Tables into cache by cache line stride */
static WARN_UNUSED_RESULT WC_INLINE word32 PreFetchTe(void)
{
 800f794:	b480      	push	{r7}
 800f796:	b085      	sub	sp, #20
 800f798:	af00      	add	r7, sp, #0
#ifndef WOLFSSL_AES_TOUCH_LINES
    word32 x = 0;
 800f79a:	2300      	movs	r3, #0
 800f79c:	60fb      	str	r3, [r7, #12]
    int i,j;

    for (i = 0; i < 4; i++) {
 800f79e:	2300      	movs	r3, #0
 800f7a0:	60bb      	str	r3, [r7, #8]
 800f7a2:	e015      	b.n	800f7d0 <PreFetchTe+0x3c>
        /* 256 elements, each one is 4 bytes */
        for (j = 0; j < 256; j += WC_CACHE_LINE_SZ/4) {
 800f7a4:	2300      	movs	r3, #0
 800f7a6:	607b      	str	r3, [r7, #4]
 800f7a8:	e00c      	b.n	800f7c4 <PreFetchTe+0x30>
            x &= Te[i][j];
 800f7aa:	490e      	ldr	r1, [pc, #56]	@ (800f7e4 <PreFetchTe+0x50>)
 800f7ac:	68bb      	ldr	r3, [r7, #8]
 800f7ae:	021a      	lsls	r2, r3, #8
 800f7b0:	687b      	ldr	r3, [r7, #4]
 800f7b2:	4413      	add	r3, r2
 800f7b4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800f7b8:	68fa      	ldr	r2, [r7, #12]
 800f7ba:	4013      	ands	r3, r2
 800f7bc:	60fb      	str	r3, [r7, #12]
        for (j = 0; j < 256; j += WC_CACHE_LINE_SZ/4) {
 800f7be:	687b      	ldr	r3, [r7, #4]
 800f7c0:	3308      	adds	r3, #8
 800f7c2:	607b      	str	r3, [r7, #4]
 800f7c4:	687b      	ldr	r3, [r7, #4]
 800f7c6:	2bff      	cmp	r3, #255	@ 0xff
 800f7c8:	ddef      	ble.n	800f7aa <PreFetchTe+0x16>
    for (i = 0; i < 4; i++) {
 800f7ca:	68bb      	ldr	r3, [r7, #8]
 800f7cc:	3301      	adds	r3, #1
 800f7ce:	60bb      	str	r3, [r7, #8]
 800f7d0:	68bb      	ldr	r3, [r7, #8]
 800f7d2:	2b03      	cmp	r3, #3
 800f7d4:	dde6      	ble.n	800f7a4 <PreFetchTe+0x10>
        }
    }
    return x;
 800f7d6:	68fb      	ldr	r3, [r7, #12]
#else
    return 0;
#endif
}
 800f7d8:	4618      	mov	r0, r3
 800f7da:	3714      	adds	r7, #20
 800f7dc:	46bd      	mov	sp, r7
 800f7de:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f7e2:	4770      	bx	lr
 800f7e4:	08031494 	.word	0x08031494

0800f7e8 <AesEncrypt_C>:
 * @param [out] outBlock  Encrypted block.
 * @param [in]  r         Rounds divided by 2.
 */
static void AesEncrypt_C(Aes* aes, const byte* inBlock, byte* outBlock,
        word32 r)
{
 800f7e8:	b580      	push	{r7, lr}
 800f7ea:	b08e      	sub	sp, #56	@ 0x38
 800f7ec:	af00      	add	r7, sp, #0
 800f7ee:	60f8      	str	r0, [r7, #12]
 800f7f0:	60b9      	str	r1, [r7, #8]
 800f7f2:	607a      	str	r2, [r7, #4]
 800f7f4:	603b      	str	r3, [r7, #0]
    const word32* rk;

#ifdef WC_C_DYNAMIC_FALLBACK
    rk = aes->key_C_fallback;
#else
    rk = aes->key;
 800f7f6:	68fb      	ldr	r3, [r7, #12]
 800f7f8:	627b      	str	r3, [r7, #36]	@ 0x24

    /*
     * map byte array block to cipher state
     * and add initial round key:
     */
    XMEMCPY(&s0, inBlock,                  sizeof(s0));
 800f7fa:	68bb      	ldr	r3, [r7, #8]
 800f7fc:	681b      	ldr	r3, [r3, #0]
 800f7fe:	623b      	str	r3, [r7, #32]
    XMEMCPY(&s1, inBlock +     sizeof(s0), sizeof(s1));
 800f800:	68bb      	ldr	r3, [r7, #8]
 800f802:	3304      	adds	r3, #4
 800f804:	681b      	ldr	r3, [r3, #0]
 800f806:	61fb      	str	r3, [r7, #28]
    XMEMCPY(&s2, inBlock + 2 * sizeof(s0), sizeof(s2));
 800f808:	68bb      	ldr	r3, [r7, #8]
 800f80a:	3308      	adds	r3, #8
 800f80c:	681b      	ldr	r3, [r3, #0]
 800f80e:	61bb      	str	r3, [r7, #24]
    XMEMCPY(&s3, inBlock + 3 * sizeof(s0), sizeof(s3));
 800f810:	68bb      	ldr	r3, [r7, #8]
 800f812:	330c      	adds	r3, #12
 800f814:	681b      	ldr	r3, [r3, #0]
 800f816:	617b      	str	r3, [r7, #20]

#ifdef LITTLE_ENDIAN_ORDER
    s0 = ByteReverseWord32(s0);
 800f818:	6a3b      	ldr	r3, [r7, #32]
 800f81a:	4618      	mov	r0, r3
 800f81c:	f7ff fee5 	bl	800f5ea <ByteReverseWord32>
 800f820:	4603      	mov	r3, r0
 800f822:	623b      	str	r3, [r7, #32]
    s1 = ByteReverseWord32(s1);
 800f824:	69fb      	ldr	r3, [r7, #28]
 800f826:	4618      	mov	r0, r3
 800f828:	f7ff fedf 	bl	800f5ea <ByteReverseWord32>
 800f82c:	4603      	mov	r3, r0
 800f82e:	61fb      	str	r3, [r7, #28]
    s2 = ByteReverseWord32(s2);
 800f830:	69bb      	ldr	r3, [r7, #24]
 800f832:	4618      	mov	r0, r3
 800f834:	f7ff fed9 	bl	800f5ea <ByteReverseWord32>
 800f838:	4603      	mov	r3, r0
 800f83a:	61bb      	str	r3, [r7, #24]
    s3 = ByteReverseWord32(s3);
 800f83c:	697b      	ldr	r3, [r7, #20]
 800f83e:	4618      	mov	r0, r3
 800f840:	f7ff fed3 	bl	800f5ea <ByteReverseWord32>
 800f844:	4603      	mov	r3, r0
 800f846:	617b      	str	r3, [r7, #20]
#endif

    /* AddRoundKey */
    s0 ^= rk[0];
 800f848:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f84a:	681a      	ldr	r2, [r3, #0]
 800f84c:	6a3b      	ldr	r3, [r7, #32]
 800f84e:	4053      	eors	r3, r2
 800f850:	623b      	str	r3, [r7, #32]
    s1 ^= rk[1];
 800f852:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f854:	3304      	adds	r3, #4
 800f856:	681a      	ldr	r2, [r3, #0]
 800f858:	69fb      	ldr	r3, [r7, #28]
 800f85a:	4053      	eors	r3, r2
 800f85c:	61fb      	str	r3, [r7, #28]
    s2 ^= rk[2];
 800f85e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f860:	3308      	adds	r3, #8
 800f862:	681a      	ldr	r2, [r3, #0]
 800f864:	69bb      	ldr	r3, [r7, #24]
 800f866:	4053      	eors	r3, r2
 800f868:	61bb      	str	r3, [r7, #24]
    s3 ^= rk[3];
 800f86a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f86c:	330c      	adds	r3, #12
 800f86e:	681a      	ldr	r2, [r3, #0]
 800f870:	697b      	ldr	r3, [r7, #20]
 800f872:	4053      	eors	r3, r2
 800f874:	617b      	str	r3, [r7, #20]

#ifndef WOLFSSL_AES_SMALL_TABLES
#ifndef WC_NO_CACHE_RESISTANT
    s0 |= PreFetchTe();
 800f876:	f7ff ff8d 	bl	800f794 <PreFetchTe>
 800f87a:	4602      	mov	r2, r0
 800f87c:	6a3b      	ldr	r3, [r7, #32]
 800f87e:	4313      	orrs	r3, r2
 800f880:	623b      	str	r3, [r7, #32]
    s0 ^= rk[(o)+0]; s1 ^= rk[(o)+1]; s2 ^= rk[(o)+2]; s3 ^= rk[(o)+3];
#endif

#ifndef WOLFSSL_AES_NO_UNROLL
/* Unroll the loop. */
                       ENC_ROUND_T_S( 0);
 800f882:	6a3b      	ldr	r3, [r7, #32]
 800f884:	0e1b      	lsrs	r3, r3, #24
 800f886:	b2db      	uxtb	r3, r3
 800f888:	461a      	mov	r2, r3
 800f88a:	4bb6      	ldr	r3, [pc, #728]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800f88c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800f890:	69fb      	ldr	r3, [r7, #28]
 800f892:	0c1b      	lsrs	r3, r3, #16
 800f894:	b2db      	uxtb	r3, r3
 800f896:	49b3      	ldr	r1, [pc, #716]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800f898:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800f89c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800f8a0:	405a      	eors	r2, r3
 800f8a2:	69bb      	ldr	r3, [r7, #24]
 800f8a4:	0a1b      	lsrs	r3, r3, #8
 800f8a6:	b2db      	uxtb	r3, r3
 800f8a8:	49ae      	ldr	r1, [pc, #696]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800f8aa:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800f8ae:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800f8b2:	405a      	eors	r2, r3
 800f8b4:	697b      	ldr	r3, [r7, #20]
 800f8b6:	b2db      	uxtb	r3, r3
 800f8b8:	49aa      	ldr	r1, [pc, #680]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800f8ba:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800f8be:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800f8c2:	405a      	eors	r2, r3
 800f8c4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f8c6:	3310      	adds	r3, #16
 800f8c8:	681b      	ldr	r3, [r3, #0]
 800f8ca:	4053      	eors	r3, r2
 800f8cc:	637b      	str	r3, [r7, #52]	@ 0x34
 800f8ce:	69fb      	ldr	r3, [r7, #28]
 800f8d0:	0e1b      	lsrs	r3, r3, #24
 800f8d2:	b2db      	uxtb	r3, r3
 800f8d4:	461a      	mov	r2, r3
 800f8d6:	4ba3      	ldr	r3, [pc, #652]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800f8d8:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800f8dc:	69bb      	ldr	r3, [r7, #24]
 800f8de:	0c1b      	lsrs	r3, r3, #16
 800f8e0:	b2db      	uxtb	r3, r3
 800f8e2:	49a0      	ldr	r1, [pc, #640]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800f8e4:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800f8e8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800f8ec:	405a      	eors	r2, r3
 800f8ee:	697b      	ldr	r3, [r7, #20]
 800f8f0:	0a1b      	lsrs	r3, r3, #8
 800f8f2:	b2db      	uxtb	r3, r3
 800f8f4:	499b      	ldr	r1, [pc, #620]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800f8f6:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800f8fa:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800f8fe:	405a      	eors	r2, r3
 800f900:	6a3b      	ldr	r3, [r7, #32]
 800f902:	b2db      	uxtb	r3, r3
 800f904:	4997      	ldr	r1, [pc, #604]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800f906:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800f90a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800f90e:	405a      	eors	r2, r3
 800f910:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f912:	3314      	adds	r3, #20
 800f914:	681b      	ldr	r3, [r3, #0]
 800f916:	4053      	eors	r3, r2
 800f918:	633b      	str	r3, [r7, #48]	@ 0x30
 800f91a:	69bb      	ldr	r3, [r7, #24]
 800f91c:	0e1b      	lsrs	r3, r3, #24
 800f91e:	b2db      	uxtb	r3, r3
 800f920:	461a      	mov	r2, r3
 800f922:	4b90      	ldr	r3, [pc, #576]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800f924:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800f928:	697b      	ldr	r3, [r7, #20]
 800f92a:	0c1b      	lsrs	r3, r3, #16
 800f92c:	b2db      	uxtb	r3, r3
 800f92e:	498d      	ldr	r1, [pc, #564]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800f930:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800f934:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800f938:	405a      	eors	r2, r3
 800f93a:	6a3b      	ldr	r3, [r7, #32]
 800f93c:	0a1b      	lsrs	r3, r3, #8
 800f93e:	b2db      	uxtb	r3, r3
 800f940:	4988      	ldr	r1, [pc, #544]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800f942:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800f946:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800f94a:	405a      	eors	r2, r3
 800f94c:	69fb      	ldr	r3, [r7, #28]
 800f94e:	b2db      	uxtb	r3, r3
 800f950:	4984      	ldr	r1, [pc, #528]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800f952:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800f956:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800f95a:	405a      	eors	r2, r3
 800f95c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f95e:	3318      	adds	r3, #24
 800f960:	681b      	ldr	r3, [r3, #0]
 800f962:	4053      	eors	r3, r2
 800f964:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800f966:	697b      	ldr	r3, [r7, #20]
 800f968:	0e1b      	lsrs	r3, r3, #24
 800f96a:	b2db      	uxtb	r3, r3
 800f96c:	461a      	mov	r2, r3
 800f96e:	4b7d      	ldr	r3, [pc, #500]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800f970:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800f974:	6a3b      	ldr	r3, [r7, #32]
 800f976:	0c1b      	lsrs	r3, r3, #16
 800f978:	b2db      	uxtb	r3, r3
 800f97a:	497a      	ldr	r1, [pc, #488]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800f97c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800f980:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800f984:	405a      	eors	r2, r3
 800f986:	69fb      	ldr	r3, [r7, #28]
 800f988:	0a1b      	lsrs	r3, r3, #8
 800f98a:	b2db      	uxtb	r3, r3
 800f98c:	4975      	ldr	r1, [pc, #468]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800f98e:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800f992:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800f996:	405a      	eors	r2, r3
 800f998:	69bb      	ldr	r3, [r7, #24]
 800f99a:	b2db      	uxtb	r3, r3
 800f99c:	4971      	ldr	r1, [pc, #452]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800f99e:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800f9a2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800f9a6:	405a      	eors	r2, r3
 800f9a8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f9aa:	331c      	adds	r3, #28
 800f9ac:	681b      	ldr	r3, [r3, #0]
 800f9ae:	4053      	eors	r3, r2
 800f9b0:	62bb      	str	r3, [r7, #40]	@ 0x28
    ENC_ROUND_S_T( 8); ENC_ROUND_T_S( 8);
 800f9b2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f9b4:	0e1b      	lsrs	r3, r3, #24
 800f9b6:	b2db      	uxtb	r3, r3
 800f9b8:	461a      	mov	r2, r3
 800f9ba:	4b6a      	ldr	r3, [pc, #424]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800f9bc:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800f9c0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800f9c2:	0c1b      	lsrs	r3, r3, #16
 800f9c4:	b2db      	uxtb	r3, r3
 800f9c6:	4967      	ldr	r1, [pc, #412]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800f9c8:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800f9cc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800f9d0:	405a      	eors	r2, r3
 800f9d2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800f9d4:	0a1b      	lsrs	r3, r3, #8
 800f9d6:	b2db      	uxtb	r3, r3
 800f9d8:	4962      	ldr	r1, [pc, #392]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800f9da:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800f9de:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800f9e2:	405a      	eors	r2, r3
 800f9e4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f9e6:	b2db      	uxtb	r3, r3
 800f9e8:	495e      	ldr	r1, [pc, #376]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800f9ea:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800f9ee:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800f9f2:	405a      	eors	r2, r3
 800f9f4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f9f6:	3320      	adds	r3, #32
 800f9f8:	681b      	ldr	r3, [r3, #0]
 800f9fa:	4053      	eors	r3, r2
 800f9fc:	623b      	str	r3, [r7, #32]
 800f9fe:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800fa00:	0e1b      	lsrs	r3, r3, #24
 800fa02:	b2db      	uxtb	r3, r3
 800fa04:	461a      	mov	r2, r3
 800fa06:	4b57      	ldr	r3, [pc, #348]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800fa08:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fa0c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800fa0e:	0c1b      	lsrs	r3, r3, #16
 800fa10:	b2db      	uxtb	r3, r3
 800fa12:	4954      	ldr	r1, [pc, #336]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800fa14:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fa18:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fa1c:	405a      	eors	r2, r3
 800fa1e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800fa20:	0a1b      	lsrs	r3, r3, #8
 800fa22:	b2db      	uxtb	r3, r3
 800fa24:	494f      	ldr	r1, [pc, #316]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800fa26:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fa2a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fa2e:	405a      	eors	r2, r3
 800fa30:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fa32:	b2db      	uxtb	r3, r3
 800fa34:	494b      	ldr	r1, [pc, #300]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800fa36:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fa3a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fa3e:	405a      	eors	r2, r3
 800fa40:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fa42:	3324      	adds	r3, #36	@ 0x24
 800fa44:	681b      	ldr	r3, [r3, #0]
 800fa46:	4053      	eors	r3, r2
 800fa48:	61fb      	str	r3, [r7, #28]
 800fa4a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800fa4c:	0e1b      	lsrs	r3, r3, #24
 800fa4e:	b2db      	uxtb	r3, r3
 800fa50:	461a      	mov	r2, r3
 800fa52:	4b44      	ldr	r3, [pc, #272]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800fa54:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fa58:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800fa5a:	0c1b      	lsrs	r3, r3, #16
 800fa5c:	b2db      	uxtb	r3, r3
 800fa5e:	4941      	ldr	r1, [pc, #260]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800fa60:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fa64:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fa68:	405a      	eors	r2, r3
 800fa6a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fa6c:	0a1b      	lsrs	r3, r3, #8
 800fa6e:	b2db      	uxtb	r3, r3
 800fa70:	493c      	ldr	r1, [pc, #240]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800fa72:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fa76:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fa7a:	405a      	eors	r2, r3
 800fa7c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800fa7e:	b2db      	uxtb	r3, r3
 800fa80:	4938      	ldr	r1, [pc, #224]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800fa82:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fa86:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fa8a:	405a      	eors	r2, r3
 800fa8c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fa8e:	3328      	adds	r3, #40	@ 0x28
 800fa90:	681b      	ldr	r3, [r3, #0]
 800fa92:	4053      	eors	r3, r2
 800fa94:	61bb      	str	r3, [r7, #24]
 800fa96:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800fa98:	0e1b      	lsrs	r3, r3, #24
 800fa9a:	b2db      	uxtb	r3, r3
 800fa9c:	461a      	mov	r2, r3
 800fa9e:	4b31      	ldr	r3, [pc, #196]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800faa0:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800faa4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800faa6:	0c1b      	lsrs	r3, r3, #16
 800faa8:	b2db      	uxtb	r3, r3
 800faaa:	492e      	ldr	r1, [pc, #184]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800faac:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fab0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fab4:	405a      	eors	r2, r3
 800fab6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800fab8:	0a1b      	lsrs	r3, r3, #8
 800faba:	b2db      	uxtb	r3, r3
 800fabc:	4929      	ldr	r1, [pc, #164]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800fabe:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fac2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fac6:	405a      	eors	r2, r3
 800fac8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800faca:	b2db      	uxtb	r3, r3
 800facc:	4925      	ldr	r1, [pc, #148]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800face:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fad2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fad6:	405a      	eors	r2, r3
 800fad8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fada:	332c      	adds	r3, #44	@ 0x2c
 800fadc:	681b      	ldr	r3, [r3, #0]
 800fade:	4053      	eors	r3, r2
 800fae0:	617b      	str	r3, [r7, #20]
 800fae2:	6a3b      	ldr	r3, [r7, #32]
 800fae4:	0e1b      	lsrs	r3, r3, #24
 800fae6:	b2db      	uxtb	r3, r3
 800fae8:	461a      	mov	r2, r3
 800faea:	4b1e      	ldr	r3, [pc, #120]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800faec:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800faf0:	69fb      	ldr	r3, [r7, #28]
 800faf2:	0c1b      	lsrs	r3, r3, #16
 800faf4:	b2db      	uxtb	r3, r3
 800faf6:	491b      	ldr	r1, [pc, #108]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800faf8:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fafc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fb00:	405a      	eors	r2, r3
 800fb02:	69bb      	ldr	r3, [r7, #24]
 800fb04:	0a1b      	lsrs	r3, r3, #8
 800fb06:	b2db      	uxtb	r3, r3
 800fb08:	4916      	ldr	r1, [pc, #88]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800fb0a:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fb0e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fb12:	405a      	eors	r2, r3
 800fb14:	697b      	ldr	r3, [r7, #20]
 800fb16:	b2db      	uxtb	r3, r3
 800fb18:	4912      	ldr	r1, [pc, #72]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800fb1a:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fb1e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fb22:	405a      	eors	r2, r3
 800fb24:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fb26:	3330      	adds	r3, #48	@ 0x30
 800fb28:	681b      	ldr	r3, [r3, #0]
 800fb2a:	4053      	eors	r3, r2
 800fb2c:	637b      	str	r3, [r7, #52]	@ 0x34
 800fb2e:	69fb      	ldr	r3, [r7, #28]
 800fb30:	0e1b      	lsrs	r3, r3, #24
 800fb32:	b2db      	uxtb	r3, r3
 800fb34:	461a      	mov	r2, r3
 800fb36:	4b0b      	ldr	r3, [pc, #44]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800fb38:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fb3c:	69bb      	ldr	r3, [r7, #24]
 800fb3e:	0c1b      	lsrs	r3, r3, #16
 800fb40:	b2db      	uxtb	r3, r3
 800fb42:	4908      	ldr	r1, [pc, #32]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800fb44:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fb48:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fb4c:	405a      	eors	r2, r3
 800fb4e:	697b      	ldr	r3, [r7, #20]
 800fb50:	0a1b      	lsrs	r3, r3, #8
 800fb52:	b2db      	uxtb	r3, r3
 800fb54:	4903      	ldr	r1, [pc, #12]	@ (800fb64 <AesEncrypt_C+0x37c>)
 800fb56:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fb5a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fb5e:	405a      	eors	r2, r3
 800fb60:	6a3b      	ldr	r3, [r7, #32]
 800fb62:	e001      	b.n	800fb68 <AesEncrypt_C+0x380>
 800fb64:	08031494 	.word	0x08031494
 800fb68:	b2db      	uxtb	r3, r3
 800fb6a:	49b6      	ldr	r1, [pc, #728]	@ (800fe44 <AesEncrypt_C+0x65c>)
 800fb6c:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fb70:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fb74:	405a      	eors	r2, r3
 800fb76:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fb78:	3334      	adds	r3, #52	@ 0x34
 800fb7a:	681b      	ldr	r3, [r3, #0]
 800fb7c:	4053      	eors	r3, r2
 800fb7e:	633b      	str	r3, [r7, #48]	@ 0x30
 800fb80:	69bb      	ldr	r3, [r7, #24]
 800fb82:	0e1b      	lsrs	r3, r3, #24
 800fb84:	b2db      	uxtb	r3, r3
 800fb86:	461a      	mov	r2, r3
 800fb88:	4bae      	ldr	r3, [pc, #696]	@ (800fe44 <AesEncrypt_C+0x65c>)
 800fb8a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fb8e:	697b      	ldr	r3, [r7, #20]
 800fb90:	0c1b      	lsrs	r3, r3, #16
 800fb92:	b2db      	uxtb	r3, r3
 800fb94:	49ab      	ldr	r1, [pc, #684]	@ (800fe44 <AesEncrypt_C+0x65c>)
 800fb96:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fb9a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fb9e:	405a      	eors	r2, r3
 800fba0:	6a3b      	ldr	r3, [r7, #32]
 800fba2:	0a1b      	lsrs	r3, r3, #8
 800fba4:	b2db      	uxtb	r3, r3
 800fba6:	49a7      	ldr	r1, [pc, #668]	@ (800fe44 <AesEncrypt_C+0x65c>)
 800fba8:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fbac:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fbb0:	405a      	eors	r2, r3
 800fbb2:	69fb      	ldr	r3, [r7, #28]
 800fbb4:	b2db      	uxtb	r3, r3
 800fbb6:	49a3      	ldr	r1, [pc, #652]	@ (800fe44 <AesEncrypt_C+0x65c>)
 800fbb8:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fbbc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fbc0:	405a      	eors	r2, r3
 800fbc2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fbc4:	3338      	adds	r3, #56	@ 0x38
 800fbc6:	681b      	ldr	r3, [r3, #0]
 800fbc8:	4053      	eors	r3, r2
 800fbca:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800fbcc:	697b      	ldr	r3, [r7, #20]
 800fbce:	0e1b      	lsrs	r3, r3, #24
 800fbd0:	b2db      	uxtb	r3, r3
 800fbd2:	461a      	mov	r2, r3
 800fbd4:	4b9b      	ldr	r3, [pc, #620]	@ (800fe44 <AesEncrypt_C+0x65c>)
 800fbd6:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fbda:	6a3b      	ldr	r3, [r7, #32]
 800fbdc:	0c1b      	lsrs	r3, r3, #16
 800fbde:	b2db      	uxtb	r3, r3
 800fbe0:	4998      	ldr	r1, [pc, #608]	@ (800fe44 <AesEncrypt_C+0x65c>)
 800fbe2:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fbe6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fbea:	405a      	eors	r2, r3
 800fbec:	69fb      	ldr	r3, [r7, #28]
 800fbee:	0a1b      	lsrs	r3, r3, #8
 800fbf0:	b2db      	uxtb	r3, r3
 800fbf2:	4994      	ldr	r1, [pc, #592]	@ (800fe44 <AesEncrypt_C+0x65c>)
 800fbf4:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fbf8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fbfc:	405a      	eors	r2, r3
 800fbfe:	69bb      	ldr	r3, [r7, #24]
 800fc00:	b2db      	uxtb	r3, r3
 800fc02:	4990      	ldr	r1, [pc, #576]	@ (800fe44 <AesEncrypt_C+0x65c>)
 800fc04:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fc08:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fc0c:	405a      	eors	r2, r3
 800fc0e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fc10:	333c      	adds	r3, #60	@ 0x3c
 800fc12:	681b      	ldr	r3, [r3, #0]
 800fc14:	4053      	eors	r3, r2
 800fc16:	62bb      	str	r3, [r7, #40]	@ 0x28
    ENC_ROUND_S_T(16); ENC_ROUND_T_S(16);
 800fc18:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fc1a:	0e1b      	lsrs	r3, r3, #24
 800fc1c:	b2db      	uxtb	r3, r3
 800fc1e:	461a      	mov	r2, r3
 800fc20:	4b88      	ldr	r3, [pc, #544]	@ (800fe44 <AesEncrypt_C+0x65c>)
 800fc22:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fc26:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800fc28:	0c1b      	lsrs	r3, r3, #16
 800fc2a:	b2db      	uxtb	r3, r3
 800fc2c:	4985      	ldr	r1, [pc, #532]	@ (800fe44 <AesEncrypt_C+0x65c>)
 800fc2e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fc32:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fc36:	405a      	eors	r2, r3
 800fc38:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800fc3a:	0a1b      	lsrs	r3, r3, #8
 800fc3c:	b2db      	uxtb	r3, r3
 800fc3e:	4981      	ldr	r1, [pc, #516]	@ (800fe44 <AesEncrypt_C+0x65c>)
 800fc40:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fc44:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fc48:	405a      	eors	r2, r3
 800fc4a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800fc4c:	b2db      	uxtb	r3, r3
 800fc4e:	497d      	ldr	r1, [pc, #500]	@ (800fe44 <AesEncrypt_C+0x65c>)
 800fc50:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fc54:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fc58:	405a      	eors	r2, r3
 800fc5a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fc5c:	3340      	adds	r3, #64	@ 0x40
 800fc5e:	681b      	ldr	r3, [r3, #0]
 800fc60:	4053      	eors	r3, r2
 800fc62:	623b      	str	r3, [r7, #32]
 800fc64:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800fc66:	0e1b      	lsrs	r3, r3, #24
 800fc68:	b2db      	uxtb	r3, r3
 800fc6a:	461a      	mov	r2, r3
 800fc6c:	4b75      	ldr	r3, [pc, #468]	@ (800fe44 <AesEncrypt_C+0x65c>)
 800fc6e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fc72:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800fc74:	0c1b      	lsrs	r3, r3, #16
 800fc76:	b2db      	uxtb	r3, r3
 800fc78:	4972      	ldr	r1, [pc, #456]	@ (800fe44 <AesEncrypt_C+0x65c>)
 800fc7a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fc7e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fc82:	405a      	eors	r2, r3
 800fc84:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800fc86:	0a1b      	lsrs	r3, r3, #8
 800fc88:	b2db      	uxtb	r3, r3
 800fc8a:	496e      	ldr	r1, [pc, #440]	@ (800fe44 <AesEncrypt_C+0x65c>)
 800fc8c:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fc90:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fc94:	405a      	eors	r2, r3
 800fc96:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fc98:	b2db      	uxtb	r3, r3
 800fc9a:	496a      	ldr	r1, [pc, #424]	@ (800fe44 <AesEncrypt_C+0x65c>)
 800fc9c:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fca0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fca4:	405a      	eors	r2, r3
 800fca6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fca8:	3344      	adds	r3, #68	@ 0x44
 800fcaa:	681b      	ldr	r3, [r3, #0]
 800fcac:	4053      	eors	r3, r2
 800fcae:	61fb      	str	r3, [r7, #28]
 800fcb0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800fcb2:	0e1b      	lsrs	r3, r3, #24
 800fcb4:	b2db      	uxtb	r3, r3
 800fcb6:	461a      	mov	r2, r3
 800fcb8:	4b62      	ldr	r3, [pc, #392]	@ (800fe44 <AesEncrypt_C+0x65c>)
 800fcba:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fcbe:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800fcc0:	0c1b      	lsrs	r3, r3, #16
 800fcc2:	b2db      	uxtb	r3, r3
 800fcc4:	495f      	ldr	r1, [pc, #380]	@ (800fe44 <AesEncrypt_C+0x65c>)
 800fcc6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fcca:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fcce:	405a      	eors	r2, r3
 800fcd0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fcd2:	0a1b      	lsrs	r3, r3, #8
 800fcd4:	b2db      	uxtb	r3, r3
 800fcd6:	495b      	ldr	r1, [pc, #364]	@ (800fe44 <AesEncrypt_C+0x65c>)
 800fcd8:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fcdc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fce0:	405a      	eors	r2, r3
 800fce2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800fce4:	b2db      	uxtb	r3, r3
 800fce6:	4957      	ldr	r1, [pc, #348]	@ (800fe44 <AesEncrypt_C+0x65c>)
 800fce8:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fcec:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fcf0:	405a      	eors	r2, r3
 800fcf2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fcf4:	3348      	adds	r3, #72	@ 0x48
 800fcf6:	681b      	ldr	r3, [r3, #0]
 800fcf8:	4053      	eors	r3, r2
 800fcfa:	61bb      	str	r3, [r7, #24]
 800fcfc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800fcfe:	0e1b      	lsrs	r3, r3, #24
 800fd00:	b2db      	uxtb	r3, r3
 800fd02:	461a      	mov	r2, r3
 800fd04:	4b4f      	ldr	r3, [pc, #316]	@ (800fe44 <AesEncrypt_C+0x65c>)
 800fd06:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fd0a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fd0c:	0c1b      	lsrs	r3, r3, #16
 800fd0e:	b2db      	uxtb	r3, r3
 800fd10:	494c      	ldr	r1, [pc, #304]	@ (800fe44 <AesEncrypt_C+0x65c>)
 800fd12:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fd16:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fd1a:	405a      	eors	r2, r3
 800fd1c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800fd1e:	0a1b      	lsrs	r3, r3, #8
 800fd20:	b2db      	uxtb	r3, r3
 800fd22:	4948      	ldr	r1, [pc, #288]	@ (800fe44 <AesEncrypt_C+0x65c>)
 800fd24:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fd28:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fd2c:	405a      	eors	r2, r3
 800fd2e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800fd30:	b2db      	uxtb	r3, r3
 800fd32:	4944      	ldr	r1, [pc, #272]	@ (800fe44 <AesEncrypt_C+0x65c>)
 800fd34:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fd38:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fd3c:	405a      	eors	r2, r3
 800fd3e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fd40:	334c      	adds	r3, #76	@ 0x4c
 800fd42:	681b      	ldr	r3, [r3, #0]
 800fd44:	4053      	eors	r3, r2
 800fd46:	617b      	str	r3, [r7, #20]
 800fd48:	6a3b      	ldr	r3, [r7, #32]
 800fd4a:	0e1b      	lsrs	r3, r3, #24
 800fd4c:	b2db      	uxtb	r3, r3
 800fd4e:	461a      	mov	r2, r3
 800fd50:	4b3c      	ldr	r3, [pc, #240]	@ (800fe44 <AesEncrypt_C+0x65c>)
 800fd52:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fd56:	69fb      	ldr	r3, [r7, #28]
 800fd58:	0c1b      	lsrs	r3, r3, #16
 800fd5a:	b2db      	uxtb	r3, r3
 800fd5c:	4939      	ldr	r1, [pc, #228]	@ (800fe44 <AesEncrypt_C+0x65c>)
 800fd5e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fd62:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fd66:	405a      	eors	r2, r3
 800fd68:	69bb      	ldr	r3, [r7, #24]
 800fd6a:	0a1b      	lsrs	r3, r3, #8
 800fd6c:	b2db      	uxtb	r3, r3
 800fd6e:	4935      	ldr	r1, [pc, #212]	@ (800fe44 <AesEncrypt_C+0x65c>)
 800fd70:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fd74:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fd78:	405a      	eors	r2, r3
 800fd7a:	697b      	ldr	r3, [r7, #20]
 800fd7c:	b2db      	uxtb	r3, r3
 800fd7e:	4931      	ldr	r1, [pc, #196]	@ (800fe44 <AesEncrypt_C+0x65c>)
 800fd80:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fd84:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fd88:	405a      	eors	r2, r3
 800fd8a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fd8c:	3350      	adds	r3, #80	@ 0x50
 800fd8e:	681b      	ldr	r3, [r3, #0]
 800fd90:	4053      	eors	r3, r2
 800fd92:	637b      	str	r3, [r7, #52]	@ 0x34
 800fd94:	69fb      	ldr	r3, [r7, #28]
 800fd96:	0e1b      	lsrs	r3, r3, #24
 800fd98:	b2db      	uxtb	r3, r3
 800fd9a:	461a      	mov	r2, r3
 800fd9c:	4b29      	ldr	r3, [pc, #164]	@ (800fe44 <AesEncrypt_C+0x65c>)
 800fd9e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fda2:	69bb      	ldr	r3, [r7, #24]
 800fda4:	0c1b      	lsrs	r3, r3, #16
 800fda6:	b2db      	uxtb	r3, r3
 800fda8:	4926      	ldr	r1, [pc, #152]	@ (800fe44 <AesEncrypt_C+0x65c>)
 800fdaa:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fdae:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fdb2:	405a      	eors	r2, r3
 800fdb4:	697b      	ldr	r3, [r7, #20]
 800fdb6:	0a1b      	lsrs	r3, r3, #8
 800fdb8:	b2db      	uxtb	r3, r3
 800fdba:	4922      	ldr	r1, [pc, #136]	@ (800fe44 <AesEncrypt_C+0x65c>)
 800fdbc:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fdc0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fdc4:	405a      	eors	r2, r3
 800fdc6:	6a3b      	ldr	r3, [r7, #32]
 800fdc8:	b2db      	uxtb	r3, r3
 800fdca:	491e      	ldr	r1, [pc, #120]	@ (800fe44 <AesEncrypt_C+0x65c>)
 800fdcc:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fdd0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fdd4:	405a      	eors	r2, r3
 800fdd6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fdd8:	3354      	adds	r3, #84	@ 0x54
 800fdda:	681b      	ldr	r3, [r3, #0]
 800fddc:	4053      	eors	r3, r2
 800fdde:	633b      	str	r3, [r7, #48]	@ 0x30
 800fde0:	69bb      	ldr	r3, [r7, #24]
 800fde2:	0e1b      	lsrs	r3, r3, #24
 800fde4:	b2db      	uxtb	r3, r3
 800fde6:	461a      	mov	r2, r3
 800fde8:	4b16      	ldr	r3, [pc, #88]	@ (800fe44 <AesEncrypt_C+0x65c>)
 800fdea:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fdee:	697b      	ldr	r3, [r7, #20]
 800fdf0:	0c1b      	lsrs	r3, r3, #16
 800fdf2:	b2db      	uxtb	r3, r3
 800fdf4:	4913      	ldr	r1, [pc, #76]	@ (800fe44 <AesEncrypt_C+0x65c>)
 800fdf6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fdfa:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fdfe:	405a      	eors	r2, r3
 800fe00:	6a3b      	ldr	r3, [r7, #32]
 800fe02:	0a1b      	lsrs	r3, r3, #8
 800fe04:	b2db      	uxtb	r3, r3
 800fe06:	490f      	ldr	r1, [pc, #60]	@ (800fe44 <AesEncrypt_C+0x65c>)
 800fe08:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fe0c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fe10:	405a      	eors	r2, r3
 800fe12:	69fb      	ldr	r3, [r7, #28]
 800fe14:	b2db      	uxtb	r3, r3
 800fe16:	490b      	ldr	r1, [pc, #44]	@ (800fe44 <AesEncrypt_C+0x65c>)
 800fe18:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fe1c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fe20:	405a      	eors	r2, r3
 800fe22:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fe24:	3358      	adds	r3, #88	@ 0x58
 800fe26:	681b      	ldr	r3, [r3, #0]
 800fe28:	4053      	eors	r3, r2
 800fe2a:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800fe2c:	697b      	ldr	r3, [r7, #20]
 800fe2e:	0e1b      	lsrs	r3, r3, #24
 800fe30:	b2db      	uxtb	r3, r3
 800fe32:	461a      	mov	r2, r3
 800fe34:	4b03      	ldr	r3, [pc, #12]	@ (800fe44 <AesEncrypt_C+0x65c>)
 800fe36:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fe3a:	6a3b      	ldr	r3, [r7, #32]
 800fe3c:	0c1b      	lsrs	r3, r3, #16
 800fe3e:	b2db      	uxtb	r3, r3
 800fe40:	e002      	b.n	800fe48 <AesEncrypt_C+0x660>
 800fe42:	bf00      	nop
 800fe44:	08031494 	.word	0x08031494
 800fe48:	49b6      	ldr	r1, [pc, #728]	@ (8010124 <AesEncrypt_C+0x93c>)
 800fe4a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fe4e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fe52:	405a      	eors	r2, r3
 800fe54:	69fb      	ldr	r3, [r7, #28]
 800fe56:	0a1b      	lsrs	r3, r3, #8
 800fe58:	b2db      	uxtb	r3, r3
 800fe5a:	49b2      	ldr	r1, [pc, #712]	@ (8010124 <AesEncrypt_C+0x93c>)
 800fe5c:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fe60:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fe64:	405a      	eors	r2, r3
 800fe66:	69bb      	ldr	r3, [r7, #24]
 800fe68:	b2db      	uxtb	r3, r3
 800fe6a:	49ae      	ldr	r1, [pc, #696]	@ (8010124 <AesEncrypt_C+0x93c>)
 800fe6c:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fe70:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fe74:	405a      	eors	r2, r3
 800fe76:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fe78:	335c      	adds	r3, #92	@ 0x5c
 800fe7a:	681b      	ldr	r3, [r3, #0]
 800fe7c:	4053      	eors	r3, r2
 800fe7e:	62bb      	str	r3, [r7, #40]	@ 0x28
    ENC_ROUND_S_T(24); ENC_ROUND_T_S(24);
 800fe80:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fe82:	0e1b      	lsrs	r3, r3, #24
 800fe84:	b2db      	uxtb	r3, r3
 800fe86:	461a      	mov	r2, r3
 800fe88:	4ba6      	ldr	r3, [pc, #664]	@ (8010124 <AesEncrypt_C+0x93c>)
 800fe8a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fe8e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800fe90:	0c1b      	lsrs	r3, r3, #16
 800fe92:	b2db      	uxtb	r3, r3
 800fe94:	49a3      	ldr	r1, [pc, #652]	@ (8010124 <AesEncrypt_C+0x93c>)
 800fe96:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fe9a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fe9e:	405a      	eors	r2, r3
 800fea0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800fea2:	0a1b      	lsrs	r3, r3, #8
 800fea4:	b2db      	uxtb	r3, r3
 800fea6:	499f      	ldr	r1, [pc, #636]	@ (8010124 <AesEncrypt_C+0x93c>)
 800fea8:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800feac:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800feb0:	405a      	eors	r2, r3
 800feb2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800feb4:	b2db      	uxtb	r3, r3
 800feb6:	499b      	ldr	r1, [pc, #620]	@ (8010124 <AesEncrypt_C+0x93c>)
 800feb8:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800febc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fec0:	405a      	eors	r2, r3
 800fec2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fec4:	3360      	adds	r3, #96	@ 0x60
 800fec6:	681b      	ldr	r3, [r3, #0]
 800fec8:	4053      	eors	r3, r2
 800feca:	623b      	str	r3, [r7, #32]
 800fecc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800fece:	0e1b      	lsrs	r3, r3, #24
 800fed0:	b2db      	uxtb	r3, r3
 800fed2:	461a      	mov	r2, r3
 800fed4:	4b93      	ldr	r3, [pc, #588]	@ (8010124 <AesEncrypt_C+0x93c>)
 800fed6:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800feda:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800fedc:	0c1b      	lsrs	r3, r3, #16
 800fede:	b2db      	uxtb	r3, r3
 800fee0:	4990      	ldr	r1, [pc, #576]	@ (8010124 <AesEncrypt_C+0x93c>)
 800fee2:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fee6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800feea:	405a      	eors	r2, r3
 800feec:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800feee:	0a1b      	lsrs	r3, r3, #8
 800fef0:	b2db      	uxtb	r3, r3
 800fef2:	498c      	ldr	r1, [pc, #560]	@ (8010124 <AesEncrypt_C+0x93c>)
 800fef4:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fef8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fefc:	405a      	eors	r2, r3
 800fefe:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800ff00:	b2db      	uxtb	r3, r3
 800ff02:	4988      	ldr	r1, [pc, #544]	@ (8010124 <AesEncrypt_C+0x93c>)
 800ff04:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800ff08:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800ff0c:	405a      	eors	r2, r3
 800ff0e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800ff10:	3364      	adds	r3, #100	@ 0x64
 800ff12:	681b      	ldr	r3, [r3, #0]
 800ff14:	4053      	eors	r3, r2
 800ff16:	61fb      	str	r3, [r7, #28]
 800ff18:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800ff1a:	0e1b      	lsrs	r3, r3, #24
 800ff1c:	b2db      	uxtb	r3, r3
 800ff1e:	461a      	mov	r2, r3
 800ff20:	4b80      	ldr	r3, [pc, #512]	@ (8010124 <AesEncrypt_C+0x93c>)
 800ff22:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800ff26:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800ff28:	0c1b      	lsrs	r3, r3, #16
 800ff2a:	b2db      	uxtb	r3, r3
 800ff2c:	497d      	ldr	r1, [pc, #500]	@ (8010124 <AesEncrypt_C+0x93c>)
 800ff2e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800ff32:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800ff36:	405a      	eors	r2, r3
 800ff38:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800ff3a:	0a1b      	lsrs	r3, r3, #8
 800ff3c:	b2db      	uxtb	r3, r3
 800ff3e:	4979      	ldr	r1, [pc, #484]	@ (8010124 <AesEncrypt_C+0x93c>)
 800ff40:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800ff44:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800ff48:	405a      	eors	r2, r3
 800ff4a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800ff4c:	b2db      	uxtb	r3, r3
 800ff4e:	4975      	ldr	r1, [pc, #468]	@ (8010124 <AesEncrypt_C+0x93c>)
 800ff50:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800ff54:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800ff58:	405a      	eors	r2, r3
 800ff5a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800ff5c:	3368      	adds	r3, #104	@ 0x68
 800ff5e:	681b      	ldr	r3, [r3, #0]
 800ff60:	4053      	eors	r3, r2
 800ff62:	61bb      	str	r3, [r7, #24]
 800ff64:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800ff66:	0e1b      	lsrs	r3, r3, #24
 800ff68:	b2db      	uxtb	r3, r3
 800ff6a:	461a      	mov	r2, r3
 800ff6c:	4b6d      	ldr	r3, [pc, #436]	@ (8010124 <AesEncrypt_C+0x93c>)
 800ff6e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800ff72:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800ff74:	0c1b      	lsrs	r3, r3, #16
 800ff76:	b2db      	uxtb	r3, r3
 800ff78:	496a      	ldr	r1, [pc, #424]	@ (8010124 <AesEncrypt_C+0x93c>)
 800ff7a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800ff7e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800ff82:	405a      	eors	r2, r3
 800ff84:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800ff86:	0a1b      	lsrs	r3, r3, #8
 800ff88:	b2db      	uxtb	r3, r3
 800ff8a:	4966      	ldr	r1, [pc, #408]	@ (8010124 <AesEncrypt_C+0x93c>)
 800ff8c:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800ff90:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800ff94:	405a      	eors	r2, r3
 800ff96:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800ff98:	b2db      	uxtb	r3, r3
 800ff9a:	4962      	ldr	r1, [pc, #392]	@ (8010124 <AesEncrypt_C+0x93c>)
 800ff9c:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800ffa0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800ffa4:	405a      	eors	r2, r3
 800ffa6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800ffa8:	336c      	adds	r3, #108	@ 0x6c
 800ffaa:	681b      	ldr	r3, [r3, #0]
 800ffac:	4053      	eors	r3, r2
 800ffae:	617b      	str	r3, [r7, #20]
 800ffb0:	6a3b      	ldr	r3, [r7, #32]
 800ffb2:	0e1b      	lsrs	r3, r3, #24
 800ffb4:	b2db      	uxtb	r3, r3
 800ffb6:	461a      	mov	r2, r3
 800ffb8:	4b5a      	ldr	r3, [pc, #360]	@ (8010124 <AesEncrypt_C+0x93c>)
 800ffba:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800ffbe:	69fb      	ldr	r3, [r7, #28]
 800ffc0:	0c1b      	lsrs	r3, r3, #16
 800ffc2:	b2db      	uxtb	r3, r3
 800ffc4:	4957      	ldr	r1, [pc, #348]	@ (8010124 <AesEncrypt_C+0x93c>)
 800ffc6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800ffca:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800ffce:	405a      	eors	r2, r3
 800ffd0:	69bb      	ldr	r3, [r7, #24]
 800ffd2:	0a1b      	lsrs	r3, r3, #8
 800ffd4:	b2db      	uxtb	r3, r3
 800ffd6:	4953      	ldr	r1, [pc, #332]	@ (8010124 <AesEncrypt_C+0x93c>)
 800ffd8:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800ffdc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800ffe0:	405a      	eors	r2, r3
 800ffe2:	697b      	ldr	r3, [r7, #20]
 800ffe4:	b2db      	uxtb	r3, r3
 800ffe6:	494f      	ldr	r1, [pc, #316]	@ (8010124 <AesEncrypt_C+0x93c>)
 800ffe8:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800ffec:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fff0:	405a      	eors	r2, r3
 800fff2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fff4:	3370      	adds	r3, #112	@ 0x70
 800fff6:	681b      	ldr	r3, [r3, #0]
 800fff8:	4053      	eors	r3, r2
 800fffa:	637b      	str	r3, [r7, #52]	@ 0x34
 800fffc:	69fb      	ldr	r3, [r7, #28]
 800fffe:	0e1b      	lsrs	r3, r3, #24
 8010000:	b2db      	uxtb	r3, r3
 8010002:	461a      	mov	r2, r3
 8010004:	4b47      	ldr	r3, [pc, #284]	@ (8010124 <AesEncrypt_C+0x93c>)
 8010006:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801000a:	69bb      	ldr	r3, [r7, #24]
 801000c:	0c1b      	lsrs	r3, r3, #16
 801000e:	b2db      	uxtb	r3, r3
 8010010:	4944      	ldr	r1, [pc, #272]	@ (8010124 <AesEncrypt_C+0x93c>)
 8010012:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010016:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801001a:	405a      	eors	r2, r3
 801001c:	697b      	ldr	r3, [r7, #20]
 801001e:	0a1b      	lsrs	r3, r3, #8
 8010020:	b2db      	uxtb	r3, r3
 8010022:	4940      	ldr	r1, [pc, #256]	@ (8010124 <AesEncrypt_C+0x93c>)
 8010024:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010028:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801002c:	405a      	eors	r2, r3
 801002e:	6a3b      	ldr	r3, [r7, #32]
 8010030:	b2db      	uxtb	r3, r3
 8010032:	493c      	ldr	r1, [pc, #240]	@ (8010124 <AesEncrypt_C+0x93c>)
 8010034:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010038:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801003c:	405a      	eors	r2, r3
 801003e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010040:	3374      	adds	r3, #116	@ 0x74
 8010042:	681b      	ldr	r3, [r3, #0]
 8010044:	4053      	eors	r3, r2
 8010046:	633b      	str	r3, [r7, #48]	@ 0x30
 8010048:	69bb      	ldr	r3, [r7, #24]
 801004a:	0e1b      	lsrs	r3, r3, #24
 801004c:	b2db      	uxtb	r3, r3
 801004e:	461a      	mov	r2, r3
 8010050:	4b34      	ldr	r3, [pc, #208]	@ (8010124 <AesEncrypt_C+0x93c>)
 8010052:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010056:	697b      	ldr	r3, [r7, #20]
 8010058:	0c1b      	lsrs	r3, r3, #16
 801005a:	b2db      	uxtb	r3, r3
 801005c:	4931      	ldr	r1, [pc, #196]	@ (8010124 <AesEncrypt_C+0x93c>)
 801005e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010062:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010066:	405a      	eors	r2, r3
 8010068:	6a3b      	ldr	r3, [r7, #32]
 801006a:	0a1b      	lsrs	r3, r3, #8
 801006c:	b2db      	uxtb	r3, r3
 801006e:	492d      	ldr	r1, [pc, #180]	@ (8010124 <AesEncrypt_C+0x93c>)
 8010070:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010074:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010078:	405a      	eors	r2, r3
 801007a:	69fb      	ldr	r3, [r7, #28]
 801007c:	b2db      	uxtb	r3, r3
 801007e:	4929      	ldr	r1, [pc, #164]	@ (8010124 <AesEncrypt_C+0x93c>)
 8010080:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010084:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010088:	405a      	eors	r2, r3
 801008a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801008c:	3378      	adds	r3, #120	@ 0x78
 801008e:	681b      	ldr	r3, [r3, #0]
 8010090:	4053      	eors	r3, r2
 8010092:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8010094:	697b      	ldr	r3, [r7, #20]
 8010096:	0e1b      	lsrs	r3, r3, #24
 8010098:	b2db      	uxtb	r3, r3
 801009a:	461a      	mov	r2, r3
 801009c:	4b21      	ldr	r3, [pc, #132]	@ (8010124 <AesEncrypt_C+0x93c>)
 801009e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80100a2:	6a3b      	ldr	r3, [r7, #32]
 80100a4:	0c1b      	lsrs	r3, r3, #16
 80100a6:	b2db      	uxtb	r3, r3
 80100a8:	491e      	ldr	r1, [pc, #120]	@ (8010124 <AesEncrypt_C+0x93c>)
 80100aa:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80100ae:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80100b2:	405a      	eors	r2, r3
 80100b4:	69fb      	ldr	r3, [r7, #28]
 80100b6:	0a1b      	lsrs	r3, r3, #8
 80100b8:	b2db      	uxtb	r3, r3
 80100ba:	491a      	ldr	r1, [pc, #104]	@ (8010124 <AesEncrypt_C+0x93c>)
 80100bc:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80100c0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80100c4:	405a      	eors	r2, r3
 80100c6:	69bb      	ldr	r3, [r7, #24]
 80100c8:	b2db      	uxtb	r3, r3
 80100ca:	4916      	ldr	r1, [pc, #88]	@ (8010124 <AesEncrypt_C+0x93c>)
 80100cc:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80100d0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80100d4:	405a      	eors	r2, r3
 80100d6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80100d8:	337c      	adds	r3, #124	@ 0x7c
 80100da:	681b      	ldr	r3, [r3, #0]
 80100dc:	4053      	eors	r3, r2
 80100de:	62bb      	str	r3, [r7, #40]	@ 0x28
    ENC_ROUND_S_T(32); ENC_ROUND_T_S(32);
 80100e0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80100e2:	0e1b      	lsrs	r3, r3, #24
 80100e4:	b2db      	uxtb	r3, r3
 80100e6:	461a      	mov	r2, r3
 80100e8:	4b0e      	ldr	r3, [pc, #56]	@ (8010124 <AesEncrypt_C+0x93c>)
 80100ea:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80100ee:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80100f0:	0c1b      	lsrs	r3, r3, #16
 80100f2:	b2db      	uxtb	r3, r3
 80100f4:	490b      	ldr	r1, [pc, #44]	@ (8010124 <AesEncrypt_C+0x93c>)
 80100f6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80100fa:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80100fe:	405a      	eors	r2, r3
 8010100:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010102:	0a1b      	lsrs	r3, r3, #8
 8010104:	b2db      	uxtb	r3, r3
 8010106:	4907      	ldr	r1, [pc, #28]	@ (8010124 <AesEncrypt_C+0x93c>)
 8010108:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801010c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010110:	405a      	eors	r2, r3
 8010112:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010114:	b2db      	uxtb	r3, r3
 8010116:	4903      	ldr	r1, [pc, #12]	@ (8010124 <AesEncrypt_C+0x93c>)
 8010118:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801011c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010120:	405a      	eors	r2, r3
 8010122:	e001      	b.n	8010128 <AesEncrypt_C+0x940>
 8010124:	08031494 	.word	0x08031494
 8010128:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801012a:	3380      	adds	r3, #128	@ 0x80
 801012c:	681b      	ldr	r3, [r3, #0]
 801012e:	4053      	eors	r3, r2
 8010130:	623b      	str	r3, [r7, #32]
 8010132:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010134:	0e1b      	lsrs	r3, r3, #24
 8010136:	b2db      	uxtb	r3, r3
 8010138:	461a      	mov	r2, r3
 801013a:	4bb6      	ldr	r3, [pc, #728]	@ (8010414 <AesEncrypt_C+0xc2c>)
 801013c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010140:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010142:	0c1b      	lsrs	r3, r3, #16
 8010144:	b2db      	uxtb	r3, r3
 8010146:	49b3      	ldr	r1, [pc, #716]	@ (8010414 <AesEncrypt_C+0xc2c>)
 8010148:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801014c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010150:	405a      	eors	r2, r3
 8010152:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010154:	0a1b      	lsrs	r3, r3, #8
 8010156:	b2db      	uxtb	r3, r3
 8010158:	49ae      	ldr	r1, [pc, #696]	@ (8010414 <AesEncrypt_C+0xc2c>)
 801015a:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801015e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010162:	405a      	eors	r2, r3
 8010164:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010166:	b2db      	uxtb	r3, r3
 8010168:	49aa      	ldr	r1, [pc, #680]	@ (8010414 <AesEncrypt_C+0xc2c>)
 801016a:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801016e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010172:	405a      	eors	r2, r3
 8010174:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010176:	3384      	adds	r3, #132	@ 0x84
 8010178:	681b      	ldr	r3, [r3, #0]
 801017a:	4053      	eors	r3, r2
 801017c:	61fb      	str	r3, [r7, #28]
 801017e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010180:	0e1b      	lsrs	r3, r3, #24
 8010182:	b2db      	uxtb	r3, r3
 8010184:	461a      	mov	r2, r3
 8010186:	4ba3      	ldr	r3, [pc, #652]	@ (8010414 <AesEncrypt_C+0xc2c>)
 8010188:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801018c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801018e:	0c1b      	lsrs	r3, r3, #16
 8010190:	b2db      	uxtb	r3, r3
 8010192:	49a0      	ldr	r1, [pc, #640]	@ (8010414 <AesEncrypt_C+0xc2c>)
 8010194:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010198:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801019c:	405a      	eors	r2, r3
 801019e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80101a0:	0a1b      	lsrs	r3, r3, #8
 80101a2:	b2db      	uxtb	r3, r3
 80101a4:	499b      	ldr	r1, [pc, #620]	@ (8010414 <AesEncrypt_C+0xc2c>)
 80101a6:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80101aa:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80101ae:	405a      	eors	r2, r3
 80101b0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80101b2:	b2db      	uxtb	r3, r3
 80101b4:	4997      	ldr	r1, [pc, #604]	@ (8010414 <AesEncrypt_C+0xc2c>)
 80101b6:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80101ba:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80101be:	405a      	eors	r2, r3
 80101c0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80101c2:	3388      	adds	r3, #136	@ 0x88
 80101c4:	681b      	ldr	r3, [r3, #0]
 80101c6:	4053      	eors	r3, r2
 80101c8:	61bb      	str	r3, [r7, #24]
 80101ca:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80101cc:	0e1b      	lsrs	r3, r3, #24
 80101ce:	b2db      	uxtb	r3, r3
 80101d0:	461a      	mov	r2, r3
 80101d2:	4b90      	ldr	r3, [pc, #576]	@ (8010414 <AesEncrypt_C+0xc2c>)
 80101d4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80101d8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80101da:	0c1b      	lsrs	r3, r3, #16
 80101dc:	b2db      	uxtb	r3, r3
 80101de:	498d      	ldr	r1, [pc, #564]	@ (8010414 <AesEncrypt_C+0xc2c>)
 80101e0:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80101e4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80101e8:	405a      	eors	r2, r3
 80101ea:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80101ec:	0a1b      	lsrs	r3, r3, #8
 80101ee:	b2db      	uxtb	r3, r3
 80101f0:	4988      	ldr	r1, [pc, #544]	@ (8010414 <AesEncrypt_C+0xc2c>)
 80101f2:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80101f6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80101fa:	405a      	eors	r2, r3
 80101fc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80101fe:	b2db      	uxtb	r3, r3
 8010200:	4984      	ldr	r1, [pc, #528]	@ (8010414 <AesEncrypt_C+0xc2c>)
 8010202:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010206:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801020a:	405a      	eors	r2, r3
 801020c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801020e:	338c      	adds	r3, #140	@ 0x8c
 8010210:	681b      	ldr	r3, [r3, #0]
 8010212:	4053      	eors	r3, r2
 8010214:	617b      	str	r3, [r7, #20]
 8010216:	6a3b      	ldr	r3, [r7, #32]
 8010218:	0e1b      	lsrs	r3, r3, #24
 801021a:	b2db      	uxtb	r3, r3
 801021c:	461a      	mov	r2, r3
 801021e:	4b7d      	ldr	r3, [pc, #500]	@ (8010414 <AesEncrypt_C+0xc2c>)
 8010220:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010224:	69fb      	ldr	r3, [r7, #28]
 8010226:	0c1b      	lsrs	r3, r3, #16
 8010228:	b2db      	uxtb	r3, r3
 801022a:	497a      	ldr	r1, [pc, #488]	@ (8010414 <AesEncrypt_C+0xc2c>)
 801022c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010230:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010234:	405a      	eors	r2, r3
 8010236:	69bb      	ldr	r3, [r7, #24]
 8010238:	0a1b      	lsrs	r3, r3, #8
 801023a:	b2db      	uxtb	r3, r3
 801023c:	4975      	ldr	r1, [pc, #468]	@ (8010414 <AesEncrypt_C+0xc2c>)
 801023e:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010242:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010246:	405a      	eors	r2, r3
 8010248:	697b      	ldr	r3, [r7, #20]
 801024a:	b2db      	uxtb	r3, r3
 801024c:	4971      	ldr	r1, [pc, #452]	@ (8010414 <AesEncrypt_C+0xc2c>)
 801024e:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010252:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010256:	405a      	eors	r2, r3
 8010258:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801025a:	3390      	adds	r3, #144	@ 0x90
 801025c:	681b      	ldr	r3, [r3, #0]
 801025e:	4053      	eors	r3, r2
 8010260:	637b      	str	r3, [r7, #52]	@ 0x34
 8010262:	69fb      	ldr	r3, [r7, #28]
 8010264:	0e1b      	lsrs	r3, r3, #24
 8010266:	b2db      	uxtb	r3, r3
 8010268:	461a      	mov	r2, r3
 801026a:	4b6a      	ldr	r3, [pc, #424]	@ (8010414 <AesEncrypt_C+0xc2c>)
 801026c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010270:	69bb      	ldr	r3, [r7, #24]
 8010272:	0c1b      	lsrs	r3, r3, #16
 8010274:	b2db      	uxtb	r3, r3
 8010276:	4967      	ldr	r1, [pc, #412]	@ (8010414 <AesEncrypt_C+0xc2c>)
 8010278:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801027c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010280:	405a      	eors	r2, r3
 8010282:	697b      	ldr	r3, [r7, #20]
 8010284:	0a1b      	lsrs	r3, r3, #8
 8010286:	b2db      	uxtb	r3, r3
 8010288:	4962      	ldr	r1, [pc, #392]	@ (8010414 <AesEncrypt_C+0xc2c>)
 801028a:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801028e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010292:	405a      	eors	r2, r3
 8010294:	6a3b      	ldr	r3, [r7, #32]
 8010296:	b2db      	uxtb	r3, r3
 8010298:	495e      	ldr	r1, [pc, #376]	@ (8010414 <AesEncrypt_C+0xc2c>)
 801029a:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801029e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80102a2:	405a      	eors	r2, r3
 80102a4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80102a6:	3394      	adds	r3, #148	@ 0x94
 80102a8:	681b      	ldr	r3, [r3, #0]
 80102aa:	4053      	eors	r3, r2
 80102ac:	633b      	str	r3, [r7, #48]	@ 0x30
 80102ae:	69bb      	ldr	r3, [r7, #24]
 80102b0:	0e1b      	lsrs	r3, r3, #24
 80102b2:	b2db      	uxtb	r3, r3
 80102b4:	461a      	mov	r2, r3
 80102b6:	4b57      	ldr	r3, [pc, #348]	@ (8010414 <AesEncrypt_C+0xc2c>)
 80102b8:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80102bc:	697b      	ldr	r3, [r7, #20]
 80102be:	0c1b      	lsrs	r3, r3, #16
 80102c0:	b2db      	uxtb	r3, r3
 80102c2:	4954      	ldr	r1, [pc, #336]	@ (8010414 <AesEncrypt_C+0xc2c>)
 80102c4:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80102c8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80102cc:	405a      	eors	r2, r3
 80102ce:	6a3b      	ldr	r3, [r7, #32]
 80102d0:	0a1b      	lsrs	r3, r3, #8
 80102d2:	b2db      	uxtb	r3, r3
 80102d4:	494f      	ldr	r1, [pc, #316]	@ (8010414 <AesEncrypt_C+0xc2c>)
 80102d6:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80102da:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80102de:	405a      	eors	r2, r3
 80102e0:	69fb      	ldr	r3, [r7, #28]
 80102e2:	b2db      	uxtb	r3, r3
 80102e4:	494b      	ldr	r1, [pc, #300]	@ (8010414 <AesEncrypt_C+0xc2c>)
 80102e6:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80102ea:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80102ee:	405a      	eors	r2, r3
 80102f0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80102f2:	3398      	adds	r3, #152	@ 0x98
 80102f4:	681b      	ldr	r3, [r3, #0]
 80102f6:	4053      	eors	r3, r2
 80102f8:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80102fa:	697b      	ldr	r3, [r7, #20]
 80102fc:	0e1b      	lsrs	r3, r3, #24
 80102fe:	b2db      	uxtb	r3, r3
 8010300:	461a      	mov	r2, r3
 8010302:	4b44      	ldr	r3, [pc, #272]	@ (8010414 <AesEncrypt_C+0xc2c>)
 8010304:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010308:	6a3b      	ldr	r3, [r7, #32]
 801030a:	0c1b      	lsrs	r3, r3, #16
 801030c:	b2db      	uxtb	r3, r3
 801030e:	4941      	ldr	r1, [pc, #260]	@ (8010414 <AesEncrypt_C+0xc2c>)
 8010310:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010314:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010318:	405a      	eors	r2, r3
 801031a:	69fb      	ldr	r3, [r7, #28]
 801031c:	0a1b      	lsrs	r3, r3, #8
 801031e:	b2db      	uxtb	r3, r3
 8010320:	493c      	ldr	r1, [pc, #240]	@ (8010414 <AesEncrypt_C+0xc2c>)
 8010322:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010326:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801032a:	405a      	eors	r2, r3
 801032c:	69bb      	ldr	r3, [r7, #24]
 801032e:	b2db      	uxtb	r3, r3
 8010330:	4938      	ldr	r1, [pc, #224]	@ (8010414 <AesEncrypt_C+0xc2c>)
 8010332:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010336:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801033a:	405a      	eors	r2, r3
 801033c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801033e:	339c      	adds	r3, #156	@ 0x9c
 8010340:	681b      	ldr	r3, [r3, #0]
 8010342:	4053      	eors	r3, r2
 8010344:	62bb      	str	r3, [r7, #40]	@ 0x28
    if (r > 5) {
 8010346:	683b      	ldr	r3, [r7, #0]
 8010348:	2b05      	cmp	r3, #5
 801034a:	f240 826a 	bls.w	8010822 <AesEncrypt_C+0x103a>
        ENC_ROUND_S_T(40); ENC_ROUND_T_S(40);
 801034e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010350:	0e1b      	lsrs	r3, r3, #24
 8010352:	b2db      	uxtb	r3, r3
 8010354:	461a      	mov	r2, r3
 8010356:	4b2f      	ldr	r3, [pc, #188]	@ (8010414 <AesEncrypt_C+0xc2c>)
 8010358:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801035c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801035e:	0c1b      	lsrs	r3, r3, #16
 8010360:	b2db      	uxtb	r3, r3
 8010362:	492c      	ldr	r1, [pc, #176]	@ (8010414 <AesEncrypt_C+0xc2c>)
 8010364:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010368:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801036c:	405a      	eors	r2, r3
 801036e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010370:	0a1b      	lsrs	r3, r3, #8
 8010372:	b2db      	uxtb	r3, r3
 8010374:	4927      	ldr	r1, [pc, #156]	@ (8010414 <AesEncrypt_C+0xc2c>)
 8010376:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801037a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801037e:	405a      	eors	r2, r3
 8010380:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010382:	b2db      	uxtb	r3, r3
 8010384:	4923      	ldr	r1, [pc, #140]	@ (8010414 <AesEncrypt_C+0xc2c>)
 8010386:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801038a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801038e:	405a      	eors	r2, r3
 8010390:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010392:	33a0      	adds	r3, #160	@ 0xa0
 8010394:	681b      	ldr	r3, [r3, #0]
 8010396:	4053      	eors	r3, r2
 8010398:	623b      	str	r3, [r7, #32]
 801039a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801039c:	0e1b      	lsrs	r3, r3, #24
 801039e:	b2db      	uxtb	r3, r3
 80103a0:	461a      	mov	r2, r3
 80103a2:	4b1c      	ldr	r3, [pc, #112]	@ (8010414 <AesEncrypt_C+0xc2c>)
 80103a4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80103a8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80103aa:	0c1b      	lsrs	r3, r3, #16
 80103ac:	b2db      	uxtb	r3, r3
 80103ae:	4919      	ldr	r1, [pc, #100]	@ (8010414 <AesEncrypt_C+0xc2c>)
 80103b0:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80103b4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80103b8:	405a      	eors	r2, r3
 80103ba:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80103bc:	0a1b      	lsrs	r3, r3, #8
 80103be:	b2db      	uxtb	r3, r3
 80103c0:	4914      	ldr	r1, [pc, #80]	@ (8010414 <AesEncrypt_C+0xc2c>)
 80103c2:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80103c6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80103ca:	405a      	eors	r2, r3
 80103cc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80103ce:	b2db      	uxtb	r3, r3
 80103d0:	4910      	ldr	r1, [pc, #64]	@ (8010414 <AesEncrypt_C+0xc2c>)
 80103d2:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80103d6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80103da:	405a      	eors	r2, r3
 80103dc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80103de:	33a4      	adds	r3, #164	@ 0xa4
 80103e0:	681b      	ldr	r3, [r3, #0]
 80103e2:	4053      	eors	r3, r2
 80103e4:	61fb      	str	r3, [r7, #28]
 80103e6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80103e8:	0e1b      	lsrs	r3, r3, #24
 80103ea:	b2db      	uxtb	r3, r3
 80103ec:	461a      	mov	r2, r3
 80103ee:	4b09      	ldr	r3, [pc, #36]	@ (8010414 <AesEncrypt_C+0xc2c>)
 80103f0:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80103f4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80103f6:	0c1b      	lsrs	r3, r3, #16
 80103f8:	b2db      	uxtb	r3, r3
 80103fa:	4906      	ldr	r1, [pc, #24]	@ (8010414 <AesEncrypt_C+0xc2c>)
 80103fc:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010400:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010404:	405a      	eors	r2, r3
 8010406:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010408:	0a1b      	lsrs	r3, r3, #8
 801040a:	b2db      	uxtb	r3, r3
 801040c:	4901      	ldr	r1, [pc, #4]	@ (8010414 <AesEncrypt_C+0xc2c>)
 801040e:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010412:	e001      	b.n	8010418 <AesEncrypt_C+0xc30>
 8010414:	08031494 	.word	0x08031494
 8010418:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801041c:	405a      	eors	r2, r3
 801041e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010420:	b2db      	uxtb	r3, r3
 8010422:	49b6      	ldr	r1, [pc, #728]	@ (80106fc <AesEncrypt_C+0xf14>)
 8010424:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010428:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801042c:	405a      	eors	r2, r3
 801042e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010430:	33a8      	adds	r3, #168	@ 0xa8
 8010432:	681b      	ldr	r3, [r3, #0]
 8010434:	4053      	eors	r3, r2
 8010436:	61bb      	str	r3, [r7, #24]
 8010438:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801043a:	0e1b      	lsrs	r3, r3, #24
 801043c:	b2db      	uxtb	r3, r3
 801043e:	461a      	mov	r2, r3
 8010440:	4bae      	ldr	r3, [pc, #696]	@ (80106fc <AesEncrypt_C+0xf14>)
 8010442:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010446:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010448:	0c1b      	lsrs	r3, r3, #16
 801044a:	b2db      	uxtb	r3, r3
 801044c:	49ab      	ldr	r1, [pc, #684]	@ (80106fc <AesEncrypt_C+0xf14>)
 801044e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010452:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010456:	405a      	eors	r2, r3
 8010458:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801045a:	0a1b      	lsrs	r3, r3, #8
 801045c:	b2db      	uxtb	r3, r3
 801045e:	49a7      	ldr	r1, [pc, #668]	@ (80106fc <AesEncrypt_C+0xf14>)
 8010460:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010464:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010468:	405a      	eors	r2, r3
 801046a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801046c:	b2db      	uxtb	r3, r3
 801046e:	49a3      	ldr	r1, [pc, #652]	@ (80106fc <AesEncrypt_C+0xf14>)
 8010470:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010474:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010478:	405a      	eors	r2, r3
 801047a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801047c:	33ac      	adds	r3, #172	@ 0xac
 801047e:	681b      	ldr	r3, [r3, #0]
 8010480:	4053      	eors	r3, r2
 8010482:	617b      	str	r3, [r7, #20]
 8010484:	6a3b      	ldr	r3, [r7, #32]
 8010486:	0e1b      	lsrs	r3, r3, #24
 8010488:	b2db      	uxtb	r3, r3
 801048a:	461a      	mov	r2, r3
 801048c:	4b9b      	ldr	r3, [pc, #620]	@ (80106fc <AesEncrypt_C+0xf14>)
 801048e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010492:	69fb      	ldr	r3, [r7, #28]
 8010494:	0c1b      	lsrs	r3, r3, #16
 8010496:	b2db      	uxtb	r3, r3
 8010498:	4998      	ldr	r1, [pc, #608]	@ (80106fc <AesEncrypt_C+0xf14>)
 801049a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801049e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80104a2:	405a      	eors	r2, r3
 80104a4:	69bb      	ldr	r3, [r7, #24]
 80104a6:	0a1b      	lsrs	r3, r3, #8
 80104a8:	b2db      	uxtb	r3, r3
 80104aa:	4994      	ldr	r1, [pc, #592]	@ (80106fc <AesEncrypt_C+0xf14>)
 80104ac:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80104b0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80104b4:	405a      	eors	r2, r3
 80104b6:	697b      	ldr	r3, [r7, #20]
 80104b8:	b2db      	uxtb	r3, r3
 80104ba:	4990      	ldr	r1, [pc, #576]	@ (80106fc <AesEncrypt_C+0xf14>)
 80104bc:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80104c0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80104c4:	405a      	eors	r2, r3
 80104c6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80104c8:	33b0      	adds	r3, #176	@ 0xb0
 80104ca:	681b      	ldr	r3, [r3, #0]
 80104cc:	4053      	eors	r3, r2
 80104ce:	637b      	str	r3, [r7, #52]	@ 0x34
 80104d0:	69fb      	ldr	r3, [r7, #28]
 80104d2:	0e1b      	lsrs	r3, r3, #24
 80104d4:	b2db      	uxtb	r3, r3
 80104d6:	461a      	mov	r2, r3
 80104d8:	4b88      	ldr	r3, [pc, #544]	@ (80106fc <AesEncrypt_C+0xf14>)
 80104da:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80104de:	69bb      	ldr	r3, [r7, #24]
 80104e0:	0c1b      	lsrs	r3, r3, #16
 80104e2:	b2db      	uxtb	r3, r3
 80104e4:	4985      	ldr	r1, [pc, #532]	@ (80106fc <AesEncrypt_C+0xf14>)
 80104e6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80104ea:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80104ee:	405a      	eors	r2, r3
 80104f0:	697b      	ldr	r3, [r7, #20]
 80104f2:	0a1b      	lsrs	r3, r3, #8
 80104f4:	b2db      	uxtb	r3, r3
 80104f6:	4981      	ldr	r1, [pc, #516]	@ (80106fc <AesEncrypt_C+0xf14>)
 80104f8:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80104fc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010500:	405a      	eors	r2, r3
 8010502:	6a3b      	ldr	r3, [r7, #32]
 8010504:	b2db      	uxtb	r3, r3
 8010506:	497d      	ldr	r1, [pc, #500]	@ (80106fc <AesEncrypt_C+0xf14>)
 8010508:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801050c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010510:	405a      	eors	r2, r3
 8010512:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010514:	33b4      	adds	r3, #180	@ 0xb4
 8010516:	681b      	ldr	r3, [r3, #0]
 8010518:	4053      	eors	r3, r2
 801051a:	633b      	str	r3, [r7, #48]	@ 0x30
 801051c:	69bb      	ldr	r3, [r7, #24]
 801051e:	0e1b      	lsrs	r3, r3, #24
 8010520:	b2db      	uxtb	r3, r3
 8010522:	461a      	mov	r2, r3
 8010524:	4b75      	ldr	r3, [pc, #468]	@ (80106fc <AesEncrypt_C+0xf14>)
 8010526:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801052a:	697b      	ldr	r3, [r7, #20]
 801052c:	0c1b      	lsrs	r3, r3, #16
 801052e:	b2db      	uxtb	r3, r3
 8010530:	4972      	ldr	r1, [pc, #456]	@ (80106fc <AesEncrypt_C+0xf14>)
 8010532:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010536:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801053a:	405a      	eors	r2, r3
 801053c:	6a3b      	ldr	r3, [r7, #32]
 801053e:	0a1b      	lsrs	r3, r3, #8
 8010540:	b2db      	uxtb	r3, r3
 8010542:	496e      	ldr	r1, [pc, #440]	@ (80106fc <AesEncrypt_C+0xf14>)
 8010544:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010548:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801054c:	405a      	eors	r2, r3
 801054e:	69fb      	ldr	r3, [r7, #28]
 8010550:	b2db      	uxtb	r3, r3
 8010552:	496a      	ldr	r1, [pc, #424]	@ (80106fc <AesEncrypt_C+0xf14>)
 8010554:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010558:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801055c:	405a      	eors	r2, r3
 801055e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010560:	33b8      	adds	r3, #184	@ 0xb8
 8010562:	681b      	ldr	r3, [r3, #0]
 8010564:	4053      	eors	r3, r2
 8010566:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8010568:	697b      	ldr	r3, [r7, #20]
 801056a:	0e1b      	lsrs	r3, r3, #24
 801056c:	b2db      	uxtb	r3, r3
 801056e:	461a      	mov	r2, r3
 8010570:	4b62      	ldr	r3, [pc, #392]	@ (80106fc <AesEncrypt_C+0xf14>)
 8010572:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010576:	6a3b      	ldr	r3, [r7, #32]
 8010578:	0c1b      	lsrs	r3, r3, #16
 801057a:	b2db      	uxtb	r3, r3
 801057c:	495f      	ldr	r1, [pc, #380]	@ (80106fc <AesEncrypt_C+0xf14>)
 801057e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010582:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010586:	405a      	eors	r2, r3
 8010588:	69fb      	ldr	r3, [r7, #28]
 801058a:	0a1b      	lsrs	r3, r3, #8
 801058c:	b2db      	uxtb	r3, r3
 801058e:	495b      	ldr	r1, [pc, #364]	@ (80106fc <AesEncrypt_C+0xf14>)
 8010590:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010594:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010598:	405a      	eors	r2, r3
 801059a:	69bb      	ldr	r3, [r7, #24]
 801059c:	b2db      	uxtb	r3, r3
 801059e:	4957      	ldr	r1, [pc, #348]	@ (80106fc <AesEncrypt_C+0xf14>)
 80105a0:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80105a4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80105a8:	405a      	eors	r2, r3
 80105aa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80105ac:	33bc      	adds	r3, #188	@ 0xbc
 80105ae:	681b      	ldr	r3, [r3, #0]
 80105b0:	4053      	eors	r3, r2
 80105b2:	62bb      	str	r3, [r7, #40]	@ 0x28
        if (r > 6) {
 80105b4:	683b      	ldr	r3, [r7, #0]
 80105b6:	2b06      	cmp	r3, #6
 80105b8:	f240 8133 	bls.w	8010822 <AesEncrypt_C+0x103a>
            ENC_ROUND_S_T(48); ENC_ROUND_T_S(48);
 80105bc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80105be:	0e1b      	lsrs	r3, r3, #24
 80105c0:	b2db      	uxtb	r3, r3
 80105c2:	461a      	mov	r2, r3
 80105c4:	4b4d      	ldr	r3, [pc, #308]	@ (80106fc <AesEncrypt_C+0xf14>)
 80105c6:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80105ca:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80105cc:	0c1b      	lsrs	r3, r3, #16
 80105ce:	b2db      	uxtb	r3, r3
 80105d0:	494a      	ldr	r1, [pc, #296]	@ (80106fc <AesEncrypt_C+0xf14>)
 80105d2:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80105d6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80105da:	405a      	eors	r2, r3
 80105dc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80105de:	0a1b      	lsrs	r3, r3, #8
 80105e0:	b2db      	uxtb	r3, r3
 80105e2:	4946      	ldr	r1, [pc, #280]	@ (80106fc <AesEncrypt_C+0xf14>)
 80105e4:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80105e8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80105ec:	405a      	eors	r2, r3
 80105ee:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80105f0:	b2db      	uxtb	r3, r3
 80105f2:	4942      	ldr	r1, [pc, #264]	@ (80106fc <AesEncrypt_C+0xf14>)
 80105f4:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80105f8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80105fc:	405a      	eors	r2, r3
 80105fe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010600:	33c0      	adds	r3, #192	@ 0xc0
 8010602:	681b      	ldr	r3, [r3, #0]
 8010604:	4053      	eors	r3, r2
 8010606:	623b      	str	r3, [r7, #32]
 8010608:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801060a:	0e1b      	lsrs	r3, r3, #24
 801060c:	b2db      	uxtb	r3, r3
 801060e:	461a      	mov	r2, r3
 8010610:	4b3a      	ldr	r3, [pc, #232]	@ (80106fc <AesEncrypt_C+0xf14>)
 8010612:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010616:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010618:	0c1b      	lsrs	r3, r3, #16
 801061a:	b2db      	uxtb	r3, r3
 801061c:	4937      	ldr	r1, [pc, #220]	@ (80106fc <AesEncrypt_C+0xf14>)
 801061e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010622:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010626:	405a      	eors	r2, r3
 8010628:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801062a:	0a1b      	lsrs	r3, r3, #8
 801062c:	b2db      	uxtb	r3, r3
 801062e:	4933      	ldr	r1, [pc, #204]	@ (80106fc <AesEncrypt_C+0xf14>)
 8010630:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010634:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010638:	405a      	eors	r2, r3
 801063a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801063c:	b2db      	uxtb	r3, r3
 801063e:	492f      	ldr	r1, [pc, #188]	@ (80106fc <AesEncrypt_C+0xf14>)
 8010640:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010644:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010648:	405a      	eors	r2, r3
 801064a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801064c:	33c4      	adds	r3, #196	@ 0xc4
 801064e:	681b      	ldr	r3, [r3, #0]
 8010650:	4053      	eors	r3, r2
 8010652:	61fb      	str	r3, [r7, #28]
 8010654:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010656:	0e1b      	lsrs	r3, r3, #24
 8010658:	b2db      	uxtb	r3, r3
 801065a:	461a      	mov	r2, r3
 801065c:	4b27      	ldr	r3, [pc, #156]	@ (80106fc <AesEncrypt_C+0xf14>)
 801065e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010662:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010664:	0c1b      	lsrs	r3, r3, #16
 8010666:	b2db      	uxtb	r3, r3
 8010668:	4924      	ldr	r1, [pc, #144]	@ (80106fc <AesEncrypt_C+0xf14>)
 801066a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801066e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010672:	405a      	eors	r2, r3
 8010674:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010676:	0a1b      	lsrs	r3, r3, #8
 8010678:	b2db      	uxtb	r3, r3
 801067a:	4920      	ldr	r1, [pc, #128]	@ (80106fc <AesEncrypt_C+0xf14>)
 801067c:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010680:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010684:	405a      	eors	r2, r3
 8010686:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010688:	b2db      	uxtb	r3, r3
 801068a:	491c      	ldr	r1, [pc, #112]	@ (80106fc <AesEncrypt_C+0xf14>)
 801068c:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010690:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010694:	405a      	eors	r2, r3
 8010696:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010698:	33c8      	adds	r3, #200	@ 0xc8
 801069a:	681b      	ldr	r3, [r3, #0]
 801069c:	4053      	eors	r3, r2
 801069e:	61bb      	str	r3, [r7, #24]
 80106a0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80106a2:	0e1b      	lsrs	r3, r3, #24
 80106a4:	b2db      	uxtb	r3, r3
 80106a6:	461a      	mov	r2, r3
 80106a8:	4b14      	ldr	r3, [pc, #80]	@ (80106fc <AesEncrypt_C+0xf14>)
 80106aa:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80106ae:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80106b0:	0c1b      	lsrs	r3, r3, #16
 80106b2:	b2db      	uxtb	r3, r3
 80106b4:	4911      	ldr	r1, [pc, #68]	@ (80106fc <AesEncrypt_C+0xf14>)
 80106b6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80106ba:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80106be:	405a      	eors	r2, r3
 80106c0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80106c2:	0a1b      	lsrs	r3, r3, #8
 80106c4:	b2db      	uxtb	r3, r3
 80106c6:	490d      	ldr	r1, [pc, #52]	@ (80106fc <AesEncrypt_C+0xf14>)
 80106c8:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80106cc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80106d0:	405a      	eors	r2, r3
 80106d2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80106d4:	b2db      	uxtb	r3, r3
 80106d6:	4909      	ldr	r1, [pc, #36]	@ (80106fc <AesEncrypt_C+0xf14>)
 80106d8:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80106dc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80106e0:	405a      	eors	r2, r3
 80106e2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80106e4:	33cc      	adds	r3, #204	@ 0xcc
 80106e6:	681b      	ldr	r3, [r3, #0]
 80106e8:	4053      	eors	r3, r2
 80106ea:	617b      	str	r3, [r7, #20]
 80106ec:	6a3b      	ldr	r3, [r7, #32]
 80106ee:	0e1b      	lsrs	r3, r3, #24
 80106f0:	b2db      	uxtb	r3, r3
 80106f2:	461a      	mov	r2, r3
 80106f4:	4b01      	ldr	r3, [pc, #4]	@ (80106fc <AesEncrypt_C+0xf14>)
 80106f6:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80106fa:	e001      	b.n	8010700 <AesEncrypt_C+0xf18>
 80106fc:	08031494 	.word	0x08031494
 8010700:	69fb      	ldr	r3, [r7, #28]
 8010702:	0c1b      	lsrs	r3, r3, #16
 8010704:	b2db      	uxtb	r3, r3
 8010706:	49b8      	ldr	r1, [pc, #736]	@ (80109e8 <AesEncrypt_C+0x1200>)
 8010708:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801070c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010710:	405a      	eors	r2, r3
 8010712:	69bb      	ldr	r3, [r7, #24]
 8010714:	0a1b      	lsrs	r3, r3, #8
 8010716:	b2db      	uxtb	r3, r3
 8010718:	49b3      	ldr	r1, [pc, #716]	@ (80109e8 <AesEncrypt_C+0x1200>)
 801071a:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801071e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010722:	405a      	eors	r2, r3
 8010724:	697b      	ldr	r3, [r7, #20]
 8010726:	b2db      	uxtb	r3, r3
 8010728:	49af      	ldr	r1, [pc, #700]	@ (80109e8 <AesEncrypt_C+0x1200>)
 801072a:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801072e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010732:	405a      	eors	r2, r3
 8010734:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010736:	33d0      	adds	r3, #208	@ 0xd0
 8010738:	681b      	ldr	r3, [r3, #0]
 801073a:	4053      	eors	r3, r2
 801073c:	637b      	str	r3, [r7, #52]	@ 0x34
 801073e:	69fb      	ldr	r3, [r7, #28]
 8010740:	0e1b      	lsrs	r3, r3, #24
 8010742:	b2db      	uxtb	r3, r3
 8010744:	461a      	mov	r2, r3
 8010746:	4ba8      	ldr	r3, [pc, #672]	@ (80109e8 <AesEncrypt_C+0x1200>)
 8010748:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801074c:	69bb      	ldr	r3, [r7, #24]
 801074e:	0c1b      	lsrs	r3, r3, #16
 8010750:	b2db      	uxtb	r3, r3
 8010752:	49a5      	ldr	r1, [pc, #660]	@ (80109e8 <AesEncrypt_C+0x1200>)
 8010754:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010758:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801075c:	405a      	eors	r2, r3
 801075e:	697b      	ldr	r3, [r7, #20]
 8010760:	0a1b      	lsrs	r3, r3, #8
 8010762:	b2db      	uxtb	r3, r3
 8010764:	49a0      	ldr	r1, [pc, #640]	@ (80109e8 <AesEncrypt_C+0x1200>)
 8010766:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801076a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801076e:	405a      	eors	r2, r3
 8010770:	6a3b      	ldr	r3, [r7, #32]
 8010772:	b2db      	uxtb	r3, r3
 8010774:	499c      	ldr	r1, [pc, #624]	@ (80109e8 <AesEncrypt_C+0x1200>)
 8010776:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801077a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801077e:	405a      	eors	r2, r3
 8010780:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010782:	33d4      	adds	r3, #212	@ 0xd4
 8010784:	681b      	ldr	r3, [r3, #0]
 8010786:	4053      	eors	r3, r2
 8010788:	633b      	str	r3, [r7, #48]	@ 0x30
 801078a:	69bb      	ldr	r3, [r7, #24]
 801078c:	0e1b      	lsrs	r3, r3, #24
 801078e:	b2db      	uxtb	r3, r3
 8010790:	461a      	mov	r2, r3
 8010792:	4b95      	ldr	r3, [pc, #596]	@ (80109e8 <AesEncrypt_C+0x1200>)
 8010794:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010798:	697b      	ldr	r3, [r7, #20]
 801079a:	0c1b      	lsrs	r3, r3, #16
 801079c:	b2db      	uxtb	r3, r3
 801079e:	4992      	ldr	r1, [pc, #584]	@ (80109e8 <AesEncrypt_C+0x1200>)
 80107a0:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80107a4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80107a8:	405a      	eors	r2, r3
 80107aa:	6a3b      	ldr	r3, [r7, #32]
 80107ac:	0a1b      	lsrs	r3, r3, #8
 80107ae:	b2db      	uxtb	r3, r3
 80107b0:	498d      	ldr	r1, [pc, #564]	@ (80109e8 <AesEncrypt_C+0x1200>)
 80107b2:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80107b6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80107ba:	405a      	eors	r2, r3
 80107bc:	69fb      	ldr	r3, [r7, #28]
 80107be:	b2db      	uxtb	r3, r3
 80107c0:	4989      	ldr	r1, [pc, #548]	@ (80109e8 <AesEncrypt_C+0x1200>)
 80107c2:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80107c6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80107ca:	405a      	eors	r2, r3
 80107cc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80107ce:	33d8      	adds	r3, #216	@ 0xd8
 80107d0:	681b      	ldr	r3, [r3, #0]
 80107d2:	4053      	eors	r3, r2
 80107d4:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80107d6:	697b      	ldr	r3, [r7, #20]
 80107d8:	0e1b      	lsrs	r3, r3, #24
 80107da:	b2db      	uxtb	r3, r3
 80107dc:	461a      	mov	r2, r3
 80107de:	4b82      	ldr	r3, [pc, #520]	@ (80109e8 <AesEncrypt_C+0x1200>)
 80107e0:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80107e4:	6a3b      	ldr	r3, [r7, #32]
 80107e6:	0c1b      	lsrs	r3, r3, #16
 80107e8:	b2db      	uxtb	r3, r3
 80107ea:	497f      	ldr	r1, [pc, #508]	@ (80109e8 <AesEncrypt_C+0x1200>)
 80107ec:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80107f0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80107f4:	405a      	eors	r2, r3
 80107f6:	69fb      	ldr	r3, [r7, #28]
 80107f8:	0a1b      	lsrs	r3, r3, #8
 80107fa:	b2db      	uxtb	r3, r3
 80107fc:	497a      	ldr	r1, [pc, #488]	@ (80109e8 <AesEncrypt_C+0x1200>)
 80107fe:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010802:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010806:	405a      	eors	r2, r3
 8010808:	69bb      	ldr	r3, [r7, #24]
 801080a:	b2db      	uxtb	r3, r3
 801080c:	4976      	ldr	r1, [pc, #472]	@ (80109e8 <AesEncrypt_C+0x1200>)
 801080e:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010812:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010816:	405a      	eors	r2, r3
 8010818:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801081a:	33dc      	adds	r3, #220	@ 0xdc
 801081c:	681b      	ldr	r3, [r3, #0]
 801081e:	4053      	eors	r3, r2
 8010820:	62bb      	str	r3, [r7, #40]	@ 0x28
        }
    }
    rk += r * 8;
 8010822:	683b      	ldr	r3, [r7, #0]
 8010824:	015b      	lsls	r3, r3, #5
 8010826:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8010828:	4413      	add	r3, r2
 801082a:	627b      	str	r3, [r7, #36]	@ 0x24
     * map cipher state to byte array block:
     */

#ifndef WOLFSSL_AES_TOUCH_LINES
    s0 =
        (GetTable(Te[2], GETBYTE(t0, 3)) & 0xff000000) ^
 801082c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801082e:	0e1b      	lsrs	r3, r3, #24
 8010830:	b2db      	uxtb	r3, r3
 8010832:	4a6d      	ldr	r2, [pc, #436]	@ (80109e8 <AesEncrypt_C+0x1200>)
 8010834:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010838:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801083c:	f003 427f 	and.w	r2, r3, #4278190080	@ 0xff000000
        (GetTable(Te[3], GETBYTE(t1, 2)) & 0x00ff0000) ^
 8010840:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010842:	0c1b      	lsrs	r3, r3, #16
 8010844:	b2db      	uxtb	r3, r3
 8010846:	4968      	ldr	r1, [pc, #416]	@ (80109e8 <AesEncrypt_C+0x1200>)
 8010848:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801084c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010850:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
        (GetTable(Te[2], GETBYTE(t0, 3)) & 0xff000000) ^
 8010854:	431a      	orrs	r2, r3
        (GetTable(Te[0], GETBYTE(t2, 1)) & 0x0000ff00) ^
 8010856:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010858:	0a1b      	lsrs	r3, r3, #8
 801085a:	b2db      	uxtb	r3, r3
 801085c:	4619      	mov	r1, r3
 801085e:	4b62      	ldr	r3, [pc, #392]	@ (80109e8 <AesEncrypt_C+0x1200>)
 8010860:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8010864:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
        (GetTable(Te[3], GETBYTE(t1, 2)) & 0x00ff0000) ^
 8010868:	405a      	eors	r2, r3
        (GetTable(Te[1], GETBYTE(t3, 0)) & 0x000000ff) ^
 801086a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801086c:	b2db      	uxtb	r3, r3
 801086e:	495e      	ldr	r1, [pc, #376]	@ (80109e8 <AesEncrypt_C+0x1200>)
 8010870:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010874:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010878:	b2db      	uxtb	r3, r3
        (GetTable(Te[0], GETBYTE(t2, 1)) & 0x0000ff00) ^
 801087a:	405a      	eors	r2, r3
        rk[0];
 801087c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801087e:	681b      	ldr	r3, [r3, #0]
        (GetTable(Te[1], GETBYTE(t3, 0)) & 0x000000ff) ^
 8010880:	4053      	eors	r3, r2
    s0 =
 8010882:	623b      	str	r3, [r7, #32]
    s1 =
        (GetTable(Te[2], GETBYTE(t1, 3)) & 0xff000000) ^
 8010884:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010886:	0e1b      	lsrs	r3, r3, #24
 8010888:	b2db      	uxtb	r3, r3
 801088a:	4a57      	ldr	r2, [pc, #348]	@ (80109e8 <AesEncrypt_C+0x1200>)
 801088c:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010890:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8010894:	f003 427f 	and.w	r2, r3, #4278190080	@ 0xff000000
        (GetTable(Te[3], GETBYTE(t2, 2)) & 0x00ff0000) ^
 8010898:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801089a:	0c1b      	lsrs	r3, r3, #16
 801089c:	b2db      	uxtb	r3, r3
 801089e:	4952      	ldr	r1, [pc, #328]	@ (80109e8 <AesEncrypt_C+0x1200>)
 80108a0:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80108a4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80108a8:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
        (GetTable(Te[2], GETBYTE(t1, 3)) & 0xff000000) ^
 80108ac:	431a      	orrs	r2, r3
        (GetTable(Te[0], GETBYTE(t3, 1)) & 0x0000ff00) ^
 80108ae:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80108b0:	0a1b      	lsrs	r3, r3, #8
 80108b2:	b2db      	uxtb	r3, r3
 80108b4:	4619      	mov	r1, r3
 80108b6:	4b4c      	ldr	r3, [pc, #304]	@ (80109e8 <AesEncrypt_C+0x1200>)
 80108b8:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 80108bc:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
        (GetTable(Te[3], GETBYTE(t2, 2)) & 0x00ff0000) ^
 80108c0:	405a      	eors	r2, r3
        (GetTable(Te[1], GETBYTE(t0, 0)) & 0x000000ff) ^
 80108c2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80108c4:	b2db      	uxtb	r3, r3
 80108c6:	4948      	ldr	r1, [pc, #288]	@ (80109e8 <AesEncrypt_C+0x1200>)
 80108c8:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80108cc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80108d0:	b2db      	uxtb	r3, r3
        (GetTable(Te[0], GETBYTE(t3, 1)) & 0x0000ff00) ^
 80108d2:	405a      	eors	r2, r3
        rk[1];
 80108d4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80108d6:	3304      	adds	r3, #4
 80108d8:	681b      	ldr	r3, [r3, #0]
        (GetTable(Te[1], GETBYTE(t0, 0)) & 0x000000ff) ^
 80108da:	4053      	eors	r3, r2
    s1 =
 80108dc:	61fb      	str	r3, [r7, #28]
    s2 =
        (GetTable(Te[2], GETBYTE(t2, 3)) & 0xff000000) ^
 80108de:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80108e0:	0e1b      	lsrs	r3, r3, #24
 80108e2:	b2db      	uxtb	r3, r3
 80108e4:	4a40      	ldr	r2, [pc, #256]	@ (80109e8 <AesEncrypt_C+0x1200>)
 80108e6:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80108ea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80108ee:	f003 427f 	and.w	r2, r3, #4278190080	@ 0xff000000
        (GetTable(Te[3], GETBYTE(t3, 2)) & 0x00ff0000) ^
 80108f2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80108f4:	0c1b      	lsrs	r3, r3, #16
 80108f6:	b2db      	uxtb	r3, r3
 80108f8:	493b      	ldr	r1, [pc, #236]	@ (80109e8 <AesEncrypt_C+0x1200>)
 80108fa:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80108fe:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010902:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
        (GetTable(Te[2], GETBYTE(t2, 3)) & 0xff000000) ^
 8010906:	431a      	orrs	r2, r3
        (GetTable(Te[0], GETBYTE(t0, 1)) & 0x0000ff00) ^
 8010908:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801090a:	0a1b      	lsrs	r3, r3, #8
 801090c:	b2db      	uxtb	r3, r3
 801090e:	4619      	mov	r1, r3
 8010910:	4b35      	ldr	r3, [pc, #212]	@ (80109e8 <AesEncrypt_C+0x1200>)
 8010912:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8010916:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
        (GetTable(Te[3], GETBYTE(t3, 2)) & 0x00ff0000) ^
 801091a:	405a      	eors	r2, r3
        (GetTable(Te[1], GETBYTE(t1, 0)) & 0x000000ff) ^
 801091c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801091e:	b2db      	uxtb	r3, r3
 8010920:	4931      	ldr	r1, [pc, #196]	@ (80109e8 <AesEncrypt_C+0x1200>)
 8010922:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010926:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801092a:	b2db      	uxtb	r3, r3
        (GetTable(Te[0], GETBYTE(t0, 1)) & 0x0000ff00) ^
 801092c:	405a      	eors	r2, r3
        rk[2];
 801092e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010930:	3308      	adds	r3, #8
 8010932:	681b      	ldr	r3, [r3, #0]
        (GetTable(Te[1], GETBYTE(t1, 0)) & 0x000000ff) ^
 8010934:	4053      	eors	r3, r2
    s2 =
 8010936:	61bb      	str	r3, [r7, #24]
    s3 =
        (GetTable(Te[2], GETBYTE(t3, 3)) & 0xff000000) ^
 8010938:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801093a:	0e1b      	lsrs	r3, r3, #24
 801093c:	b2db      	uxtb	r3, r3
 801093e:	4a2a      	ldr	r2, [pc, #168]	@ (80109e8 <AesEncrypt_C+0x1200>)
 8010940:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010944:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8010948:	f003 427f 	and.w	r2, r3, #4278190080	@ 0xff000000
        (GetTable(Te[3], GETBYTE(t0, 2)) & 0x00ff0000) ^
 801094c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801094e:	0c1b      	lsrs	r3, r3, #16
 8010950:	b2db      	uxtb	r3, r3
 8010952:	4925      	ldr	r1, [pc, #148]	@ (80109e8 <AesEncrypt_C+0x1200>)
 8010954:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010958:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801095c:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
        (GetTable(Te[2], GETBYTE(t3, 3)) & 0xff000000) ^
 8010960:	431a      	orrs	r2, r3
        (GetTable(Te[0], GETBYTE(t1, 1)) & 0x0000ff00) ^
 8010962:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010964:	0a1b      	lsrs	r3, r3, #8
 8010966:	b2db      	uxtb	r3, r3
 8010968:	4619      	mov	r1, r3
 801096a:	4b1f      	ldr	r3, [pc, #124]	@ (80109e8 <AesEncrypt_C+0x1200>)
 801096c:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8010970:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
        (GetTable(Te[3], GETBYTE(t0, 2)) & 0x00ff0000) ^
 8010974:	405a      	eors	r2, r3
        (GetTable(Te[1], GETBYTE(t2, 0)) & 0x000000ff) ^
 8010976:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010978:	b2db      	uxtb	r3, r3
 801097a:	491b      	ldr	r1, [pc, #108]	@ (80109e8 <AesEncrypt_C+0x1200>)
 801097c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010980:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010984:	b2db      	uxtb	r3, r3
        (GetTable(Te[0], GETBYTE(t1, 1)) & 0x0000ff00) ^
 8010986:	405a      	eors	r2, r3
        rk[3];
 8010988:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801098a:	330c      	adds	r3, #12
 801098c:	681b      	ldr	r3, [r3, #0]
        (GetTable(Te[1], GETBYTE(t2, 0)) & 0x000000ff) ^
 801098e:	4053      	eors	r3, r2
    s3 =
 8010990:	617b      	str	r3, [r7, #20]
    s3 = t3 ^ rk[3];
#endif

    /* write out */
#ifdef LITTLE_ENDIAN_ORDER
    s0 = ByteReverseWord32(s0);
 8010992:	6a3b      	ldr	r3, [r7, #32]
 8010994:	4618      	mov	r0, r3
 8010996:	f7fe fe28 	bl	800f5ea <ByteReverseWord32>
 801099a:	4603      	mov	r3, r0
 801099c:	623b      	str	r3, [r7, #32]
    s1 = ByteReverseWord32(s1);
 801099e:	69fb      	ldr	r3, [r7, #28]
 80109a0:	4618      	mov	r0, r3
 80109a2:	f7fe fe22 	bl	800f5ea <ByteReverseWord32>
 80109a6:	4603      	mov	r3, r0
 80109a8:	61fb      	str	r3, [r7, #28]
    s2 = ByteReverseWord32(s2);
 80109aa:	69bb      	ldr	r3, [r7, #24]
 80109ac:	4618      	mov	r0, r3
 80109ae:	f7fe fe1c 	bl	800f5ea <ByteReverseWord32>
 80109b2:	4603      	mov	r3, r0
 80109b4:	61bb      	str	r3, [r7, #24]
    s3 = ByteReverseWord32(s3);
 80109b6:	697b      	ldr	r3, [r7, #20]
 80109b8:	4618      	mov	r0, r3
 80109ba:	f7fe fe16 	bl	800f5ea <ByteReverseWord32>
 80109be:	4603      	mov	r3, r0
 80109c0:	617b      	str	r3, [r7, #20]
#endif

    XMEMCPY(outBlock,                  &s0, sizeof(s0));
 80109c2:	6a3a      	ldr	r2, [r7, #32]
 80109c4:	687b      	ldr	r3, [r7, #4]
 80109c6:	601a      	str	r2, [r3, #0]
    XMEMCPY(outBlock +     sizeof(s0), &s1, sizeof(s1));
 80109c8:	687b      	ldr	r3, [r7, #4]
 80109ca:	3304      	adds	r3, #4
 80109cc:	69fa      	ldr	r2, [r7, #28]
 80109ce:	601a      	str	r2, [r3, #0]
    XMEMCPY(outBlock + 2 * sizeof(s0), &s2, sizeof(s2));
 80109d0:	687b      	ldr	r3, [r7, #4]
 80109d2:	3308      	adds	r3, #8
 80109d4:	69ba      	ldr	r2, [r7, #24]
 80109d6:	601a      	str	r2, [r3, #0]
    XMEMCPY(outBlock + 3 * sizeof(s0), &s3, sizeof(s3));
 80109d8:	687b      	ldr	r3, [r7, #4]
 80109da:	330c      	adds	r3, #12
 80109dc:	697a      	ldr	r2, [r7, #20]
 80109de:	601a      	str	r2, [r3, #0]
}
 80109e0:	bf00      	nop
 80109e2:	3738      	adds	r7, #56	@ 0x38
 80109e4:	46bd      	mov	sp, r7
 80109e6:	bd80      	pop	{r7, pc}
 80109e8:	08031494 	.word	0x08031494

080109ec <wc_AesEncrypt>:

/* this section disabled with NO_AES_192 */
/* calling this one when missing NO_AES_192  */
static WARN_UNUSED_RESULT int wc_AesEncrypt(
    Aes* aes, const byte* inBlock, byte* outBlock)
{
 80109ec:	b580      	push	{r7, lr}
 80109ee:	b086      	sub	sp, #24
 80109f0:	af00      	add	r7, sp, #0
 80109f2:	60f8      	str	r0, [r7, #12]
 80109f4:	60b9      	str	r1, [r7, #8]
 80109f6:	607a      	str	r2, [r7, #4]
#if defined(MAX3266X_CB)
    int ret_cb;
#endif
    word32 r;

    if (aes == NULL) {
 80109f8:	68fb      	ldr	r3, [r7, #12]
 80109fa:	2b00      	cmp	r3, #0
 80109fc:	d102      	bne.n	8010a04 <wc_AesEncrypt+0x18>
        return BAD_FUNC_ARG;
 80109fe:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8010a02:	e014      	b.n	8010a2e <wc_AesEncrypt+0x42>
        if (ret < 0)
            return ret;
    }
#endif

    r = aes->rounds >> 1;
 8010a04:	68fb      	ldr	r3, [r7, #12]
 8010a06:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8010a0a:	085b      	lsrs	r3, r3, #1
 8010a0c:	617b      	str	r3, [r7, #20]

    if (r > 7 || r == 0) {
 8010a0e:	697b      	ldr	r3, [r7, #20]
 8010a10:	2b07      	cmp	r3, #7
 8010a12:	d802      	bhi.n	8010a1a <wc_AesEncrypt+0x2e>
 8010a14:	697b      	ldr	r3, [r7, #20]
 8010a16:	2b00      	cmp	r3, #0
 8010a18:	d102      	bne.n	8010a20 <wc_AesEncrypt+0x34>
        WOLFSSL_ERROR_VERBOSE(KEYUSAGE_E);
        return KEYUSAGE_E;
 8010a1a:	f06f 03e1 	mvn.w	r3, #225	@ 0xe1
 8010a1e:	e006      	b.n	8010a2e <wc_AesEncrypt+0x42>
            return ret_cb;
        /* fall-through when unavailable */
    }
#endif

    AesEncrypt_C(aes, inBlock, outBlock, r);
 8010a20:	697b      	ldr	r3, [r7, #20]
 8010a22:	687a      	ldr	r2, [r7, #4]
 8010a24:	68b9      	ldr	r1, [r7, #8]
 8010a26:	68f8      	ldr	r0, [r7, #12]
 8010a28:	f7fe fede 	bl	800f7e8 <AesEncrypt_C>

    return 0;
 8010a2c:	2300      	movs	r3, #0
} /* wc_AesEncrypt */
 8010a2e:	4618      	mov	r0, r3
 8010a30:	3718      	adds	r7, #24
 8010a32:	46bd      	mov	sp, r7
 8010a34:	bd80      	pop	{r7, pc}
	...

08010a38 <PreFetchTd>:
#ifndef WC_AES_BITSLICED
#ifndef WC_NO_CACHE_RESISTANT
#ifndef WOLFSSL_AES_SMALL_TABLES
/* load 4 Td Tables into cache by cache line stride */
static WARN_UNUSED_RESULT WC_INLINE word32 PreFetchTd(void)
{
 8010a38:	b480      	push	{r7}
 8010a3a:	b085      	sub	sp, #20
 8010a3c:	af00      	add	r7, sp, #0
    word32 x = 0;
 8010a3e:	2300      	movs	r3, #0
 8010a40:	60fb      	str	r3, [r7, #12]
    int i,j;

    for (i = 0; i < 4; i++) {
 8010a42:	2300      	movs	r3, #0
 8010a44:	60bb      	str	r3, [r7, #8]
 8010a46:	e015      	b.n	8010a74 <PreFetchTd+0x3c>
        /* 256 elements, each one is 4 bytes */
        for (j = 0; j < 256; j += WC_CACHE_LINE_SZ/4) {
 8010a48:	2300      	movs	r3, #0
 8010a4a:	607b      	str	r3, [r7, #4]
 8010a4c:	e00c      	b.n	8010a68 <PreFetchTd+0x30>
            x &= Td[i][j];
 8010a4e:	490e      	ldr	r1, [pc, #56]	@ (8010a88 <PreFetchTd+0x50>)
 8010a50:	68bb      	ldr	r3, [r7, #8]
 8010a52:	021a      	lsls	r2, r3, #8
 8010a54:	687b      	ldr	r3, [r7, #4]
 8010a56:	4413      	add	r3, r2
 8010a58:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010a5c:	68fa      	ldr	r2, [r7, #12]
 8010a5e:	4013      	ands	r3, r2
 8010a60:	60fb      	str	r3, [r7, #12]
        for (j = 0; j < 256; j += WC_CACHE_LINE_SZ/4) {
 8010a62:	687b      	ldr	r3, [r7, #4]
 8010a64:	3308      	adds	r3, #8
 8010a66:	607b      	str	r3, [r7, #4]
 8010a68:	687b      	ldr	r3, [r7, #4]
 8010a6a:	2bff      	cmp	r3, #255	@ 0xff
 8010a6c:	ddef      	ble.n	8010a4e <PreFetchTd+0x16>
    for (i = 0; i < 4; i++) {
 8010a6e:	68bb      	ldr	r3, [r7, #8]
 8010a70:	3301      	adds	r3, #1
 8010a72:	60bb      	str	r3, [r7, #8]
 8010a74:	68bb      	ldr	r3, [r7, #8]
 8010a76:	2b03      	cmp	r3, #3
 8010a78:	dde6      	ble.n	8010a48 <PreFetchTd+0x10>
        }
    }
    return x;
 8010a7a:	68fb      	ldr	r3, [r7, #12]
}
 8010a7c:	4618      	mov	r0, r3
 8010a7e:	3714      	adds	r7, #20
 8010a80:	46bd      	mov	sp, r7
 8010a82:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010a86:	4770      	bx	lr
 8010a88:	08032494 	.word	0x08032494

08010a8c <PreFetchTd4>:
#endif /* !WOLFSSL_AES_SMALL_TABLES */

/* load Td Table4 into cache by cache line stride */
static WARN_UNUSED_RESULT WC_INLINE word32 PreFetchTd4(void)
{
 8010a8c:	b480      	push	{r7}
 8010a8e:	b083      	sub	sp, #12
 8010a90:	af00      	add	r7, sp, #0
#ifndef WOLFSSL_AES_TOUCH_LINES
    word32 x = 0;
 8010a92:	2300      	movs	r3, #0
 8010a94:	607b      	str	r3, [r7, #4]
    int i;

    for (i = 0; i < 256; i += WC_CACHE_LINE_SZ) {
 8010a96:	2300      	movs	r3, #0
 8010a98:	603b      	str	r3, [r7, #0]
 8010a9a:	e00a      	b.n	8010ab2 <PreFetchTd4+0x26>
        x &= (word32)Td4[i];
 8010a9c:	4a0a      	ldr	r2, [pc, #40]	@ (8010ac8 <PreFetchTd4+0x3c>)
 8010a9e:	683b      	ldr	r3, [r7, #0]
 8010aa0:	4413      	add	r3, r2
 8010aa2:	781b      	ldrb	r3, [r3, #0]
 8010aa4:	461a      	mov	r2, r3
 8010aa6:	687b      	ldr	r3, [r7, #4]
 8010aa8:	4013      	ands	r3, r2
 8010aaa:	607b      	str	r3, [r7, #4]
    for (i = 0; i < 256; i += WC_CACHE_LINE_SZ) {
 8010aac:	683b      	ldr	r3, [r7, #0]
 8010aae:	3320      	adds	r3, #32
 8010ab0:	603b      	str	r3, [r7, #0]
 8010ab2:	683b      	ldr	r3, [r7, #0]
 8010ab4:	2bff      	cmp	r3, #255	@ 0xff
 8010ab6:	ddf1      	ble.n	8010a9c <PreFetchTd4+0x10>
    }
    return x;
 8010ab8:	687b      	ldr	r3, [r7, #4]
#else
    return 0;
#endif
}
 8010aba:	4618      	mov	r0, r3
 8010abc:	370c      	adds	r7, #12
 8010abe:	46bd      	mov	sp, r7
 8010ac0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010ac4:	4770      	bx	lr
 8010ac6:	bf00      	nop
 8010ac8:	08033494 	.word	0x08033494

08010acc <AesDecrypt_C>:
 * @param [out] outBlock  Encrypted block.
 * @param [in]  r         Rounds divided by 2.
 */
static void AesDecrypt_C(Aes* aes, const byte* inBlock, byte* outBlock,
    word32 r)
{
 8010acc:	b580      	push	{r7, lr}
 8010ace:	b08e      	sub	sp, #56	@ 0x38
 8010ad0:	af00      	add	r7, sp, #0
 8010ad2:	60f8      	str	r0, [r7, #12]
 8010ad4:	60b9      	str	r1, [r7, #8]
 8010ad6:	607a      	str	r2, [r7, #4]
 8010ad8:	603b      	str	r3, [r7, #0]
    const word32* rk;

#ifdef WC_C_DYNAMIC_FALLBACK
    rk = aes->key_C_fallback;
#else
    rk = aes->key;
 8010ada:	68fb      	ldr	r3, [r7, #12]
 8010adc:	627b      	str	r3, [r7, #36]	@ 0x24

    /*
     * map byte array block to cipher state
     * and add initial round key:
     */
    XMEMCPY(&s0, inBlock,                  sizeof(s0));
 8010ade:	68bb      	ldr	r3, [r7, #8]
 8010ae0:	681b      	ldr	r3, [r3, #0]
 8010ae2:	623b      	str	r3, [r7, #32]
    XMEMCPY(&s1, inBlock + sizeof(s0),     sizeof(s1));
 8010ae4:	68bb      	ldr	r3, [r7, #8]
 8010ae6:	3304      	adds	r3, #4
 8010ae8:	681b      	ldr	r3, [r3, #0]
 8010aea:	61fb      	str	r3, [r7, #28]
    XMEMCPY(&s2, inBlock + 2 * sizeof(s0), sizeof(s2));
 8010aec:	68bb      	ldr	r3, [r7, #8]
 8010aee:	3308      	adds	r3, #8
 8010af0:	681b      	ldr	r3, [r3, #0]
 8010af2:	61bb      	str	r3, [r7, #24]
    XMEMCPY(&s3, inBlock + 3 * sizeof(s0), sizeof(s3));
 8010af4:	68bb      	ldr	r3, [r7, #8]
 8010af6:	330c      	adds	r3, #12
 8010af8:	681b      	ldr	r3, [r3, #0]
 8010afa:	617b      	str	r3, [r7, #20]

#ifdef LITTLE_ENDIAN_ORDER
    s0 = ByteReverseWord32(s0);
 8010afc:	6a3b      	ldr	r3, [r7, #32]
 8010afe:	4618      	mov	r0, r3
 8010b00:	f7fe fd73 	bl	800f5ea <ByteReverseWord32>
 8010b04:	4603      	mov	r3, r0
 8010b06:	623b      	str	r3, [r7, #32]
    s1 = ByteReverseWord32(s1);
 8010b08:	69fb      	ldr	r3, [r7, #28]
 8010b0a:	4618      	mov	r0, r3
 8010b0c:	f7fe fd6d 	bl	800f5ea <ByteReverseWord32>
 8010b10:	4603      	mov	r3, r0
 8010b12:	61fb      	str	r3, [r7, #28]
    s2 = ByteReverseWord32(s2);
 8010b14:	69bb      	ldr	r3, [r7, #24]
 8010b16:	4618      	mov	r0, r3
 8010b18:	f7fe fd67 	bl	800f5ea <ByteReverseWord32>
 8010b1c:	4603      	mov	r3, r0
 8010b1e:	61bb      	str	r3, [r7, #24]
    s3 = ByteReverseWord32(s3);
 8010b20:	697b      	ldr	r3, [r7, #20]
 8010b22:	4618      	mov	r0, r3
 8010b24:	f7fe fd61 	bl	800f5ea <ByteReverseWord32>
 8010b28:	4603      	mov	r3, r0
 8010b2a:	617b      	str	r3, [r7, #20]
#endif

    s0 ^= rk[0];
 8010b2c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010b2e:	681a      	ldr	r2, [r3, #0]
 8010b30:	6a3b      	ldr	r3, [r7, #32]
 8010b32:	4053      	eors	r3, r2
 8010b34:	623b      	str	r3, [r7, #32]
    s1 ^= rk[1];
 8010b36:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010b38:	3304      	adds	r3, #4
 8010b3a:	681a      	ldr	r2, [r3, #0]
 8010b3c:	69fb      	ldr	r3, [r7, #28]
 8010b3e:	4053      	eors	r3, r2
 8010b40:	61fb      	str	r3, [r7, #28]
    s2 ^= rk[2];
 8010b42:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010b44:	3308      	adds	r3, #8
 8010b46:	681a      	ldr	r2, [r3, #0]
 8010b48:	69bb      	ldr	r3, [r7, #24]
 8010b4a:	4053      	eors	r3, r2
 8010b4c:	61bb      	str	r3, [r7, #24]
    s3 ^= rk[3];
 8010b4e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010b50:	330c      	adds	r3, #12
 8010b52:	681a      	ldr	r2, [r3, #0]
 8010b54:	697b      	ldr	r3, [r7, #20]
 8010b56:	4053      	eors	r3, r2
 8010b58:	617b      	str	r3, [r7, #20]

#ifndef WOLFSSL_AES_SMALL_TABLES
#ifndef WC_NO_CACHE_RESISTANT
    s0 |= PreFetchTd();
 8010b5a:	f7ff ff6d 	bl	8010a38 <PreFetchTd>
 8010b5e:	4602      	mov	r2, r0
 8010b60:	6a3b      	ldr	r3, [r7, #32]
 8010b62:	4313      	orrs	r3, r2
 8010b64:	623b      	str	r3, [r7, #32]
                          &s2, GETBYTE(t3, 0), &s3, GETBYTE(t0, 0));           \
    s0 ^= rk[(o)+0]; s1 ^= rk[(o)+1]; s2 ^= rk[(o)+2]; s3 ^= rk[(o)+3];
#endif

#ifndef WOLFSSL_AES_NO_UNROLL
                       DEC_ROUND_T_S( 0);
 8010b66:	6a3b      	ldr	r3, [r7, #32]
 8010b68:	0e1b      	lsrs	r3, r3, #24
 8010b6a:	b2db      	uxtb	r3, r3
 8010b6c:	461a      	mov	r2, r3
 8010b6e:	4bb6      	ldr	r3, [pc, #728]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010b70:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010b74:	697b      	ldr	r3, [r7, #20]
 8010b76:	0c1b      	lsrs	r3, r3, #16
 8010b78:	b2db      	uxtb	r3, r3
 8010b7a:	49b3      	ldr	r1, [pc, #716]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010b7c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010b80:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010b84:	405a      	eors	r2, r3
 8010b86:	69bb      	ldr	r3, [r7, #24]
 8010b88:	0a1b      	lsrs	r3, r3, #8
 8010b8a:	b2db      	uxtb	r3, r3
 8010b8c:	49ae      	ldr	r1, [pc, #696]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010b8e:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010b92:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010b96:	405a      	eors	r2, r3
 8010b98:	69fb      	ldr	r3, [r7, #28]
 8010b9a:	b2db      	uxtb	r3, r3
 8010b9c:	49aa      	ldr	r1, [pc, #680]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010b9e:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010ba2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010ba6:	405a      	eors	r2, r3
 8010ba8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010baa:	3310      	adds	r3, #16
 8010bac:	681b      	ldr	r3, [r3, #0]
 8010bae:	4053      	eors	r3, r2
 8010bb0:	637b      	str	r3, [r7, #52]	@ 0x34
 8010bb2:	69fb      	ldr	r3, [r7, #28]
 8010bb4:	0e1b      	lsrs	r3, r3, #24
 8010bb6:	b2db      	uxtb	r3, r3
 8010bb8:	461a      	mov	r2, r3
 8010bba:	4ba3      	ldr	r3, [pc, #652]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010bbc:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010bc0:	6a3b      	ldr	r3, [r7, #32]
 8010bc2:	0c1b      	lsrs	r3, r3, #16
 8010bc4:	b2db      	uxtb	r3, r3
 8010bc6:	49a0      	ldr	r1, [pc, #640]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010bc8:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010bcc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010bd0:	405a      	eors	r2, r3
 8010bd2:	697b      	ldr	r3, [r7, #20]
 8010bd4:	0a1b      	lsrs	r3, r3, #8
 8010bd6:	b2db      	uxtb	r3, r3
 8010bd8:	499b      	ldr	r1, [pc, #620]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010bda:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010bde:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010be2:	405a      	eors	r2, r3
 8010be4:	69bb      	ldr	r3, [r7, #24]
 8010be6:	b2db      	uxtb	r3, r3
 8010be8:	4997      	ldr	r1, [pc, #604]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010bea:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010bee:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010bf2:	405a      	eors	r2, r3
 8010bf4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010bf6:	3314      	adds	r3, #20
 8010bf8:	681b      	ldr	r3, [r3, #0]
 8010bfa:	4053      	eors	r3, r2
 8010bfc:	633b      	str	r3, [r7, #48]	@ 0x30
 8010bfe:	69bb      	ldr	r3, [r7, #24]
 8010c00:	0e1b      	lsrs	r3, r3, #24
 8010c02:	b2db      	uxtb	r3, r3
 8010c04:	461a      	mov	r2, r3
 8010c06:	4b90      	ldr	r3, [pc, #576]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010c08:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010c0c:	69fb      	ldr	r3, [r7, #28]
 8010c0e:	0c1b      	lsrs	r3, r3, #16
 8010c10:	b2db      	uxtb	r3, r3
 8010c12:	498d      	ldr	r1, [pc, #564]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010c14:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010c18:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010c1c:	405a      	eors	r2, r3
 8010c1e:	6a3b      	ldr	r3, [r7, #32]
 8010c20:	0a1b      	lsrs	r3, r3, #8
 8010c22:	b2db      	uxtb	r3, r3
 8010c24:	4988      	ldr	r1, [pc, #544]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010c26:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010c2a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010c2e:	405a      	eors	r2, r3
 8010c30:	697b      	ldr	r3, [r7, #20]
 8010c32:	b2db      	uxtb	r3, r3
 8010c34:	4984      	ldr	r1, [pc, #528]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010c36:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010c3a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010c3e:	405a      	eors	r2, r3
 8010c40:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010c42:	3318      	adds	r3, #24
 8010c44:	681b      	ldr	r3, [r3, #0]
 8010c46:	4053      	eors	r3, r2
 8010c48:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8010c4a:	697b      	ldr	r3, [r7, #20]
 8010c4c:	0e1b      	lsrs	r3, r3, #24
 8010c4e:	b2db      	uxtb	r3, r3
 8010c50:	461a      	mov	r2, r3
 8010c52:	4b7d      	ldr	r3, [pc, #500]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010c54:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010c58:	69bb      	ldr	r3, [r7, #24]
 8010c5a:	0c1b      	lsrs	r3, r3, #16
 8010c5c:	b2db      	uxtb	r3, r3
 8010c5e:	497a      	ldr	r1, [pc, #488]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010c60:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010c64:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010c68:	405a      	eors	r2, r3
 8010c6a:	69fb      	ldr	r3, [r7, #28]
 8010c6c:	0a1b      	lsrs	r3, r3, #8
 8010c6e:	b2db      	uxtb	r3, r3
 8010c70:	4975      	ldr	r1, [pc, #468]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010c72:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010c76:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010c7a:	405a      	eors	r2, r3
 8010c7c:	6a3b      	ldr	r3, [r7, #32]
 8010c7e:	b2db      	uxtb	r3, r3
 8010c80:	4971      	ldr	r1, [pc, #452]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010c82:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010c86:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010c8a:	405a      	eors	r2, r3
 8010c8c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010c8e:	331c      	adds	r3, #28
 8010c90:	681b      	ldr	r3, [r3, #0]
 8010c92:	4053      	eors	r3, r2
 8010c94:	62bb      	str	r3, [r7, #40]	@ 0x28
    DEC_ROUND_S_T( 8); DEC_ROUND_T_S( 8);
 8010c96:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010c98:	0e1b      	lsrs	r3, r3, #24
 8010c9a:	b2db      	uxtb	r3, r3
 8010c9c:	461a      	mov	r2, r3
 8010c9e:	4b6a      	ldr	r3, [pc, #424]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010ca0:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010ca4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010ca6:	0c1b      	lsrs	r3, r3, #16
 8010ca8:	b2db      	uxtb	r3, r3
 8010caa:	4967      	ldr	r1, [pc, #412]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010cac:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010cb0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010cb4:	405a      	eors	r2, r3
 8010cb6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010cb8:	0a1b      	lsrs	r3, r3, #8
 8010cba:	b2db      	uxtb	r3, r3
 8010cbc:	4962      	ldr	r1, [pc, #392]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010cbe:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010cc2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010cc6:	405a      	eors	r2, r3
 8010cc8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010cca:	b2db      	uxtb	r3, r3
 8010ccc:	495e      	ldr	r1, [pc, #376]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010cce:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010cd2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010cd6:	405a      	eors	r2, r3
 8010cd8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010cda:	3320      	adds	r3, #32
 8010cdc:	681b      	ldr	r3, [r3, #0]
 8010cde:	4053      	eors	r3, r2
 8010ce0:	623b      	str	r3, [r7, #32]
 8010ce2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010ce4:	0e1b      	lsrs	r3, r3, #24
 8010ce6:	b2db      	uxtb	r3, r3
 8010ce8:	461a      	mov	r2, r3
 8010cea:	4b57      	ldr	r3, [pc, #348]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010cec:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010cf0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010cf2:	0c1b      	lsrs	r3, r3, #16
 8010cf4:	b2db      	uxtb	r3, r3
 8010cf6:	4954      	ldr	r1, [pc, #336]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010cf8:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010cfc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010d00:	405a      	eors	r2, r3
 8010d02:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010d04:	0a1b      	lsrs	r3, r3, #8
 8010d06:	b2db      	uxtb	r3, r3
 8010d08:	494f      	ldr	r1, [pc, #316]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010d0a:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010d0e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010d12:	405a      	eors	r2, r3
 8010d14:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010d16:	b2db      	uxtb	r3, r3
 8010d18:	494b      	ldr	r1, [pc, #300]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010d1a:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010d1e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010d22:	405a      	eors	r2, r3
 8010d24:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010d26:	3324      	adds	r3, #36	@ 0x24
 8010d28:	681b      	ldr	r3, [r3, #0]
 8010d2a:	4053      	eors	r3, r2
 8010d2c:	61fb      	str	r3, [r7, #28]
 8010d2e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010d30:	0e1b      	lsrs	r3, r3, #24
 8010d32:	b2db      	uxtb	r3, r3
 8010d34:	461a      	mov	r2, r3
 8010d36:	4b44      	ldr	r3, [pc, #272]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010d38:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010d3c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010d3e:	0c1b      	lsrs	r3, r3, #16
 8010d40:	b2db      	uxtb	r3, r3
 8010d42:	4941      	ldr	r1, [pc, #260]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010d44:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010d48:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010d4c:	405a      	eors	r2, r3
 8010d4e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010d50:	0a1b      	lsrs	r3, r3, #8
 8010d52:	b2db      	uxtb	r3, r3
 8010d54:	493c      	ldr	r1, [pc, #240]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010d56:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010d5a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010d5e:	405a      	eors	r2, r3
 8010d60:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010d62:	b2db      	uxtb	r3, r3
 8010d64:	4938      	ldr	r1, [pc, #224]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010d66:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010d6a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010d6e:	405a      	eors	r2, r3
 8010d70:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010d72:	3328      	adds	r3, #40	@ 0x28
 8010d74:	681b      	ldr	r3, [r3, #0]
 8010d76:	4053      	eors	r3, r2
 8010d78:	61bb      	str	r3, [r7, #24]
 8010d7a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010d7c:	0e1b      	lsrs	r3, r3, #24
 8010d7e:	b2db      	uxtb	r3, r3
 8010d80:	461a      	mov	r2, r3
 8010d82:	4b31      	ldr	r3, [pc, #196]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010d84:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010d88:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010d8a:	0c1b      	lsrs	r3, r3, #16
 8010d8c:	b2db      	uxtb	r3, r3
 8010d8e:	492e      	ldr	r1, [pc, #184]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010d90:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010d94:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010d98:	405a      	eors	r2, r3
 8010d9a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010d9c:	0a1b      	lsrs	r3, r3, #8
 8010d9e:	b2db      	uxtb	r3, r3
 8010da0:	4929      	ldr	r1, [pc, #164]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010da2:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010da6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010daa:	405a      	eors	r2, r3
 8010dac:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010dae:	b2db      	uxtb	r3, r3
 8010db0:	4925      	ldr	r1, [pc, #148]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010db2:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010db6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010dba:	405a      	eors	r2, r3
 8010dbc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010dbe:	332c      	adds	r3, #44	@ 0x2c
 8010dc0:	681b      	ldr	r3, [r3, #0]
 8010dc2:	4053      	eors	r3, r2
 8010dc4:	617b      	str	r3, [r7, #20]
 8010dc6:	6a3b      	ldr	r3, [r7, #32]
 8010dc8:	0e1b      	lsrs	r3, r3, #24
 8010dca:	b2db      	uxtb	r3, r3
 8010dcc:	461a      	mov	r2, r3
 8010dce:	4b1e      	ldr	r3, [pc, #120]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010dd0:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010dd4:	697b      	ldr	r3, [r7, #20]
 8010dd6:	0c1b      	lsrs	r3, r3, #16
 8010dd8:	b2db      	uxtb	r3, r3
 8010dda:	491b      	ldr	r1, [pc, #108]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010ddc:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010de0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010de4:	405a      	eors	r2, r3
 8010de6:	69bb      	ldr	r3, [r7, #24]
 8010de8:	0a1b      	lsrs	r3, r3, #8
 8010dea:	b2db      	uxtb	r3, r3
 8010dec:	4916      	ldr	r1, [pc, #88]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010dee:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010df2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010df6:	405a      	eors	r2, r3
 8010df8:	69fb      	ldr	r3, [r7, #28]
 8010dfa:	b2db      	uxtb	r3, r3
 8010dfc:	4912      	ldr	r1, [pc, #72]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010dfe:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010e02:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010e06:	405a      	eors	r2, r3
 8010e08:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010e0a:	3330      	adds	r3, #48	@ 0x30
 8010e0c:	681b      	ldr	r3, [r3, #0]
 8010e0e:	4053      	eors	r3, r2
 8010e10:	637b      	str	r3, [r7, #52]	@ 0x34
 8010e12:	69fb      	ldr	r3, [r7, #28]
 8010e14:	0e1b      	lsrs	r3, r3, #24
 8010e16:	b2db      	uxtb	r3, r3
 8010e18:	461a      	mov	r2, r3
 8010e1a:	4b0b      	ldr	r3, [pc, #44]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010e1c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010e20:	6a3b      	ldr	r3, [r7, #32]
 8010e22:	0c1b      	lsrs	r3, r3, #16
 8010e24:	b2db      	uxtb	r3, r3
 8010e26:	4908      	ldr	r1, [pc, #32]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010e28:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010e2c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010e30:	405a      	eors	r2, r3
 8010e32:	697b      	ldr	r3, [r7, #20]
 8010e34:	0a1b      	lsrs	r3, r3, #8
 8010e36:	b2db      	uxtb	r3, r3
 8010e38:	4903      	ldr	r1, [pc, #12]	@ (8010e48 <AesDecrypt_C+0x37c>)
 8010e3a:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010e3e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010e42:	405a      	eors	r2, r3
 8010e44:	69bb      	ldr	r3, [r7, #24]
 8010e46:	e001      	b.n	8010e4c <AesDecrypt_C+0x380>
 8010e48:	08032494 	.word	0x08032494
 8010e4c:	b2db      	uxtb	r3, r3
 8010e4e:	49b6      	ldr	r1, [pc, #728]	@ (8011128 <AesDecrypt_C+0x65c>)
 8010e50:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010e54:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010e58:	405a      	eors	r2, r3
 8010e5a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010e5c:	3334      	adds	r3, #52	@ 0x34
 8010e5e:	681b      	ldr	r3, [r3, #0]
 8010e60:	4053      	eors	r3, r2
 8010e62:	633b      	str	r3, [r7, #48]	@ 0x30
 8010e64:	69bb      	ldr	r3, [r7, #24]
 8010e66:	0e1b      	lsrs	r3, r3, #24
 8010e68:	b2db      	uxtb	r3, r3
 8010e6a:	461a      	mov	r2, r3
 8010e6c:	4bae      	ldr	r3, [pc, #696]	@ (8011128 <AesDecrypt_C+0x65c>)
 8010e6e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010e72:	69fb      	ldr	r3, [r7, #28]
 8010e74:	0c1b      	lsrs	r3, r3, #16
 8010e76:	b2db      	uxtb	r3, r3
 8010e78:	49ab      	ldr	r1, [pc, #684]	@ (8011128 <AesDecrypt_C+0x65c>)
 8010e7a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010e7e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010e82:	405a      	eors	r2, r3
 8010e84:	6a3b      	ldr	r3, [r7, #32]
 8010e86:	0a1b      	lsrs	r3, r3, #8
 8010e88:	b2db      	uxtb	r3, r3
 8010e8a:	49a7      	ldr	r1, [pc, #668]	@ (8011128 <AesDecrypt_C+0x65c>)
 8010e8c:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010e90:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010e94:	405a      	eors	r2, r3
 8010e96:	697b      	ldr	r3, [r7, #20]
 8010e98:	b2db      	uxtb	r3, r3
 8010e9a:	49a3      	ldr	r1, [pc, #652]	@ (8011128 <AesDecrypt_C+0x65c>)
 8010e9c:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010ea0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010ea4:	405a      	eors	r2, r3
 8010ea6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010ea8:	3338      	adds	r3, #56	@ 0x38
 8010eaa:	681b      	ldr	r3, [r3, #0]
 8010eac:	4053      	eors	r3, r2
 8010eae:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8010eb0:	697b      	ldr	r3, [r7, #20]
 8010eb2:	0e1b      	lsrs	r3, r3, #24
 8010eb4:	b2db      	uxtb	r3, r3
 8010eb6:	461a      	mov	r2, r3
 8010eb8:	4b9b      	ldr	r3, [pc, #620]	@ (8011128 <AesDecrypt_C+0x65c>)
 8010eba:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010ebe:	69bb      	ldr	r3, [r7, #24]
 8010ec0:	0c1b      	lsrs	r3, r3, #16
 8010ec2:	b2db      	uxtb	r3, r3
 8010ec4:	4998      	ldr	r1, [pc, #608]	@ (8011128 <AesDecrypt_C+0x65c>)
 8010ec6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010eca:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010ece:	405a      	eors	r2, r3
 8010ed0:	69fb      	ldr	r3, [r7, #28]
 8010ed2:	0a1b      	lsrs	r3, r3, #8
 8010ed4:	b2db      	uxtb	r3, r3
 8010ed6:	4994      	ldr	r1, [pc, #592]	@ (8011128 <AesDecrypt_C+0x65c>)
 8010ed8:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010edc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010ee0:	405a      	eors	r2, r3
 8010ee2:	6a3b      	ldr	r3, [r7, #32]
 8010ee4:	b2db      	uxtb	r3, r3
 8010ee6:	4990      	ldr	r1, [pc, #576]	@ (8011128 <AesDecrypt_C+0x65c>)
 8010ee8:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010eec:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010ef0:	405a      	eors	r2, r3
 8010ef2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010ef4:	333c      	adds	r3, #60	@ 0x3c
 8010ef6:	681b      	ldr	r3, [r3, #0]
 8010ef8:	4053      	eors	r3, r2
 8010efa:	62bb      	str	r3, [r7, #40]	@ 0x28
    DEC_ROUND_S_T(16); DEC_ROUND_T_S(16);
 8010efc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010efe:	0e1b      	lsrs	r3, r3, #24
 8010f00:	b2db      	uxtb	r3, r3
 8010f02:	461a      	mov	r2, r3
 8010f04:	4b88      	ldr	r3, [pc, #544]	@ (8011128 <AesDecrypt_C+0x65c>)
 8010f06:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010f0a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010f0c:	0c1b      	lsrs	r3, r3, #16
 8010f0e:	b2db      	uxtb	r3, r3
 8010f10:	4985      	ldr	r1, [pc, #532]	@ (8011128 <AesDecrypt_C+0x65c>)
 8010f12:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010f16:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010f1a:	405a      	eors	r2, r3
 8010f1c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010f1e:	0a1b      	lsrs	r3, r3, #8
 8010f20:	b2db      	uxtb	r3, r3
 8010f22:	4981      	ldr	r1, [pc, #516]	@ (8011128 <AesDecrypt_C+0x65c>)
 8010f24:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010f28:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010f2c:	405a      	eors	r2, r3
 8010f2e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010f30:	b2db      	uxtb	r3, r3
 8010f32:	497d      	ldr	r1, [pc, #500]	@ (8011128 <AesDecrypt_C+0x65c>)
 8010f34:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010f38:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010f3c:	405a      	eors	r2, r3
 8010f3e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010f40:	3340      	adds	r3, #64	@ 0x40
 8010f42:	681b      	ldr	r3, [r3, #0]
 8010f44:	4053      	eors	r3, r2
 8010f46:	623b      	str	r3, [r7, #32]
 8010f48:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010f4a:	0e1b      	lsrs	r3, r3, #24
 8010f4c:	b2db      	uxtb	r3, r3
 8010f4e:	461a      	mov	r2, r3
 8010f50:	4b75      	ldr	r3, [pc, #468]	@ (8011128 <AesDecrypt_C+0x65c>)
 8010f52:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010f56:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010f58:	0c1b      	lsrs	r3, r3, #16
 8010f5a:	b2db      	uxtb	r3, r3
 8010f5c:	4972      	ldr	r1, [pc, #456]	@ (8011128 <AesDecrypt_C+0x65c>)
 8010f5e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010f62:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010f66:	405a      	eors	r2, r3
 8010f68:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010f6a:	0a1b      	lsrs	r3, r3, #8
 8010f6c:	b2db      	uxtb	r3, r3
 8010f6e:	496e      	ldr	r1, [pc, #440]	@ (8011128 <AesDecrypt_C+0x65c>)
 8010f70:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010f74:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010f78:	405a      	eors	r2, r3
 8010f7a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010f7c:	b2db      	uxtb	r3, r3
 8010f7e:	496a      	ldr	r1, [pc, #424]	@ (8011128 <AesDecrypt_C+0x65c>)
 8010f80:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010f84:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010f88:	405a      	eors	r2, r3
 8010f8a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010f8c:	3344      	adds	r3, #68	@ 0x44
 8010f8e:	681b      	ldr	r3, [r3, #0]
 8010f90:	4053      	eors	r3, r2
 8010f92:	61fb      	str	r3, [r7, #28]
 8010f94:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010f96:	0e1b      	lsrs	r3, r3, #24
 8010f98:	b2db      	uxtb	r3, r3
 8010f9a:	461a      	mov	r2, r3
 8010f9c:	4b62      	ldr	r3, [pc, #392]	@ (8011128 <AesDecrypt_C+0x65c>)
 8010f9e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010fa2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010fa4:	0c1b      	lsrs	r3, r3, #16
 8010fa6:	b2db      	uxtb	r3, r3
 8010fa8:	495f      	ldr	r1, [pc, #380]	@ (8011128 <AesDecrypt_C+0x65c>)
 8010faa:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010fae:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010fb2:	405a      	eors	r2, r3
 8010fb4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010fb6:	0a1b      	lsrs	r3, r3, #8
 8010fb8:	b2db      	uxtb	r3, r3
 8010fba:	495b      	ldr	r1, [pc, #364]	@ (8011128 <AesDecrypt_C+0x65c>)
 8010fbc:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010fc0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010fc4:	405a      	eors	r2, r3
 8010fc6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010fc8:	b2db      	uxtb	r3, r3
 8010fca:	4957      	ldr	r1, [pc, #348]	@ (8011128 <AesDecrypt_C+0x65c>)
 8010fcc:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010fd0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010fd4:	405a      	eors	r2, r3
 8010fd6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010fd8:	3348      	adds	r3, #72	@ 0x48
 8010fda:	681b      	ldr	r3, [r3, #0]
 8010fdc:	4053      	eors	r3, r2
 8010fde:	61bb      	str	r3, [r7, #24]
 8010fe0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010fe2:	0e1b      	lsrs	r3, r3, #24
 8010fe4:	b2db      	uxtb	r3, r3
 8010fe6:	461a      	mov	r2, r3
 8010fe8:	4b4f      	ldr	r3, [pc, #316]	@ (8011128 <AesDecrypt_C+0x65c>)
 8010fea:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010fee:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010ff0:	0c1b      	lsrs	r3, r3, #16
 8010ff2:	b2db      	uxtb	r3, r3
 8010ff4:	494c      	ldr	r1, [pc, #304]	@ (8011128 <AesDecrypt_C+0x65c>)
 8010ff6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010ffa:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010ffe:	405a      	eors	r2, r3
 8011000:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011002:	0a1b      	lsrs	r3, r3, #8
 8011004:	b2db      	uxtb	r3, r3
 8011006:	4948      	ldr	r1, [pc, #288]	@ (8011128 <AesDecrypt_C+0x65c>)
 8011008:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801100c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011010:	405a      	eors	r2, r3
 8011012:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011014:	b2db      	uxtb	r3, r3
 8011016:	4944      	ldr	r1, [pc, #272]	@ (8011128 <AesDecrypt_C+0x65c>)
 8011018:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801101c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011020:	405a      	eors	r2, r3
 8011022:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011024:	334c      	adds	r3, #76	@ 0x4c
 8011026:	681b      	ldr	r3, [r3, #0]
 8011028:	4053      	eors	r3, r2
 801102a:	617b      	str	r3, [r7, #20]
 801102c:	6a3b      	ldr	r3, [r7, #32]
 801102e:	0e1b      	lsrs	r3, r3, #24
 8011030:	b2db      	uxtb	r3, r3
 8011032:	461a      	mov	r2, r3
 8011034:	4b3c      	ldr	r3, [pc, #240]	@ (8011128 <AesDecrypt_C+0x65c>)
 8011036:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801103a:	697b      	ldr	r3, [r7, #20]
 801103c:	0c1b      	lsrs	r3, r3, #16
 801103e:	b2db      	uxtb	r3, r3
 8011040:	4939      	ldr	r1, [pc, #228]	@ (8011128 <AesDecrypt_C+0x65c>)
 8011042:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011046:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801104a:	405a      	eors	r2, r3
 801104c:	69bb      	ldr	r3, [r7, #24]
 801104e:	0a1b      	lsrs	r3, r3, #8
 8011050:	b2db      	uxtb	r3, r3
 8011052:	4935      	ldr	r1, [pc, #212]	@ (8011128 <AesDecrypt_C+0x65c>)
 8011054:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011058:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801105c:	405a      	eors	r2, r3
 801105e:	69fb      	ldr	r3, [r7, #28]
 8011060:	b2db      	uxtb	r3, r3
 8011062:	4931      	ldr	r1, [pc, #196]	@ (8011128 <AesDecrypt_C+0x65c>)
 8011064:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011068:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801106c:	405a      	eors	r2, r3
 801106e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011070:	3350      	adds	r3, #80	@ 0x50
 8011072:	681b      	ldr	r3, [r3, #0]
 8011074:	4053      	eors	r3, r2
 8011076:	637b      	str	r3, [r7, #52]	@ 0x34
 8011078:	69fb      	ldr	r3, [r7, #28]
 801107a:	0e1b      	lsrs	r3, r3, #24
 801107c:	b2db      	uxtb	r3, r3
 801107e:	461a      	mov	r2, r3
 8011080:	4b29      	ldr	r3, [pc, #164]	@ (8011128 <AesDecrypt_C+0x65c>)
 8011082:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011086:	6a3b      	ldr	r3, [r7, #32]
 8011088:	0c1b      	lsrs	r3, r3, #16
 801108a:	b2db      	uxtb	r3, r3
 801108c:	4926      	ldr	r1, [pc, #152]	@ (8011128 <AesDecrypt_C+0x65c>)
 801108e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011092:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011096:	405a      	eors	r2, r3
 8011098:	697b      	ldr	r3, [r7, #20]
 801109a:	0a1b      	lsrs	r3, r3, #8
 801109c:	b2db      	uxtb	r3, r3
 801109e:	4922      	ldr	r1, [pc, #136]	@ (8011128 <AesDecrypt_C+0x65c>)
 80110a0:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80110a4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80110a8:	405a      	eors	r2, r3
 80110aa:	69bb      	ldr	r3, [r7, #24]
 80110ac:	b2db      	uxtb	r3, r3
 80110ae:	491e      	ldr	r1, [pc, #120]	@ (8011128 <AesDecrypt_C+0x65c>)
 80110b0:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80110b4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80110b8:	405a      	eors	r2, r3
 80110ba:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80110bc:	3354      	adds	r3, #84	@ 0x54
 80110be:	681b      	ldr	r3, [r3, #0]
 80110c0:	4053      	eors	r3, r2
 80110c2:	633b      	str	r3, [r7, #48]	@ 0x30
 80110c4:	69bb      	ldr	r3, [r7, #24]
 80110c6:	0e1b      	lsrs	r3, r3, #24
 80110c8:	b2db      	uxtb	r3, r3
 80110ca:	461a      	mov	r2, r3
 80110cc:	4b16      	ldr	r3, [pc, #88]	@ (8011128 <AesDecrypt_C+0x65c>)
 80110ce:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80110d2:	69fb      	ldr	r3, [r7, #28]
 80110d4:	0c1b      	lsrs	r3, r3, #16
 80110d6:	b2db      	uxtb	r3, r3
 80110d8:	4913      	ldr	r1, [pc, #76]	@ (8011128 <AesDecrypt_C+0x65c>)
 80110da:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80110de:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80110e2:	405a      	eors	r2, r3
 80110e4:	6a3b      	ldr	r3, [r7, #32]
 80110e6:	0a1b      	lsrs	r3, r3, #8
 80110e8:	b2db      	uxtb	r3, r3
 80110ea:	490f      	ldr	r1, [pc, #60]	@ (8011128 <AesDecrypt_C+0x65c>)
 80110ec:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80110f0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80110f4:	405a      	eors	r2, r3
 80110f6:	697b      	ldr	r3, [r7, #20]
 80110f8:	b2db      	uxtb	r3, r3
 80110fa:	490b      	ldr	r1, [pc, #44]	@ (8011128 <AesDecrypt_C+0x65c>)
 80110fc:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011100:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011104:	405a      	eors	r2, r3
 8011106:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011108:	3358      	adds	r3, #88	@ 0x58
 801110a:	681b      	ldr	r3, [r3, #0]
 801110c:	4053      	eors	r3, r2
 801110e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8011110:	697b      	ldr	r3, [r7, #20]
 8011112:	0e1b      	lsrs	r3, r3, #24
 8011114:	b2db      	uxtb	r3, r3
 8011116:	461a      	mov	r2, r3
 8011118:	4b03      	ldr	r3, [pc, #12]	@ (8011128 <AesDecrypt_C+0x65c>)
 801111a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801111e:	69bb      	ldr	r3, [r7, #24]
 8011120:	0c1b      	lsrs	r3, r3, #16
 8011122:	b2db      	uxtb	r3, r3
 8011124:	e002      	b.n	801112c <AesDecrypt_C+0x660>
 8011126:	bf00      	nop
 8011128:	08032494 	.word	0x08032494
 801112c:	49b6      	ldr	r1, [pc, #728]	@ (8011408 <AesDecrypt_C+0x93c>)
 801112e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011132:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011136:	405a      	eors	r2, r3
 8011138:	69fb      	ldr	r3, [r7, #28]
 801113a:	0a1b      	lsrs	r3, r3, #8
 801113c:	b2db      	uxtb	r3, r3
 801113e:	49b2      	ldr	r1, [pc, #712]	@ (8011408 <AesDecrypt_C+0x93c>)
 8011140:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011144:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011148:	405a      	eors	r2, r3
 801114a:	6a3b      	ldr	r3, [r7, #32]
 801114c:	b2db      	uxtb	r3, r3
 801114e:	49ae      	ldr	r1, [pc, #696]	@ (8011408 <AesDecrypt_C+0x93c>)
 8011150:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011154:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011158:	405a      	eors	r2, r3
 801115a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801115c:	335c      	adds	r3, #92	@ 0x5c
 801115e:	681b      	ldr	r3, [r3, #0]
 8011160:	4053      	eors	r3, r2
 8011162:	62bb      	str	r3, [r7, #40]	@ 0x28
    DEC_ROUND_S_T(24); DEC_ROUND_T_S(24);
 8011164:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011166:	0e1b      	lsrs	r3, r3, #24
 8011168:	b2db      	uxtb	r3, r3
 801116a:	461a      	mov	r2, r3
 801116c:	4ba6      	ldr	r3, [pc, #664]	@ (8011408 <AesDecrypt_C+0x93c>)
 801116e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011172:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011174:	0c1b      	lsrs	r3, r3, #16
 8011176:	b2db      	uxtb	r3, r3
 8011178:	49a3      	ldr	r1, [pc, #652]	@ (8011408 <AesDecrypt_C+0x93c>)
 801117a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801117e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011182:	405a      	eors	r2, r3
 8011184:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011186:	0a1b      	lsrs	r3, r3, #8
 8011188:	b2db      	uxtb	r3, r3
 801118a:	499f      	ldr	r1, [pc, #636]	@ (8011408 <AesDecrypt_C+0x93c>)
 801118c:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011190:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011194:	405a      	eors	r2, r3
 8011196:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011198:	b2db      	uxtb	r3, r3
 801119a:	499b      	ldr	r1, [pc, #620]	@ (8011408 <AesDecrypt_C+0x93c>)
 801119c:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80111a0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80111a4:	405a      	eors	r2, r3
 80111a6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80111a8:	3360      	adds	r3, #96	@ 0x60
 80111aa:	681b      	ldr	r3, [r3, #0]
 80111ac:	4053      	eors	r3, r2
 80111ae:	623b      	str	r3, [r7, #32]
 80111b0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80111b2:	0e1b      	lsrs	r3, r3, #24
 80111b4:	b2db      	uxtb	r3, r3
 80111b6:	461a      	mov	r2, r3
 80111b8:	4b93      	ldr	r3, [pc, #588]	@ (8011408 <AesDecrypt_C+0x93c>)
 80111ba:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80111be:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80111c0:	0c1b      	lsrs	r3, r3, #16
 80111c2:	b2db      	uxtb	r3, r3
 80111c4:	4990      	ldr	r1, [pc, #576]	@ (8011408 <AesDecrypt_C+0x93c>)
 80111c6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80111ca:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80111ce:	405a      	eors	r2, r3
 80111d0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80111d2:	0a1b      	lsrs	r3, r3, #8
 80111d4:	b2db      	uxtb	r3, r3
 80111d6:	498c      	ldr	r1, [pc, #560]	@ (8011408 <AesDecrypt_C+0x93c>)
 80111d8:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80111dc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80111e0:	405a      	eors	r2, r3
 80111e2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80111e4:	b2db      	uxtb	r3, r3
 80111e6:	4988      	ldr	r1, [pc, #544]	@ (8011408 <AesDecrypt_C+0x93c>)
 80111e8:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80111ec:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80111f0:	405a      	eors	r2, r3
 80111f2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80111f4:	3364      	adds	r3, #100	@ 0x64
 80111f6:	681b      	ldr	r3, [r3, #0]
 80111f8:	4053      	eors	r3, r2
 80111fa:	61fb      	str	r3, [r7, #28]
 80111fc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80111fe:	0e1b      	lsrs	r3, r3, #24
 8011200:	b2db      	uxtb	r3, r3
 8011202:	461a      	mov	r2, r3
 8011204:	4b80      	ldr	r3, [pc, #512]	@ (8011408 <AesDecrypt_C+0x93c>)
 8011206:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801120a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801120c:	0c1b      	lsrs	r3, r3, #16
 801120e:	b2db      	uxtb	r3, r3
 8011210:	497d      	ldr	r1, [pc, #500]	@ (8011408 <AesDecrypt_C+0x93c>)
 8011212:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011216:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801121a:	405a      	eors	r2, r3
 801121c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801121e:	0a1b      	lsrs	r3, r3, #8
 8011220:	b2db      	uxtb	r3, r3
 8011222:	4979      	ldr	r1, [pc, #484]	@ (8011408 <AesDecrypt_C+0x93c>)
 8011224:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011228:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801122c:	405a      	eors	r2, r3
 801122e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011230:	b2db      	uxtb	r3, r3
 8011232:	4975      	ldr	r1, [pc, #468]	@ (8011408 <AesDecrypt_C+0x93c>)
 8011234:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011238:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801123c:	405a      	eors	r2, r3
 801123e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011240:	3368      	adds	r3, #104	@ 0x68
 8011242:	681b      	ldr	r3, [r3, #0]
 8011244:	4053      	eors	r3, r2
 8011246:	61bb      	str	r3, [r7, #24]
 8011248:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801124a:	0e1b      	lsrs	r3, r3, #24
 801124c:	b2db      	uxtb	r3, r3
 801124e:	461a      	mov	r2, r3
 8011250:	4b6d      	ldr	r3, [pc, #436]	@ (8011408 <AesDecrypt_C+0x93c>)
 8011252:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011256:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011258:	0c1b      	lsrs	r3, r3, #16
 801125a:	b2db      	uxtb	r3, r3
 801125c:	496a      	ldr	r1, [pc, #424]	@ (8011408 <AesDecrypt_C+0x93c>)
 801125e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011262:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011266:	405a      	eors	r2, r3
 8011268:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801126a:	0a1b      	lsrs	r3, r3, #8
 801126c:	b2db      	uxtb	r3, r3
 801126e:	4966      	ldr	r1, [pc, #408]	@ (8011408 <AesDecrypt_C+0x93c>)
 8011270:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011274:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011278:	405a      	eors	r2, r3
 801127a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801127c:	b2db      	uxtb	r3, r3
 801127e:	4962      	ldr	r1, [pc, #392]	@ (8011408 <AesDecrypt_C+0x93c>)
 8011280:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011284:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011288:	405a      	eors	r2, r3
 801128a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801128c:	336c      	adds	r3, #108	@ 0x6c
 801128e:	681b      	ldr	r3, [r3, #0]
 8011290:	4053      	eors	r3, r2
 8011292:	617b      	str	r3, [r7, #20]
 8011294:	6a3b      	ldr	r3, [r7, #32]
 8011296:	0e1b      	lsrs	r3, r3, #24
 8011298:	b2db      	uxtb	r3, r3
 801129a:	461a      	mov	r2, r3
 801129c:	4b5a      	ldr	r3, [pc, #360]	@ (8011408 <AesDecrypt_C+0x93c>)
 801129e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80112a2:	697b      	ldr	r3, [r7, #20]
 80112a4:	0c1b      	lsrs	r3, r3, #16
 80112a6:	b2db      	uxtb	r3, r3
 80112a8:	4957      	ldr	r1, [pc, #348]	@ (8011408 <AesDecrypt_C+0x93c>)
 80112aa:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80112ae:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80112b2:	405a      	eors	r2, r3
 80112b4:	69bb      	ldr	r3, [r7, #24]
 80112b6:	0a1b      	lsrs	r3, r3, #8
 80112b8:	b2db      	uxtb	r3, r3
 80112ba:	4953      	ldr	r1, [pc, #332]	@ (8011408 <AesDecrypt_C+0x93c>)
 80112bc:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80112c0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80112c4:	405a      	eors	r2, r3
 80112c6:	69fb      	ldr	r3, [r7, #28]
 80112c8:	b2db      	uxtb	r3, r3
 80112ca:	494f      	ldr	r1, [pc, #316]	@ (8011408 <AesDecrypt_C+0x93c>)
 80112cc:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80112d0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80112d4:	405a      	eors	r2, r3
 80112d6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80112d8:	3370      	adds	r3, #112	@ 0x70
 80112da:	681b      	ldr	r3, [r3, #0]
 80112dc:	4053      	eors	r3, r2
 80112de:	637b      	str	r3, [r7, #52]	@ 0x34
 80112e0:	69fb      	ldr	r3, [r7, #28]
 80112e2:	0e1b      	lsrs	r3, r3, #24
 80112e4:	b2db      	uxtb	r3, r3
 80112e6:	461a      	mov	r2, r3
 80112e8:	4b47      	ldr	r3, [pc, #284]	@ (8011408 <AesDecrypt_C+0x93c>)
 80112ea:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80112ee:	6a3b      	ldr	r3, [r7, #32]
 80112f0:	0c1b      	lsrs	r3, r3, #16
 80112f2:	b2db      	uxtb	r3, r3
 80112f4:	4944      	ldr	r1, [pc, #272]	@ (8011408 <AesDecrypt_C+0x93c>)
 80112f6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80112fa:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80112fe:	405a      	eors	r2, r3
 8011300:	697b      	ldr	r3, [r7, #20]
 8011302:	0a1b      	lsrs	r3, r3, #8
 8011304:	b2db      	uxtb	r3, r3
 8011306:	4940      	ldr	r1, [pc, #256]	@ (8011408 <AesDecrypt_C+0x93c>)
 8011308:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801130c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011310:	405a      	eors	r2, r3
 8011312:	69bb      	ldr	r3, [r7, #24]
 8011314:	b2db      	uxtb	r3, r3
 8011316:	493c      	ldr	r1, [pc, #240]	@ (8011408 <AesDecrypt_C+0x93c>)
 8011318:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801131c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011320:	405a      	eors	r2, r3
 8011322:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011324:	3374      	adds	r3, #116	@ 0x74
 8011326:	681b      	ldr	r3, [r3, #0]
 8011328:	4053      	eors	r3, r2
 801132a:	633b      	str	r3, [r7, #48]	@ 0x30
 801132c:	69bb      	ldr	r3, [r7, #24]
 801132e:	0e1b      	lsrs	r3, r3, #24
 8011330:	b2db      	uxtb	r3, r3
 8011332:	461a      	mov	r2, r3
 8011334:	4b34      	ldr	r3, [pc, #208]	@ (8011408 <AesDecrypt_C+0x93c>)
 8011336:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801133a:	69fb      	ldr	r3, [r7, #28]
 801133c:	0c1b      	lsrs	r3, r3, #16
 801133e:	b2db      	uxtb	r3, r3
 8011340:	4931      	ldr	r1, [pc, #196]	@ (8011408 <AesDecrypt_C+0x93c>)
 8011342:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011346:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801134a:	405a      	eors	r2, r3
 801134c:	6a3b      	ldr	r3, [r7, #32]
 801134e:	0a1b      	lsrs	r3, r3, #8
 8011350:	b2db      	uxtb	r3, r3
 8011352:	492d      	ldr	r1, [pc, #180]	@ (8011408 <AesDecrypt_C+0x93c>)
 8011354:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011358:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801135c:	405a      	eors	r2, r3
 801135e:	697b      	ldr	r3, [r7, #20]
 8011360:	b2db      	uxtb	r3, r3
 8011362:	4929      	ldr	r1, [pc, #164]	@ (8011408 <AesDecrypt_C+0x93c>)
 8011364:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011368:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801136c:	405a      	eors	r2, r3
 801136e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011370:	3378      	adds	r3, #120	@ 0x78
 8011372:	681b      	ldr	r3, [r3, #0]
 8011374:	4053      	eors	r3, r2
 8011376:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8011378:	697b      	ldr	r3, [r7, #20]
 801137a:	0e1b      	lsrs	r3, r3, #24
 801137c:	b2db      	uxtb	r3, r3
 801137e:	461a      	mov	r2, r3
 8011380:	4b21      	ldr	r3, [pc, #132]	@ (8011408 <AesDecrypt_C+0x93c>)
 8011382:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011386:	69bb      	ldr	r3, [r7, #24]
 8011388:	0c1b      	lsrs	r3, r3, #16
 801138a:	b2db      	uxtb	r3, r3
 801138c:	491e      	ldr	r1, [pc, #120]	@ (8011408 <AesDecrypt_C+0x93c>)
 801138e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011392:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011396:	405a      	eors	r2, r3
 8011398:	69fb      	ldr	r3, [r7, #28]
 801139a:	0a1b      	lsrs	r3, r3, #8
 801139c:	b2db      	uxtb	r3, r3
 801139e:	491a      	ldr	r1, [pc, #104]	@ (8011408 <AesDecrypt_C+0x93c>)
 80113a0:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80113a4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80113a8:	405a      	eors	r2, r3
 80113aa:	6a3b      	ldr	r3, [r7, #32]
 80113ac:	b2db      	uxtb	r3, r3
 80113ae:	4916      	ldr	r1, [pc, #88]	@ (8011408 <AesDecrypt_C+0x93c>)
 80113b0:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80113b4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80113b8:	405a      	eors	r2, r3
 80113ba:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80113bc:	337c      	adds	r3, #124	@ 0x7c
 80113be:	681b      	ldr	r3, [r3, #0]
 80113c0:	4053      	eors	r3, r2
 80113c2:	62bb      	str	r3, [r7, #40]	@ 0x28
    DEC_ROUND_S_T(32); DEC_ROUND_T_S(32);
 80113c4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80113c6:	0e1b      	lsrs	r3, r3, #24
 80113c8:	b2db      	uxtb	r3, r3
 80113ca:	461a      	mov	r2, r3
 80113cc:	4b0e      	ldr	r3, [pc, #56]	@ (8011408 <AesDecrypt_C+0x93c>)
 80113ce:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80113d2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80113d4:	0c1b      	lsrs	r3, r3, #16
 80113d6:	b2db      	uxtb	r3, r3
 80113d8:	490b      	ldr	r1, [pc, #44]	@ (8011408 <AesDecrypt_C+0x93c>)
 80113da:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80113de:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80113e2:	405a      	eors	r2, r3
 80113e4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80113e6:	0a1b      	lsrs	r3, r3, #8
 80113e8:	b2db      	uxtb	r3, r3
 80113ea:	4907      	ldr	r1, [pc, #28]	@ (8011408 <AesDecrypt_C+0x93c>)
 80113ec:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80113f0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80113f4:	405a      	eors	r2, r3
 80113f6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80113f8:	b2db      	uxtb	r3, r3
 80113fa:	4903      	ldr	r1, [pc, #12]	@ (8011408 <AesDecrypt_C+0x93c>)
 80113fc:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011400:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011404:	405a      	eors	r2, r3
 8011406:	e001      	b.n	801140c <AesDecrypt_C+0x940>
 8011408:	08032494 	.word	0x08032494
 801140c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801140e:	3380      	adds	r3, #128	@ 0x80
 8011410:	681b      	ldr	r3, [r3, #0]
 8011412:	4053      	eors	r3, r2
 8011414:	623b      	str	r3, [r7, #32]
 8011416:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011418:	0e1b      	lsrs	r3, r3, #24
 801141a:	b2db      	uxtb	r3, r3
 801141c:	461a      	mov	r2, r3
 801141e:	4bb6      	ldr	r3, [pc, #728]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 8011420:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011424:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011426:	0c1b      	lsrs	r3, r3, #16
 8011428:	b2db      	uxtb	r3, r3
 801142a:	49b3      	ldr	r1, [pc, #716]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 801142c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011430:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011434:	405a      	eors	r2, r3
 8011436:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011438:	0a1b      	lsrs	r3, r3, #8
 801143a:	b2db      	uxtb	r3, r3
 801143c:	49ae      	ldr	r1, [pc, #696]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 801143e:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011442:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011446:	405a      	eors	r2, r3
 8011448:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801144a:	b2db      	uxtb	r3, r3
 801144c:	49aa      	ldr	r1, [pc, #680]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 801144e:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011452:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011456:	405a      	eors	r2, r3
 8011458:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801145a:	3384      	adds	r3, #132	@ 0x84
 801145c:	681b      	ldr	r3, [r3, #0]
 801145e:	4053      	eors	r3, r2
 8011460:	61fb      	str	r3, [r7, #28]
 8011462:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011464:	0e1b      	lsrs	r3, r3, #24
 8011466:	b2db      	uxtb	r3, r3
 8011468:	461a      	mov	r2, r3
 801146a:	4ba3      	ldr	r3, [pc, #652]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 801146c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011470:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011472:	0c1b      	lsrs	r3, r3, #16
 8011474:	b2db      	uxtb	r3, r3
 8011476:	49a0      	ldr	r1, [pc, #640]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 8011478:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801147c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011480:	405a      	eors	r2, r3
 8011482:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011484:	0a1b      	lsrs	r3, r3, #8
 8011486:	b2db      	uxtb	r3, r3
 8011488:	499b      	ldr	r1, [pc, #620]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 801148a:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801148e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011492:	405a      	eors	r2, r3
 8011494:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011496:	b2db      	uxtb	r3, r3
 8011498:	4997      	ldr	r1, [pc, #604]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 801149a:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801149e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80114a2:	405a      	eors	r2, r3
 80114a4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80114a6:	3388      	adds	r3, #136	@ 0x88
 80114a8:	681b      	ldr	r3, [r3, #0]
 80114aa:	4053      	eors	r3, r2
 80114ac:	61bb      	str	r3, [r7, #24]
 80114ae:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80114b0:	0e1b      	lsrs	r3, r3, #24
 80114b2:	b2db      	uxtb	r3, r3
 80114b4:	461a      	mov	r2, r3
 80114b6:	4b90      	ldr	r3, [pc, #576]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 80114b8:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80114bc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80114be:	0c1b      	lsrs	r3, r3, #16
 80114c0:	b2db      	uxtb	r3, r3
 80114c2:	498d      	ldr	r1, [pc, #564]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 80114c4:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80114c8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80114cc:	405a      	eors	r2, r3
 80114ce:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80114d0:	0a1b      	lsrs	r3, r3, #8
 80114d2:	b2db      	uxtb	r3, r3
 80114d4:	4988      	ldr	r1, [pc, #544]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 80114d6:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80114da:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80114de:	405a      	eors	r2, r3
 80114e0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80114e2:	b2db      	uxtb	r3, r3
 80114e4:	4984      	ldr	r1, [pc, #528]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 80114e6:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80114ea:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80114ee:	405a      	eors	r2, r3
 80114f0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80114f2:	338c      	adds	r3, #140	@ 0x8c
 80114f4:	681b      	ldr	r3, [r3, #0]
 80114f6:	4053      	eors	r3, r2
 80114f8:	617b      	str	r3, [r7, #20]
 80114fa:	6a3b      	ldr	r3, [r7, #32]
 80114fc:	0e1b      	lsrs	r3, r3, #24
 80114fe:	b2db      	uxtb	r3, r3
 8011500:	461a      	mov	r2, r3
 8011502:	4b7d      	ldr	r3, [pc, #500]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 8011504:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011508:	697b      	ldr	r3, [r7, #20]
 801150a:	0c1b      	lsrs	r3, r3, #16
 801150c:	b2db      	uxtb	r3, r3
 801150e:	497a      	ldr	r1, [pc, #488]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 8011510:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011514:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011518:	405a      	eors	r2, r3
 801151a:	69bb      	ldr	r3, [r7, #24]
 801151c:	0a1b      	lsrs	r3, r3, #8
 801151e:	b2db      	uxtb	r3, r3
 8011520:	4975      	ldr	r1, [pc, #468]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 8011522:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011526:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801152a:	405a      	eors	r2, r3
 801152c:	69fb      	ldr	r3, [r7, #28]
 801152e:	b2db      	uxtb	r3, r3
 8011530:	4971      	ldr	r1, [pc, #452]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 8011532:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011536:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801153a:	405a      	eors	r2, r3
 801153c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801153e:	3390      	adds	r3, #144	@ 0x90
 8011540:	681b      	ldr	r3, [r3, #0]
 8011542:	4053      	eors	r3, r2
 8011544:	637b      	str	r3, [r7, #52]	@ 0x34
 8011546:	69fb      	ldr	r3, [r7, #28]
 8011548:	0e1b      	lsrs	r3, r3, #24
 801154a:	b2db      	uxtb	r3, r3
 801154c:	461a      	mov	r2, r3
 801154e:	4b6a      	ldr	r3, [pc, #424]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 8011550:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011554:	6a3b      	ldr	r3, [r7, #32]
 8011556:	0c1b      	lsrs	r3, r3, #16
 8011558:	b2db      	uxtb	r3, r3
 801155a:	4967      	ldr	r1, [pc, #412]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 801155c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011560:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011564:	405a      	eors	r2, r3
 8011566:	697b      	ldr	r3, [r7, #20]
 8011568:	0a1b      	lsrs	r3, r3, #8
 801156a:	b2db      	uxtb	r3, r3
 801156c:	4962      	ldr	r1, [pc, #392]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 801156e:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011572:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011576:	405a      	eors	r2, r3
 8011578:	69bb      	ldr	r3, [r7, #24]
 801157a:	b2db      	uxtb	r3, r3
 801157c:	495e      	ldr	r1, [pc, #376]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 801157e:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011582:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011586:	405a      	eors	r2, r3
 8011588:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801158a:	3394      	adds	r3, #148	@ 0x94
 801158c:	681b      	ldr	r3, [r3, #0]
 801158e:	4053      	eors	r3, r2
 8011590:	633b      	str	r3, [r7, #48]	@ 0x30
 8011592:	69bb      	ldr	r3, [r7, #24]
 8011594:	0e1b      	lsrs	r3, r3, #24
 8011596:	b2db      	uxtb	r3, r3
 8011598:	461a      	mov	r2, r3
 801159a:	4b57      	ldr	r3, [pc, #348]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 801159c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80115a0:	69fb      	ldr	r3, [r7, #28]
 80115a2:	0c1b      	lsrs	r3, r3, #16
 80115a4:	b2db      	uxtb	r3, r3
 80115a6:	4954      	ldr	r1, [pc, #336]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 80115a8:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80115ac:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80115b0:	405a      	eors	r2, r3
 80115b2:	6a3b      	ldr	r3, [r7, #32]
 80115b4:	0a1b      	lsrs	r3, r3, #8
 80115b6:	b2db      	uxtb	r3, r3
 80115b8:	494f      	ldr	r1, [pc, #316]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 80115ba:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80115be:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80115c2:	405a      	eors	r2, r3
 80115c4:	697b      	ldr	r3, [r7, #20]
 80115c6:	b2db      	uxtb	r3, r3
 80115c8:	494b      	ldr	r1, [pc, #300]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 80115ca:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80115ce:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80115d2:	405a      	eors	r2, r3
 80115d4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80115d6:	3398      	adds	r3, #152	@ 0x98
 80115d8:	681b      	ldr	r3, [r3, #0]
 80115da:	4053      	eors	r3, r2
 80115dc:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80115de:	697b      	ldr	r3, [r7, #20]
 80115e0:	0e1b      	lsrs	r3, r3, #24
 80115e2:	b2db      	uxtb	r3, r3
 80115e4:	461a      	mov	r2, r3
 80115e6:	4b44      	ldr	r3, [pc, #272]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 80115e8:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80115ec:	69bb      	ldr	r3, [r7, #24]
 80115ee:	0c1b      	lsrs	r3, r3, #16
 80115f0:	b2db      	uxtb	r3, r3
 80115f2:	4941      	ldr	r1, [pc, #260]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 80115f4:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80115f8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80115fc:	405a      	eors	r2, r3
 80115fe:	69fb      	ldr	r3, [r7, #28]
 8011600:	0a1b      	lsrs	r3, r3, #8
 8011602:	b2db      	uxtb	r3, r3
 8011604:	493c      	ldr	r1, [pc, #240]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 8011606:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801160a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801160e:	405a      	eors	r2, r3
 8011610:	6a3b      	ldr	r3, [r7, #32]
 8011612:	b2db      	uxtb	r3, r3
 8011614:	4938      	ldr	r1, [pc, #224]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 8011616:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801161a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801161e:	405a      	eors	r2, r3
 8011620:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011622:	339c      	adds	r3, #156	@ 0x9c
 8011624:	681b      	ldr	r3, [r3, #0]
 8011626:	4053      	eors	r3, r2
 8011628:	62bb      	str	r3, [r7, #40]	@ 0x28
    if (r > 5) {
 801162a:	683b      	ldr	r3, [r7, #0]
 801162c:	2b05      	cmp	r3, #5
 801162e:	f240 826a 	bls.w	8011b06 <AesDecrypt_C+0x103a>
        DEC_ROUND_S_T(40); DEC_ROUND_T_S(40);
 8011632:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011634:	0e1b      	lsrs	r3, r3, #24
 8011636:	b2db      	uxtb	r3, r3
 8011638:	461a      	mov	r2, r3
 801163a:	4b2f      	ldr	r3, [pc, #188]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 801163c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011640:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011642:	0c1b      	lsrs	r3, r3, #16
 8011644:	b2db      	uxtb	r3, r3
 8011646:	492c      	ldr	r1, [pc, #176]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 8011648:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801164c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011650:	405a      	eors	r2, r3
 8011652:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011654:	0a1b      	lsrs	r3, r3, #8
 8011656:	b2db      	uxtb	r3, r3
 8011658:	4927      	ldr	r1, [pc, #156]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 801165a:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801165e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011662:	405a      	eors	r2, r3
 8011664:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011666:	b2db      	uxtb	r3, r3
 8011668:	4923      	ldr	r1, [pc, #140]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 801166a:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801166e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011672:	405a      	eors	r2, r3
 8011674:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011676:	33a0      	adds	r3, #160	@ 0xa0
 8011678:	681b      	ldr	r3, [r3, #0]
 801167a:	4053      	eors	r3, r2
 801167c:	623b      	str	r3, [r7, #32]
 801167e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011680:	0e1b      	lsrs	r3, r3, #24
 8011682:	b2db      	uxtb	r3, r3
 8011684:	461a      	mov	r2, r3
 8011686:	4b1c      	ldr	r3, [pc, #112]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 8011688:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801168c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801168e:	0c1b      	lsrs	r3, r3, #16
 8011690:	b2db      	uxtb	r3, r3
 8011692:	4919      	ldr	r1, [pc, #100]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 8011694:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011698:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801169c:	405a      	eors	r2, r3
 801169e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80116a0:	0a1b      	lsrs	r3, r3, #8
 80116a2:	b2db      	uxtb	r3, r3
 80116a4:	4914      	ldr	r1, [pc, #80]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 80116a6:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80116aa:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80116ae:	405a      	eors	r2, r3
 80116b0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80116b2:	b2db      	uxtb	r3, r3
 80116b4:	4910      	ldr	r1, [pc, #64]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 80116b6:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80116ba:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80116be:	405a      	eors	r2, r3
 80116c0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80116c2:	33a4      	adds	r3, #164	@ 0xa4
 80116c4:	681b      	ldr	r3, [r3, #0]
 80116c6:	4053      	eors	r3, r2
 80116c8:	61fb      	str	r3, [r7, #28]
 80116ca:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80116cc:	0e1b      	lsrs	r3, r3, #24
 80116ce:	b2db      	uxtb	r3, r3
 80116d0:	461a      	mov	r2, r3
 80116d2:	4b09      	ldr	r3, [pc, #36]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 80116d4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80116d8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80116da:	0c1b      	lsrs	r3, r3, #16
 80116dc:	b2db      	uxtb	r3, r3
 80116de:	4906      	ldr	r1, [pc, #24]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 80116e0:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80116e4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80116e8:	405a      	eors	r2, r3
 80116ea:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80116ec:	0a1b      	lsrs	r3, r3, #8
 80116ee:	b2db      	uxtb	r3, r3
 80116f0:	4901      	ldr	r1, [pc, #4]	@ (80116f8 <AesDecrypt_C+0xc2c>)
 80116f2:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80116f6:	e001      	b.n	80116fc <AesDecrypt_C+0xc30>
 80116f8:	08032494 	.word	0x08032494
 80116fc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011700:	405a      	eors	r2, r3
 8011702:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011704:	b2db      	uxtb	r3, r3
 8011706:	49b6      	ldr	r1, [pc, #728]	@ (80119e0 <AesDecrypt_C+0xf14>)
 8011708:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801170c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011710:	405a      	eors	r2, r3
 8011712:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011714:	33a8      	adds	r3, #168	@ 0xa8
 8011716:	681b      	ldr	r3, [r3, #0]
 8011718:	4053      	eors	r3, r2
 801171a:	61bb      	str	r3, [r7, #24]
 801171c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801171e:	0e1b      	lsrs	r3, r3, #24
 8011720:	b2db      	uxtb	r3, r3
 8011722:	461a      	mov	r2, r3
 8011724:	4bae      	ldr	r3, [pc, #696]	@ (80119e0 <AesDecrypt_C+0xf14>)
 8011726:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801172a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801172c:	0c1b      	lsrs	r3, r3, #16
 801172e:	b2db      	uxtb	r3, r3
 8011730:	49ab      	ldr	r1, [pc, #684]	@ (80119e0 <AesDecrypt_C+0xf14>)
 8011732:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011736:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801173a:	405a      	eors	r2, r3
 801173c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801173e:	0a1b      	lsrs	r3, r3, #8
 8011740:	b2db      	uxtb	r3, r3
 8011742:	49a7      	ldr	r1, [pc, #668]	@ (80119e0 <AesDecrypt_C+0xf14>)
 8011744:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011748:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801174c:	405a      	eors	r2, r3
 801174e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011750:	b2db      	uxtb	r3, r3
 8011752:	49a3      	ldr	r1, [pc, #652]	@ (80119e0 <AesDecrypt_C+0xf14>)
 8011754:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011758:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801175c:	405a      	eors	r2, r3
 801175e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011760:	33ac      	adds	r3, #172	@ 0xac
 8011762:	681b      	ldr	r3, [r3, #0]
 8011764:	4053      	eors	r3, r2
 8011766:	617b      	str	r3, [r7, #20]
 8011768:	6a3b      	ldr	r3, [r7, #32]
 801176a:	0e1b      	lsrs	r3, r3, #24
 801176c:	b2db      	uxtb	r3, r3
 801176e:	461a      	mov	r2, r3
 8011770:	4b9b      	ldr	r3, [pc, #620]	@ (80119e0 <AesDecrypt_C+0xf14>)
 8011772:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011776:	697b      	ldr	r3, [r7, #20]
 8011778:	0c1b      	lsrs	r3, r3, #16
 801177a:	b2db      	uxtb	r3, r3
 801177c:	4998      	ldr	r1, [pc, #608]	@ (80119e0 <AesDecrypt_C+0xf14>)
 801177e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011782:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011786:	405a      	eors	r2, r3
 8011788:	69bb      	ldr	r3, [r7, #24]
 801178a:	0a1b      	lsrs	r3, r3, #8
 801178c:	b2db      	uxtb	r3, r3
 801178e:	4994      	ldr	r1, [pc, #592]	@ (80119e0 <AesDecrypt_C+0xf14>)
 8011790:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011794:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011798:	405a      	eors	r2, r3
 801179a:	69fb      	ldr	r3, [r7, #28]
 801179c:	b2db      	uxtb	r3, r3
 801179e:	4990      	ldr	r1, [pc, #576]	@ (80119e0 <AesDecrypt_C+0xf14>)
 80117a0:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80117a4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80117a8:	405a      	eors	r2, r3
 80117aa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80117ac:	33b0      	adds	r3, #176	@ 0xb0
 80117ae:	681b      	ldr	r3, [r3, #0]
 80117b0:	4053      	eors	r3, r2
 80117b2:	637b      	str	r3, [r7, #52]	@ 0x34
 80117b4:	69fb      	ldr	r3, [r7, #28]
 80117b6:	0e1b      	lsrs	r3, r3, #24
 80117b8:	b2db      	uxtb	r3, r3
 80117ba:	461a      	mov	r2, r3
 80117bc:	4b88      	ldr	r3, [pc, #544]	@ (80119e0 <AesDecrypt_C+0xf14>)
 80117be:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80117c2:	6a3b      	ldr	r3, [r7, #32]
 80117c4:	0c1b      	lsrs	r3, r3, #16
 80117c6:	b2db      	uxtb	r3, r3
 80117c8:	4985      	ldr	r1, [pc, #532]	@ (80119e0 <AesDecrypt_C+0xf14>)
 80117ca:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80117ce:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80117d2:	405a      	eors	r2, r3
 80117d4:	697b      	ldr	r3, [r7, #20]
 80117d6:	0a1b      	lsrs	r3, r3, #8
 80117d8:	b2db      	uxtb	r3, r3
 80117da:	4981      	ldr	r1, [pc, #516]	@ (80119e0 <AesDecrypt_C+0xf14>)
 80117dc:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80117e0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80117e4:	405a      	eors	r2, r3
 80117e6:	69bb      	ldr	r3, [r7, #24]
 80117e8:	b2db      	uxtb	r3, r3
 80117ea:	497d      	ldr	r1, [pc, #500]	@ (80119e0 <AesDecrypt_C+0xf14>)
 80117ec:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80117f0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80117f4:	405a      	eors	r2, r3
 80117f6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80117f8:	33b4      	adds	r3, #180	@ 0xb4
 80117fa:	681b      	ldr	r3, [r3, #0]
 80117fc:	4053      	eors	r3, r2
 80117fe:	633b      	str	r3, [r7, #48]	@ 0x30
 8011800:	69bb      	ldr	r3, [r7, #24]
 8011802:	0e1b      	lsrs	r3, r3, #24
 8011804:	b2db      	uxtb	r3, r3
 8011806:	461a      	mov	r2, r3
 8011808:	4b75      	ldr	r3, [pc, #468]	@ (80119e0 <AesDecrypt_C+0xf14>)
 801180a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801180e:	69fb      	ldr	r3, [r7, #28]
 8011810:	0c1b      	lsrs	r3, r3, #16
 8011812:	b2db      	uxtb	r3, r3
 8011814:	4972      	ldr	r1, [pc, #456]	@ (80119e0 <AesDecrypt_C+0xf14>)
 8011816:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801181a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801181e:	405a      	eors	r2, r3
 8011820:	6a3b      	ldr	r3, [r7, #32]
 8011822:	0a1b      	lsrs	r3, r3, #8
 8011824:	b2db      	uxtb	r3, r3
 8011826:	496e      	ldr	r1, [pc, #440]	@ (80119e0 <AesDecrypt_C+0xf14>)
 8011828:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801182c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011830:	405a      	eors	r2, r3
 8011832:	697b      	ldr	r3, [r7, #20]
 8011834:	b2db      	uxtb	r3, r3
 8011836:	496a      	ldr	r1, [pc, #424]	@ (80119e0 <AesDecrypt_C+0xf14>)
 8011838:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801183c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011840:	405a      	eors	r2, r3
 8011842:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011844:	33b8      	adds	r3, #184	@ 0xb8
 8011846:	681b      	ldr	r3, [r3, #0]
 8011848:	4053      	eors	r3, r2
 801184a:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801184c:	697b      	ldr	r3, [r7, #20]
 801184e:	0e1b      	lsrs	r3, r3, #24
 8011850:	b2db      	uxtb	r3, r3
 8011852:	461a      	mov	r2, r3
 8011854:	4b62      	ldr	r3, [pc, #392]	@ (80119e0 <AesDecrypt_C+0xf14>)
 8011856:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801185a:	69bb      	ldr	r3, [r7, #24]
 801185c:	0c1b      	lsrs	r3, r3, #16
 801185e:	b2db      	uxtb	r3, r3
 8011860:	495f      	ldr	r1, [pc, #380]	@ (80119e0 <AesDecrypt_C+0xf14>)
 8011862:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011866:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801186a:	405a      	eors	r2, r3
 801186c:	69fb      	ldr	r3, [r7, #28]
 801186e:	0a1b      	lsrs	r3, r3, #8
 8011870:	b2db      	uxtb	r3, r3
 8011872:	495b      	ldr	r1, [pc, #364]	@ (80119e0 <AesDecrypt_C+0xf14>)
 8011874:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011878:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801187c:	405a      	eors	r2, r3
 801187e:	6a3b      	ldr	r3, [r7, #32]
 8011880:	b2db      	uxtb	r3, r3
 8011882:	4957      	ldr	r1, [pc, #348]	@ (80119e0 <AesDecrypt_C+0xf14>)
 8011884:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011888:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801188c:	405a      	eors	r2, r3
 801188e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011890:	33bc      	adds	r3, #188	@ 0xbc
 8011892:	681b      	ldr	r3, [r3, #0]
 8011894:	4053      	eors	r3, r2
 8011896:	62bb      	str	r3, [r7, #40]	@ 0x28
        if (r > 6) {
 8011898:	683b      	ldr	r3, [r7, #0]
 801189a:	2b06      	cmp	r3, #6
 801189c:	f240 8133 	bls.w	8011b06 <AesDecrypt_C+0x103a>
            DEC_ROUND_S_T(48); DEC_ROUND_T_S(48);
 80118a0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80118a2:	0e1b      	lsrs	r3, r3, #24
 80118a4:	b2db      	uxtb	r3, r3
 80118a6:	461a      	mov	r2, r3
 80118a8:	4b4d      	ldr	r3, [pc, #308]	@ (80119e0 <AesDecrypt_C+0xf14>)
 80118aa:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80118ae:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80118b0:	0c1b      	lsrs	r3, r3, #16
 80118b2:	b2db      	uxtb	r3, r3
 80118b4:	494a      	ldr	r1, [pc, #296]	@ (80119e0 <AesDecrypt_C+0xf14>)
 80118b6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80118ba:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80118be:	405a      	eors	r2, r3
 80118c0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80118c2:	0a1b      	lsrs	r3, r3, #8
 80118c4:	b2db      	uxtb	r3, r3
 80118c6:	4946      	ldr	r1, [pc, #280]	@ (80119e0 <AesDecrypt_C+0xf14>)
 80118c8:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80118cc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80118d0:	405a      	eors	r2, r3
 80118d2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80118d4:	b2db      	uxtb	r3, r3
 80118d6:	4942      	ldr	r1, [pc, #264]	@ (80119e0 <AesDecrypt_C+0xf14>)
 80118d8:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80118dc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80118e0:	405a      	eors	r2, r3
 80118e2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80118e4:	33c0      	adds	r3, #192	@ 0xc0
 80118e6:	681b      	ldr	r3, [r3, #0]
 80118e8:	4053      	eors	r3, r2
 80118ea:	623b      	str	r3, [r7, #32]
 80118ec:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80118ee:	0e1b      	lsrs	r3, r3, #24
 80118f0:	b2db      	uxtb	r3, r3
 80118f2:	461a      	mov	r2, r3
 80118f4:	4b3a      	ldr	r3, [pc, #232]	@ (80119e0 <AesDecrypt_C+0xf14>)
 80118f6:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80118fa:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80118fc:	0c1b      	lsrs	r3, r3, #16
 80118fe:	b2db      	uxtb	r3, r3
 8011900:	4937      	ldr	r1, [pc, #220]	@ (80119e0 <AesDecrypt_C+0xf14>)
 8011902:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011906:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801190a:	405a      	eors	r2, r3
 801190c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801190e:	0a1b      	lsrs	r3, r3, #8
 8011910:	b2db      	uxtb	r3, r3
 8011912:	4933      	ldr	r1, [pc, #204]	@ (80119e0 <AesDecrypt_C+0xf14>)
 8011914:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011918:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801191c:	405a      	eors	r2, r3
 801191e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011920:	b2db      	uxtb	r3, r3
 8011922:	492f      	ldr	r1, [pc, #188]	@ (80119e0 <AesDecrypt_C+0xf14>)
 8011924:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011928:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801192c:	405a      	eors	r2, r3
 801192e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011930:	33c4      	adds	r3, #196	@ 0xc4
 8011932:	681b      	ldr	r3, [r3, #0]
 8011934:	4053      	eors	r3, r2
 8011936:	61fb      	str	r3, [r7, #28]
 8011938:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801193a:	0e1b      	lsrs	r3, r3, #24
 801193c:	b2db      	uxtb	r3, r3
 801193e:	461a      	mov	r2, r3
 8011940:	4b27      	ldr	r3, [pc, #156]	@ (80119e0 <AesDecrypt_C+0xf14>)
 8011942:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011946:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011948:	0c1b      	lsrs	r3, r3, #16
 801194a:	b2db      	uxtb	r3, r3
 801194c:	4924      	ldr	r1, [pc, #144]	@ (80119e0 <AesDecrypt_C+0xf14>)
 801194e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011952:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011956:	405a      	eors	r2, r3
 8011958:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801195a:	0a1b      	lsrs	r3, r3, #8
 801195c:	b2db      	uxtb	r3, r3
 801195e:	4920      	ldr	r1, [pc, #128]	@ (80119e0 <AesDecrypt_C+0xf14>)
 8011960:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011964:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011968:	405a      	eors	r2, r3
 801196a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801196c:	b2db      	uxtb	r3, r3
 801196e:	491c      	ldr	r1, [pc, #112]	@ (80119e0 <AesDecrypt_C+0xf14>)
 8011970:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011974:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011978:	405a      	eors	r2, r3
 801197a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801197c:	33c8      	adds	r3, #200	@ 0xc8
 801197e:	681b      	ldr	r3, [r3, #0]
 8011980:	4053      	eors	r3, r2
 8011982:	61bb      	str	r3, [r7, #24]
 8011984:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011986:	0e1b      	lsrs	r3, r3, #24
 8011988:	b2db      	uxtb	r3, r3
 801198a:	461a      	mov	r2, r3
 801198c:	4b14      	ldr	r3, [pc, #80]	@ (80119e0 <AesDecrypt_C+0xf14>)
 801198e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011992:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011994:	0c1b      	lsrs	r3, r3, #16
 8011996:	b2db      	uxtb	r3, r3
 8011998:	4911      	ldr	r1, [pc, #68]	@ (80119e0 <AesDecrypt_C+0xf14>)
 801199a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801199e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80119a2:	405a      	eors	r2, r3
 80119a4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80119a6:	0a1b      	lsrs	r3, r3, #8
 80119a8:	b2db      	uxtb	r3, r3
 80119aa:	490d      	ldr	r1, [pc, #52]	@ (80119e0 <AesDecrypt_C+0xf14>)
 80119ac:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80119b0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80119b4:	405a      	eors	r2, r3
 80119b6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80119b8:	b2db      	uxtb	r3, r3
 80119ba:	4909      	ldr	r1, [pc, #36]	@ (80119e0 <AesDecrypt_C+0xf14>)
 80119bc:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80119c0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80119c4:	405a      	eors	r2, r3
 80119c6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80119c8:	33cc      	adds	r3, #204	@ 0xcc
 80119ca:	681b      	ldr	r3, [r3, #0]
 80119cc:	4053      	eors	r3, r2
 80119ce:	617b      	str	r3, [r7, #20]
 80119d0:	6a3b      	ldr	r3, [r7, #32]
 80119d2:	0e1b      	lsrs	r3, r3, #24
 80119d4:	b2db      	uxtb	r3, r3
 80119d6:	461a      	mov	r2, r3
 80119d8:	4b01      	ldr	r3, [pc, #4]	@ (80119e0 <AesDecrypt_C+0xf14>)
 80119da:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80119de:	e001      	b.n	80119e4 <AesDecrypt_C+0xf18>
 80119e0:	08032494 	.word	0x08032494
 80119e4:	697b      	ldr	r3, [r7, #20]
 80119e6:	0c1b      	lsrs	r3, r3, #16
 80119e8:	b2db      	uxtb	r3, r3
 80119ea:	49a5      	ldr	r1, [pc, #660]	@ (8011c80 <AesDecrypt_C+0x11b4>)
 80119ec:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80119f0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80119f4:	405a      	eors	r2, r3
 80119f6:	69bb      	ldr	r3, [r7, #24]
 80119f8:	0a1b      	lsrs	r3, r3, #8
 80119fa:	b2db      	uxtb	r3, r3
 80119fc:	49a0      	ldr	r1, [pc, #640]	@ (8011c80 <AesDecrypt_C+0x11b4>)
 80119fe:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011a02:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011a06:	405a      	eors	r2, r3
 8011a08:	69fb      	ldr	r3, [r7, #28]
 8011a0a:	b2db      	uxtb	r3, r3
 8011a0c:	499c      	ldr	r1, [pc, #624]	@ (8011c80 <AesDecrypt_C+0x11b4>)
 8011a0e:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011a12:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011a16:	405a      	eors	r2, r3
 8011a18:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011a1a:	33d0      	adds	r3, #208	@ 0xd0
 8011a1c:	681b      	ldr	r3, [r3, #0]
 8011a1e:	4053      	eors	r3, r2
 8011a20:	637b      	str	r3, [r7, #52]	@ 0x34
 8011a22:	69fb      	ldr	r3, [r7, #28]
 8011a24:	0e1b      	lsrs	r3, r3, #24
 8011a26:	b2db      	uxtb	r3, r3
 8011a28:	461a      	mov	r2, r3
 8011a2a:	4b95      	ldr	r3, [pc, #596]	@ (8011c80 <AesDecrypt_C+0x11b4>)
 8011a2c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011a30:	6a3b      	ldr	r3, [r7, #32]
 8011a32:	0c1b      	lsrs	r3, r3, #16
 8011a34:	b2db      	uxtb	r3, r3
 8011a36:	4992      	ldr	r1, [pc, #584]	@ (8011c80 <AesDecrypt_C+0x11b4>)
 8011a38:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011a3c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011a40:	405a      	eors	r2, r3
 8011a42:	697b      	ldr	r3, [r7, #20]
 8011a44:	0a1b      	lsrs	r3, r3, #8
 8011a46:	b2db      	uxtb	r3, r3
 8011a48:	498d      	ldr	r1, [pc, #564]	@ (8011c80 <AesDecrypt_C+0x11b4>)
 8011a4a:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011a4e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011a52:	405a      	eors	r2, r3
 8011a54:	69bb      	ldr	r3, [r7, #24]
 8011a56:	b2db      	uxtb	r3, r3
 8011a58:	4989      	ldr	r1, [pc, #548]	@ (8011c80 <AesDecrypt_C+0x11b4>)
 8011a5a:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011a5e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011a62:	405a      	eors	r2, r3
 8011a64:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011a66:	33d4      	adds	r3, #212	@ 0xd4
 8011a68:	681b      	ldr	r3, [r3, #0]
 8011a6a:	4053      	eors	r3, r2
 8011a6c:	633b      	str	r3, [r7, #48]	@ 0x30
 8011a6e:	69bb      	ldr	r3, [r7, #24]
 8011a70:	0e1b      	lsrs	r3, r3, #24
 8011a72:	b2db      	uxtb	r3, r3
 8011a74:	461a      	mov	r2, r3
 8011a76:	4b82      	ldr	r3, [pc, #520]	@ (8011c80 <AesDecrypt_C+0x11b4>)
 8011a78:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011a7c:	69fb      	ldr	r3, [r7, #28]
 8011a7e:	0c1b      	lsrs	r3, r3, #16
 8011a80:	b2db      	uxtb	r3, r3
 8011a82:	497f      	ldr	r1, [pc, #508]	@ (8011c80 <AesDecrypt_C+0x11b4>)
 8011a84:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011a88:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011a8c:	405a      	eors	r2, r3
 8011a8e:	6a3b      	ldr	r3, [r7, #32]
 8011a90:	0a1b      	lsrs	r3, r3, #8
 8011a92:	b2db      	uxtb	r3, r3
 8011a94:	497a      	ldr	r1, [pc, #488]	@ (8011c80 <AesDecrypt_C+0x11b4>)
 8011a96:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011a9a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011a9e:	405a      	eors	r2, r3
 8011aa0:	697b      	ldr	r3, [r7, #20]
 8011aa2:	b2db      	uxtb	r3, r3
 8011aa4:	4976      	ldr	r1, [pc, #472]	@ (8011c80 <AesDecrypt_C+0x11b4>)
 8011aa6:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011aaa:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011aae:	405a      	eors	r2, r3
 8011ab0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011ab2:	33d8      	adds	r3, #216	@ 0xd8
 8011ab4:	681b      	ldr	r3, [r3, #0]
 8011ab6:	4053      	eors	r3, r2
 8011ab8:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8011aba:	697b      	ldr	r3, [r7, #20]
 8011abc:	0e1b      	lsrs	r3, r3, #24
 8011abe:	b2db      	uxtb	r3, r3
 8011ac0:	461a      	mov	r2, r3
 8011ac2:	4b6f      	ldr	r3, [pc, #444]	@ (8011c80 <AesDecrypt_C+0x11b4>)
 8011ac4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011ac8:	69bb      	ldr	r3, [r7, #24]
 8011aca:	0c1b      	lsrs	r3, r3, #16
 8011acc:	b2db      	uxtb	r3, r3
 8011ace:	496c      	ldr	r1, [pc, #432]	@ (8011c80 <AesDecrypt_C+0x11b4>)
 8011ad0:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011ad4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011ad8:	405a      	eors	r2, r3
 8011ada:	69fb      	ldr	r3, [r7, #28]
 8011adc:	0a1b      	lsrs	r3, r3, #8
 8011ade:	b2db      	uxtb	r3, r3
 8011ae0:	4967      	ldr	r1, [pc, #412]	@ (8011c80 <AesDecrypt_C+0x11b4>)
 8011ae2:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011ae6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011aea:	405a      	eors	r2, r3
 8011aec:	6a3b      	ldr	r3, [r7, #32]
 8011aee:	b2db      	uxtb	r3, r3
 8011af0:	4963      	ldr	r1, [pc, #396]	@ (8011c80 <AesDecrypt_C+0x11b4>)
 8011af2:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011af6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011afa:	405a      	eors	r2, r3
 8011afc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011afe:	33dc      	adds	r3, #220	@ 0xdc
 8011b00:	681b      	ldr	r3, [r3, #0]
 8011b02:	4053      	eors	r3, r2
 8011b04:	62bb      	str	r3, [r7, #40]	@ 0x28
        }
    }
    rk += r * 8;
 8011b06:	683b      	ldr	r3, [r7, #0]
 8011b08:	015b      	lsls	r3, r3, #5
 8011b0a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8011b0c:	4413      	add	r3, r2
 8011b0e:	627b      	str	r3, [r7, #36]	@ 0x24
     * apply last round and
     * map cipher state to byte array block:
     */

#ifndef WC_NO_CACHE_RESISTANT
    t0 |= PreFetchTd4();
 8011b10:	f7fe ffbc 	bl	8010a8c <PreFetchTd4>
 8011b14:	4602      	mov	r2, r0
 8011b16:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011b18:	4313      	orrs	r3, r2
 8011b1a:	637b      	str	r3, [r7, #52]	@ 0x34
#endif

    s0 = GetTable8_4(Td4, GETBYTE(t0, 3), GETBYTE(t3, 2),
 8011b1c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011b1e:	0e1b      	lsrs	r3, r3, #24
 8011b20:	b2db      	uxtb	r3, r3
 8011b22:	461a      	mov	r2, r3
 8011b24:	4b57      	ldr	r3, [pc, #348]	@ (8011c84 <AesDecrypt_C+0x11b8>)
 8011b26:	5c9b      	ldrb	r3, [r3, r2]
 8011b28:	061a      	lsls	r2, r3, #24
 8011b2a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011b2c:	0c1b      	lsrs	r3, r3, #16
 8011b2e:	b2db      	uxtb	r3, r3
 8011b30:	4619      	mov	r1, r3
 8011b32:	4b54      	ldr	r3, [pc, #336]	@ (8011c84 <AesDecrypt_C+0x11b8>)
 8011b34:	5c5b      	ldrb	r3, [r3, r1]
 8011b36:	041b      	lsls	r3, r3, #16
 8011b38:	431a      	orrs	r2, r3
 8011b3a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011b3c:	0a1b      	lsrs	r3, r3, #8
 8011b3e:	b2db      	uxtb	r3, r3
 8011b40:	4619      	mov	r1, r3
 8011b42:	4b50      	ldr	r3, [pc, #320]	@ (8011c84 <AesDecrypt_C+0x11b8>)
 8011b44:	5c5b      	ldrb	r3, [r3, r1]
 8011b46:	021b      	lsls	r3, r3, #8
 8011b48:	4313      	orrs	r3, r2
 8011b4a:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8011b4c:	b2d2      	uxtb	r2, r2
 8011b4e:	4611      	mov	r1, r2
 8011b50:	4a4c      	ldr	r2, [pc, #304]	@ (8011c84 <AesDecrypt_C+0x11b8>)
 8011b52:	5c52      	ldrb	r2, [r2, r1]
 8011b54:	431a      	orrs	r2, r3
                          GETBYTE(t2, 1), GETBYTE(t1, 0)) ^ rk[0];
 8011b56:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011b58:	681b      	ldr	r3, [r3, #0]
 8011b5a:	4053      	eors	r3, r2
    s0 = GetTable8_4(Td4, GETBYTE(t0, 3), GETBYTE(t3, 2),
 8011b5c:	623b      	str	r3, [r7, #32]
    s1 = GetTable8_4(Td4, GETBYTE(t1, 3), GETBYTE(t0, 2),
 8011b5e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011b60:	0e1b      	lsrs	r3, r3, #24
 8011b62:	b2db      	uxtb	r3, r3
 8011b64:	461a      	mov	r2, r3
 8011b66:	4b47      	ldr	r3, [pc, #284]	@ (8011c84 <AesDecrypt_C+0x11b8>)
 8011b68:	5c9b      	ldrb	r3, [r3, r2]
 8011b6a:	061a      	lsls	r2, r3, #24
 8011b6c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011b6e:	0c1b      	lsrs	r3, r3, #16
 8011b70:	b2db      	uxtb	r3, r3
 8011b72:	4619      	mov	r1, r3
 8011b74:	4b43      	ldr	r3, [pc, #268]	@ (8011c84 <AesDecrypt_C+0x11b8>)
 8011b76:	5c5b      	ldrb	r3, [r3, r1]
 8011b78:	041b      	lsls	r3, r3, #16
 8011b7a:	431a      	orrs	r2, r3
 8011b7c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011b7e:	0a1b      	lsrs	r3, r3, #8
 8011b80:	b2db      	uxtb	r3, r3
 8011b82:	4619      	mov	r1, r3
 8011b84:	4b3f      	ldr	r3, [pc, #252]	@ (8011c84 <AesDecrypt_C+0x11b8>)
 8011b86:	5c5b      	ldrb	r3, [r3, r1]
 8011b88:	021b      	lsls	r3, r3, #8
 8011b8a:	4313      	orrs	r3, r2
 8011b8c:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8011b8e:	b2d2      	uxtb	r2, r2
 8011b90:	4611      	mov	r1, r2
 8011b92:	4a3c      	ldr	r2, [pc, #240]	@ (8011c84 <AesDecrypt_C+0x11b8>)
 8011b94:	5c52      	ldrb	r2, [r2, r1]
 8011b96:	431a      	orrs	r2, r3
                          GETBYTE(t3, 1), GETBYTE(t2, 0)) ^ rk[1];
 8011b98:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011b9a:	3304      	adds	r3, #4
 8011b9c:	681b      	ldr	r3, [r3, #0]
 8011b9e:	4053      	eors	r3, r2
    s1 = GetTable8_4(Td4, GETBYTE(t1, 3), GETBYTE(t0, 2),
 8011ba0:	61fb      	str	r3, [r7, #28]
    s2 = GetTable8_4(Td4, GETBYTE(t2, 3), GETBYTE(t1, 2),
 8011ba2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011ba4:	0e1b      	lsrs	r3, r3, #24
 8011ba6:	b2db      	uxtb	r3, r3
 8011ba8:	461a      	mov	r2, r3
 8011baa:	4b36      	ldr	r3, [pc, #216]	@ (8011c84 <AesDecrypt_C+0x11b8>)
 8011bac:	5c9b      	ldrb	r3, [r3, r2]
 8011bae:	061a      	lsls	r2, r3, #24
 8011bb0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011bb2:	0c1b      	lsrs	r3, r3, #16
 8011bb4:	b2db      	uxtb	r3, r3
 8011bb6:	4619      	mov	r1, r3
 8011bb8:	4b32      	ldr	r3, [pc, #200]	@ (8011c84 <AesDecrypt_C+0x11b8>)
 8011bba:	5c5b      	ldrb	r3, [r3, r1]
 8011bbc:	041b      	lsls	r3, r3, #16
 8011bbe:	431a      	orrs	r2, r3
 8011bc0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011bc2:	0a1b      	lsrs	r3, r3, #8
 8011bc4:	b2db      	uxtb	r3, r3
 8011bc6:	4619      	mov	r1, r3
 8011bc8:	4b2e      	ldr	r3, [pc, #184]	@ (8011c84 <AesDecrypt_C+0x11b8>)
 8011bca:	5c5b      	ldrb	r3, [r3, r1]
 8011bcc:	021b      	lsls	r3, r3, #8
 8011bce:	4313      	orrs	r3, r2
 8011bd0:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8011bd2:	b2d2      	uxtb	r2, r2
 8011bd4:	4611      	mov	r1, r2
 8011bd6:	4a2b      	ldr	r2, [pc, #172]	@ (8011c84 <AesDecrypt_C+0x11b8>)
 8011bd8:	5c52      	ldrb	r2, [r2, r1]
 8011bda:	431a      	orrs	r2, r3
                          GETBYTE(t0, 1), GETBYTE(t3, 0)) ^ rk[2];
 8011bdc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011bde:	3308      	adds	r3, #8
 8011be0:	681b      	ldr	r3, [r3, #0]
 8011be2:	4053      	eors	r3, r2
    s2 = GetTable8_4(Td4, GETBYTE(t2, 3), GETBYTE(t1, 2),
 8011be4:	61bb      	str	r3, [r7, #24]
    s3 = GetTable8_4(Td4, GETBYTE(t3, 3), GETBYTE(t2, 2),
 8011be6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011be8:	0e1b      	lsrs	r3, r3, #24
 8011bea:	b2db      	uxtb	r3, r3
 8011bec:	461a      	mov	r2, r3
 8011bee:	4b25      	ldr	r3, [pc, #148]	@ (8011c84 <AesDecrypt_C+0x11b8>)
 8011bf0:	5c9b      	ldrb	r3, [r3, r2]
 8011bf2:	061a      	lsls	r2, r3, #24
 8011bf4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011bf6:	0c1b      	lsrs	r3, r3, #16
 8011bf8:	b2db      	uxtb	r3, r3
 8011bfa:	4619      	mov	r1, r3
 8011bfc:	4b21      	ldr	r3, [pc, #132]	@ (8011c84 <AesDecrypt_C+0x11b8>)
 8011bfe:	5c5b      	ldrb	r3, [r3, r1]
 8011c00:	041b      	lsls	r3, r3, #16
 8011c02:	431a      	orrs	r2, r3
 8011c04:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011c06:	0a1b      	lsrs	r3, r3, #8
 8011c08:	b2db      	uxtb	r3, r3
 8011c0a:	4619      	mov	r1, r3
 8011c0c:	4b1d      	ldr	r3, [pc, #116]	@ (8011c84 <AesDecrypt_C+0x11b8>)
 8011c0e:	5c5b      	ldrb	r3, [r3, r1]
 8011c10:	021b      	lsls	r3, r3, #8
 8011c12:	4313      	orrs	r3, r2
 8011c14:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8011c16:	b2d2      	uxtb	r2, r2
 8011c18:	4611      	mov	r1, r2
 8011c1a:	4a1a      	ldr	r2, [pc, #104]	@ (8011c84 <AesDecrypt_C+0x11b8>)
 8011c1c:	5c52      	ldrb	r2, [r2, r1]
 8011c1e:	431a      	orrs	r2, r3
                          GETBYTE(t1, 1), GETBYTE(t0, 0)) ^ rk[3];
 8011c20:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011c22:	330c      	adds	r3, #12
 8011c24:	681b      	ldr	r3, [r3, #0]
 8011c26:	4053      	eors	r3, r2
    s3 = GetTable8_4(Td4, GETBYTE(t3, 3), GETBYTE(t2, 2),
 8011c28:	617b      	str	r3, [r7, #20]
    s3 = t3 ^ rk[3];
#endif

    /* write out */
#ifdef LITTLE_ENDIAN_ORDER
    s0 = ByteReverseWord32(s0);
 8011c2a:	6a3b      	ldr	r3, [r7, #32]
 8011c2c:	4618      	mov	r0, r3
 8011c2e:	f7fd fcdc 	bl	800f5ea <ByteReverseWord32>
 8011c32:	4603      	mov	r3, r0
 8011c34:	623b      	str	r3, [r7, #32]
    s1 = ByteReverseWord32(s1);
 8011c36:	69fb      	ldr	r3, [r7, #28]
 8011c38:	4618      	mov	r0, r3
 8011c3a:	f7fd fcd6 	bl	800f5ea <ByteReverseWord32>
 8011c3e:	4603      	mov	r3, r0
 8011c40:	61fb      	str	r3, [r7, #28]
    s2 = ByteReverseWord32(s2);
 8011c42:	69bb      	ldr	r3, [r7, #24]
 8011c44:	4618      	mov	r0, r3
 8011c46:	f7fd fcd0 	bl	800f5ea <ByteReverseWord32>
 8011c4a:	4603      	mov	r3, r0
 8011c4c:	61bb      	str	r3, [r7, #24]
    s3 = ByteReverseWord32(s3);
 8011c4e:	697b      	ldr	r3, [r7, #20]
 8011c50:	4618      	mov	r0, r3
 8011c52:	f7fd fcca 	bl	800f5ea <ByteReverseWord32>
 8011c56:	4603      	mov	r3, r0
 8011c58:	617b      	str	r3, [r7, #20]
#endif

    XMEMCPY(outBlock,                  &s0, sizeof(s0));
 8011c5a:	6a3a      	ldr	r2, [r7, #32]
 8011c5c:	687b      	ldr	r3, [r7, #4]
 8011c5e:	601a      	str	r2, [r3, #0]
    XMEMCPY(outBlock + sizeof(s0),     &s1, sizeof(s1));
 8011c60:	687b      	ldr	r3, [r7, #4]
 8011c62:	3304      	adds	r3, #4
 8011c64:	69fa      	ldr	r2, [r7, #28]
 8011c66:	601a      	str	r2, [r3, #0]
    XMEMCPY(outBlock + 2 * sizeof(s0), &s2, sizeof(s2));
 8011c68:	687b      	ldr	r3, [r7, #4]
 8011c6a:	3308      	adds	r3, #8
 8011c6c:	69ba      	ldr	r2, [r7, #24]
 8011c6e:	601a      	str	r2, [r3, #0]
    XMEMCPY(outBlock + 3 * sizeof(s0), &s3, sizeof(s3));
 8011c70:	687b      	ldr	r3, [r7, #4]
 8011c72:	330c      	adds	r3, #12
 8011c74:	697a      	ldr	r2, [r7, #20]
 8011c76:	601a      	str	r2, [r3, #0]

}
 8011c78:	bf00      	nop
 8011c7a:	3738      	adds	r7, #56	@ 0x38
 8011c7c:	46bd      	mov	sp, r7
 8011c7e:	bd80      	pop	{r7, pc}
 8011c80:	08032494 	.word	0x08032494
 8011c84:	08033494 	.word	0x08033494

08011c88 <wc_AesDecrypt>:

#if !defined(WC_AES_BITSLICED) || defined(WOLFSSL_AES_DIRECT)
/* Software AES - ECB Decrypt */
static WARN_UNUSED_RESULT int wc_AesDecrypt(
    Aes* aes, const byte* inBlock, byte* outBlock)
{
 8011c88:	b580      	push	{r7, lr}
 8011c8a:	b086      	sub	sp, #24
 8011c8c:	af00      	add	r7, sp, #0
 8011c8e:	60f8      	str	r0, [r7, #12]
 8011c90:	60b9      	str	r1, [r7, #8]
 8011c92:	607a      	str	r2, [r7, #4]
#if defined(MAX3266X_CB)
    int ret_cb;
#endif
    word32 r;

    if (aes == NULL) {
 8011c94:	68fb      	ldr	r3, [r7, #12]
 8011c96:	2b00      	cmp	r3, #0
 8011c98:	d102      	bne.n	8011ca0 <wc_AesDecrypt+0x18>
        return BAD_FUNC_ARG;
 8011c9a:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8011c9e:	e014      	b.n	8011cca <wc_AesDecrypt+0x42>
        if (ret < 0)
            return ret;
    }
#endif

    r = aes->rounds >> 1;
 8011ca0:	68fb      	ldr	r3, [r7, #12]
 8011ca2:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8011ca6:	085b      	lsrs	r3, r3, #1
 8011ca8:	617b      	str	r3, [r7, #20]

    if (r > 7 || r == 0) {
 8011caa:	697b      	ldr	r3, [r7, #20]
 8011cac:	2b07      	cmp	r3, #7
 8011cae:	d802      	bhi.n	8011cb6 <wc_AesDecrypt+0x2e>
 8011cb0:	697b      	ldr	r3, [r7, #20]
 8011cb2:	2b00      	cmp	r3, #0
 8011cb4:	d102      	bne.n	8011cbc <wc_AesDecrypt+0x34>
        WOLFSSL_ERROR_VERBOSE(KEYUSAGE_E);
        return KEYUSAGE_E;
 8011cb6:	f06f 03e1 	mvn.w	r3, #225	@ 0xe1
 8011cba:	e006      	b.n	8011cca <wc_AesDecrypt+0x42>
            return ret_cb;
        /* fall-through when unavailable */
    }
#endif

    AesDecrypt_C(aes, inBlock, outBlock, r);
 8011cbc:	697b      	ldr	r3, [r7, #20]
 8011cbe:	687a      	ldr	r2, [r7, #4]
 8011cc0:	68b9      	ldr	r1, [r7, #8]
 8011cc2:	68f8      	ldr	r0, [r7, #12]
 8011cc4:	f7fe ff02 	bl	8010acc <AesDecrypt_C>

    return 0;
 8011cc8:	2300      	movs	r3, #0
} /* wc_AesDecrypt[_SW]() */
 8011cca:	4618      	mov	r0, r3
 8011ccc:	3718      	adds	r7, #24
 8011cce:	46bd      	mov	sp, r7
 8011cd0:	bd80      	pop	{r7, pc}
	...

08011cd4 <AesSetKey_C>:
 * @param [in]  key    Block to encrypt.
 * @param [in]  keySz  Number of bytes in key.
 * @param [in]  dir    Direction of crypt: AES_ENCRYPTION or AES_DECRYPTION.
 */
static void AesSetKey_C(Aes* aes, const byte* key, word32 keySz, int dir)
{
 8011cd4:	b580      	push	{r7, lr}
 8011cd6:	b088      	sub	sp, #32
 8011cd8:	af00      	add	r7, sp, #0
 8011cda:	60f8      	str	r0, [r7, #12]
 8011cdc:	60b9      	str	r1, [r7, #8]
 8011cde:	607a      	str	r2, [r7, #4]
 8011ce0:	603b      	str	r3, [r7, #0]
#ifdef WC_C_DYNAMIC_FALLBACK
    word32* rk = aes->key_C_fallback;
#else
    word32* rk = aes->key;
 8011ce2:	68fb      	ldr	r3, [r7, #12]
 8011ce4:	61fb      	str	r3, [r7, #28]
#endif
    word32 temp;
    unsigned int i = 0;
 8011ce6:	2300      	movs	r3, #0
 8011ce8:	61bb      	str	r3, [r7, #24]

    XMEMCPY(rk, key, keySz);
 8011cea:	687a      	ldr	r2, [r7, #4]
 8011cec:	68b9      	ldr	r1, [r7, #8]
 8011cee:	69f8      	ldr	r0, [r7, #28]
 8011cf0:	f016 fc54 	bl	802859c <memcpy>
#if defined(LITTLE_ENDIAN_ORDER) && !defined(WOLFSSL_PIC32MZ_CRYPT) && \
    (!defined(WOLFSSL_ESP32_CRYPT) || defined(NO_WOLFSSL_ESP32_CRYPT_AES)) && \
    !defined(MAX3266X_AES)
    /* Always reverse words when using only SW */
    {
        ByteReverseWords(rk, rk, keySz);
 8011cf4:	687a      	ldr	r2, [r7, #4]
 8011cf6:	69f9      	ldr	r1, [r7, #28]
 8011cf8:	69f8      	ldr	r0, [r7, #28]
 8011cfa:	f7fd fc8d 	bl	800f618 <ByteReverseWords>
            /* If we don't need SW fallback, don't need to reverse words. */
        #endif /* NEED_AES_HW_FALLBACK */
    #endif /* WOLFSSL_ESPIDF */
#endif /* LITTLE_ENDIAN_ORDER, etc */

    switch (keySz) {
 8011cfe:	687b      	ldr	r3, [r7, #4]
 8011d00:	2b20      	cmp	r3, #32
 8011d02:	f000 80e5 	beq.w	8011ed0 <AesSetKey_C+0x1fc>
 8011d06:	687b      	ldr	r3, [r7, #4]
 8011d08:	2b20      	cmp	r3, #32
 8011d0a:	f200 8193 	bhi.w	8012034 <AesSetKey_C+0x360>
 8011d0e:	687b      	ldr	r3, [r7, #4]
 8011d10:	2b10      	cmp	r3, #16
 8011d12:	d003      	beq.n	8011d1c <AesSetKey_C+0x48>
 8011d14:	687b      	ldr	r3, [r7, #4]
 8011d16:	2b18      	cmp	r3, #24
 8011d18:	d061      	beq.n	8011dde <AesSetKey_C+0x10a>
 8011d1a:	e18b      	b.n	8012034 <AesSetKey_C+0x360>
        temp = (word32)-1;
        wc_MemZero_Add("wc_AesSetKeyLocal temp", &temp, sizeof(temp));
    #endif
        while (1)
        {
            temp  = rk[3];
 8011d1c:	69fb      	ldr	r3, [r7, #28]
 8011d1e:	68db      	ldr	r3, [r3, #12]
 8011d20:	613b      	str	r3, [r7, #16]
            rk[4] = rk[0] ^
 8011d22:	69fb      	ldr	r3, [r7, #28]
 8011d24:	681a      	ldr	r2, [r3, #0]
        #ifndef WOLFSSL_AES_SMALL_TABLES
                (GetTable(Te[2], GETBYTE(temp, 2)) & 0xff000000) ^
 8011d26:	693b      	ldr	r3, [r7, #16]
 8011d28:	0c1b      	lsrs	r3, r3, #16
 8011d2a:	b2db      	uxtb	r3, r3
 8011d2c:	4966      	ldr	r1, [pc, #408]	@ (8011ec8 <AesSetKey_C+0x1f4>)
 8011d2e:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011d32:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011d36:	f003 437f 	and.w	r3, r3, #4278190080	@ 0xff000000
            rk[4] = rk[0] ^
 8011d3a:	405a      	eors	r2, r3
                (GetTable(Te[3], GETBYTE(temp, 1)) & 0x00ff0000) ^
 8011d3c:	693b      	ldr	r3, [r7, #16]
 8011d3e:	0a1b      	lsrs	r3, r3, #8
 8011d40:	b2db      	uxtb	r3, r3
 8011d42:	4961      	ldr	r1, [pc, #388]	@ (8011ec8 <AesSetKey_C+0x1f4>)
 8011d44:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011d48:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011d4c:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
                (GetTable(Te[2], GETBYTE(temp, 2)) & 0xff000000) ^
 8011d50:	405a      	eors	r2, r3
                (GetTable(Te[0], GETBYTE(temp, 0)) & 0x0000ff00) ^
 8011d52:	693b      	ldr	r3, [r7, #16]
 8011d54:	b2db      	uxtb	r3, r3
 8011d56:	4619      	mov	r1, r3
 8011d58:	4b5b      	ldr	r3, [pc, #364]	@ (8011ec8 <AesSetKey_C+0x1f4>)
 8011d5a:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8011d5e:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
                (GetTable(Te[3], GETBYTE(temp, 1)) & 0x00ff0000) ^
 8011d62:	405a      	eors	r2, r3
                (GetTable(Te[1], GETBYTE(temp, 3)) & 0x000000ff) ^
 8011d64:	693b      	ldr	r3, [r7, #16]
 8011d66:	0e1b      	lsrs	r3, r3, #24
 8011d68:	b2db      	uxtb	r3, r3
 8011d6a:	4957      	ldr	r1, [pc, #348]	@ (8011ec8 <AesSetKey_C+0x1f4>)
 8011d6c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011d70:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011d74:	b2db      	uxtb	r3, r3
                (GetTable(Te[0], GETBYTE(temp, 0)) & 0x0000ff00) ^
 8011d76:	ea82 0103 	eor.w	r1, r2, r3
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 2)) << 24) ^
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 1)) << 16) ^
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 0)) <<  8) ^
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 3))) ^
        #endif
                rcon[i];
 8011d7a:	4a54      	ldr	r2, [pc, #336]	@ (8011ecc <AesSetKey_C+0x1f8>)
 8011d7c:	69bb      	ldr	r3, [r7, #24]
 8011d7e:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
            rk[4] = rk[0] ^
 8011d82:	69fb      	ldr	r3, [r7, #28]
 8011d84:	3310      	adds	r3, #16
                (GetTable(Te[1], GETBYTE(temp, 3)) & 0x000000ff) ^
 8011d86:	404a      	eors	r2, r1
            rk[4] = rk[0] ^
 8011d88:	601a      	str	r2, [r3, #0]
            rk[5] = rk[1] ^ rk[4];
 8011d8a:	69fb      	ldr	r3, [r7, #28]
 8011d8c:	3304      	adds	r3, #4
 8011d8e:	6819      	ldr	r1, [r3, #0]
 8011d90:	69fb      	ldr	r3, [r7, #28]
 8011d92:	3310      	adds	r3, #16
 8011d94:	681a      	ldr	r2, [r3, #0]
 8011d96:	69fb      	ldr	r3, [r7, #28]
 8011d98:	3314      	adds	r3, #20
 8011d9a:	404a      	eors	r2, r1
 8011d9c:	601a      	str	r2, [r3, #0]
            rk[6] = rk[2] ^ rk[5];
 8011d9e:	69fb      	ldr	r3, [r7, #28]
 8011da0:	3308      	adds	r3, #8
 8011da2:	6819      	ldr	r1, [r3, #0]
 8011da4:	69fb      	ldr	r3, [r7, #28]
 8011da6:	3314      	adds	r3, #20
 8011da8:	681a      	ldr	r2, [r3, #0]
 8011daa:	69fb      	ldr	r3, [r7, #28]
 8011dac:	3318      	adds	r3, #24
 8011dae:	404a      	eors	r2, r1
 8011db0:	601a      	str	r2, [r3, #0]
            rk[7] = rk[3] ^ rk[6];
 8011db2:	69fb      	ldr	r3, [r7, #28]
 8011db4:	330c      	adds	r3, #12
 8011db6:	6819      	ldr	r1, [r3, #0]
 8011db8:	69fb      	ldr	r3, [r7, #28]
 8011dba:	3318      	adds	r3, #24
 8011dbc:	681a      	ldr	r2, [r3, #0]
 8011dbe:	69fb      	ldr	r3, [r7, #28]
 8011dc0:	331c      	adds	r3, #28
 8011dc2:	404a      	eors	r2, r1
 8011dc4:	601a      	str	r2, [r3, #0]
            if (++i == 10)
 8011dc6:	69bb      	ldr	r3, [r7, #24]
 8011dc8:	3301      	adds	r3, #1
 8011dca:	61bb      	str	r3, [r7, #24]
 8011dcc:	69bb      	ldr	r3, [r7, #24]
 8011dce:	2b0a      	cmp	r3, #10
 8011dd0:	d003      	beq.n	8011dda <AesSetKey_C+0x106>
                break;
            rk += 4;
 8011dd2:	69fb      	ldr	r3, [r7, #28]
 8011dd4:	3310      	adds	r3, #16
 8011dd6:	61fb      	str	r3, [r7, #28]
            temp  = rk[3];
 8011dd8:	e7a0      	b.n	8011d1c <AesSetKey_C+0x48>
                break;
 8011dda:	bf00      	nop
        }
        break;
 8011ddc:	e12a      	b.n	8012034 <AesSetKey_C+0x360>
        wc_MemZero_Add("wc_AesSetKeyLocal temp", &temp, sizeof(temp));
    #endif
        /* for (;;) here triggers a bug in VC60 SP4 w/ Pro Pack */
        while (1)
        {
            temp = rk[ 5];
 8011dde:	69fb      	ldr	r3, [r7, #28]
 8011de0:	695b      	ldr	r3, [r3, #20]
 8011de2:	613b      	str	r3, [r7, #16]
            rk[ 6] = rk[ 0] ^
 8011de4:	69fb      	ldr	r3, [r7, #28]
 8011de6:	681a      	ldr	r2, [r3, #0]
        #ifndef WOLFSSL_AES_SMALL_TABLES
                (GetTable(Te[2], GETBYTE(temp, 2)) & 0xff000000) ^
 8011de8:	693b      	ldr	r3, [r7, #16]
 8011dea:	0c1b      	lsrs	r3, r3, #16
 8011dec:	b2db      	uxtb	r3, r3
 8011dee:	4936      	ldr	r1, [pc, #216]	@ (8011ec8 <AesSetKey_C+0x1f4>)
 8011df0:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011df4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011df8:	f003 437f 	and.w	r3, r3, #4278190080	@ 0xff000000
            rk[ 6] = rk[ 0] ^
 8011dfc:	405a      	eors	r2, r3
                (GetTable(Te[3], GETBYTE(temp, 1)) & 0x00ff0000) ^
 8011dfe:	693b      	ldr	r3, [r7, #16]
 8011e00:	0a1b      	lsrs	r3, r3, #8
 8011e02:	b2db      	uxtb	r3, r3
 8011e04:	4930      	ldr	r1, [pc, #192]	@ (8011ec8 <AesSetKey_C+0x1f4>)
 8011e06:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011e0a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011e0e:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
                (GetTable(Te[2], GETBYTE(temp, 2)) & 0xff000000) ^
 8011e12:	405a      	eors	r2, r3
                (GetTable(Te[0], GETBYTE(temp, 0)) & 0x0000ff00) ^
 8011e14:	693b      	ldr	r3, [r7, #16]
 8011e16:	b2db      	uxtb	r3, r3
 8011e18:	4619      	mov	r1, r3
 8011e1a:	4b2b      	ldr	r3, [pc, #172]	@ (8011ec8 <AesSetKey_C+0x1f4>)
 8011e1c:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8011e20:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
                (GetTable(Te[3], GETBYTE(temp, 1)) & 0x00ff0000) ^
 8011e24:	405a      	eors	r2, r3
                (GetTable(Te[1], GETBYTE(temp, 3)) & 0x000000ff) ^
 8011e26:	693b      	ldr	r3, [r7, #16]
 8011e28:	0e1b      	lsrs	r3, r3, #24
 8011e2a:	b2db      	uxtb	r3, r3
 8011e2c:	4926      	ldr	r1, [pc, #152]	@ (8011ec8 <AesSetKey_C+0x1f4>)
 8011e2e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011e32:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011e36:	b2db      	uxtb	r3, r3
                (GetTable(Te[0], GETBYTE(temp, 0)) & 0x0000ff00) ^
 8011e38:	ea82 0103 	eor.w	r1, r2, r3
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 2)) << 24) ^
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 1)) << 16) ^
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 0)) <<  8) ^
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 3))) ^
        #endif
                rcon[i];
 8011e3c:	4a23      	ldr	r2, [pc, #140]	@ (8011ecc <AesSetKey_C+0x1f8>)
 8011e3e:	69bb      	ldr	r3, [r7, #24]
 8011e40:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
            rk[ 6] = rk[ 0] ^
 8011e44:	69fb      	ldr	r3, [r7, #28]
 8011e46:	3318      	adds	r3, #24
                (GetTable(Te[1], GETBYTE(temp, 3)) & 0x000000ff) ^
 8011e48:	404a      	eors	r2, r1
            rk[ 6] = rk[ 0] ^
 8011e4a:	601a      	str	r2, [r3, #0]
            rk[ 7] = rk[ 1] ^ rk[ 6];
 8011e4c:	69fb      	ldr	r3, [r7, #28]
 8011e4e:	3304      	adds	r3, #4
 8011e50:	6819      	ldr	r1, [r3, #0]
 8011e52:	69fb      	ldr	r3, [r7, #28]
 8011e54:	3318      	adds	r3, #24
 8011e56:	681a      	ldr	r2, [r3, #0]
 8011e58:	69fb      	ldr	r3, [r7, #28]
 8011e5a:	331c      	adds	r3, #28
 8011e5c:	404a      	eors	r2, r1
 8011e5e:	601a      	str	r2, [r3, #0]
            rk[ 8] = rk[ 2] ^ rk[ 7];
 8011e60:	69fb      	ldr	r3, [r7, #28]
 8011e62:	3308      	adds	r3, #8
 8011e64:	6819      	ldr	r1, [r3, #0]
 8011e66:	69fb      	ldr	r3, [r7, #28]
 8011e68:	331c      	adds	r3, #28
 8011e6a:	681a      	ldr	r2, [r3, #0]
 8011e6c:	69fb      	ldr	r3, [r7, #28]
 8011e6e:	3320      	adds	r3, #32
 8011e70:	404a      	eors	r2, r1
 8011e72:	601a      	str	r2, [r3, #0]
            rk[ 9] = rk[ 3] ^ rk[ 8];
 8011e74:	69fb      	ldr	r3, [r7, #28]
 8011e76:	330c      	adds	r3, #12
 8011e78:	6819      	ldr	r1, [r3, #0]
 8011e7a:	69fb      	ldr	r3, [r7, #28]
 8011e7c:	3320      	adds	r3, #32
 8011e7e:	681a      	ldr	r2, [r3, #0]
 8011e80:	69fb      	ldr	r3, [r7, #28]
 8011e82:	3324      	adds	r3, #36	@ 0x24
 8011e84:	404a      	eors	r2, r1
 8011e86:	601a      	str	r2, [r3, #0]
            if (++i == 8)
 8011e88:	69bb      	ldr	r3, [r7, #24]
 8011e8a:	3301      	adds	r3, #1
 8011e8c:	61bb      	str	r3, [r7, #24]
 8011e8e:	69bb      	ldr	r3, [r7, #24]
 8011e90:	2b08      	cmp	r3, #8
 8011e92:	d017      	beq.n	8011ec4 <AesSetKey_C+0x1f0>
                break;
            rk[10] = rk[ 4] ^ rk[ 9];
 8011e94:	69fb      	ldr	r3, [r7, #28]
 8011e96:	3310      	adds	r3, #16
 8011e98:	6819      	ldr	r1, [r3, #0]
 8011e9a:	69fb      	ldr	r3, [r7, #28]
 8011e9c:	3324      	adds	r3, #36	@ 0x24
 8011e9e:	681a      	ldr	r2, [r3, #0]
 8011ea0:	69fb      	ldr	r3, [r7, #28]
 8011ea2:	3328      	adds	r3, #40	@ 0x28
 8011ea4:	404a      	eors	r2, r1
 8011ea6:	601a      	str	r2, [r3, #0]
            rk[11] = rk[ 5] ^ rk[10];
 8011ea8:	69fb      	ldr	r3, [r7, #28]
 8011eaa:	3314      	adds	r3, #20
 8011eac:	6819      	ldr	r1, [r3, #0]
 8011eae:	69fb      	ldr	r3, [r7, #28]
 8011eb0:	3328      	adds	r3, #40	@ 0x28
 8011eb2:	681a      	ldr	r2, [r3, #0]
 8011eb4:	69fb      	ldr	r3, [r7, #28]
 8011eb6:	332c      	adds	r3, #44	@ 0x2c
 8011eb8:	404a      	eors	r2, r1
 8011eba:	601a      	str	r2, [r3, #0]
            rk += 6;
 8011ebc:	69fb      	ldr	r3, [r7, #28]
 8011ebe:	3318      	adds	r3, #24
 8011ec0:	61fb      	str	r3, [r7, #28]
            temp = rk[ 5];
 8011ec2:	e78c      	b.n	8011dde <AesSetKey_C+0x10a>
                break;
 8011ec4:	bf00      	nop
        }
        break;
 8011ec6:	e0b5      	b.n	8012034 <AesSetKey_C+0x360>
 8011ec8:	08031494 	.word	0x08031494
 8011ecc:	0803146c 	.word	0x0803146c
        temp = (word32)-1;
        wc_MemZero_Add("wc_AesSetKeyLocal temp", &temp, sizeof(temp));
    #endif
        while (1)
        {
            temp = rk[ 7];
 8011ed0:	69fb      	ldr	r3, [r7, #28]
 8011ed2:	69db      	ldr	r3, [r3, #28]
 8011ed4:	613b      	str	r3, [r7, #16]
            rk[ 8] = rk[ 0] ^
 8011ed6:	69fb      	ldr	r3, [r7, #28]
 8011ed8:	681a      	ldr	r2, [r3, #0]
        #ifndef WOLFSSL_AES_SMALL_TABLES
                (GetTable(Te[2], GETBYTE(temp, 2)) & 0xff000000) ^
 8011eda:	693b      	ldr	r3, [r7, #16]
 8011edc:	0c1b      	lsrs	r3, r3, #16
 8011ede:	b2db      	uxtb	r3, r3
 8011ee0:	499a      	ldr	r1, [pc, #616]	@ (801214c <AesSetKey_C+0x478>)
 8011ee2:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011ee6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011eea:	f003 437f 	and.w	r3, r3, #4278190080	@ 0xff000000
            rk[ 8] = rk[ 0] ^
 8011eee:	405a      	eors	r2, r3
                (GetTable(Te[3], GETBYTE(temp, 1)) & 0x00ff0000) ^
 8011ef0:	693b      	ldr	r3, [r7, #16]
 8011ef2:	0a1b      	lsrs	r3, r3, #8
 8011ef4:	b2db      	uxtb	r3, r3
 8011ef6:	4995      	ldr	r1, [pc, #596]	@ (801214c <AesSetKey_C+0x478>)
 8011ef8:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011efc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011f00:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
                (GetTable(Te[2], GETBYTE(temp, 2)) & 0xff000000) ^
 8011f04:	405a      	eors	r2, r3
                (GetTable(Te[0], GETBYTE(temp, 0)) & 0x0000ff00) ^
 8011f06:	693b      	ldr	r3, [r7, #16]
 8011f08:	b2db      	uxtb	r3, r3
 8011f0a:	4619      	mov	r1, r3
 8011f0c:	4b8f      	ldr	r3, [pc, #572]	@ (801214c <AesSetKey_C+0x478>)
 8011f0e:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8011f12:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
                (GetTable(Te[3], GETBYTE(temp, 1)) & 0x00ff0000) ^
 8011f16:	405a      	eors	r2, r3
                (GetTable(Te[1], GETBYTE(temp, 3)) & 0x000000ff) ^
 8011f18:	693b      	ldr	r3, [r7, #16]
 8011f1a:	0e1b      	lsrs	r3, r3, #24
 8011f1c:	b2db      	uxtb	r3, r3
 8011f1e:	498b      	ldr	r1, [pc, #556]	@ (801214c <AesSetKey_C+0x478>)
 8011f20:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011f24:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011f28:	b2db      	uxtb	r3, r3
                (GetTable(Te[0], GETBYTE(temp, 0)) & 0x0000ff00) ^
 8011f2a:	ea82 0103 	eor.w	r1, r2, r3
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 2)) << 24) ^
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 1)) << 16) ^
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 0)) <<  8) ^
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 3))) ^
        #endif
                rcon[i];
 8011f2e:	4a88      	ldr	r2, [pc, #544]	@ (8012150 <AesSetKey_C+0x47c>)
 8011f30:	69bb      	ldr	r3, [r7, #24]
 8011f32:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
            rk[ 8] = rk[ 0] ^
 8011f36:	69fb      	ldr	r3, [r7, #28]
 8011f38:	3320      	adds	r3, #32
                (GetTable(Te[1], GETBYTE(temp, 3)) & 0x000000ff) ^
 8011f3a:	404a      	eors	r2, r1
            rk[ 8] = rk[ 0] ^
 8011f3c:	601a      	str	r2, [r3, #0]
            rk[ 9] = rk[ 1] ^ rk[ 8];
 8011f3e:	69fb      	ldr	r3, [r7, #28]
 8011f40:	3304      	adds	r3, #4
 8011f42:	6819      	ldr	r1, [r3, #0]
 8011f44:	69fb      	ldr	r3, [r7, #28]
 8011f46:	3320      	adds	r3, #32
 8011f48:	681a      	ldr	r2, [r3, #0]
 8011f4a:	69fb      	ldr	r3, [r7, #28]
 8011f4c:	3324      	adds	r3, #36	@ 0x24
 8011f4e:	404a      	eors	r2, r1
 8011f50:	601a      	str	r2, [r3, #0]
            rk[10] = rk[ 2] ^ rk[ 9];
 8011f52:	69fb      	ldr	r3, [r7, #28]
 8011f54:	3308      	adds	r3, #8
 8011f56:	6819      	ldr	r1, [r3, #0]
 8011f58:	69fb      	ldr	r3, [r7, #28]
 8011f5a:	3324      	adds	r3, #36	@ 0x24
 8011f5c:	681a      	ldr	r2, [r3, #0]
 8011f5e:	69fb      	ldr	r3, [r7, #28]
 8011f60:	3328      	adds	r3, #40	@ 0x28
 8011f62:	404a      	eors	r2, r1
 8011f64:	601a      	str	r2, [r3, #0]
            rk[11] = rk[ 3] ^ rk[10];
 8011f66:	69fb      	ldr	r3, [r7, #28]
 8011f68:	330c      	adds	r3, #12
 8011f6a:	6819      	ldr	r1, [r3, #0]
 8011f6c:	69fb      	ldr	r3, [r7, #28]
 8011f6e:	3328      	adds	r3, #40	@ 0x28
 8011f70:	681a      	ldr	r2, [r3, #0]
 8011f72:	69fb      	ldr	r3, [r7, #28]
 8011f74:	332c      	adds	r3, #44	@ 0x2c
 8011f76:	404a      	eors	r2, r1
 8011f78:	601a      	str	r2, [r3, #0]
            if (++i == 7)
 8011f7a:	69bb      	ldr	r3, [r7, #24]
 8011f7c:	3301      	adds	r3, #1
 8011f7e:	61bb      	str	r3, [r7, #24]
 8011f80:	69bb      	ldr	r3, [r7, #24]
 8011f82:	2b07      	cmp	r3, #7
 8011f84:	d054      	beq.n	8012030 <AesSetKey_C+0x35c>
                break;
            temp = rk[11];
 8011f86:	69fb      	ldr	r3, [r7, #28]
 8011f88:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8011f8a:	613b      	str	r3, [r7, #16]
            rk[12] = rk[ 4] ^
 8011f8c:	69fb      	ldr	r3, [r7, #28]
 8011f8e:	3310      	adds	r3, #16
 8011f90:	681a      	ldr	r2, [r3, #0]
        #ifndef WOLFSSL_AES_SMALL_TABLES
                (GetTable(Te[2], GETBYTE(temp, 3)) & 0xff000000) ^
 8011f92:	693b      	ldr	r3, [r7, #16]
 8011f94:	0e1b      	lsrs	r3, r3, #24
 8011f96:	b2db      	uxtb	r3, r3
 8011f98:	496c      	ldr	r1, [pc, #432]	@ (801214c <AesSetKey_C+0x478>)
 8011f9a:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011f9e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011fa2:	f003 437f 	and.w	r3, r3, #4278190080	@ 0xff000000
            rk[12] = rk[ 4] ^
 8011fa6:	405a      	eors	r2, r3
                (GetTable(Te[3], GETBYTE(temp, 2)) & 0x00ff0000) ^
 8011fa8:	693b      	ldr	r3, [r7, #16]
 8011faa:	0c1b      	lsrs	r3, r3, #16
 8011fac:	b2db      	uxtb	r3, r3
 8011fae:	4967      	ldr	r1, [pc, #412]	@ (801214c <AesSetKey_C+0x478>)
 8011fb0:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011fb4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011fb8:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
                (GetTable(Te[2], GETBYTE(temp, 3)) & 0xff000000) ^
 8011fbc:	405a      	eors	r2, r3
                (GetTable(Te[0], GETBYTE(temp, 1)) & 0x0000ff00) ^
 8011fbe:	693b      	ldr	r3, [r7, #16]
 8011fc0:	0a1b      	lsrs	r3, r3, #8
 8011fc2:	b2db      	uxtb	r3, r3
 8011fc4:	4619      	mov	r1, r3
 8011fc6:	4b61      	ldr	r3, [pc, #388]	@ (801214c <AesSetKey_C+0x478>)
 8011fc8:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8011fcc:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
                (GetTable(Te[3], GETBYTE(temp, 2)) & 0x00ff0000) ^
 8011fd0:	ea82 0103 	eor.w	r1, r2, r3
                (GetTable(Te[1], GETBYTE(temp, 0)) & 0x000000ff);
 8011fd4:	693b      	ldr	r3, [r7, #16]
 8011fd6:	b2db      	uxtb	r3, r3
 8011fd8:	4a5c      	ldr	r2, [pc, #368]	@ (801214c <AesSetKey_C+0x478>)
 8011fda:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011fde:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8011fe2:	b2da      	uxtb	r2, r3
            rk[12] = rk[ 4] ^
 8011fe4:	69fb      	ldr	r3, [r7, #28]
 8011fe6:	3330      	adds	r3, #48	@ 0x30
                (GetTable(Te[0], GETBYTE(temp, 1)) & 0x0000ff00) ^
 8011fe8:	404a      	eors	r2, r1
            rk[12] = rk[ 4] ^
 8011fea:	601a      	str	r2, [r3, #0]
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 3)) << 24) ^
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 2)) << 16) ^
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 1)) <<  8) ^
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 0)));
        #endif
            rk[13] = rk[ 5] ^ rk[12];
 8011fec:	69fb      	ldr	r3, [r7, #28]
 8011fee:	3314      	adds	r3, #20
 8011ff0:	6819      	ldr	r1, [r3, #0]
 8011ff2:	69fb      	ldr	r3, [r7, #28]
 8011ff4:	3330      	adds	r3, #48	@ 0x30
 8011ff6:	681a      	ldr	r2, [r3, #0]
 8011ff8:	69fb      	ldr	r3, [r7, #28]
 8011ffa:	3334      	adds	r3, #52	@ 0x34
 8011ffc:	404a      	eors	r2, r1
 8011ffe:	601a      	str	r2, [r3, #0]
            rk[14] = rk[ 6] ^ rk[13];
 8012000:	69fb      	ldr	r3, [r7, #28]
 8012002:	3318      	adds	r3, #24
 8012004:	6819      	ldr	r1, [r3, #0]
 8012006:	69fb      	ldr	r3, [r7, #28]
 8012008:	3334      	adds	r3, #52	@ 0x34
 801200a:	681a      	ldr	r2, [r3, #0]
 801200c:	69fb      	ldr	r3, [r7, #28]
 801200e:	3338      	adds	r3, #56	@ 0x38
 8012010:	404a      	eors	r2, r1
 8012012:	601a      	str	r2, [r3, #0]
            rk[15] = rk[ 7] ^ rk[14];
 8012014:	69fb      	ldr	r3, [r7, #28]
 8012016:	331c      	adds	r3, #28
 8012018:	6819      	ldr	r1, [r3, #0]
 801201a:	69fb      	ldr	r3, [r7, #28]
 801201c:	3338      	adds	r3, #56	@ 0x38
 801201e:	681a      	ldr	r2, [r3, #0]
 8012020:	69fb      	ldr	r3, [r7, #28]
 8012022:	333c      	adds	r3, #60	@ 0x3c
 8012024:	404a      	eors	r2, r1
 8012026:	601a      	str	r2, [r3, #0]

            rk += 8;
 8012028:	69fb      	ldr	r3, [r7, #28]
 801202a:	3320      	adds	r3, #32
 801202c:	61fb      	str	r3, [r7, #28]
            temp = rk[ 7];
 801202e:	e74f      	b.n	8011ed0 <AesSetKey_C+0x1fc>
                break;
 8012030:	bf00      	nop
        }
        break;
 8012032:	bf00      	nop
#endif /* 256 */
    } /* switch */
    ForceZero(&temp, sizeof(temp));
 8012034:	f107 0310 	add.w	r3, r7, #16
 8012038:	2104      	movs	r1, #4
 801203a:	4618      	mov	r0, r3
 801203c:	f7fd fb91 	bl	800f762 <ForceZero>

#if defined(HAVE_AES_DECRYPT) && !defined(MAX3266X_AES)
    if (dir == AES_DECRYPTION) {
 8012040:	683b      	ldr	r3, [r7, #0]
 8012042:	2b01      	cmp	r3, #1
 8012044:	f040 819d 	bne.w	8012382 <AesSetKey_C+0x6ae>
        unsigned int j;

#ifdef WC_C_DYNAMIC_FALLBACK
        rk = aes->key_C_fallback;
#else
        rk = aes->key;
 8012048:	68fb      	ldr	r3, [r7, #12]
 801204a:	61fb      	str	r3, [r7, #28]
#endif

        /* invert the order of the round keys: */
        for (i = 0, j = 4* aes->rounds; i < j; i += 4, j -= 4) {
 801204c:	2300      	movs	r3, #0
 801204e:	61bb      	str	r3, [r7, #24]
 8012050:	68fb      	ldr	r3, [r7, #12]
 8012052:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8012056:	009b      	lsls	r3, r3, #2
 8012058:	617b      	str	r3, [r7, #20]
 801205a:	e069      	b.n	8012130 <AesSetKey_C+0x45c>
            temp = rk[i    ]; rk[i    ] = rk[j    ]; rk[j    ] = temp;
 801205c:	69bb      	ldr	r3, [r7, #24]
 801205e:	009b      	lsls	r3, r3, #2
 8012060:	69fa      	ldr	r2, [r7, #28]
 8012062:	4413      	add	r3, r2
 8012064:	681b      	ldr	r3, [r3, #0]
 8012066:	613b      	str	r3, [r7, #16]
 8012068:	697b      	ldr	r3, [r7, #20]
 801206a:	009b      	lsls	r3, r3, #2
 801206c:	69fa      	ldr	r2, [r7, #28]
 801206e:	441a      	add	r2, r3
 8012070:	69bb      	ldr	r3, [r7, #24]
 8012072:	009b      	lsls	r3, r3, #2
 8012074:	69f9      	ldr	r1, [r7, #28]
 8012076:	440b      	add	r3, r1
 8012078:	6812      	ldr	r2, [r2, #0]
 801207a:	601a      	str	r2, [r3, #0]
 801207c:	697b      	ldr	r3, [r7, #20]
 801207e:	009b      	lsls	r3, r3, #2
 8012080:	69fa      	ldr	r2, [r7, #28]
 8012082:	4413      	add	r3, r2
 8012084:	693a      	ldr	r2, [r7, #16]
 8012086:	601a      	str	r2, [r3, #0]
            temp = rk[i + 1]; rk[i + 1] = rk[j + 1]; rk[j + 1] = temp;
 8012088:	69bb      	ldr	r3, [r7, #24]
 801208a:	3301      	adds	r3, #1
 801208c:	009b      	lsls	r3, r3, #2
 801208e:	69fa      	ldr	r2, [r7, #28]
 8012090:	4413      	add	r3, r2
 8012092:	681b      	ldr	r3, [r3, #0]
 8012094:	613b      	str	r3, [r7, #16]
 8012096:	697b      	ldr	r3, [r7, #20]
 8012098:	3301      	adds	r3, #1
 801209a:	009b      	lsls	r3, r3, #2
 801209c:	69fa      	ldr	r2, [r7, #28]
 801209e:	441a      	add	r2, r3
 80120a0:	69bb      	ldr	r3, [r7, #24]
 80120a2:	3301      	adds	r3, #1
 80120a4:	009b      	lsls	r3, r3, #2
 80120a6:	69f9      	ldr	r1, [r7, #28]
 80120a8:	440b      	add	r3, r1
 80120aa:	6812      	ldr	r2, [r2, #0]
 80120ac:	601a      	str	r2, [r3, #0]
 80120ae:	697b      	ldr	r3, [r7, #20]
 80120b0:	3301      	adds	r3, #1
 80120b2:	009b      	lsls	r3, r3, #2
 80120b4:	69fa      	ldr	r2, [r7, #28]
 80120b6:	4413      	add	r3, r2
 80120b8:	693a      	ldr	r2, [r7, #16]
 80120ba:	601a      	str	r2, [r3, #0]
            temp = rk[i + 2]; rk[i + 2] = rk[j + 2]; rk[j + 2] = temp;
 80120bc:	69bb      	ldr	r3, [r7, #24]
 80120be:	3302      	adds	r3, #2
 80120c0:	009b      	lsls	r3, r3, #2
 80120c2:	69fa      	ldr	r2, [r7, #28]
 80120c4:	4413      	add	r3, r2
 80120c6:	681b      	ldr	r3, [r3, #0]
 80120c8:	613b      	str	r3, [r7, #16]
 80120ca:	697b      	ldr	r3, [r7, #20]
 80120cc:	3302      	adds	r3, #2
 80120ce:	009b      	lsls	r3, r3, #2
 80120d0:	69fa      	ldr	r2, [r7, #28]
 80120d2:	441a      	add	r2, r3
 80120d4:	69bb      	ldr	r3, [r7, #24]
 80120d6:	3302      	adds	r3, #2
 80120d8:	009b      	lsls	r3, r3, #2
 80120da:	69f9      	ldr	r1, [r7, #28]
 80120dc:	440b      	add	r3, r1
 80120de:	6812      	ldr	r2, [r2, #0]
 80120e0:	601a      	str	r2, [r3, #0]
 80120e2:	697b      	ldr	r3, [r7, #20]
 80120e4:	3302      	adds	r3, #2
 80120e6:	009b      	lsls	r3, r3, #2
 80120e8:	69fa      	ldr	r2, [r7, #28]
 80120ea:	4413      	add	r3, r2
 80120ec:	693a      	ldr	r2, [r7, #16]
 80120ee:	601a      	str	r2, [r3, #0]
            temp = rk[i + 3]; rk[i + 3] = rk[j + 3]; rk[j + 3] = temp;
 80120f0:	69bb      	ldr	r3, [r7, #24]
 80120f2:	3303      	adds	r3, #3
 80120f4:	009b      	lsls	r3, r3, #2
 80120f6:	69fa      	ldr	r2, [r7, #28]
 80120f8:	4413      	add	r3, r2
 80120fa:	681b      	ldr	r3, [r3, #0]
 80120fc:	613b      	str	r3, [r7, #16]
 80120fe:	697b      	ldr	r3, [r7, #20]
 8012100:	3303      	adds	r3, #3
 8012102:	009b      	lsls	r3, r3, #2
 8012104:	69fa      	ldr	r2, [r7, #28]
 8012106:	441a      	add	r2, r3
 8012108:	69bb      	ldr	r3, [r7, #24]
 801210a:	3303      	adds	r3, #3
 801210c:	009b      	lsls	r3, r3, #2
 801210e:	69f9      	ldr	r1, [r7, #28]
 8012110:	440b      	add	r3, r1
 8012112:	6812      	ldr	r2, [r2, #0]
 8012114:	601a      	str	r2, [r3, #0]
 8012116:	697b      	ldr	r3, [r7, #20]
 8012118:	3303      	adds	r3, #3
 801211a:	009b      	lsls	r3, r3, #2
 801211c:	69fa      	ldr	r2, [r7, #28]
 801211e:	4413      	add	r3, r2
 8012120:	693a      	ldr	r2, [r7, #16]
 8012122:	601a      	str	r2, [r3, #0]
        for (i = 0, j = 4* aes->rounds; i < j; i += 4, j -= 4) {
 8012124:	69bb      	ldr	r3, [r7, #24]
 8012126:	3304      	adds	r3, #4
 8012128:	61bb      	str	r3, [r7, #24]
 801212a:	697b      	ldr	r3, [r7, #20]
 801212c:	3b04      	subs	r3, #4
 801212e:	617b      	str	r3, [r7, #20]
 8012130:	69ba      	ldr	r2, [r7, #24]
 8012132:	697b      	ldr	r3, [r7, #20]
 8012134:	429a      	cmp	r2, r3
 8012136:	d391      	bcc.n	801205c <AesSetKey_C+0x388>
        }
        ForceZero(&temp, sizeof(temp));
 8012138:	f107 0310 	add.w	r3, r7, #16
 801213c:	2104      	movs	r1, #4
 801213e:	4618      	mov	r0, r3
 8012140:	f7fd fb0f 	bl	800f762 <ForceZero>
    #if !defined(WOLFSSL_AES_SMALL_TABLES)
        /* apply the inverse MixColumn transform to all round keys but the
           first and the last: */
        for (i = 1; i < aes->rounds; i++) {
 8012144:	2301      	movs	r3, #1
 8012146:	61bb      	str	r3, [r7, #24]
 8012148:	e114      	b.n	8012374 <AesSetKey_C+0x6a0>
 801214a:	bf00      	nop
 801214c:	08031494 	.word	0x08031494
 8012150:	0803146c 	.word	0x0803146c
            rk += 4;
 8012154:	69fb      	ldr	r3, [r7, #28]
 8012156:	3310      	adds	r3, #16
 8012158:	61fb      	str	r3, [r7, #28]
            rk[0] =
                GetTable(Td[0], GetTable(Te[1], GETBYTE(rk[0], 3)) & 0xff) ^
 801215a:	69fb      	ldr	r3, [r7, #28]
 801215c:	681b      	ldr	r3, [r3, #0]
 801215e:	0e1b      	lsrs	r3, r3, #24
 8012160:	b2db      	uxtb	r3, r3
 8012162:	4a8a      	ldr	r2, [pc, #552]	@ (801238c <AesSetKey_C+0x6b8>)
 8012164:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8012168:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801216c:	b2db      	uxtb	r3, r3
 801216e:	4a88      	ldr	r2, [pc, #544]	@ (8012390 <AesSetKey_C+0x6bc>)
 8012170:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
                GetTable(Td[1], GetTable(Te[1], GETBYTE(rk[0], 2)) & 0xff) ^
 8012174:	69fb      	ldr	r3, [r7, #28]
 8012176:	681b      	ldr	r3, [r3, #0]
 8012178:	0c1b      	lsrs	r3, r3, #16
 801217a:	b2db      	uxtb	r3, r3
 801217c:	4983      	ldr	r1, [pc, #524]	@ (801238c <AesSetKey_C+0x6b8>)
 801217e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8012182:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8012186:	b2db      	uxtb	r3, r3
 8012188:	4981      	ldr	r1, [pc, #516]	@ (8012390 <AesSetKey_C+0x6bc>)
 801218a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801218e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
                GetTable(Td[0], GetTable(Te[1], GETBYTE(rk[0], 3)) & 0xff) ^
 8012192:	405a      	eors	r2, r3
                GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[0], 1)) & 0xff) ^
 8012194:	69fb      	ldr	r3, [r7, #28]
 8012196:	681b      	ldr	r3, [r3, #0]
 8012198:	0a1b      	lsrs	r3, r3, #8
 801219a:	b2db      	uxtb	r3, r3
 801219c:	497b      	ldr	r1, [pc, #492]	@ (801238c <AesSetKey_C+0x6b8>)
 801219e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80121a2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80121a6:	b2db      	uxtb	r3, r3
 80121a8:	4979      	ldr	r1, [pc, #484]	@ (8012390 <AesSetKey_C+0x6bc>)
 80121aa:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80121ae:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
                GetTable(Td[1], GetTable(Te[1], GETBYTE(rk[0], 2)) & 0xff) ^
 80121b2:	405a      	eors	r2, r3
                GetTable(Td[3], GetTable(Te[1], GETBYTE(rk[0], 0)) & 0xff);
 80121b4:	69fb      	ldr	r3, [r7, #28]
 80121b6:	681b      	ldr	r3, [r3, #0]
 80121b8:	b2db      	uxtb	r3, r3
 80121ba:	4974      	ldr	r1, [pc, #464]	@ (801238c <AesSetKey_C+0x6b8>)
 80121bc:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80121c0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80121c4:	b2db      	uxtb	r3, r3
 80121c6:	4972      	ldr	r1, [pc, #456]	@ (8012390 <AesSetKey_C+0x6bc>)
 80121c8:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80121cc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
                GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[0], 1)) & 0xff) ^
 80121d0:	405a      	eors	r2, r3
            rk[0] =
 80121d2:	69fb      	ldr	r3, [r7, #28]
 80121d4:	601a      	str	r2, [r3, #0]
            rk[1] =
                GetTable(Td[0], GetTable(Te[1], GETBYTE(rk[1], 3)) & 0xff) ^
 80121d6:	69fb      	ldr	r3, [r7, #28]
 80121d8:	3304      	adds	r3, #4
 80121da:	681b      	ldr	r3, [r3, #0]
 80121dc:	0e1b      	lsrs	r3, r3, #24
 80121de:	b2db      	uxtb	r3, r3
 80121e0:	4a6a      	ldr	r2, [pc, #424]	@ (801238c <AesSetKey_C+0x6b8>)
 80121e2:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80121e6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80121ea:	b2db      	uxtb	r3, r3
 80121ec:	4a68      	ldr	r2, [pc, #416]	@ (8012390 <AesSetKey_C+0x6bc>)
 80121ee:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
                GetTable(Td[1], GetTable(Te[1], GETBYTE(rk[1], 2)) & 0xff) ^
 80121f2:	69fb      	ldr	r3, [r7, #28]
 80121f4:	3304      	adds	r3, #4
 80121f6:	681b      	ldr	r3, [r3, #0]
 80121f8:	0c1b      	lsrs	r3, r3, #16
 80121fa:	b2db      	uxtb	r3, r3
 80121fc:	4963      	ldr	r1, [pc, #396]	@ (801238c <AesSetKey_C+0x6b8>)
 80121fe:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8012202:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8012206:	b2db      	uxtb	r3, r3
 8012208:	4961      	ldr	r1, [pc, #388]	@ (8012390 <AesSetKey_C+0x6bc>)
 801220a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801220e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
                GetTable(Td[0], GetTable(Te[1], GETBYTE(rk[1], 3)) & 0xff) ^
 8012212:	405a      	eors	r2, r3
                GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[1], 1)) & 0xff) ^
 8012214:	69fb      	ldr	r3, [r7, #28]
 8012216:	3304      	adds	r3, #4
 8012218:	681b      	ldr	r3, [r3, #0]
 801221a:	0a1b      	lsrs	r3, r3, #8
 801221c:	b2db      	uxtb	r3, r3
 801221e:	495b      	ldr	r1, [pc, #364]	@ (801238c <AesSetKey_C+0x6b8>)
 8012220:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8012224:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8012228:	b2db      	uxtb	r3, r3
 801222a:	4959      	ldr	r1, [pc, #356]	@ (8012390 <AesSetKey_C+0x6bc>)
 801222c:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8012230:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
                GetTable(Td[1], GetTable(Te[1], GETBYTE(rk[1], 2)) & 0xff) ^
 8012234:	ea82 0103 	eor.w	r1, r2, r3
                GetTable(Td[3], GetTable(Te[1], GETBYTE(rk[1], 0)) & 0xff);
 8012238:	69fb      	ldr	r3, [r7, #28]
 801223a:	3304      	adds	r3, #4
 801223c:	681b      	ldr	r3, [r3, #0]
 801223e:	b2db      	uxtb	r3, r3
 8012240:	4a52      	ldr	r2, [pc, #328]	@ (801238c <AesSetKey_C+0x6b8>)
 8012242:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8012246:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801224a:	b2db      	uxtb	r3, r3
 801224c:	4a50      	ldr	r2, [pc, #320]	@ (8012390 <AesSetKey_C+0x6bc>)
 801224e:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8012252:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
            rk[1] =
 8012256:	69fb      	ldr	r3, [r7, #28]
 8012258:	3304      	adds	r3, #4
                GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[1], 1)) & 0xff) ^
 801225a:	404a      	eors	r2, r1
            rk[1] =
 801225c:	601a      	str	r2, [r3, #0]
            rk[2] =
                GetTable(Td[0], GetTable(Te[1], GETBYTE(rk[2], 3)) & 0xff) ^
 801225e:	69fb      	ldr	r3, [r7, #28]
 8012260:	3308      	adds	r3, #8
 8012262:	681b      	ldr	r3, [r3, #0]
 8012264:	0e1b      	lsrs	r3, r3, #24
 8012266:	b2db      	uxtb	r3, r3
 8012268:	4a48      	ldr	r2, [pc, #288]	@ (801238c <AesSetKey_C+0x6b8>)
 801226a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801226e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8012272:	b2db      	uxtb	r3, r3
 8012274:	4a46      	ldr	r2, [pc, #280]	@ (8012390 <AesSetKey_C+0x6bc>)
 8012276:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
                GetTable(Td[1], GetTable(Te[1], GETBYTE(rk[2], 2)) & 0xff) ^
 801227a:	69fb      	ldr	r3, [r7, #28]
 801227c:	3308      	adds	r3, #8
 801227e:	681b      	ldr	r3, [r3, #0]
 8012280:	0c1b      	lsrs	r3, r3, #16
 8012282:	b2db      	uxtb	r3, r3
 8012284:	4941      	ldr	r1, [pc, #260]	@ (801238c <AesSetKey_C+0x6b8>)
 8012286:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801228a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801228e:	b2db      	uxtb	r3, r3
 8012290:	493f      	ldr	r1, [pc, #252]	@ (8012390 <AesSetKey_C+0x6bc>)
 8012292:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8012296:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
                GetTable(Td[0], GetTable(Te[1], GETBYTE(rk[2], 3)) & 0xff) ^
 801229a:	405a      	eors	r2, r3
                GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[2], 1)) & 0xff) ^
 801229c:	69fb      	ldr	r3, [r7, #28]
 801229e:	3308      	adds	r3, #8
 80122a0:	681b      	ldr	r3, [r3, #0]
 80122a2:	0a1b      	lsrs	r3, r3, #8
 80122a4:	b2db      	uxtb	r3, r3
 80122a6:	4939      	ldr	r1, [pc, #228]	@ (801238c <AesSetKey_C+0x6b8>)
 80122a8:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80122ac:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80122b0:	b2db      	uxtb	r3, r3
 80122b2:	4937      	ldr	r1, [pc, #220]	@ (8012390 <AesSetKey_C+0x6bc>)
 80122b4:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80122b8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
                GetTable(Td[1], GetTable(Te[1], GETBYTE(rk[2], 2)) & 0xff) ^
 80122bc:	ea82 0103 	eor.w	r1, r2, r3
                GetTable(Td[3], GetTable(Te[1], GETBYTE(rk[2], 0)) & 0xff);
 80122c0:	69fb      	ldr	r3, [r7, #28]
 80122c2:	3308      	adds	r3, #8
 80122c4:	681b      	ldr	r3, [r3, #0]
 80122c6:	b2db      	uxtb	r3, r3
 80122c8:	4a30      	ldr	r2, [pc, #192]	@ (801238c <AesSetKey_C+0x6b8>)
 80122ca:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80122ce:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80122d2:	b2db      	uxtb	r3, r3
 80122d4:	4a2e      	ldr	r2, [pc, #184]	@ (8012390 <AesSetKey_C+0x6bc>)
 80122d6:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80122da:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
            rk[2] =
 80122de:	69fb      	ldr	r3, [r7, #28]
 80122e0:	3308      	adds	r3, #8
                GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[2], 1)) & 0xff) ^
 80122e2:	404a      	eors	r2, r1
            rk[2] =
 80122e4:	601a      	str	r2, [r3, #0]
            rk[3] =
                GetTable(Td[0], GetTable(Te[1], GETBYTE(rk[3], 3)) & 0xff) ^
 80122e6:	69fb      	ldr	r3, [r7, #28]
 80122e8:	330c      	adds	r3, #12
 80122ea:	681b      	ldr	r3, [r3, #0]
 80122ec:	0e1b      	lsrs	r3, r3, #24
 80122ee:	b2db      	uxtb	r3, r3
 80122f0:	4a26      	ldr	r2, [pc, #152]	@ (801238c <AesSetKey_C+0x6b8>)
 80122f2:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80122f6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80122fa:	b2db      	uxtb	r3, r3
 80122fc:	4a24      	ldr	r2, [pc, #144]	@ (8012390 <AesSetKey_C+0x6bc>)
 80122fe:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
                GetTable(Td[1], GetTable(Te[1], GETBYTE(rk[3], 2)) & 0xff) ^
 8012302:	69fb      	ldr	r3, [r7, #28]
 8012304:	330c      	adds	r3, #12
 8012306:	681b      	ldr	r3, [r3, #0]
 8012308:	0c1b      	lsrs	r3, r3, #16
 801230a:	b2db      	uxtb	r3, r3
 801230c:	491f      	ldr	r1, [pc, #124]	@ (801238c <AesSetKey_C+0x6b8>)
 801230e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8012312:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8012316:	b2db      	uxtb	r3, r3
 8012318:	491d      	ldr	r1, [pc, #116]	@ (8012390 <AesSetKey_C+0x6bc>)
 801231a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801231e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
                GetTable(Td[0], GetTable(Te[1], GETBYTE(rk[3], 3)) & 0xff) ^
 8012322:	405a      	eors	r2, r3
                GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[3], 1)) & 0xff) ^
 8012324:	69fb      	ldr	r3, [r7, #28]
 8012326:	330c      	adds	r3, #12
 8012328:	681b      	ldr	r3, [r3, #0]
 801232a:	0a1b      	lsrs	r3, r3, #8
 801232c:	b2db      	uxtb	r3, r3
 801232e:	4917      	ldr	r1, [pc, #92]	@ (801238c <AesSetKey_C+0x6b8>)
 8012330:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8012334:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8012338:	b2db      	uxtb	r3, r3
 801233a:	4915      	ldr	r1, [pc, #84]	@ (8012390 <AesSetKey_C+0x6bc>)
 801233c:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8012340:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
                GetTable(Td[1], GetTable(Te[1], GETBYTE(rk[3], 2)) & 0xff) ^
 8012344:	ea82 0103 	eor.w	r1, r2, r3
                GetTable(Td[3], GetTable(Te[1], GETBYTE(rk[3], 0)) & 0xff);
 8012348:	69fb      	ldr	r3, [r7, #28]
 801234a:	330c      	adds	r3, #12
 801234c:	681b      	ldr	r3, [r3, #0]
 801234e:	b2db      	uxtb	r3, r3
 8012350:	4a0e      	ldr	r2, [pc, #56]	@ (801238c <AesSetKey_C+0x6b8>)
 8012352:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8012356:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801235a:	b2db      	uxtb	r3, r3
 801235c:	4a0c      	ldr	r2, [pc, #48]	@ (8012390 <AesSetKey_C+0x6bc>)
 801235e:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8012362:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
            rk[3] =
 8012366:	69fb      	ldr	r3, [r7, #28]
 8012368:	330c      	adds	r3, #12
                GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[3], 1)) & 0xff) ^
 801236a:	404a      	eors	r2, r1
            rk[3] =
 801236c:	601a      	str	r2, [r3, #0]
        for (i = 1; i < aes->rounds; i++) {
 801236e:	69bb      	ldr	r3, [r7, #24]
 8012370:	3301      	adds	r3, #1
 8012372:	61bb      	str	r3, [r7, #24]
 8012374:	68fb      	ldr	r3, [r7, #12]
 8012376:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 801237a:	69ba      	ldr	r2, [r7, #24]
 801237c:	429a      	cmp	r2, r3
 801237e:	f4ff aee9 	bcc.w	8012154 <AesSetKey_C+0x480>
#ifdef WOLFSSL_CHECK_MEM_ZERO
    wc_MemZero_Check(&temp, sizeof(temp));
#else
    (void)temp;
#endif
}
 8012382:	bf00      	nop
 8012384:	3720      	adds	r7, #32
 8012386:	46bd      	mov	sp, r7
 8012388:	bd80      	pop	{r7, pc}
 801238a:	bf00      	nop
 801238c:	08031494 	.word	0x08031494
 8012390:	08032494 	.word	0x08032494

08012394 <wc_AesSetKeyLocal>:
#ifndef WOLFSSL_RISCV_ASM
    /* Software AES - SetKey */
    static WARN_UNUSED_RESULT int wc_AesSetKeyLocal(
        Aes* aes, const byte* userKey, word32 keylen, const byte* iv, int dir,
        int checkKeyLen)
    {
 8012394:	b580      	push	{r7, lr}
 8012396:	b086      	sub	sp, #24
 8012398:	af00      	add	r7, sp, #0
 801239a:	60f8      	str	r0, [r7, #12]
 801239c:	60b9      	str	r1, [r7, #8]
 801239e:	607a      	str	r2, [r7, #4]
 80123a0:	603b      	str	r3, [r7, #0]
    #ifdef WOLFSSL_IMX6_CAAM_BLOB
        byte   local[32];
        word32 localSz = 32;
    #endif

        if (aes == NULL)
 80123a2:	68fb      	ldr	r3, [r7, #12]
 80123a4:	2b00      	cmp	r3, #0
 80123a6:	d102      	bne.n	80123ae <wc_AesSetKeyLocal+0x1a>
            return BAD_FUNC_ARG;
 80123a8:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80123ac:	e054      	b.n	8012458 <wc_AesSetKeyLocal+0xc4>
        ret = wc_debug_CipherLifecycleCheck(aes->CipherLifecycleTag, 0);
        if (ret < 0)
            return ret;
#endif

        switch (keylen) {
 80123ae:	687b      	ldr	r3, [r7, #4]
 80123b0:	3b10      	subs	r3, #16
 80123b2:	2b10      	cmp	r3, #16
 80123b4:	bf8c      	ite	hi
 80123b6:	2201      	movhi	r2, #1
 80123b8:	2200      	movls	r2, #0
 80123ba:	b2d2      	uxtb	r2, r2
 80123bc:	2a00      	cmp	r2, #0
 80123be:	d10b      	bne.n	80123d8 <wc_AesSetKeyLocal+0x44>
 80123c0:	4a27      	ldr	r2, [pc, #156]	@ (8012460 <wc_AesSetKeyLocal+0xcc>)
 80123c2:	fa22 f303 	lsr.w	r3, r2, r3
 80123c6:	f003 0301 	and.w	r3, r3, #1
 80123ca:	2b00      	cmp	r3, #0
 80123cc:	bf14      	ite	ne
 80123ce:	2301      	movne	r3, #1
 80123d0:	2300      	moveq	r3, #0
 80123d2:	b2db      	uxtb	r3, r3
 80123d4:	2b00      	cmp	r3, #0
 80123d6:	d102      	bne.n	80123de <wc_AesSetKeyLocal+0x4a>
        defined(WOLFSSL_AES_256)
        case 32:
    #endif
            break;
        default:
            return BAD_FUNC_ARG;
 80123d8:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80123dc:	e03c      	b.n	8012458 <wc_AesSetKeyLocal+0xc4>
            break;
 80123de:	bf00      	nop
            }
            XMEMCPY(aes->devKey, userKey, keylen);
        }
    #endif

        if (checkKeyLen) {
 80123e0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80123e2:	2b00      	cmp	r3, #0
 80123e4:	d00b      	beq.n	80123fe <wc_AesSetKeyLocal+0x6a>
            if (keylen != 16 && keylen != 24 && keylen != 32) {
 80123e6:	687b      	ldr	r3, [r7, #4]
 80123e8:	2b10      	cmp	r3, #16
 80123ea:	d008      	beq.n	80123fe <wc_AesSetKeyLocal+0x6a>
 80123ec:	687b      	ldr	r3, [r7, #4]
 80123ee:	2b18      	cmp	r3, #24
 80123f0:	d005      	beq.n	80123fe <wc_AesSetKeyLocal+0x6a>
 80123f2:	687b      	ldr	r3, [r7, #4]
 80123f4:	2b20      	cmp	r3, #32
 80123f6:	d002      	beq.n	80123fe <wc_AesSetKeyLocal+0x6a>
                return BAD_FUNC_ARG;
 80123f8:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80123fc:	e02c      	b.n	8012458 <wc_AesSetKeyLocal+0xc4>
    #if defined(WOLFSSL_AES_COUNTER) || defined(WOLFSSL_AES_CFB) || \
        defined(WOLFSSL_AES_OFB) || defined(WOLFSSL_AES_XTS)
        aes->left = 0;
    #endif

        aes->keylen = (int)keylen;
 80123fe:	687a      	ldr	r2, [r7, #4]
 8012400:	68fb      	ldr	r3, [r7, #12]
 8012402:	f8c3 20f4 	str.w	r2, [r3, #244]	@ 0xf4
        aes->rounds = (keylen/4) + 6;
 8012406:	687b      	ldr	r3, [r7, #4]
 8012408:	089b      	lsrs	r3, r3, #2
 801240a:	1d9a      	adds	r2, r3, #6
 801240c:	68fb      	ldr	r3, [r7, #12]
 801240e:	f8c3 20f0 	str.w	r2, [r3, #240]	@ 0xf0
        ret = wc_AesSetIV(aes, iv);
 8012412:	6839      	ldr	r1, [r7, #0]
 8012414:	68f8      	ldr	r0, [r7, #12]
 8012416:	f000 f847 	bl	80124a8 <wc_AesSetIV>
 801241a:	6178      	str	r0, [r7, #20]
        if (ret != 0)
 801241c:	697b      	ldr	r3, [r7, #20]
 801241e:	2b00      	cmp	r3, #0
 8012420:	d001      	beq.n	8012426 <wc_AesSetKeyLocal+0x92>
            return ret;
 8012422:	697b      	ldr	r3, [r7, #20]
 8012424:	e018      	b.n	8012458 <wc_AesSetKeyLocal+0xc4>
            aes->init = 0;
        }
        (void)dir;
    #endif

        if (keylen > sizeof(aes->key)) {
 8012426:	687b      	ldr	r3, [r7, #4]
 8012428:	2bf0      	cmp	r3, #240	@ 0xf0
 801242a:	d902      	bls.n	8012432 <wc_AesSetKeyLocal+0x9e>
            return BAD_FUNC_ARG;
 801242c:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8012430:	e012      	b.n	8012458 <wc_AesSetKeyLocal+0xc4>
            }
            return ret;
        }
#endif

        XMEMCPY(aes->key, userKey, keylen);
 8012432:	68fb      	ldr	r3, [r7, #12]
 8012434:	687a      	ldr	r2, [r7, #4]
 8012436:	68b9      	ldr	r1, [r7, #8]
 8012438:	4618      	mov	r0, r3
 801243a:	f016 f8af 	bl	802859c <memcpy>
    #if defined(LITTLE_ENDIAN_ORDER) && !defined(WOLFSSL_PIC32MZ_CRYPT) && \
        (!defined(WOLFSSL_ESP32_CRYPT) || defined(NO_WOLFSSL_ESP32_CRYPT_AES)) \
        && !defined(MAX3266X_AES)

        /* software */
        ByteReverseWords(aes->key, aes->key, keylen);
 801243e:	68fb      	ldr	r3, [r7, #12]
 8012440:	68f9      	ldr	r1, [r7, #12]
 8012442:	687a      	ldr	r2, [r7, #4]
 8012444:	4618      	mov	r0, r3
 8012446:	f7fd f8e7 	bl	800f618 <ByteReverseWords>
        }
    #endif
#endif /* !WC_AES_BITSLICED */

#ifdef NEED_AES_TABLES
        AesSetKey_C(aes, userKey, keylen, dir);
 801244a:	6a3b      	ldr	r3, [r7, #32]
 801244c:	687a      	ldr	r2, [r7, #4]
 801244e:	68b9      	ldr	r1, [r7, #8]
 8012450:	68f8      	ldr	r0, [r7, #12]
 8012452:	f7ff fc3f 	bl	8011cd4 <AesSetKey_C>
        aes->ctx.cfd = -1;
    #endif
    #ifdef WOLFSSL_IMX6_CAAM_BLOB
        ForceZero(local, sizeof(local));
    #endif
        return ret;
 8012456:	697b      	ldr	r3, [r7, #20]
    } /* wc_AesSetKeyLocal */
 8012458:	4618      	mov	r0, r3
 801245a:	3718      	adds	r7, #24
 801245c:	46bd      	mov	sp, r7
 801245e:	bd80      	pop	{r7, pc}
 8012460:	00010101 	.word	0x00010101

08012464 <wc_AesSetKey>:

    int wc_AesSetKey(Aes* aes, const byte* userKey, word32 keylen,
            const byte* iv, int dir)
    {
 8012464:	b580      	push	{r7, lr}
 8012466:	b086      	sub	sp, #24
 8012468:	af02      	add	r7, sp, #8
 801246a:	60f8      	str	r0, [r7, #12]
 801246c:	60b9      	str	r1, [r7, #8]
 801246e:	607a      	str	r2, [r7, #4]
 8012470:	603b      	str	r3, [r7, #0]
        if (aes == NULL) {
 8012472:	68fb      	ldr	r3, [r7, #12]
 8012474:	2b00      	cmp	r3, #0
 8012476:	d102      	bne.n	801247e <wc_AesSetKey+0x1a>
            return BAD_FUNC_ARG;
 8012478:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801247c:	e010      	b.n	80124a0 <wc_AesSetKey+0x3c>
        }
        if (keylen > sizeof(aes->key)) {
 801247e:	687b      	ldr	r3, [r7, #4]
 8012480:	2bf0      	cmp	r3, #240	@ 0xf0
 8012482:	d902      	bls.n	801248a <wc_AesSetKey+0x26>
            return BAD_FUNC_ARG;
 8012484:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8012488:	e00a      	b.n	80124a0 <wc_AesSetKey+0x3c>
                           keylen);
        #endif
        }
    #endif /* WOLFSSL_ESPIDF && NEED_AES_HW_FALLBACK */

        return wc_AesSetKeyLocal(aes, userKey, keylen, iv, dir, 1);
 801248a:	2301      	movs	r3, #1
 801248c:	9301      	str	r3, [sp, #4]
 801248e:	69bb      	ldr	r3, [r7, #24]
 8012490:	9300      	str	r3, [sp, #0]
 8012492:	683b      	ldr	r3, [r7, #0]
 8012494:	687a      	ldr	r2, [r7, #4]
 8012496:	68b9      	ldr	r1, [r7, #8]
 8012498:	68f8      	ldr	r0, [r7, #12]
 801249a:	f7ff ff7b 	bl	8012394 <wc_AesSetKeyLocal>
 801249e:	4603      	mov	r3, r0

    } /* wc_AesSetKey() */
 80124a0:	4618      	mov	r0, r3
 80124a2:	3710      	adds	r7, #16
 80124a4:	46bd      	mov	sp, r7
 80124a6:	bd80      	pop	{r7, pc}

080124a8 <wc_AesSetIV>:
#endif /* wc_AesSetKey block */


/* wc_AesSetIV is shared between software and hardware */
int wc_AesSetIV(Aes* aes, const byte* iv)
{
 80124a8:	b580      	push	{r7, lr}
 80124aa:	b082      	sub	sp, #8
 80124ac:	af00      	add	r7, sp, #0
 80124ae:	6078      	str	r0, [r7, #4]
 80124b0:	6039      	str	r1, [r7, #0]
    if (aes == NULL)
 80124b2:	687b      	ldr	r3, [r7, #4]
 80124b4:	2b00      	cmp	r3, #0
 80124b6:	d102      	bne.n	80124be <wc_AesSetIV+0x16>
        return BAD_FUNC_ARG;
 80124b8:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80124bc:	e012      	b.n	80124e4 <wc_AesSetIV+0x3c>
        if (ret < 0)
            return ret;
    }
#endif

    if (iv)
 80124be:	683b      	ldr	r3, [r7, #0]
 80124c0:	2b00      	cmp	r3, #0
 80124c2:	d007      	beq.n	80124d4 <wc_AesSetIV+0x2c>
        XMEMCPY(aes->reg, iv, WC_AES_BLOCK_SIZE);
 80124c4:	687b      	ldr	r3, [r7, #4]
 80124c6:	33f8      	adds	r3, #248	@ 0xf8
 80124c8:	2210      	movs	r2, #16
 80124ca:	6839      	ldr	r1, [r7, #0]
 80124cc:	4618      	mov	r0, r3
 80124ce:	f016 f865 	bl	802859c <memcpy>
 80124d2:	e006      	b.n	80124e2 <wc_AesSetIV+0x3a>
    else
        XMEMSET(aes->reg,  0, WC_AES_BLOCK_SIZE);
 80124d4:	687b      	ldr	r3, [r7, #4]
 80124d6:	33f8      	adds	r3, #248	@ 0xf8
 80124d8:	2210      	movs	r2, #16
 80124da:	2100      	movs	r1, #0
 80124dc:	4618      	mov	r0, r3
 80124de:	f015 fff3 	bl	80284c8 <memset>
    defined(WOLFSSL_AES_OFB) || defined(WOLFSSL_AES_XTS)
    /* Clear any unused bytes from last cipher op. */
    aes->left = 0;
#endif

    return 0;
 80124e2:	2300      	movs	r3, #0
}
 80124e4:	4618      	mov	r0, r3
 80124e6:	3708      	adds	r7, #8
 80124e8:	46bd      	mov	sp, r7
 80124ea:	bd80      	pop	{r7, pc}

080124ec <wc_AesCbcEncrypt>:

#ifdef NEED_SW_AESCBC
    /* Software AES - CBC Encrypt */

int wc_AesCbcEncrypt(Aes* aes, byte* out, const byte* in, word32 sz)
    {
 80124ec:	b580      	push	{r7, lr}
 80124ee:	b086      	sub	sp, #24
 80124f0:	af00      	add	r7, sp, #0
 80124f2:	60f8      	str	r0, [r7, #12]
 80124f4:	60b9      	str	r1, [r7, #8]
 80124f6:	607a      	str	r2, [r7, #4]
 80124f8:	603b      	str	r3, [r7, #0]
        word32 blocks;
        int ret;

        if (aes == NULL || out == NULL || in == NULL) {
 80124fa:	68fb      	ldr	r3, [r7, #12]
 80124fc:	2b00      	cmp	r3, #0
 80124fe:	d005      	beq.n	801250c <wc_AesCbcEncrypt+0x20>
 8012500:	68bb      	ldr	r3, [r7, #8]
 8012502:	2b00      	cmp	r3, #0
 8012504:	d002      	beq.n	801250c <wc_AesCbcEncrypt+0x20>
 8012506:	687b      	ldr	r3, [r7, #4]
 8012508:	2b00      	cmp	r3, #0
 801250a:	d102      	bne.n	8012512 <wc_AesCbcEncrypt+0x26>
            return BAD_FUNC_ARG;
 801250c:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8012510:	e033      	b.n	801257a <wc_AesCbcEncrypt+0x8e>
        }

        if (sz == 0) {
 8012512:	683b      	ldr	r3, [r7, #0]
 8012514:	2b00      	cmp	r3, #0
 8012516:	d101      	bne.n	801251c <wc_AesCbcEncrypt+0x30>
            return 0;
 8012518:	2300      	movs	r3, #0
 801251a:	e02e      	b.n	801257a <wc_AesCbcEncrypt+0x8e>
        }

        blocks = sz / WC_AES_BLOCK_SIZE;
 801251c:	683b      	ldr	r3, [r7, #0]
 801251e:	091b      	lsrs	r3, r3, #4
 8012520:	617b      	str	r3, [r7, #20]
            ret = 0;
        }
        else
    #endif
        {
            ret = 0;
 8012522:	2300      	movs	r3, #0
 8012524:	613b      	str	r3, [r7, #16]
            while (blocks--) {
 8012526:	e020      	b.n	801256a <wc_AesCbcEncrypt+0x7e>
                xorbuf((byte*)aes->reg, in, WC_AES_BLOCK_SIZE);
 8012528:	68fb      	ldr	r3, [r7, #12]
 801252a:	33f8      	adds	r3, #248	@ 0xf8
 801252c:	2210      	movs	r2, #16
 801252e:	6879      	ldr	r1, [r7, #4]
 8012530:	4618      	mov	r0, r3
 8012532:	f7fd f8bc 	bl	800f6ae <xorbuf>
                ret = wc_AesEncrypt(aes, (byte*)aes->reg, (byte*)aes->reg);
 8012536:	68fb      	ldr	r3, [r7, #12]
 8012538:	f103 01f8 	add.w	r1, r3, #248	@ 0xf8
 801253c:	68fb      	ldr	r3, [r7, #12]
 801253e:	33f8      	adds	r3, #248	@ 0xf8
 8012540:	461a      	mov	r2, r3
 8012542:	68f8      	ldr	r0, [r7, #12]
 8012544:	f7fe fa52 	bl	80109ec <wc_AesEncrypt>
 8012548:	6138      	str	r0, [r7, #16]
                if (ret != 0)
 801254a:	693b      	ldr	r3, [r7, #16]
 801254c:	2b00      	cmp	r3, #0
 801254e:	d112      	bne.n	8012576 <wc_AesCbcEncrypt+0x8a>
                    break;
                XMEMCPY(out, aes->reg, WC_AES_BLOCK_SIZE);
 8012550:	68fb      	ldr	r3, [r7, #12]
 8012552:	33f8      	adds	r3, #248	@ 0xf8
 8012554:	2210      	movs	r2, #16
 8012556:	4619      	mov	r1, r3
 8012558:	68b8      	ldr	r0, [r7, #8]
 801255a:	f016 f81f 	bl	802859c <memcpy>

                out += WC_AES_BLOCK_SIZE;
 801255e:	68bb      	ldr	r3, [r7, #8]
 8012560:	3310      	adds	r3, #16
 8012562:	60bb      	str	r3, [r7, #8]
                in  += WC_AES_BLOCK_SIZE;
 8012564:	687b      	ldr	r3, [r7, #4]
 8012566:	3310      	adds	r3, #16
 8012568:	607b      	str	r3, [r7, #4]
            while (blocks--) {
 801256a:	697b      	ldr	r3, [r7, #20]
 801256c:	1e5a      	subs	r2, r3, #1
 801256e:	617a      	str	r2, [r7, #20]
 8012570:	2b00      	cmp	r3, #0
 8012572:	d1d9      	bne.n	8012528 <wc_AesCbcEncrypt+0x3c>
 8012574:	e000      	b.n	8012578 <wc_AesCbcEncrypt+0x8c>
                    break;
 8012576:	bf00      	nop

    #ifdef WOLFSSL_AESNI
        VECTOR_REGISTERS_POP;
    #endif

        return ret;
 8012578:	693b      	ldr	r3, [r7, #16]
    } /* wc_AesCbcEncrypt */
 801257a:	4618      	mov	r0, r3
 801257c:	3718      	adds	r7, #24
 801257e:	46bd      	mov	sp, r7
 8012580:	bd80      	pop	{r7, pc}

08012582 <wc_AesCbcDecrypt>:

#ifdef HAVE_AES_DECRYPT
    /* Software AES - CBC Decrypt */
    int wc_AesCbcDecrypt(Aes* aes, byte* out, const byte* in, word32 sz)
    {
 8012582:	b580      	push	{r7, lr}
 8012584:	b086      	sub	sp, #24
 8012586:	af00      	add	r7, sp, #0
 8012588:	60f8      	str	r0, [r7, #12]
 801258a:	60b9      	str	r1, [r7, #8]
 801258c:	607a      	str	r2, [r7, #4]
 801258e:	603b      	str	r3, [r7, #0]
        word32 blocks;
        int ret;

        if (aes == NULL || out == NULL || in == NULL) {
 8012590:	68fb      	ldr	r3, [r7, #12]
 8012592:	2b00      	cmp	r3, #0
 8012594:	d005      	beq.n	80125a2 <wc_AesCbcDecrypt+0x20>
 8012596:	68bb      	ldr	r3, [r7, #8]
 8012598:	2b00      	cmp	r3, #0
 801259a:	d002      	beq.n	80125a2 <wc_AesCbcDecrypt+0x20>
 801259c:	687b      	ldr	r3, [r7, #4]
 801259e:	2b00      	cmp	r3, #0
 80125a0:	d102      	bne.n	80125a8 <wc_AesCbcDecrypt+0x26>
            return BAD_FUNC_ARG;
 80125a2:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80125a6:	e042      	b.n	801262e <wc_AesCbcDecrypt+0xac>
        }

        if (sz == 0) {
 80125a8:	683b      	ldr	r3, [r7, #0]
 80125aa:	2b00      	cmp	r3, #0
 80125ac:	d101      	bne.n	80125b2 <wc_AesCbcDecrypt+0x30>
            return 0;
 80125ae:	2300      	movs	r3, #0
 80125b0:	e03d      	b.n	801262e <wc_AesCbcDecrypt+0xac>
                          "unsupported keylen = %d", aes->keylen);
        #endif
        }
    #endif

        blocks = sz / WC_AES_BLOCK_SIZE;
 80125b2:	683b      	ldr	r3, [r7, #0]
 80125b4:	091b      	lsrs	r3, r3, #4
 80125b6:	617b      	str	r3, [r7, #20]
        if (sz % WC_AES_BLOCK_SIZE) {
 80125b8:	683b      	ldr	r3, [r7, #0]
 80125ba:	f003 030f 	and.w	r3, r3, #15
 80125be:	2b00      	cmp	r3, #0
 80125c0:	d002      	beq.n	80125c8 <wc_AesCbcDecrypt+0x46>
#ifdef WOLFSSL_AES_CBC_LENGTH_CHECKS
            return BAD_LENGTH_E;
#else
            return BAD_FUNC_ARG;
 80125c2:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80125c6:	e032      	b.n	801262e <wc_AesCbcDecrypt+0xac>
            ret = 0;
        }
        else
    #endif
        {
            ret = 0;
 80125c8:	2300      	movs	r3, #0
 80125ca:	613b      	str	r3, [r7, #16]

                    blocks = 0;
                }
            }
#else
            while (blocks--) {
 80125cc:	e029      	b.n	8012622 <wc_AesCbcDecrypt+0xa0>
                XMEMCPY(aes->tmp, in, WC_AES_BLOCK_SIZE);
 80125ce:	68fb      	ldr	r3, [r7, #12]
 80125d0:	f503 7384 	add.w	r3, r3, #264	@ 0x108
 80125d4:	2210      	movs	r2, #16
 80125d6:	6879      	ldr	r1, [r7, #4]
 80125d8:	4618      	mov	r0, r3
 80125da:	f015 ffdf 	bl	802859c <memcpy>
                ret = wc_AesDecrypt(aes, in, out);
 80125de:	68ba      	ldr	r2, [r7, #8]
 80125e0:	6879      	ldr	r1, [r7, #4]
 80125e2:	68f8      	ldr	r0, [r7, #12]
 80125e4:	f7ff fb50 	bl	8011c88 <wc_AesDecrypt>
 80125e8:	6138      	str	r0, [r7, #16]
                if (ret != 0)
 80125ea:	693b      	ldr	r3, [r7, #16]
 80125ec:	2b00      	cmp	r3, #0
 80125ee:	d001      	beq.n	80125f4 <wc_AesCbcDecrypt+0x72>
                    return ret;
 80125f0:	693b      	ldr	r3, [r7, #16]
 80125f2:	e01c      	b.n	801262e <wc_AesCbcDecrypt+0xac>
                xorbuf(out, (byte*)aes->reg, WC_AES_BLOCK_SIZE);
 80125f4:	68fb      	ldr	r3, [r7, #12]
 80125f6:	33f8      	adds	r3, #248	@ 0xf8
 80125f8:	2210      	movs	r2, #16
 80125fa:	4619      	mov	r1, r3
 80125fc:	68b8      	ldr	r0, [r7, #8]
 80125fe:	f7fd f856 	bl	800f6ae <xorbuf>
                /* store iv for next call */
                XMEMCPY(aes->reg, aes->tmp, WC_AES_BLOCK_SIZE);
 8012602:	68fb      	ldr	r3, [r7, #12]
 8012604:	f103 00f8 	add.w	r0, r3, #248	@ 0xf8
 8012608:	68fb      	ldr	r3, [r7, #12]
 801260a:	f503 7384 	add.w	r3, r3, #264	@ 0x108
 801260e:	2210      	movs	r2, #16
 8012610:	4619      	mov	r1, r3
 8012612:	f015 ffc3 	bl	802859c <memcpy>

                out += WC_AES_BLOCK_SIZE;
 8012616:	68bb      	ldr	r3, [r7, #8]
 8012618:	3310      	adds	r3, #16
 801261a:	60bb      	str	r3, [r7, #8]
                in  += WC_AES_BLOCK_SIZE;
 801261c:	687b      	ldr	r3, [r7, #4]
 801261e:	3310      	adds	r3, #16
 8012620:	607b      	str	r3, [r7, #4]
            while (blocks--) {
 8012622:	697b      	ldr	r3, [r7, #20]
 8012624:	1e5a      	subs	r2, r3, #1
 8012626:	617a      	str	r2, [r7, #20]
 8012628:	2b00      	cmp	r3, #0
 801262a:	d1d0      	bne.n	80125ce <wc_AesCbcDecrypt+0x4c>
#endif
        }

        VECTOR_REGISTERS_POP;

        return ret;
 801262c:	693b      	ldr	r3, [r7, #16]
    }
 801262e:	4618      	mov	r0, r3
 8012630:	3718      	adds	r7, #24
 8012632:	46bd      	mov	sp, r7
 8012634:	bd80      	pop	{r7, pc}

08012636 <wc_AesInit>:
}
#endif /* !WC_NO_CONSTRUCTORS */

/* Initialize Aes */
int wc_AesInit(Aes* aes, void* heap, int devId)
{
 8012636:	b580      	push	{r7, lr}
 8012638:	b086      	sub	sp, #24
 801263a:	af00      	add	r7, sp, #0
 801263c:	60f8      	str	r0, [r7, #12]
 801263e:	60b9      	str	r1, [r7, #8]
 8012640:	607a      	str	r2, [r7, #4]
    int ret = 0;
 8012642:	2300      	movs	r3, #0
 8012644:	617b      	str	r3, [r7, #20]

    if (aes == NULL)
 8012646:	68fb      	ldr	r3, [r7, #12]
 8012648:	2b00      	cmp	r3, #0
 801264a:	d102      	bne.n	8012652 <wc_AesInit+0x1c>
        return BAD_FUNC_ARG;
 801264c:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8012650:	e00a      	b.n	8012668 <wc_AesInit+0x32>

    XMEMSET(aes, 0, sizeof(*aes));
 8012652:	f44f 72a6 	mov.w	r2, #332	@ 0x14c
 8012656:	2100      	movs	r1, #0
 8012658:	68f8      	ldr	r0, [r7, #12]
 801265a:	f015 ff35 	bl	80284c8 <memset>

    aes->heap = heap;
 801265e:	68fb      	ldr	r3, [r7, #12]
 8012660:	68ba      	ldr	r2, [r7, #8]
 8012662:	f8c3 2148 	str.w	r2, [r3, #328]	@ 0x148
#ifdef WC_DEBUG_CIPHER_LIFECYCLE
    if (ret == 0)
        ret = wc_debug_CipherLifecycleInit(&aes->CipherLifecycleTag, aes->heap);
#endif

    return ret;
 8012666:	697b      	ldr	r3, [r7, #20]
}
 8012668:	4618      	mov	r0, r3
 801266a:	3718      	adds	r7, #24
 801266c:	46bd      	mov	sp, r7
 801266e:	bd80      	pop	{r7, pc}

08012670 <wc_AesFree>:
}
#endif

/* Free Aes resources */
void wc_AesFree(Aes* aes)
{
 8012670:	b580      	push	{r7, lr}
 8012672:	b082      	sub	sp, #8
 8012674:	af00      	add	r7, sp, #0
 8012676:	6078      	str	r0, [r7, #4]
    if (aes == NULL) {
 8012678:	687b      	ldr	r3, [r7, #4]
 801267a:	2b00      	cmp	r3, #0
 801267c:	d005      	beq.n	801268a <wc_AesFree+0x1a>
    defined(WOLFSSL_RENESAS_FSPSM_CRYPTONLY)) && \
    !defined(NO_WOLFSSL_RENESAS_FSPSM_AES))
    wc_fspsm_Aesfree(aes);
#endif

    ForceZero(aes, sizeof(Aes));
 801267e:	f44f 71a6 	mov.w	r1, #332	@ 0x14c
 8012682:	6878      	ldr	r0, [r7, #4]
 8012684:	f7fd f86d 	bl	800f762 <ForceZero>
 8012688:	e000      	b.n	801268c <wc_AesFree+0x1c>
        return;
 801268a:	bf00      	nop

#ifdef WOLFSSL_CHECK_MEM_ZERO
    wc_MemZero_Check(aes, sizeof(Aes));
#endif
}
 801268c:	3708      	adds	r7, #8
 801268e:	46bd      	mov	sp, r7
 8012690:	bd80      	pop	{r7, pc}

08012692 <ForceZero>:
{
 8012692:	b480      	push	{r7}
 8012694:	b085      	sub	sp, #20
 8012696:	af00      	add	r7, sp, #0
 8012698:	6078      	str	r0, [r7, #4]
 801269a:	6039      	str	r1, [r7, #0]
    volatile byte* z = (volatile byte*)mem;
 801269c:	687b      	ldr	r3, [r7, #4]
 801269e:	60fb      	str	r3, [r7, #12]
    while (len--) *z++ = 0;
 80126a0:	e004      	b.n	80126ac <ForceZero+0x1a>
 80126a2:	68fb      	ldr	r3, [r7, #12]
 80126a4:	1c5a      	adds	r2, r3, #1
 80126a6:	60fa      	str	r2, [r7, #12]
 80126a8:	2200      	movs	r2, #0
 80126aa:	701a      	strb	r2, [r3, #0]
 80126ac:	683b      	ldr	r3, [r7, #0]
 80126ae:	1e5a      	subs	r2, r3, #1
 80126b0:	603a      	str	r2, [r7, #0]
 80126b2:	2b00      	cmp	r3, #0
 80126b4:	d1f5      	bne.n	80126a2 <ForceZero+0x10>
}
 80126b6:	bf00      	nop
 80126b8:	bf00      	nop
 80126ba:	3714      	adds	r7, #20
 80126bc:	46bd      	mov	sp, r7
 80126be:	f85d 7b04 	ldr.w	r7, [sp], #4
 80126c2:	4770      	bx	lr

080126c4 <min>:
    {
 80126c4:	b480      	push	{r7}
 80126c6:	b083      	sub	sp, #12
 80126c8:	af00      	add	r7, sp, #0
 80126ca:	6078      	str	r0, [r7, #4]
 80126cc:	6039      	str	r1, [r7, #0]
        return a > b ? b : a;
 80126ce:	687a      	ldr	r2, [r7, #4]
 80126d0:	683b      	ldr	r3, [r7, #0]
 80126d2:	4293      	cmp	r3, r2
 80126d4:	bf28      	it	cs
 80126d6:	4613      	movcs	r3, r2
    }
 80126d8:	4618      	mov	r0, r3
 80126da:	370c      	adds	r7, #12
 80126dc:	46bd      	mov	sp, r7
 80126de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80126e2:	4770      	bx	lr

080126e4 <CopyString>:
}
#endif /* WOLFCRYPT_ONLY && !NO_HASH_WRAPPER &&
        * (!NO_SESSION_CACHE || HAVE_SESSION_TICKET) */

WC_MISC_STATIC WC_INLINE char* CopyString(const char* src, int srcLen,
        void* heap, int type) {
 80126e4:	b580      	push	{r7, lr}
 80126e6:	b086      	sub	sp, #24
 80126e8:	af00      	add	r7, sp, #0
 80126ea:	60f8      	str	r0, [r7, #12]
 80126ec:	60b9      	str	r1, [r7, #8]
 80126ee:	607a      	str	r2, [r7, #4]
 80126f0:	603b      	str	r3, [r7, #0]
    char* dst = NULL;
 80126f2:	2300      	movs	r3, #0
 80126f4:	617b      	str	r3, [r7, #20]

    if (src == NULL)
 80126f6:	68fb      	ldr	r3, [r7, #12]
 80126f8:	2b00      	cmp	r3, #0
 80126fa:	d101      	bne.n	8012700 <CopyString+0x1c>
        return NULL;
 80126fc:	2300      	movs	r3, #0
 80126fe:	e01c      	b.n	801273a <CopyString+0x56>

    if (srcLen <= 0)
 8012700:	68bb      	ldr	r3, [r7, #8]
 8012702:	2b00      	cmp	r3, #0
 8012704:	dc04      	bgt.n	8012710 <CopyString+0x2c>
        srcLen = (int)XSTRLEN(src);
 8012706:	68f8      	ldr	r0, [r7, #12]
 8012708:	f7ed fd6c 	bl	80001e4 <strlen>
 801270c:	4603      	mov	r3, r0
 801270e:	60bb      	str	r3, [r7, #8]

    dst = (char*)XMALLOC((size_t)srcLen + 1, heap, type);
 8012710:	68bb      	ldr	r3, [r7, #8]
 8012712:	3301      	adds	r3, #1
 8012714:	4618      	mov	r0, r3
 8012716:	f00c f9b7 	bl	801ea88 <wolfSSL_Malloc>
 801271a:	6178      	str	r0, [r7, #20]
    if (dst != NULL) {
 801271c:	697b      	ldr	r3, [r7, #20]
 801271e:	2b00      	cmp	r3, #0
 8012720:	d00a      	beq.n	8012738 <CopyString+0x54>
        XMEMCPY(dst, src, (size_t)srcLen);
 8012722:	68bb      	ldr	r3, [r7, #8]
 8012724:	461a      	mov	r2, r3
 8012726:	68f9      	ldr	r1, [r7, #12]
 8012728:	6978      	ldr	r0, [r7, #20]
 801272a:	f015 ff37 	bl	802859c <memcpy>
        dst[srcLen] = '\0';
 801272e:	68bb      	ldr	r3, [r7, #8]
 8012730:	697a      	ldr	r2, [r7, #20]
 8012732:	4413      	add	r3, r2
 8012734:	2200      	movs	r2, #0
 8012736:	701a      	strb	r2, [r3, #0]
    }

    return dst;
 8012738:	697b      	ldr	r3, [r7, #20]
}
 801273a:	4618      	mov	r0, r3
 801273c:	3718      	adds	r7, #24
 801273e:	46bd      	mov	sp, r7
 8012740:	bd80      	pop	{r7, pc}

08012742 <BytePrecision>:
 *
 * @param [in] value  Value to be encoded.
 * @return  Number of bytes to encode value.
 */
static word32 BytePrecision(word32 value)
{
 8012742:	b480      	push	{r7}
 8012744:	b085      	sub	sp, #20
 8012746:	af00      	add	r7, sp, #0
 8012748:	6078      	str	r0, [r7, #4]
    word32 i;
    for (i = (word32)sizeof(value); i; --i)
 801274a:	2304      	movs	r3, #4
 801274c:	60fb      	str	r3, [r7, #12]
 801274e:	e00a      	b.n	8012766 <BytePrecision+0x24>
        if (value >> ((i - 1) * WOLFSSL_BIT_SIZE))
 8012750:	68fb      	ldr	r3, [r7, #12]
 8012752:	3b01      	subs	r3, #1
 8012754:	00db      	lsls	r3, r3, #3
 8012756:	687a      	ldr	r2, [r7, #4]
 8012758:	fa22 f303 	lsr.w	r3, r2, r3
 801275c:	2b00      	cmp	r3, #0
 801275e:	d106      	bne.n	801276e <BytePrecision+0x2c>
    for (i = (word32)sizeof(value); i; --i)
 8012760:	68fb      	ldr	r3, [r7, #12]
 8012762:	3b01      	subs	r3, #1
 8012764:	60fb      	str	r3, [r7, #12]
 8012766:	68fb      	ldr	r3, [r7, #12]
 8012768:	2b00      	cmp	r3, #0
 801276a:	d1f1      	bne.n	8012750 <BytePrecision+0xe>
 801276c:	e000      	b.n	8012770 <BytePrecision+0x2e>
            break;
 801276e:	bf00      	nop

    return i;
 8012770:	68fb      	ldr	r3, [r7, #12]
}
 8012772:	4618      	mov	r0, r3
 8012774:	3714      	adds	r7, #20
 8012776:	46bd      	mov	sp, r7
 8012778:	f85d 7b04 	ldr.w	r7, [sp], #4
 801277c:	4770      	bx	lr

0801277e <SetASNLength>:
 * @param [in]      length  Value to encode.
 * @param [in, out] output  Buffer to encode into.
 * @return  Number of bytes used in encoding.
 */
WOLFSSL_LOCAL word32 SetASNLength(word32 length, byte* output)
{
 801277e:	b580      	push	{r7, lr}
 8012780:	b084      	sub	sp, #16
 8012782:	af00      	add	r7, sp, #0
 8012784:	6078      	str	r0, [r7, #4]
 8012786:	6039      	str	r1, [r7, #0]
    word32 i = 0;
 8012788:	2300      	movs	r3, #0
 801278a:	60fb      	str	r3, [r7, #12]

    if (length < ASN_LONG_LENGTH)
 801278c:	687b      	ldr	r3, [r7, #4]
 801278e:	2b7f      	cmp	r3, #127	@ 0x7f
 8012790:	d808      	bhi.n	80127a4 <SetASNLength+0x26>
        output[i++] = (byte)length;
 8012792:	68fb      	ldr	r3, [r7, #12]
 8012794:	1c5a      	adds	r2, r3, #1
 8012796:	60fa      	str	r2, [r7, #12]
 8012798:	683a      	ldr	r2, [r7, #0]
 801279a:	4413      	add	r3, r2
 801279c:	687a      	ldr	r2, [r7, #4]
 801279e:	b2d2      	uxtb	r2, r2
 80127a0:	701a      	strb	r2, [r3, #0]
 80127a2:	e026      	b.n	80127f2 <SetASNLength+0x74>
    else {
        word32 j;

        output[i++] = (byte)(BytePrecision(length) | ASN_LONG_LENGTH);
 80127a4:	6878      	ldr	r0, [r7, #4]
 80127a6:	f7ff ffcc 	bl	8012742 <BytePrecision>
 80127aa:	4603      	mov	r3, r0
 80127ac:	b2da      	uxtb	r2, r3
 80127ae:	68fb      	ldr	r3, [r7, #12]
 80127b0:	1c59      	adds	r1, r3, #1
 80127b2:	60f9      	str	r1, [r7, #12]
 80127b4:	6839      	ldr	r1, [r7, #0]
 80127b6:	440b      	add	r3, r1
 80127b8:	f062 027f 	orn	r2, r2, #127	@ 0x7f
 80127bc:	b2d2      	uxtb	r2, r2
 80127be:	701a      	strb	r2, [r3, #0]

        for (j = BytePrecision(length); j; --j) {
 80127c0:	6878      	ldr	r0, [r7, #4]
 80127c2:	f7ff ffbe 	bl	8012742 <BytePrecision>
 80127c6:	60b8      	str	r0, [r7, #8]
 80127c8:	e010      	b.n	80127ec <SetASNLength+0x6e>
            output[i] = (byte)(length >> ((j - 1) * WOLFSSL_BIT_SIZE));
 80127ca:	68bb      	ldr	r3, [r7, #8]
 80127cc:	3b01      	subs	r3, #1
 80127ce:	00db      	lsls	r3, r3, #3
 80127d0:	687a      	ldr	r2, [r7, #4]
 80127d2:	fa22 f103 	lsr.w	r1, r2, r3
 80127d6:	683a      	ldr	r2, [r7, #0]
 80127d8:	68fb      	ldr	r3, [r7, #12]
 80127da:	4413      	add	r3, r2
 80127dc:	b2ca      	uxtb	r2, r1
 80127de:	701a      	strb	r2, [r3, #0]
            i++;
 80127e0:	68fb      	ldr	r3, [r7, #12]
 80127e2:	3301      	adds	r3, #1
 80127e4:	60fb      	str	r3, [r7, #12]
        for (j = BytePrecision(length); j; --j) {
 80127e6:	68bb      	ldr	r3, [r7, #8]
 80127e8:	3b01      	subs	r3, #1
 80127ea:	60bb      	str	r3, [r7, #8]
 80127ec:	68bb      	ldr	r3, [r7, #8]
 80127ee:	2b00      	cmp	r3, #0
 80127f0:	d1eb      	bne.n	80127ca <SetASNLength+0x4c>
        }
    }

    return i;
 80127f2:	68fb      	ldr	r3, [r7, #12]
}
 80127f4:	4618      	mov	r0, r3
 80127f6:	3710      	adds	r7, #16
 80127f8:	46bd      	mov	sp, r7
 80127fa:	bd80      	pop	{r7, pc}

080127fc <SizeASNLength>:
 *
 * @param [in] length  Value to encode.
 * @return  Number of bytes required to encode.
 */
static word32 SizeASNLength(word32 length)
{
 80127fc:	b580      	push	{r7, lr}
 80127fe:	b082      	sub	sp, #8
 8012800:	af00      	add	r7, sp, #0
 8012802:	6078      	str	r0, [r7, #4]
    return 1 + ((length >= ASN_LONG_LENGTH) ? BytePrecision(length) : 0);
 8012804:	687b      	ldr	r3, [r7, #4]
 8012806:	2b7f      	cmp	r3, #127	@ 0x7f
 8012808:	d905      	bls.n	8012816 <SizeASNLength+0x1a>
 801280a:	6878      	ldr	r0, [r7, #4]
 801280c:	f7ff ff99 	bl	8012742 <BytePrecision>
 8012810:	4603      	mov	r3, r0
 8012812:	3301      	adds	r3, #1
 8012814:	e000      	b.n	8012818 <SizeASNLength+0x1c>
 8012816:	2301      	movs	r3, #1
}
 8012818:	4618      	mov	r0, r3
 801281a:	3708      	adds	r7, #8
 801281c:	46bd      	mov	sp, r7
 801281e:	bd80      	pop	{r7, pc}

08012820 <SizeASN_Num>:
 * @param [in] bits  Maximum number of bits to encode.
 * @param [in] tag   BER tag e.g. INTEGER, BIT_STRING, etc.
 * @return  Number of bytes to the ASN.1 item.
 */
static word32 SizeASN_Num(word32 n, int bits, byte tag)
{
 8012820:	b480      	push	{r7}
 8012822:	b087      	sub	sp, #28
 8012824:	af00      	add	r7, sp, #0
 8012826:	60f8      	str	r0, [r7, #12]
 8012828:	60b9      	str	r1, [r7, #8]
 801282a:	4613      	mov	r3, r2
 801282c:	71fb      	strb	r3, [r7, #7]
    int    j;
    word32 len;

    len = 1 + 1 + (word32)bits / 8;
 801282e:	68bb      	ldr	r3, [r7, #8]
 8012830:	08db      	lsrs	r3, r3, #3
 8012832:	3302      	adds	r3, #2
 8012834:	613b      	str	r3, [r7, #16]
    /* Discover actual size by checking for high zeros. */
    for (j = bits - 8; j > 0; j -= 8) {
 8012836:	68bb      	ldr	r3, [r7, #8]
 8012838:	3b08      	subs	r3, #8
 801283a:	617b      	str	r3, [r7, #20]
 801283c:	e00b      	b.n	8012856 <SizeASN_Num+0x36>
        if (n >> j)
 801283e:	68fa      	ldr	r2, [r7, #12]
 8012840:	697b      	ldr	r3, [r7, #20]
 8012842:	fa22 f303 	lsr.w	r3, r2, r3
 8012846:	2b00      	cmp	r3, #0
 8012848:	d109      	bne.n	801285e <SizeASN_Num+0x3e>
            break;
        len--;
 801284a:	693b      	ldr	r3, [r7, #16]
 801284c:	3b01      	subs	r3, #1
 801284e:	613b      	str	r3, [r7, #16]
    for (j = bits - 8; j > 0; j -= 8) {
 8012850:	697b      	ldr	r3, [r7, #20]
 8012852:	3b08      	subs	r3, #8
 8012854:	617b      	str	r3, [r7, #20]
 8012856:	697b      	ldr	r3, [r7, #20]
 8012858:	2b00      	cmp	r3, #0
 801285a:	dcf0      	bgt.n	801283e <SizeASN_Num+0x1e>
 801285c:	e000      	b.n	8012860 <SizeASN_Num+0x40>
            break;
 801285e:	bf00      	nop
    }
    if (tag == ASN_BIT_STRING)
 8012860:	79fb      	ldrb	r3, [r7, #7]
 8012862:	2b03      	cmp	r3, #3
 8012864:	d103      	bne.n	801286e <SizeASN_Num+0x4e>
        len++;
 8012866:	693b      	ldr	r3, [r7, #16]
 8012868:	3301      	adds	r3, #1
 801286a:	613b      	str	r3, [r7, #16]
 801286c:	e00d      	b.n	801288a <SizeASN_Num+0x6a>
    else if ((tag == ASN_INTEGER) && (((n >> j) & 0x80) == 0x80))
 801286e:	79fb      	ldrb	r3, [r7, #7]
 8012870:	2b02      	cmp	r3, #2
 8012872:	d10a      	bne.n	801288a <SizeASN_Num+0x6a>
 8012874:	68fa      	ldr	r2, [r7, #12]
 8012876:	697b      	ldr	r3, [r7, #20]
 8012878:	fa22 f303 	lsr.w	r3, r2, r3
 801287c:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8012880:	2b00      	cmp	r3, #0
 8012882:	d002      	beq.n	801288a <SizeASN_Num+0x6a>
        len++;
 8012884:	693b      	ldr	r3, [r7, #16]
 8012886:	3301      	adds	r3, #1
 8012888:	613b      	str	r3, [r7, #16]

    return len;
 801288a:	693b      	ldr	r3, [r7, #16]
}
 801288c:	4618      	mov	r0, r3
 801288e:	371c      	adds	r7, #28
 8012890:	46bd      	mov	sp, r7
 8012892:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012896:	4770      	bx	lr

08012898 <SizeASN_CalcDataLength>:
 *                         known.
 * @param [in]      idx    Index of item working on.
 */
static void SizeASN_CalcDataLength(const ASNItem* asn, ASNSetData *data,
                                   int idx, int maxIdx)
{
 8012898:	b480      	push	{r7}
 801289a:	b087      	sub	sp, #28
 801289c:	af00      	add	r7, sp, #0
 801289e:	60f8      	str	r0, [r7, #12]
 80128a0:	60b9      	str	r1, [r7, #8]
 80128a2:	607a      	str	r2, [r7, #4]
 80128a4:	603b      	str	r3, [r7, #0]
    int j;

    data[idx].data.buffer.length = 0;
 80128a6:	687a      	ldr	r2, [r7, #4]
 80128a8:	4613      	mov	r3, r2
 80128aa:	009b      	lsls	r3, r3, #2
 80128ac:	4413      	add	r3, r2
 80128ae:	009b      	lsls	r3, r3, #2
 80128b0:	461a      	mov	r2, r3
 80128b2:	68bb      	ldr	r3, [r7, #8]
 80128b4:	4413      	add	r3, r2
 80128b6:	2200      	movs	r2, #0
 80128b8:	60da      	str	r2, [r3, #12]
    /* Sum the item length of all items underneath. */
    for (j = idx + 1; j < maxIdx; j++) {
 80128ba:	687b      	ldr	r3, [r7, #4]
 80128bc:	3301      	adds	r3, #1
 80128be:	617b      	str	r3, [r7, #20]
 80128c0:	e073      	b.n	80129aa <SizeASN_CalcDataLength+0x112>
        /* Stop looking if the next ASN.1 is same level or higher. */
        if (asn[j].depth <= asn[idx].depth)
 80128c2:	697b      	ldr	r3, [r7, #20]
 80128c4:	009b      	lsls	r3, r3, #2
 80128c6:	68fa      	ldr	r2, [r7, #12]
 80128c8:	4413      	add	r3, r2
 80128ca:	781a      	ldrb	r2, [r3, #0]
 80128cc:	687b      	ldr	r3, [r7, #4]
 80128ce:	009b      	lsls	r3, r3, #2
 80128d0:	68f9      	ldr	r1, [r7, #12]
 80128d2:	440b      	add	r3, r1
 80128d4:	781b      	ldrb	r3, [r3, #0]
 80128d6:	429a      	cmp	r2, r3
 80128d8:	d96c      	bls.n	80129b4 <SizeASN_CalcDataLength+0x11c>
            break;
        /* Only add in length if it is one level below. */
        if (asn[j].depth - 1 == asn[idx].depth) {
 80128da:	697b      	ldr	r3, [r7, #20]
 80128dc:	009b      	lsls	r3, r3, #2
 80128de:	68fa      	ldr	r2, [r7, #12]
 80128e0:	4413      	add	r3, r2
 80128e2:	781b      	ldrb	r3, [r3, #0]
 80128e4:	3b01      	subs	r3, #1
 80128e6:	687a      	ldr	r2, [r7, #4]
 80128e8:	0092      	lsls	r2, r2, #2
 80128ea:	68f9      	ldr	r1, [r7, #12]
 80128ec:	440a      	add	r2, r1
 80128ee:	7812      	ldrb	r2, [r2, #0]
 80128f0:	4293      	cmp	r3, r2
 80128f2:	d157      	bne.n	80129a4 <SizeASN_CalcDataLength+0x10c>
            data[idx].data.buffer.length += data[j].length;
 80128f4:	687a      	ldr	r2, [r7, #4]
 80128f6:	4613      	mov	r3, r2
 80128f8:	009b      	lsls	r3, r3, #2
 80128fa:	4413      	add	r3, r2
 80128fc:	009b      	lsls	r3, r3, #2
 80128fe:	461a      	mov	r2, r3
 8012900:	68bb      	ldr	r3, [r7, #8]
 8012902:	4413      	add	r3, r2
 8012904:	68d8      	ldr	r0, [r3, #12]
 8012906:	697a      	ldr	r2, [r7, #20]
 8012908:	4613      	mov	r3, r2
 801290a:	009b      	lsls	r3, r3, #2
 801290c:	4413      	add	r3, r2
 801290e:	009b      	lsls	r3, r3, #2
 8012910:	461a      	mov	r2, r3
 8012912:	68bb      	ldr	r3, [r7, #8]
 8012914:	4413      	add	r3, r2
 8012916:	6859      	ldr	r1, [r3, #4]
 8012918:	687a      	ldr	r2, [r7, #4]
 801291a:	4613      	mov	r3, r2
 801291c:	009b      	lsls	r3, r3, #2
 801291e:	4413      	add	r3, r2
 8012920:	009b      	lsls	r3, r3, #2
 8012922:	461a      	mov	r2, r3
 8012924:	68bb      	ldr	r3, [r7, #8]
 8012926:	4413      	add	r3, r2
 8012928:	1842      	adds	r2, r0, r1
 801292a:	60da      	str	r2, [r3, #12]
            /* The length of a header only item doesn't include the data unless
             * a replacement buffer is supplied.
             */
            if (asn[j].headerOnly && data[j].data.buffer.data == NULL &&
 801292c:	697b      	ldr	r3, [r7, #20]
 801292e:	009b      	lsls	r3, r3, #2
 8012930:	68fa      	ldr	r2, [r7, #12]
 8012932:	4413      	add	r3, r2
 8012934:	789b      	ldrb	r3, [r3, #2]
 8012936:	f003 0302 	and.w	r3, r3, #2
 801293a:	b2db      	uxtb	r3, r3
 801293c:	2b00      	cmp	r3, #0
 801293e:	d031      	beq.n	80129a4 <SizeASN_CalcDataLength+0x10c>
 8012940:	697a      	ldr	r2, [r7, #20]
 8012942:	4613      	mov	r3, r2
 8012944:	009b      	lsls	r3, r3, #2
 8012946:	4413      	add	r3, r2
 8012948:	009b      	lsls	r3, r3, #2
 801294a:	461a      	mov	r2, r3
 801294c:	68bb      	ldr	r3, [r7, #8]
 801294e:	4413      	add	r3, r2
 8012950:	689b      	ldr	r3, [r3, #8]
 8012952:	2b00      	cmp	r3, #0
 8012954:	d126      	bne.n	80129a4 <SizeASN_CalcDataLength+0x10c>
                    data[j].dataType != ASN_DATA_TYPE_REPLACE_BUFFER) {
 8012956:	697a      	ldr	r2, [r7, #20]
 8012958:	4613      	mov	r3, r2
 801295a:	009b      	lsls	r3, r3, #2
 801295c:	4413      	add	r3, r2
 801295e:	009b      	lsls	r3, r3, #2
 8012960:	461a      	mov	r2, r3
 8012962:	68bb      	ldr	r3, [r7, #8]
 8012964:	4413      	add	r3, r2
 8012966:	7c1b      	ldrb	r3, [r3, #16]
            if (asn[j].headerOnly && data[j].data.buffer.data == NULL &&
 8012968:	2b07      	cmp	r3, #7
 801296a:	d01b      	beq.n	80129a4 <SizeASN_CalcDataLength+0x10c>
                data[idx].data.buffer.length += data[j].data.buffer.length;
 801296c:	687a      	ldr	r2, [r7, #4]
 801296e:	4613      	mov	r3, r2
 8012970:	009b      	lsls	r3, r3, #2
 8012972:	4413      	add	r3, r2
 8012974:	009b      	lsls	r3, r3, #2
 8012976:	461a      	mov	r2, r3
 8012978:	68bb      	ldr	r3, [r7, #8]
 801297a:	4413      	add	r3, r2
 801297c:	68d8      	ldr	r0, [r3, #12]
 801297e:	697a      	ldr	r2, [r7, #20]
 8012980:	4613      	mov	r3, r2
 8012982:	009b      	lsls	r3, r3, #2
 8012984:	4413      	add	r3, r2
 8012986:	009b      	lsls	r3, r3, #2
 8012988:	461a      	mov	r2, r3
 801298a:	68bb      	ldr	r3, [r7, #8]
 801298c:	4413      	add	r3, r2
 801298e:	68d9      	ldr	r1, [r3, #12]
 8012990:	687a      	ldr	r2, [r7, #4]
 8012992:	4613      	mov	r3, r2
 8012994:	009b      	lsls	r3, r3, #2
 8012996:	4413      	add	r3, r2
 8012998:	009b      	lsls	r3, r3, #2
 801299a:	461a      	mov	r2, r3
 801299c:	68bb      	ldr	r3, [r7, #8]
 801299e:	4413      	add	r3, r2
 80129a0:	1842      	adds	r2, r0, r1
 80129a2:	60da      	str	r2, [r3, #12]
    for (j = idx + 1; j < maxIdx; j++) {
 80129a4:	697b      	ldr	r3, [r7, #20]
 80129a6:	3301      	adds	r3, #1
 80129a8:	617b      	str	r3, [r7, #20]
 80129aa:	697a      	ldr	r2, [r7, #20]
 80129ac:	683b      	ldr	r3, [r7, #0]
 80129ae:	429a      	cmp	r2, r3
 80129b0:	db87      	blt.n	80128c2 <SizeASN_CalcDataLength+0x2a>
            }
        }
    }
}
 80129b2:	e000      	b.n	80129b6 <SizeASN_CalcDataLength+0x11e>
            break;
 80129b4:	bf00      	nop
}
 80129b6:	bf00      	nop
 80129b8:	371c      	adds	r7, #28
 80129ba:	46bd      	mov	sp, r7
 80129bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80129c0:	4770      	bx	lr
	...

080129c4 <SizeASN_Items>:
 * @param [out]     encSz  Length of the DER encoding.
 * @return  0 on success.
 * @return  BAD_STATE_E when the data type is not supported.
 */
int SizeASN_Items(const ASNItem* asn, ASNSetData *data, int count, int* encSz)
{
 80129c4:	b580      	push	{r7, lr}
 80129c6:	b08a      	sub	sp, #40	@ 0x28
 80129c8:	af00      	add	r7, sp, #0
 80129ca:	60f8      	str	r0, [r7, #12]
 80129cc:	60b9      	str	r1, [r7, #8]
 80129ce:	607a      	str	r2, [r7, #4]
 80129d0:	603b      	str	r3, [r7, #0]
    int    i;
    word32 sz = 0;
 80129d2:	2300      	movs	r3, #0
 80129d4:	623b      	str	r3, [r7, #32]

#ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
    WOLFSSL_ENTER("SizeASN_Items");
#endif

    for (i = count - 1; i >= 0; i--) {
 80129d6:	687b      	ldr	r3, [r7, #4]
 80129d8:	3b01      	subs	r3, #1
 80129da:	627b      	str	r3, [r7, #36]	@ 0x24
 80129dc:	e16c      	b.n	8012cb8 <SizeASN_Items+0x2f4>
        /* Skip this ASN.1 item when encoding. */
        if (data[i].noOut) {
 80129de:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80129e0:	4613      	mov	r3, r2
 80129e2:	009b      	lsls	r3, r3, #2
 80129e4:	4413      	add	r3, r2
 80129e6:	009b      	lsls	r3, r3, #2
 80129e8:	461a      	mov	r2, r3
 80129ea:	68bb      	ldr	r3, [r7, #8]
 80129ec:	4413      	add	r3, r2
 80129ee:	7c5b      	ldrb	r3, [r3, #17]
 80129f0:	2b00      	cmp	r3, #0
 80129f2:	d00a      	beq.n	8012a0a <SizeASN_Items+0x46>
            /* Set the offset to the current size - used in writing DER. */
            data[i].offset = sz;
 80129f4:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80129f6:	4613      	mov	r3, r2
 80129f8:	009b      	lsls	r3, r3, #2
 80129fa:	4413      	add	r3, r2
 80129fc:	009b      	lsls	r3, r3, #2
 80129fe:	461a      	mov	r2, r3
 8012a00:	68bb      	ldr	r3, [r7, #8]
 8012a02:	4413      	add	r3, r2
 8012a04:	6a3a      	ldr	r2, [r7, #32]
 8012a06:	601a      	str	r2, [r3, #0]
            continue;
 8012a08:	e153      	b.n	8012cb2 <SizeASN_Items+0x2ee>
        }

        len = 0;
 8012a0a:	2300      	movs	r3, #0
 8012a0c:	61fb      	str	r3, [r7, #28]
        switch (data[i].dataType) {
 8012a0e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012a10:	4613      	mov	r3, r2
 8012a12:	009b      	lsls	r3, r3, #2
 8012a14:	4413      	add	r3, r2
 8012a16:	009b      	lsls	r3, r3, #2
 8012a18:	461a      	mov	r2, r3
 8012a1a:	68bb      	ldr	r3, [r7, #8]
 8012a1c:	4413      	add	r3, r2
 8012a1e:	7c1b      	ldrb	r3, [r3, #16]
 8012a20:	2b08      	cmp	r3, #8
 8012a22:	f200 812e 	bhi.w	8012c82 <SizeASN_Items+0x2be>
 8012a26:	a201      	add	r2, pc, #4	@ (adr r2, 8012a2c <SizeASN_Items+0x68>)
 8012a28:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8012a2c:	08012b15 	.word	0x08012b15
 8012a30:	08012a51 	.word	0x08012a51
 8012a34:	08012a7b 	.word	0x08012a7b
 8012a38:	08012c83 	.word	0x08012c83
 8012a3c:	08012c83 	.word	0x08012c83
 8012a40:	08012c83 	.word	0x08012c83
 8012a44:	08012c83 	.word	0x08012c83
 8012a48:	08012aff 	.word	0x08012aff
 8012a4c:	08012aa5 	.word	0x08012aa5
            /* Calculate the size of the number of different sizes. */
            case ASN_DATA_TYPE_WORD8:
                len = SizeASN_Num(data[i].data.u8, 8, asn[i].tag);
 8012a50:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012a52:	4613      	mov	r3, r2
 8012a54:	009b      	lsls	r3, r3, #2
 8012a56:	4413      	add	r3, r2
 8012a58:	009b      	lsls	r3, r3, #2
 8012a5a:	461a      	mov	r2, r3
 8012a5c:	68bb      	ldr	r3, [r7, #8]
 8012a5e:	4413      	add	r3, r2
 8012a60:	7a1b      	ldrb	r3, [r3, #8]
 8012a62:	4618      	mov	r0, r3
 8012a64:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012a66:	009b      	lsls	r3, r3, #2
 8012a68:	68fa      	ldr	r2, [r7, #12]
 8012a6a:	4413      	add	r3, r2
 8012a6c:	785b      	ldrb	r3, [r3, #1]
 8012a6e:	461a      	mov	r2, r3
 8012a70:	2108      	movs	r1, #8
 8012a72:	f7ff fed5 	bl	8012820 <SizeASN_Num>
 8012a76:	61f8      	str	r0, [r7, #28]
                break;
 8012a78:	e103      	b.n	8012c82 <SizeASN_Items+0x2be>
            case ASN_DATA_TYPE_WORD16:
                len = SizeASN_Num(data[i].data.u16, 16, asn[i].tag);
 8012a7a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012a7c:	4613      	mov	r3, r2
 8012a7e:	009b      	lsls	r3, r3, #2
 8012a80:	4413      	add	r3, r2
 8012a82:	009b      	lsls	r3, r3, #2
 8012a84:	461a      	mov	r2, r3
 8012a86:	68bb      	ldr	r3, [r7, #8]
 8012a88:	4413      	add	r3, r2
 8012a8a:	891b      	ldrh	r3, [r3, #8]
 8012a8c:	4618      	mov	r0, r3
 8012a8e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012a90:	009b      	lsls	r3, r3, #2
 8012a92:	68fa      	ldr	r2, [r7, #12]
 8012a94:	4413      	add	r3, r2
 8012a96:	785b      	ldrb	r3, [r3, #1]
 8012a98:	461a      	mov	r2, r3
 8012a9a:	2110      	movs	r1, #16
 8012a9c:	f7ff fec0 	bl	8012820 <SizeASN_Num>
 8012aa0:	61f8      	str	r0, [r7, #28]
                break;
 8012aa2:	e0ee      	b.n	8012c82 <SizeASN_Items+0x2be>
                break;
        #endif

            case ASN_DATA_TYPE_MP:
                /* Calculate the size of the MP integer data. */
                length = mp_unsigned_bin_size(data[i].data.mp);
 8012aa4:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012aa6:	4613      	mov	r3, r2
 8012aa8:	009b      	lsls	r3, r3, #2
 8012aaa:	4413      	add	r3, r2
 8012aac:	009b      	lsls	r3, r3, #2
 8012aae:	461a      	mov	r2, r3
 8012ab0:	68bb      	ldr	r3, [r7, #8]
 8012ab2:	4413      	add	r3, r2
 8012ab4:	689b      	ldr	r3, [r3, #8]
 8012ab6:	4618      	mov	r0, r3
 8012ab8:	f013 ff9a 	bl	80269f0 <mp_unsigned_bin_size>
 8012abc:	6138      	str	r0, [r7, #16]
                length += mp_leading_bit(data[i].data.mp) ? 1 : 0;
 8012abe:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012ac0:	4613      	mov	r3, r2
 8012ac2:	009b      	lsls	r3, r3, #2
 8012ac4:	4413      	add	r3, r2
 8012ac6:	009b      	lsls	r3, r3, #2
 8012ac8:	461a      	mov	r2, r3
 8012aca:	68bb      	ldr	r3, [r7, #8]
 8012acc:	4413      	add	r3, r2
 8012ace:	689b      	ldr	r3, [r3, #8]
 8012ad0:	4618      	mov	r0, r3
 8012ad2:	f014 f855 	bl	8026b80 <mp_leading_bit>
 8012ad6:	4603      	mov	r3, r0
 8012ad8:	2b00      	cmp	r3, #0
 8012ada:	bf14      	ite	ne
 8012adc:	2301      	movne	r3, #1
 8012ade:	2300      	moveq	r3, #0
 8012ae0:	b2db      	uxtb	r3, r3
 8012ae2:	461a      	mov	r2, r3
 8012ae4:	693b      	ldr	r3, [r7, #16]
 8012ae6:	4413      	add	r3, r2
 8012ae8:	613b      	str	r3, [r7, #16]
                len = (word32)SizeASNHeader((word32)length) + (word32)length;
 8012aea:	693b      	ldr	r3, [r7, #16]
 8012aec:	4618      	mov	r0, r3
 8012aee:	f7ff fe85 	bl	80127fc <SizeASNLength>
 8012af2:	4602      	mov	r2, r0
 8012af4:	693b      	ldr	r3, [r7, #16]
 8012af6:	4413      	add	r3, r2
 8012af8:	3301      	adds	r3, #1
 8012afa:	61fb      	str	r3, [r7, #28]
                break;
 8012afc:	e0c1      	b.n	8012c82 <SizeASN_Items+0x2be>

            case ASN_DATA_TYPE_REPLACE_BUFFER:
                /* Buffer is put in directly - use the length. */
                len = data[i].data.buffer.length;
 8012afe:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012b00:	4613      	mov	r3, r2
 8012b02:	009b      	lsls	r3, r3, #2
 8012b04:	4413      	add	r3, r2
 8012b06:	009b      	lsls	r3, r3, #2
 8012b08:	461a      	mov	r2, r3
 8012b0a:	68bb      	ldr	r3, [r7, #8]
 8012b0c:	4413      	add	r3, r2
 8012b0e:	68db      	ldr	r3, [r3, #12]
 8012b10:	61fb      	str	r3, [r7, #28]
                break;
 8012b12:	e0b6      	b.n	8012c82 <SizeASN_Items+0x2be>

            case ASN_DATA_TYPE_NONE:
                /* Calculate the size based on the data to be included.
                 * Mostly used for constructed items.
                 */
                if (asn[i].headerOnly) {
 8012b14:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012b16:	009b      	lsls	r3, r3, #2
 8012b18:	68fa      	ldr	r2, [r7, #12]
 8012b1a:	4413      	add	r3, r2
 8012b1c:	789b      	ldrb	r3, [r3, #2]
 8012b1e:	f003 0302 	and.w	r3, r3, #2
 8012b22:	b2db      	uxtb	r3, r3
 8012b24:	2b00      	cmp	r3, #0
 8012b26:	d040      	beq.n	8012baa <SizeASN_Items+0x1e6>
                    if (data[i].data.buffer.data != NULL) {
 8012b28:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012b2a:	4613      	mov	r3, r2
 8012b2c:	009b      	lsls	r3, r3, #2
 8012b2e:	4413      	add	r3, r2
 8012b30:	009b      	lsls	r3, r3, #2
 8012b32:	461a      	mov	r2, r3
 8012b34:	68bb      	ldr	r3, [r7, #8]
 8012b36:	4413      	add	r3, r2
 8012b38:	689b      	ldr	r3, [r3, #8]
 8012b3a:	2b00      	cmp	r3, #0
 8012b3c:	d02d      	beq.n	8012b9a <SizeASN_Items+0x1d6>
                        /* Force all child nodes to be ignored. Buffer
                         * overwrites children. */
                        {
                            int ii;
                            for (ii = i + 1; ii < count; ii++) {
 8012b3e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012b40:	3301      	adds	r3, #1
 8012b42:	617b      	str	r3, [r7, #20]
 8012b44:	e024      	b.n	8012b90 <SizeASN_Items+0x1cc>
                                if (asn[ii].depth <= asn[i].depth)
 8012b46:	697b      	ldr	r3, [r7, #20]
 8012b48:	009b      	lsls	r3, r3, #2
 8012b4a:	68fa      	ldr	r2, [r7, #12]
 8012b4c:	4413      	add	r3, r2
 8012b4e:	781a      	ldrb	r2, [r3, #0]
 8012b50:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012b52:	009b      	lsls	r3, r3, #2
 8012b54:	68f9      	ldr	r1, [r7, #12]
 8012b56:	440b      	add	r3, r1
 8012b58:	781b      	ldrb	r3, [r3, #0]
 8012b5a:	429a      	cmp	r2, r3
 8012b5c:	d924      	bls.n	8012ba8 <SizeASN_Items+0x1e4>
                                    break;
                                sz -= data[ii].length;
 8012b5e:	697a      	ldr	r2, [r7, #20]
 8012b60:	4613      	mov	r3, r2
 8012b62:	009b      	lsls	r3, r3, #2
 8012b64:	4413      	add	r3, r2
 8012b66:	009b      	lsls	r3, r3, #2
 8012b68:	461a      	mov	r2, r3
 8012b6a:	68bb      	ldr	r3, [r7, #8]
 8012b6c:	4413      	add	r3, r2
 8012b6e:	685b      	ldr	r3, [r3, #4]
 8012b70:	6a3a      	ldr	r2, [r7, #32]
 8012b72:	1ad3      	subs	r3, r2, r3
 8012b74:	623b      	str	r3, [r7, #32]
                                data[ii].noOut = 1;
 8012b76:	697a      	ldr	r2, [r7, #20]
 8012b78:	4613      	mov	r3, r2
 8012b7a:	009b      	lsls	r3, r3, #2
 8012b7c:	4413      	add	r3, r2
 8012b7e:	009b      	lsls	r3, r3, #2
 8012b80:	461a      	mov	r2, r3
 8012b82:	68bb      	ldr	r3, [r7, #8]
 8012b84:	4413      	add	r3, r2
 8012b86:	2201      	movs	r2, #1
 8012b88:	745a      	strb	r2, [r3, #17]
                            for (ii = i + 1; ii < count; ii++) {
 8012b8a:	697b      	ldr	r3, [r7, #20]
 8012b8c:	3301      	adds	r3, #1
 8012b8e:	617b      	str	r3, [r7, #20]
 8012b90:	697a      	ldr	r2, [r7, #20]
 8012b92:	687b      	ldr	r3, [r7, #4]
 8012b94:	429a      	cmp	r2, r3
 8012b96:	dbd6      	blt.n	8012b46 <SizeASN_Items+0x182>
 8012b98:	e007      	b.n	8012baa <SizeASN_Items+0x1e6>
                        }
                    }
                    else {
                        /* Calculate data length from items below if no buffer
                         * supplied. */
                        SizeASN_CalcDataLength(asn, data, i, count);
 8012b9a:	687b      	ldr	r3, [r7, #4]
 8012b9c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012b9e:	68b9      	ldr	r1, [r7, #8]
 8012ba0:	68f8      	ldr	r0, [r7, #12]
 8012ba2:	f7ff fe79 	bl	8012898 <SizeASN_CalcDataLength>
 8012ba6:	e000      	b.n	8012baa <SizeASN_Items+0x1e6>
                                    break;
 8012ba8:	bf00      	nop
                    }
                }
                if (asn[i].tag == ASN_BOOLEAN) {
 8012baa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012bac:	009b      	lsls	r3, r3, #2
 8012bae:	68fa      	ldr	r2, [r7, #12]
 8012bb0:	4413      	add	r3, r2
 8012bb2:	785b      	ldrb	r3, [r3, #1]
 8012bb4:	2b01      	cmp	r3, #1
 8012bb6:	d102      	bne.n	8012bbe <SizeASN_Items+0x1fa>
                    dataLen = 1;
 8012bb8:	2301      	movs	r3, #1
 8012bba:	61bb      	str	r3, [r7, #24]
 8012bbc:	e009      	b.n	8012bd2 <SizeASN_Items+0x20e>
                }
                else {
                    dataLen = data[i].data.buffer.length;
 8012bbe:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012bc0:	4613      	mov	r3, r2
 8012bc2:	009b      	lsls	r3, r3, #2
 8012bc4:	4413      	add	r3, r2
 8012bc6:	009b      	lsls	r3, r3, #2
 8012bc8:	461a      	mov	r2, r3
 8012bca:	68bb      	ldr	r3, [r7, #8]
 8012bcc:	4413      	add	r3, r2
 8012bce:	68db      	ldr	r3, [r3, #12]
 8012bd0:	61bb      	str	r3, [r7, #24]
                }
                /* BIT_STRING and INTEGER have one byte prepended. */
                if ((asn[i].tag == ASN_BIT_STRING) ||
 8012bd2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012bd4:	009b      	lsls	r3, r3, #2
 8012bd6:	68fa      	ldr	r2, [r7, #12]
 8012bd8:	4413      	add	r3, r2
 8012bda:	785b      	ldrb	r3, [r3, #1]
 8012bdc:	2b03      	cmp	r3, #3
 8012bde:	d01e      	beq.n	8012c1e <SizeASN_Items+0x25a>
                                                   ASNIntMSBSet(asn, data, i)) {
 8012be0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012be2:	009b      	lsls	r3, r3, #2
 8012be4:	68fa      	ldr	r2, [r7, #12]
 8012be6:	4413      	add	r3, r2
 8012be8:	785b      	ldrb	r3, [r3, #1]
                if ((asn[i].tag == ASN_BIT_STRING) ||
 8012bea:	2b02      	cmp	r3, #2
 8012bec:	d127      	bne.n	8012c3e <SizeASN_Items+0x27a>
                                                   ASNIntMSBSet(asn, data, i)) {
 8012bee:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012bf0:	4613      	mov	r3, r2
 8012bf2:	009b      	lsls	r3, r3, #2
 8012bf4:	4413      	add	r3, r2
 8012bf6:	009b      	lsls	r3, r3, #2
 8012bf8:	461a      	mov	r2, r3
 8012bfa:	68bb      	ldr	r3, [r7, #8]
 8012bfc:	4413      	add	r3, r2
 8012bfe:	689b      	ldr	r3, [r3, #8]
 8012c00:	2b00      	cmp	r3, #0
 8012c02:	d01c      	beq.n	8012c3e <SizeASN_Items+0x27a>
 8012c04:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012c06:	4613      	mov	r3, r2
 8012c08:	009b      	lsls	r3, r3, #2
 8012c0a:	4413      	add	r3, r2
 8012c0c:	009b      	lsls	r3, r3, #2
 8012c0e:	461a      	mov	r2, r3
 8012c10:	68bb      	ldr	r3, [r7, #8]
 8012c12:	4413      	add	r3, r2
 8012c14:	689b      	ldr	r3, [r3, #8]
 8012c16:	781b      	ldrb	r3, [r3, #0]
 8012c18:	b25b      	sxtb	r3, r3
 8012c1a:	2b00      	cmp	r3, #0
 8012c1c:	da0f      	bge.n	8012c3e <SizeASN_Items+0x27a>
                    dataLen++;
 8012c1e:	69bb      	ldr	r3, [r7, #24]
 8012c20:	3301      	adds	r3, #1
 8012c22:	61bb      	str	r3, [r7, #24]
                    /* ASN.1 items are below and cannot include extra byte. */
                    if (asn[i].headerOnly) {
 8012c24:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012c26:	009b      	lsls	r3, r3, #2
 8012c28:	68fa      	ldr	r2, [r7, #12]
 8012c2a:	4413      	add	r3, r2
 8012c2c:	789b      	ldrb	r3, [r3, #2]
 8012c2e:	f003 0302 	and.w	r3, r3, #2
 8012c32:	b2db      	uxtb	r3, r3
 8012c34:	2b00      	cmp	r3, #0
 8012c36:	d002      	beq.n	8012c3e <SizeASN_Items+0x27a>
                        len++;
 8012c38:	69fb      	ldr	r3, [r7, #28]
 8012c3a:	3301      	adds	r3, #1
 8012c3c:	61fb      	str	r3, [r7, #28]
                    }
                }
                /* Add in the size of tag and length. */
                len += SizeASNHeader(dataLen);
 8012c3e:	69b8      	ldr	r0, [r7, #24]
 8012c40:	f7ff fddc 	bl	80127fc <SizeASNLength>
 8012c44:	4603      	mov	r3, r0
 8012c46:	3301      	adds	r3, #1
 8012c48:	69fa      	ldr	r2, [r7, #28]
 8012c4a:	4413      	add	r3, r2
 8012c4c:	61fb      	str	r3, [r7, #28]
                /* Include data in length if not header only or if
                 * buffer supplied. */
                if (!asn[i].headerOnly || data[i].data.buffer.data != NULL) {
 8012c4e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012c50:	009b      	lsls	r3, r3, #2
 8012c52:	68fa      	ldr	r2, [r7, #12]
 8012c54:	4413      	add	r3, r2
 8012c56:	789b      	ldrb	r3, [r3, #2]
 8012c58:	f003 0302 	and.w	r3, r3, #2
 8012c5c:	b2db      	uxtb	r3, r3
 8012c5e:	2b00      	cmp	r3, #0
 8012c60:	d00a      	beq.n	8012c78 <SizeASN_Items+0x2b4>
 8012c62:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012c64:	4613      	mov	r3, r2
 8012c66:	009b      	lsls	r3, r3, #2
 8012c68:	4413      	add	r3, r2
 8012c6a:	009b      	lsls	r3, r3, #2
 8012c6c:	461a      	mov	r2, r3
 8012c6e:	68bb      	ldr	r3, [r7, #8]
 8012c70:	4413      	add	r3, r2
 8012c72:	689b      	ldr	r3, [r3, #8]
 8012c74:	2b00      	cmp	r3, #0
 8012c76:	d003      	beq.n	8012c80 <SizeASN_Items+0x2bc>
                    len += dataLen;
 8012c78:	69fa      	ldr	r2, [r7, #28]
 8012c7a:	69bb      	ldr	r3, [r7, #24]
 8012c7c:	4413      	add	r3, r2
 8012c7e:	61fb      	str	r3, [r7, #28]
                }
                break;
 8012c80:	bf00      	nop
                return BAD_STATE_E;
        #endif
        }

        /* Set the total length of the item. */
        data[i].length = len;
 8012c82:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012c84:	4613      	mov	r3, r2
 8012c86:	009b      	lsls	r3, r3, #2
 8012c88:	4413      	add	r3, r2
 8012c8a:	009b      	lsls	r3, r3, #2
 8012c8c:	461a      	mov	r2, r3
 8012c8e:	68bb      	ldr	r3, [r7, #8]
 8012c90:	4413      	add	r3, r2
 8012c92:	69fa      	ldr	r2, [r7, #28]
 8012c94:	605a      	str	r2, [r3, #4]
        /* Add length to total size. */
        sz += len;
 8012c96:	6a3a      	ldr	r2, [r7, #32]
 8012c98:	69fb      	ldr	r3, [r7, #28]
 8012c9a:	4413      	add	r3, r2
 8012c9c:	623b      	str	r3, [r7, #32]
        /* Set the offset to the current size - used in writing DER. */
        data[i].offset = sz;
 8012c9e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012ca0:	4613      	mov	r3, r2
 8012ca2:	009b      	lsls	r3, r3, #2
 8012ca4:	4413      	add	r3, r2
 8012ca6:	009b      	lsls	r3, r3, #2
 8012ca8:	461a      	mov	r2, r3
 8012caa:	68bb      	ldr	r3, [r7, #8]
 8012cac:	4413      	add	r3, r2
 8012cae:	6a3a      	ldr	r2, [r7, #32]
 8012cb0:	601a      	str	r2, [r3, #0]
    for (i = count - 1; i >= 0; i--) {
 8012cb2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012cb4:	3b01      	subs	r3, #1
 8012cb6:	627b      	str	r3, [r7, #36]	@ 0x24
 8012cb8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012cba:	2b00      	cmp	r3, #0
 8012cbc:	f6bf ae8f 	bge.w	80129de <SizeASN_Items+0x1a>
                data[i].offset, data[i].length, asn[i].constructed ? '+' : ' ',
                asn[i].depth, "", TagString(asn[i].tag));
    #endif
    }

    *encSz = (int)sz;
 8012cc0:	6a3a      	ldr	r2, [r7, #32]
 8012cc2:	683b      	ldr	r3, [r7, #0]
 8012cc4:	601a      	str	r2, [r3, #0]
    return 0;
 8012cc6:	2300      	movs	r3, #0
}
 8012cc8:	4618      	mov	r0, r3
 8012cca:	3728      	adds	r7, #40	@ 0x28
 8012ccc:	46bd      	mov	sp, r7
 8012cce:	bd80      	pop	{r7, pc}

08012cd0 <SetASN_Num>:
 * @param [in] n     Number to be encoded.
 * @param [in] bits  Maximum number of bits to encode.
 * @param [in] tag   DER tag e.g. INTEGER, BIT_STRING, etc.
 */
static void SetASN_Num(word32 n, int bits, byte* out, byte tag)
{
 8012cd0:	b480      	push	{r7}
 8012cd2:	b089      	sub	sp, #36	@ 0x24
 8012cd4:	af00      	add	r7, sp, #0
 8012cd6:	60f8      	str	r0, [r7, #12]
 8012cd8:	60b9      	str	r1, [r7, #8]
 8012cda:	607a      	str	r2, [r7, #4]
 8012cdc:	70fb      	strb	r3, [r7, #3]
    byte   len;

    /* Encoding: Tag (1 byte) | Length (1 byte) | Data (number) */

    /* Data will start at index 2 unless BIT_STRING or INTEGER */
    idx = 2;
 8012cde:	2302      	movs	r3, #2
 8012ce0:	61bb      	str	r3, [r7, #24]

    /* Set the length of the number based on maximum bit length. */
    len = (byte)(bits / 8);
 8012ce2:	68bb      	ldr	r3, [r7, #8]
 8012ce4:	2b00      	cmp	r3, #0
 8012ce6:	da00      	bge.n	8012cea <SetASN_Num+0x1a>
 8012ce8:	3307      	adds	r3, #7
 8012cea:	10db      	asrs	r3, r3, #3
 8012cec:	75fb      	strb	r3, [r7, #23]
    /* Discover actual size by checking for leading zero bytes. */
    for (j = bits - 8; j > 0; j -= 8) {
 8012cee:	68bb      	ldr	r3, [r7, #8]
 8012cf0:	3b08      	subs	r3, #8
 8012cf2:	61fb      	str	r3, [r7, #28]
 8012cf4:	e00b      	b.n	8012d0e <SetASN_Num+0x3e>
        if ((n >> j) != 0) {
 8012cf6:	68fa      	ldr	r2, [r7, #12]
 8012cf8:	69fb      	ldr	r3, [r7, #28]
 8012cfa:	fa22 f303 	lsr.w	r3, r2, r3
 8012cfe:	2b00      	cmp	r3, #0
 8012d00:	d109      	bne.n	8012d16 <SetASN_Num+0x46>
            break;
        }
        len--;
 8012d02:	7dfb      	ldrb	r3, [r7, #23]
 8012d04:	3b01      	subs	r3, #1
 8012d06:	75fb      	strb	r3, [r7, #23]
    for (j = bits - 8; j > 0; j -= 8) {
 8012d08:	69fb      	ldr	r3, [r7, #28]
 8012d0a:	3b08      	subs	r3, #8
 8012d0c:	61fb      	str	r3, [r7, #28]
 8012d0e:	69fb      	ldr	r3, [r7, #28]
 8012d10:	2b00      	cmp	r3, #0
 8012d12:	dcf0      	bgt.n	8012cf6 <SetASN_Num+0x26>
 8012d14:	e000      	b.n	8012d18 <SetASN_Num+0x48>
            break;
 8012d16:	bf00      	nop
    /* Keep j, index of first non-zero byte, for writing out. */

    /* A BIT_STRING has the number of unused bits in last byte prepended to
     * data.
     */
    if (tag == ASN_BIT_STRING) {
 8012d18:	78fb      	ldrb	r3, [r7, #3]
 8012d1a:	2b03      	cmp	r3, #3
 8012d1c:	d124      	bne.n	8012d68 <SetASN_Num+0x98>
        byte unusedBits = 0;
 8012d1e:	2300      	movs	r3, #0
 8012d20:	75bb      	strb	r3, [r7, #22]
        byte lastByte = (byte)(n >> j);
 8012d22:	68fa      	ldr	r2, [r7, #12]
 8012d24:	69fb      	ldr	r3, [r7, #28]
 8012d26:	fa22 f303 	lsr.w	r3, r2, r3
 8012d2a:	757b      	strb	r3, [r7, #21]

        /* Quick check last bit. */
        if ((lastByte & 0x01) == 0x00) {
 8012d2c:	7d7b      	ldrb	r3, [r7, #21]
 8012d2e:	f003 0301 	and.w	r3, r3, #1
 8012d32:	2b00      	cmp	r3, #0
 8012d34:	d10e      	bne.n	8012d54 <SetASN_Num+0x84>
            unusedBits++;
 8012d36:	7dbb      	ldrb	r3, [r7, #22]
 8012d38:	3301      	adds	r3, #1
 8012d3a:	75bb      	strb	r3, [r7, #22]
            /* Check each bit for first least significant bit set. */
            while (((lastByte >> unusedBits) & 0x01) == 0x00)
 8012d3c:	e002      	b.n	8012d44 <SetASN_Num+0x74>
                unusedBits++;
 8012d3e:	7dbb      	ldrb	r3, [r7, #22]
 8012d40:	3301      	adds	r3, #1
 8012d42:	75bb      	strb	r3, [r7, #22]
            while (((lastByte >> unusedBits) & 0x01) == 0x00)
 8012d44:	7d7a      	ldrb	r2, [r7, #21]
 8012d46:	7dbb      	ldrb	r3, [r7, #22]
 8012d48:	fa42 f303 	asr.w	r3, r2, r3
 8012d4c:	f003 0301 	and.w	r3, r3, #1
 8012d50:	2b00      	cmp	r3, #0
 8012d52:	d0f4      	beq.n	8012d3e <SetASN_Num+0x6e>
        }
        /* Add unused bits byte. */
        len++;
 8012d54:	7dfb      	ldrb	r3, [r7, #23]
 8012d56:	3301      	adds	r3, #1
 8012d58:	75fb      	strb	r3, [r7, #23]
        out[idx++] = unusedBits;
 8012d5a:	69bb      	ldr	r3, [r7, #24]
 8012d5c:	1c5a      	adds	r2, r3, #1
 8012d5e:	61ba      	str	r2, [r7, #24]
 8012d60:	687a      	ldr	r2, [r7, #4]
 8012d62:	4413      	add	r3, r2
 8012d64:	7dba      	ldrb	r2, [r7, #22]
 8012d66:	701a      	strb	r2, [r3, #0]
    }

    /* An INTEGER has a prepended byte if MSB of number is 1 - makes encoded
     * value positive. */
    if ((tag == ASN_INTEGER) && (((n >> j) & 0x80) == 0x80)) {
 8012d68:	78fb      	ldrb	r3, [r7, #3]
 8012d6a:	2b02      	cmp	r3, #2
 8012d6c:	d111      	bne.n	8012d92 <SetASN_Num+0xc2>
 8012d6e:	68fa      	ldr	r2, [r7, #12]
 8012d70:	69fb      	ldr	r3, [r7, #28]
 8012d72:	fa22 f303 	lsr.w	r3, r2, r3
 8012d76:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8012d7a:	2b00      	cmp	r3, #0
 8012d7c:	d009      	beq.n	8012d92 <SetASN_Num+0xc2>
        len++;
 8012d7e:	7dfb      	ldrb	r3, [r7, #23]
 8012d80:	3301      	adds	r3, #1
 8012d82:	75fb      	strb	r3, [r7, #23]
        out[idx++] = 0;
 8012d84:	69bb      	ldr	r3, [r7, #24]
 8012d86:	1c5a      	adds	r2, r3, #1
 8012d88:	61ba      	str	r2, [r7, #24]
 8012d8a:	687a      	ldr	r2, [r7, #4]
 8012d8c:	4413      	add	r3, r2
 8012d8e:	2200      	movs	r2, #0
 8012d90:	701a      	strb	r2, [r3, #0]
    }

    /* Go back and put in length. */
    out[1] = len;
 8012d92:	687b      	ldr	r3, [r7, #4]
 8012d94:	3301      	adds	r3, #1
 8012d96:	7dfa      	ldrb	r2, [r7, #23]
 8012d98:	701a      	strb	r2, [r3, #0]
    /* Place in the required bytes of the number. */
    for (; j >= 0; j -= 8)
 8012d9a:	e00d      	b.n	8012db8 <SetASN_Num+0xe8>
        out[idx++] = (byte)(n >> j);
 8012d9c:	68fa      	ldr	r2, [r7, #12]
 8012d9e:	69fb      	ldr	r3, [r7, #28]
 8012da0:	fa22 f103 	lsr.w	r1, r2, r3
 8012da4:	69bb      	ldr	r3, [r7, #24]
 8012da6:	1c5a      	adds	r2, r3, #1
 8012da8:	61ba      	str	r2, [r7, #24]
 8012daa:	687a      	ldr	r2, [r7, #4]
 8012dac:	4413      	add	r3, r2
 8012dae:	b2ca      	uxtb	r2, r1
 8012db0:	701a      	strb	r2, [r3, #0]
    for (; j >= 0; j -= 8)
 8012db2:	69fb      	ldr	r3, [r7, #28]
 8012db4:	3b08      	subs	r3, #8
 8012db6:	61fb      	str	r3, [r7, #28]
 8012db8:	69fb      	ldr	r3, [r7, #28]
 8012dba:	2b00      	cmp	r3, #0
 8012dbc:	daee      	bge.n	8012d9c <SetASN_Num+0xcc>
}
 8012dbe:	bf00      	nop
 8012dc0:	bf00      	nop
 8012dc2:	3724      	adds	r7, #36	@ 0x24
 8012dc4:	46bd      	mov	sp, r7
 8012dc6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012dca:	4770      	bx	lr

08012dcc <SetASN_Items>:
 * @param [in]      count   Count of items to encode.
 * @param [in, out] output  Buffer to write encoding into.
 * @return  Size of the DER encoding in bytes.
 */
int SetASN_Items(const ASNItem* asn, ASNSetData *data, int count, byte* output)
{
 8012dcc:	b580      	push	{r7, lr}
 8012dce:	b08c      	sub	sp, #48	@ 0x30
 8012dd0:	af00      	add	r7, sp, #0
 8012dd2:	60f8      	str	r0, [r7, #12]
 8012dd4:	60b9      	str	r1, [r7, #8]
 8012dd6:	607a      	str	r2, [r7, #4]
 8012dd8:	603b      	str	r3, [r7, #0]
    WOLFSSL_ENTER("SetASN_Items");
#endif

    /* Offset of first item is the total length.
     * SizeASN_Items() calculated this. */
    sz = data[0].offset;
 8012dda:	68bb      	ldr	r3, [r7, #8]
 8012ddc:	681b      	ldr	r3, [r3, #0]
 8012dde:	623b      	str	r3, [r7, #32]

    /* Write out each item. */
    for (i = 0; i < count; i++) {
 8012de0:	2300      	movs	r3, #0
 8012de2:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8012de4:	e1fe      	b.n	80131e4 <SetASN_Items+0x418>
        /* Skip items not writing out. */
        if (data[i].noOut)
 8012de6:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8012de8:	4613      	mov	r3, r2
 8012dea:	009b      	lsls	r3, r3, #2
 8012dec:	4413      	add	r3, r2
 8012dee:	009b      	lsls	r3, r3, #2
 8012df0:	461a      	mov	r2, r3
 8012df2:	68bb      	ldr	r3, [r7, #8]
 8012df4:	4413      	add	r3, r2
 8012df6:	7c5b      	ldrb	r3, [r3, #17]
 8012df8:	2b00      	cmp	r3, #0
 8012dfa:	f040 81eb 	bne.w	80131d4 <SetASN_Items+0x408>
            continue;

        /* Start position to write item based on reverse offsets. */
        out = output + sz - data[i].offset;
 8012dfe:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8012e00:	4613      	mov	r3, r2
 8012e02:	009b      	lsls	r3, r3, #2
 8012e04:	4413      	add	r3, r2
 8012e06:	009b      	lsls	r3, r3, #2
 8012e08:	461a      	mov	r2, r3
 8012e0a:	68bb      	ldr	r3, [r7, #8]
 8012e0c:	4413      	add	r3, r2
 8012e0e:	681b      	ldr	r3, [r3, #0]
 8012e10:	6a3a      	ldr	r2, [r7, #32]
 8012e12:	1ad3      	subs	r3, r2, r3
 8012e14:	683a      	ldr	r2, [r7, #0]
 8012e16:	4413      	add	r3, r2
 8012e18:	61fb      	str	r3, [r7, #28]
        /* Index from start of item out. */
        idx = 0;
 8012e1a:	2300      	movs	r3, #0
 8012e1c:	62bb      	str	r3, [r7, #40]	@ 0x28

        if (data[i].dataType != ASN_DATA_TYPE_REPLACE_BUFFER) {
 8012e1e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8012e20:	4613      	mov	r3, r2
 8012e22:	009b      	lsls	r3, r3, #2
 8012e24:	4413      	add	r3, r2
 8012e26:	009b      	lsls	r3, r3, #2
 8012e28:	461a      	mov	r2, r3
 8012e2a:	68bb      	ldr	r3, [r7, #8]
 8012e2c:	4413      	add	r3, r2
 8012e2e:	7c1b      	ldrb	r3, [r3, #16]
 8012e30:	2b07      	cmp	r3, #7
 8012e32:	d019      	beq.n	8012e68 <SetASN_Items+0x9c>
            /* Put in the tag - not dumping in DER from buffer. */
            out[idx++] = asn[i].tag |
 8012e34:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8012e36:	009b      	lsls	r3, r3, #2
 8012e38:	68fa      	ldr	r2, [r7, #12]
 8012e3a:	4413      	add	r3, r2
 8012e3c:	785b      	ldrb	r3, [r3, #1]
 8012e3e:	b25a      	sxtb	r2, r3
                         (asn[i].constructed ? ASN_CONSTRUCTED : 0);
 8012e40:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8012e42:	009b      	lsls	r3, r3, #2
 8012e44:	68f9      	ldr	r1, [r7, #12]
 8012e46:	440b      	add	r3, r1
 8012e48:	789b      	ldrb	r3, [r3, #2]
 8012e4a:	b25b      	sxtb	r3, r3
 8012e4c:	015b      	lsls	r3, r3, #5
 8012e4e:	b25b      	sxtb	r3, r3
 8012e50:	f003 0320 	and.w	r3, r3, #32
 8012e54:	b25b      	sxtb	r3, r3
            out[idx++] = asn[i].tag |
 8012e56:	4313      	orrs	r3, r2
 8012e58:	b259      	sxtb	r1, r3
 8012e5a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8012e5c:	1c5a      	adds	r2, r3, #1
 8012e5e:	62ba      	str	r2, [r7, #40]	@ 0x28
 8012e60:	69fa      	ldr	r2, [r7, #28]
 8012e62:	4413      	add	r3, r2
 8012e64:	b2ca      	uxtb	r2, r1
 8012e66:	701a      	strb	r2, [r3, #0]
                sz - data[i].offset,
                data[i].length, asn[i].constructed ? '+' : ' ', asn[i].depth,
                "", TagString(asn[i].tag));
    #endif

        switch (data[i].dataType) {
 8012e68:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8012e6a:	4613      	mov	r3, r2
 8012e6c:	009b      	lsls	r3, r3, #2
 8012e6e:	4413      	add	r3, r2
 8012e70:	009b      	lsls	r3, r3, #2
 8012e72:	461a      	mov	r2, r3
 8012e74:	68bb      	ldr	r3, [r7, #8]
 8012e76:	4413      	add	r3, r2
 8012e78:	7c1b      	ldrb	r3, [r3, #16]
 8012e7a:	2b08      	cmp	r3, #8
 8012e7c:	f200 81af 	bhi.w	80131de <SetASN_Items+0x412>
 8012e80:	a201      	add	r2, pc, #4	@ (adr r2, 8012e88 <SetASN_Items+0xbc>)
 8012e82:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8012e86:	bf00      	nop
 8012e88:	08013015 	.word	0x08013015
 8012e8c:	08012ead 	.word	0x08012ead
 8012e90:	08012ed5 	.word	0x08012ed5
 8012e94:	080131df 	.word	0x080131df
 8012e98:	080131df 	.word	0x080131df
 8012e9c:	080131df 	.word	0x080131df
 8012ea0:	080131df 	.word	0x080131df
 8012ea4:	08012fb3 	.word	0x08012fb3
 8012ea8:	08012efd 	.word	0x08012efd
            /* Write out the length and data of a number. */
            case ASN_DATA_TYPE_WORD8:
                SetASN_Num(data[i].data.u8, 8, out, asn[i].tag);
 8012eac:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8012eae:	4613      	mov	r3, r2
 8012eb0:	009b      	lsls	r3, r3, #2
 8012eb2:	4413      	add	r3, r2
 8012eb4:	009b      	lsls	r3, r3, #2
 8012eb6:	461a      	mov	r2, r3
 8012eb8:	68bb      	ldr	r3, [r7, #8]
 8012eba:	4413      	add	r3, r2
 8012ebc:	7a1b      	ldrb	r3, [r3, #8]
 8012ebe:	4618      	mov	r0, r3
 8012ec0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8012ec2:	009b      	lsls	r3, r3, #2
 8012ec4:	68fa      	ldr	r2, [r7, #12]
 8012ec6:	4413      	add	r3, r2
 8012ec8:	785b      	ldrb	r3, [r3, #1]
 8012eca:	69fa      	ldr	r2, [r7, #28]
 8012ecc:	2108      	movs	r1, #8
 8012ece:	f7ff feff 	bl	8012cd0 <SetASN_Num>
                break;
 8012ed2:	e184      	b.n	80131de <SetASN_Items+0x412>
            case ASN_DATA_TYPE_WORD16:
                SetASN_Num(data[i].data.u16, 16, out, asn[i].tag);
 8012ed4:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8012ed6:	4613      	mov	r3, r2
 8012ed8:	009b      	lsls	r3, r3, #2
 8012eda:	4413      	add	r3, r2
 8012edc:	009b      	lsls	r3, r3, #2
 8012ede:	461a      	mov	r2, r3
 8012ee0:	68bb      	ldr	r3, [r7, #8]
 8012ee2:	4413      	add	r3, r2
 8012ee4:	891b      	ldrh	r3, [r3, #8]
 8012ee6:	4618      	mov	r0, r3
 8012ee8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8012eea:	009b      	lsls	r3, r3, #2
 8012eec:	68fa      	ldr	r2, [r7, #12]
 8012eee:	4413      	add	r3, r2
 8012ef0:	785b      	ldrb	r3, [r3, #1]
 8012ef2:	69fa      	ldr	r2, [r7, #28]
 8012ef4:	2110      	movs	r1, #16
 8012ef6:	f7ff feeb 	bl	8012cd0 <SetASN_Num>
                break;
 8012efa:	e170      	b.n	80131de <SetASN_Items+0x412>
        #endif

            /* Write out the length and data of a multi-precision number. */
            case ASN_DATA_TYPE_MP:
                /* Get length in bytes. */
                length = mp_unsigned_bin_size(data[i].data.mp);
 8012efc:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8012efe:	4613      	mov	r3, r2
 8012f00:	009b      	lsls	r3, r3, #2
 8012f02:	4413      	add	r3, r2
 8012f04:	009b      	lsls	r3, r3, #2
 8012f06:	461a      	mov	r2, r3
 8012f08:	68bb      	ldr	r3, [r7, #8]
 8012f0a:	4413      	add	r3, r2
 8012f0c:	689b      	ldr	r3, [r3, #8]
 8012f0e:	4618      	mov	r0, r3
 8012f10:	f013 fd6e 	bl	80269f0 <mp_unsigned_bin_size>
 8012f14:	61b8      	str	r0, [r7, #24]
                /* Add one for leading zero to make encoding a positive num. */
                length += mp_leading_bit(data[i].data.mp) ? 1 : 0;
 8012f16:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8012f18:	4613      	mov	r3, r2
 8012f1a:	009b      	lsls	r3, r3, #2
 8012f1c:	4413      	add	r3, r2
 8012f1e:	009b      	lsls	r3, r3, #2
 8012f20:	461a      	mov	r2, r3
 8012f22:	68bb      	ldr	r3, [r7, #8]
 8012f24:	4413      	add	r3, r2
 8012f26:	689b      	ldr	r3, [r3, #8]
 8012f28:	4618      	mov	r0, r3
 8012f2a:	f013 fe29 	bl	8026b80 <mp_leading_bit>
 8012f2e:	4603      	mov	r3, r0
 8012f30:	2b00      	cmp	r3, #0
 8012f32:	bf14      	ite	ne
 8012f34:	2301      	movne	r3, #1
 8012f36:	2300      	moveq	r3, #0
 8012f38:	b2db      	uxtb	r3, r3
 8012f3a:	461a      	mov	r2, r3
 8012f3c:	69bb      	ldr	r3, [r7, #24]
 8012f3e:	4413      	add	r3, r2
 8012f40:	61bb      	str	r3, [r7, #24]
                /* Write out length. */
                idx += SetASNLength((word32)length, out + idx);
 8012f42:	69b8      	ldr	r0, [r7, #24]
 8012f44:	69fa      	ldr	r2, [r7, #28]
 8012f46:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8012f48:	4413      	add	r3, r2
 8012f4a:	4619      	mov	r1, r3
 8012f4c:	f7ff fc17 	bl	801277e <SetASNLength>
 8012f50:	4602      	mov	r2, r0
 8012f52:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8012f54:	4413      	add	r3, r2
 8012f56:	62bb      	str	r3, [r7, #40]	@ 0x28
                /* Write out leading zero to make positive. */
                if (mp_leading_bit(data[i].data.mp)) {
 8012f58:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8012f5a:	4613      	mov	r3, r2
 8012f5c:	009b      	lsls	r3, r3, #2
 8012f5e:	4413      	add	r3, r2
 8012f60:	009b      	lsls	r3, r3, #2
 8012f62:	461a      	mov	r2, r3
 8012f64:	68bb      	ldr	r3, [r7, #8]
 8012f66:	4413      	add	r3, r2
 8012f68:	689b      	ldr	r3, [r3, #8]
 8012f6a:	4618      	mov	r0, r3
 8012f6c:	f013 fe08 	bl	8026b80 <mp_leading_bit>
 8012f70:	4603      	mov	r3, r0
 8012f72:	2b00      	cmp	r3, #0
 8012f74:	d006      	beq.n	8012f84 <SetASN_Items+0x1b8>
                    out[idx++] = 0;
 8012f76:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8012f78:	1c5a      	adds	r2, r3, #1
 8012f7a:	62ba      	str	r2, [r7, #40]	@ 0x28
 8012f7c:	69fa      	ldr	r2, [r7, #28]
 8012f7e:	4413      	add	r3, r2
 8012f80:	2200      	movs	r2, #0
 8012f82:	701a      	strb	r2, [r3, #0]
                }
                /* Encode number in big-endian byte array. */
                err = mp_to_unsigned_bin(data[i].data.mp, out + idx);
 8012f84:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8012f86:	4613      	mov	r3, r2
 8012f88:	009b      	lsls	r3, r3, #2
 8012f8a:	4413      	add	r3, r2
 8012f8c:	009b      	lsls	r3, r3, #2
 8012f8e:	461a      	mov	r2, r3
 8012f90:	68bb      	ldr	r3, [r7, #8]
 8012f92:	4413      	add	r3, r2
 8012f94:	6898      	ldr	r0, [r3, #8]
 8012f96:	69fa      	ldr	r2, [r7, #28]
 8012f98:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8012f9a:	4413      	add	r3, r2
 8012f9c:	4619      	mov	r1, r3
 8012f9e:	f013 fd33 	bl	8026a08 <mp_to_unsigned_bin>
 8012fa2:	6178      	str	r0, [r7, #20]
                if (err != MP_OKAY) {
 8012fa4:	697b      	ldr	r3, [r7, #20]
 8012fa6:	2b00      	cmp	r3, #0
 8012fa8:	f000 8116 	beq.w	80131d8 <SetASN_Items+0x40c>
                    WOLFSSL_MSG("SetASN_Items: Failed to write mp_int");
                    return MP_TO_E;
 8012fac:	f06f 0370 	mvn.w	r3, #112	@ 0x70
 8012fb0:	e11e      	b.n	80131f0 <SetASN_Items+0x424>
                }
                break;

            case ASN_DATA_TYPE_REPLACE_BUFFER:
                if (data[i].data.buffer.data == NULL) {
 8012fb2:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8012fb4:	4613      	mov	r3, r2
 8012fb6:	009b      	lsls	r3, r3, #2
 8012fb8:	4413      	add	r3, r2
 8012fba:	009b      	lsls	r3, r3, #2
 8012fbc:	461a      	mov	r2, r3
 8012fbe:	68bb      	ldr	r3, [r7, #8]
 8012fc0:	4413      	add	r3, r2
 8012fc2:	689b      	ldr	r3, [r3, #8]
 8012fc4:	2b00      	cmp	r3, #0
 8012fc6:	d10c      	bne.n	8012fe2 <SetASN_Items+0x216>
                    /* Return pointer for caller to use. */
                    data[i].data.buffer.data = out + idx;
 8012fc8:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8012fca:	4613      	mov	r3, r2
 8012fcc:	009b      	lsls	r3, r3, #2
 8012fce:	4413      	add	r3, r2
 8012fd0:	009b      	lsls	r3, r3, #2
 8012fd2:	461a      	mov	r2, r3
 8012fd4:	68bb      	ldr	r3, [r7, #8]
 8012fd6:	4413      	add	r3, r2
 8012fd8:	69f9      	ldr	r1, [r7, #28]
 8012fda:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8012fdc:	440a      	add	r2, r1
 8012fde:	609a      	str	r2, [r3, #8]
                else {
                    /* Dump in the DER encoded data. */
                    XMEMCPY(out + idx, data[i].data.buffer.data,
                            data[i].data.buffer.length);
                }
                break;
 8012fe0:	e0fd      	b.n	80131de <SetASN_Items+0x412>
                    XMEMCPY(out + idx, data[i].data.buffer.data,
 8012fe2:	69fa      	ldr	r2, [r7, #28]
 8012fe4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8012fe6:	18d0      	adds	r0, r2, r3
 8012fe8:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8012fea:	4613      	mov	r3, r2
 8012fec:	009b      	lsls	r3, r3, #2
 8012fee:	4413      	add	r3, r2
 8012ff0:	009b      	lsls	r3, r3, #2
 8012ff2:	461a      	mov	r2, r3
 8012ff4:	68bb      	ldr	r3, [r7, #8]
 8012ff6:	4413      	add	r3, r2
 8012ff8:	6899      	ldr	r1, [r3, #8]
 8012ffa:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8012ffc:	4613      	mov	r3, r2
 8012ffe:	009b      	lsls	r3, r3, #2
 8013000:	4413      	add	r3, r2
 8013002:	009b      	lsls	r3, r3, #2
 8013004:	461a      	mov	r2, r3
 8013006:	68bb      	ldr	r3, [r7, #8]
 8013008:	4413      	add	r3, r2
 801300a:	68db      	ldr	r3, [r3, #12]
 801300c:	461a      	mov	r2, r3
 801300e:	f015 fac5 	bl	802859c <memcpy>
                break;
 8013012:	e0e4      	b.n	80131de <SetASN_Items+0x412>

            case ASN_DATA_TYPE_NONE:
                if (asn[i].tag == ASN_BOOLEAN) {
 8013014:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013016:	009b      	lsls	r3, r3, #2
 8013018:	68fa      	ldr	r2, [r7, #12]
 801301a:	4413      	add	r3, r2
 801301c:	785b      	ldrb	r3, [r3, #1]
 801301e:	2b01      	cmp	r3, #1
 8013020:	d11a      	bne.n	8013058 <SetASN_Items+0x28c>
                    /* Always one byte of data. */
                    out[idx++] = 1;
 8013022:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8013024:	1c5a      	adds	r2, r3, #1
 8013026:	62ba      	str	r2, [r7, #40]	@ 0x28
 8013028:	69fa      	ldr	r2, [r7, #28]
 801302a:	4413      	add	r3, r2
 801302c:	2201      	movs	r2, #1
 801302e:	701a      	strb	r2, [r3, #0]
                    /* TRUE = 0xff, FALSE = 0x00 */
                    out[idx] = data[i].data.u8 ? 0xffU : 0x00U;
 8013030:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8013032:	4613      	mov	r3, r2
 8013034:	009b      	lsls	r3, r3, #2
 8013036:	4413      	add	r3, r2
 8013038:	009b      	lsls	r3, r3, #2
 801303a:	461a      	mov	r2, r3
 801303c:	68bb      	ldr	r3, [r7, #8]
 801303e:	4413      	add	r3, r2
 8013040:	7a1b      	ldrb	r3, [r3, #8]
 8013042:	2b00      	cmp	r3, #0
 8013044:	d001      	beq.n	801304a <SetASN_Items+0x27e>
 8013046:	21ff      	movs	r1, #255	@ 0xff
 8013048:	e000      	b.n	801304c <SetASN_Items+0x280>
 801304a:	2100      	movs	r1, #0
 801304c:	69fa      	ldr	r2, [r7, #28]
 801304e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8013050:	4413      	add	r3, r2
 8013052:	460a      	mov	r2, r1
 8013054:	701a      	strb	r2, [r3, #0]
                        /* Allow data to come from output buffer. */
                        XMEMMOVE(out + idx, data[i].data.buffer.data,
                                 data[i].data.buffer.length);
                    }
                }
                break;
 8013056:	e0c1      	b.n	80131dc <SetASN_Items+0x410>
                else if (asn[i].tag == ASN_TAG_NULL) {
 8013058:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801305a:	009b      	lsls	r3, r3, #2
 801305c:	68fa      	ldr	r2, [r7, #12]
 801305e:	4413      	add	r3, r2
 8013060:	785b      	ldrb	r3, [r3, #1]
 8013062:	2b05      	cmp	r3, #5
 8013064:	d105      	bne.n	8013072 <SetASN_Items+0x2a6>
                    out[idx] = 0;
 8013066:	69fa      	ldr	r2, [r7, #28]
 8013068:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801306a:	4413      	add	r3, r2
 801306c:	2200      	movs	r2, #0
 801306e:	701a      	strb	r2, [r3, #0]
                break;
 8013070:	e0b4      	b.n	80131dc <SetASN_Items+0x410>
                    word32 dataLen = data[i].data.buffer.length;
 8013072:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8013074:	4613      	mov	r3, r2
 8013076:	009b      	lsls	r3, r3, #2
 8013078:	4413      	add	r3, r2
 801307a:	009b      	lsls	r3, r3, #2
 801307c:	461a      	mov	r2, r3
 801307e:	68bb      	ldr	r3, [r7, #8]
 8013080:	4413      	add	r3, r2
 8013082:	68db      	ldr	r3, [r3, #12]
 8013084:	627b      	str	r3, [r7, #36]	@ 0x24
                    if ((asn[i].tag == ASN_BIT_STRING) ||
 8013086:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013088:	009b      	lsls	r3, r3, #2
 801308a:	68fa      	ldr	r2, [r7, #12]
 801308c:	4413      	add	r3, r2
 801308e:	785b      	ldrb	r3, [r3, #1]
 8013090:	2b03      	cmp	r3, #3
 8013092:	d01e      	beq.n	80130d2 <SetASN_Items+0x306>
                                                   ASNIntMSBSet(asn, data, i)) {
 8013094:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013096:	009b      	lsls	r3, r3, #2
 8013098:	68fa      	ldr	r2, [r7, #12]
 801309a:	4413      	add	r3, r2
 801309c:	785b      	ldrb	r3, [r3, #1]
                    if ((asn[i].tag == ASN_BIT_STRING) ||
 801309e:	2b02      	cmp	r3, #2
 80130a0:	d11a      	bne.n	80130d8 <SetASN_Items+0x30c>
                                                   ASNIntMSBSet(asn, data, i)) {
 80130a2:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80130a4:	4613      	mov	r3, r2
 80130a6:	009b      	lsls	r3, r3, #2
 80130a8:	4413      	add	r3, r2
 80130aa:	009b      	lsls	r3, r3, #2
 80130ac:	461a      	mov	r2, r3
 80130ae:	68bb      	ldr	r3, [r7, #8]
 80130b0:	4413      	add	r3, r2
 80130b2:	689b      	ldr	r3, [r3, #8]
 80130b4:	2b00      	cmp	r3, #0
 80130b6:	d00f      	beq.n	80130d8 <SetASN_Items+0x30c>
 80130b8:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80130ba:	4613      	mov	r3, r2
 80130bc:	009b      	lsls	r3, r3, #2
 80130be:	4413      	add	r3, r2
 80130c0:	009b      	lsls	r3, r3, #2
 80130c2:	461a      	mov	r2, r3
 80130c4:	68bb      	ldr	r3, [r7, #8]
 80130c6:	4413      	add	r3, r2
 80130c8:	689b      	ldr	r3, [r3, #8]
 80130ca:	781b      	ldrb	r3, [r3, #0]
 80130cc:	b25b      	sxtb	r3, r3
 80130ce:	2b00      	cmp	r3, #0
 80130d0:	da02      	bge.n	80130d8 <SetASN_Items+0x30c>
                        dataLen++;
 80130d2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80130d4:	3301      	adds	r3, #1
 80130d6:	627b      	str	r3, [r7, #36]	@ 0x24
                    idx += SetASNLength(dataLen, out + idx);
 80130d8:	69fa      	ldr	r2, [r7, #28]
 80130da:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80130dc:	4413      	add	r3, r2
 80130de:	4619      	mov	r1, r3
 80130e0:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 80130e2:	f7ff fb4c 	bl	801277e <SetASNLength>
 80130e6:	4602      	mov	r2, r0
 80130e8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80130ea:	4413      	add	r3, r2
 80130ec:	62bb      	str	r3, [r7, #40]	@ 0x28
                    if ((asn[i].tag == ASN_BIT_STRING) ||
 80130ee:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80130f0:	009b      	lsls	r3, r3, #2
 80130f2:	68fa      	ldr	r2, [r7, #12]
 80130f4:	4413      	add	r3, r2
 80130f6:	785b      	ldrb	r3, [r3, #1]
 80130f8:	2b03      	cmp	r3, #3
 80130fa:	d01e      	beq.n	801313a <SetASN_Items+0x36e>
                                                   ASNIntMSBSet(asn, data, i)) {
 80130fc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80130fe:	009b      	lsls	r3, r3, #2
 8013100:	68fa      	ldr	r2, [r7, #12]
 8013102:	4413      	add	r3, r2
 8013104:	785b      	ldrb	r3, [r3, #1]
                    if ((asn[i].tag == ASN_BIT_STRING) ||
 8013106:	2b02      	cmp	r3, #2
 8013108:	d11e      	bne.n	8013148 <SetASN_Items+0x37c>
                                                   ASNIntMSBSet(asn, data, i)) {
 801310a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801310c:	4613      	mov	r3, r2
 801310e:	009b      	lsls	r3, r3, #2
 8013110:	4413      	add	r3, r2
 8013112:	009b      	lsls	r3, r3, #2
 8013114:	461a      	mov	r2, r3
 8013116:	68bb      	ldr	r3, [r7, #8]
 8013118:	4413      	add	r3, r2
 801311a:	689b      	ldr	r3, [r3, #8]
 801311c:	2b00      	cmp	r3, #0
 801311e:	d013      	beq.n	8013148 <SetASN_Items+0x37c>
 8013120:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8013122:	4613      	mov	r3, r2
 8013124:	009b      	lsls	r3, r3, #2
 8013126:	4413      	add	r3, r2
 8013128:	009b      	lsls	r3, r3, #2
 801312a:	461a      	mov	r2, r3
 801312c:	68bb      	ldr	r3, [r7, #8]
 801312e:	4413      	add	r3, r2
 8013130:	689b      	ldr	r3, [r3, #8]
 8013132:	781b      	ldrb	r3, [r3, #0]
 8013134:	b25b      	sxtb	r3, r3
 8013136:	2b00      	cmp	r3, #0
 8013138:	da06      	bge.n	8013148 <SetASN_Items+0x37c>
                        out[idx++] = 0x00;
 801313a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801313c:	1c5a      	adds	r2, r3, #1
 801313e:	62ba      	str	r2, [r7, #40]	@ 0x28
 8013140:	69fa      	ldr	r2, [r7, #28]
 8013142:	4413      	add	r3, r2
 8013144:	2200      	movs	r2, #0
 8013146:	701a      	strb	r2, [r3, #0]
                    if (data[i].data.buffer.data == NULL) {
 8013148:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801314a:	4613      	mov	r3, r2
 801314c:	009b      	lsls	r3, r3, #2
 801314e:	4413      	add	r3, r2
 8013150:	009b      	lsls	r3, r3, #2
 8013152:	461a      	mov	r2, r3
 8013154:	68bb      	ldr	r3, [r7, #8]
 8013156:	4413      	add	r3, r2
 8013158:	689b      	ldr	r3, [r3, #8]
 801315a:	2b00      	cmp	r3, #0
 801315c:	d10c      	bne.n	8013178 <SetASN_Items+0x3ac>
                        data[i].data.buffer.data = out + idx;
 801315e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8013160:	4613      	mov	r3, r2
 8013162:	009b      	lsls	r3, r3, #2
 8013164:	4413      	add	r3, r2
 8013166:	009b      	lsls	r3, r3, #2
 8013168:	461a      	mov	r2, r3
 801316a:	68bb      	ldr	r3, [r7, #8]
 801316c:	4413      	add	r3, r2
 801316e:	69f9      	ldr	r1, [r7, #28]
 8013170:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8013172:	440a      	add	r2, r1
 8013174:	609a      	str	r2, [r3, #8]
                break;
 8013176:	e031      	b.n	80131dc <SetASN_Items+0x410>
                    else if (!asn[i].headerOnly ||
 8013178:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801317a:	009b      	lsls	r3, r3, #2
 801317c:	68fa      	ldr	r2, [r7, #12]
 801317e:	4413      	add	r3, r2
 8013180:	789b      	ldrb	r3, [r3, #2]
 8013182:	f003 0302 	and.w	r3, r3, #2
 8013186:	b2db      	uxtb	r3, r3
 8013188:	2b00      	cmp	r3, #0
 801318a:	d00a      	beq.n	80131a2 <SetASN_Items+0x3d6>
                            data[i].data.buffer.data != NULL) {
 801318c:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801318e:	4613      	mov	r3, r2
 8013190:	009b      	lsls	r3, r3, #2
 8013192:	4413      	add	r3, r2
 8013194:	009b      	lsls	r3, r3, #2
 8013196:	461a      	mov	r2, r3
 8013198:	68bb      	ldr	r3, [r7, #8]
 801319a:	4413      	add	r3, r2
 801319c:	689b      	ldr	r3, [r3, #8]
                    else if (!asn[i].headerOnly ||
 801319e:	2b00      	cmp	r3, #0
 80131a0:	d01c      	beq.n	80131dc <SetASN_Items+0x410>
                        XMEMMOVE(out + idx, data[i].data.buffer.data,
 80131a2:	69fa      	ldr	r2, [r7, #28]
 80131a4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80131a6:	18d0      	adds	r0, r2, r3
 80131a8:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80131aa:	4613      	mov	r3, r2
 80131ac:	009b      	lsls	r3, r3, #2
 80131ae:	4413      	add	r3, r2
 80131b0:	009b      	lsls	r3, r3, #2
 80131b2:	461a      	mov	r2, r3
 80131b4:	68bb      	ldr	r3, [r7, #8]
 80131b6:	4413      	add	r3, r2
 80131b8:	6899      	ldr	r1, [r3, #8]
 80131ba:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80131bc:	4613      	mov	r3, r2
 80131be:	009b      	lsls	r3, r3, #2
 80131c0:	4413      	add	r3, r2
 80131c2:	009b      	lsls	r3, r3, #2
 80131c4:	461a      	mov	r2, r3
 80131c6:	68bb      	ldr	r3, [r7, #8]
 80131c8:	4413      	add	r3, r2
 80131ca:	68db      	ldr	r3, [r3, #12]
 80131cc:	461a      	mov	r2, r3
 80131ce:	f015 f961 	bl	8028494 <memmove>
                break;
 80131d2:	e003      	b.n	80131dc <SetASN_Items+0x410>
            continue;
 80131d4:	bf00      	nop
 80131d6:	e002      	b.n	80131de <SetASN_Items+0x412>
                break;
 80131d8:	bf00      	nop
 80131da:	e000      	b.n	80131de <SetASN_Items+0x412>
                break;
 80131dc:	bf00      	nop
    for (i = 0; i < count; i++) {
 80131de:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80131e0:	3301      	adds	r3, #1
 80131e2:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80131e4:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80131e6:	687b      	ldr	r3, [r7, #4]
 80131e8:	429a      	cmp	r2, r3
 80131ea:	f6ff adfc 	blt.w	8012de6 <SetASN_Items+0x1a>
                return BAD_STATE_E;
        #endif
        }
    }

    return (int)sz;
 80131ee:	6a3b      	ldr	r3, [r7, #32]
}
 80131f0:	4618      	mov	r0, r3
 80131f2:	3730      	adds	r7, #48	@ 0x30
 80131f4:	46bd      	mov	sp, r7
 80131f6:	bd80      	pop	{r7, pc}

080131f8 <GetASN_Integer>:
 * @return  ASN_PARSE_E when 0 is not required but seen.
 * @return  ASN_EXPECT_0_E when 0 is required and not seen.
 */
static int GetASN_Integer(const byte* input, word32 idx, int length,
                          int positive)
{
 80131f8:	b480      	push	{r7}
 80131fa:	b085      	sub	sp, #20
 80131fc:	af00      	add	r7, sp, #0
 80131fe:	60f8      	str	r0, [r7, #12]
 8013200:	60b9      	str	r1, [r7, #8]
 8013202:	607a      	str	r2, [r7, #4]
 8013204:	603b      	str	r3, [r7, #0]
#if !defined(HAVE_SELFTEST) && !defined(HAVE_FIPS) || \
    (defined(HAVE_FIPS_VERSION) && (HAVE_FIPS_VERSION > 2))
    /* Check contents consist of one or more octets. */
    if (length == 0) {
 8013206:	687b      	ldr	r3, [r7, #4]
 8013208:	2b00      	cmp	r3, #0
 801320a:	d102      	bne.n	8013212 <GetASN_Integer+0x1a>
        WOLFSSL_MSG("Zero length INTEGER not allowed");
        return ASN_PARSE_E;
 801320c:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013210:	e035      	b.n	801327e <GetASN_Integer+0x86>
    }
#endif
    if (input[idx] == 0) {
 8013212:	68fa      	ldr	r2, [r7, #12]
 8013214:	68bb      	ldr	r3, [r7, #8]
 8013216:	4413      	add	r3, r2
 8013218:	781b      	ldrb	r3, [r3, #0]
 801321a:	2b00      	cmp	r3, #0
 801321c:	d10d      	bne.n	801323a <GetASN_Integer+0x42>
        /* Check leading zero byte required. */
        if ((length > 1) && ((input[idx + 1] & 0x80) == 0)) {
 801321e:	687b      	ldr	r3, [r7, #4]
 8013220:	2b01      	cmp	r3, #1
 8013222:	dd2b      	ble.n	801327c <GetASN_Integer+0x84>
 8013224:	68bb      	ldr	r3, [r7, #8]
 8013226:	3301      	adds	r3, #1
 8013228:	68fa      	ldr	r2, [r7, #12]
 801322a:	4413      	add	r3, r2
 801322c:	781b      	ldrb	r3, [r3, #0]
 801322e:	b25b      	sxtb	r3, r3
 8013230:	2b00      	cmp	r3, #0
 8013232:	db23      	blt.n	801327c <GetASN_Integer+0x84>
            WOLFSSL_MSG("Zero not required on INTEGER");
        #ifndef WOLFSSL_ASN_INT_LEAD_0_ANY
            return ASN_PARSE_E;
 8013234:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013238:	e021      	b.n	801327e <GetASN_Integer+0x86>
        }
    }
    /* check for invalid padding on negative integer.
     * c.f. X.690 (ISO/IEC 8825-2:2003 (E)) 10.4.6; RFC 5280 4.1
     */
    else if ((length > 1) && (input[idx] == 0xff) &&
 801323a:	687b      	ldr	r3, [r7, #4]
 801323c:	2b01      	cmp	r3, #1
 801323e:	dd10      	ble.n	8013262 <GetASN_Integer+0x6a>
 8013240:	68fa      	ldr	r2, [r7, #12]
 8013242:	68bb      	ldr	r3, [r7, #8]
 8013244:	4413      	add	r3, r2
 8013246:	781b      	ldrb	r3, [r3, #0]
 8013248:	2bff      	cmp	r3, #255	@ 0xff
 801324a:	d10a      	bne.n	8013262 <GetASN_Integer+0x6a>
             ((input[idx + 1] & 0x80) != 0)) {
 801324c:	68bb      	ldr	r3, [r7, #8]
 801324e:	3301      	adds	r3, #1
 8013250:	68fa      	ldr	r2, [r7, #12]
 8013252:	4413      	add	r3, r2
 8013254:	781b      	ldrb	r3, [r3, #0]
 8013256:	b25b      	sxtb	r3, r3
    else if ((length > 1) && (input[idx] == 0xff) &&
 8013258:	2b00      	cmp	r3, #0
 801325a:	da02      	bge.n	8013262 <GetASN_Integer+0x6a>
        WOLFSSL_MSG("Bad INTEGER encoding of negative");
    #ifndef WOLFSSL_ASN_INT_LEAD_0_ANY
        return ASN_EXPECT_0_E;
 801325c:	f06f 0391 	mvn.w	r3, #145	@ 0x91
 8013260:	e00d      	b.n	801327e <GetASN_Integer+0x86>
    #endif /* WOLFSSL_ASN_INT_LEAD_0_ANY */
    }
    /* Check whether a leading zero byte was required. */
    else if (positive && (input[idx] & 0x80)) {
 8013262:	683b      	ldr	r3, [r7, #0]
 8013264:	2b00      	cmp	r3, #0
 8013266:	d009      	beq.n	801327c <GetASN_Integer+0x84>
 8013268:	68fa      	ldr	r2, [r7, #12]
 801326a:	68bb      	ldr	r3, [r7, #8]
 801326c:	4413      	add	r3, r2
 801326e:	781b      	ldrb	r3, [r3, #0]
 8013270:	b25b      	sxtb	r3, r3
 8013272:	2b00      	cmp	r3, #0
 8013274:	da02      	bge.n	801327c <GetASN_Integer+0x84>
        WOLFSSL_MSG("INTEGER is negative");
    #ifndef WOLFSSL_ASN_INT_LEAD_0_ANY
        return ASN_EXPECT_0_E;
 8013276:	f06f 0391 	mvn.w	r3, #145	@ 0x91
 801327a:	e000      	b.n	801327e <GetASN_Integer+0x86>
    #endif /* WOLFSSL_ASN_INT_LEAD_0_ANY */
    }

    return 0;
 801327c:	2300      	movs	r3, #0
}
 801327e:	4618      	mov	r0, r3
 8013280:	3714      	adds	r7, #20
 8013282:	46bd      	mov	sp, r7
 8013284:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013288:	4770      	bx	lr

0801328a <GetASN_BitString>:
 * @param [in] length  Length of input data.
 * @return  0 on success.
 * @return  ASN_PARSE_E when unused bits is invalid.
 */
int GetASN_BitString(const byte* input, word32 idx, int length)
{
 801328a:	b480      	push	{r7}
 801328c:	b085      	sub	sp, #20
 801328e:	af00      	add	r7, sp, #0
 8013290:	60f8      	str	r0, [r7, #12]
 8013292:	60b9      	str	r1, [r7, #8]
 8013294:	607a      	str	r2, [r7, #4]
#if !defined(HAVE_SELFTEST) && !defined(HAVE_FIPS) || \
    (defined(HAVE_FIPS_VERSION) && (HAVE_FIPS_VERSION > 2))
    /* Check contents consist of one or more octets. */
    if (length == 0) {
 8013296:	687b      	ldr	r3, [r7, #4]
 8013298:	2b00      	cmp	r3, #0
 801329a:	d102      	bne.n	80132a2 <GetASN_BitString+0x18>
    #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
        WOLFSSL_MSG("Zero length BIT STRING not allowed");
    #endif
        return ASN_PARSE_E;
 801329c:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80132a0:	e01f      	b.n	80132e2 <GetASN_BitString+0x58>
    }
#endif
    /* Ensure unused bits value is valid range. */
    if (input[idx] > 7) {
 80132a2:	68fa      	ldr	r2, [r7, #12]
 80132a4:	68bb      	ldr	r3, [r7, #8]
 80132a6:	4413      	add	r3, r2
 80132a8:	781b      	ldrb	r3, [r3, #0]
 80132aa:	2b07      	cmp	r3, #7
 80132ac:	d902      	bls.n	80132b4 <GetASN_BitString+0x2a>
    #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
        WOLFSSL_MSG_VSNPRINTF("BIT STRING unused bits too big: %d > 7",
                input[idx]);
    #endif
        return ASN_PARSE_E;
 80132ae:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80132b2:	e016      	b.n	80132e2 <GetASN_BitString+0x58>
    }
    /* Ensure unused bits are zero. */
    if ((byte)(input[idx + (word32)length - 1] << (8 - input[idx])) != 0) {
 80132b4:	687a      	ldr	r2, [r7, #4]
 80132b6:	68bb      	ldr	r3, [r7, #8]
 80132b8:	4413      	add	r3, r2
 80132ba:	3b01      	subs	r3, #1
 80132bc:	68fa      	ldr	r2, [r7, #12]
 80132be:	4413      	add	r3, r2
 80132c0:	781b      	ldrb	r3, [r3, #0]
 80132c2:	4619      	mov	r1, r3
 80132c4:	68fa      	ldr	r2, [r7, #12]
 80132c6:	68bb      	ldr	r3, [r7, #8]
 80132c8:	4413      	add	r3, r2
 80132ca:	781b      	ldrb	r3, [r3, #0]
 80132cc:	f1c3 0308 	rsb	r3, r3, #8
 80132d0:	fa01 f303 	lsl.w	r3, r1, r3
 80132d4:	b2db      	uxtb	r3, r3
 80132d6:	2b00      	cmp	r3, #0
 80132d8:	d002      	beq.n	80132e0 <GetASN_BitString+0x56>
    #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
        WOLFSSL_MSG_VSNPRINTF("BIT STRING unused bits used: %d %02x",
                input[idx], input[idx + length - 1]);
    #endif
        return ASN_PARSE_E;
 80132da:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80132de:	e000      	b.n	80132e2 <GetASN_BitString+0x58>
    }

    return 0;
 80132e0:	2300      	movs	r3, #0
}
 80132e2:	4618      	mov	r0, r3
 80132e4:	3714      	adds	r7, #20
 80132e6:	46bd      	mov	sp, r7
 80132e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80132ec:	4770      	bx	lr

080132ee <GetASN_UTF8String>:
 * @param [in] length  Length of input data.
 * @return  0 on success.
 * @return  ASN_PARSE_E when data is invalid.
 */
static int GetASN_UTF8String(const byte* input, word32 idx, int length)
{
 80132ee:	b480      	push	{r7}
 80132f0:	b089      	sub	sp, #36	@ 0x24
 80132f2:	af00      	add	r7, sp, #0
 80132f4:	60f8      	str	r0, [r7, #12]
 80132f6:	60b9      	str	r1, [r7, #8]
 80132f8:	607a      	str	r2, [r7, #4]
    int ret = 0;
 80132fa:	2300      	movs	r3, #0
 80132fc:	61fb      	str	r3, [r7, #28]
    word32 i = 0;
 80132fe:	2300      	movs	r3, #0
 8013300:	61bb      	str	r3, [r7, #24]

    while ((ret == 0) && ((int)i < length)) {
 8013302:	e058      	b.n	80133b6 <GetASN_UTF8String+0xc8>
        int cnt;

        /* Check code points and get count of following bytes. */
        if ((input[idx + i] & 0x80) == 0x00) {
 8013304:	68ba      	ldr	r2, [r7, #8]
 8013306:	69bb      	ldr	r3, [r7, #24]
 8013308:	4413      	add	r3, r2
 801330a:	68fa      	ldr	r2, [r7, #12]
 801330c:	4413      	add	r3, r2
 801330e:	781b      	ldrb	r3, [r3, #0]
 8013310:	b25b      	sxtb	r3, r3
 8013312:	2b00      	cmp	r3, #0
 8013314:	db02      	blt.n	801331c <GetASN_UTF8String+0x2e>
            cnt = 0;
 8013316:	2300      	movs	r3, #0
 8013318:	617b      	str	r3, [r7, #20]
 801331a:	e02a      	b.n	8013372 <GetASN_UTF8String+0x84>
        }
        else if ((input[idx + i] & 0xe0) == 0xc0) {
 801331c:	68ba      	ldr	r2, [r7, #8]
 801331e:	69bb      	ldr	r3, [r7, #24]
 8013320:	4413      	add	r3, r2
 8013322:	68fa      	ldr	r2, [r7, #12]
 8013324:	4413      	add	r3, r2
 8013326:	781b      	ldrb	r3, [r3, #0]
 8013328:	f003 03e0 	and.w	r3, r3, #224	@ 0xe0
 801332c:	2bc0      	cmp	r3, #192	@ 0xc0
 801332e:	d102      	bne.n	8013336 <GetASN_UTF8String+0x48>
            cnt = 1;
 8013330:	2301      	movs	r3, #1
 8013332:	617b      	str	r3, [r7, #20]
 8013334:	e01d      	b.n	8013372 <GetASN_UTF8String+0x84>
        }
        else if ((input[idx + i] & 0xf0) == 0xe0) {
 8013336:	68ba      	ldr	r2, [r7, #8]
 8013338:	69bb      	ldr	r3, [r7, #24]
 801333a:	4413      	add	r3, r2
 801333c:	68fa      	ldr	r2, [r7, #12]
 801333e:	4413      	add	r3, r2
 8013340:	781b      	ldrb	r3, [r3, #0]
 8013342:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 8013346:	2be0      	cmp	r3, #224	@ 0xe0
 8013348:	d102      	bne.n	8013350 <GetASN_UTF8String+0x62>
            cnt = 2;
 801334a:	2302      	movs	r3, #2
 801334c:	617b      	str	r3, [r7, #20]
 801334e:	e010      	b.n	8013372 <GetASN_UTF8String+0x84>
        }
        else if ((input[idx + i] & 0xf8) == 0xf0) {
 8013350:	68ba      	ldr	r2, [r7, #8]
 8013352:	69bb      	ldr	r3, [r7, #24]
 8013354:	4413      	add	r3, r2
 8013356:	68fa      	ldr	r2, [r7, #12]
 8013358:	4413      	add	r3, r2
 801335a:	781b      	ldrb	r3, [r3, #0]
 801335c:	f003 03f8 	and.w	r3, r3, #248	@ 0xf8
 8013360:	2bf0      	cmp	r3, #240	@ 0xf0
 8013362:	d102      	bne.n	801336a <GetASN_UTF8String+0x7c>
            cnt = 3;
 8013364:	2303      	movs	r3, #3
 8013366:	617b      	str	r3, [r7, #20]
 8013368:	e003      	b.n	8013372 <GetASN_UTF8String+0x84>
        }
        else {
            WOLFSSL_MSG("Invalid character in UTF8STRING\n");
            ret = ASN_PARSE_E;
 801336a:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801336e:	61fb      	str	r3, [r7, #28]
            break;
 8013370:	e028      	b.n	80133c4 <GetASN_UTF8String+0xd6>
        }

        /* Have checked first byte. */
        i++;
 8013372:	69bb      	ldr	r3, [r7, #24]
 8013374:	3301      	adds	r3, #1
 8013376:	61bb      	str	r3, [r7, #24]
        /* Check each following byte. */
        for (; cnt > 0; cnt--) {
 8013378:	e01a      	b.n	80133b0 <GetASN_UTF8String+0xc2>
            /* Check we have enough data. */
            if ((int)i == length) {
 801337a:	69bb      	ldr	r3, [r7, #24]
 801337c:	687a      	ldr	r2, [r7, #4]
 801337e:	429a      	cmp	r2, r3
 8013380:	d103      	bne.n	801338a <GetASN_UTF8String+0x9c>
                WOLFSSL_MSG("Missing character in UTF8STRING\n");
                ret = ASN_PARSE_E;
 8013382:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013386:	61fb      	str	r3, [r7, #28]
                break;
 8013388:	e015      	b.n	80133b6 <GetASN_UTF8String+0xc8>
            }
            /* Check following byte has top bit set. */
            if ((input[idx + i] & 0x80) != 0x80) {
 801338a:	68ba      	ldr	r2, [r7, #8]
 801338c:	69bb      	ldr	r3, [r7, #24]
 801338e:	4413      	add	r3, r2
 8013390:	68fa      	ldr	r2, [r7, #12]
 8013392:	4413      	add	r3, r2
 8013394:	781b      	ldrb	r3, [r3, #0]
 8013396:	b25b      	sxtb	r3, r3
 8013398:	2b00      	cmp	r3, #0
 801339a:	db03      	blt.n	80133a4 <GetASN_UTF8String+0xb6>
                WOLFSSL_MSG("Invalid character in UTF8STRING\n");
                ret = ASN_PARSE_E;
 801339c:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80133a0:	61fb      	str	r3, [r7, #28]
                break;
 80133a2:	e008      	b.n	80133b6 <GetASN_UTF8String+0xc8>
            }
            i++;
 80133a4:	69bb      	ldr	r3, [r7, #24]
 80133a6:	3301      	adds	r3, #1
 80133a8:	61bb      	str	r3, [r7, #24]
        for (; cnt > 0; cnt--) {
 80133aa:	697b      	ldr	r3, [r7, #20]
 80133ac:	3b01      	subs	r3, #1
 80133ae:	617b      	str	r3, [r7, #20]
 80133b0:	697b      	ldr	r3, [r7, #20]
 80133b2:	2b00      	cmp	r3, #0
 80133b4:	dce1      	bgt.n	801337a <GetASN_UTF8String+0x8c>
    while ((ret == 0) && ((int)i < length)) {
 80133b6:	69fb      	ldr	r3, [r7, #28]
 80133b8:	2b00      	cmp	r3, #0
 80133ba:	d103      	bne.n	80133c4 <GetASN_UTF8String+0xd6>
 80133bc:	69bb      	ldr	r3, [r7, #24]
 80133be:	687a      	ldr	r2, [r7, #4]
 80133c0:	429a      	cmp	r2, r3
 80133c2:	dc9f      	bgt.n	8013304 <GetASN_UTF8String+0x16>
        }
    }

    return ret;
 80133c4:	69fb      	ldr	r3, [r7, #28]
}
 80133c6:	4618      	mov	r0, r3
 80133c8:	3724      	adds	r7, #36	@ 0x24
 80133ca:	46bd      	mov	sp, r7
 80133cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80133d0:	4770      	bx	lr

080133d2 <GetASN_ObjectId>:
 * @param [in] length  Length of input data.
 * @return  0 on success.
 * @return  ASN_PARSE_E when data is invalid.
 */
static int GetASN_ObjectId(const byte* input, word32 idx, int length)
{
 80133d2:	b480      	push	{r7}
 80133d4:	b087      	sub	sp, #28
 80133d6:	af00      	add	r7, sp, #0
 80133d8:	60f8      	str	r0, [r7, #12]
 80133da:	60b9      	str	r1, [r7, #8]
 80133dc:	607a      	str	r2, [r7, #4]
    int ret = 0;
 80133de:	2300      	movs	r3, #0
 80133e0:	617b      	str	r3, [r7, #20]

    /* OID data must be at least 3 bytes. */
    if (length < 3) {
 80133e2:	687b      	ldr	r3, [r7, #4]
 80133e4:	2b02      	cmp	r3, #2
 80133e6:	dc03      	bgt.n	80133f0 <GetASN_ObjectId+0x1e>
    #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
        WOLFSSL_MSG_VSNPRINTF("OID length must be 3 or more: %d", length);
    #else
        WOLFSSL_MSG("OID length less than 3");
    #endif
        ret = ASN_PARSE_E;
 80133e8:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80133ec:	617b      	str	r3, [r7, #20]
 80133ee:	e00c      	b.n	801340a <GetASN_ObjectId+0x38>
    }
    /* Last octet of a sub-identifier has bit 8 clear. Last octet must be last
     * of a subidentifier. Ensure last octet hasn't got top bit set.
     */
    else if ((input[(int)idx + length - 1] & 0x80) == 0x80) {
 80133f0:	68ba      	ldr	r2, [r7, #8]
 80133f2:	687b      	ldr	r3, [r7, #4]
 80133f4:	4413      	add	r3, r2
 80133f6:	3b01      	subs	r3, #1
 80133f8:	68fa      	ldr	r2, [r7, #12]
 80133fa:	4413      	add	r3, r2
 80133fc:	781b      	ldrb	r3, [r3, #0]
 80133fe:	b25b      	sxtb	r3, r3
 8013400:	2b00      	cmp	r3, #0
 8013402:	da02      	bge.n	801340a <GetASN_ObjectId+0x38>
        WOLFSSL_MSG("OID last octet has top bit set");
        ret = ASN_PARSE_E;
 8013404:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013408:	617b      	str	r3, [r7, #20]
    }

    return ret;
 801340a:	697b      	ldr	r3, [r7, #20]
}
 801340c:	4618      	mov	r0, r3
 801340e:	371c      	adds	r7, #28
 8013410:	46bd      	mov	sp, r7
 8013412:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013416:	4770      	bx	lr

08013418 <GetASN_StoreData>:
 * @return  ASN_UNKNOWN_OID_E when the OID cannot be verified.
 */
static int GetASN_StoreData(const ASNItem* asn, ASNGetData* data,
                            const byte* input, word32 idx, int len,
                            int zeroPadded)
{
 8013418:	b590      	push	{r4, r7, lr}
 801341a:	b08b      	sub	sp, #44	@ 0x2c
 801341c:	af02      	add	r7, sp, #8
 801341e:	60f8      	str	r0, [r7, #12]
 8013420:	60b9      	str	r1, [r7, #8]
 8013422:	607a      	str	r2, [r7, #4]
 8013424:	603b      	str	r3, [r7, #0]
    int i;
    int err;

    /* Parse data based on data type to extract. */
    switch (data->dataType) {
 8013426:	68bb      	ldr	r3, [r7, #8]
 8013428:	7e1b      	ldrb	r3, [r3, #24]
 801342a:	2b0b      	cmp	r3, #11
 801342c:	f200 8162 	bhi.w	80136f4 <GetASN_StoreData+0x2dc>
 8013430:	a201      	add	r2, pc, #4	@ (adr r2, 8013438 <GetASN_StoreData+0x20>)
 8013432:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8013436:	bf00      	nop
 8013438:	08013637 	.word	0x08013637
 801343c:	08013469 	.word	0x08013469
 8013440:	08013485 	.word	0x08013485
 8013444:	080136f5 	.word	0x080136f5
 8013448:	080134e3 	.word	0x080134e3
 801344c:	0801353d 	.word	0x0801353d
 8013450:	0801356d 	.word	0x0801356d
 8013454:	080136f5 	.word	0x080136f5
 8013458:	0801359f 	.word	0x0801359f
 801345c:	080135b5 	.word	0x080135b5
 8013460:	0801359f 	.word	0x0801359f
 8013464:	080135e1 	.word	0x080135e1
        /* Parse a data into a number of specified bits. */
        case ASN_DATA_TYPE_WORD8:
            /* Check data is small enough to fit. */
            if (len != 1) {
 8013468:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801346a:	2b01      	cmp	r3, #1
 801346c:	d002      	beq.n	8013474 <GetASN_StoreData+0x5c>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG_VSNPRINTF("Expecting one byte: %d", len);
            #endif
                return ASN_PARSE_E;
 801346e:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013472:	e140      	b.n	80136f6 <GetASN_StoreData+0x2de>
            }
            /* Fill number with all of data. */
            *data->data.u8 = input[idx];
 8013474:	687a      	ldr	r2, [r7, #4]
 8013476:	683b      	ldr	r3, [r7, #0]
 8013478:	441a      	add	r2, r3
 801347a:	68bb      	ldr	r3, [r7, #8]
 801347c:	689b      	ldr	r3, [r3, #8]
 801347e:	7812      	ldrb	r2, [r2, #0]
 8013480:	701a      	strb	r2, [r3, #0]
            break;
 8013482:	e137      	b.n	80136f4 <GetASN_StoreData+0x2dc>
        case ASN_DATA_TYPE_WORD16:
            /* Check data is small enough to fit. */
            if (len == 0 || len > 2) {
 8013484:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013486:	2b00      	cmp	r3, #0
 8013488:	d002      	beq.n	8013490 <GetASN_StoreData+0x78>
 801348a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801348c:	2b02      	cmp	r3, #2
 801348e:	dd02      	ble.n	8013496 <GetASN_StoreData+0x7e>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG_VSNPRINTF("Expecting 1 or 2 bytes: %d", len);
            #endif
                return ASN_PARSE_E;
 8013490:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013494:	e12f      	b.n	80136f6 <GetASN_StoreData+0x2de>
            }
            /* Fill number with all of data. */
            *data->data.u16 = 0;
 8013496:	68bb      	ldr	r3, [r7, #8]
 8013498:	689b      	ldr	r3, [r3, #8]
 801349a:	2200      	movs	r2, #0
 801349c:	801a      	strh	r2, [r3, #0]
            for (i = 0; i < len; i++) {
 801349e:	2300      	movs	r3, #0
 80134a0:	61fb      	str	r3, [r7, #28]
 80134a2:	e019      	b.n	80134d8 <GetASN_StoreData+0xc0>
                *data->data.u16 = (word16)(*data->data.u16 << 8U);
 80134a4:	68bb      	ldr	r3, [r7, #8]
 80134a6:	689b      	ldr	r3, [r3, #8]
 80134a8:	881a      	ldrh	r2, [r3, #0]
 80134aa:	68bb      	ldr	r3, [r7, #8]
 80134ac:	689b      	ldr	r3, [r3, #8]
 80134ae:	0212      	lsls	r2, r2, #8
 80134b0:	b292      	uxth	r2, r2
 80134b2:	801a      	strh	r2, [r3, #0]
                *data->data.u16 = (word16)(*data->data.u16 | input[idx + (word32)i]);
 80134b4:	68bb      	ldr	r3, [r7, #8]
 80134b6:	689b      	ldr	r3, [r3, #8]
 80134b8:	881a      	ldrh	r2, [r3, #0]
 80134ba:	69f9      	ldr	r1, [r7, #28]
 80134bc:	683b      	ldr	r3, [r7, #0]
 80134be:	440b      	add	r3, r1
 80134c0:	6879      	ldr	r1, [r7, #4]
 80134c2:	440b      	add	r3, r1
 80134c4:	781b      	ldrb	r3, [r3, #0]
 80134c6:	4619      	mov	r1, r3
 80134c8:	68bb      	ldr	r3, [r7, #8]
 80134ca:	689b      	ldr	r3, [r3, #8]
 80134cc:	430a      	orrs	r2, r1
 80134ce:	b292      	uxth	r2, r2
 80134d0:	801a      	strh	r2, [r3, #0]
            for (i = 0; i < len; i++) {
 80134d2:	69fb      	ldr	r3, [r7, #28]
 80134d4:	3301      	adds	r3, #1
 80134d6:	61fb      	str	r3, [r7, #28]
 80134d8:	69fa      	ldr	r2, [r7, #28]
 80134da:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80134dc:	429a      	cmp	r2, r3
 80134de:	dbe1      	blt.n	80134a4 <GetASN_StoreData+0x8c>
            }
            break;
 80134e0:	e108      	b.n	80136f4 <GetASN_StoreData+0x2dc>
        case ASN_DATA_TYPE_WORD32:
            /* Check data is small enough to fit. */
            if (len == 0 || len > 4) {
 80134e2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80134e4:	2b00      	cmp	r3, #0
 80134e6:	d002      	beq.n	80134ee <GetASN_StoreData+0xd6>
 80134e8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80134ea:	2b04      	cmp	r3, #4
 80134ec:	dd02      	ble.n	80134f4 <GetASN_StoreData+0xdc>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG_VSNPRINTF("Expecting 1 to 4 bytes: %d", len);
            #endif
                return ASN_PARSE_E;
 80134ee:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80134f2:	e100      	b.n	80136f6 <GetASN_StoreData+0x2de>
            }
            /* Fill number with all of data. */
            *data->data.u32 = 0;
 80134f4:	68bb      	ldr	r3, [r7, #8]
 80134f6:	689b      	ldr	r3, [r3, #8]
 80134f8:	2200      	movs	r2, #0
 80134fa:	601a      	str	r2, [r3, #0]
            for (i = 0; i < len; i++) {
 80134fc:	2300      	movs	r3, #0
 80134fe:	61fb      	str	r3, [r7, #28]
 8013500:	e017      	b.n	8013532 <GetASN_StoreData+0x11a>
                *data->data.u32 <<= 8;
 8013502:	68bb      	ldr	r3, [r7, #8]
 8013504:	689b      	ldr	r3, [r3, #8]
 8013506:	681a      	ldr	r2, [r3, #0]
 8013508:	68bb      	ldr	r3, [r7, #8]
 801350a:	689b      	ldr	r3, [r3, #8]
 801350c:	0212      	lsls	r2, r2, #8
 801350e:	601a      	str	r2, [r3, #0]
                *data->data.u32 |= input[idx + (word32)i] ;
 8013510:	68bb      	ldr	r3, [r7, #8]
 8013512:	689b      	ldr	r3, [r3, #8]
 8013514:	681a      	ldr	r2, [r3, #0]
 8013516:	69f9      	ldr	r1, [r7, #28]
 8013518:	683b      	ldr	r3, [r7, #0]
 801351a:	440b      	add	r3, r1
 801351c:	6879      	ldr	r1, [r7, #4]
 801351e:	440b      	add	r3, r1
 8013520:	781b      	ldrb	r3, [r3, #0]
 8013522:	4619      	mov	r1, r3
 8013524:	68bb      	ldr	r3, [r7, #8]
 8013526:	689b      	ldr	r3, [r3, #8]
 8013528:	430a      	orrs	r2, r1
 801352a:	601a      	str	r2, [r3, #0]
            for (i = 0; i < len; i++) {
 801352c:	69fb      	ldr	r3, [r7, #28]
 801352e:	3301      	adds	r3, #1
 8013530:	61fb      	str	r3, [r7, #28]
 8013532:	69fa      	ldr	r2, [r7, #28]
 8013534:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013536:	429a      	cmp	r2, r3
 8013538:	dbe3      	blt.n	8013502 <GetASN_StoreData+0xea>
            }
            break;
 801353a:	e0db      	b.n	80136f4 <GetASN_StoreData+0x2dc>

        case ASN_DATA_TYPE_BUFFER:
            /* Check buffer is big enough to hold data. */
            if (len > (int)*data->data.buffer.length) {
 801353c:	68bb      	ldr	r3, [r7, #8]
 801353e:	68db      	ldr	r3, [r3, #12]
 8013540:	681b      	ldr	r3, [r3, #0]
 8013542:	461a      	mov	r2, r3
 8013544:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013546:	4293      	cmp	r3, r2
 8013548:	dd02      	ble.n	8013550 <GetASN_StoreData+0x138>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG_VSNPRINTF("Buffer too small for data: %d %d", len,
                        *data->data.buffer.length);
            #endif
                return ASN_PARSE_E;
 801354a:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801354e:	e0d2      	b.n	80136f6 <GetASN_StoreData+0x2de>
            }
            /* Copy in data and record actual length seen. */
            XMEMCPY(data->data.buffer.data, input + idx, (size_t)len);
 8013550:	68bb      	ldr	r3, [r7, #8]
 8013552:	6898      	ldr	r0, [r3, #8]
 8013554:	687a      	ldr	r2, [r7, #4]
 8013556:	683b      	ldr	r3, [r7, #0]
 8013558:	4413      	add	r3, r2
 801355a:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801355c:	4619      	mov	r1, r3
 801355e:	f015 f81d 	bl	802859c <memcpy>
            *data->data.buffer.length = (word32)len;
 8013562:	68bb      	ldr	r3, [r7, #8]
 8013564:	68db      	ldr	r3, [r3, #12]
 8013566:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8013568:	601a      	str	r2, [r3, #0]
            break;
 801356a:	e0c3      	b.n	80136f4 <GetASN_StoreData+0x2dc>

        case ASN_DATA_TYPE_EXP_BUFFER:
            /* Check data is same size expected. */
            if (len != (int)data->data.ref.length) {
 801356c:	68bb      	ldr	r3, [r7, #8]
 801356e:	68db      	ldr	r3, [r3, #12]
 8013570:	461a      	mov	r2, r3
 8013572:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013574:	4293      	cmp	r3, r2
 8013576:	d002      	beq.n	801357e <GetASN_StoreData+0x166>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG_VSNPRINTF("Data not expected length: %d %d", len,
                        data->data.ref.length);
            #endif
                return ASN_PARSE_E;
 8013578:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801357c:	e0bb      	b.n	80136f6 <GetASN_StoreData+0x2de>
            }
            /* Check data is same as expected. */
            if (XMEMCMP(data->data.ref.data, input + idx, (size_t)len) != 0) {
 801357e:	68bb      	ldr	r3, [r7, #8]
 8013580:	6898      	ldr	r0, [r3, #8]
 8013582:	687a      	ldr	r2, [r7, #4]
 8013584:	683b      	ldr	r3, [r7, #0]
 8013586:	4413      	add	r3, r2
 8013588:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801358a:	4619      	mov	r1, r3
 801358c:	f014 ff72 	bl	8028474 <memcmp>
 8013590:	4603      	mov	r3, r0
 8013592:	2b00      	cmp	r3, #0
 8013594:	f000 80a9 	beq.w	80136ea <GetASN_StoreData+0x2d2>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG("Data not as expected");
            #endif
                return ASN_PARSE_E;
 8013598:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801359c:	e0ab      	b.n	80136f6 <GetASN_StoreData+0x2de>
            break;

        case ASN_DATA_TYPE_MP:
        case ASN_DATA_TYPE_MP_POS_NEG:
            /* Initialize mp_int and read in big-endian byte array. */
            if (mp_init(data->data.mp) != MP_OKAY) {
 801359e:	68bb      	ldr	r3, [r7, #8]
 80135a0:	689b      	ldr	r3, [r3, #8]
 80135a2:	4618      	mov	r0, r3
 80135a4:	f013 f875 	bl	8026692 <mp_init>
 80135a8:	4603      	mov	r3, r0
 80135aa:	2b00      	cmp	r3, #0
 80135ac:	d002      	beq.n	80135b4 <GetASN_StoreData+0x19c>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG_VSNPRINTF("Failed to init mp: %p", data->data.mp);
            #endif
                return MP_INIT_E;
 80135ae:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 80135b2:	e0a0      	b.n	80136f6 <GetASN_StoreData+0x2de>
            }
            FALL_THROUGH;
        case ASN_DATA_TYPE_MP_INITED:
            err = mp_read_unsigned_bin(data->data.mp, (byte*)input + idx,
 80135b4:	68bb      	ldr	r3, [r7, #8]
 80135b6:	6898      	ldr	r0, [r3, #8]
 80135b8:	687a      	ldr	r2, [r7, #4]
 80135ba:	683b      	ldr	r3, [r7, #0]
 80135bc:	4413      	add	r3, r2
 80135be:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80135c0:	4619      	mov	r1, r3
 80135c2:	f013 fa3f 	bl	8026a44 <mp_read_unsigned_bin>
 80135c6:	61b8      	str	r0, [r7, #24]
                                       (word32)len);
            if (err != 0) {
 80135c8:	69bb      	ldr	r3, [r7, #24]
 80135ca:	2b00      	cmp	r3, #0
 80135cc:	f000 808f 	beq.w	80136ee <GetASN_StoreData+0x2d6>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG_VSNPRINTF("Failed to read mp: %d", err);
            #endif
                mp_clear(data->data.mp);
 80135d0:	68bb      	ldr	r3, [r7, #8]
 80135d2:	689b      	ldr	r3, [r3, #8]
 80135d4:	4618      	mov	r0, r3
 80135d6:	f013 f8e6 	bl	80267a6 <mp_clear>
                return ASN_GETINT_E;
 80135da:	f06f 038d 	mvn.w	r3, #141	@ 0x8d
 80135de:	e08a      	b.n	80136f6 <GetASN_StoreData+0x2de>
        #endif
            break;

        case ASN_DATA_TYPE_CHOICE:
            /* Check if tag matched any of the choices specified. */
            for (i = 0; data->data.choice[i] != 0; i++)
 80135e0:	2300      	movs	r3, #0
 80135e2:	61fb      	str	r3, [r7, #28]
 80135e4:	e00b      	b.n	80135fe <GetASN_StoreData+0x1e6>
                if (data->data.choice[i] == data->tag)
 80135e6:	68bb      	ldr	r3, [r7, #8]
 80135e8:	689a      	ldr	r2, [r3, #8]
 80135ea:	69fb      	ldr	r3, [r7, #28]
 80135ec:	4413      	add	r3, r2
 80135ee:	781a      	ldrb	r2, [r3, #0]
 80135f0:	68bb      	ldr	r3, [r7, #8]
 80135f2:	7e5b      	ldrb	r3, [r3, #25]
 80135f4:	429a      	cmp	r2, r3
 80135f6:	d00a      	beq.n	801360e <GetASN_StoreData+0x1f6>
            for (i = 0; data->data.choice[i] != 0; i++)
 80135f8:	69fb      	ldr	r3, [r7, #28]
 80135fa:	3301      	adds	r3, #1
 80135fc:	61fb      	str	r3, [r7, #28]
 80135fe:	68bb      	ldr	r3, [r7, #8]
 8013600:	689a      	ldr	r2, [r3, #8]
 8013602:	69fb      	ldr	r3, [r7, #28]
 8013604:	4413      	add	r3, r2
 8013606:	781b      	ldrb	r3, [r3, #0]
 8013608:	2b00      	cmp	r3, #0
 801360a:	d1ec      	bne.n	80135e6 <GetASN_StoreData+0x1ce>
 801360c:	e000      	b.n	8013610 <GetASN_StoreData+0x1f8>
                    break;
 801360e:	bf00      	nop
            if (data->data.choice[i] == 0) {
 8013610:	68bb      	ldr	r3, [r7, #8]
 8013612:	689a      	ldr	r2, [r3, #8]
 8013614:	69fb      	ldr	r3, [r7, #28]
 8013616:	4413      	add	r3, r2
 8013618:	781b      	ldrb	r3, [r3, #0]
 801361a:	2b00      	cmp	r3, #0
 801361c:	d102      	bne.n	8013624 <GetASN_StoreData+0x20c>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG("Tag didn't match a choice");
            #endif
                return ASN_PARSE_E;
 801361e:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013622:	e068      	b.n	80136f6 <GetASN_StoreData+0x2de>
            }

            /* Store data pointer and length for caller. */
            data->data.ref.data = input + idx;
 8013624:	687a      	ldr	r2, [r7, #4]
 8013626:	683b      	ldr	r3, [r7, #0]
 8013628:	441a      	add	r2, r3
 801362a:	68bb      	ldr	r3, [r7, #8]
 801362c:	609a      	str	r2, [r3, #8]
            data->data.ref.length = (word32)len;
 801362e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8013630:	68bb      	ldr	r3, [r7, #8]
 8013632:	60da      	str	r2, [r3, #12]
            break;
 8013634:	e05e      	b.n	80136f4 <GetASN_StoreData+0x2dc>

        case ASN_DATA_TYPE_NONE:
            /* Default behaviour based on tag. */
            if (asn->tag == ASN_BOOLEAN) {
 8013636:	68fb      	ldr	r3, [r7, #12]
 8013638:	785b      	ldrb	r3, [r3, #1]
 801363a:	2b01      	cmp	r3, #1
 801363c:	d119      	bne.n	8013672 <GetASN_StoreData+0x25a>
                /* BOOLEAN has only one byte of data in BER. */
                if (len != 1) {
 801363e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013640:	2b01      	cmp	r3, #1
 8013642:	d002      	beq.n	801364a <GetASN_StoreData+0x232>
                #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                    WOLFSSL_MSG_VSNPRINTF("BOOLEAN length too long: %d", len);
                #endif
                    return ASN_PARSE_E;
 8013644:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013648:	e055      	b.n	80136f6 <GetASN_StoreData+0x2de>
                }
                if (data->data.u8 == NULL)
 801364a:	68bb      	ldr	r3, [r7, #8]
 801364c:	689b      	ldr	r3, [r3, #8]
 801364e:	2b00      	cmp	r3, #0
 8013650:	d102      	bne.n	8013658 <GetASN_StoreData+0x240>
                    return BAD_STATE_E;
 8013652:	f06f 03bf 	mvn.w	r3, #191	@ 0xbf
 8013656:	e04e      	b.n	80136f6 <GetASN_StoreData+0x2de>
                /* Store C boolean value. */
                *data->data.u8 = (input[idx] != 0);
 8013658:	687a      	ldr	r2, [r7, #4]
 801365a:	683b      	ldr	r3, [r7, #0]
 801365c:	4413      	add	r3, r2
 801365e:	781b      	ldrb	r3, [r3, #0]
 8013660:	2b00      	cmp	r3, #0
 8013662:	bf14      	ite	ne
 8013664:	2301      	movne	r3, #1
 8013666:	2300      	moveq	r3, #0
 8013668:	b2da      	uxtb	r2, r3
 801366a:	68bb      	ldr	r3, [r7, #8]
 801366c:	689b      	ldr	r3, [r3, #8]
 801366e:	701a      	strb	r2, [r3, #0]
                break;
 8013670:	e040      	b.n	80136f4 <GetASN_StoreData+0x2dc>
            }
            if (asn->tag == ASN_TAG_NULL) {
 8013672:	68fb      	ldr	r3, [r7, #12]
 8013674:	785b      	ldrb	r3, [r3, #1]
 8013676:	2b05      	cmp	r3, #5
 8013678:	d10b      	bne.n	8013692 <GetASN_StoreData+0x27a>
                /* NULL has no data in BER. */
                if (len != 0) {
 801367a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801367c:	2b00      	cmp	r3, #0
 801367e:	d002      	beq.n	8013686 <GetASN_StoreData+0x26e>
                #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                    WOLFSSL_MSG_VSNPRINTF("NULL length too long: %d", len);
                #endif
                    return ASN_EXPECT_0_E;
 8013680:	f06f 0391 	mvn.w	r3, #145	@ 0x91
 8013684:	e037      	b.n	80136f6 <GetASN_StoreData+0x2de>
                }
                data->data.ref.data = input + idx;
 8013686:	687a      	ldr	r2, [r7, #4]
 8013688:	683b      	ldr	r3, [r7, #0]
 801368a:	441a      	add	r2, r3
 801368c:	68bb      	ldr	r3, [r7, #8]
 801368e:	609a      	str	r2, [r3, #8]
                break;
 8013690:	e030      	b.n	80136f4 <GetASN_StoreData+0x2dc>
            }
            if (asn->tag == ASN_OBJECT_ID) {
 8013692:	68fb      	ldr	r3, [r7, #12]
 8013694:	785b      	ldrb	r3, [r3, #1]
 8013696:	2b06      	cmp	r3, #6
 8013698:	d11e      	bne.n	80136d8 <GetASN_StoreData+0x2c0>
                word32 oidIdx = 0;
 801369a:	2300      	movs	r3, #0
 801369c:	617b      	str	r3, [r7, #20]
                /* Store OID data pointer and length */
                data->data.oid.data = input + idx;
 801369e:	687a      	ldr	r2, [r7, #4]
 80136a0:	683b      	ldr	r3, [r7, #0]
 80136a2:	441a      	add	r2, r3
 80136a4:	68bb      	ldr	r3, [r7, #8]
 80136a6:	609a      	str	r2, [r3, #8]
                data->data.oid.length = (word32)len;
 80136a8:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80136aa:	68bb      	ldr	r3, [r7, #8]
 80136ac:	60da      	str	r2, [r3, #12]
                /* Get the OID sum. */
                err = GetOID(input + idx, &oidIdx, &data->data.oid.sum,
 80136ae:	687a      	ldr	r2, [r7, #4]
 80136b0:	683b      	ldr	r3, [r7, #0]
 80136b2:	18d0      	adds	r0, r2, r3
 80136b4:	68bb      	ldr	r3, [r7, #8]
 80136b6:	f103 0214 	add.w	r2, r3, #20
 80136ba:	68bb      	ldr	r3, [r7, #8]
 80136bc:	691c      	ldr	r4, [r3, #16]
 80136be:	f107 0114 	add.w	r1, r7, #20
 80136c2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80136c4:	9300      	str	r3, [sp, #0]
 80136c6:	4623      	mov	r3, r4
 80136c8:	f001 f812 	bl	80146f0 <GetOID>
 80136cc:	61b8      	str	r0, [r7, #24]
                        data->data.oid.type, len);
                if (err < 0) {
 80136ce:	69bb      	ldr	r3, [r7, #24]
 80136d0:	2b00      	cmp	r3, #0
 80136d2:	da0e      	bge.n	80136f2 <GetASN_StoreData+0x2da>
                #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                    WOLFSSL_MSG_VSNPRINTF("OID check failed: %d", err);
                #endif
                    return err;
 80136d4:	69bb      	ldr	r3, [r7, #24]
 80136d6:	e00e      	b.n	80136f6 <GetASN_StoreData+0x2de>
                }
                break;
            }

            /* Otherwise store data pointer and length. */
            data->data.ref.data = input + idx;
 80136d8:	687a      	ldr	r2, [r7, #4]
 80136da:	683b      	ldr	r3, [r7, #0]
 80136dc:	441a      	add	r2, r3
 80136de:	68bb      	ldr	r3, [r7, #8]
 80136e0:	609a      	str	r2, [r3, #8]
            data->data.ref.length = (word32)len;
 80136e2:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80136e4:	68bb      	ldr	r3, [r7, #8]
 80136e6:	60da      	str	r2, [r3, #12]
            break;
 80136e8:	e004      	b.n	80136f4 <GetASN_StoreData+0x2dc>
            break;
 80136ea:	bf00      	nop
 80136ec:	e002      	b.n	80136f4 <GetASN_StoreData+0x2dc>
            break;
 80136ee:	bf00      	nop
 80136f0:	e000      	b.n	80136f4 <GetASN_StoreData+0x2dc>
                break;
 80136f2:	bf00      	nop
        #endif
            return BAD_STATE_E;
    #endif
    }

    return 0;
 80136f4:	2300      	movs	r3, #0
}
 80136f6:	4618      	mov	r0, r3
 80136f8:	3724      	adds	r7, #36	@ 0x24
 80136fa:	46bd      	mov	sp, r7
 80136fc:	bd90      	pop	{r4, r7, pc}
 80136fe:	bf00      	nop

08013700 <GetASN_Items>:
 * @return  BAD_STATE_E when the data type is not supported.
 * @return  ASN_UNKNOWN_OID_E when the OID cannot be verified.
 */
int GetASN_Items(const ASNItem* asn, ASNGetData *data, int count, int complete,
                 const byte* input, word32* inOutIdx, word32 length)
{
 8013700:	b590      	push	{r4, r7, lr}
 8013702:	b09b      	sub	sp, #108	@ 0x6c
 8013704:	af02      	add	r7, sp, #8
 8013706:	60f8      	str	r0, [r7, #12]
 8013708:	60b9      	str	r1, [r7, #8]
 801370a:	607a      	str	r2, [r7, #4]
 801370c:	603b      	str	r3, [r7, #0]
    int    i;
    int    j;
    int    err;
    int    len;
    /* Current index into buffer. */
    word32 idx = *inOutIdx;
 801370e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8013710:	681b      	ldr	r3, [r3, #0]
 8013712:	633b      	str	r3, [r7, #48]	@ 0x30
    /* Declare the end index array. */
    word32 endIdx[GET_ASN_MAX_DEPTH];
    /* Set choices to -1 to indicate they haven't been seen or found. */
    signed char   choiceMet[GET_ASN_MAX_CHOICES] = { -1, -1 };
 8013714:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 8013718:	823b      	strh	r3, [r7, #16]
    /* Not matching a choice right now. */
    int    choice = 0;
 801371a:	2300      	movs	r3, #0
 801371c:	657b      	str	r3, [r7, #84]	@ 0x54
#ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
    WOLFSSL_ENTER("GetASN_Items");
#endif

    /* Set the end index at each depth to be the length. */
    for (i=0; i<GET_ASN_MAX_DEPTH; i++) {
 801371e:	2300      	movs	r3, #0
 8013720:	65fb      	str	r3, [r7, #92]	@ 0x5c
 8013722:	e009      	b.n	8013738 <GetASN_Items+0x38>
        endIdx[i] = length;
 8013724:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013726:	009b      	lsls	r3, r3, #2
 8013728:	3360      	adds	r3, #96	@ 0x60
 801372a:	443b      	add	r3, r7
 801372c:	6fba      	ldr	r2, [r7, #120]	@ 0x78
 801372e:	f843 2c4c 	str.w	r2, [r3, #-76]
    for (i=0; i<GET_ASN_MAX_DEPTH; i++) {
 8013732:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013734:	3301      	adds	r3, #1
 8013736:	65fb      	str	r3, [r7, #92]	@ 0x5c
 8013738:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801373a:	2b06      	cmp	r3, #6
 801373c:	ddf2      	ble.n	8013724 <GetASN_Items+0x24>
    }

    /* Start depth at first items depth. */
    minDepth = depth = asn[0].depth;
 801373e:	68fb      	ldr	r3, [r7, #12]
 8013740:	781b      	ldrb	r3, [r3, #0]
 8013742:	653b      	str	r3, [r7, #80]	@ 0x50
 8013744:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8013746:	64fb      	str	r3, [r7, #76]	@ 0x4c
    /* Check every ASN.1 item. */
    for (i = 0; i < count; i++) {
 8013748:	2300      	movs	r3, #0
 801374a:	65fb      	str	r3, [r7, #92]	@ 0x5c
 801374c:	e245      	b.n	8013bda <GetASN_Items+0x4da>
        /* Store offset of ASN.1 item. */
        data[i].offset = idx;
 801374e:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8013750:	4613      	mov	r3, r2
 8013752:	00db      	lsls	r3, r3, #3
 8013754:	1a9b      	subs	r3, r3, r2
 8013756:	009b      	lsls	r3, r3, #2
 8013758:	461a      	mov	r2, r3
 801375a:	68bb      	ldr	r3, [r7, #8]
 801375c:	4413      	add	r3, r2
 801375e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8013760:	601a      	str	r2, [r3, #0]
        /* Length of data in ASN.1 item starts empty. */
        data[i].length = 0;
 8013762:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8013764:	4613      	mov	r3, r2
 8013766:	00db      	lsls	r3, r3, #3
 8013768:	1a9b      	subs	r3, r3, r2
 801376a:	009b      	lsls	r3, r3, #2
 801376c:	461a      	mov	r2, r3
 801376e:	68bb      	ldr	r3, [r7, #8]
 8013770:	4413      	add	r3, r2
 8013772:	2200      	movs	r2, #0
 8013774:	605a      	str	r2, [r3, #4]
        /* Get current item depth. */
        depth = asn[i].depth;
 8013776:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013778:	009b      	lsls	r3, r3, #2
 801377a:	68fa      	ldr	r2, [r7, #12]
 801377c:	4413      	add	r3, r2
 801377e:	781b      	ldrb	r3, [r3, #0]
 8013780:	653b      	str	r3, [r7, #80]	@ 0x50
            WOLFSSL_MSG("Depth in template too large");
            return ASN_PARSE_E;
        }
    #endif
        /* Keep track of minimum depth. */
        if (depth < minDepth) {
 8013782:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 8013784:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8013786:	429a      	cmp	r2, r3
 8013788:	da01      	bge.n	801378e <GetASN_Items+0x8e>
            minDepth = depth;
 801378a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801378c:	64fb      	str	r3, [r7, #76]	@ 0x4c
        }

        /* Reset choice if different from previous. */
        if (choice > 0 && asn[i].optional != choice) {
 801378e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8013790:	2b00      	cmp	r3, #0
 8013792:	dd0a      	ble.n	80137aa <GetASN_Items+0xaa>
 8013794:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013796:	009b      	lsls	r3, r3, #2
 8013798:	68fa      	ldr	r2, [r7, #12]
 801379a:	4413      	add	r3, r2
 801379c:	78db      	ldrb	r3, [r3, #3]
 801379e:	461a      	mov	r2, r3
 80137a0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80137a2:	4293      	cmp	r3, r2
 80137a4:	d001      	beq.n	80137aa <GetASN_Items+0xaa>
            choice = 0;
 80137a6:	2300      	movs	r3, #0
 80137a8:	657b      	str	r3, [r7, #84]	@ 0x54
        }
        /* Check if first of numbered choice. */
        if (choice == 0 && asn[i].optional > 1) {
 80137aa:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80137ac:	2b00      	cmp	r3, #0
 80137ae:	d122      	bne.n	80137f6 <GetASN_Items+0xf6>
 80137b0:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80137b2:	009b      	lsls	r3, r3, #2
 80137b4:	68fa      	ldr	r2, [r7, #12]
 80137b6:	4413      	add	r3, r2
 80137b8:	78db      	ldrb	r3, [r3, #3]
 80137ba:	2b01      	cmp	r3, #1
 80137bc:	d91b      	bls.n	80137f6 <GetASN_Items+0xf6>
            choice = asn[i].optional;
 80137be:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80137c0:	009b      	lsls	r3, r3, #2
 80137c2:	68fa      	ldr	r2, [r7, #12]
 80137c4:	4413      	add	r3, r2
 80137c6:	78db      	ldrb	r3, [r3, #3]
 80137c8:	657b      	str	r3, [r7, #84]	@ 0x54
            tmpScharVal = choiceMet[choice - 2];
 80137ca:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80137cc:	3b02      	subs	r3, #2
 80137ce:	3360      	adds	r3, #96	@ 0x60
 80137d0:	443b      	add	r3, r7
 80137d2:	f813 3c50 	ldrb.w	r3, [r3, #-80]
 80137d6:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
            XFENCE(); /* Prevent memory access */
 80137da:	f3bf 8f5b 	dmb	ish
            if (tmpScharVal == -1) {
 80137de:	f997 3047 	ldrsb.w	r3, [r7, #71]	@ 0x47
 80137e2:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 80137e6:	d106      	bne.n	80137f6 <GetASN_Items+0xf6>
                /* Choice seen but not found a match yet. */
                choiceMet[choice - 2] = 0;
 80137e8:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80137ea:	3b02      	subs	r3, #2
 80137ec:	3360      	adds	r3, #96	@ 0x60
 80137ee:	443b      	add	r3, r7
 80137f0:	2200      	movs	r2, #0
 80137f2:	f803 2c50 	strb.w	r2, [r3, #-80]
            }
        }

        /* Check for end of data or not a choice and tag not matching. */
        tmpW32Val = endIdx[depth];
 80137f6:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80137f8:	009b      	lsls	r3, r3, #2
 80137fa:	3360      	adds	r3, #96	@ 0x60
 80137fc:	443b      	add	r3, r7
 80137fe:	f853 3c4c 	ldr.w	r3, [r3, #-76]
 8013802:	643b      	str	r3, [r7, #64]	@ 0x40
        XFENCE(); /* Prevent memory access */
 8013804:	f3bf 8f5b 	dmb	ish
        if (idx == tmpW32Val || (data[i].dataType != ASN_DATA_TYPE_CHOICE &&
 8013808:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801380a:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 801380c:	429a      	cmp	r2, r3
 801380e:	d017      	beq.n	8013840 <GetASN_Items+0x140>
 8013810:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8013812:	4613      	mov	r3, r2
 8013814:	00db      	lsls	r3, r3, #3
 8013816:	1a9b      	subs	r3, r3, r2
 8013818:	009b      	lsls	r3, r3, #2
 801381a:	461a      	mov	r2, r3
 801381c:	68bb      	ldr	r3, [r7, #8]
 801381e:	4413      	add	r3, r2
 8013820:	7e1b      	ldrb	r3, [r3, #24]
 8013822:	2b0b      	cmp	r3, #11
 8013824:	d06e      	beq.n	8013904 <GetASN_Items+0x204>
                              (input[idx] & ~ASN_CONSTRUCTED) != asn[i].tag)) {
 8013826:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013828:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 801382a:	4413      	add	r3, r2
 801382c:	781b      	ldrb	r3, [r3, #0]
 801382e:	f023 0320 	bic.w	r3, r3, #32
 8013832:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8013834:	0092      	lsls	r2, r2, #2
 8013836:	68f9      	ldr	r1, [r7, #12]
 8013838:	440a      	add	r2, r1
 801383a:	7852      	ldrb	r2, [r2, #1]
        if (idx == tmpW32Val || (data[i].dataType != ASN_DATA_TYPE_CHOICE &&
 801383c:	4293      	cmp	r3, r2
 801383e:	d061      	beq.n	8013904 <GetASN_Items+0x204>
            if (asn[i].optional) {
 8013840:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013842:	009b      	lsls	r3, r3, #2
 8013844:	68fa      	ldr	r2, [r7, #12]
 8013846:	4413      	add	r3, r2
 8013848:	78db      	ldrb	r3, [r3, #3]
 801384a:	2b00      	cmp	r3, #0
 801384c:	d030      	beq.n	80138b0 <GetASN_Items+0x1b0>
                /* Skip over ASN.1 items underneath this optional item. */
                for (j = i + 1; j < count; j++) {
 801384e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013850:	3301      	adds	r3, #1
 8013852:	65bb      	str	r3, [r7, #88]	@ 0x58
 8013854:	e022      	b.n	801389c <GetASN_Items+0x19c>
                    if (asn[i].depth >= asn[j].depth)
 8013856:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013858:	009b      	lsls	r3, r3, #2
 801385a:	68fa      	ldr	r2, [r7, #12]
 801385c:	4413      	add	r3, r2
 801385e:	781a      	ldrb	r2, [r3, #0]
 8013860:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8013862:	009b      	lsls	r3, r3, #2
 8013864:	68f9      	ldr	r1, [r7, #12]
 8013866:	440b      	add	r3, r1
 8013868:	781b      	ldrb	r3, [r3, #0]
 801386a:	429a      	cmp	r2, r3
 801386c:	d21b      	bcs.n	80138a6 <GetASN_Items+0x1a6>
                        break;
                    data[j].offset = idx;
 801386e:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8013870:	4613      	mov	r3, r2
 8013872:	00db      	lsls	r3, r3, #3
 8013874:	1a9b      	subs	r3, r3, r2
 8013876:	009b      	lsls	r3, r3, #2
 8013878:	461a      	mov	r2, r3
 801387a:	68bb      	ldr	r3, [r7, #8]
 801387c:	4413      	add	r3, r2
 801387e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8013880:	601a      	str	r2, [r3, #0]
                    data[j].length = 0;
 8013882:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8013884:	4613      	mov	r3, r2
 8013886:	00db      	lsls	r3, r3, #3
 8013888:	1a9b      	subs	r3, r3, r2
 801388a:	009b      	lsls	r3, r3, #2
 801388c:	461a      	mov	r2, r3
 801388e:	68bb      	ldr	r3, [r7, #8]
 8013890:	4413      	add	r3, r2
 8013892:	2200      	movs	r2, #0
 8013894:	605a      	str	r2, [r3, #4]
                for (j = i + 1; j < count; j++) {
 8013896:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8013898:	3301      	adds	r3, #1
 801389a:	65bb      	str	r3, [r7, #88]	@ 0x58
 801389c:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 801389e:	687b      	ldr	r3, [r7, #4]
 80138a0:	429a      	cmp	r2, r3
 80138a2:	dbd8      	blt.n	8013856 <GetASN_Items+0x156>
 80138a4:	e000      	b.n	80138a8 <GetASN_Items+0x1a8>
                        break;
 80138a6:	bf00      	nop
                }
                i = j - 1;
 80138a8:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80138aa:	3b01      	subs	r3, #1
 80138ac:	65fb      	str	r3, [r7, #92]	@ 0x5c
                continue;
 80138ae:	e191      	b.n	8013bd4 <GetASN_Items+0x4d4>
            }

            /* Check for end of data. */
            if (idx == length) {
 80138b0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80138b2:	6fba      	ldr	r2, [r7, #120]	@ 0x78
 80138b4:	429a      	cmp	r2, r3
 80138b6:	d102      	bne.n	80138be <GetASN_Items+0x1be>
                    asn[i].constructed ? '+' : ' ', asn[i].depth, "",
                    TagString(asn[i].tag), 6 - asn[i].depth, "");
                WOLFSSL_MSG_VSNPRINTF("Index past end of data: %d %d", idx,
                        length);
        #endif
                return BUFFER_E;
 80138b8:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 80138bc:	e1c3      	b.n	8013c46 <GetASN_Items+0x546>
                asn[i].constructed ? '+' : ' ', asn[i].depth, "",
                TagString(asn[i].tag), 6 - asn[i].depth, "",
                input[idx], TagString(input[idx]));
        #endif
            /* Check for end of data at this depth. */
            if (idx == endIdx[depth]) {
 80138be:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80138c0:	009b      	lsls	r3, r3, #2
 80138c2:	3360      	adds	r3, #96	@ 0x60
 80138c4:	443b      	add	r3, r7
 80138c6:	f853 2c4c 	ldr.w	r2, [r3, #-76]
 80138ca:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80138cc:	429a      	cmp	r2, r3
 80138ce:	d102      	bne.n	80138d6 <GetASN_Items+0x1d6>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG_VSNPRINTF("Index past outer item: %d %d", idx,
                        endIdx[depth]);
            #endif
                return ASN_PARSE_E;
 80138d0:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80138d4:	e1b7      	b.n	8013c46 <GetASN_Items+0x546>
            }

            /* Expecting an OBJECT_ID */
            if (asn[i].tag == ASN_OBJECT_ID) {
 80138d6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80138d8:	009b      	lsls	r3, r3, #2
 80138da:	68fa      	ldr	r2, [r7, #12]
 80138dc:	4413      	add	r3, r2
 80138de:	785b      	ldrb	r3, [r3, #1]
 80138e0:	2b06      	cmp	r3, #6
 80138e2:	d102      	bne.n	80138ea <GetASN_Items+0x1ea>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG("Expecting OBJECT ID");
            #endif
                return ASN_OBJECT_ID_E;
 80138e4:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 80138e8:	e1ad      	b.n	8013c46 <GetASN_Items+0x546>
            }
            /* Expecting a BIT_STRING */
            if (asn[i].tag == ASN_BIT_STRING) {
 80138ea:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80138ec:	009b      	lsls	r3, r3, #2
 80138ee:	68fa      	ldr	r2, [r7, #12]
 80138f0:	4413      	add	r3, r2
 80138f2:	785b      	ldrb	r3, [r3, #1]
 80138f4:	2b03      	cmp	r3, #3
 80138f6:	d102      	bne.n	80138fe <GetASN_Items+0x1fe>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG("Expecting BIT STRING");
            #endif
                return ASN_BITSTR_E;
 80138f8:	f06f 0392 	mvn.w	r3, #146	@ 0x92
 80138fc:	e1a3      	b.n	8013c46 <GetASN_Items+0x546>
            }
            /* Not the expected tag. */
        #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
            WOLFSSL_MSG("Bad tag");
        #endif
            return ASN_PARSE_E;
 80138fe:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013902:	e1a0      	b.n	8013c46 <GetASN_Items+0x546>
        }

        /* Store found tag in data. */
        data[i].tag = input[idx];
 8013904:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013906:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 8013908:	18d1      	adds	r1, r2, r3
 801390a:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801390c:	4613      	mov	r3, r2
 801390e:	00db      	lsls	r3, r3, #3
 8013910:	1a9b      	subs	r3, r3, r2
 8013912:	009b      	lsls	r3, r3, #2
 8013914:	461a      	mov	r2, r3
 8013916:	68bb      	ldr	r3, [r7, #8]
 8013918:	4413      	add	r3, r2
 801391a:	780a      	ldrb	r2, [r1, #0]
 801391c:	765a      	strb	r2, [r3, #25]
        XFENCE(); /* Prevent memory access */
 801391e:	f3bf 8f5b 	dmb	ish
        if (data[i].dataType != ASN_DATA_TYPE_CHOICE) {
 8013922:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8013924:	4613      	mov	r3, r2
 8013926:	00db      	lsls	r3, r3, #3
 8013928:	1a9b      	subs	r3, r3, r2
 801392a:	009b      	lsls	r3, r3, #2
 801392c:	461a      	mov	r2, r3
 801392e:	68bb      	ldr	r3, [r7, #8]
 8013930:	4413      	add	r3, r2
 8013932:	7e1b      	ldrb	r3, [r3, #24]
 8013934:	2b0b      	cmp	r3, #11
 8013936:	d01a      	beq.n	801396e <GetASN_Items+0x26e>
            int constructed = (input[idx] & ASN_CONSTRUCTED) == ASN_CONSTRUCTED;
 8013938:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801393a:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 801393c:	4413      	add	r3, r2
 801393e:	781b      	ldrb	r3, [r3, #0]
 8013940:	f003 0320 	and.w	r3, r3, #32
 8013944:	2b00      	cmp	r3, #0
 8013946:	bf14      	ite	ne
 8013948:	2301      	movne	r3, #1
 801394a:	2300      	moveq	r3, #0
 801394c:	b2db      	uxtb	r3, r3
 801394e:	63fb      	str	r3, [r7, #60]	@ 0x3c
            /* Check constructed match expected for non-choice ASN.1 item. */
            if (asn[i].constructed != constructed) {
 8013950:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013952:	009b      	lsls	r3, r3, #2
 8013954:	68fa      	ldr	r2, [r7, #12]
 8013956:	4413      	add	r3, r2
 8013958:	789b      	ldrb	r3, [r3, #2]
 801395a:	f3c3 0300 	ubfx	r3, r3, #0, #1
 801395e:	b2db      	uxtb	r3, r3
 8013960:	461a      	mov	r2, r3
 8013962:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8013964:	4293      	cmp	r3, r2
 8013966:	d002      	beq.n	801396e <GetASN_Items+0x26e>
                }
                else {
                    WOLFSSL_MSG("Not expected to be constructed");
                }
            #endif
                return ASN_PARSE_E;
 8013968:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801396c:	e16b      	b.n	8013c46 <GetASN_Items+0x546>
            }
        }
        /* Move index to start of length. */
        idx++;
 801396e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013970:	3301      	adds	r3, #1
 8013972:	633b      	str	r3, [r7, #48]	@ 0x30
        /* Get the encoded length. */
        if (GetASN_Length(input, &idx, &len, endIdx[depth], 1) < 0) {
 8013974:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8013976:	009b      	lsls	r3, r3, #2
 8013978:	3360      	adds	r3, #96	@ 0x60
 801397a:	443b      	add	r3, r7
 801397c:	f853 3c4c 	ldr.w	r3, [r3, #-76]
 8013980:	f107 0234 	add.w	r2, r7, #52	@ 0x34
 8013984:	f107 0130 	add.w	r1, r7, #48	@ 0x30
 8013988:	2001      	movs	r0, #1
 801398a:	9000      	str	r0, [sp, #0]
 801398c:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801398e:	f000 f9c2 	bl	8013d16 <GetLength_ex>
 8013992:	4603      	mov	r3, r0
 8013994:	2b00      	cmp	r3, #0
 8013996:	da02      	bge.n	801399e <GetASN_Items+0x29e>
        #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
            WOLFSSL_MSG_VSNPRINTF("%2d: idx=%d len=%d end=%d", i, idx, len,
                    endIdx[depth]);
        #endif
            return ASN_PARSE_E;
 8013998:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801399c:	e153      	b.n	8013c46 <GetASN_Items+0x546>
        }
        /* Store length of data. */
        data[i].length = (word32)len;
 801399e:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 80139a0:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 80139a2:	4613      	mov	r3, r2
 80139a4:	00db      	lsls	r3, r3, #3
 80139a6:	1a9b      	subs	r3, r3, r2
 80139a8:	009b      	lsls	r3, r3, #2
 80139aa:	461a      	mov	r2, r3
 80139ac:	68bb      	ldr	r3, [r7, #8]
 80139ae:	4413      	add	r3, r2
 80139b0:	460a      	mov	r2, r1
 80139b2:	605a      	str	r2, [r3, #4]
        /* Note the max length of items under this one. */
        endIdx[depth + 1] = idx + (word32)len;
 80139b4:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80139b6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80139b8:	4619      	mov	r1, r3
 80139ba:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80139bc:	3301      	adds	r3, #1
 80139be:	440a      	add	r2, r1
 80139c0:	009b      	lsls	r3, r3, #2
 80139c2:	3360      	adds	r3, #96	@ 0x60
 80139c4:	443b      	add	r3, r7
 80139c6:	f843 2c4c 	str.w	r2, [r3, #-76]
        if (choice > 1) {
 80139ca:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80139cc:	2b01      	cmp	r3, #1
 80139ce:	dd06      	ble.n	80139de <GetASN_Items+0x2de>
            /* Note we found a number choice. */
            choiceMet[choice - 2] = 1;
 80139d0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80139d2:	3b02      	subs	r3, #2
 80139d4:	3360      	adds	r3, #96	@ 0x60
 80139d6:	443b      	add	r3, r7
 80139d8:	2201      	movs	r2, #1
 80139da:	f803 2c50 	strb.w	r2, [r3, #-80]
                data[i].offset, data[i].length, asn[i].constructed ? '+' : ' ',
                asn[i].depth, "", TagString(data[i].tag));
    #endif

        /* Assume no zero padding on INTEGER. */
        zeroPadded = 0;
 80139de:	2300      	movs	r3, #0
 80139e0:	64bb      	str	r3, [r7, #72]	@ 0x48
        /* Check data types that prepended a byte. */
        if (asn[i].tag == ASN_INTEGER) {
 80139e2:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80139e4:	009b      	lsls	r3, r3, #2
 80139e6:	68fa      	ldr	r2, [r7, #12]
 80139e8:	4413      	add	r3, r2
 80139ea:	785b      	ldrb	r3, [r3, #1]
 80139ec:	2b02      	cmp	r3, #2
 80139ee:	d136      	bne.n	8013a5e <GetASN_Items+0x35e>
            /* Check validity of first byte. */
            err = GetASN_Integer(input, idx, len,
 80139f0:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 80139f2:	6b78      	ldr	r0, [r7, #52]	@ 0x34
                    data[i].dataType == ASN_DATA_TYPE_MP ||
 80139f4:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 80139f6:	4613      	mov	r3, r2
 80139f8:	00db      	lsls	r3, r3, #3
 80139fa:	1a9b      	subs	r3, r3, r2
 80139fc:	009b      	lsls	r3, r3, #2
 80139fe:	461a      	mov	r2, r3
 8013a00:	68bb      	ldr	r3, [r7, #8]
 8013a02:	4413      	add	r3, r2
 8013a04:	7e1b      	ldrb	r3, [r3, #24]
            err = GetASN_Integer(input, idx, len,
 8013a06:	2b08      	cmp	r3, #8
 8013a08:	d00a      	beq.n	8013a20 <GetASN_Items+0x320>
                    data[i].dataType == ASN_DATA_TYPE_MP_INITED);
 8013a0a:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8013a0c:	4613      	mov	r3, r2
 8013a0e:	00db      	lsls	r3, r3, #3
 8013a10:	1a9b      	subs	r3, r3, r2
 8013a12:	009b      	lsls	r3, r3, #2
 8013a14:	461a      	mov	r2, r3
 8013a16:	68bb      	ldr	r3, [r7, #8]
 8013a18:	4413      	add	r3, r2
 8013a1a:	7e1b      	ldrb	r3, [r3, #24]
            err = GetASN_Integer(input, idx, len,
 8013a1c:	2b09      	cmp	r3, #9
 8013a1e:	d101      	bne.n	8013a24 <GetASN_Items+0x324>
 8013a20:	2301      	movs	r3, #1
 8013a22:	e000      	b.n	8013a26 <GetASN_Items+0x326>
 8013a24:	2300      	movs	r3, #0
 8013a26:	4602      	mov	r2, r0
 8013a28:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 8013a2a:	f7ff fbe5 	bl	80131f8 <GetASN_Integer>
 8013a2e:	63b8      	str	r0, [r7, #56]	@ 0x38
            if (err != 0)
 8013a30:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8013a32:	2b00      	cmp	r3, #0
 8013a34:	d001      	beq.n	8013a3a <GetASN_Items+0x33a>
                return err;
 8013a36:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8013a38:	e105      	b.n	8013c46 <GetASN_Items+0x546>
            if (len > 1 && input[idx] == 0) {
 8013a3a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8013a3c:	2b01      	cmp	r3, #1
 8013a3e:	dd59      	ble.n	8013af4 <GetASN_Items+0x3f4>
 8013a40:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013a42:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 8013a44:	4413      	add	r3, r2
 8013a46:	781b      	ldrb	r3, [r3, #0]
 8013a48:	2b00      	cmp	r3, #0
 8013a4a:	d153      	bne.n	8013af4 <GetASN_Items+0x3f4>
                zeroPadded = 1;
 8013a4c:	2301      	movs	r3, #1
 8013a4e:	64bb      	str	r3, [r7, #72]	@ 0x48
                /* Move over prepended byte. */
                idx++;
 8013a50:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013a52:	3301      	adds	r3, #1
 8013a54:	633b      	str	r3, [r7, #48]	@ 0x30
                len--;
 8013a56:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8013a58:	3b01      	subs	r3, #1
 8013a5a:	637b      	str	r3, [r7, #52]	@ 0x34
 8013a5c:	e04a      	b.n	8013af4 <GetASN_Items+0x3f4>
            }
        }
        else if (asn[i].tag == ASN_BIT_STRING) {
 8013a5e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013a60:	009b      	lsls	r3, r3, #2
 8013a62:	68fa      	ldr	r2, [r7, #12]
 8013a64:	4413      	add	r3, r2
 8013a66:	785b      	ldrb	r3, [r3, #1]
 8013a68:	2b03      	cmp	r3, #3
 8013a6a:	d112      	bne.n	8013a92 <GetASN_Items+0x392>
            /* Check prepended byte is correct. */
            err = GetASN_BitString(input, idx, len);
 8013a6c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013a6e:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8013a70:	4619      	mov	r1, r3
 8013a72:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 8013a74:	f7ff fc09 	bl	801328a <GetASN_BitString>
 8013a78:	63b8      	str	r0, [r7, #56]	@ 0x38
            if (err != 0)
 8013a7a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8013a7c:	2b00      	cmp	r3, #0
 8013a7e:	d001      	beq.n	8013a84 <GetASN_Items+0x384>
                return err;
 8013a80:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8013a82:	e0e0      	b.n	8013c46 <GetASN_Items+0x546>
            /* Move over prepended byte. */
            idx++;
 8013a84:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013a86:	3301      	adds	r3, #1
 8013a88:	633b      	str	r3, [r7, #48]	@ 0x30
            len--;
 8013a8a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8013a8c:	3b01      	subs	r3, #1
 8013a8e:	637b      	str	r3, [r7, #52]	@ 0x34
 8013a90:	e030      	b.n	8013af4 <GetASN_Items+0x3f4>
        }
    #ifndef WOLFSSL_NO_ASN_STRICT
        else if ((asn[i].tag == ASN_UTF8STRING) ||
 8013a92:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013a94:	009b      	lsls	r3, r3, #2
 8013a96:	68fa      	ldr	r2, [r7, #12]
 8013a98:	4413      	add	r3, r2
 8013a9a:	785b      	ldrb	r3, [r3, #1]
 8013a9c:	2b0c      	cmp	r3, #12
 8013a9e:	d00a      	beq.n	8013ab6 <GetASN_Items+0x3b6>
                 (data[i].tag == ASN_UTF8STRING)) {
 8013aa0:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8013aa2:	4613      	mov	r3, r2
 8013aa4:	00db      	lsls	r3, r3, #3
 8013aa6:	1a9b      	subs	r3, r3, r2
 8013aa8:	009b      	lsls	r3, r3, #2
 8013aaa:	461a      	mov	r2, r3
 8013aac:	68bb      	ldr	r3, [r7, #8]
 8013aae:	4413      	add	r3, r2
 8013ab0:	7e5b      	ldrb	r3, [r3, #25]
        else if ((asn[i].tag == ASN_UTF8STRING) ||
 8013ab2:	2b0c      	cmp	r3, #12
 8013ab4:	d10b      	bne.n	8013ace <GetASN_Items+0x3ce>
            /* Check validity of data. */
            err = GetASN_UTF8String(input, idx, len);
 8013ab6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013ab8:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8013aba:	4619      	mov	r1, r3
 8013abc:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 8013abe:	f7ff fc16 	bl	80132ee <GetASN_UTF8String>
 8013ac2:	63b8      	str	r0, [r7, #56]	@ 0x38
            if (err != 0)
 8013ac4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8013ac6:	2b00      	cmp	r3, #0
 8013ac8:	d014      	beq.n	8013af4 <GetASN_Items+0x3f4>
                return err;
 8013aca:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8013acc:	e0bb      	b.n	8013c46 <GetASN_Items+0x546>
        }
    #endif
        else if (asn[i].tag == ASN_OBJECT_ID) {
 8013ace:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013ad0:	009b      	lsls	r3, r3, #2
 8013ad2:	68fa      	ldr	r2, [r7, #12]
 8013ad4:	4413      	add	r3, r2
 8013ad6:	785b      	ldrb	r3, [r3, #1]
 8013ad8:	2b06      	cmp	r3, #6
 8013ada:	d10b      	bne.n	8013af4 <GetASN_Items+0x3f4>
            /* Check validity of data. */
            err = GetASN_ObjectId(input, idx, len);
 8013adc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013ade:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8013ae0:	4619      	mov	r1, r3
 8013ae2:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 8013ae4:	f7ff fc75 	bl	80133d2 <GetASN_ObjectId>
 8013ae8:	63b8      	str	r0, [r7, #56]	@ 0x38
            if (err != 0)
 8013aea:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8013aec:	2b00      	cmp	r3, #0
 8013aee:	d001      	beq.n	8013af4 <GetASN_Items+0x3f4>
                return err;
 8013af0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8013af2:	e0a8      	b.n	8013c46 <GetASN_Items+0x546>
        }

        /* Don't parse data if only header required. */
        if (asn[i].headerOnly) {
 8013af4:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013af6:	009b      	lsls	r3, r3, #2
 8013af8:	68fa      	ldr	r2, [r7, #12]
 8013afa:	4413      	add	r3, r2
 8013afc:	789b      	ldrb	r3, [r3, #2]
 8013afe:	f003 0302 	and.w	r3, r3, #2
 8013b02:	b2db      	uxtb	r3, r3
 8013b04:	2b00      	cmp	r3, #0
 8013b06:	d017      	beq.n	8013b38 <GetASN_Items+0x438>
            /* Store reference to data and length. */
            data[i].data.ref.data = input + idx;
 8013b08:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 8013b0a:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8013b0c:	4613      	mov	r3, r2
 8013b0e:	00db      	lsls	r3, r3, #3
 8013b10:	1a9b      	subs	r3, r3, r2
 8013b12:	009b      	lsls	r3, r3, #2
 8013b14:	461a      	mov	r2, r3
 8013b16:	68bb      	ldr	r3, [r7, #8]
 8013b18:	4413      	add	r3, r2
 8013b1a:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 8013b1c:	440a      	add	r2, r1
 8013b1e:	609a      	str	r2, [r3, #8]
            data[i].data.ref.length = (word32)len;
 8013b20:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 8013b22:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8013b24:	4613      	mov	r3, r2
 8013b26:	00db      	lsls	r3, r3, #3
 8013b28:	1a9b      	subs	r3, r3, r2
 8013b2a:	009b      	lsls	r3, r3, #2
 8013b2c:	461a      	mov	r2, r3
 8013b2e:	68bb      	ldr	r3, [r7, #8]
 8013b30:	4413      	add	r3, r2
 8013b32:	460a      	mov	r2, r1
 8013b34:	60da      	str	r2, [r3, #12]
            continue;
 8013b36:	e04d      	b.n	8013bd4 <GetASN_Items+0x4d4>
        }

        /* Store the data at idx in the ASN data item. */
        err = GetASN_StoreData(&asn[i], &data[i], input, idx, len, zeroPadded);
 8013b38:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013b3a:	009b      	lsls	r3, r3, #2
 8013b3c:	68fa      	ldr	r2, [r7, #12]
 8013b3e:	18d0      	adds	r0, r2, r3
 8013b40:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8013b42:	4613      	mov	r3, r2
 8013b44:	00db      	lsls	r3, r3, #3
 8013b46:	1a9b      	subs	r3, r3, r2
 8013b48:	009b      	lsls	r3, r3, #2
 8013b4a:	461a      	mov	r2, r3
 8013b4c:	68bb      	ldr	r3, [r7, #8]
 8013b4e:	1899      	adds	r1, r3, r2
 8013b50:	6b3c      	ldr	r4, [r7, #48]	@ 0x30
 8013b52:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8013b54:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8013b56:	9201      	str	r2, [sp, #4]
 8013b58:	9300      	str	r3, [sp, #0]
 8013b5a:	4623      	mov	r3, r4
 8013b5c:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 8013b5e:	f7ff fc5b 	bl	8013418 <GetASN_StoreData>
 8013b62:	63b8      	str	r0, [r7, #56]	@ 0x38
        if (err != 0) {
 8013b64:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8013b66:	2b00      	cmp	r3, #0
 8013b68:	d001      	beq.n	8013b6e <GetASN_Items+0x46e>
            return err;
 8013b6a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8013b6c:	e06b      	b.n	8013c46 <GetASN_Items+0x546>
        }

        /* Move index to next item. */
        idx += (word32)len;
 8013b6e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013b70:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8013b72:	4413      	add	r3, r2
 8013b74:	633b      	str	r3, [r7, #48]	@ 0x30

        /* When matched numbered choice ... */
        if (asn[i].optional > 1) {
 8013b76:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013b78:	009b      	lsls	r3, r3, #2
 8013b7a:	68fa      	ldr	r2, [r7, #12]
 8013b7c:	4413      	add	r3, r2
 8013b7e:	78db      	ldrb	r3, [r3, #3]
 8013b80:	2b01      	cmp	r3, #1
 8013b82:	d927      	bls.n	8013bd4 <GetASN_Items+0x4d4>
            /* Skip over other ASN.1 items of the same number. */
            for (j = i + 1; j < count; j++) {
 8013b84:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013b86:	3301      	adds	r3, #1
 8013b88:	65bb      	str	r3, [r7, #88]	@ 0x58
 8013b8a:	e01a      	b.n	8013bc2 <GetASN_Items+0x4c2>
                if (asn[j].depth <= asn[i].depth &&
 8013b8c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8013b8e:	009b      	lsls	r3, r3, #2
 8013b90:	68fa      	ldr	r2, [r7, #12]
 8013b92:	4413      	add	r3, r2
 8013b94:	781a      	ldrb	r2, [r3, #0]
 8013b96:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013b98:	009b      	lsls	r3, r3, #2
 8013b9a:	68f9      	ldr	r1, [r7, #12]
 8013b9c:	440b      	add	r3, r1
 8013b9e:	781b      	ldrb	r3, [r3, #0]
 8013ba0:	429a      	cmp	r2, r3
 8013ba2:	d80b      	bhi.n	8013bbc <GetASN_Items+0x4bc>
                                           asn[j].optional != asn[i].optional) {
 8013ba4:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8013ba6:	009b      	lsls	r3, r3, #2
 8013ba8:	68fa      	ldr	r2, [r7, #12]
 8013baa:	4413      	add	r3, r2
 8013bac:	78da      	ldrb	r2, [r3, #3]
 8013bae:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013bb0:	009b      	lsls	r3, r3, #2
 8013bb2:	68f9      	ldr	r1, [r7, #12]
 8013bb4:	440b      	add	r3, r1
 8013bb6:	78db      	ldrb	r3, [r3, #3]
                if (asn[j].depth <= asn[i].depth &&
 8013bb8:	429a      	cmp	r2, r3
 8013bba:	d107      	bne.n	8013bcc <GetASN_Items+0x4cc>
            for (j = i + 1; j < count; j++) {
 8013bbc:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8013bbe:	3301      	adds	r3, #1
 8013bc0:	65bb      	str	r3, [r7, #88]	@ 0x58
 8013bc2:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8013bc4:	687b      	ldr	r3, [r7, #4]
 8013bc6:	429a      	cmp	r2, r3
 8013bc8:	dbe0      	blt.n	8013b8c <GetASN_Items+0x48c>
 8013bca:	e000      	b.n	8013bce <GetASN_Items+0x4ce>
                   break;
 8013bcc:	bf00      	nop
                }
            }
            i = j - 1;
 8013bce:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8013bd0:	3b01      	subs	r3, #1
 8013bd2:	65fb      	str	r3, [r7, #92]	@ 0x5c
    for (i = 0; i < count; i++) {
 8013bd4:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013bd6:	3301      	adds	r3, #1
 8013bd8:	65fb      	str	r3, [r7, #92]	@ 0x5c
 8013bda:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8013bdc:	687b      	ldr	r3, [r7, #4]
 8013bde:	429a      	cmp	r2, r3
 8013be0:	f6ff adb5 	blt.w	801374e <GetASN_Items+0x4e>
        }
    }

    if (complete) {
 8013be4:	683b      	ldr	r3, [r7, #0]
 8013be6:	2b00      	cmp	r3, #0
 8013be8:	d015      	beq.n	8013c16 <GetASN_Items+0x516>
        /* When expecting ASN.1 items to completely use data, check we did. */
        for (j = depth; j > minDepth; j--) {
 8013bea:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8013bec:	65bb      	str	r3, [r7, #88]	@ 0x58
 8013bee:	e00e      	b.n	8013c0e <GetASN_Items+0x50e>
            if (idx < endIdx[j]) {
 8013bf0:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8013bf2:	009b      	lsls	r3, r3, #2
 8013bf4:	3360      	adds	r3, #96	@ 0x60
 8013bf6:	443b      	add	r3, r7
 8013bf8:	f853 2c4c 	ldr.w	r2, [r3, #-76]
 8013bfc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013bfe:	429a      	cmp	r2, r3
 8013c00:	d902      	bls.n	8013c08 <GetASN_Items+0x508>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG_VSNPRINTF(
                    "More data in constructed item at depth: %d", j - 1);
            #endif
                return ASN_PARSE_E;
 8013c02:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013c06:	e01e      	b.n	8013c46 <GetASN_Items+0x546>
        for (j = depth; j > minDepth; j--) {
 8013c08:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8013c0a:	3b01      	subs	r3, #1
 8013c0c:	65bb      	str	r3, [r7, #88]	@ 0x58
 8013c0e:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8013c10:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8013c12:	429a      	cmp	r2, r3
 8013c14:	dcec      	bgt.n	8013bf0 <GetASN_Items+0x4f0>
            }
        }
    }

    /* Check all choices where met - found an item for them. */
    for (j = 0; j < GET_ASN_MAX_CHOICES; j++) {
 8013c16:	2300      	movs	r3, #0
 8013c18:	65bb      	str	r3, [r7, #88]	@ 0x58
 8013c1a:	e00d      	b.n	8013c38 <GetASN_Items+0x538>
        if (choiceMet[j] == 0) {
 8013c1c:	f107 0210 	add.w	r2, r7, #16
 8013c20:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8013c22:	4413      	add	r3, r2
 8013c24:	f993 3000 	ldrsb.w	r3, [r3]
 8013c28:	2b00      	cmp	r3, #0
 8013c2a:	d102      	bne.n	8013c32 <GetASN_Items+0x532>
        #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
            WOLFSSL_MSG_VSNPRINTF("No choice seen: %d", j + 2);
        #endif
            return ASN_PARSE_E;
 8013c2c:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013c30:	e009      	b.n	8013c46 <GetASN_Items+0x546>
    for (j = 0; j < GET_ASN_MAX_CHOICES; j++) {
 8013c32:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8013c34:	3301      	adds	r3, #1
 8013c36:	65bb      	str	r3, [r7, #88]	@ 0x58
 8013c38:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8013c3a:	2b01      	cmp	r3, #1
 8013c3c:	ddee      	ble.n	8013c1c <GetASN_Items+0x51c>
        }
    }

    /* Return index after ASN.1 data has been parsed. */
    *inOutIdx = idx;
 8013c3e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8013c40:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8013c42:	601a      	str	r2, [r3, #0]

    return 0;
 8013c44:	2300      	movs	r3, #0
}
 8013c46:	4618      	mov	r0, r3
 8013c48:	3764      	adds	r7, #100	@ 0x64
 8013c4a:	46bd      	mov	sp, r7
 8013c4c:	bd90      	pop	{r4, r7, pc}

08013c4e <GetASN_Sequence>:
 * @return  BUFFER_E when not enough data to complete decode.
 * @return  ASN_PARSE when decoding failed.
 */
static int GetASN_Sequence(const byte* input, word32* inOutIdx, int* len,
                           word32 maxIdx, int complete)
{
 8013c4e:	b580      	push	{r7, lr}
 8013c50:	b088      	sub	sp, #32
 8013c52:	af02      	add	r7, sp, #8
 8013c54:	60f8      	str	r0, [r7, #12]
 8013c56:	60b9      	str	r1, [r7, #8]
 8013c58:	607a      	str	r2, [r7, #4]
 8013c5a:	603b      	str	r3, [r7, #0]
    int ret = 0;
 8013c5c:	2300      	movs	r3, #0
 8013c5e:	617b      	str	r3, [r7, #20]
    word32 idx = *inOutIdx;
 8013c60:	68bb      	ldr	r3, [r7, #8]
 8013c62:	681b      	ldr	r3, [r3, #0]
 8013c64:	613b      	str	r3, [r7, #16]

    /* Check buffer big enough for tag. */
    if (idx + 1 > maxIdx) {
 8013c66:	693b      	ldr	r3, [r7, #16]
 8013c68:	3301      	adds	r3, #1
 8013c6a:	683a      	ldr	r2, [r7, #0]
 8013c6c:	429a      	cmp	r2, r3
 8013c6e:	d202      	bcs.n	8013c76 <GetASN_Sequence+0x28>
        ret = BUFFER_E;
 8013c70:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8013c74:	617b      	str	r3, [r7, #20]
    }
    /* Check it is a constructed SEQUENCE. */
    if ((ret == 0) && (input[idx++] != (ASN_SEQUENCE | ASN_CONSTRUCTED))) {
 8013c76:	697b      	ldr	r3, [r7, #20]
 8013c78:	2b00      	cmp	r3, #0
 8013c7a:	d10a      	bne.n	8013c92 <GetASN_Sequence+0x44>
 8013c7c:	693b      	ldr	r3, [r7, #16]
 8013c7e:	1c5a      	adds	r2, r3, #1
 8013c80:	613a      	str	r2, [r7, #16]
 8013c82:	68fa      	ldr	r2, [r7, #12]
 8013c84:	4413      	add	r3, r2
 8013c86:	781b      	ldrb	r3, [r3, #0]
 8013c88:	2b30      	cmp	r3, #48	@ 0x30
 8013c8a:	d002      	beq.n	8013c92 <GetASN_Sequence+0x44>
        ret = ASN_PARSE_E;
 8013c8c:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013c90:	617b      	str	r3, [r7, #20]
    }
    /* Get the length. */
    if ((ret == 0) && (GetASN_Length(input, &idx, len, maxIdx, 1) < 0)) {
 8013c92:	697b      	ldr	r3, [r7, #20]
 8013c94:	2b00      	cmp	r3, #0
 8013c96:	d10e      	bne.n	8013cb6 <GetASN_Sequence+0x68>
 8013c98:	f107 0110 	add.w	r1, r7, #16
 8013c9c:	2301      	movs	r3, #1
 8013c9e:	9300      	str	r3, [sp, #0]
 8013ca0:	683b      	ldr	r3, [r7, #0]
 8013ca2:	687a      	ldr	r2, [r7, #4]
 8013ca4:	68f8      	ldr	r0, [r7, #12]
 8013ca6:	f000 f836 	bl	8013d16 <GetLength_ex>
 8013caa:	4603      	mov	r3, r0
 8013cac:	2b00      	cmp	r3, #0
 8013cae:	da02      	bge.n	8013cb6 <GetASN_Sequence+0x68>
        ret = ASN_PARSE_E;
 8013cb0:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013cb4:	617b      	str	r3, [r7, #20]
    }
    /* Check all data used if complete set. */
    if ((ret == 0) && complete && (idx + (word32)*len != maxIdx)) {
 8013cb6:	697b      	ldr	r3, [r7, #20]
 8013cb8:	2b00      	cmp	r3, #0
 8013cba:	d10d      	bne.n	8013cd8 <GetASN_Sequence+0x8a>
 8013cbc:	6a3b      	ldr	r3, [r7, #32]
 8013cbe:	2b00      	cmp	r3, #0
 8013cc0:	d00a      	beq.n	8013cd8 <GetASN_Sequence+0x8a>
 8013cc2:	687b      	ldr	r3, [r7, #4]
 8013cc4:	681b      	ldr	r3, [r3, #0]
 8013cc6:	461a      	mov	r2, r3
 8013cc8:	693b      	ldr	r3, [r7, #16]
 8013cca:	4413      	add	r3, r2
 8013ccc:	683a      	ldr	r2, [r7, #0]
 8013cce:	429a      	cmp	r2, r3
 8013cd0:	d002      	beq.n	8013cd8 <GetASN_Sequence+0x8a>
        ret = ASN_PARSE_E;
 8013cd2:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013cd6:	617b      	str	r3, [r7, #20]
    }
    if (ret == 0) {
 8013cd8:	697b      	ldr	r3, [r7, #20]
 8013cda:	2b00      	cmp	r3, #0
 8013cdc:	d102      	bne.n	8013ce4 <GetASN_Sequence+0x96>
        /* Return index of next byte of encoded data. */
        *inOutIdx = idx;
 8013cde:	693a      	ldr	r2, [r7, #16]
 8013ce0:	68bb      	ldr	r3, [r7, #8]
 8013ce2:	601a      	str	r2, [r3, #0]
    }

    return ret;
 8013ce4:	697b      	ldr	r3, [r7, #20]
}
 8013ce6:	4618      	mov	r0, r3
 8013ce8:	3718      	adds	r7, #24
 8013cea:	46bd      	mov	sp, r7
 8013cec:	bd80      	pop	{r7, pc}

08013cee <GetLength>:
 * @return  Length on success.
 * @return  ASN_PARSE_E if the encoding is invalid.
 * @return  BUFFER_E when not enough data to complete decode.
 */
int GetLength(const byte* input, word32* inOutIdx, int* len, word32 maxIdx)
{
 8013cee:	b580      	push	{r7, lr}
 8013cf0:	b086      	sub	sp, #24
 8013cf2:	af02      	add	r7, sp, #8
 8013cf4:	60f8      	str	r0, [r7, #12]
 8013cf6:	60b9      	str	r1, [r7, #8]
 8013cf8:	607a      	str	r2, [r7, #4]
 8013cfa:	603b      	str	r3, [r7, #0]
    return GetLength_ex(input, inOutIdx, len, maxIdx, 1);
 8013cfc:	2301      	movs	r3, #1
 8013cfe:	9300      	str	r3, [sp, #0]
 8013d00:	683b      	ldr	r3, [r7, #0]
 8013d02:	687a      	ldr	r2, [r7, #4]
 8013d04:	68b9      	ldr	r1, [r7, #8]
 8013d06:	68f8      	ldr	r0, [r7, #12]
 8013d08:	f000 f805 	bl	8013d16 <GetLength_ex>
 8013d0c:	4603      	mov	r3, r0
}
 8013d0e:	4618      	mov	r0, r3
 8013d10:	3710      	adds	r7, #16
 8013d12:	46bd      	mov	sp, r7
 8013d14:	bd80      	pop	{r7, pc}

08013d16 <GetLength_ex>:
 * @return  ASN_PARSE_E if the encoding is invalid.
 * @return  BUFFER_E when not enough data to complete decode.
 */
int GetLength_ex(const byte* input, word32* inOutIdx, int* len, word32 maxIdx,
                 int check)
{
 8013d16:	b480      	push	{r7}
 8013d18:	b08b      	sub	sp, #44	@ 0x2c
 8013d1a:	af00      	add	r7, sp, #0
 8013d1c:	60f8      	str	r0, [r7, #12]
 8013d1e:	60b9      	str	r1, [r7, #8]
 8013d20:	607a      	str	r2, [r7, #4]
 8013d22:	603b      	str	r3, [r7, #0]
    int     length = 0;
 8013d24:	2300      	movs	r3, #0
 8013d26:	627b      	str	r3, [r7, #36]	@ 0x24
    word32  idx = (word32)*inOutIdx;
 8013d28:	68bb      	ldr	r3, [r7, #8]
 8013d2a:	681b      	ldr	r3, [r3, #0]
 8013d2c:	623b      	str	r3, [r7, #32]
    byte    b;

    /* Ensure zero return length on error. */
    *len = 0;
 8013d2e:	687b      	ldr	r3, [r7, #4]
 8013d30:	2200      	movs	r2, #0
 8013d32:	601a      	str	r2, [r3, #0]

    /* Check there is at least one byte available containing length information.
     */
    if ((idx + 1) > maxIdx) {
 8013d34:	6a3b      	ldr	r3, [r7, #32]
 8013d36:	3301      	adds	r3, #1
 8013d38:	683a      	ldr	r2, [r7, #0]
 8013d3a:	429a      	cmp	r2, r3
 8013d3c:	d202      	bcs.n	8013d44 <GetLength_ex+0x2e>
        WOLFSSL_MSG("GetLength - bad index on input");
        return BUFFER_E;
 8013d3e:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8013d42:	e066      	b.n	8013e12 <GetLength_ex+0xfc>
    }

    /* Get the first length byte. */
    b = input[idx++];
 8013d44:	6a3b      	ldr	r3, [r7, #32]
 8013d46:	1c5a      	adds	r2, r3, #1
 8013d48:	623a      	str	r2, [r7, #32]
 8013d4a:	68fa      	ldr	r2, [r7, #12]
 8013d4c:	4413      	add	r3, r2
 8013d4e:	781b      	ldrb	r3, [r3, #0]
 8013d50:	75fb      	strb	r3, [r7, #23]
    /* Check if the first byte indicates the count of bytes. */
    if (b >= ASN_LONG_LENGTH) {
 8013d52:	f997 3017 	ldrsb.w	r3, [r7, #23]
 8013d56:	2b00      	cmp	r3, #0
 8013d58:	da43      	bge.n	8013de2 <GetLength_ex+0xcc>
        /* Bottom 7 bits are the number of bytes to calculate length with.
         * Note: 0 indicates indefinite length encoding *not* 0 bytes of length.
         */
        int bytes = (int)(b & 0x7F);
 8013d5a:	7dfb      	ldrb	r3, [r7, #23]
 8013d5c:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8013d60:	61fb      	str	r3, [r7, #28]
        int minLen;

        /* Calculate minimum length to be encoded with bytes. */
        if (b == ASN_INDEF_LENGTH) {
 8013d62:	7dfb      	ldrb	r3, [r7, #23]
 8013d64:	2b80      	cmp	r3, #128	@ 0x80
 8013d66:	d102      	bne.n	8013d6e <GetLength_ex+0x58>
            /* Indefinite length encoding - no length bytes. */
            minLen = 0;
 8013d68:	2300      	movs	r3, #0
 8013d6a:	61bb      	str	r3, [r7, #24]
 8013d6c:	e012      	b.n	8013d94 <GetLength_ex+0x7e>
        }
        else if (bytes == 1) {
 8013d6e:	69fb      	ldr	r3, [r7, #28]
 8013d70:	2b01      	cmp	r3, #1
 8013d72:	d102      	bne.n	8013d7a <GetLength_ex+0x64>
            minLen = 0x80;
 8013d74:	2380      	movs	r3, #128	@ 0x80
 8013d76:	61bb      	str	r3, [r7, #24]
 8013d78:	e00c      	b.n	8013d94 <GetLength_ex+0x7e>
        }
        /* Only support up to the number of bytes that fit into return var. */
        else if (bytes > (int)sizeof(length)) {
 8013d7a:	69fb      	ldr	r3, [r7, #28]
 8013d7c:	2b04      	cmp	r3, #4
 8013d7e:	dd02      	ble.n	8013d86 <GetLength_ex+0x70>
            WOLFSSL_MSG("GetLength - overlong data length spec");
            return ASN_PARSE_E;
 8013d80:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013d84:	e045      	b.n	8013e12 <GetLength_ex+0xfc>
        }
        else {
            minLen = 1 << ((bytes - 1) * 8);
 8013d86:	69fb      	ldr	r3, [r7, #28]
 8013d88:	3b01      	subs	r3, #1
 8013d8a:	00db      	lsls	r3, r3, #3
 8013d8c:	2201      	movs	r2, #1
 8013d8e:	fa02 f303 	lsl.w	r3, r2, r3
 8013d92:	61bb      	str	r3, [r7, #24]
        }

        /* Check the number of bytes required are available. */
        if ((idx + (word32)bytes) > maxIdx) {
 8013d94:	69fa      	ldr	r2, [r7, #28]
 8013d96:	6a3b      	ldr	r3, [r7, #32]
 8013d98:	4413      	add	r3, r2
 8013d9a:	683a      	ldr	r2, [r7, #0]
 8013d9c:	429a      	cmp	r2, r3
 8013d9e:	d20e      	bcs.n	8013dbe <GetLength_ex+0xa8>
            WOLFSSL_MSG("GetLength - bad long length");
            return BUFFER_E;
 8013da0:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8013da4:	e035      	b.n	8013e12 <GetLength_ex+0xfc>
        }

        /* Big-endian encoding of number. */
        while (bytes--) {
            b = input[idx++];
 8013da6:	6a3b      	ldr	r3, [r7, #32]
 8013da8:	1c5a      	adds	r2, r3, #1
 8013daa:	623a      	str	r2, [r7, #32]
 8013dac:	68fa      	ldr	r2, [r7, #12]
 8013dae:	4413      	add	r3, r2
 8013db0:	781b      	ldrb	r3, [r3, #0]
 8013db2:	75fb      	strb	r3, [r7, #23]
            length = (length << 8) | b;
 8013db4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8013db6:	021a      	lsls	r2, r3, #8
 8013db8:	7dfb      	ldrb	r3, [r7, #23]
 8013dba:	4313      	orrs	r3, r2
 8013dbc:	627b      	str	r3, [r7, #36]	@ 0x24
        while (bytes--) {
 8013dbe:	69fb      	ldr	r3, [r7, #28]
 8013dc0:	1e5a      	subs	r2, r3, #1
 8013dc2:	61fa      	str	r2, [r7, #28]
 8013dc4:	2b00      	cmp	r3, #0
 8013dc6:	d1ee      	bne.n	8013da6 <GetLength_ex+0x90>
        }
        /* Negative value indicates we overflowed the signed int. */
        if (length < 0) {
 8013dc8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8013dca:	2b00      	cmp	r3, #0
 8013dcc:	da02      	bge.n	8013dd4 <GetLength_ex+0xbe>
            return ASN_PARSE_E;
 8013dce:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013dd2:	e01e      	b.n	8013e12 <GetLength_ex+0xfc>
        }
        /* Don't allow lengths that are longer than strictly required. */
        if (length < minLen) {
 8013dd4:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8013dd6:	69bb      	ldr	r3, [r7, #24]
 8013dd8:	429a      	cmp	r2, r3
 8013dda:	da04      	bge.n	8013de6 <GetLength_ex+0xd0>
            return ASN_PARSE_E;
 8013ddc:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013de0:	e017      	b.n	8013e12 <GetLength_ex+0xfc>
        }
    }
    else {
        /* Length in first byte. */
        length = b;
 8013de2:	7dfb      	ldrb	r3, [r7, #23]
 8013de4:	627b      	str	r3, [r7, #36]	@ 0x24
    }

    /* When requested, check the buffer has at least length bytes left. */
    if (check && ((idx + (word32)length) > maxIdx)) {
 8013de6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013de8:	2b00      	cmp	r3, #0
 8013dea:	d008      	beq.n	8013dfe <GetLength_ex+0xe8>
 8013dec:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8013dee:	6a3b      	ldr	r3, [r7, #32]
 8013df0:	4413      	add	r3, r2
 8013df2:	683a      	ldr	r2, [r7, #0]
 8013df4:	429a      	cmp	r2, r3
 8013df6:	d202      	bcs.n	8013dfe <GetLength_ex+0xe8>
        WOLFSSL_MSG("GetLength - value exceeds buffer length");
        return BUFFER_E;
 8013df8:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8013dfc:	e009      	b.n	8013e12 <GetLength_ex+0xfc>
    }

    /* Return index after length encoding. */
    *inOutIdx = idx;
 8013dfe:	68bb      	ldr	r3, [r7, #8]
 8013e00:	6a3a      	ldr	r2, [r7, #32]
 8013e02:	601a      	str	r2, [r3, #0]
    /* Return length if valid. */
    if (length > 0) {
 8013e04:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8013e06:	2b00      	cmp	r3, #0
 8013e08:	dd02      	ble.n	8013e10 <GetLength_ex+0xfa>
        *len = length;
 8013e0a:	687b      	ldr	r3, [r7, #4]
 8013e0c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8013e0e:	601a      	str	r2, [r3, #0]
    }

    /* Return length calculated or error code. */
    return length;
 8013e10:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 8013e12:	4618      	mov	r0, r3
 8013e14:	372c      	adds	r7, #44	@ 0x2c
 8013e16:	46bd      	mov	sp, r7
 8013e18:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013e1c:	4770      	bx	lr

08013e1e <GetASNTag>:
 * return  0 on success
 * return  BAD_FUNC_ARG when tag, inOutIdx or input is NULL.
 * return  BUFFER_E when not enough space in buffer for tag.
 */
int GetASNTag(const byte* input, word32* inOutIdx, byte* tag, word32 maxIdx)
{
 8013e1e:	b480      	push	{r7}
 8013e20:	b087      	sub	sp, #28
 8013e22:	af00      	add	r7, sp, #0
 8013e24:	60f8      	str	r0, [r7, #12]
 8013e26:	60b9      	str	r1, [r7, #8]
 8013e28:	607a      	str	r2, [r7, #4]
 8013e2a:	603b      	str	r3, [r7, #0]
    int ret = 0;
 8013e2c:	2300      	movs	r3, #0
 8013e2e:	617b      	str	r3, [r7, #20]
    word32 idx = 0;
 8013e30:	2300      	movs	r3, #0
 8013e32:	613b      	str	r3, [r7, #16]

    /* Check validity of parameters. */
    if ((tag == NULL) || (inOutIdx == NULL) || (input == NULL)) {
 8013e34:	687b      	ldr	r3, [r7, #4]
 8013e36:	2b00      	cmp	r3, #0
 8013e38:	d005      	beq.n	8013e46 <GetASNTag+0x28>
 8013e3a:	68bb      	ldr	r3, [r7, #8]
 8013e3c:	2b00      	cmp	r3, #0
 8013e3e:	d002      	beq.n	8013e46 <GetASNTag+0x28>
 8013e40:	68fb      	ldr	r3, [r7, #12]
 8013e42:	2b00      	cmp	r3, #0
 8013e44:	d102      	bne.n	8013e4c <GetASNTag+0x2e>
        ret = BAD_FUNC_ARG;
 8013e46:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8013e4a:	617b      	str	r3, [r7, #20]
    }
    if (ret == 0) {
 8013e4c:	697b      	ldr	r3, [r7, #20]
 8013e4e:	2b00      	cmp	r3, #0
 8013e50:	d10a      	bne.n	8013e68 <GetASNTag+0x4a>
        /* Get index and ensure space for tag. */
        idx = *inOutIdx;
 8013e52:	68bb      	ldr	r3, [r7, #8]
 8013e54:	681b      	ldr	r3, [r3, #0]
 8013e56:	613b      	str	r3, [r7, #16]
        if (idx + ASN_TAG_SZ > maxIdx) {
 8013e58:	693b      	ldr	r3, [r7, #16]
 8013e5a:	3301      	adds	r3, #1
 8013e5c:	683a      	ldr	r2, [r7, #0]
 8013e5e:	429a      	cmp	r2, r3
 8013e60:	d202      	bcs.n	8013e68 <GetASNTag+0x4a>
            WOLFSSL_MSG("Buffer too small for ASN tag");
            ret = BUFFER_E;
 8013e62:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8013e66:	617b      	str	r3, [r7, #20]
        }
    }
    if (ret == 0) {
 8013e68:	697b      	ldr	r3, [r7, #20]
 8013e6a:	2b00      	cmp	r3, #0
 8013e6c:	d109      	bne.n	8013e82 <GetASNTag+0x64>
        /* Return the tag and the index after tag. */
        *tag = input[idx];
 8013e6e:	68fa      	ldr	r2, [r7, #12]
 8013e70:	693b      	ldr	r3, [r7, #16]
 8013e72:	4413      	add	r3, r2
 8013e74:	781a      	ldrb	r2, [r3, #0]
 8013e76:	687b      	ldr	r3, [r7, #4]
 8013e78:	701a      	strb	r2, [r3, #0]
        *inOutIdx = idx + ASN_TAG_SZ;
 8013e7a:	693b      	ldr	r3, [r7, #16]
 8013e7c:	1c5a      	adds	r2, r3, #1
 8013e7e:	68bb      	ldr	r3, [r7, #8]
 8013e80:	601a      	str	r2, [r3, #0]
    }
    /* Return error code. */
    return ret;
 8013e82:	697b      	ldr	r3, [r7, #20]
}
 8013e84:	4618      	mov	r0, r3
 8013e86:	371c      	adds	r7, #28
 8013e88:	46bd      	mov	sp, r7
 8013e8a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013e8e:	4770      	bx	lr

08013e90 <GetASNHeader_ex>:
 * @return  BUFFER_E when there is not enough data to parse.
 * @return  ASN_PARSE_E when the expected tag is not found or length is invalid.
 */
static int GetASNHeader_ex(const byte* input, byte tag, word32* inOutIdx,
                           int* len, word32 maxIdx, int check)
{
 8013e90:	b580      	push	{r7, lr}
 8013e92:	b08a      	sub	sp, #40	@ 0x28
 8013e94:	af02      	add	r7, sp, #8
 8013e96:	60f8      	str	r0, [r7, #12]
 8013e98:	607a      	str	r2, [r7, #4]
 8013e9a:	603b      	str	r3, [r7, #0]
 8013e9c:	460b      	mov	r3, r1
 8013e9e:	72fb      	strb	r3, [r7, #11]
    int    ret = 0;
 8013ea0:	2300      	movs	r3, #0
 8013ea2:	61fb      	str	r3, [r7, #28]
    word32 idx = *inOutIdx;
 8013ea4:	687b      	ldr	r3, [r7, #4]
 8013ea6:	681b      	ldr	r3, [r3, #0]
 8013ea8:	61bb      	str	r3, [r7, #24]
    byte   tagFound;
    int    length = 0;
 8013eaa:	2300      	movs	r3, #0
 8013eac:	613b      	str	r3, [r7, #16]

    /* Get tag/type. */
    if (GetASNTag(input, &idx, &tagFound, maxIdx) != 0) {
 8013eae:	f107 0217 	add.w	r2, r7, #23
 8013eb2:	f107 0118 	add.w	r1, r7, #24
 8013eb6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8013eb8:	68f8      	ldr	r0, [r7, #12]
 8013eba:	f7ff ffb0 	bl	8013e1e <GetASNTag>
 8013ebe:	4603      	mov	r3, r0
 8013ec0:	2b00      	cmp	r3, #0
 8013ec2:	d002      	beq.n	8013eca <GetASNHeader_ex+0x3a>
        ret = ASN_PARSE_E;
 8013ec4:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013ec8:	61fb      	str	r3, [r7, #28]
    }
    /* Ensure tag is the expected value. */
    if ((ret == 0) && (tagFound != tag)) {
 8013eca:	69fb      	ldr	r3, [r7, #28]
 8013ecc:	2b00      	cmp	r3, #0
 8013ece:	d106      	bne.n	8013ede <GetASNHeader_ex+0x4e>
 8013ed0:	7dfb      	ldrb	r3, [r7, #23]
 8013ed2:	7afa      	ldrb	r2, [r7, #11]
 8013ed4:	429a      	cmp	r2, r3
 8013ed6:	d002      	beq.n	8013ede <GetASNHeader_ex+0x4e>
        ret = ASN_PARSE_E;
 8013ed8:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013edc:	61fb      	str	r3, [r7, #28]
    }
    /* Get the encoded length. */
    if ((ret == 0) && (GetLength_ex(input, &idx, &length, maxIdx, check) < 0)) {
 8013ede:	69fb      	ldr	r3, [r7, #28]
 8013ee0:	2b00      	cmp	r3, #0
 8013ee2:	d10f      	bne.n	8013f04 <GetASNHeader_ex+0x74>
 8013ee4:	f107 0210 	add.w	r2, r7, #16
 8013ee8:	f107 0118 	add.w	r1, r7, #24
 8013eec:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013eee:	9300      	str	r3, [sp, #0]
 8013ef0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8013ef2:	68f8      	ldr	r0, [r7, #12]
 8013ef4:	f7ff ff0f 	bl	8013d16 <GetLength_ex>
 8013ef8:	4603      	mov	r3, r0
 8013efa:	2b00      	cmp	r3, #0
 8013efc:	da02      	bge.n	8013f04 <GetASNHeader_ex+0x74>
        ret = ASN_PARSE_E;
 8013efe:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013f02:	61fb      	str	r3, [r7, #28]
    }
    if (ret == 0 && tag == ASN_OBJECT_ID) {
 8013f04:	69fb      	ldr	r3, [r7, #28]
 8013f06:	2b00      	cmp	r3, #0
 8013f08:	d117      	bne.n	8013f3a <GetASNHeader_ex+0xaa>
 8013f0a:	7afb      	ldrb	r3, [r7, #11]
 8013f0c:	2b06      	cmp	r3, #6
 8013f0e:	d114      	bne.n	8013f3a <GetASNHeader_ex+0xaa>
        if (length < 3) {
 8013f10:	693b      	ldr	r3, [r7, #16]
 8013f12:	2b02      	cmp	r3, #2
 8013f14:	dc03      	bgt.n	8013f1e <GetASNHeader_ex+0x8e>
            /* OID data must be at least 3 bytes. */
            WOLFSSL_MSG("OID length less than 3");
            ret = ASN_PARSE_E;
 8013f16:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013f1a:	61fb      	str	r3, [r7, #28]
 8013f1c:	e00d      	b.n	8013f3a <GetASNHeader_ex+0xaa>
        }
        else if ((input[(int)idx + length - 1] & 0x80) == 0x80) {
 8013f1e:	69bb      	ldr	r3, [r7, #24]
 8013f20:	461a      	mov	r2, r3
 8013f22:	693b      	ldr	r3, [r7, #16]
 8013f24:	4413      	add	r3, r2
 8013f26:	3b01      	subs	r3, #1
 8013f28:	68fa      	ldr	r2, [r7, #12]
 8013f2a:	4413      	add	r3, r2
 8013f2c:	781b      	ldrb	r3, [r3, #0]
 8013f2e:	b25b      	sxtb	r3, r3
 8013f30:	2b00      	cmp	r3, #0
 8013f32:	da02      	bge.n	8013f3a <GetASNHeader_ex+0xaa>
            /* Last octet of a sub-identifier has bit 8 clear. Last octet must be
            * last of a subidentifier. Ensure last octet hasn't got top bit set. */
            WOLFSSL_MSG("OID last octet has top bit set");
            ret = ASN_PARSE_E;
 8013f34:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013f38:	61fb      	str	r3, [r7, #28]
        }
    }
    if (ret == 0) {
 8013f3a:	69fb      	ldr	r3, [r7, #28]
 8013f3c:	2b00      	cmp	r3, #0
 8013f3e:	d107      	bne.n	8013f50 <GetASNHeader_ex+0xc0>
        /* Return the length of data and index after header. */
        *len      = length;
 8013f40:	693a      	ldr	r2, [r7, #16]
 8013f42:	683b      	ldr	r3, [r7, #0]
 8013f44:	601a      	str	r2, [r3, #0]
        *inOutIdx = idx;
 8013f46:	69ba      	ldr	r2, [r7, #24]
 8013f48:	687b      	ldr	r3, [r7, #4]
 8013f4a:	601a      	str	r2, [r3, #0]
        ret = length;
 8013f4c:	693b      	ldr	r3, [r7, #16]
 8013f4e:	61fb      	str	r3, [r7, #28]
    }
    /* Return number of data bytes or error code. */
    return ret;
 8013f50:	69fb      	ldr	r3, [r7, #28]
}
 8013f52:	4618      	mov	r0, r3
 8013f54:	3720      	adds	r7, #32
 8013f56:	46bd      	mov	sp, r7
 8013f58:	bd80      	pop	{r7, pc}

08013f5a <GetASNHeader>:
 * @return  BUFFER_E when there is not enough data to parse.
 * @return  ASN_PARSE_E when the expected tag is not found or length is invalid.
 */
int GetASNHeader(const byte* input, byte tag, word32* inOutIdx, int* len,
                        word32 maxIdx)
{
 8013f5a:	b580      	push	{r7, lr}
 8013f5c:	b086      	sub	sp, #24
 8013f5e:	af02      	add	r7, sp, #8
 8013f60:	60f8      	str	r0, [r7, #12]
 8013f62:	607a      	str	r2, [r7, #4]
 8013f64:	603b      	str	r3, [r7, #0]
 8013f66:	460b      	mov	r3, r1
 8013f68:	72fb      	strb	r3, [r7, #11]
    return GetASNHeader_ex(input, tag, inOutIdx, len, maxIdx, 1);
 8013f6a:	7af9      	ldrb	r1, [r7, #11]
 8013f6c:	2301      	movs	r3, #1
 8013f6e:	9301      	str	r3, [sp, #4]
 8013f70:	69bb      	ldr	r3, [r7, #24]
 8013f72:	9300      	str	r3, [sp, #0]
 8013f74:	683b      	ldr	r3, [r7, #0]
 8013f76:	687a      	ldr	r2, [r7, #4]
 8013f78:	68f8      	ldr	r0, [r7, #12]
 8013f7a:	f7ff ff89 	bl	8013e90 <GetASNHeader_ex>
 8013f7e:	4603      	mov	r3, r0
}
 8013f80:	4618      	mov	r0, r3
 8013f82:	3710      	adds	r7, #16
 8013f84:	46bd      	mov	sp, r7
 8013f86:	bd80      	pop	{r7, pc}

08013f88 <GetSequence>:
 * @return  BUFFER_E when there is not enough data to parse.
 * @return  ASN_PARSE_E when the tag is not a SEQUENCE or length is invalid.
 */
int GetSequence(const byte* input, word32* inOutIdx, int* len,
                           word32 maxIdx)
{
 8013f88:	b580      	push	{r7, lr}
 8013f8a:	b086      	sub	sp, #24
 8013f8c:	af02      	add	r7, sp, #8
 8013f8e:	60f8      	str	r0, [r7, #12]
 8013f90:	60b9      	str	r1, [r7, #8]
 8013f92:	607a      	str	r2, [r7, #4]
 8013f94:	603b      	str	r3, [r7, #0]
    return GetASNHeader(input, ASN_SEQUENCE | ASN_CONSTRUCTED, inOutIdx, len,
 8013f96:	683b      	ldr	r3, [r7, #0]
 8013f98:	9300      	str	r3, [sp, #0]
 8013f9a:	687b      	ldr	r3, [r7, #4]
 8013f9c:	68ba      	ldr	r2, [r7, #8]
 8013f9e:	2130      	movs	r1, #48	@ 0x30
 8013fa0:	68f8      	ldr	r0, [r7, #12]
 8013fa2:	f7ff ffda 	bl	8013f5a <GetASNHeader>
 8013fa6:	4603      	mov	r3, r0
                        maxIdx);
}
 8013fa8:	4618      	mov	r0, r3
 8013faa:	3710      	adds	r7, #16
 8013fac:	46bd      	mov	sp, r7
 8013fae:	bd80      	pop	{r7, pc}

08013fb0 <GetSequence_ex>:
 * @return  BUFFER_E when there is not enough data to parse.
 * @return  ASN_PARSE_E when the tag is not a SEQUENCE or length is invalid.
 */
int GetSequence_ex(const byte* input, word32* inOutIdx, int* len,
                           word32 maxIdx, int check)
{
 8013fb0:	b580      	push	{r7, lr}
 8013fb2:	b086      	sub	sp, #24
 8013fb4:	af02      	add	r7, sp, #8
 8013fb6:	60f8      	str	r0, [r7, #12]
 8013fb8:	60b9      	str	r1, [r7, #8]
 8013fba:	607a      	str	r2, [r7, #4]
 8013fbc:	603b      	str	r3, [r7, #0]
    return GetASNHeader_ex(input, ASN_SEQUENCE | ASN_CONSTRUCTED, inOutIdx, len,
 8013fbe:	69bb      	ldr	r3, [r7, #24]
 8013fc0:	9301      	str	r3, [sp, #4]
 8013fc2:	683b      	ldr	r3, [r7, #0]
 8013fc4:	9300      	str	r3, [sp, #0]
 8013fc6:	687b      	ldr	r3, [r7, #4]
 8013fc8:	68ba      	ldr	r2, [r7, #8]
 8013fca:	2130      	movs	r1, #48	@ 0x30
 8013fcc:	68f8      	ldr	r0, [r7, #12]
 8013fce:	f7ff ff5f 	bl	8013e90 <GetASNHeader_ex>
 8013fd2:	4603      	mov	r3, r0
                        maxIdx, check);
}
 8013fd4:	4618      	mov	r0, r3
 8013fd6:	3710      	adds	r7, #16
 8013fd8:	46bd      	mov	sp, r7
 8013fda:	bd80      	pop	{r7, pc}

08013fdc <GetOctetString>:
 * @return  Number of bytes in the ASN.1 data on success.
 * @return  BUFFER_E when there is not enough data to parse.
 * @return  ASN_PARSE_E when the tag is not a OCTET STRING or length is invalid.
 */
int GetOctetString(const byte* input, word32* inOutIdx, int* len, word32 maxIdx)
{
 8013fdc:	b580      	push	{r7, lr}
 8013fde:	b086      	sub	sp, #24
 8013fe0:	af02      	add	r7, sp, #8
 8013fe2:	60f8      	str	r0, [r7, #12]
 8013fe4:	60b9      	str	r1, [r7, #8]
 8013fe6:	607a      	str	r2, [r7, #4]
 8013fe8:	603b      	str	r3, [r7, #0]
    return GetASNHeader(input, ASN_OCTET_STRING, inOutIdx, len, maxIdx);
 8013fea:	683b      	ldr	r3, [r7, #0]
 8013fec:	9300      	str	r3, [sp, #0]
 8013fee:	687b      	ldr	r3, [r7, #4]
 8013ff0:	68ba      	ldr	r2, [r7, #8]
 8013ff2:	2104      	movs	r1, #4
 8013ff4:	68f8      	ldr	r0, [r7, #12]
 8013ff6:	f7ff ffb0 	bl	8013f5a <GetASNHeader>
 8013ffa:	4603      	mov	r3, r0
}
 8013ffc:	4618      	mov	r0, r3
 8013ffe:	3710      	adds	r7, #16
 8014000:	46bd      	mov	sp, r7
 8014002:	bd80      	pop	{r7, pc}

08014004 <CheckBitString>:
 * @return  BUFFER_E when data in buffer is too small.
 * @return  ASN_EXPECT_0_E when unused bits is not zero when expected.
 */
int CheckBitString(const byte* input, word32* inOutIdx, int* len,
                          word32 maxIdx, int zeroBits, byte* unusedBits)
{
 8014004:	b580      	push	{r7, lr}
 8014006:	b092      	sub	sp, #72	@ 0x48
 8014008:	af04      	add	r7, sp, #16
 801400a:	60f8      	str	r0, [r7, #12]
 801400c:	60b9      	str	r1, [r7, #8]
 801400e:	607a      	str	r2, [r7, #4]
 8014010:	603b      	str	r3, [r7, #0]

    return 0;
#else
    ASNGetData dataASN[bitStringASN_Length];
    int ret;
    int bits = 0;
 8014012:	2300      	movs	r3, #0
 8014014:	633b      	str	r3, [r7, #48]	@ 0x30

    /* Parse BIT_STRING and check validity of unused bits. */
    XMEMSET(dataASN, 0, sizeof(dataASN));
 8014016:	f107 0314 	add.w	r3, r7, #20
 801401a:	221c      	movs	r2, #28
 801401c:	2100      	movs	r1, #0
 801401e:	4618      	mov	r0, r3
 8014020:	f014 fa52 	bl	80284c8 <memset>
    /* Decode BIT_STRING. */
    ret = GetASN_Items(bitStringASN, dataASN, bitStringASN_Length, 0, input,
 8014024:	f107 0114 	add.w	r1, r7, #20
 8014028:	683b      	ldr	r3, [r7, #0]
 801402a:	9302      	str	r3, [sp, #8]
 801402c:	68bb      	ldr	r3, [r7, #8]
 801402e:	9301      	str	r3, [sp, #4]
 8014030:	68fb      	ldr	r3, [r7, #12]
 8014032:	9300      	str	r3, [sp, #0]
 8014034:	2300      	movs	r3, #0
 8014036:	2201      	movs	r2, #1
 8014038:	4814      	ldr	r0, [pc, #80]	@ (801408c <CheckBitString+0x88>)
 801403a:	f7ff fb61 	bl	8013700 <GetASN_Items>
 801403e:	6378      	str	r0, [r7, #52]	@ 0x34
            inOutIdx, maxIdx);
    if (ret == 0) {
 8014040:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014042:	2b00      	cmp	r3, #0
 8014044:	d10c      	bne.n	8014060 <CheckBitString+0x5c>
        /* Get unused bits from dynamic ASN.1 data. */
        bits = GetASNItem_UnusedBits(dataASN[BITSTRINGASN_IDX_BIT_STR]);
 8014046:	69fb      	ldr	r3, [r7, #28]
 8014048:	3b01      	subs	r3, #1
 801404a:	781b      	ldrb	r3, [r3, #0]
 801404c:	633b      	str	r3, [r7, #48]	@ 0x30
        /* Check unused bits is 0 when expected. */
        if (zeroBits && (bits != 0)) {
 801404e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8014050:	2b00      	cmp	r3, #0
 8014052:	d005      	beq.n	8014060 <CheckBitString+0x5c>
 8014054:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014056:	2b00      	cmp	r3, #0
 8014058:	d002      	beq.n	8014060 <CheckBitString+0x5c>
            ret = ASN_EXPECT_0_E;
 801405a:	f06f 0391 	mvn.w	r3, #145	@ 0x91
 801405e:	637b      	str	r3, [r7, #52]	@ 0x34
        }
    }
    if (ret == 0) {
 8014060:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014062:	2b00      	cmp	r3, #0
 8014064:	d10d      	bne.n	8014082 <CheckBitString+0x7e>
        /* Return length of data and unused bits if required. */
        if (len != NULL) {
 8014066:	687b      	ldr	r3, [r7, #4]
 8014068:	2b00      	cmp	r3, #0
 801406a:	d003      	beq.n	8014074 <CheckBitString+0x70>
            *len = (int)dataASN[BITSTRINGASN_IDX_BIT_STR].data.ref.length;
 801406c:	6a3b      	ldr	r3, [r7, #32]
 801406e:	461a      	mov	r2, r3
 8014070:	687b      	ldr	r3, [r7, #4]
 8014072:	601a      	str	r2, [r3, #0]
        }
        if (unusedBits != NULL) {
 8014074:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8014076:	2b00      	cmp	r3, #0
 8014078:	d003      	beq.n	8014082 <CheckBitString+0x7e>
            *unusedBits = (byte)bits;
 801407a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801407c:	b2da      	uxtb	r2, r3
 801407e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8014080:	701a      	strb	r2, [r3, #0]
        }
    }

    return ret;
 8014082:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
#endif
}
 8014084:	4618      	mov	r0, r3
 8014086:	3738      	adds	r7, #56	@ 0x38
 8014088:	46bd      	mov	sp, r7
 801408a:	bd80      	pop	{r7, pc}
 801408c:	08033594 	.word	0x08033594

08014090 <OidFromId>:
 * @param [out] oidSz  Length of OID byte array returned.
 * @return  Array of bytes for the OID.
 * @return  NULL when ID/type not recognized.
 */
const byte* OidFromId(word32 id, word32 type, word32* oidSz)
{
 8014090:	b580      	push	{r7, lr}
 8014092:	b086      	sub	sp, #24
 8014094:	af00      	add	r7, sp, #0
 8014096:	60f8      	str	r0, [r7, #12]
 8014098:	60b9      	str	r1, [r7, #8]
 801409a:	607a      	str	r2, [r7, #4]
    const byte* oid = NULL;
 801409c:	2300      	movs	r3, #0
 801409e:	617b      	str	r3, [r7, #20]

    *oidSz = 0;
 80140a0:	687b      	ldr	r3, [r7, #4]
 80140a2:	2200      	movs	r2, #0
 80140a4:	601a      	str	r2, [r3, #0]

    switch (type) {
 80140a6:	68bb      	ldr	r3, [r7, #8]
 80140a8:	2b13      	cmp	r3, #19
 80140aa:	f200 82ca 	bhi.w	8014642 <OidFromId+0x5b2>
 80140ae:	a201      	add	r2, pc, #4	@ (adr r2, 80140b4 <OidFromId+0x24>)
 80140b0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80140b4:	08014105 	.word	0x08014105
 80140b8:	0801411d 	.word	0x0801411d
 80140bc:	0801416b 	.word	0x0801416b
 80140c0:	080141d9 	.word	0x080141d9
 80140c4:	080141e9 	.word	0x080141e9
 80140c8:	08014643 	.word	0x08014643
 80140cc:	080142fd 	.word	0x080142fd
 80140d0:	08014499 	.word	0x08014499
 80140d4:	080144c1 	.word	0x080144c1
 80140d8:	080144d7 	.word	0x080144d7
 80140dc:	080144ed 	.word	0x080144ed
 80140e0:	0801458b 	.word	0x0801458b
 80140e4:	080145c3 	.word	0x080145c3
 80140e8:	08014613 	.word	0x08014613
 80140ec:	080145a3 	.word	0x080145a3
 80140f0:	08014629 	.word	0x08014629
 80140f4:	08014643 	.word	0x08014643
 80140f8:	08014643 	.word	0x08014643
 80140fc:	08014643 	.word	0x08014643
 8014100:	08014643 	.word	0x08014643

        case oidHashType:
            switch (id) {
 8014104:	68fb      	ldr	r3, [r7, #12]
 8014106:	f5b3 7fcf 	cmp.w	r3, #414	@ 0x19e
 801410a:	d105      	bne.n	8014118 <OidFromId+0x88>
                    *oidSz = sizeof(hashSha224hOid);
                    break;
            #endif
            #ifndef NO_SHA256
                case SHA256h:
                    oid = hashSha256hOid;
 801410c:	4bb6      	ldr	r3, [pc, #728]	@ (80143e8 <OidFromId+0x358>)
 801410e:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(hashSha256hOid);
 8014110:	687b      	ldr	r3, [r7, #4]
 8014112:	2209      	movs	r2, #9
 8014114:	601a      	str	r2, [r3, #0]
                    break;
 8014116:	e000      	b.n	801411a <OidFromId+0x8a>
                    *oidSz = sizeof(hashSha3_512hOid);
                    break;
            #endif /* WOLFSSL_NOSHA3_512 */
            #endif /* WOLFSSL_SHA3 */
                default:
                    break;
 8014118:	bf00      	nop
            }
            break;
 801411a:	e293      	b.n	8014644 <OidFromId+0x5b4>

        case oidSigType:
            switch (id) {
 801411c:	68fb      	ldr	r3, [r7, #12]
 801411e:	f240 228f 	movw	r2, #655	@ 0x28f
 8014122:	4293      	cmp	r3, r2
 8014124:	d00d      	beq.n	8014142 <OidFromId+0xb2>
 8014126:	68fb      	ldr	r3, [r7, #12]
 8014128:	f5b3 7f24 	cmp.w	r3, #656	@ 0x290
 801412c:	d21b      	bcs.n	8014166 <OidFromId+0xd6>
 801412e:	68fb      	ldr	r3, [r7, #12]
 8014130:	f5b3 7f03 	cmp.w	r3, #524	@ 0x20c
 8014134:	d011      	beq.n	801415a <OidFromId+0xca>
 8014136:	68fb      	ldr	r3, [r7, #12]
 8014138:	f240 228e 	movw	r2, #654	@ 0x28e
 801413c:	4293      	cmp	r3, r2
 801413e:	d006      	beq.n	801414e <OidFromId+0xbe>
                    oid = sigSphincsSmall_Level5Oid;
                    *oidSz = sizeof(sigSphincsSmall_Level5Oid);
                    break;
                #endif /* HAVE_SPHINCS */
                default:
                    break;
 8014140:	e011      	b.n	8014166 <OidFromId+0xd6>
                    oid = sigSha256wRsaOid;
 8014142:	4baa      	ldr	r3, [pc, #680]	@ (80143ec <OidFromId+0x35c>)
 8014144:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(sigSha256wRsaOid);
 8014146:	687b      	ldr	r3, [r7, #4]
 8014148:	2209      	movs	r2, #9
 801414a:	601a      	str	r2, [r3, #0]
                    break;
 801414c:	e00c      	b.n	8014168 <OidFromId+0xd8>
                    oid = sigRsaSsaPssOid;
 801414e:	4ba8      	ldr	r3, [pc, #672]	@ (80143f0 <OidFromId+0x360>)
 8014150:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(sigRsaSsaPssOid);
 8014152:	687b      	ldr	r3, [r7, #4]
 8014154:	2209      	movs	r2, #9
 8014156:	601a      	str	r2, [r3, #0]
                    break;
 8014158:	e006      	b.n	8014168 <OidFromId+0xd8>
                    oid = sigSha256wEcdsaOid;
 801415a:	4ba6      	ldr	r3, [pc, #664]	@ (80143f4 <OidFromId+0x364>)
 801415c:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(sigSha256wEcdsaOid);
 801415e:	687b      	ldr	r3, [r7, #4]
 8014160:	2208      	movs	r2, #8
 8014162:	601a      	str	r2, [r3, #0]
                    break;
 8014164:	e000      	b.n	8014168 <OidFromId+0xd8>
                    break;
 8014166:	bf00      	nop
            }
            break;
 8014168:	e26c      	b.n	8014644 <OidFromId+0x5b4>

        case oidKeyType:
            switch (id) {
 801416a:	68fb      	ldr	r3, [r7, #12]
 801416c:	f240 228e 	movw	r2, #654	@ 0x28e
 8014170:	4293      	cmp	r3, r2
 8014172:	d01d      	beq.n	80141b0 <OidFromId+0x120>
 8014174:	68fb      	ldr	r3, [r7, #12]
 8014176:	f240 228e 	movw	r2, #654	@ 0x28e
 801417a:	4293      	cmp	r3, r2
 801417c:	d82a      	bhi.n	80141d4 <OidFromId+0x144>
 801417e:	68fb      	ldr	r3, [r7, #12]
 8014180:	f240 2287 	movw	r2, #647	@ 0x287
 8014184:	4293      	cmp	r3, r2
 8014186:	d01f      	beq.n	80141c8 <OidFromId+0x138>
 8014188:	68fb      	ldr	r3, [r7, #12]
 801418a:	f5b3 7f22 	cmp.w	r3, #648	@ 0x288
 801418e:	d221      	bcs.n	80141d4 <OidFromId+0x144>
 8014190:	68fb      	ldr	r3, [r7, #12]
 8014192:	f240 2206 	movw	r2, #518	@ 0x206
 8014196:	4293      	cmp	r3, r2
 8014198:	d010      	beq.n	80141bc <OidFromId+0x12c>
 801419a:	68fb      	ldr	r3, [r7, #12]
 801419c:	f240 2285 	movw	r2, #645	@ 0x285
 80141a0:	4293      	cmp	r3, r2
 80141a2:	d117      	bne.n	80141d4 <OidFromId+0x144>
                    *oidSz = sizeof(keyDsaOid);
                    break;
                #endif /* NO_DSA */
            #ifndef NO_RSA
                case RSAk:
                    oid = keyRsaOid;
 80141a4:	4b94      	ldr	r3, [pc, #592]	@ (80143f8 <OidFromId+0x368>)
 80141a6:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(keyRsaOid);
 80141a8:	687b      	ldr	r3, [r7, #4]
 80141aa:	2209      	movs	r2, #9
 80141ac:	601a      	str	r2, [r3, #0]
                    break;
 80141ae:	e012      	b.n	80141d6 <OidFromId+0x146>
                #ifdef WC_RSA_PSS
                case RSAPSSk:
                    oid = keyRsaPssOid;
 80141b0:	4b92      	ldr	r3, [pc, #584]	@ (80143fc <OidFromId+0x36c>)
 80141b2:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(keyRsaPssOid);
 80141b4:	687b      	ldr	r3, [r7, #4]
 80141b6:	2209      	movs	r2, #9
 80141b8:	601a      	str	r2, [r3, #0]
                    break;
 80141ba:	e00c      	b.n	80141d6 <OidFromId+0x146>
                #endif
            #endif /* NO_RSA */
                #ifdef HAVE_ECC
                case ECDSAk:
                    oid = keyEcdsaOid;
 80141bc:	4b90      	ldr	r3, [pc, #576]	@ (8014400 <OidFromId+0x370>)
 80141be:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(keyEcdsaOid);
 80141c0:	687b      	ldr	r3, [r7, #4]
 80141c2:	2207      	movs	r2, #7
 80141c4:	601a      	str	r2, [r3, #0]
                    break;
 80141c6:	e006      	b.n	80141d6 <OidFromId+0x146>
                    *oidSz = sizeof(keyCurve448Oid);
                    break;
                #endif /* HAVE_CURVE448 */
                #ifndef NO_DH
                case DHk:
                    oid = keyDhOid;
 80141c8:	4b8e      	ldr	r3, [pc, #568]	@ (8014404 <OidFromId+0x374>)
 80141ca:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(keyDhOid);
 80141cc:	687b      	ldr	r3, [r7, #4]
 80141ce:	2209      	movs	r2, #9
 80141d0:	601a      	str	r2, [r3, #0]
                    break;
 80141d2:	e000      	b.n	80141d6 <OidFromId+0x146>
                    oid = keySphincsSmall_Level5Oid;
                    *oidSz = sizeof(keySphincsSmall_Level5Oid);
                    break;
                #endif /* HAVE_SPHINCS */
                default:
                    break;
 80141d4:	bf00      	nop
            }
            break;
 80141d6:	e235      	b.n	8014644 <OidFromId+0x5b4>

        #ifdef HAVE_ECC
        case oidCurveType:
            if (wc_ecc_get_oid(id, &oid, oidSz) < 0) {
 80141d8:	f107 0314 	add.w	r3, r7, #20
 80141dc:	687a      	ldr	r2, [r7, #4]
 80141de:	4619      	mov	r1, r3
 80141e0:	68f8      	ldr	r0, [r7, #12]
 80141e2:	f00a f869 	bl	801e2b8 <wc_ecc_get_oid>
                WOLFSSL_MSG("ECC OID not found");
            }
            break;
 80141e6:	e22d      	b.n	8014644 <OidFromId+0x5b4>
        #endif /* HAVE_ECC */

        case oidBlkType:
            switch (id) {
 80141e8:	68fb      	ldr	r3, [r7, #12]
 80141ea:	f5a3 73cf 	sub.w	r3, r3, #414	@ 0x19e
 80141ee:	2b2c      	cmp	r3, #44	@ 0x2c
 80141f0:	f200 8082 	bhi.w	80142f8 <OidFromId+0x268>
 80141f4:	a201      	add	r2, pc, #4	@ (adr r2, 80141fc <OidFromId+0x16c>)
 80141f6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80141fa:	bf00      	nop
 80141fc:	080142b1 	.word	0x080142b1
 8014200:	080142f9 	.word	0x080142f9
 8014204:	080142f9 	.word	0x080142f9
 8014208:	080142f9 	.word	0x080142f9
 801420c:	080142d5 	.word	0x080142d5
 8014210:	080142f9 	.word	0x080142f9
 8014214:	080142f9 	.word	0x080142f9
 8014218:	080142f9 	.word	0x080142f9
 801421c:	080142f9 	.word	0x080142f9
 8014220:	080142f9 	.word	0x080142f9
 8014224:	080142f9 	.word	0x080142f9
 8014228:	080142f9 	.word	0x080142f9
 801422c:	080142f9 	.word	0x080142f9
 8014230:	080142f9 	.word	0x080142f9
 8014234:	080142f9 	.word	0x080142f9
 8014238:	080142f9 	.word	0x080142f9
 801423c:	080142f9 	.word	0x080142f9
 8014240:	080142f9 	.word	0x080142f9
 8014244:	080142f9 	.word	0x080142f9
 8014248:	080142f9 	.word	0x080142f9
 801424c:	080142bd 	.word	0x080142bd
 8014250:	080142f9 	.word	0x080142f9
 8014254:	080142f9 	.word	0x080142f9
 8014258:	080142f9 	.word	0x080142f9
 801425c:	080142e1 	.word	0x080142e1
 8014260:	080142f9 	.word	0x080142f9
 8014264:	080142f9 	.word	0x080142f9
 8014268:	080142f9 	.word	0x080142f9
 801426c:	080142f9 	.word	0x080142f9
 8014270:	080142f9 	.word	0x080142f9
 8014274:	080142f9 	.word	0x080142f9
 8014278:	080142f9 	.word	0x080142f9
 801427c:	080142f9 	.word	0x080142f9
 8014280:	080142f9 	.word	0x080142f9
 8014284:	080142f9 	.word	0x080142f9
 8014288:	080142f9 	.word	0x080142f9
 801428c:	080142f9 	.word	0x080142f9
 8014290:	080142f9 	.word	0x080142f9
 8014294:	080142f9 	.word	0x080142f9
 8014298:	080142f9 	.word	0x080142f9
 801429c:	080142c9 	.word	0x080142c9
 80142a0:	080142f9 	.word	0x080142f9
 80142a4:	080142f9 	.word	0x080142f9
 80142a8:	080142f9 	.word	0x080142f9
 80142ac:	080142ed 	.word	0x080142ed
    #ifdef HAVE_AES_CBC
        #ifdef WOLFSSL_AES_128
                case AES128CBCb:
                    oid = blkAes128CbcOid;
 80142b0:	4b55      	ldr	r3, [pc, #340]	@ (8014408 <OidFromId+0x378>)
 80142b2:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(blkAes128CbcOid);
 80142b4:	687b      	ldr	r3, [r7, #4]
 80142b6:	2209      	movs	r2, #9
 80142b8:	601a      	str	r2, [r3, #0]
                    break;
 80142ba:	e01e      	b.n	80142fa <OidFromId+0x26a>
        #endif
        #ifdef WOLFSSL_AES_192
                case AES192CBCb:
                    oid = blkAes192CbcOid;
 80142bc:	4b53      	ldr	r3, [pc, #332]	@ (801440c <OidFromId+0x37c>)
 80142be:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(blkAes192CbcOid);
 80142c0:	687b      	ldr	r3, [r7, #4]
 80142c2:	2209      	movs	r2, #9
 80142c4:	601a      	str	r2, [r3, #0]
                    break;
 80142c6:	e018      	b.n	80142fa <OidFromId+0x26a>
        #endif
        #ifdef WOLFSSL_AES_256
                case AES256CBCb:
                    oid = blkAes256CbcOid;
 80142c8:	4b51      	ldr	r3, [pc, #324]	@ (8014410 <OidFromId+0x380>)
 80142ca:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(blkAes256CbcOid);
 80142cc:	687b      	ldr	r3, [r7, #4]
 80142ce:	2209      	movs	r2, #9
 80142d0:	601a      	str	r2, [r3, #0]
                    break;
 80142d2:	e012      	b.n	80142fa <OidFromId+0x26a>
        #endif
    #endif /* HAVE_AES_CBC */
    #ifdef HAVE_AESGCM
        #ifdef WOLFSSL_AES_128
                case AES128GCMb:
                    oid = blkAes128GcmOid;
 80142d4:	4b4f      	ldr	r3, [pc, #316]	@ (8014414 <OidFromId+0x384>)
 80142d6:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(blkAes128GcmOid);
 80142d8:	687b      	ldr	r3, [r7, #4]
 80142da:	2209      	movs	r2, #9
 80142dc:	601a      	str	r2, [r3, #0]
                    break;
 80142de:	e00c      	b.n	80142fa <OidFromId+0x26a>
        #endif
        #ifdef WOLFSSL_AES_192
                case AES192GCMb:
                    oid = blkAes192GcmOid;
 80142e0:	4b4d      	ldr	r3, [pc, #308]	@ (8014418 <OidFromId+0x388>)
 80142e2:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(blkAes192GcmOid);
 80142e4:	687b      	ldr	r3, [r7, #4]
 80142e6:	2209      	movs	r2, #9
 80142e8:	601a      	str	r2, [r3, #0]
                    break;
 80142ea:	e006      	b.n	80142fa <OidFromId+0x26a>
        #endif
        #ifdef WOLFSSL_AES_256
                case AES256GCMb:
                    oid = blkAes256GcmOid;
 80142ec:	4b4b      	ldr	r3, [pc, #300]	@ (801441c <OidFromId+0x38c>)
 80142ee:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(blkAes256GcmOid);
 80142f0:	687b      	ldr	r3, [r7, #4]
 80142f2:	2209      	movs	r2, #9
 80142f4:	601a      	str	r2, [r3, #0]
                    break;
 80142f6:	e000      	b.n	80142fa <OidFromId+0x26a>
                    oid = blkDes3CbcOid;
                    *oidSz = sizeof(blkDes3CbcOid);
                    break;
    #endif /* !NO_DES3 */
                default:
                    break;
 80142f8:	bf00      	nop
            }
            break;
 80142fa:	e1a3      	b.n	8014644 <OidFromId+0x5b4>
            }
            break;
        #endif /* HAVE_OCSP */

        case oidCertExtType:
            switch (id) {
 80142fc:	68fb      	ldr	r3, [r7, #12]
 80142fe:	2b45      	cmp	r3, #69	@ 0x45
 8014300:	f000 8098 	beq.w	8014434 <OidFromId+0x3a4>
 8014304:	68fb      	ldr	r3, [r7, #12]
 8014306:	2b45      	cmp	r3, #69	@ 0x45
 8014308:	f0c0 80c4 	bcc.w	8014494 <OidFromId+0x404>
 801430c:	68fb      	ldr	r3, [r7, #12]
 801430e:	2ba8      	cmp	r3, #168	@ 0xa8
 8014310:	f200 80c0 	bhi.w	8014494 <OidFromId+0x404>
 8014314:	68fb      	ldr	r3, [r7, #12]
 8014316:	2b80      	cmp	r3, #128	@ 0x80
 8014318:	f0c0 80bc 	bcc.w	8014494 <OidFromId+0x404>
 801431c:	68fb      	ldr	r3, [r7, #12]
 801431e:	3b80      	subs	r3, #128	@ 0x80
 8014320:	2b28      	cmp	r3, #40	@ 0x28
 8014322:	f200 80b7 	bhi.w	8014494 <OidFromId+0x404>
 8014326:	a201      	add	r2, pc, #4	@ (adr r2, 801432c <OidFromId+0x29c>)
 8014328:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801432c:	0801444d 	.word	0x0801444d
 8014330:	08014465 	.word	0x08014465
 8014334:	08014495 	.word	0x08014495
 8014338:	080143dd 	.word	0x080143dd
 801433c:	08014495 	.word	0x08014495
 8014340:	080143d1 	.word	0x080143d1
 8014344:	08014495 	.word	0x08014495
 8014348:	08014495 	.word	0x08014495
 801434c:	08014495 	.word	0x08014495
 8014350:	08014495 	.word	0x08014495
 8014354:	08014495 	.word	0x08014495
 8014358:	08014495 	.word	0x08014495
 801435c:	08014495 	.word	0x08014495
 8014360:	08014495 	.word	0x08014495
 8014364:	08014495 	.word	0x08014495
 8014368:	08014495 	.word	0x08014495
 801436c:	08014489 	.word	0x08014489
 8014370:	08014429 	.word	0x08014429
 8014374:	08014459 	.word	0x08014459
 8014378:	08014495 	.word	0x08014495
 801437c:	08014495 	.word	0x08014495
 8014380:	08014441 	.word	0x08014441
 8014384:	08014495 	.word	0x08014495
 8014388:	0801447d 	.word	0x0801447d
 801438c:	08014495 	.word	0x08014495
 8014390:	08014495 	.word	0x08014495
 8014394:	08014495 	.word	0x08014495
 8014398:	08014495 	.word	0x08014495
 801439c:	08014495 	.word	0x08014495
 80143a0:	08014495 	.word	0x08014495
 80143a4:	08014495 	.word	0x08014495
 80143a8:	08014495 	.word	0x08014495
 80143ac:	08014495 	.word	0x08014495
 80143b0:	08014495 	.word	0x08014495
 80143b4:	08014495 	.word	0x08014495
 80143b8:	08014495 	.word	0x08014495
 80143bc:	08014495 	.word	0x08014495
 80143c0:	08014495 	.word	0x08014495
 80143c4:	08014495 	.word	0x08014495
 80143c8:	08014495 	.word	0x08014495
 80143cc:	08014471 	.word	0x08014471
                case BASIC_CA_OID:
                    oid = extBasicCaOid;
 80143d0:	4b13      	ldr	r3, [pc, #76]	@ (8014420 <OidFromId+0x390>)
 80143d2:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extBasicCaOid);
 80143d4:	687b      	ldr	r3, [r7, #4]
 80143d6:	2203      	movs	r2, #3
 80143d8:	601a      	str	r2, [r3, #0]
                    break;
 80143da:	e05c      	b.n	8014496 <OidFromId+0x406>
                case ALT_NAMES_OID:
                    oid = extAltNamesOid;
 80143dc:	4b11      	ldr	r3, [pc, #68]	@ (8014424 <OidFromId+0x394>)
 80143de:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extAltNamesOid);
 80143e0:	687b      	ldr	r3, [r7, #4]
 80143e2:	2203      	movs	r2, #3
 80143e4:	601a      	str	r2, [r3, #0]
                    break;
 80143e6:	e056      	b.n	8014496 <OidFromId+0x406>
 80143e8:	08033598 	.word	0x08033598
 80143ec:	080335ac 	.word	0x080335ac
 80143f0:	080335b8 	.word	0x080335b8
 80143f4:	080335c4 	.word	0x080335c4
 80143f8:	080335cc 	.word	0x080335cc
 80143fc:	080335d8 	.word	0x080335d8
 8014400:	080335e4 	.word	0x080335e4
 8014404:	080335ec 	.word	0x080335ec
 8014408:	080335f8 	.word	0x080335f8
 801440c:	08033604 	.word	0x08033604
 8014410:	08033610 	.word	0x08033610
 8014414:	0803361c 	.word	0x0803361c
 8014418:	08033628 	.word	0x08033628
 801441c:	08033634 	.word	0x08033634
 8014420:	0803366c 	.word	0x0803366c
 8014424:	08033670 	.word	0x08033670
                case CRL_DIST_OID:
                    oid = extCrlDistOid;
 8014428:	4b89      	ldr	r3, [pc, #548]	@ (8014650 <OidFromId+0x5c0>)
 801442a:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extCrlDistOid);
 801442c:	687b      	ldr	r3, [r7, #4]
 801442e:	2203      	movs	r2, #3
 8014430:	601a      	str	r2, [r3, #0]
                    break;
 8014432:	e030      	b.n	8014496 <OidFromId+0x406>
                case AUTH_INFO_OID:
                    oid = extAuthInfoOid;
 8014434:	4b87      	ldr	r3, [pc, #540]	@ (8014654 <OidFromId+0x5c4>)
 8014436:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extAuthInfoOid);
 8014438:	687b      	ldr	r3, [r7, #4]
 801443a:	2208      	movs	r2, #8
 801443c:	601a      	str	r2, [r3, #0]
                    break;
 801443e:	e02a      	b.n	8014496 <OidFromId+0x406>
                case AUTH_KEY_OID:
                    oid = extAuthKeyOid;
 8014440:	4b85      	ldr	r3, [pc, #532]	@ (8014658 <OidFromId+0x5c8>)
 8014442:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extAuthKeyOid);
 8014444:	687b      	ldr	r3, [r7, #4]
 8014446:	2203      	movs	r2, #3
 8014448:	601a      	str	r2, [r3, #0]
                    break;
 801444a:	e024      	b.n	8014496 <OidFromId+0x406>
                case SUBJ_KEY_OID:
                    oid = extSubjKeyOid;
 801444c:	4b83      	ldr	r3, [pc, #524]	@ (801465c <OidFromId+0x5cc>)
 801444e:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extSubjKeyOid);
 8014450:	687b      	ldr	r3, [r7, #4]
 8014452:	2203      	movs	r2, #3
 8014454:	601a      	str	r2, [r3, #0]
                    break;
 8014456:	e01e      	b.n	8014496 <OidFromId+0x406>
                case CERT_POLICY_OID:
                    oid = extCertPolicyOid;
 8014458:	4b81      	ldr	r3, [pc, #516]	@ (8014660 <OidFromId+0x5d0>)
 801445a:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extCertPolicyOid);
 801445c:	687b      	ldr	r3, [r7, #4]
 801445e:	2203      	movs	r2, #3
 8014460:	601a      	str	r2, [r3, #0]
                    break;
 8014462:	e018      	b.n	8014496 <OidFromId+0x406>
                case KEY_USAGE_OID:
                    oid = extKeyUsageOid;
 8014464:	4b7f      	ldr	r3, [pc, #508]	@ (8014664 <OidFromId+0x5d4>)
 8014466:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extKeyUsageOid);
 8014468:	687b      	ldr	r3, [r7, #4]
 801446a:	2203      	movs	r2, #3
 801446c:	601a      	str	r2, [r3, #0]
                    break;
 801446e:	e012      	b.n	8014496 <OidFromId+0x406>
                case INHIBIT_ANY_OID:
                    oid = extInhibitAnyOid;
 8014470:	4b7d      	ldr	r3, [pc, #500]	@ (8014668 <OidFromId+0x5d8>)
 8014472:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extInhibitAnyOid);
 8014474:	687b      	ldr	r3, [r7, #4]
 8014476:	2203      	movs	r2, #3
 8014478:	601a      	str	r2, [r3, #0]
                    break;
 801447a:	e00c      	b.n	8014496 <OidFromId+0x406>
                case EXT_KEY_USAGE_OID:
                    oid = extExtKeyUsageOid;
 801447c:	4b7b      	ldr	r3, [pc, #492]	@ (801466c <OidFromId+0x5dc>)
 801447e:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extExtKeyUsageOid);
 8014480:	687b      	ldr	r3, [r7, #4]
 8014482:	2203      	movs	r2, #3
 8014484:	601a      	str	r2, [r3, #0]
                    break;
 8014486:	e006      	b.n	8014496 <OidFromId+0x406>
            #ifndef IGNORE_NAME_CONSTRAINTS
                case NAME_CONS_OID:
                    oid = extNameConsOid;
 8014488:	4b79      	ldr	r3, [pc, #484]	@ (8014670 <OidFromId+0x5e0>)
 801448a:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extNameConsOid);
 801448c:	687b      	ldr	r3, [r7, #4]
 801448e:	2203      	movs	r2, #3
 8014490:	601a      	str	r2, [r3, #0]
                    break;
 8014492:	e000      	b.n	8014496 <OidFromId+0x406>
                    oid = extSubjInfoAccessOid;
                    *oidSz = sizeof(extSubjInfoAccessOid);
                    break;
            #endif
                default:
                    break;
 8014494:	bf00      	nop
            }
            break;
 8014496:	e0d5      	b.n	8014644 <OidFromId+0x5b4>
            }
            #endif
            break;

        case oidCertAuthInfoType:
            switch (id) {
 8014498:	68fb      	ldr	r3, [r7, #12]
 801449a:	2b74      	cmp	r3, #116	@ 0x74
 801449c:	d003      	beq.n	80144a6 <OidFromId+0x416>
 801449e:	68fb      	ldr	r3, [r7, #12]
 80144a0:	2b75      	cmp	r3, #117	@ 0x75
 80144a2:	d006      	beq.n	80144b2 <OidFromId+0x422>
                    oid = extAuthInfoCaRespOid;
                    *oidSz = sizeof(extAuthInfoCaRespOid);
                    break;
                #endif /* WOLFSSL_SUBJ_INFO_ACC */
                default:
                    break;
 80144a4:	e00b      	b.n	80144be <OidFromId+0x42e>
                    oid = extAuthInfoOcspOid;
 80144a6:	4b73      	ldr	r3, [pc, #460]	@ (8014674 <OidFromId+0x5e4>)
 80144a8:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extAuthInfoOcspOid);
 80144aa:	687b      	ldr	r3, [r7, #4]
 80144ac:	2208      	movs	r2, #8
 80144ae:	601a      	str	r2, [r3, #0]
                    break;
 80144b0:	e005      	b.n	80144be <OidFromId+0x42e>
                    oid = extAuthInfoCaIssuerOid;
 80144b2:	4b71      	ldr	r3, [pc, #452]	@ (8014678 <OidFromId+0x5e8>)
 80144b4:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extAuthInfoCaIssuerOid);
 80144b6:	687b      	ldr	r3, [r7, #4]
 80144b8:	2208      	movs	r2, #8
 80144ba:	601a      	str	r2, [r3, #0]
                    break;
 80144bc:	bf00      	nop
            }
            break;
 80144be:	e0c1      	b.n	8014644 <OidFromId+0x5b4>

        case oidCertPolicyType:
            switch (id) {
 80144c0:	68fb      	ldr	r3, [r7, #12]
 80144c2:	2b92      	cmp	r3, #146	@ 0x92
 80144c4:	d105      	bne.n	80144d2 <OidFromId+0x442>
                case CP_ANY_OID:
                    oid = extCertPolicyAnyOid;
 80144c6:	4b6d      	ldr	r3, [pc, #436]	@ (801467c <OidFromId+0x5ec>)
 80144c8:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extCertPolicyAnyOid);
 80144ca:	687b      	ldr	r3, [r7, #4]
 80144cc:	2204      	movs	r2, #4
 80144ce:	601a      	str	r2, [r3, #0]
                    break;
 80144d0:	e000      	b.n	80144d4 <OidFromId+0x444>
                    oid = extCertPolicyFpkiPiviAuthOid;
                    *oidSz = sizeof(extCertPolicyFpkiPiviAuthOid);
                    break;
                #endif /* WOLFSSL_FPKI */
                default:
                    break;
 80144d2:	bf00      	nop
            }
            break;
 80144d4:	e0b6      	b.n	8014644 <OidFromId+0x5b4>

        case oidCertAltNameType:
            switch (id) {
 80144d6:	68fb      	ldr	r3, [r7, #12]
 80144d8:	2b4f      	cmp	r3, #79	@ 0x4f
 80144da:	d105      	bne.n	80144e8 <OidFromId+0x458>
                case HW_NAME_OID:
                    oid = extAltNamesHwNameOid;
 80144dc:	4b68      	ldr	r3, [pc, #416]	@ (8014680 <OidFromId+0x5f0>)
 80144de:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extAltNamesHwNameOid);
 80144e0:	687b      	ldr	r3, [r7, #4]
 80144e2:	2208      	movs	r2, #8
 80144e4:	601a      	str	r2, [r3, #0]
                    break;
 80144e6:	e000      	b.n	80144ea <OidFromId+0x45a>
                default:
                    break;
 80144e8:	bf00      	nop
            }
            break;
 80144ea:	e0ab      	b.n	8014644 <OidFromId+0x5b4>

        case oidCertKeyUseType:
            switch (id) {
 80144ec:	68fb      	ldr	r3, [r7, #12]
 80144ee:	2b4f      	cmp	r3, #79	@ 0x4f
 80144f0:	d81c      	bhi.n	801452c <OidFromId+0x49c>
 80144f2:	68fb      	ldr	r3, [r7, #12]
 80144f4:	2b47      	cmp	r3, #71	@ 0x47
 80144f6:	d346      	bcc.n	8014586 <OidFromId+0x4f6>
 80144f8:	68fb      	ldr	r3, [r7, #12]
 80144fa:	3b47      	subs	r3, #71	@ 0x47
 80144fc:	2b08      	cmp	r3, #8
 80144fe:	d842      	bhi.n	8014586 <OidFromId+0x4f6>
 8014500:	a201      	add	r2, pc, #4	@ (adr r2, 8014508 <OidFromId+0x478>)
 8014502:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8014506:	bf00      	nop
 8014508:	0801453f 	.word	0x0801453f
 801450c:	0801454b 	.word	0x0801454b
 8014510:	08014557 	.word	0x08014557
 8014514:	08014563 	.word	0x08014563
 8014518:	08014587 	.word	0x08014587
 801451c:	08014587 	.word	0x08014587
 8014520:	08014587 	.word	0x08014587
 8014524:	0801456f 	.word	0x0801456f
 8014528:	0801457b 	.word	0x0801457b
 801452c:	68fb      	ldr	r3, [r7, #12]
 801452e:	2b97      	cmp	r3, #151	@ 0x97
 8014530:	d129      	bne.n	8014586 <OidFromId+0x4f6>
                case EKU_ANY_OID:
                    oid = extExtKeyUsageAnyOid;
 8014532:	4b54      	ldr	r3, [pc, #336]	@ (8014684 <OidFromId+0x5f4>)
 8014534:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extExtKeyUsageAnyOid);
 8014536:	687b      	ldr	r3, [r7, #4]
 8014538:	2204      	movs	r2, #4
 801453a:	601a      	str	r2, [r3, #0]
                    break;
 801453c:	e024      	b.n	8014588 <OidFromId+0x4f8>
                case EKU_SERVER_AUTH_OID:
                    oid = extExtKeyUsageServerAuthOid;
 801453e:	4b52      	ldr	r3, [pc, #328]	@ (8014688 <OidFromId+0x5f8>)
 8014540:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extExtKeyUsageServerAuthOid);
 8014542:	687b      	ldr	r3, [r7, #4]
 8014544:	2208      	movs	r2, #8
 8014546:	601a      	str	r2, [r3, #0]
                    break;
 8014548:	e01e      	b.n	8014588 <OidFromId+0x4f8>
                case EKU_CLIENT_AUTH_OID:
                    oid = extExtKeyUsageClientAuthOid;
 801454a:	4b50      	ldr	r3, [pc, #320]	@ (801468c <OidFromId+0x5fc>)
 801454c:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extExtKeyUsageClientAuthOid);
 801454e:	687b      	ldr	r3, [r7, #4]
 8014550:	2208      	movs	r2, #8
 8014552:	601a      	str	r2, [r3, #0]
                    break;
 8014554:	e018      	b.n	8014588 <OidFromId+0x4f8>
                case EKU_CODESIGNING_OID:
                    oid = extExtKeyUsageCodeSigningOid;
 8014556:	4b4e      	ldr	r3, [pc, #312]	@ (8014690 <OidFromId+0x600>)
 8014558:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extExtKeyUsageCodeSigningOid);
 801455a:	687b      	ldr	r3, [r7, #4]
 801455c:	2208      	movs	r2, #8
 801455e:	601a      	str	r2, [r3, #0]
                    break;
 8014560:	e012      	b.n	8014588 <OidFromId+0x4f8>
                case EKU_EMAILPROTECT_OID:
                    oid = extExtKeyUsageEmailProtectOid;
 8014562:	4b4c      	ldr	r3, [pc, #304]	@ (8014694 <OidFromId+0x604>)
 8014564:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extExtKeyUsageEmailProtectOid);
 8014566:	687b      	ldr	r3, [r7, #4]
 8014568:	2208      	movs	r2, #8
 801456a:	601a      	str	r2, [r3, #0]
                    break;
 801456c:	e00c      	b.n	8014588 <OidFromId+0x4f8>
                case EKU_TIMESTAMP_OID:
                    oid = extExtKeyUsageTimestampOid;
 801456e:	4b4a      	ldr	r3, [pc, #296]	@ (8014698 <OidFromId+0x608>)
 8014570:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extExtKeyUsageTimestampOid);
 8014572:	687b      	ldr	r3, [r7, #4]
 8014574:	2208      	movs	r2, #8
 8014576:	601a      	str	r2, [r3, #0]
                    break;
 8014578:	e006      	b.n	8014588 <OidFromId+0x4f8>
                case EKU_OCSP_SIGN_OID:
                    oid = extExtKeyUsageOcspSignOid;
 801457a:	4b48      	ldr	r3, [pc, #288]	@ (801469c <OidFromId+0x60c>)
 801457c:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extExtKeyUsageOcspSignOid);
 801457e:	687b      	ldr	r3, [r7, #4]
 8014580:	2208      	movs	r2, #8
 8014582:	601a      	str	r2, [r3, #0]
                    break;
 8014584:	e000      	b.n	8014588 <OidFromId+0x4f8>
                    oid = extExtKeyUsageSshKpClientAuthOid;
                    *oidSz = sizeof(extExtKeyUsageSshKpClientAuthOid);
                    break;
                #endif /* WOLFSSL_WOLFSSH */
                default:
                    break;
 8014586:	bf00      	nop
            }
            break;
 8014588:	e05c      	b.n	8014644 <OidFromId+0x5b4>

        case oidKdfType:
            switch (id) {
 801458a:	68fb      	ldr	r3, [r7, #12]
 801458c:	f5b3 7f25 	cmp.w	r3, #660	@ 0x294
 8014590:	d105      	bne.n	801459e <OidFromId+0x50e>
                case PBKDF2_OID:
                    oid = pbkdf2Oid;
 8014592:	4b43      	ldr	r3, [pc, #268]	@ (80146a0 <OidFromId+0x610>)
 8014594:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(pbkdf2Oid);
 8014596:	687b      	ldr	r3, [r7, #4]
 8014598:	2209      	movs	r2, #9
 801459a:	601a      	str	r2, [r3, #0]
                    break;
 801459c:	e000      	b.n	80145a0 <OidFromId+0x510>
                default:
                    break;
 801459e:	bf00      	nop
            }
            break;
 80145a0:	e050      	b.n	8014644 <OidFromId+0x5b4>

        case oidPBEType:
            switch (id) {
 80145a2:	68fb      	ldr	r3, [r7, #12]
 80145a4:	2b0d      	cmp	r3, #13
 80145a6:	d004      	beq.n	80145b2 <OidFromId+0x522>
 80145a8:	68fb      	ldr	r3, [r7, #12]
 80145aa:	f240 2295 	movw	r2, #661	@ 0x295
 80145ae:	4293      	cmp	r3, r2
 80145b0:	d105      	bne.n	80145be <OidFromId+0x52e>
                    *oidSz = sizeof(pbe40Rc2Cbc);
                    break;
        #endif
                case PBES2_SUM:
                case PBES2:
                    oid = pbes2;
 80145b2:	4b3c      	ldr	r3, [pc, #240]	@ (80146a4 <OidFromId+0x614>)
 80145b4:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(pbes2);
 80145b6:	687b      	ldr	r3, [r7, #4]
 80145b8:	2209      	movs	r2, #9
 80145ba:	601a      	str	r2, [r3, #0]
                    break;
 80145bc:	e000      	b.n	80145c0 <OidFromId+0x530>
                default:
                    break;
 80145be:	bf00      	nop
            }
            break;
 80145c0:	e040      	b.n	8014644 <OidFromId+0x5b4>

        case oidKeyWrapType:
            switch (id) {
 80145c2:	68fb      	ldr	r3, [r7, #12]
 80145c4:	f240 12c9 	movw	r2, #457	@ 0x1c9
 80145c8:	4293      	cmp	r3, r2
 80145ca:	d01a      	beq.n	8014602 <OidFromId+0x572>
 80145cc:	68fb      	ldr	r3, [r7, #12]
 80145ce:	f5b3 7fe5 	cmp.w	r3, #458	@ 0x1ca
 80145d2:	d21c      	bcs.n	801460e <OidFromId+0x57e>
 80145d4:	68fb      	ldr	r3, [r7, #12]
 80145d6:	f240 12a1 	movw	r2, #417	@ 0x1a1
 80145da:	4293      	cmp	r3, r2
 80145dc:	d005      	beq.n	80145ea <OidFromId+0x55a>
 80145de:	68fb      	ldr	r3, [r7, #12]
 80145e0:	f240 12b5 	movw	r2, #437	@ 0x1b5
 80145e4:	4293      	cmp	r3, r2
 80145e6:	d006      	beq.n	80145f6 <OidFromId+0x566>
                    oid = wrapPwriKekOid;
                    *oidSz = sizeof(wrapPwriKekOid);
                    break;
            #endif
                default:
                    break;
 80145e8:	e011      	b.n	801460e <OidFromId+0x57e>
                    oid = wrapAes128Oid;
 80145ea:	4b2f      	ldr	r3, [pc, #188]	@ (80146a8 <OidFromId+0x618>)
 80145ec:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(wrapAes128Oid);
 80145ee:	687b      	ldr	r3, [r7, #4]
 80145f0:	2209      	movs	r2, #9
 80145f2:	601a      	str	r2, [r3, #0]
                    break;
 80145f4:	e00c      	b.n	8014610 <OidFromId+0x580>
                    oid = wrapAes192Oid;
 80145f6:	4b2d      	ldr	r3, [pc, #180]	@ (80146ac <OidFromId+0x61c>)
 80145f8:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(wrapAes192Oid);
 80145fa:	687b      	ldr	r3, [r7, #4]
 80145fc:	2209      	movs	r2, #9
 80145fe:	601a      	str	r2, [r3, #0]
                    break;
 8014600:	e006      	b.n	8014610 <OidFromId+0x580>
                    oid = wrapAes256Oid;
 8014602:	4b2b      	ldr	r3, [pc, #172]	@ (80146b0 <OidFromId+0x620>)
 8014604:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(wrapAes256Oid);
 8014606:	687b      	ldr	r3, [r7, #4]
 8014608:	2209      	movs	r2, #9
 801460a:	601a      	str	r2, [r3, #0]
                    break;
 801460c:	e000      	b.n	8014610 <OidFromId+0x580>
                    break;
 801460e:	bf00      	nop
            }
            break;
 8014610:	e018      	b.n	8014644 <OidFromId+0x5b4>

        case oidCmsKeyAgreeType:
            switch (id) {
 8014612:	68fb      	ldr	r3, [r7, #12]
 8014614:	2bbd      	cmp	r3, #189	@ 0xbd
 8014616:	d105      	bne.n	8014624 <OidFromId+0x594>
                    *oidSz = sizeof(dhSinglePass_stdDH_sha224kdf_Oid);
                    break;
            #endif
            #ifndef NO_SHA256
                case dhSinglePass_stdDH_sha256kdf_scheme:
                    oid = dhSinglePass_stdDH_sha256kdf_Oid;
 8014618:	4b26      	ldr	r3, [pc, #152]	@ (80146b4 <OidFromId+0x624>)
 801461a:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(dhSinglePass_stdDH_sha256kdf_Oid);
 801461c:	687b      	ldr	r3, [r7, #4]
 801461e:	2206      	movs	r2, #6
 8014620:	601a      	str	r2, [r3, #0]
                    break;
 8014622:	e000      	b.n	8014626 <OidFromId+0x596>
                    oid = dhSinglePass_stdDH_sha512kdf_Oid;
                    *oidSz = sizeof(dhSinglePass_stdDH_sha512kdf_Oid);
                    break;
            #endif
                default:
                    break;
 8014624:	bf00      	nop
            }
            break;
 8014626:	e00d      	b.n	8014644 <OidFromId+0x5b4>

#ifndef NO_HMAC
        case oidHmacType:
            switch (id) {
 8014628:	68fb      	ldr	r3, [r7, #12]
 801462a:	f240 228d 	movw	r2, #653	@ 0x28d
 801462e:	4293      	cmp	r3, r2
 8014630:	d105      	bne.n	801463e <OidFromId+0x5ae>
                    *oidSz = sizeof(hmacSha224Oid);
                    break;
        #endif
        #ifndef NO_SHA256
                case HMAC_SHA256_OID:
                    oid = hmacSha256Oid;
 8014632:	4b21      	ldr	r3, [pc, #132]	@ (80146b8 <OidFromId+0x628>)
 8014634:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(hmacSha256Oid);
 8014636:	687b      	ldr	r3, [r7, #4]
 8014638:	2208      	movs	r2, #8
 801463a:	601a      	str	r2, [r3, #0]
                    break;
 801463c:	e000      	b.n	8014640 <OidFromId+0x5b0>
                    oid = hmacSha512Oid;
                    *oidSz = sizeof(hmacSha512Oid);
                    break;
        #endif
                default:
                    break;
 801463e:	bf00      	nop
            }
            break;
 8014640:	e000      	b.n	8014644 <OidFromId+0x5b4>
            }
            break;
#endif /* WOLFSSL_SUBJ_DIR_ATTR */
        case oidIgnoreType:
        default:
            break;
 8014642:	bf00      	nop
    }

    return oid;
 8014644:	697b      	ldr	r3, [r7, #20]
}
 8014646:	4618      	mov	r0, r3
 8014648:	3718      	adds	r7, #24
 801464a:	46bd      	mov	sp, r7
 801464c:	bd80      	pop	{r7, pc}
 801464e:	bf00      	nop
 8014650:	08033674 	.word	0x08033674
 8014654:	08033678 	.word	0x08033678
 8014658:	08033680 	.word	0x08033680
 801465c:	08033684 	.word	0x08033684
 8014660:	08033688 	.word	0x08033688
 8014664:	0803368c 	.word	0x0803368c
 8014668:	08033690 	.word	0x08033690
 801466c:	08033694 	.word	0x08033694
 8014670:	08033698 	.word	0x08033698
 8014674:	0803369c 	.word	0x0803369c
 8014678:	080336a4 	.word	0x080336a4
 801467c:	080336ac 	.word	0x080336ac
 8014680:	080336b0 	.word	0x080336b0
 8014684:	080336b8 	.word	0x080336b8
 8014688:	080336bc 	.word	0x080336bc
 801468c:	080336c4 	.word	0x080336c4
 8014690:	080336cc 	.word	0x080336cc
 8014694:	080336d4 	.word	0x080336d4
 8014698:	080336dc 	.word	0x080336dc
 801469c:	080336e4 	.word	0x080336e4
 80146a0:	080336f8 	.word	0x080336f8
 80146a4:	08033704 	.word	0x08033704
 80146a8:	08033640 	.word	0x08033640
 80146ac:	0803364c 	.word	0x0803364c
 80146b0:	08033658 	.word	0x08033658
 80146b4:	08033664 	.word	0x08033664
 80146b8:	080335a4 	.word	0x080335a4

080146bc <CheckCurve>:
 * @param [in]  oid  OID id.
 * @return  ECC set id on success.
 * @return  ECC_CURVE_OID_E when OID id is 0 or not supported.
 */
static int CheckCurve(word32 oid)
{
 80146bc:	b580      	push	{r7, lr}
 80146be:	b084      	sub	sp, #16
 80146c0:	af00      	add	r7, sp, #0
 80146c2:	6078      	str	r0, [r7, #4]
    int ret;
    word32 oidSz;

    /* Lookup OID id. */
    ret = wc_ecc_get_oid(oid, NULL, &oidSz);
 80146c4:	f107 0308 	add.w	r3, r7, #8
 80146c8:	461a      	mov	r2, r3
 80146ca:	2100      	movs	r1, #0
 80146cc:	6878      	ldr	r0, [r7, #4]
 80146ce:	f009 fdf3 	bl	801e2b8 <wc_ecc_get_oid>
 80146d2:	60f8      	str	r0, [r7, #12]
    /* Check for error or zero length OID size (can't get OID for encoding). */
    if ((ret < 0) || (oidSz == 0)) {
 80146d4:	68fb      	ldr	r3, [r7, #12]
 80146d6:	2b00      	cmp	r3, #0
 80146d8:	db02      	blt.n	80146e0 <CheckCurve+0x24>
 80146da:	68bb      	ldr	r3, [r7, #8]
 80146dc:	2b00      	cmp	r3, #0
 80146de:	d102      	bne.n	80146e6 <CheckCurve+0x2a>
        WOLFSSL_MSG("CheckCurve not found");
        WOLFSSL_ERROR_VERBOSE(ECC_CURVE_OID_E);
        ret = ECC_CURVE_OID_E;
 80146e0:	f06f 03ab 	mvn.w	r3, #171	@ 0xab
 80146e4:	60fb      	str	r3, [r7, #12]
    }

    /* Return ECC set id or error code. */
    return ret;
 80146e6:	68fb      	ldr	r3, [r7, #12]
}
 80146e8:	4618      	mov	r0, r3
 80146ea:	3710      	adds	r7, #16
 80146ec:	46bd      	mov	sp, r7
 80146ee:	bd80      	pop	{r7, pc}

080146f0 <GetOID>:
 * @return  BUFFER_E when not enough bytes for proper decode. (ASN_DUMP_OID and
 *          HAVE_OID_DECODING)
 */
static int GetOID(const byte* input, word32* inOutIdx, word32* oid,
                  word32 oidType, int length)
{
 80146f0:	b580      	push	{r7, lr}
 80146f2:	b08a      	sub	sp, #40	@ 0x28
 80146f4:	af00      	add	r7, sp, #0
 80146f6:	60f8      	str	r0, [r7, #12]
 80146f8:	60b9      	str	r1, [r7, #8]
 80146fa:	607a      	str	r2, [r7, #4]
 80146fc:	603b      	str	r3, [r7, #0]
    int    ret = 0;
 80146fe:	2300      	movs	r3, #0
 8014700:	627b      	str	r3, [r7, #36]	@ 0x24
    word32 idx = *inOutIdx;
 8014702:	68bb      	ldr	r3, [r7, #8]
 8014704:	681b      	ldr	r3, [r3, #0]
 8014706:	623b      	str	r3, [r7, #32]
#ifndef NO_VERIFY_OID
    word32 actualOidSz;
    const byte* actualOid;
    const byte* checkOid = NULL;
 8014708:	2300      	movs	r3, #0
 801470a:	61fb      	str	r3, [r7, #28]
#endif /* NO_VERIFY_OID */
#if defined(HAVE_SPHINCS)
    word32 found_collision = 0;
#endif
    (void)oidType;
    *oid = 0;
 801470c:	687b      	ldr	r3, [r7, #4]
 801470e:	2200      	movs	r2, #0
 8014710:	601a      	str	r2, [r3, #0]

#ifndef NO_VERIFY_OID
    /* Keep references to OID data and length for check. */
    actualOid = &input[idx];
 8014712:	68fa      	ldr	r2, [r7, #12]
 8014714:	6a3b      	ldr	r3, [r7, #32]
 8014716:	4413      	add	r3, r2
 8014718:	61bb      	str	r3, [r7, #24]
    actualOidSz = (word32)length;
 801471a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801471c:	617b      	str	r3, [r7, #20]
        found_collision = SPHINCS_FAST_LEVEL3k;
    }
#endif /* HAVE_SPHINCS */

    /* Sum it up for now. */
    while (length--) {
 801471e:	e00b      	b.n	8014738 <GetOID+0x48>
        /* odd HC08 compiler behavior here when input[idx++] */
        *oid += (word32)input[idx];
 8014720:	687b      	ldr	r3, [r7, #4]
 8014722:	681b      	ldr	r3, [r3, #0]
 8014724:	68f9      	ldr	r1, [r7, #12]
 8014726:	6a3a      	ldr	r2, [r7, #32]
 8014728:	440a      	add	r2, r1
 801472a:	7812      	ldrb	r2, [r2, #0]
 801472c:	441a      	add	r2, r3
 801472e:	687b      	ldr	r3, [r7, #4]
 8014730:	601a      	str	r2, [r3, #0]
        idx++;
 8014732:	6a3b      	ldr	r3, [r7, #32]
 8014734:	3301      	adds	r3, #1
 8014736:	623b      	str	r3, [r7, #32]
    while (length--) {
 8014738:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801473a:	1e5a      	subs	r2, r3, #1
 801473c:	633a      	str	r2, [r7, #48]	@ 0x30
 801473e:	2b00      	cmp	r3, #0
 8014740:	d1ee      	bne.n	8014720 <GetOID+0x30>
        *oid = found_collision;
    }
#endif /* HAVE_SPHINCS */

    /* Return the index after the OID data. */
    *inOutIdx = idx;
 8014742:	68bb      	ldr	r3, [r7, #8]
 8014744:	6a3a      	ldr	r2, [r7, #32]
 8014746:	601a      	str	r2, [r3, #0]

#ifndef NO_VERIFY_OID
    /* 'Ignore' type means we don't care which OID it is. */
    if (oidType != oidIgnoreType) {
 8014748:	683b      	ldr	r3, [r7, #0]
 801474a:	2b15      	cmp	r3, #21
 801474c:	d01e      	beq.n	801478c <GetOID+0x9c>
        /* Get the OID data for the id-type. */
        checkOid = OidFromId(*oid, oidType, &checkOidSz);
 801474e:	687b      	ldr	r3, [r7, #4]
 8014750:	681b      	ldr	r3, [r3, #0]
 8014752:	f107 0210 	add.w	r2, r7, #16
 8014756:	6839      	ldr	r1, [r7, #0]
 8014758:	4618      	mov	r0, r3
 801475a:	f7ff fc99 	bl	8014090 <OidFromId>
 801475e:	61f8      	str	r0, [r7, #28]
        /* TODO: Want to fail when checkOid is NULL.
         * Can't as too many situations where unknown OID is to be
         * supported. Extra parameter for must not be NULL?
         */
        /* Check that the OID data matches what we found for the OID id. */
        if ((ret == 0) && (checkOid != NULL) && ((checkOidSz != actualOidSz) ||
 8014760:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014762:	2b00      	cmp	r3, #0
 8014764:	d112      	bne.n	801478c <GetOID+0x9c>
 8014766:	69fb      	ldr	r3, [r7, #28]
 8014768:	2b00      	cmp	r3, #0
 801476a:	d00f      	beq.n	801478c <GetOID+0x9c>
 801476c:	693b      	ldr	r3, [r7, #16]
 801476e:	697a      	ldr	r2, [r7, #20]
 8014770:	429a      	cmp	r2, r3
 8014772:	d108      	bne.n	8014786 <GetOID+0x96>
                (XMEMCMP(actualOid, checkOid, checkOidSz) != 0))) {
 8014774:	693b      	ldr	r3, [r7, #16]
 8014776:	461a      	mov	r2, r3
 8014778:	69f9      	ldr	r1, [r7, #28]
 801477a:	69b8      	ldr	r0, [r7, #24]
 801477c:	f013 fe7a 	bl	8028474 <memcmp>
 8014780:	4603      	mov	r3, r0
        if ((ret == 0) && (checkOid != NULL) && ((checkOidSz != actualOidSz) ||
 8014782:	2b00      	cmp	r3, #0
 8014784:	d002      	beq.n	801478c <GetOID+0x9c>
            WOLFSSL_MSG("OID Check Failed");
            WOLFSSL_ERROR_VERBOSE(ASN_UNKNOWN_OID_E);
            ret = ASN_UNKNOWN_OID_E;
 8014786:	f06f 0393 	mvn.w	r3, #147	@ 0x93
 801478a:	627b      	str	r3, [r7, #36]	@ 0x24
        }
    }
#endif /* NO_VERIFY_OID */

    return ret;
 801478c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 801478e:	4618      	mov	r0, r3
 8014790:	3728      	adds	r7, #40	@ 0x28
 8014792:	46bd      	mov	sp, r7
 8014794:	bd80      	pop	{r7, pc}
	...

08014798 <GetAlgoIdImpl>:
#define algoIdASN_Length (sizeof(algoIdASN) / sizeof(ASNItem))
#endif

static int GetAlgoIdImpl(const byte* input, word32* inOutIdx, word32* oid,
                     word32 oidType, word32 maxIdx, byte *absentParams)
{
 8014798:	b580      	push	{r7, lr}
 801479a:	b08c      	sub	sp, #48	@ 0x30
 801479c:	af04      	add	r7, sp, #16
 801479e:	60f8      	str	r0, [r7, #12]
 80147a0:	60b9      	str	r1, [r7, #8]
 80147a2:	607a      	str	r2, [r7, #4]
 80147a4:	603b      	str	r3, [r7, #0]

    *inOutIdx = idx;

    return 0;
#else
    DECL_ASNGETDATA(dataASN, algoIdASN_Length);
 80147a6:	2300      	movs	r3, #0
 80147a8:	61fb      	str	r3, [r7, #28]
    int ret = 0;
 80147aa:	2300      	movs	r3, #0
 80147ac:	61bb      	str	r3, [r7, #24]

    WOLFSSL_ENTER("GetAlgoId");

    CALLOC_ASNGETDATA(dataASN, algoIdASN_Length, ret, NULL);
 80147ae:	69bb      	ldr	r3, [r7, #24]
 80147b0:	2b00      	cmp	r3, #0
 80147b2:	d109      	bne.n	80147c8 <GetAlgoIdImpl+0x30>
 80147b4:	2054      	movs	r0, #84	@ 0x54
 80147b6:	f00a f967 	bl	801ea88 <wolfSSL_Malloc>
 80147ba:	61f8      	str	r0, [r7, #28]
 80147bc:	69fb      	ldr	r3, [r7, #28]
 80147be:	2b00      	cmp	r3, #0
 80147c0:	d102      	bne.n	80147c8 <GetAlgoIdImpl+0x30>
 80147c2:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 80147c6:	61bb      	str	r3, [r7, #24]
 80147c8:	69bb      	ldr	r3, [r7, #24]
 80147ca:	2b00      	cmp	r3, #0
 80147cc:	d104      	bne.n	80147d8 <GetAlgoIdImpl+0x40>
 80147ce:	2254      	movs	r2, #84	@ 0x54
 80147d0:	2100      	movs	r1, #0
 80147d2:	69f8      	ldr	r0, [r7, #28]
 80147d4:	f013 fe78 	bl	80284c8 <memset>
    if (ret == 0) {
 80147d8:	69bb      	ldr	r3, [r7, #24]
 80147da:	2b00      	cmp	r3, #0
 80147dc:	d110      	bne.n	8014800 <GetAlgoIdImpl+0x68>
        /* Set OID type expected. */
        GetASN_OID(&dataASN[ALGOIDASN_IDX_OID], oidType);
 80147de:	69fb      	ldr	r3, [r7, #28]
 80147e0:	331c      	adds	r3, #28
 80147e2:	683a      	ldr	r2, [r7, #0]
 80147e4:	611a      	str	r2, [r3, #16]
        /* Decode the algorithm identifier. */
        ret = GetASN_Items(algoIdASN, dataASN, algoIdASN_Length, 0, input,
 80147e6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80147e8:	9302      	str	r3, [sp, #8]
 80147ea:	68bb      	ldr	r3, [r7, #8]
 80147ec:	9301      	str	r3, [sp, #4]
 80147ee:	68fb      	ldr	r3, [r7, #12]
 80147f0:	9300      	str	r3, [sp, #0]
 80147f2:	2300      	movs	r3, #0
 80147f4:	2203      	movs	r2, #3
 80147f6:	69f9      	ldr	r1, [r7, #28]
 80147f8:	4813      	ldr	r0, [pc, #76]	@ (8014848 <GetAlgoIdImpl+0xb0>)
 80147fa:	f7fe ff81 	bl	8013700 <GetASN_Items>
 80147fe:	61b8      	str	r0, [r7, #24]
            inOutIdx, maxIdx);
    }
    if (ret == 0) {
 8014800:	69bb      	ldr	r3, [r7, #24]
 8014802:	2b00      	cmp	r3, #0
 8014804:	d10f      	bne.n	8014826 <GetAlgoIdImpl+0x8e>
        /* Return the OID id/sum. */
        *oid = dataASN[ALGOIDASN_IDX_OID].data.oid.sum;
 8014806:	69fb      	ldr	r3, [r7, #28]
 8014808:	331c      	adds	r3, #28
 801480a:	695a      	ldr	r2, [r3, #20]
 801480c:	687b      	ldr	r3, [r7, #4]
 801480e:	601a      	str	r2, [r3, #0]

        if ((absentParams != NULL) &&
 8014810:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014812:	2b00      	cmp	r3, #0
 8014814:	d007      	beq.n	8014826 <GetAlgoIdImpl+0x8e>
            (dataASN[ALGOIDASN_IDX_NULL].tag == ASN_TAG_NULL)) {
 8014816:	69fb      	ldr	r3, [r7, #28]
 8014818:	3338      	adds	r3, #56	@ 0x38
 801481a:	7e5b      	ldrb	r3, [r3, #25]
        if ((absentParams != NULL) &&
 801481c:	2b05      	cmp	r3, #5
 801481e:	d102      	bne.n	8014826 <GetAlgoIdImpl+0x8e>
            *absentParams = FALSE;
 8014820:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014822:	2200      	movs	r2, #0
 8014824:	701a      	strb	r2, [r3, #0]
        }
    }

    FREE_ASNGETDATA(dataASN, NULL);
 8014826:	69fb      	ldr	r3, [r7, #28]
 8014828:	2b00      	cmp	r3, #0
 801482a:	d007      	beq.n	801483c <GetAlgoIdImpl+0xa4>
 801482c:	69fb      	ldr	r3, [r7, #28]
 801482e:	617b      	str	r3, [r7, #20]
 8014830:	697b      	ldr	r3, [r7, #20]
 8014832:	2b00      	cmp	r3, #0
 8014834:	d002      	beq.n	801483c <GetAlgoIdImpl+0xa4>
 8014836:	6978      	ldr	r0, [r7, #20]
 8014838:	f00a f942 	bl	801eac0 <wolfSSL_Free>
    return ret;
 801483c:	69bb      	ldr	r3, [r7, #24]
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 801483e:	4618      	mov	r0, r3
 8014840:	3720      	adds	r7, #32
 8014842:	46bd      	mov	sp, r7
 8014844:	bd80      	pop	{r7, pc}
 8014846:	bf00      	nop
 8014848:	08033740 	.word	0x08033740

0801484c <GetAlgoId>:
 * @return  ASN_PARSE_E when encoding is invalid.
 * @return  ASN_UNKNOWN_OID_E when the OID cannot be verified.
 */
int GetAlgoId(const byte* input, word32* inOutIdx, word32* oid,
                     word32 oidType, word32 maxIdx)
{
 801484c:	b580      	push	{r7, lr}
 801484e:	b086      	sub	sp, #24
 8014850:	af02      	add	r7, sp, #8
 8014852:	60f8      	str	r0, [r7, #12]
 8014854:	60b9      	str	r1, [r7, #8]
 8014856:	607a      	str	r2, [r7, #4]
 8014858:	603b      	str	r3, [r7, #0]
    return GetAlgoIdImpl(input, inOutIdx, oid, oidType, maxIdx, NULL);
 801485a:	2300      	movs	r3, #0
 801485c:	9301      	str	r3, [sp, #4]
 801485e:	69bb      	ldr	r3, [r7, #24]
 8014860:	9300      	str	r3, [sp, #0]
 8014862:	683b      	ldr	r3, [r7, #0]
 8014864:	687a      	ldr	r2, [r7, #4]
 8014866:	68b9      	ldr	r1, [r7, #8]
 8014868:	68f8      	ldr	r0, [r7, #12]
 801486a:	f7ff ff95 	bl	8014798 <GetAlgoIdImpl>
 801486e:	4603      	mov	r3, r0
}
 8014870:	4618      	mov	r0, r3
 8014872:	3710      	adds	r7, #16
 8014874:	46bd      	mov	sp, r7
 8014876:	bd80      	pop	{r7, pc}

08014878 <RsaPssHashOidToType>:
 * @param  [out]  type  Hash type.
 * @return  0 on success.
 * @return  ASN_PARSE_E when hash OID not supported for RSA PSS.
 */
static int RsaPssHashOidToType(word32 oid, enum wc_HashType* type)
{
 8014878:	b480      	push	{r7}
 801487a:	b085      	sub	sp, #20
 801487c:	af00      	add	r7, sp, #0
 801487e:	6078      	str	r0, [r7, #4]
 8014880:	6039      	str	r1, [r7, #0]
    int ret = 0;
 8014882:	2300      	movs	r3, #0
 8014884:	60fb      	str	r3, [r7, #12]

    switch (oid) {
 8014886:	687b      	ldr	r3, [r7, #4]
 8014888:	f5b3 7fcf 	cmp.w	r3, #414	@ 0x19e
 801488c:	d103      	bne.n	8014896 <RsaPssHashOidToType+0x1e>
        *type = WC_HASH_TYPE_SHA224;
        break;
#endif
#ifndef NO_SHA256
    case SHA256h:
        *type = WC_HASH_TYPE_SHA256;
 801488e:	683b      	ldr	r3, [r7, #0]
 8014890:	2206      	movs	r2, #6
 8014892:	701a      	strb	r2, [r3, #0]
        break;
 8014894:	e003      	b.n	801489e <RsaPssHashOidToType+0x26>
        break;
    /* TODO: SHA512_224h */
    /* TODO: SHA512_256h */
#endif
    default:
        ret = ASN_PARSE_E;
 8014896:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801489a:	60fb      	str	r3, [r7, #12]
        break;
 801489c:	bf00      	nop
    }

    return ret;
 801489e:	68fb      	ldr	r3, [r7, #12]
}
 80148a0:	4618      	mov	r0, r3
 80148a2:	3714      	adds	r7, #20
 80148a4:	46bd      	mov	sp, r7
 80148a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80148aa:	4770      	bx	lr

080148ac <RsaPssHashOidToMgf1>:
 * @param  [out]  mgf   MGF type.
 * @return  0 on success.
 * @return  ASN_PARSE_E when hash OID not supported for RSA PSS.
 */
static int RsaPssHashOidToMgf1(word32 oid, int* mgf)
{
 80148ac:	b480      	push	{r7}
 80148ae:	b085      	sub	sp, #20
 80148b0:	af00      	add	r7, sp, #0
 80148b2:	6078      	str	r0, [r7, #4]
 80148b4:	6039      	str	r1, [r7, #0]
    int ret = 0;
 80148b6:	2300      	movs	r3, #0
 80148b8:	60fb      	str	r3, [r7, #12]

    switch (oid) {
 80148ba:	687b      	ldr	r3, [r7, #4]
 80148bc:	f5b3 7fcf 	cmp.w	r3, #414	@ 0x19e
 80148c0:	d103      	bne.n	80148ca <RsaPssHashOidToMgf1+0x1e>
        *mgf = WC_MGF1SHA224;
        break;
#endif
#ifndef NO_SHA256
    case SHA256h:
        *mgf = WC_MGF1SHA256;
 80148c2:	683b      	ldr	r3, [r7, #0]
 80148c4:	2201      	movs	r2, #1
 80148c6:	601a      	str	r2, [r3, #0]
        break;
 80148c8:	e003      	b.n	80148d2 <RsaPssHashOidToMgf1+0x26>
        break;
    /* TODO: SHA512_224h */
    /* TODO: SHA512_256h */
#endif
    default:
        ret = ASN_PARSE_E;
 80148ca:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80148ce:	60fb      	str	r3, [r7, #12]
        break;
 80148d0:	bf00      	nop
    }

    return ret;
 80148d2:	68fb      	ldr	r3, [r7, #12]
}
 80148d4:	4618      	mov	r0, r3
 80148d6:	3714      	adds	r7, #20
 80148d8:	46bd      	mov	sp, r7
 80148da:	f85d 7b04 	ldr.w	r7, [sp], #4
 80148de:	4770      	bx	lr

080148e0 <RsaPssHashOidToSigOid>:
 * @param  [out]  sigOid  Signature OID to pass wto HashForSignature().
 * @return  0 on success.
 * @return  ASN_PARSE_E when hash OID not supported for RSA PSS.
 */
static int RsaPssHashOidToSigOid(word32 oid, word32* sigOid)
{
 80148e0:	b480      	push	{r7}
 80148e2:	b085      	sub	sp, #20
 80148e4:	af00      	add	r7, sp, #0
 80148e6:	6078      	str	r0, [r7, #4]
 80148e8:	6039      	str	r1, [r7, #0]
    int ret = 0;
 80148ea:	2300      	movs	r3, #0
 80148ec:	60fb      	str	r3, [r7, #12]

    switch (oid) {
 80148ee:	687b      	ldr	r3, [r7, #4]
 80148f0:	2b06      	cmp	r3, #6
 80148f2:	d104      	bne.n	80148fe <RsaPssHashOidToSigOid+0x1e>
        *sigOid = CTC_SHA224wRSA;
        break;
#endif
#ifndef NO_SHA256
    case WC_HASH_TYPE_SHA256:
        *sigOid = CTC_SHA256wRSA;
 80148f4:	683b      	ldr	r3, [r7, #0]
 80148f6:	f240 228f 	movw	r2, #655	@ 0x28f
 80148fa:	601a      	str	r2, [r3, #0]
        break;
 80148fc:	e003      	b.n	8014906 <RsaPssHashOidToSigOid+0x26>
#endif
    /* TODO: SHA512_224h */
    /* TODO: SHA512_256h */
    /* Not supported by HashForSignature() */
    default:
        ret = ASN_PARSE_E;
 80148fe:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8014902:	60fb      	str	r3, [r7, #12]
        break;
 8014904:	bf00      	nop
    }

    return ret;
 8014906:	68fb      	ldr	r3, [r7, #12]
}
 8014908:	4618      	mov	r0, r3
 801490a:	3714      	adds	r7, #20
 801490c:	46bd      	mov	sp, r7
 801490e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014912:	4770      	bx	lr

08014914 <DecodeRsaPssParams>:
 * @return  ASN_PARSE_E when the decoding fails.
 * @return  0 on success.
 */
static int DecodeRsaPssParams(const byte* params, word32 sz,
    enum wc_HashType* hash, int* mgf, int* saltLen)
{
 8014914:	b580      	push	{r7, lr}
 8014916:	b090      	sub	sp, #64	@ 0x40
 8014918:	af04      	add	r7, sp, #16
 801491a:	60f8      	str	r0, [r7, #12]
 801491c:	60b9      	str	r1, [r7, #8]
 801491e:	607a      	str	r2, [r7, #4]
 8014920:	603b      	str	r3, [r7, #0]
        ret = ASN_PARSE_E;
    }

    return ret;
#else
    DECL_ASNGETDATA(dataASN, rsaPssParamsASN_Length);
 8014922:	2300      	movs	r3, #0
 8014924:	62fb      	str	r3, [r7, #44]	@ 0x2c
    int ret = 0;
 8014926:	2300      	movs	r3, #0
 8014928:	62bb      	str	r3, [r7, #40]	@ 0x28
    word16 sLen = 20;
 801492a:	2314      	movs	r3, #20
 801492c:	837b      	strh	r3, [r7, #26]

    if (params == NULL) {
 801492e:	68fb      	ldr	r3, [r7, #12]
 8014930:	2b00      	cmp	r3, #0
 8014932:	d102      	bne.n	801493a <DecodeRsaPssParams+0x26>
        ret = BAD_FUNC_ARG;
 8014934:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8014938:	62bb      	str	r3, [r7, #40]	@ 0x28
    }

    CALLOC_ASNGETDATA(dataASN, rsaPssParamsASN_Length, ret, NULL);
 801493a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801493c:	2b00      	cmp	r3, #0
 801493e:	d10a      	bne.n	8014956 <DecodeRsaPssParams+0x42>
 8014940:	f44f 70d2 	mov.w	r0, #420	@ 0x1a4
 8014944:	f00a f8a0 	bl	801ea88 <wolfSSL_Malloc>
 8014948:	62f8      	str	r0, [r7, #44]	@ 0x2c
 801494a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801494c:	2b00      	cmp	r3, #0
 801494e:	d102      	bne.n	8014956 <DecodeRsaPssParams+0x42>
 8014950:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8014954:	62bb      	str	r3, [r7, #40]	@ 0x28
 8014956:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014958:	2b00      	cmp	r3, #0
 801495a:	d105      	bne.n	8014968 <DecodeRsaPssParams+0x54>
 801495c:	f44f 72d2 	mov.w	r2, #420	@ 0x1a4
 8014960:	2100      	movs	r1, #0
 8014962:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8014964:	f013 fdb0 	bl	80284c8 <memset>
    if (ret == 0) {
 8014968:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801496a:	2b00      	cmp	r3, #0
 801496c:	d128      	bne.n	80149c0 <DecodeRsaPssParams+0xac>
        word32 inOutIdx = 0;
 801496e:	2300      	movs	r3, #0
 8014970:	617b      	str	r3, [r7, #20]
        /* Default values. */
        *hash = WC_HASH_TYPE_SHA;
 8014972:	687b      	ldr	r3, [r7, #4]
 8014974:	2204      	movs	r2, #4
 8014976:	701a      	strb	r2, [r3, #0]
        *mgf = WC_MGF1SHA1;
 8014978:	683b      	ldr	r3, [r7, #0]
 801497a:	221a      	movs	r2, #26
 801497c:	601a      	str	r2, [r3, #0]

        /* Set OID type expected. */
        GetASN_OID(&dataASN[RSAPSSPARAMSASN_IDX_HASHOID], oidHashType);
 801497e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014980:	3354      	adds	r3, #84	@ 0x54
 8014982:	2200      	movs	r2, #0
 8014984:	611a      	str	r2, [r3, #16]
        GetASN_OID(&dataASN[RSAPSSPARAMSASN_IDX_MGFHOID], oidHashType);
 8014986:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014988:	33fc      	adds	r3, #252	@ 0xfc
 801498a:	2200      	movs	r2, #0
 801498c:	611a      	str	r2, [r3, #16]
        /* Place the salt length into 16-bit var sLen. */
        GetASN_Int16Bit(&dataASN[RSAPSSPARAMSASN_IDX_SALTLENINT], &sLen);
 801498e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014990:	f503 73a8 	add.w	r3, r3, #336	@ 0x150
 8014994:	2202      	movs	r2, #2
 8014996:	761a      	strb	r2, [r3, #24]
 8014998:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801499a:	f503 73a8 	add.w	r3, r3, #336	@ 0x150
 801499e:	f107 021a 	add.w	r2, r7, #26
 80149a2:	609a      	str	r2, [r3, #8]
        /* Decode the algorithm identifier. */
        ret = GetASN_Items(rsaPssParamsASN, dataASN, rsaPssParamsASN_Length, 1,
 80149a4:	68bb      	ldr	r3, [r7, #8]
 80149a6:	9302      	str	r3, [sp, #8]
 80149a8:	f107 0314 	add.w	r3, r7, #20
 80149ac:	9301      	str	r3, [sp, #4]
 80149ae:	68fb      	ldr	r3, [r7, #12]
 80149b0:	9300      	str	r3, [sp, #0]
 80149b2:	2301      	movs	r3, #1
 80149b4:	220f      	movs	r2, #15
 80149b6:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 80149b8:	481e      	ldr	r0, [pc, #120]	@ (8014a34 <DecodeRsaPssParams+0x120>)
 80149ba:	f7fe fea1 	bl	8013700 <GetASN_Items>
 80149be:	62b8      	str	r0, [r7, #40]	@ 0x28
            params, &inOutIdx, sz);
    }
    if ((ret == 0) && (dataASN[RSAPSSPARAMSASN_IDX_HASHOID].tag != 0)) {
 80149c0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80149c2:	2b00      	cmp	r3, #0
 80149c4:	d10d      	bne.n	80149e2 <DecodeRsaPssParams+0xce>
 80149c6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80149c8:	3354      	adds	r3, #84	@ 0x54
 80149ca:	7e5b      	ldrb	r3, [r3, #25]
 80149cc:	2b00      	cmp	r3, #0
 80149ce:	d008      	beq.n	80149e2 <DecodeRsaPssParams+0xce>
        word32 oid = dataASN[RSAPSSPARAMSASN_IDX_HASHOID].data.oid.sum;
 80149d0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80149d2:	3354      	adds	r3, #84	@ 0x54
 80149d4:	695b      	ldr	r3, [r3, #20]
 80149d6:	627b      	str	r3, [r7, #36]	@ 0x24
        ret = RsaPssHashOidToType(oid, hash);
 80149d8:	6879      	ldr	r1, [r7, #4]
 80149da:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 80149dc:	f7ff ff4c 	bl	8014878 <RsaPssHashOidToType>
 80149e0:	62b8      	str	r0, [r7, #40]	@ 0x28
    }
    if ((ret == 0) && (dataASN[RSAPSSPARAMSASN_IDX_MGFHOID].tag != 0)) {
 80149e2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80149e4:	2b00      	cmp	r3, #0
 80149e6:	d10d      	bne.n	8014a04 <DecodeRsaPssParams+0xf0>
 80149e8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80149ea:	33fc      	adds	r3, #252	@ 0xfc
 80149ec:	7e5b      	ldrb	r3, [r3, #25]
 80149ee:	2b00      	cmp	r3, #0
 80149f0:	d008      	beq.n	8014a04 <DecodeRsaPssParams+0xf0>
        word32 oid = dataASN[RSAPSSPARAMSASN_IDX_MGFHOID].data.oid.sum;
 80149f2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80149f4:	33fc      	adds	r3, #252	@ 0xfc
 80149f6:	695b      	ldr	r3, [r3, #20]
 80149f8:	623b      	str	r3, [r7, #32]
        ret = RsaPssHashOidToMgf1(oid, mgf);
 80149fa:	6839      	ldr	r1, [r7, #0]
 80149fc:	6a38      	ldr	r0, [r7, #32]
 80149fe:	f7ff ff55 	bl	80148ac <RsaPssHashOidToMgf1>
 8014a02:	62b8      	str	r0, [r7, #40]	@ 0x28
    }
    if (ret == 0) {
 8014a04:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014a06:	2b00      	cmp	r3, #0
 8014a08:	d103      	bne.n	8014a12 <DecodeRsaPssParams+0xfe>
        *saltLen = sLen;
 8014a0a:	8b7b      	ldrh	r3, [r7, #26]
 8014a0c:	461a      	mov	r2, r3
 8014a0e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8014a10:	601a      	str	r2, [r3, #0]
    }

    FREE_ASNGETDATA(dataASN, NULL);
 8014a12:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014a14:	2b00      	cmp	r3, #0
 8014a16:	d007      	beq.n	8014a28 <DecodeRsaPssParams+0x114>
 8014a18:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014a1a:	61fb      	str	r3, [r7, #28]
 8014a1c:	69fb      	ldr	r3, [r7, #28]
 8014a1e:	2b00      	cmp	r3, #0
 8014a20:	d002      	beq.n	8014a28 <DecodeRsaPssParams+0x114>
 8014a22:	69f8      	ldr	r0, [r7, #28]
 8014a24:	f00a f84c 	bl	801eac0 <wolfSSL_Free>
    return ret;
 8014a28:	6abb      	ldr	r3, [r7, #40]	@ 0x28
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 8014a2a:	4618      	mov	r0, r3
 8014a2c:	3730      	adds	r7, #48	@ 0x30
 8014a2e:	46bd      	mov	sp, r7
 8014a30:	bd80      	pop	{r7, pc}
 8014a32:	bf00      	nop
 8014a34:	0803374c 	.word	0x0803374c

08014a38 <GetRsaInt>:
 * @param [in] idx  Index of number.
 * @return  A pointer to an mp_int when valid index.
 * @return  NULL when invalid index.
 */
static mp_int* GetRsaInt(RsaKey* key, int idx)
{
 8014a38:	b480      	push	{r7}
 8014a3a:	b083      	sub	sp, #12
 8014a3c:	af00      	add	r7, sp, #0
 8014a3e:	6078      	str	r0, [r7, #4]
 8014a40:	6039      	str	r1, [r7, #0]
    /* Cast key to byte array to and use offset to get to mp_int field. */
    return (mp_int*)(((byte*)key) + rsaIntOffset[idx]);
 8014a42:	4a06      	ldr	r2, [pc, #24]	@ (8014a5c <GetRsaInt+0x24>)
 8014a44:	683b      	ldr	r3, [r7, #0]
 8014a46:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8014a4a:	687a      	ldr	r2, [r7, #4]
 8014a4c:	4413      	add	r3, r2
}
 8014a4e:	4618      	mov	r0, r3
 8014a50:	370c      	adds	r7, #12
 8014a52:	46bd      	mov	sp, r7
 8014a54:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014a58:	4770      	bx	lr
 8014a5a:	bf00      	nop
 8014a5c:	200000b0 	.word	0x200000b0

08014a60 <_RsaPrivateKeyDecode>:
 * @return  MP_INIT_E when the unable to initialize an mp_int.
 * @return  ASN_GETINT_E when the unable to convert data to an mp_int.
 */
static int _RsaPrivateKeyDecode(const byte* input, word32* inOutIdx,
    RsaKey* key, int* keySz, word32 inSz)
{
 8014a60:	b590      	push	{r4, r7, lr}
 8014a62:	b091      	sub	sp, #68	@ 0x44
 8014a64:	af04      	add	r7, sp, #16
 8014a66:	60f8      	str	r0, [r7, #12]
 8014a68:	60b9      	str	r1, [r7, #8]
 8014a6a:	607a      	str	r2, [r7, #4]
 8014a6c:	603b      	str	r3, [r7, #0]
    #endif
    }

    return 0;
#else
    DECL_ASNGETDATA(dataASN, rsaKeyASN_Length);
 8014a6e:	2300      	movs	r3, #0
 8014a70:	62fb      	str	r3, [r7, #44]	@ 0x2c
    int        ret = 0;
 8014a72:	2300      	movs	r3, #0
 8014a74:	62bb      	str	r3, [r7, #40]	@ 0x28
    byte       version = (byte)-1;
 8014a76:	23ff      	movs	r3, #255	@ 0xff
 8014a78:	76fb      	strb	r3, [r7, #27]
#if defined(HAVE_PKCS8) || defined(HAVE_PKCS12)
    word32 algId = 0;
 8014a7a:	2300      	movs	r3, #0
 8014a7c:	617b      	str	r3, [r7, #20]
#endif
    void*      heap = NULL;
 8014a7e:	2300      	movs	r3, #0
 8014a80:	623b      	str	r3, [r7, #32]

    /* Check validity of parameters. */
    if ((inOutIdx == NULL) || (input == NULL) || ((key == NULL) &&
 8014a82:	68bb      	ldr	r3, [r7, #8]
 8014a84:	2b00      	cmp	r3, #0
 8014a86:	d008      	beq.n	8014a9a <_RsaPrivateKeyDecode+0x3a>
 8014a88:	68fb      	ldr	r3, [r7, #12]
 8014a8a:	2b00      	cmp	r3, #0
 8014a8c:	d005      	beq.n	8014a9a <_RsaPrivateKeyDecode+0x3a>
 8014a8e:	687b      	ldr	r3, [r7, #4]
 8014a90:	2b00      	cmp	r3, #0
 8014a92:	d105      	bne.n	8014aa0 <_RsaPrivateKeyDecode+0x40>
 8014a94:	683b      	ldr	r3, [r7, #0]
 8014a96:	2b00      	cmp	r3, #0
 8014a98:	d102      	bne.n	8014aa0 <_RsaPrivateKeyDecode+0x40>
            (keySz == NULL))) {
        ret = BAD_FUNC_ARG;
 8014a9a:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8014a9e:	62bb      	str	r3, [r7, #40]	@ 0x28
    }

    if ((ret == 0) && (key != NULL)) {
 8014aa0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014aa2:	2b00      	cmp	r3, #0
 8014aa4:	d108      	bne.n	8014ab8 <_RsaPrivateKeyDecode+0x58>
 8014aa6:	687b      	ldr	r3, [r7, #4]
 8014aa8:	2b00      	cmp	r3, #0
 8014aaa:	d005      	beq.n	8014ab8 <_RsaPrivateKeyDecode+0x58>
        heap = key->heap;
 8014aac:	687b      	ldr	r3, [r7, #4]
 8014aae:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8014ab2:	f8d3 3160 	ldr.w	r3, [r3, #352]	@ 0x160
 8014ab6:	623b      	str	r3, [r7, #32]
    }

#if defined(HAVE_PKCS8) || defined(HAVE_PKCS12)
    if (ret == 0) {
 8014ab8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014aba:	2b00      	cmp	r3, #0
 8014abc:	d106      	bne.n	8014acc <_RsaPrivateKeyDecode+0x6c>
        /* if has pkcs8 header skip it */
        if (ToTraditionalInline_ex(input, inOutIdx, inSz, &algId) < 0) {
 8014abe:	f107 0314 	add.w	r3, r7, #20
 8014ac2:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8014ac4:	68b9      	ldr	r1, [r7, #8]
 8014ac6:	68f8      	ldr	r0, [r7, #12]
 8014ac8:	f000 f9dc 	bl	8014e84 <ToTraditionalInline_ex>
        }
    }
#endif

    (void)heap;
    CALLOC_ASNGETDATA(dataASN, rsaKeyASN_Length, ret, heap);
 8014acc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014ace:	2b00      	cmp	r3, #0
 8014ad0:	d10a      	bne.n	8014ae8 <_RsaPrivateKeyDecode+0x88>
 8014ad2:	f44f 708c 	mov.w	r0, #280	@ 0x118
 8014ad6:	f009 ffd7 	bl	801ea88 <wolfSSL_Malloc>
 8014ada:	62f8      	str	r0, [r7, #44]	@ 0x2c
 8014adc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014ade:	2b00      	cmp	r3, #0
 8014ae0:	d102      	bne.n	8014ae8 <_RsaPrivateKeyDecode+0x88>
 8014ae2:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8014ae6:	62bb      	str	r3, [r7, #40]	@ 0x28
 8014ae8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014aea:	2b00      	cmp	r3, #0
 8014aec:	d105      	bne.n	8014afa <_RsaPrivateKeyDecode+0x9a>
 8014aee:	f44f 728c 	mov.w	r2, #280	@ 0x118
 8014af2:	2100      	movs	r1, #0
 8014af4:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8014af6:	f013 fce7 	bl	80284c8 <memset>

    if (ret == 0) {
 8014afa:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014afc:	2b00      	cmp	r3, #0
 8014afe:	d13d      	bne.n	8014b7c <_RsaPrivateKeyDecode+0x11c>
        /* Register variable to hold version field. */
        GetASN_Int8Bit(&dataASN[RSAKEYASN_IDX_VER], &version);
 8014b00:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014b02:	331c      	adds	r3, #28
 8014b04:	2201      	movs	r2, #1
 8014b06:	761a      	strb	r2, [r3, #24]
 8014b08:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014b0a:	331c      	adds	r3, #28
 8014b0c:	f107 021b 	add.w	r2, r7, #27
 8014b10:	609a      	str	r2, [r3, #8]
    #else
        #define RSA_ASN_INTS        RSA_INTS
        /* Extracting all data from BER encoding. */
        #define RSA_ASN_COMPLETE    1
    #endif
        if (key != NULL) {
 8014b12:	687b      	ldr	r3, [r7, #4]
 8014b14:	2b00      	cmp	r3, #0
 8014b16:	d024      	beq.n	8014b62 <_RsaPrivateKeyDecode+0x102>
            int i;
            /* Extract all public fields. */
            for (i = 0; i < RSA_ASN_INTS; i++) {
 8014b18:	2300      	movs	r3, #0
 8014b1a:	627b      	str	r3, [r7, #36]	@ 0x24
 8014b1c:	e01e      	b.n	8014b5c <_RsaPrivateKeyDecode+0xfc>
                GetASN_MP(&dataASN[(byte)RSAKEYASN_IDX_N + i],
 8014b1e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014b20:	3302      	adds	r3, #2
 8014b22:	461a      	mov	r2, r3
 8014b24:	4613      	mov	r3, r2
 8014b26:	00db      	lsls	r3, r3, #3
 8014b28:	1a9b      	subs	r3, r3, r2
 8014b2a:	009b      	lsls	r3, r3, #2
 8014b2c:	461a      	mov	r2, r3
 8014b2e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014b30:	4413      	add	r3, r2
 8014b32:	2208      	movs	r2, #8
 8014b34:	761a      	strb	r2, [r3, #24]
 8014b36:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014b38:	3302      	adds	r3, #2
 8014b3a:	461a      	mov	r2, r3
 8014b3c:	4613      	mov	r3, r2
 8014b3e:	00db      	lsls	r3, r3, #3
 8014b40:	1a9b      	subs	r3, r3, r2
 8014b42:	009b      	lsls	r3, r3, #2
 8014b44:	461a      	mov	r2, r3
 8014b46:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014b48:	189c      	adds	r4, r3, r2
 8014b4a:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8014b4c:	6878      	ldr	r0, [r7, #4]
 8014b4e:	f7ff ff73 	bl	8014a38 <GetRsaInt>
 8014b52:	4603      	mov	r3, r0
 8014b54:	60a3      	str	r3, [r4, #8]
            for (i = 0; i < RSA_ASN_INTS; i++) {
 8014b56:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014b58:	3301      	adds	r3, #1
 8014b5a:	627b      	str	r3, [r7, #36]	@ 0x24
 8014b5c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014b5e:	2b07      	cmp	r3, #7
 8014b60:	dddd      	ble.n	8014b1e <_RsaPrivateKeyDecode+0xbe>
                    GetRsaInt(key, i));
            }
        }
        /* Parse BER encoding for RSA private key. */
        ret = GetASN_Items(rsaKeyASN, dataASN, rsaKeyASN_Length,
 8014b62:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8014b64:	9302      	str	r3, [sp, #8]
 8014b66:	68bb      	ldr	r3, [r7, #8]
 8014b68:	9301      	str	r3, [sp, #4]
 8014b6a:	68fb      	ldr	r3, [r7, #12]
 8014b6c:	9300      	str	r3, [sp, #0]
 8014b6e:	2301      	movs	r3, #1
 8014b70:	220a      	movs	r2, #10
 8014b72:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8014b74:	4822      	ldr	r0, [pc, #136]	@ (8014c00 <_RsaPrivateKeyDecode+0x1a0>)
 8014b76:	f7fe fdc3 	bl	8013700 <GetASN_Items>
 8014b7a:	62b8      	str	r0, [r7, #40]	@ 0x28
    }
    /* Check version: 0 - two prime, 1 - multi-prime
     * Multi-prime has optional sequence after coefficient for extra primes.
     * If extra primes, parsing will fail as not all the buffer was used.
     */
    if ((ret == 0) && (version > PKCS1v1)) {
 8014b7c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014b7e:	2b00      	cmp	r3, #0
 8014b80:	d105      	bne.n	8014b8e <_RsaPrivateKeyDecode+0x12e>
 8014b82:	7efb      	ldrb	r3, [r7, #27]
 8014b84:	2b01      	cmp	r3, #1
 8014b86:	d902      	bls.n	8014b8e <_RsaPrivateKeyDecode+0x12e>
        ret = ASN_PARSE_E;
 8014b88:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8014b8c:	62bb      	str	r3, [r7, #40]	@ 0x28
    }
    if ((ret == 0) && (key != NULL)) {
 8014b8e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014b90:	2b00      	cmp	r3, #0
 8014b92:	d10a      	bne.n	8014baa <_RsaPrivateKeyDecode+0x14a>
 8014b94:	687b      	ldr	r3, [r7, #4]
 8014b96:	2b00      	cmp	r3, #0
 8014b98:	d007      	beq.n	8014baa <_RsaPrivateKeyDecode+0x14a>
    #if !defined(WOLFSSL_RSA_PUBLIC_ONLY)
        /* RSA key object has all private key values. */
        key->type = RSA_PRIVATE;
 8014b9a:	687b      	ldr	r3, [r7, #4]
 8014b9c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8014ba0:	461a      	mov	r2, r3
 8014ba2:	2301      	movs	r3, #1
 8014ba4:	f8c2 3168 	str.w	r3, [r2, #360]	@ 0x168
 8014ba8:	e01a      	b.n	8014be0 <_RsaPrivateKeyDecode+0x180>
    #ifdef WOLFSSL_XILINX_CRYPT
        if (wc_InitRsaHw(key) != 0)
            ret = BAD_STATE_E;
    #endif
    }
    else if (ret == 0) {
 8014baa:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014bac:	2b00      	cmp	r3, #0
 8014bae:	d117      	bne.n	8014be0 <_RsaPrivateKeyDecode+0x180>
        /* Not filling in key but do want key size. */
        *keySz = (int)dataASN[(byte)RSAKEYASN_IDX_N].length;
 8014bb0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014bb2:	3338      	adds	r3, #56	@ 0x38
 8014bb4:	685b      	ldr	r3, [r3, #4]
 8014bb6:	461a      	mov	r2, r3
 8014bb8:	683b      	ldr	r3, [r7, #0]
 8014bba:	601a      	str	r2, [r3, #0]
        /* Check whether first byte of data is 0x00 and drop it. */
        if (input[(int)dataASN[RSAKEYASN_IDX_E].offset - *keySz] == 0) {
 8014bbc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014bbe:	3354      	adds	r3, #84	@ 0x54
 8014bc0:	681b      	ldr	r3, [r3, #0]
 8014bc2:	461a      	mov	r2, r3
 8014bc4:	683b      	ldr	r3, [r7, #0]
 8014bc6:	681b      	ldr	r3, [r3, #0]
 8014bc8:	1ad3      	subs	r3, r2, r3
 8014bca:	461a      	mov	r2, r3
 8014bcc:	68fb      	ldr	r3, [r7, #12]
 8014bce:	4413      	add	r3, r2
 8014bd0:	781b      	ldrb	r3, [r3, #0]
 8014bd2:	2b00      	cmp	r3, #0
 8014bd4:	d104      	bne.n	8014be0 <_RsaPrivateKeyDecode+0x180>
            (*keySz)--;
 8014bd6:	683b      	ldr	r3, [r7, #0]
 8014bd8:	681b      	ldr	r3, [r3, #0]
 8014bda:	1e5a      	subs	r2, r3, #1
 8014bdc:	683b      	ldr	r3, [r7, #0]
 8014bde:	601a      	str	r2, [r3, #0]
        }
    }

    FREE_ASNGETDATA(dataASN, heap);
 8014be0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014be2:	2b00      	cmp	r3, #0
 8014be4:	d007      	beq.n	8014bf6 <_RsaPrivateKeyDecode+0x196>
 8014be6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014be8:	61fb      	str	r3, [r7, #28]
 8014bea:	69fb      	ldr	r3, [r7, #28]
 8014bec:	2b00      	cmp	r3, #0
 8014bee:	d002      	beq.n	8014bf6 <_RsaPrivateKeyDecode+0x196>
 8014bf0:	69f8      	ldr	r0, [r7, #28]
 8014bf2:	f009 ff65 	bl	801eac0 <wolfSSL_Free>
    return ret;
 8014bf6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 8014bf8:	4618      	mov	r0, r3
 8014bfa:	3734      	adds	r7, #52	@ 0x34
 8014bfc:	46bd      	mov	sp, r7
 8014bfe:	bd90      	pop	{r4, r7, pc}
 8014c00:	08033788 	.word	0x08033788

08014c04 <wc_RsaPrivateKeyDecode>:
 * @return  MP_INIT_E when the unable to initialize an mp_int.
 * @return  ASN_GETINT_E when the unable to convert data to an mp_int.
 */
int wc_RsaPrivateKeyDecode(const byte* input, word32* inOutIdx, RsaKey* key,
    word32 inSz)
{
 8014c04:	b580      	push	{r7, lr}
 8014c06:	b086      	sub	sp, #24
 8014c08:	af02      	add	r7, sp, #8
 8014c0a:	60f8      	str	r0, [r7, #12]
 8014c0c:	60b9      	str	r1, [r7, #8]
 8014c0e:	607a      	str	r2, [r7, #4]
 8014c10:	603b      	str	r3, [r7, #0]
    if (key == NULL) {
 8014c12:	687b      	ldr	r3, [r7, #4]
 8014c14:	2b00      	cmp	r3, #0
 8014c16:	d102      	bne.n	8014c1e <wc_RsaPrivateKeyDecode+0x1a>
        return BAD_FUNC_ARG;
 8014c18:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8014c1c:	e008      	b.n	8014c30 <wc_RsaPrivateKeyDecode+0x2c>
    }
    return _RsaPrivateKeyDecode(input, inOutIdx, key, NULL, inSz);
 8014c1e:	683b      	ldr	r3, [r7, #0]
 8014c20:	9300      	str	r3, [sp, #0]
 8014c22:	2300      	movs	r3, #0
 8014c24:	687a      	ldr	r2, [r7, #4]
 8014c26:	68b9      	ldr	r1, [r7, #8]
 8014c28:	68f8      	ldr	r0, [r7, #12]
 8014c2a:	f7ff ff19 	bl	8014a60 <_RsaPrivateKeyDecode>
 8014c2e:	4603      	mov	r3, r0
}
 8014c30:	4618      	mov	r0, r3
 8014c32:	3710      	adds	r7, #16
 8014c34:	46bd      	mov	sp, r7
 8014c36:	bd80      	pop	{r7, pc}

08014c38 <wc_RsaPrivateKeyValidate>:
 * @return  MP_INIT_E when the unable to initialize an mp_int.
 * @return  ASN_GETINT_E when the unable to convert data to an mp_int.
 */
int wc_RsaPrivateKeyValidate(const byte* input, word32* inOutIdx, int* keySz,
     word32 inSz)
{
 8014c38:	b580      	push	{r7, lr}
 8014c3a:	b086      	sub	sp, #24
 8014c3c:	af02      	add	r7, sp, #8
 8014c3e:	60f8      	str	r0, [r7, #12]
 8014c40:	60b9      	str	r1, [r7, #8]
 8014c42:	607a      	str	r2, [r7, #4]
 8014c44:	603b      	str	r3, [r7, #0]
    return _RsaPrivateKeyDecode(input, inOutIdx, NULL, keySz, inSz);
 8014c46:	683b      	ldr	r3, [r7, #0]
 8014c48:	9300      	str	r3, [sp, #0]
 8014c4a:	687b      	ldr	r3, [r7, #4]
 8014c4c:	2200      	movs	r2, #0
 8014c4e:	68b9      	ldr	r1, [r7, #8]
 8014c50:	68f8      	ldr	r0, [r7, #12]
 8014c52:	f7ff ff05 	bl	8014a60 <_RsaPrivateKeyDecode>
 8014c56:	4603      	mov	r3, r0
}
 8014c58:	4618      	mov	r0, r3
 8014c5a:	3710      	adds	r7, #16
 8014c5c:	46bd      	mov	sp, r7
 8014c5e:	bd80      	pop	{r7, pc}

08014c60 <ToTraditionalInline_ex2>:
 * @return  ASN_EXPECT_0_E when the INTEGER has the MSB set or NULL has a
 *          non-zero length.
 */
int ToTraditionalInline_ex2(const byte* input, word32* inOutIdx, word32 sz,
                            word32* algId, word32* eccOid)
{
 8014c60:	b580      	push	{r7, lr}
 8014c62:	b094      	sub	sp, #80	@ 0x50
 8014c64:	af04      	add	r7, sp, #16
 8014c66:	60f8      	str	r0, [r7, #12]
 8014c68:	60b9      	str	r1, [r7, #8]
 8014c6a:	607a      	str	r2, [r7, #4]
 8014c6c:	603b      	str	r3, [r7, #0]

    *inOutIdx = idx;

    return length;
#else
    DECL_ASNGETDATA(dataASN, pkcs8KeyASN_Length);
 8014c6e:	2300      	movs	r3, #0
 8014c70:	63fb      	str	r3, [r7, #60]	@ 0x3c
    int ret = 0;
 8014c72:	2300      	movs	r3, #0
 8014c74:	63bb      	str	r3, [r7, #56]	@ 0x38
    word32 oid = 9;
 8014c76:	2309      	movs	r3, #9
 8014c78:	637b      	str	r3, [r7, #52]	@ 0x34
    byte version = 0;
 8014c7a:	2300      	movs	r3, #0
 8014c7c:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
    word32 idx;

    (void)eccOid;

    /* Check validity of parameters. */
    if (input == NULL || inOutIdx == NULL) {
 8014c80:	68fb      	ldr	r3, [r7, #12]
 8014c82:	2b00      	cmp	r3, #0
 8014c84:	d002      	beq.n	8014c8c <ToTraditionalInline_ex2+0x2c>
 8014c86:	68bb      	ldr	r3, [r7, #8]
 8014c88:	2b00      	cmp	r3, #0
 8014c8a:	d102      	bne.n	8014c92 <ToTraditionalInline_ex2+0x32>
        return BAD_FUNC_ARG;
 8014c8c:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8014c90:	e0f2      	b.n	8014e78 <ToTraditionalInline_ex2+0x218>
    }

    idx = *inOutIdx;
 8014c92:	68bb      	ldr	r3, [r7, #8]
 8014c94:	681b      	ldr	r3, [r3, #0]
 8014c96:	61fb      	str	r3, [r7, #28]

    CALLOC_ASNGETDATA(dataASN, pkcs8KeyASN_Length, ret, NULL);
 8014c98:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8014c9a:	2b00      	cmp	r3, #0
 8014c9c:	d109      	bne.n	8014cb2 <ToTraditionalInline_ex2+0x52>
 8014c9e:	20fc      	movs	r0, #252	@ 0xfc
 8014ca0:	f009 fef2 	bl	801ea88 <wolfSSL_Malloc>
 8014ca4:	63f8      	str	r0, [r7, #60]	@ 0x3c
 8014ca6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014ca8:	2b00      	cmp	r3, #0
 8014caa:	d102      	bne.n	8014cb2 <ToTraditionalInline_ex2+0x52>
 8014cac:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8014cb0:	63bb      	str	r3, [r7, #56]	@ 0x38
 8014cb2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8014cb4:	2b00      	cmp	r3, #0
 8014cb6:	d104      	bne.n	8014cc2 <ToTraditionalInline_ex2+0x62>
 8014cb8:	22fc      	movs	r2, #252	@ 0xfc
 8014cba:	2100      	movs	r1, #0
 8014cbc:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8014cbe:	f013 fc03 	bl	80284c8 <memset>

    if (ret == 0) {
 8014cc2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8014cc4:	2b00      	cmp	r3, #0
 8014cc6:	d11e      	bne.n	8014d06 <ToTraditionalInline_ex2+0xa6>
        /* Get version, check key type and curve type. */
        GetASN_Int8Bit(&dataASN[PKCS8KEYASN_IDX_VER], &version);
 8014cc8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014cca:	331c      	adds	r3, #28
 8014ccc:	2201      	movs	r2, #1
 8014cce:	761a      	strb	r2, [r3, #24]
 8014cd0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014cd2:	331c      	adds	r3, #28
 8014cd4:	f107 0223 	add.w	r2, r7, #35	@ 0x23
 8014cd8:	609a      	str	r2, [r3, #8]
        GetASN_OID(&dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_OID_KEY], oidKeyType);
 8014cda:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014cdc:	3354      	adds	r3, #84	@ 0x54
 8014cde:	2202      	movs	r2, #2
 8014ce0:	611a      	str	r2, [r3, #16]
        GetASN_OID(&dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_OID_CURVE], oidCurveType);
 8014ce2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014ce4:	3370      	adds	r3, #112	@ 0x70
 8014ce6:	2203      	movs	r2, #3
 8014ce8:	611a      	str	r2, [r3, #16]
        /* Parse data. */
        ret = GetASN_Items(pkcs8KeyASN, dataASN, pkcs8KeyASN_Length, 1, input,
 8014cea:	687b      	ldr	r3, [r7, #4]
 8014cec:	9302      	str	r3, [sp, #8]
 8014cee:	f107 031c 	add.w	r3, r7, #28
 8014cf2:	9301      	str	r3, [sp, #4]
 8014cf4:	68fb      	ldr	r3, [r7, #12]
 8014cf6:	9300      	str	r3, [sp, #0]
 8014cf8:	2301      	movs	r3, #1
 8014cfa:	2209      	movs	r2, #9
 8014cfc:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 8014cfe:	4860      	ldr	r0, [pc, #384]	@ (8014e80 <ToTraditionalInline_ex2+0x220>)
 8014d00:	f7fe fcfe 	bl	8013700 <GetASN_Items>
 8014d04:	63b8      	str	r0, [r7, #56]	@ 0x38
                           &idx, sz);
    }

    if (ret == 0) {
 8014d06:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8014d08:	2b00      	cmp	r3, #0
 8014d0a:	d10a      	bne.n	8014d22 <ToTraditionalInline_ex2+0xc2>
        /* Key type OID. */
        oid = dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_OID_KEY].data.oid.sum;
 8014d0c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014d0e:	3354      	adds	r3, #84	@ 0x54
 8014d10:	695b      	ldr	r3, [r3, #20]
 8014d12:	637b      	str	r3, [r7, #52]	@ 0x34

        /* Version 1 includes an optional public key.
         * If public key is included then the parsing will fail as it did not
         * use all the data.
         */
        if (version > PKCS8v1) {
 8014d14:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 8014d18:	2b01      	cmp	r3, #1
 8014d1a:	d902      	bls.n	8014d22 <ToTraditionalInline_ex2+0xc2>
            ret = ASN_PARSE_E;
 8014d1c:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8014d20:	63bb      	str	r3, [r7, #56]	@ 0x38
        }
    }
    if (ret == 0) {
 8014d22:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8014d24:	2b00      	cmp	r3, #0
 8014d26:	f040 8089 	bne.w	8014e3c <ToTraditionalInline_ex2+0x1dc>
        switch (oid) {
 8014d2a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014d2c:	f240 228e 	movw	r2, #654	@ 0x28e
 8014d30:	4293      	cmp	r3, r2
 8014d32:	d025      	beq.n	8014d80 <ToTraditionalInline_ex2+0x120>
 8014d34:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014d36:	f240 228e 	movw	r2, #654	@ 0x28e
 8014d3a:	4293      	cmp	r3, r2
 8014d3c:	d875      	bhi.n	8014e2a <ToTraditionalInline_ex2+0x1ca>
 8014d3e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014d40:	f240 2287 	movw	r2, #647	@ 0x287
 8014d44:	4293      	cmp	r3, r2
 8014d46:	d062      	beq.n	8014e0e <ToTraditionalInline_ex2+0x1ae>
 8014d48:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014d4a:	f5b3 7f22 	cmp.w	r3, #648	@ 0x288
 8014d4e:	d26c      	bcs.n	8014e2a <ToTraditionalInline_ex2+0x1ca>
 8014d50:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014d52:	f240 2206 	movw	r2, #518	@ 0x206
 8014d56:	4293      	cmp	r3, r2
 8014d58:	d046      	beq.n	8014de8 <ToTraditionalInline_ex2+0x188>
 8014d5a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014d5c:	f240 2285 	movw	r2, #645	@ 0x285
 8014d60:	4293      	cmp	r3, r2
 8014d62:	d162      	bne.n	8014e2a <ToTraditionalInline_ex2+0x1ca>
    #ifndef NO_RSA
            case RSAk:
                /* Must have NULL item but not OBJECT_ID item. */
                if ((dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_NULL].tag == 0) ||
 8014d64:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014d66:	338c      	adds	r3, #140	@ 0x8c
 8014d68:	7e5b      	ldrb	r3, [r3, #25]
 8014d6a:	2b00      	cmp	r3, #0
 8014d6c:	d004      	beq.n	8014d78 <ToTraditionalInline_ex2+0x118>
                    (dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_OID_CURVE].tag != 0)) {
 8014d6e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014d70:	3370      	adds	r3, #112	@ 0x70
 8014d72:	7e5b      	ldrb	r3, [r3, #25]
                if ((dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_NULL].tag == 0) ||
 8014d74:	2b00      	cmp	r3, #0
 8014d76:	d05a      	beq.n	8014e2e <ToTraditionalInline_ex2+0x1ce>
                    ret = ASN_PARSE_E;
 8014d78:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8014d7c:	63bb      	str	r3, [r7, #56]	@ 0x38
                }
                break;
 8014d7e:	e056      	b.n	8014e2e <ToTraditionalInline_ex2+0x1ce>
        #ifdef WC_RSA_PSS
            case RSAPSSk:
                /* Must not have NULL item. */
                if (dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_NULL].tag != 0) {
 8014d80:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014d82:	338c      	adds	r3, #140	@ 0x8c
 8014d84:	7e5b      	ldrb	r3, [r3, #25]
 8014d86:	2b00      	cmp	r3, #0
 8014d88:	d002      	beq.n	8014d90 <ToTraditionalInline_ex2+0x130>
                    ret = ASN_PARSE_E;
 8014d8a:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8014d8e:	63bb      	str	r3, [r7, #56]	@ 0x38
                }
                if (dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_PARAM_SEQ].tag != 0) {
 8014d90:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014d92:	33a8      	adds	r3, #168	@ 0xa8
 8014d94:	7e5b      	ldrb	r3, [r3, #25]
 8014d96:	2b00      	cmp	r3, #0
 8014d98:	d04b      	beq.n	8014e32 <ToTraditionalInline_ex2+0x1d2>
                    enum wc_HashType hash;
                    int mgf;
                    int saltLen;
                    const byte* params = GetASNItem_Addr(
 8014d9a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014d9c:	33a8      	adds	r3, #168	@ 0xa8
 8014d9e:	681b      	ldr	r3, [r3, #0]
 8014da0:	68fa      	ldr	r2, [r7, #12]
 8014da2:	4413      	add	r3, r2
 8014da4:	633b      	str	r3, [r7, #48]	@ 0x30
                        dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_PARAM_SEQ], input);
                    word32 paramsSz = GetASNItem_Length(
 8014da6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014da8:	33a8      	adds	r3, #168	@ 0xa8
 8014daa:	685b      	ldr	r3, [r3, #4]
 8014dac:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8014dae:	32a8      	adds	r2, #168	@ 0xa8
 8014db0:	6891      	ldr	r1, [r2, #8]
 8014db2:	68fa      	ldr	r2, [r7, #12]
 8014db4:	1a8a      	subs	r2, r1, r2
 8014db6:	441a      	add	r2, r3
 8014db8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014dba:	33a8      	adds	r3, #168	@ 0xa8
 8014dbc:	681b      	ldr	r3, [r3, #0]
 8014dbe:	1ad3      	subs	r3, r2, r3
 8014dc0:	62fb      	str	r3, [r7, #44]	@ 0x2c
                        dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_PARAM_SEQ], input);

                    /* Validate the private key parameters. */
                    ret = DecodeRsaPssParams(params, paramsSz, &hash, &mgf,
 8014dc2:	f107 0114 	add.w	r1, r7, #20
 8014dc6:	f107 021b 	add.w	r2, r7, #27
 8014dca:	f107 0310 	add.w	r3, r7, #16
 8014dce:	9300      	str	r3, [sp, #0]
 8014dd0:	460b      	mov	r3, r1
 8014dd2:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8014dd4:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 8014dd6:	f7ff fd9d 	bl	8014914 <DecodeRsaPssParams>
 8014dda:	63b8      	str	r0, [r7, #56]	@ 0x38
                        &saltLen);
                    if (ret != 0) {
 8014ddc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8014dde:	2b00      	cmp	r3, #0
 8014de0:	d027      	beq.n	8014e32 <ToTraditionalInline_ex2+0x1d2>
                        return ASN_PARSE_E;
 8014de2:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8014de6:	e047      	b.n	8014e78 <ToTraditionalInline_ex2+0x218>
        #endif
    #endif
        #ifdef HAVE_ECC
            case ECDSAk:
                /* Must not have NULL item. */
                if (dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_NULL].tag != 0) {
 8014de8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014dea:	338c      	adds	r3, #140	@ 0x8c
 8014dec:	7e5b      	ldrb	r3, [r3, #25]
 8014dee:	2b00      	cmp	r3, #0
 8014df0:	d002      	beq.n	8014df8 <ToTraditionalInline_ex2+0x198>
                    ret = ASN_PARSE_E;
 8014df2:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8014df6:	63bb      	str	r3, [r7, #56]	@ 0x38
                }
                if (eccOid != NULL) {
 8014df8:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8014dfa:	2b00      	cmp	r3, #0
 8014dfc:	d01b      	beq.n	8014e36 <ToTraditionalInline_ex2+0x1d6>
                    ASNGetData* oidCurve =
 8014dfe:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014e00:	3370      	adds	r3, #112	@ 0x70
 8014e02:	62bb      	str	r3, [r7, #40]	@ 0x28
                        &dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_OID_CURVE];
                    *eccOid = oidCurve->data.oid.sum;
 8014e04:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014e06:	695a      	ldr	r2, [r3, #20]
 8014e08:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8014e0a:	601a      	str	r2, [r3, #0]
                }
                break;
 8014e0c:	e013      	b.n	8014e36 <ToTraditionalInline_ex2+0x1d6>
                break;
        #endif
        #ifndef NO_DH
            case DHk:
                /* Neither NULL item nor OBJECT_ID item allowed. */
                if ((dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_NULL].tag != 0) ||
 8014e0e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014e10:	338c      	adds	r3, #140	@ 0x8c
 8014e12:	7e5b      	ldrb	r3, [r3, #25]
 8014e14:	2b00      	cmp	r3, #0
 8014e16:	d104      	bne.n	8014e22 <ToTraditionalInline_ex2+0x1c2>
                    (dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_OID_CURVE].tag != 0)) {
 8014e18:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014e1a:	3370      	adds	r3, #112	@ 0x70
 8014e1c:	7e5b      	ldrb	r3, [r3, #25]
                if ((dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_NULL].tag != 0) ||
 8014e1e:	2b00      	cmp	r3, #0
 8014e20:	d00b      	beq.n	8014e3a <ToTraditionalInline_ex2+0x1da>
                    ret = ASN_PARSE_E;
 8014e22:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8014e26:	63bb      	str	r3, [r7, #56]	@ 0x38
                }
                break;
 8014e28:	e007      	b.n	8014e3a <ToTraditionalInline_ex2+0x1da>
        #endif
            /* DSAk not supported. */
            /* Falcon, Dilithium and Sphincs not supported. */
            /* Ignore OID lookup failures. */
            default:
                break;
 8014e2a:	bf00      	nop
 8014e2c:	e006      	b.n	8014e3c <ToTraditionalInline_ex2+0x1dc>
                break;
 8014e2e:	bf00      	nop
 8014e30:	e004      	b.n	8014e3c <ToTraditionalInline_ex2+0x1dc>
                break;
 8014e32:	bf00      	nop
 8014e34:	e002      	b.n	8014e3c <ToTraditionalInline_ex2+0x1dc>
                break;
 8014e36:	bf00      	nop
 8014e38:	e000      	b.n	8014e3c <ToTraditionalInline_ex2+0x1dc>
                break;
 8014e3a:	bf00      	nop
        }
    }
    if (ret == 0) {
 8014e3c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8014e3e:	2b00      	cmp	r3, #0
 8014e40:	d10e      	bne.n	8014e60 <ToTraditionalInline_ex2+0x200>
        /* Return algorithm id of internal key. */
        *algId = oid;
 8014e42:	683b      	ldr	r3, [r7, #0]
 8014e44:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8014e46:	601a      	str	r2, [r3, #0]
        /* Return index to start of internal key. */
        *inOutIdx = GetASNItem_DataIdx(dataASN[PKCS8KEYASN_IDX_PKEY_DATA], input);
 8014e48:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014e4a:	33c4      	adds	r3, #196	@ 0xc4
 8014e4c:	689a      	ldr	r2, [r3, #8]
 8014e4e:	68fb      	ldr	r3, [r7, #12]
 8014e50:	1ad3      	subs	r3, r2, r3
 8014e52:	461a      	mov	r2, r3
 8014e54:	68bb      	ldr	r3, [r7, #8]
 8014e56:	601a      	str	r2, [r3, #0]
        /* Return value is length of internal key. */
        ret = (int)dataASN[PKCS8KEYASN_IDX_PKEY_DATA].data.ref.length;
 8014e58:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014e5a:	33c4      	adds	r3, #196	@ 0xc4
 8014e5c:	68db      	ldr	r3, [r3, #12]
 8014e5e:	63bb      	str	r3, [r7, #56]	@ 0x38
    }

    FREE_ASNGETDATA(dataASN, NULL);
 8014e60:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014e62:	2b00      	cmp	r3, #0
 8014e64:	d007      	beq.n	8014e76 <ToTraditionalInline_ex2+0x216>
 8014e66:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014e68:	627b      	str	r3, [r7, #36]	@ 0x24
 8014e6a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014e6c:	2b00      	cmp	r3, #0
 8014e6e:	d002      	beq.n	8014e76 <ToTraditionalInline_ex2+0x216>
 8014e70:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8014e72:	f009 fe25 	bl	801eac0 <wolfSSL_Free>
    return ret;
 8014e76:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
#endif
}
 8014e78:	4618      	mov	r0, r3
 8014e7a:	3740      	adds	r7, #64	@ 0x40
 8014e7c:	46bd      	mov	sp, r7
 8014e7e:	bd80      	pop	{r7, pc}
 8014e80:	080337b0 	.word	0x080337b0

08014e84 <ToTraditionalInline_ex>:
 * @return  ASN_EXPECT_0_E when the INTEGER has the MSB set or NULL has a
 *          non-zero length.
 */
int ToTraditionalInline_ex(const byte* input, word32* inOutIdx, word32 sz,
                           word32* algId)
{
 8014e84:	b580      	push	{r7, lr}
 8014e86:	b086      	sub	sp, #24
 8014e88:	af02      	add	r7, sp, #8
 8014e8a:	60f8      	str	r0, [r7, #12]
 8014e8c:	60b9      	str	r1, [r7, #8]
 8014e8e:	607a      	str	r2, [r7, #4]
 8014e90:	603b      	str	r3, [r7, #0]
    return ToTraditionalInline_ex2(input, inOutIdx, sz, algId, NULL);
 8014e92:	2300      	movs	r3, #0
 8014e94:	9300      	str	r3, [sp, #0]
 8014e96:	683b      	ldr	r3, [r7, #0]
 8014e98:	687a      	ldr	r2, [r7, #4]
 8014e9a:	68b9      	ldr	r1, [r7, #8]
 8014e9c:	68f8      	ldr	r0, [r7, #12]
 8014e9e:	f7ff fedf 	bl	8014c60 <ToTraditionalInline_ex2>
 8014ea2:	4603      	mov	r3, r0
}
 8014ea4:	4618      	mov	r0, r3
 8014ea6:	3710      	adds	r7, #16
 8014ea8:	46bd      	mov	sp, r7
 8014eaa:	bd80      	pop	{r7, pc}

08014eac <wc_RsaPublicKeyDecode_ex>:
 * @return  ASN_BITSTR_E when the expected BIT_STRING tag is not found.
 * @return  ASN_UNKNOWN_OID_E when the OID cannot be verified.
 */
int wc_RsaPublicKeyDecode_ex(const byte* input, word32* inOutIdx, word32 inSz,
    const byte** n, word32* nSz, const byte** e, word32* eSz)
{
 8014eac:	b580      	push	{r7, lr}
 8014eae:	b092      	sub	sp, #72	@ 0x48
 8014eb0:	af04      	add	r7, sp, #16
 8014eb2:	60f8      	str	r0, [r7, #12]
 8014eb4:	60b9      	str	r1, [r7, #8]
 8014eb6:	607a      	str	r2, [r7, #4]
 8014eb8:	603b      	str	r3, [r7, #0]
        *e = &input[*inOutIdx];
    *inOutIdx += (word32)length;

    return ret;
#else
    DECL_ASNGETDATA(dataASN, rsaPublicKeyASN_Length);
 8014eba:	2300      	movs	r3, #0
 8014ebc:	637b      	str	r3, [r7, #52]	@ 0x34
    int ret = 0;
 8014ebe:	2300      	movs	r3, #0
 8014ec0:	633b      	str	r3, [r7, #48]	@ 0x30
#ifdef WC_RSA_PSS
    word32 oid = RSAk;
 8014ec2:	f240 2385 	movw	r3, #645	@ 0x285
 8014ec6:	62fb      	str	r3, [r7, #44]	@ 0x2c
#endif

    /* Check validity of parameters. */
    if (input == NULL || inOutIdx == NULL) {
 8014ec8:	68fb      	ldr	r3, [r7, #12]
 8014eca:	2b00      	cmp	r3, #0
 8014ecc:	d002      	beq.n	8014ed4 <wc_RsaPublicKeyDecode_ex+0x28>
 8014ece:	68bb      	ldr	r3, [r7, #8]
 8014ed0:	2b00      	cmp	r3, #0
 8014ed2:	d102      	bne.n	8014eda <wc_RsaPublicKeyDecode_ex+0x2e>
        ret = BAD_FUNC_ARG;
 8014ed4:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8014ed8:	633b      	str	r3, [r7, #48]	@ 0x30
    }

    CALLOC_ASNGETDATA(dataASN, rsaPublicKeyASN_Length, ret, NULL);
 8014eda:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014edc:	2b00      	cmp	r3, #0
 8014ede:	d109      	bne.n	8014ef4 <wc_RsaPublicKeyDecode_ex+0x48>
 8014ee0:	20fc      	movs	r0, #252	@ 0xfc
 8014ee2:	f009 fdd1 	bl	801ea88 <wolfSSL_Malloc>
 8014ee6:	6378      	str	r0, [r7, #52]	@ 0x34
 8014ee8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014eea:	2b00      	cmp	r3, #0
 8014eec:	d102      	bne.n	8014ef4 <wc_RsaPublicKeyDecode_ex+0x48>
 8014eee:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8014ef2:	633b      	str	r3, [r7, #48]	@ 0x30
 8014ef4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014ef6:	2b00      	cmp	r3, #0
 8014ef8:	d104      	bne.n	8014f04 <wc_RsaPublicKeyDecode_ex+0x58>
 8014efa:	22fc      	movs	r2, #252	@ 0xfc
 8014efc:	2100      	movs	r1, #0
 8014efe:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 8014f00:	f013 fae2 	bl	80284c8 <memset>

    if (ret == 0) {
 8014f04:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014f06:	2b00      	cmp	r3, #0
 8014f08:	d122      	bne.n	8014f50 <wc_RsaPublicKeyDecode_ex+0xa4>
        /* Try decoding PKCS #1 public key by ignoring rest of ASN.1. */
        ret = GetASN_Items(&rsaPublicKeyASN[RSAPUBLICKEYASN_IDX_PUBKEY_RSA_SEQ],
 8014f0a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014f0c:	f103 01a8 	add.w	r1, r3, #168	@ 0xa8
 8014f10:	687b      	ldr	r3, [r7, #4]
 8014f12:	9302      	str	r3, [sp, #8]
 8014f14:	68bb      	ldr	r3, [r7, #8]
 8014f16:	9301      	str	r3, [sp, #4]
 8014f18:	68fb      	ldr	r3, [r7, #12]
 8014f1a:	9300      	str	r3, [sp, #0]
 8014f1c:	2300      	movs	r3, #0
 8014f1e:	2203      	movs	r2, #3
 8014f20:	4851      	ldr	r0, [pc, #324]	@ (8015068 <wc_RsaPublicKeyDecode_ex+0x1bc>)
 8014f22:	f7fe fbed 	bl	8013700 <GetASN_Items>
 8014f26:	6338      	str	r0, [r7, #48]	@ 0x30
           &dataASN[RSAPUBLICKEYASN_IDX_PUBKEY_RSA_SEQ],
           (int)(rsaPublicKeyASN_Length - RSAPUBLICKEYASN_IDX_PUBKEY_RSA_SEQ),
           0, input, inOutIdx, inSz);
        if (ret != 0) {
 8014f28:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014f2a:	2b00      	cmp	r3, #0
 8014f2c:	d010      	beq.n	8014f50 <wc_RsaPublicKeyDecode_ex+0xa4>
            /* Didn't work - try whole SubjectKeyInfo instead. */
        #ifdef WC_RSA_PSS
            /* Could be RSA or RSA PSS key. */
            GetASN_OID(&dataASN[RSAPUBLICKEYASN_IDX_ALGOID_OID], oidKeyType);
 8014f2e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014f30:	3338      	adds	r3, #56	@ 0x38
 8014f32:	2202      	movs	r2, #2
 8014f34:	611a      	str	r2, [r3, #16]
            /* Set the OID to expect. */
            GetASN_ExpBuffer(&dataASN[RSAPUBLICKEYASN_IDX_ALGOID_OID],
                    keyRsaOid, sizeof(keyRsaOid));
        #endif
            /* Decode SubjectKeyInfo. */
            ret = GetASN_Items(rsaPublicKeyASN, dataASN,
 8014f36:	687b      	ldr	r3, [r7, #4]
 8014f38:	9302      	str	r3, [sp, #8]
 8014f3a:	68bb      	ldr	r3, [r7, #8]
 8014f3c:	9301      	str	r3, [sp, #4]
 8014f3e:	68fb      	ldr	r3, [r7, #12]
 8014f40:	9300      	str	r3, [sp, #0]
 8014f42:	2301      	movs	r3, #1
 8014f44:	2209      	movs	r2, #9
 8014f46:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 8014f48:	4848      	ldr	r0, [pc, #288]	@ (801506c <wc_RsaPublicKeyDecode_ex+0x1c0>)
 8014f4a:	f7fe fbd9 	bl	8013700 <GetASN_Items>
 8014f4e:	6338      	str	r0, [r7, #48]	@ 0x30
                               rsaPublicKeyASN_Length, 1, input, inOutIdx,
                               inSz);
        }
    }
#ifdef WC_RSA_PSS
    if ((ret == 0) && (dataASN[RSAPUBLICKEYASN_IDX_ALGOID_OID].tag != 0)) {
 8014f50:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014f52:	2b00      	cmp	r3, #0
 8014f54:	d115      	bne.n	8014f82 <wc_RsaPublicKeyDecode_ex+0xd6>
 8014f56:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014f58:	3338      	adds	r3, #56	@ 0x38
 8014f5a:	7e5b      	ldrb	r3, [r3, #25]
 8014f5c:	2b00      	cmp	r3, #0
 8014f5e:	d010      	beq.n	8014f82 <wc_RsaPublicKeyDecode_ex+0xd6>
        /* Two possible OIDs supported - RSA and RSA PSS. */
        oid = dataASN[RSAPUBLICKEYASN_IDX_ALGOID_OID].data.oid.sum;
 8014f60:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014f62:	3338      	adds	r3, #56	@ 0x38
 8014f64:	695b      	ldr	r3, [r3, #20]
 8014f66:	62fb      	str	r3, [r7, #44]	@ 0x2c
        if ((oid != RSAk) && (oid != RSAPSSk)) {
 8014f68:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014f6a:	f240 2285 	movw	r2, #645	@ 0x285
 8014f6e:	4293      	cmp	r3, r2
 8014f70:	d007      	beq.n	8014f82 <wc_RsaPublicKeyDecode_ex+0xd6>
 8014f72:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014f74:	f240 228e 	movw	r2, #654	@ 0x28e
 8014f78:	4293      	cmp	r3, r2
 8014f7a:	d002      	beq.n	8014f82 <wc_RsaPublicKeyDecode_ex+0xd6>
            ret = ASN_PARSE_E;
 8014f7c:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8014f80:	633b      	str	r3, [r7, #48]	@ 0x30
        }
    }
    if ((ret == 0) && (dataASN[RSAPUBLICKEYASN_IDX_ALGOID_P_SEQ].tag != 0)) {
 8014f82:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014f84:	2b00      	cmp	r3, #0
 8014f86:	d13b      	bne.n	8015000 <wc_RsaPublicKeyDecode_ex+0x154>
 8014f88:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014f8a:	3370      	adds	r3, #112	@ 0x70
 8014f8c:	7e5b      	ldrb	r3, [r3, #25]
 8014f8e:	2b00      	cmp	r3, #0
 8014f90:	d036      	beq.n	8015000 <wc_RsaPublicKeyDecode_ex+0x154>
        /* Can't have NULL and SEQ. */
        if (dataASN[RSAPUBLICKEYASN_IDX_ALGOID_NULL].tag != 0) {
 8014f92:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014f94:	3354      	adds	r3, #84	@ 0x54
 8014f96:	7e5b      	ldrb	r3, [r3, #25]
 8014f98:	2b00      	cmp	r3, #0
 8014f9a:	d002      	beq.n	8014fa2 <wc_RsaPublicKeyDecode_ex+0xf6>
            ret = ASN_PARSE_E;
 8014f9c:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8014fa0:	633b      	str	r3, [r7, #48]	@ 0x30
        }
        /* SEQ present only with RSA PSS. */
        if ((ret == 0) && (oid != RSAPSSk)) {
 8014fa2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014fa4:	2b00      	cmp	r3, #0
 8014fa6:	d107      	bne.n	8014fb8 <wc_RsaPublicKeyDecode_ex+0x10c>
 8014fa8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014faa:	f240 228e 	movw	r2, #654	@ 0x28e
 8014fae:	4293      	cmp	r3, r2
 8014fb0:	d002      	beq.n	8014fb8 <wc_RsaPublicKeyDecode_ex+0x10c>
            ret = ASN_PARSE_E;
 8014fb2:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8014fb6:	633b      	str	r3, [r7, #48]	@ 0x30
        }
        if (ret == 0) {
 8014fb8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014fba:	2b00      	cmp	r3, #0
 8014fbc:	d120      	bne.n	8015000 <wc_RsaPublicKeyDecode_ex+0x154>
            enum wc_HashType hash;
            int mgf;
            int saltLen;
            const byte* params = GetASNItem_Addr(
 8014fbe:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014fc0:	3370      	adds	r3, #112	@ 0x70
 8014fc2:	681b      	ldr	r3, [r3, #0]
 8014fc4:	68fa      	ldr	r2, [r7, #12]
 8014fc6:	4413      	add	r3, r2
 8014fc8:	62bb      	str	r3, [r7, #40]	@ 0x28
                dataASN[RSAPUBLICKEYASN_IDX_ALGOID_P_SEQ], input);
            word32 paramsSz = GetASNItem_Length(
 8014fca:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014fcc:	3370      	adds	r3, #112	@ 0x70
 8014fce:	685b      	ldr	r3, [r3, #4]
 8014fd0:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8014fd2:	3270      	adds	r2, #112	@ 0x70
 8014fd4:	6891      	ldr	r1, [r2, #8]
 8014fd6:	68fa      	ldr	r2, [r7, #12]
 8014fd8:	1a8a      	subs	r2, r1, r2
 8014fda:	441a      	add	r2, r3
 8014fdc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014fde:	3370      	adds	r3, #112	@ 0x70
 8014fe0:	681b      	ldr	r3, [r3, #0]
 8014fe2:	1ad3      	subs	r3, r2, r3
 8014fe4:	627b      	str	r3, [r7, #36]	@ 0x24
                dataASN[RSAPUBLICKEYASN_IDX_ALGOID_P_SEQ], input);

            /* Validate the private key parameters. */
            ret = DecodeRsaPssParams(params, paramsSz, &hash, &mgf, &saltLen);
 8014fe6:	f107 0118 	add.w	r1, r7, #24
 8014fea:	f107 021f 	add.w	r2, r7, #31
 8014fee:	f107 0314 	add.w	r3, r7, #20
 8014ff2:	9300      	str	r3, [sp, #0]
 8014ff4:	460b      	mov	r3, r1
 8014ff6:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8014ff8:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8014ffa:	f7ff fc8b 	bl	8014914 <DecodeRsaPssParams>
 8014ffe:	6338      	str	r0, [r7, #48]	@ 0x30
            /* TODO: store parameters so that usage can be checked. */
        }
    }
#endif
    if (ret == 0) {
 8015000:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8015002:	2b00      	cmp	r3, #0
 8015004:	d11f      	bne.n	8015046 <wc_RsaPublicKeyDecode_ex+0x19a>
        /* Return the buffers and lengths asked for. */
        if (n != NULL) {
 8015006:	683b      	ldr	r3, [r7, #0]
 8015008:	2b00      	cmp	r3, #0
 801500a:	d004      	beq.n	8015016 <wc_RsaPublicKeyDecode_ex+0x16a>
            *n   = dataASN[RSAPUBLICKEYASN_IDX_PUBKEY_RSA_N].data.ref.data;
 801500c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801500e:	33c4      	adds	r3, #196	@ 0xc4
 8015010:	689a      	ldr	r2, [r3, #8]
 8015012:	683b      	ldr	r3, [r7, #0]
 8015014:	601a      	str	r2, [r3, #0]
        }
        if (nSz != NULL) {
 8015016:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8015018:	2b00      	cmp	r3, #0
 801501a:	d004      	beq.n	8015026 <wc_RsaPublicKeyDecode_ex+0x17a>
            *nSz = dataASN[RSAPUBLICKEYASN_IDX_PUBKEY_RSA_N].data.ref.length;
 801501c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801501e:	33c4      	adds	r3, #196	@ 0xc4
 8015020:	68da      	ldr	r2, [r3, #12]
 8015022:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8015024:	601a      	str	r2, [r3, #0]
        }
        if (e != NULL) {
 8015026:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8015028:	2b00      	cmp	r3, #0
 801502a:	d004      	beq.n	8015036 <wc_RsaPublicKeyDecode_ex+0x18a>
            *e   = dataASN[RSAPUBLICKEYASN_IDX_PUBKEY_RSA_E].data.ref.data;
 801502c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801502e:	33e0      	adds	r3, #224	@ 0xe0
 8015030:	689a      	ldr	r2, [r3, #8]
 8015032:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8015034:	601a      	str	r2, [r3, #0]
        }
        if (eSz != NULL) {
 8015036:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8015038:	2b00      	cmp	r3, #0
 801503a:	d004      	beq.n	8015046 <wc_RsaPublicKeyDecode_ex+0x19a>
            *eSz = dataASN[RSAPUBLICKEYASN_IDX_PUBKEY_RSA_E].data.ref.length;
 801503c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801503e:	33e0      	adds	r3, #224	@ 0xe0
 8015040:	68da      	ldr	r2, [r3, #12]
 8015042:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8015044:	601a      	str	r2, [r3, #0]
        }
    }

    FREE_ASNGETDATA(dataASN, NULL);
 8015046:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8015048:	2b00      	cmp	r3, #0
 801504a:	d007      	beq.n	801505c <wc_RsaPublicKeyDecode_ex+0x1b0>
 801504c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801504e:	623b      	str	r3, [r7, #32]
 8015050:	6a3b      	ldr	r3, [r7, #32]
 8015052:	2b00      	cmp	r3, #0
 8015054:	d002      	beq.n	801505c <wc_RsaPublicKeyDecode_ex+0x1b0>
 8015056:	6a38      	ldr	r0, [r7, #32]
 8015058:	f009 fd32 	bl	801eac0 <wolfSSL_Free>
    return ret;
 801505c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 801505e:	4618      	mov	r0, r3
 8015060:	3738      	adds	r7, #56	@ 0x38
 8015062:	46bd      	mov	sp, r7
 8015064:	bd80      	pop	{r7, pc}
 8015066:	bf00      	nop
 8015068:	080337ec 	.word	0x080337ec
 801506c:	080337d4 	.word	0x080337d4

08015070 <wc_RsaPublicKeyDecode>:
 * @return  ASN_BITSTR_E when the expected BIT_STRING tag is not found.
 * @return  ASN_UNKNOWN_OID_E when the OID cannot be verified.
 */
int wc_RsaPublicKeyDecode(const byte* input, word32* inOutIdx, RsaKey* key,
                       word32 inSz)
{
 8015070:	b590      	push	{r4, r7, lr}
 8015072:	b08f      	sub	sp, #60	@ 0x3c
 8015074:	af04      	add	r7, sp, #16
 8015076:	60f8      	str	r0, [r7, #12]
 8015078:	60b9      	str	r1, [r7, #8]
 801507a:	607a      	str	r2, [r7, #4]
 801507c:	603b      	str	r3, [r7, #0]
    int ret;
    const byte *n = NULL, *e = NULL;
 801507e:	2300      	movs	r3, #0
 8015080:	623b      	str	r3, [r7, #32]
 8015082:	2300      	movs	r3, #0
 8015084:	61fb      	str	r3, [r7, #28]
    word32 nSz = 0, eSz = 0;
 8015086:	2300      	movs	r3, #0
 8015088:	61bb      	str	r3, [r7, #24]
 801508a:	2300      	movs	r3, #0
 801508c:	617b      	str	r3, [r7, #20]

    if (key == NULL)
 801508e:	687b      	ldr	r3, [r7, #4]
 8015090:	2b00      	cmp	r3, #0
 8015092:	d102      	bne.n	801509a <wc_RsaPublicKeyDecode+0x2a>
        return BAD_FUNC_ARG;
 8015094:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8015098:	e01f      	b.n	80150da <wc_RsaPublicKeyDecode+0x6a>

    ret = wc_RsaPublicKeyDecode_ex(input, inOutIdx, inSz, &n, &nSz, &e, &eSz);
 801509a:	f107 0220 	add.w	r2, r7, #32
 801509e:	f107 0314 	add.w	r3, r7, #20
 80150a2:	9302      	str	r3, [sp, #8]
 80150a4:	f107 031c 	add.w	r3, r7, #28
 80150a8:	9301      	str	r3, [sp, #4]
 80150aa:	f107 0318 	add.w	r3, r7, #24
 80150ae:	9300      	str	r3, [sp, #0]
 80150b0:	4613      	mov	r3, r2
 80150b2:	683a      	ldr	r2, [r7, #0]
 80150b4:	68b9      	ldr	r1, [r7, #8]
 80150b6:	68f8      	ldr	r0, [r7, #12]
 80150b8:	f7ff fef8 	bl	8014eac <wc_RsaPublicKeyDecode_ex>
 80150bc:	6278      	str	r0, [r7, #36]	@ 0x24
    if (ret == 0) {
 80150be:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80150c0:	2b00      	cmp	r3, #0
 80150c2:	d109      	bne.n	80150d8 <wc_RsaPublicKeyDecode+0x68>
        ret = wc_RsaPublicKeyDecodeRaw(n, nSz, e, eSz, key);
 80150c4:	6a38      	ldr	r0, [r7, #32]
 80150c6:	69b9      	ldr	r1, [r7, #24]
 80150c8:	69fa      	ldr	r2, [r7, #28]
 80150ca:	697c      	ldr	r4, [r7, #20]
 80150cc:	687b      	ldr	r3, [r7, #4]
 80150ce:	9300      	str	r3, [sp, #0]
 80150d0:	4623      	mov	r3, r4
 80150d2:	f005 f813 	bl	801a0fc <wc_RsaPublicKeyDecodeRaw>
 80150d6:	6278      	str	r0, [r7, #36]	@ 0x24
    }

    return ret;
 80150d8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 80150da:	4618      	mov	r0, r3
 80150dc:	372c      	adds	r7, #44	@ 0x2c
 80150de:	46bd      	mov	sp, r7
 80150e0:	bd90      	pop	{r4, r7, pc}

080150e2 <InitDecodedCert>:
 * @param [in]      inSz    Size of DER data in buffer in bytes.
 * @param [in]      heap    Dynamic memory hint.
 */
void InitDecodedCert(DecodedCert* cert,
                     const byte* source, word32 inSz, void* heap)
{
 80150e2:	b580      	push	{r7, lr}
 80150e4:	b086      	sub	sp, #24
 80150e6:	af02      	add	r7, sp, #8
 80150e8:	60f8      	str	r0, [r7, #12]
 80150ea:	60b9      	str	r1, [r7, #8]
 80150ec:	607a      	str	r2, [r7, #4]
 80150ee:	603b      	str	r3, [r7, #0]
    InitDecodedCert_ex(cert, source, inSz, heap, INVALID_DEVID);
 80150f0:	f06f 0301 	mvn.w	r3, #1
 80150f4:	9300      	str	r3, [sp, #0]
 80150f6:	683b      	ldr	r3, [r7, #0]
 80150f8:	687a      	ldr	r2, [r7, #4]
 80150fa:	68b9      	ldr	r1, [r7, #8]
 80150fc:	68f8      	ldr	r0, [r7, #12]
 80150fe:	f000 f804 	bl	801510a <InitDecodedCert_ex>
}
 8015102:	bf00      	nop
 8015104:	3710      	adds	r7, #16
 8015106:	46bd      	mov	sp, r7
 8015108:	bd80      	pop	{r7, pc}

0801510a <InitDecodedCert_ex>:
 * @param [in]      heap    Dynamic memory hint.
 * @param [in]      devId   Crypto callback ID to use.
 */
void InitDecodedCert_ex(DecodedCert* cert,
                     const byte* source, word32 inSz, void* heap, int devId)
{
 801510a:	b580      	push	{r7, lr}
 801510c:	b084      	sub	sp, #16
 801510e:	af00      	add	r7, sp, #0
 8015110:	60f8      	str	r0, [r7, #12]
 8015112:	60b9      	str	r1, [r7, #8]
 8015114:	607a      	str	r2, [r7, #4]
 8015116:	603b      	str	r3, [r7, #0]
    if (cert != NULL) {
 8015118:	68fb      	ldr	r3, [r7, #12]
 801511a:	2b00      	cmp	r3, #0
 801511c:	d029      	beq.n	8015172 <InitDecodedCert_ex+0x68>
        XMEMSET(cert, 0, sizeof(DecodedCert));
 801511e:	f44f 6297 	mov.w	r2, #1208	@ 0x4b8
 8015122:	2100      	movs	r1, #0
 8015124:	68f8      	ldr	r0, [r7, #12]
 8015126:	f013 f9cf 	bl	80284c8 <memset>

        cert->subjectCNEnc    = CTC_UTF8;
 801512a:	68fb      	ldr	r3, [r7, #12]
 801512c:	220c      	movs	r2, #12
 801512e:	f883 208c 	strb.w	r2, [r3, #140]	@ 0x8c
        cert->issuer[0]       = '\0';
 8015132:	68fb      	ldr	r3, [r7, #12]
 8015134:	2200      	movs	r2, #0
 8015136:	f883 208d 	strb.w	r2, [r3, #141]	@ 0x8d
        cert->subject[0]      = '\0';
 801513a:	68fb      	ldr	r3, [r7, #12]
 801513c:	2200      	movs	r2, #0
 801513e:	f883 21f5 	strb.w	r2, [r3, #501]	@ 0x1f5
        cert->source          = source;  /* don't own */
 8015142:	68fb      	ldr	r3, [r7, #12]
 8015144:	68ba      	ldr	r2, [r7, #8]
 8015146:	f8c3 2364 	str.w	r2, [r3, #868]	@ 0x364
        cert->maxIdx          = inSz;    /* can't go over this index */
 801514a:	68fb      	ldr	r3, [r7, #12]
 801514c:	687a      	ldr	r2, [r7, #4]
 801514e:	f8c3 236c 	str.w	r2, [r3, #876]	@ 0x36c
        cert->heap            = heap;
 8015152:	68fb      	ldr	r3, [r7, #12]
 8015154:	683a      	ldr	r2, [r7, #0]
 8015156:	f8c3 2370 	str.w	r2, [r3, #880]	@ 0x370
        cert->maxPathLen      = WOLFSSL_MAX_PATH_LEN;
 801515a:	68fb      	ldr	r3, [r7, #12]
 801515c:	227f      	movs	r2, #127	@ 0x7f
 801515e:	f883 241d 	strb.w	r2, [r3, #1053]	@ 0x41d
        cert->issuerOEnc     = CTC_UTF8;
        cert->issuerOUEnc    = CTC_UTF8;
    #endif /* WOLFSSL_HAVE_ISSUER_NAMES */
    #endif /* WOLFSSL_CERT_GEN || WOLFSSL_CERT_EXT */

        InitSignatureCtx(&cert->sigCtx, heap, devId);
 8015162:	68fb      	ldr	r3, [r7, #12]
 8015164:	f203 4374 	addw	r3, r3, #1140	@ 0x474
 8015168:	69ba      	ldr	r2, [r7, #24]
 801516a:	6839      	ldr	r1, [r7, #0]
 801516c:	4618      	mov	r0, r3
 801516e:	f000 ff6b 	bl	8016048 <InitSignatureCtx>
    }
}
 8015172:	bf00      	nop
 8015174:	3710      	adds	r7, #16
 8015176:	46bd      	mov	sp, r7
 8015178:	bd80      	pop	{r7, pc}

0801517a <FreeAltNames>:
 *
 * @param [in, out] altNames  Alternative names.
 * @param [in]      heap      Dynamic memory hint.
 */
void FreeAltNames(DNS_entry* altNames, void* heap)
{
 801517a:	b580      	push	{r7, lr}
 801517c:	b086      	sub	sp, #24
 801517e:	af00      	add	r7, sp, #0
 8015180:	6078      	str	r0, [r7, #4]
 8015182:	6039      	str	r1, [r7, #0]
    (void)heap;

    while (altNames) {
 8015184:	e015      	b.n	80151b2 <FreeAltNames+0x38>
        DNS_entry* tmp = altNames->next;
 8015186:	687b      	ldr	r3, [r7, #4]
 8015188:	681b      	ldr	r3, [r3, #0]
 801518a:	617b      	str	r3, [r7, #20]

        XFREE(altNames->name, heap, DYNAMIC_TYPE_ALTNAME);
 801518c:	687b      	ldr	r3, [r7, #4]
 801518e:	68db      	ldr	r3, [r3, #12]
 8015190:	613b      	str	r3, [r7, #16]
 8015192:	693b      	ldr	r3, [r7, #16]
 8015194:	2b00      	cmp	r3, #0
 8015196:	d002      	beq.n	801519e <FreeAltNames+0x24>
 8015198:	6938      	ldr	r0, [r7, #16]
 801519a:	f009 fc91 	bl	801eac0 <wolfSSL_Free>
        XFREE(altNames->ipString, heap, DYNAMIC_TYPE_ALTNAME);
    #endif
    #ifdef WOLFSSL_RID_ALT_NAME
        XFREE(altNames->ridString, heap, DYNAMIC_TYPE_ALTNAME);
    #endif
        XFREE(altNames,       heap, DYNAMIC_TYPE_ALTNAME);
 801519e:	687b      	ldr	r3, [r7, #4]
 80151a0:	60fb      	str	r3, [r7, #12]
 80151a2:	68fb      	ldr	r3, [r7, #12]
 80151a4:	2b00      	cmp	r3, #0
 80151a6:	d002      	beq.n	80151ae <FreeAltNames+0x34>
 80151a8:	68f8      	ldr	r0, [r7, #12]
 80151aa:	f009 fc89 	bl	801eac0 <wolfSSL_Free>
        altNames = tmp;
 80151ae:	697b      	ldr	r3, [r7, #20]
 80151b0:	607b      	str	r3, [r7, #4]
    while (altNames) {
 80151b2:	687b      	ldr	r3, [r7, #4]
 80151b4:	2b00      	cmp	r3, #0
 80151b6:	d1e6      	bne.n	8015186 <FreeAltNames+0xc>
    }
}
 80151b8:	bf00      	nop
 80151ba:	bf00      	nop
 80151bc:	3718      	adds	r7, #24
 80151be:	46bd      	mov	sp, r7
 80151c0:	bd80      	pop	{r7, pc}

080151c2 <AltNameNew>:

/* malloc and initialize a new alt name structure */
DNS_entry* AltNameNew(void* heap)
{
 80151c2:	b580      	push	{r7, lr}
 80151c4:	b084      	sub	sp, #16
 80151c6:	af00      	add	r7, sp, #0
 80151c8:	6078      	str	r0, [r7, #4]
    DNS_entry* ret;
    ret = (DNS_entry*)XMALLOC(sizeof(DNS_entry), heap, DYNAMIC_TYPE_ALTNAME);
 80151ca:	2010      	movs	r0, #16
 80151cc:	f009 fc5c 	bl	801ea88 <wolfSSL_Malloc>
 80151d0:	60f8      	str	r0, [r7, #12]
    if (ret != NULL) {
 80151d2:	68fb      	ldr	r3, [r7, #12]
 80151d4:	2b00      	cmp	r3, #0
 80151d6:	d004      	beq.n	80151e2 <AltNameNew+0x20>
        XMEMSET(ret, 0, sizeof(DNS_entry));
 80151d8:	2210      	movs	r2, #16
 80151da:	2100      	movs	r1, #0
 80151dc:	68f8      	ldr	r0, [r7, #12]
 80151de:	f013 f973 	bl	80284c8 <memset>
    }
    (void)heap;
    return ret;
 80151e2:	68fb      	ldr	r3, [r7, #12]
}
 80151e4:	4618      	mov	r0, r3
 80151e6:	3710      	adds	r7, #16
 80151e8:	46bd      	mov	sp, r7
 80151ea:	bd80      	pop	{r7, pc}

080151ec <AltNameDup>:

DNS_entry* AltNameDup(DNS_entry* from, void* heap)
{
 80151ec:	b580      	push	{r7, lr}
 80151ee:	b084      	sub	sp, #16
 80151f0:	af00      	add	r7, sp, #0
 80151f2:	6078      	str	r0, [r7, #4]
 80151f4:	6039      	str	r1, [r7, #0]
    DNS_entry* ret;

    ret = AltNameNew(heap);
 80151f6:	6838      	ldr	r0, [r7, #0]
 80151f8:	f7ff ffe3 	bl	80151c2 <AltNameNew>
 80151fc:	60f8      	str	r0, [r7, #12]
    if (ret == NULL) {
 80151fe:	68fb      	ldr	r3, [r7, #12]
 8015200:	2b00      	cmp	r3, #0
 8015202:	d101      	bne.n	8015208 <AltNameDup+0x1c>
        WOLFSSL_MSG("\tOut of Memory");
        return NULL;
 8015204:	2300      	movs	r3, #0
 8015206:	e01d      	b.n	8015244 <AltNameDup+0x58>
    }

    ret->type = from->type;
 8015208:	687b      	ldr	r3, [r7, #4]
 801520a:	685a      	ldr	r2, [r3, #4]
 801520c:	68fb      	ldr	r3, [r7, #12]
 801520e:	605a      	str	r2, [r3, #4]
    ret->len = from->len;
 8015210:	687b      	ldr	r3, [r7, #4]
 8015212:	689a      	ldr	r2, [r3, #8]
 8015214:	68fb      	ldr	r3, [r7, #12]
 8015216:	609a      	str	r2, [r3, #8]


    ret->name = CopyString(from->name, from->len, heap, DYNAMIC_TYPE_ALTNAME);
 8015218:	687b      	ldr	r3, [r7, #4]
 801521a:	68d8      	ldr	r0, [r3, #12]
 801521c:	687b      	ldr	r3, [r7, #4]
 801521e:	6899      	ldr	r1, [r3, #8]
 8015220:	231d      	movs	r3, #29
 8015222:	683a      	ldr	r2, [r7, #0]
 8015224:	f7fd fa5e 	bl	80126e4 <CopyString>
 8015228:	4602      	mov	r2, r0
 801522a:	68fb      	ldr	r3, [r7, #12]
 801522c:	60da      	str	r2, [r3, #12]
    ret->ipString = CopyString(from->ipString, 0, heap, DYNAMIC_TYPE_ALTNAME);
#endif
#ifdef WOLFSSL_RID_ALT_NAME
    ret->ridString = CopyString(from->ridString, 0, heap, DYNAMIC_TYPE_ALTNAME);
#endif
    if (ret->name == NULL
 801522e:	68fb      	ldr	r3, [r7, #12]
 8015230:	68db      	ldr	r3, [r3, #12]
 8015232:	2b00      	cmp	r3, #0
 8015234:	d105      	bne.n	8015242 <AltNameDup+0x56>
#ifdef WOLFSSL_RID_ALT_NAME
            || (from->ridString != NULL && ret->ridString == NULL)
#endif
            ) {
        WOLFSSL_MSG("\tOut of Memory");
        FreeAltNames(ret, heap);
 8015236:	6839      	ldr	r1, [r7, #0]
 8015238:	68f8      	ldr	r0, [r7, #12]
 801523a:	f7ff ff9e 	bl	801517a <FreeAltNames>
        return NULL;
 801523e:	2300      	movs	r3, #0
 8015240:	e000      	b.n	8015244 <AltNameDup+0x58>

#ifdef WOLFSSL_FPKI
    ret->oidSum = from->oidSum;
#endif

    return ret;
 8015242:	68fb      	ldr	r3, [r7, #12]
}
 8015244:	4618      	mov	r0, r3
 8015246:	3710      	adds	r7, #16
 8015248:	46bd      	mov	sp, r7
 801524a:	bd80      	pop	{r7, pc}

0801524c <FreeNameSubtrees>:
 *
 * @param [in, out] names  Subtree names.
 * @param [in]      heap   Dynamic memory hint.
 */
void FreeNameSubtrees(Base_entry* names, void* heap)
{
 801524c:	b580      	push	{r7, lr}
 801524e:	b086      	sub	sp, #24
 8015250:	af00      	add	r7, sp, #0
 8015252:	6078      	str	r0, [r7, #4]
 8015254:	6039      	str	r1, [r7, #0]
    (void)heap;

    while (names) {
 8015256:	e015      	b.n	8015284 <FreeNameSubtrees+0x38>
        Base_entry* tmp = names->next;
 8015258:	687b      	ldr	r3, [r7, #4]
 801525a:	681b      	ldr	r3, [r3, #0]
 801525c:	617b      	str	r3, [r7, #20]

        XFREE(names->name, heap, DYNAMIC_TYPE_ALTNAME);
 801525e:	687b      	ldr	r3, [r7, #4]
 8015260:	685b      	ldr	r3, [r3, #4]
 8015262:	613b      	str	r3, [r7, #16]
 8015264:	693b      	ldr	r3, [r7, #16]
 8015266:	2b00      	cmp	r3, #0
 8015268:	d002      	beq.n	8015270 <FreeNameSubtrees+0x24>
 801526a:	6938      	ldr	r0, [r7, #16]
 801526c:	f009 fc28 	bl	801eac0 <wolfSSL_Free>
        XFREE(names,       heap, DYNAMIC_TYPE_ALTNAME);
 8015270:	687b      	ldr	r3, [r7, #4]
 8015272:	60fb      	str	r3, [r7, #12]
 8015274:	68fb      	ldr	r3, [r7, #12]
 8015276:	2b00      	cmp	r3, #0
 8015278:	d002      	beq.n	8015280 <FreeNameSubtrees+0x34>
 801527a:	68f8      	ldr	r0, [r7, #12]
 801527c:	f009 fc20 	bl	801eac0 <wolfSSL_Free>
        names = tmp;
 8015280:	697b      	ldr	r3, [r7, #20]
 8015282:	607b      	str	r3, [r7, #4]
    while (names) {
 8015284:	687b      	ldr	r3, [r7, #4]
 8015286:	2b00      	cmp	r3, #0
 8015288:	d1e6      	bne.n	8015258 <FreeNameSubtrees+0xc>
    }
}
 801528a:	bf00      	nop
 801528c:	bf00      	nop
 801528e:	3718      	adds	r7, #24
 8015290:	46bd      	mov	sp, r7
 8015292:	bd80      	pop	{r7, pc}

08015294 <FreeDecodedCert>:
/* Free the decoded cert object's dynamic data.
 *
 * @param [in, out] cert  Decoded certificate object.
 */
void FreeDecodedCert(DecodedCert* cert)
{
 8015294:	b580      	push	{r7, lr}
 8015296:	b084      	sub	sp, #16
 8015298:	af00      	add	r7, sp, #0
 801529a:	6078      	str	r0, [r7, #4]
    if (cert == NULL)
 801529c:	687b      	ldr	r3, [r7, #4]
 801529e:	2b00      	cmp	r3, #0
 80152a0:	f000 8085 	beq.w	80153ae <FreeDecodedCert+0x11a>
        return;
    if (cert->subjectCNStored == 1) {
 80152a4:	687b      	ldr	r3, [r7, #4]
 80152a6:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 80152aa:	f003 0301 	and.w	r3, r3, #1
 80152ae:	b2db      	uxtb	r3, r3
 80152b0:	2b00      	cmp	r3, #0
 80152b2:	d009      	beq.n	80152c8 <FreeDecodedCert+0x34>
        XFREE(cert->subjectCN, cert->heap, DYNAMIC_TYPE_SUBJECT_CN);
 80152b4:	687b      	ldr	r3, [r7, #4]
 80152b6:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 80152ba:	60fb      	str	r3, [r7, #12]
 80152bc:	68fb      	ldr	r3, [r7, #12]
 80152be:	2b00      	cmp	r3, #0
 80152c0:	d002      	beq.n	80152c8 <FreeDecodedCert+0x34>
 80152c2:	68f8      	ldr	r0, [r7, #12]
 80152c4:	f009 fbfc 	bl	801eac0 <wolfSSL_Free>
    }
    if (cert->pubKeyStored == 1) {
 80152c8:	687b      	ldr	r3, [r7, #4]
 80152ca:	689b      	ldr	r3, [r3, #8]
 80152cc:	2b01      	cmp	r3, #1
 80152ce:	d108      	bne.n	80152e2 <FreeDecodedCert+0x4e>
        XFREE((void*)cert->publicKey, cert->heap, DYNAMIC_TYPE_PUBLIC_KEY);
 80152d0:	687b      	ldr	r3, [r7, #4]
 80152d2:	681b      	ldr	r3, [r3, #0]
 80152d4:	60bb      	str	r3, [r7, #8]
 80152d6:	68bb      	ldr	r3, [r7, #8]
 80152d8:	2b00      	cmp	r3, #0
 80152da:	d002      	beq.n	80152e2 <FreeDecodedCert+0x4e>
 80152dc:	68b8      	ldr	r0, [r7, #8]
 80152de:	f009 fbef 	bl	801eac0 <wolfSSL_Free>
    }
    if (cert->weOwnAltNames && cert->altNames)
 80152e2:	687b      	ldr	r3, [r7, #4]
 80152e4:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 80152e8:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 80152ec:	b2db      	uxtb	r3, r3
 80152ee:	2b00      	cmp	r3, #0
 80152f0:	d00c      	beq.n	801530c <FreeDecodedCert+0x78>
 80152f2:	687b      	ldr	r3, [r7, #4]
 80152f4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80152f6:	2b00      	cmp	r3, #0
 80152f8:	d008      	beq.n	801530c <FreeDecodedCert+0x78>
        FreeAltNames(cert->altNames, cert->heap);
 80152fa:	687b      	ldr	r3, [r7, #4]
 80152fc:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 80152fe:	687b      	ldr	r3, [r7, #4]
 8015300:	f8d3 3370 	ldr.w	r3, [r3, #880]	@ 0x370
 8015304:	4619      	mov	r1, r3
 8015306:	4610      	mov	r0, r2
 8015308:	f7ff ff37 	bl	801517a <FreeAltNames>
#ifndef IGNORE_NAME_CONSTRAINTS
    if (cert->altEmailNames)
 801530c:	687b      	ldr	r3, [r7, #4]
 801530e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8015310:	2b00      	cmp	r3, #0
 8015312:	d008      	beq.n	8015326 <FreeDecodedCert+0x92>
        FreeAltNames(cert->altEmailNames, cert->heap);
 8015314:	687b      	ldr	r3, [r7, #4]
 8015316:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8015318:	687b      	ldr	r3, [r7, #4]
 801531a:	f8d3 3370 	ldr.w	r3, [r3, #880]	@ 0x370
 801531e:	4619      	mov	r1, r3
 8015320:	4610      	mov	r0, r2
 8015322:	f7ff ff2a 	bl	801517a <FreeAltNames>
    if (cert->altDirNames)
 8015326:	687b      	ldr	r3, [r7, #4]
 8015328:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 801532a:	2b00      	cmp	r3, #0
 801532c:	d008      	beq.n	8015340 <FreeDecodedCert+0xac>
        FreeAltNames(cert->altDirNames, cert->heap);
 801532e:	687b      	ldr	r3, [r7, #4]
 8015330:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8015332:	687b      	ldr	r3, [r7, #4]
 8015334:	f8d3 3370 	ldr.w	r3, [r3, #880]	@ 0x370
 8015338:	4619      	mov	r1, r3
 801533a:	4610      	mov	r0, r2
 801533c:	f7ff ff1d 	bl	801517a <FreeAltNames>
    if (cert->permittedNames)
 8015340:	687b      	ldr	r3, [r7, #4]
 8015342:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8015344:	2b00      	cmp	r3, #0
 8015346:	d008      	beq.n	801535a <FreeDecodedCert+0xc6>
        FreeNameSubtrees(cert->permittedNames, cert->heap);
 8015348:	687b      	ldr	r3, [r7, #4]
 801534a:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 801534c:	687b      	ldr	r3, [r7, #4]
 801534e:	f8d3 3370 	ldr.w	r3, [r3, #880]	@ 0x370
 8015352:	4619      	mov	r1, r3
 8015354:	4610      	mov	r0, r2
 8015356:	f7ff ff79 	bl	801524c <FreeNameSubtrees>
    if (cert->excludedNames)
 801535a:	687b      	ldr	r3, [r7, #4]
 801535c:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 801535e:	2b00      	cmp	r3, #0
 8015360:	d008      	beq.n	8015374 <FreeDecodedCert+0xe0>
        FreeNameSubtrees(cert->excludedNames, cert->heap);
 8015362:	687b      	ldr	r3, [r7, #4]
 8015364:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8015366:	687b      	ldr	r3, [r7, #4]
 8015368:	f8d3 3370 	ldr.w	r3, [r3, #880]	@ 0x370
 801536c:	4619      	mov	r1, r3
 801536e:	4610      	mov	r0, r2
 8015370:	f7ff ff6c 	bl	801524c <FreeNameSubtrees>
    XFREE(cert->deviceType, cert->heap, DYNAMIC_TYPE_X509_EXT);
    XFREE(cert->hwType, cert->heap, DYNAMIC_TYPE_X509_EXT);
    XFREE(cert->hwSerialNum, cert->heap, DYNAMIC_TYPE_X509_EXT);
#endif /* WOLFSSL_SEP */
#ifdef WOLFSSL_X509_NAME_AVAILABLE
    if (cert->issuerName != NULL)
 8015374:	687b      	ldr	r3, [r7, #4]
 8015376:	f8d3 3464 	ldr.w	r3, [r3, #1124]	@ 0x464
 801537a:	2b00      	cmp	r3, #0
 801537c:	d005      	beq.n	801538a <FreeDecodedCert+0xf6>
        wolfSSL_X509_NAME_free((WOLFSSL_X509_NAME*)cert->issuerName);
 801537e:	687b      	ldr	r3, [r7, #4]
 8015380:	f8d3 3464 	ldr.w	r3, [r3, #1124]	@ 0x464
 8015384:	4618      	mov	r0, r3
 8015386:	f7f9 f8f6 	bl	800e576 <wolfSSL_X509_NAME_free>
    if (cert->subjectName != NULL)
 801538a:	687b      	ldr	r3, [r7, #4]
 801538c:	f8d3 3468 	ldr.w	r3, [r3, #1128]	@ 0x468
 8015390:	2b00      	cmp	r3, #0
 8015392:	d005      	beq.n	80153a0 <FreeDecodedCert+0x10c>
        wolfSSL_X509_NAME_free((WOLFSSL_X509_NAME*)cert->subjectName);
 8015394:	687b      	ldr	r3, [r7, #4]
 8015396:	f8d3 3468 	ldr.w	r3, [r3, #1128]	@ 0x468
 801539a:	4618      	mov	r0, r3
 801539c:	f7f9 f8eb 	bl	800e576 <wolfSSL_X509_NAME_free>
#endif /* WOLFSSL_X509_NAME_AVAILABLE */
#if defined(WOLFSSL_RENESAS_TSIP_TLS) || defined(WOLFSSL_RENESAS_FSPSM_TLS)
    XFREE(cert->sce_tsip_encRsaKeyIdx, cert->heap, DYNAMIC_TYPE_RSA);
#endif
    FreeSignatureCtx(&cert->sigCtx);
 80153a0:	687b      	ldr	r3, [r7, #4]
 80153a2:	f203 4374 	addw	r3, r3, #1140	@ 0x474
 80153a6:	4618      	mov	r0, r3
 80153a8:	f000 fe66 	bl	8016078 <FreeSignatureCtx>
 80153ac:	e000      	b.n	80153b0 <FreeDecodedCert+0x11c>
        return;
 80153ae:	bf00      	nop
}
 80153b0:	3710      	adds	r7, #16
 80153b2:	46bd      	mov	sp, r7
 80153b4:	bd80      	pop	{r7, pc}
	...

080153b8 <StoreRsaKey>:
 * @return  ASN_EXPECT_0_E when the INTEGER has the MSB set or NULL has a
 *          non-zero length.
 */
static int StoreRsaKey(DecodedCert* cert, const byte* source, word32* srcIdx,
                       word32 maxIdx)
{
 80153b8:	b580      	push	{r7, lr}
 80153ba:	b098      	sub	sp, #96	@ 0x60
 80153bc:	af04      	add	r7, sp, #16
 80153be:	60f8      	str	r0, [r7, #12]
 80153c0:	60b9      	str	r1, [r7, #8]
 80153c2:	607a      	str	r2, [r7, #4]
 80153c4:	603b      	str	r3, [r7, #0]
#else
    ASNGetData dataASN[rsaCertKeyASN_Length];
    int ret;

    /* No dynamic data. */
    XMEMSET(dataASN, 0, sizeof(dataASN));
 80153c6:	f107 0314 	add.w	r3, r7, #20
 80153ca:	2238      	movs	r2, #56	@ 0x38
 80153cc:	2100      	movs	r1, #0
 80153ce:	4618      	mov	r0, r3
 80153d0:	f013 f87a 	bl	80284c8 <memset>
    /* Decode the header before the key data. */
    ret = GetASN_Items(rsaCertKeyASN, dataASN, rsaCertKeyASN_Length, 1, source,
 80153d4:	f107 0114 	add.w	r1, r7, #20
 80153d8:	683b      	ldr	r3, [r7, #0]
 80153da:	9302      	str	r3, [sp, #8]
 80153dc:	687b      	ldr	r3, [r7, #4]
 80153de:	9301      	str	r3, [sp, #4]
 80153e0:	68bb      	ldr	r3, [r7, #8]
 80153e2:	9300      	str	r3, [sp, #0]
 80153e4:	2301      	movs	r3, #1
 80153e6:	2202      	movs	r2, #2
 80153e8:	4808      	ldr	r0, [pc, #32]	@ (801540c <StoreRsaKey+0x54>)
 80153ea:	f7fe f989 	bl	8013700 <GetASN_Items>
 80153ee:	64f8      	str	r0, [r7, #76]	@ 0x4c
                       srcIdx, maxIdx);
    if (ret == 0) {
 80153f0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80153f2:	2b00      	cmp	r3, #0
 80153f4:	d105      	bne.n	8015402 <StoreRsaKey+0x4a>
        /* Store the pointer and length in certificate object starting at
         * SEQUENCE. */
        GetASN_GetConstRef(&dataASN[RSACERTKEYASN_IDX_STR],
 80153f6:	69fa      	ldr	r2, [r7, #28]
 80153f8:	68fb      	ldr	r3, [r7, #12]
 80153fa:	601a      	str	r2, [r3, #0]
 80153fc:	6a3a      	ldr	r2, [r7, #32]
 80153fe:	68fb      	ldr	r3, [r7, #12]
 8015400:	605a      	str	r2, [r3, #4]
        ret = CalcHashId_ex(cert->publicKey, cert->pubKeySize,
                         cert->subjectKeyHash, HashIdAlg(cert->signatureOID));
    #endif
    }

    return ret;
 8015402:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 8015404:	4618      	mov	r0, r3
 8015406:	3750      	adds	r7, #80	@ 0x50
 8015408:	46bd      	mov	sp, r7
 801540a:	bd80      	pop	{r7, pc}
 801540c:	08033810 	.word	0x08033810

08015410 <StoreEccKey>:
 *          non-zero length.
 * @return  ASN_OBJECT_ID_E when the expected OBJECT_ID tag is not found.
 */
static int StoreEccKey(DecodedCert* cert, const byte* source, word32* srcIdx,
                       word32 maxIdx, const byte* pubKey, word32 pubKeyLen)
{
 8015410:	b580      	push	{r7, lr}
 8015412:	b08c      	sub	sp, #48	@ 0x30
 8015414:	af04      	add	r7, sp, #16
 8015416:	60f8      	str	r0, [r7, #12]
 8015418:	60b9      	str	r1, [r7, #8]
 801541a:	607a      	str	r2, [r7, #4]
 801541c:	603b      	str	r3, [r7, #0]
    cert->pubKeyStored = 1;
    cert->pubKeySize   = pubKeyLen;

    return 0;
#else
    int ret = 0;
 801541e:	2300      	movs	r3, #0
 8015420:	61fb      	str	r3, [r7, #28]
    DECL_ASNGETDATA(dataASN, eccCertKeyASN_Length);
 8015422:	2300      	movs	r3, #0
 8015424:	61bb      	str	r3, [r7, #24]
    byte* publicKey;

    /* Validate parameters. */
    if (pubKey == NULL) {
 8015426:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8015428:	2b00      	cmp	r3, #0
 801542a:	d102      	bne.n	8015432 <StoreEccKey+0x22>
        ret = BAD_FUNC_ARG;
 801542c:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8015430:	61fb      	str	r3, [r7, #28]
    }

    /* Clear dynamic data and check OID is a curve. */
    CALLOC_ASNGETDATA(dataASN, eccCertKeyASN_Length, ret, cert->heap);
 8015432:	69fb      	ldr	r3, [r7, #28]
 8015434:	2b00      	cmp	r3, #0
 8015436:	d109      	bne.n	801544c <StoreEccKey+0x3c>
 8015438:	2054      	movs	r0, #84	@ 0x54
 801543a:	f009 fb25 	bl	801ea88 <wolfSSL_Malloc>
 801543e:	61b8      	str	r0, [r7, #24]
 8015440:	69bb      	ldr	r3, [r7, #24]
 8015442:	2b00      	cmp	r3, #0
 8015444:	d102      	bne.n	801544c <StoreEccKey+0x3c>
 8015446:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801544a:	61fb      	str	r3, [r7, #28]
 801544c:	69fb      	ldr	r3, [r7, #28]
 801544e:	2b00      	cmp	r3, #0
 8015450:	d104      	bne.n	801545c <StoreEccKey+0x4c>
 8015452:	2254      	movs	r2, #84	@ 0x54
 8015454:	2100      	movs	r1, #0
 8015456:	69b8      	ldr	r0, [r7, #24]
 8015458:	f013 f836 	bl	80284c8 <memset>
    if (ret == 0) {
 801545c:	69fb      	ldr	r3, [r7, #28]
 801545e:	2b00      	cmp	r3, #0
 8015460:	d10f      	bne.n	8015482 <StoreEccKey+0x72>
        GetASN_OID(&dataASN[ECCCERTKEYASN_IDX_OID], oidCurveType);
 8015462:	69bb      	ldr	r3, [r7, #24]
 8015464:	2203      	movs	r2, #3
 8015466:	611a      	str	r2, [r3, #16]
        /* Parse ECC public key header. */
        ret = GetASN_Items(eccCertKeyASN, dataASN, eccCertKeyASN_Length, 1,
 8015468:	683b      	ldr	r3, [r7, #0]
 801546a:	9302      	str	r3, [sp, #8]
 801546c:	687b      	ldr	r3, [r7, #4]
 801546e:	9301      	str	r3, [sp, #4]
 8015470:	68bb      	ldr	r3, [r7, #8]
 8015472:	9300      	str	r3, [sp, #0]
 8015474:	2301      	movs	r3, #1
 8015476:	2203      	movs	r2, #3
 8015478:	69b9      	ldr	r1, [r7, #24]
 801547a:	4820      	ldr	r0, [pc, #128]	@ (80154fc <StoreEccKey+0xec>)
 801547c:	f7fe f940 	bl	8013700 <GetASN_Items>
 8015480:	61f8      	str	r0, [r7, #28]
                source, srcIdx, maxIdx);
    }
    if (ret == 0) {
 8015482:	69fb      	ldr	r3, [r7, #28]
 8015484:	2b00      	cmp	r3, #0
 8015486:	d129      	bne.n	80154dc <StoreEccKey+0xcc>
        if (dataASN[ECCCERTKEYASN_IDX_OID].tag != 0) {
 8015488:	69bb      	ldr	r3, [r7, #24]
 801548a:	7e5b      	ldrb	r3, [r3, #25]
 801548c:	2b00      	cmp	r3, #0
 801548e:	d005      	beq.n	801549c <StoreEccKey+0x8c>
            /* Store curve OID. */
            cert->pkCurveOID = dataASN[ECCCERTKEYASN_IDX_OID].data.oid.sum;
 8015490:	69bb      	ldr	r3, [r7, #24]
 8015492:	695a      	ldr	r2, [r3, #20]
 8015494:	68fb      	ldr	r3, [r7, #12]
 8015496:	f8c3 2440 	str.w	r2, [r3, #1088]	@ 0x440
 801549a:	e002      	b.n	80154a2 <StoreEccKey+0x92>
                    dataASN[ECCCERTKEYASN_IDX_PARAMS].data.ref.data,
                    dataASN[ECCCERTKEYASN_IDX_PARAMS].data.ref.length, NULL,
                    NULL, &cert->pkCurveSize);
    #else
            /* Explicit parameters not supported in build configuration. */
            ret = ASN_PARSE_E;
 801549c:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80154a0:	61fb      	str	r3, [r7, #28]
        }
    }
    if (ret == 0) {
    #endif
        /* Store public key data length. */
        cert->pubKeySize = pubKeyLen;
 80154a2:	68fb      	ldr	r3, [r7, #12]
 80154a4:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80154a6:	605a      	str	r2, [r3, #4]
        /* Must allocated space for key.
         * Don't memcpy into constant pointer so use temp. */
        publicKey = (byte*)XMALLOC(cert->pubKeySize, cert->heap,
 80154a8:	68fb      	ldr	r3, [r7, #12]
 80154aa:	685b      	ldr	r3, [r3, #4]
 80154ac:	4618      	mov	r0, r3
 80154ae:	f009 faeb 	bl	801ea88 <wolfSSL_Malloc>
 80154b2:	6178      	str	r0, [r7, #20]
                                   DYNAMIC_TYPE_PUBLIC_KEY);
        if (publicKey == NULL) {
 80154b4:	697b      	ldr	r3, [r7, #20]
 80154b6:	2b00      	cmp	r3, #0
 80154b8:	d103      	bne.n	80154c2 <StoreEccKey+0xb2>
            ret = MEMORY_E;
 80154ba:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 80154be:	61fb      	str	r3, [r7, #28]
 80154c0:	e00c      	b.n	80154dc <StoreEccKey+0xcc>
        }
        else {
            /* Copy in whole public key and store pointer. */
            XMEMCPY(publicKey, pubKey, cert->pubKeySize);
 80154c2:	68fb      	ldr	r3, [r7, #12]
 80154c4:	685b      	ldr	r3, [r3, #4]
 80154c6:	461a      	mov	r2, r3
 80154c8:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 80154ca:	6978      	ldr	r0, [r7, #20]
 80154cc:	f013 f866 	bl	802859c <memcpy>
            cert->publicKey = publicKey;
 80154d0:	68fb      	ldr	r3, [r7, #12]
 80154d2:	697a      	ldr	r2, [r7, #20]
 80154d4:	601a      	str	r2, [r3, #0]
            /* Indicate publicKey needs to be freed. */
            cert->pubKeyStored = 1;
 80154d6:	68fb      	ldr	r3, [r7, #12]
 80154d8:	2201      	movs	r2, #1
 80154da:	609a      	str	r2, [r3, #8]
        }
    }
    FREE_ASNGETDATA(dataASN, cert->heap);
 80154dc:	69bb      	ldr	r3, [r7, #24]
 80154de:	2b00      	cmp	r3, #0
 80154e0:	d007      	beq.n	80154f2 <StoreEccKey+0xe2>
 80154e2:	69bb      	ldr	r3, [r7, #24]
 80154e4:	613b      	str	r3, [r7, #16]
 80154e6:	693b      	ldr	r3, [r7, #16]
 80154e8:	2b00      	cmp	r3, #0
 80154ea:	d002      	beq.n	80154f2 <StoreEccKey+0xe2>
 80154ec:	6938      	ldr	r0, [r7, #16]
 80154ee:	f009 fae7 	bl	801eac0 <wolfSSL_Free>

    return ret;
 80154f2:	69fb      	ldr	r3, [r7, #28]
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 80154f4:	4618      	mov	r0, r3
 80154f6:	3720      	adds	r7, #32
 80154f8:	46bd      	mov	sp, r7
 80154fa:	bd80      	pop	{r7, pc}
 80154fc:	08033818 	.word	0x08033818

08015500 <GetCertKey>:
 *          is invalid.
 * @return  BUFFER_E when data in buffer is too small.
 */
static int GetCertKey(DecodedCert* cert, const byte* source, word32* inOutIdx,
                      word32 maxIdx)
{
 8015500:	b590      	push	{r4, r7, lr}
 8015502:	b095      	sub	sp, #84	@ 0x54
 8015504:	af02      	add	r7, sp, #8
 8015506:	60f8      	str	r0, [r7, #12]
 8015508:	60b9      	str	r1, [r7, #8]
 801550a:	607a      	str	r2, [r7, #4]
 801550c:	603b      	str	r3, [r7, #0]
    word32 srcIdx = *inOutIdx;
 801550e:	687b      	ldr	r3, [r7, #4]
 8015510:	681b      	ldr	r3, [r3, #0]
 8015512:	637b      	str	r3, [r7, #52]	@ 0x34
#if defined(HAVE_ECC) || !defined(NO_DSA)
    int pubLen;
#endif
#if defined(HAVE_ECC) || !defined(NO_DSA)
    int pubIdx = (int)srcIdx;
 8015514:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8015516:	643b      	str	r3, [r7, #64]	@ 0x40
#endif
    int ret = 0;
 8015518:	2300      	movs	r3, #0
 801551a:	647b      	str	r3, [r7, #68]	@ 0x44
    int length;

    /* Validate parameters. */
    if (source == NULL) {
 801551c:	68bb      	ldr	r3, [r7, #8]
 801551e:	2b00      	cmp	r3, #0
 8015520:	d102      	bne.n	8015528 <GetCertKey+0x28>
        return ASN_PARSE_E;
 8015522:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8015526:	e0db      	b.n	80156e0 <GetCertKey+0x1e0>

#ifndef WOLFSSL_ASN_TEMPLATE
    if (GetSequence(source, &srcIdx, &length, maxIdx) < 0)
#else
    /* Get SEQUENCE and expect all data to be accounted for. */
    if (GetASN_Sequence(source, &srcIdx, &length, maxIdx, 1) != 0)
 8015528:	f107 0230 	add.w	r2, r7, #48	@ 0x30
 801552c:	f107 0134 	add.w	r1, r7, #52	@ 0x34
 8015530:	2301      	movs	r3, #1
 8015532:	9300      	str	r3, [sp, #0]
 8015534:	683b      	ldr	r3, [r7, #0]
 8015536:	68b8      	ldr	r0, [r7, #8]
 8015538:	f7fe fb89 	bl	8013c4e <GetASN_Sequence>
 801553c:	4603      	mov	r3, r0
 801553e:	2b00      	cmp	r3, #0
 8015540:	d002      	beq.n	8015548 <GetCertKey+0x48>
#endif
    {
        return ASN_PARSE_E;
 8015542:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8015546:	e0cb      	b.n	80156e0 <GetCertKey+0x1e0>
    }

#if defined(HAVE_ECC) || !defined(NO_DSA)
    pubLen = (int)srcIdx - pubIdx + length;
 8015548:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801554a:	461a      	mov	r2, r3
 801554c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801554e:	1ad2      	subs	r2, r2, r3
 8015550:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8015552:	4413      	add	r3, r2
 8015554:	63fb      	str	r3, [r7, #60]	@ 0x3c
#endif
    maxIdx = srcIdx + (word32)length;
 8015556:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8015558:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801555a:	4413      	add	r3, r2
 801555c:	603b      	str	r3, [r7, #0]

    /* Decode the algorithm identifier for the key. */
    if (GetAlgoId(source, &srcIdx, &cert->keyOID, oidKeyType, maxIdx) < 0) {
 801555e:	68fb      	ldr	r3, [r7, #12]
 8015560:	f103 021c 	add.w	r2, r3, #28
 8015564:	f107 0134 	add.w	r1, r7, #52	@ 0x34
 8015568:	683b      	ldr	r3, [r7, #0]
 801556a:	9300      	str	r3, [sp, #0]
 801556c:	2302      	movs	r3, #2
 801556e:	68b8      	ldr	r0, [r7, #8]
 8015570:	f7ff f96c 	bl	801484c <GetAlgoId>
 8015574:	4603      	mov	r3, r0
 8015576:	2b00      	cmp	r3, #0
 8015578:	da02      	bge.n	8015580 <GetCertKey+0x80>
        return ASN_PARSE_E;
 801557a:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801557e:	e0af      	b.n	80156e0 <GetCertKey+0x1e0>
    }

    (void)length;

    /* Parse each type of public key. */
    switch (cert->keyOID) {
 8015580:	68fb      	ldr	r3, [r7, #12]
 8015582:	69db      	ldr	r3, [r3, #28]
 8015584:	f240 228e 	movw	r2, #654	@ 0x28e
 8015588:	4293      	cmp	r3, r2
 801558a:	d00e      	beq.n	80155aa <GetCertKey+0xaa>
 801558c:	f240 228e 	movw	r2, #654	@ 0x28e
 8015590:	4293      	cmp	r3, r2
 8015592:	f200 809e 	bhi.w	80156d2 <GetCertKey+0x1d2>
 8015596:	f240 2206 	movw	r2, #518	@ 0x206
 801559a:	4293      	cmp	r3, r2
 801559c:	f000 8089 	beq.w	80156b2 <GetCertKey+0x1b2>
 80155a0:	f240 2285 	movw	r2, #645	@ 0x285
 80155a4:	4293      	cmp	r3, r2
 80155a6:	d07b      	beq.n	80156a0 <GetCertKey+0x1a0>
 80155a8:	e093      	b.n	80156d2 <GetCertKey+0x1d2>
#ifndef NO_RSA
    #ifdef WC_RSA_PSS
        case RSAPSSk:
            if (srcIdx != maxIdx &&
 80155aa:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80155ac:	683a      	ldr	r2, [r7, #0]
 80155ae:	429a      	cmp	r2, r3
 80155b0:	d076      	beq.n	80156a0 <GetCertKey+0x1a0>
                          source[srcIdx] == (ASN_SEQUENCE | ASN_CONSTRUCTED)) {
 80155b2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80155b4:	68ba      	ldr	r2, [r7, #8]
 80155b6:	4413      	add	r3, r2
 80155b8:	781b      	ldrb	r3, [r3, #0]
            if (srcIdx != maxIdx &&
 80155ba:	2b30      	cmp	r3, #48	@ 0x30
 80155bc:	d170      	bne.n	80156a0 <GetCertKey+0x1a0>
                word32 seqIdx = srcIdx;
 80155be:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80155c0:	63bb      	str	r3, [r7, #56]	@ 0x38
                int seqLen;
                /* Not set when -1. */
                enum wc_HashType hash = WC_HASH_TYPE_NONE;
 80155c2:	2300      	movs	r3, #0
 80155c4:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
                int mgf = -1;
 80155c8:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80155cc:	627b      	str	r3, [r7, #36]	@ 0x24
                int saltLen = 0;
 80155ce:	2300      	movs	r3, #0
 80155d0:	623b      	str	r3, [r7, #32]
                /* Defaults for sig algorithm parameters. */
                enum wc_HashType sigHash = WC_HASH_TYPE_SHA;
 80155d2:	2304      	movs	r3, #4
 80155d4:	77fb      	strb	r3, [r7, #31]
                int sigMgf = WC_MGF1SHA1;
 80155d6:	231a      	movs	r3, #26
 80155d8:	61bb      	str	r3, [r7, #24]
                int sigSaltLen = 20;
 80155da:	2314      	movs	r3, #20
 80155dc:	617b      	str	r3, [r7, #20]

                if (GetSequence(source, &srcIdx, &seqLen, maxIdx) < 0) {
 80155de:	f107 022c 	add.w	r2, r7, #44	@ 0x2c
 80155e2:	f107 0134 	add.w	r1, r7, #52	@ 0x34
 80155e6:	683b      	ldr	r3, [r7, #0]
 80155e8:	68b8      	ldr	r0, [r7, #8]
 80155ea:	f7fe fccd 	bl	8013f88 <GetSequence>
 80155ee:	4603      	mov	r3, r0
 80155f0:	2b00      	cmp	r3, #0
 80155f2:	da02      	bge.n	80155fa <GetCertKey+0xfa>
                    return ASN_PARSE_E;
 80155f4:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80155f8:	e072      	b.n	80156e0 <GetCertKey+0x1e0>
                }
                /* Get the pubic key parameters. */
                ret = DecodeRsaPssParams(source + seqIdx,
 80155fa:	68ba      	ldr	r2, [r7, #8]
 80155fc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80155fe:	18d0      	adds	r0, r2, r3
                    (word32)seqLen + srcIdx - seqIdx, &hash, &mgf, &saltLen);
 8015600:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8015602:	461a      	mov	r2, r3
 8015604:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8015606:	441a      	add	r2, r3
                ret = DecodeRsaPssParams(source + seqIdx,
 8015608:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801560a:	1ad1      	subs	r1, r2, r3
 801560c:	f107 0424 	add.w	r4, r7, #36	@ 0x24
 8015610:	f107 022b 	add.w	r2, r7, #43	@ 0x2b
 8015614:	f107 0320 	add.w	r3, r7, #32
 8015618:	9300      	str	r3, [sp, #0]
 801561a:	4623      	mov	r3, r4
 801561c:	f7ff f97a 	bl	8014914 <DecodeRsaPssParams>
 8015620:	6478      	str	r0, [r7, #68]	@ 0x44
                if (ret != 0) {
 8015622:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8015624:	2b00      	cmp	r3, #0
 8015626:	d002      	beq.n	801562e <GetCertKey+0x12e>
                    return ASN_PARSE_E;
 8015628:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801562c:	e058      	b.n	80156e0 <GetCertKey+0x1e0>
                }
                /* Get the signature parameters. */
                ret = DecodeRsaPssParams(source + cert->sigParamsIndex,
 801562e:	68fb      	ldr	r3, [r7, #12]
 8015630:	6a1b      	ldr	r3, [r3, #32]
 8015632:	68ba      	ldr	r2, [r7, #8]
 8015634:	18d0      	adds	r0, r2, r3
 8015636:	68fb      	ldr	r3, [r7, #12]
 8015638:	6a59      	ldr	r1, [r3, #36]	@ 0x24
 801563a:	f107 0418 	add.w	r4, r7, #24
 801563e:	f107 021f 	add.w	r2, r7, #31
 8015642:	f107 0314 	add.w	r3, r7, #20
 8015646:	9300      	str	r3, [sp, #0]
 8015648:	4623      	mov	r3, r4
 801564a:	f7ff f963 	bl	8014914 <DecodeRsaPssParams>
 801564e:	6478      	str	r0, [r7, #68]	@ 0x44
                    cert->sigParamsLength, &sigHash, &sigMgf, &sigSaltLen);
                if (ret != 0) {
 8015650:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8015652:	2b00      	cmp	r3, #0
 8015654:	d002      	beq.n	801565c <GetCertKey+0x15c>
                    return ASN_PARSE_E;
 8015656:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801565a:	e041      	b.n	80156e0 <GetCertKey+0x1e0>
                }
                /* Validated signature params match public key params. */
                if (hash != WC_HASH_TYPE_NONE && hash != sigHash) {
 801565c:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
 8015660:	2b00      	cmp	r3, #0
 8015662:	d007      	beq.n	8015674 <GetCertKey+0x174>
 8015664:	f897 202b 	ldrb.w	r2, [r7, #43]	@ 0x2b
 8015668:	7ffb      	ldrb	r3, [r7, #31]
 801566a:	429a      	cmp	r2, r3
 801566c:	d002      	beq.n	8015674 <GetCertKey+0x174>
                    WOLFSSL_MSG("RSA PSS: hash not matching signature hash");
                    return ASN_PARSE_E;
 801566e:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8015672:	e035      	b.n	80156e0 <GetCertKey+0x1e0>
                }
                if (mgf != -1 && mgf != sigMgf) {
 8015674:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8015676:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 801567a:	d006      	beq.n	801568a <GetCertKey+0x18a>
 801567c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801567e:	69bb      	ldr	r3, [r7, #24]
 8015680:	429a      	cmp	r2, r3
 8015682:	d002      	beq.n	801568a <GetCertKey+0x18a>
                    WOLFSSL_MSG("RSA PSS: MGF not matching signature MGF");
                    return ASN_PARSE_E;
 8015684:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8015688:	e02a      	b.n	80156e0 <GetCertKey+0x1e0>
                }
                if (saltLen > sigSaltLen) {
 801568a:	6a3a      	ldr	r2, [r7, #32]
 801568c:	697b      	ldr	r3, [r7, #20]
 801568e:	429a      	cmp	r2, r3
 8015690:	dd02      	ble.n	8015698 <GetCertKey+0x198>
                    WOLFSSL_MSG("RSA PSS: sig salt length too small");
                    return ASN_PARSE_E;
 8015692:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8015696:	e023      	b.n	80156e0 <GetCertKey+0x1e0>
                }
                srcIdx += (word32)seqLen;
 8015698:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801569a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801569c:	4413      	add	r3, r2
 801569e:	637b      	str	r3, [r7, #52]	@ 0x34
            }
            FALL_THROUGH;
    #endif /* WC_RSA_PSS */
        case RSAk:
            ret = StoreRsaKey(cert, source, &srcIdx, maxIdx);
 80156a0:	f107 0234 	add.w	r2, r7, #52	@ 0x34
 80156a4:	683b      	ldr	r3, [r7, #0]
 80156a6:	68b9      	ldr	r1, [r7, #8]
 80156a8:	68f8      	ldr	r0, [r7, #12]
 80156aa:	f7ff fe85 	bl	80153b8 <StoreRsaKey>
 80156ae:	6478      	str	r0, [r7, #68]	@ 0x44
            break;
 80156b0:	e012      	b.n	80156d8 <GetCertKey+0x1d8>
    #ifdef HAVE_ECC
    #if defined(WOLFSSL_SM2) && defined(WOLFSSL_SM3)
        case SM2k:
    #endif
        case ECDSAk:
            ret = StoreEccKey(cert, source, &srcIdx, maxIdx, source + pubIdx,
 80156b2:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80156b4:	68ba      	ldr	r2, [r7, #8]
 80156b6:	4413      	add	r3, r2
 80156b8:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80156ba:	f107 0134 	add.w	r1, r7, #52	@ 0x34
 80156be:	9201      	str	r2, [sp, #4]
 80156c0:	9300      	str	r3, [sp, #0]
 80156c2:	683b      	ldr	r3, [r7, #0]
 80156c4:	460a      	mov	r2, r1
 80156c6:	68b9      	ldr	r1, [r7, #8]
 80156c8:	68f8      	ldr	r0, [r7, #12]
 80156ca:	f7ff fea1 	bl	8015410 <StoreEccKey>
 80156ce:	6478      	str	r0, [r7, #68]	@ 0x44
                              (word32)pubLen);
            break;
 80156d0:	e002      	b.n	80156d8 <GetCertKey+0x1d8>
            break;
    #endif /* NO_DSA */
        default:
            WOLFSSL_MSG("Unknown or not compiled in key OID");
            WOLFSSL_ERROR_VERBOSE(ASN_UNKNOWN_OID_E);
            ret = ASN_UNKNOWN_OID_E;
 80156d2:	f06f 0393 	mvn.w	r3, #147	@ 0x93
 80156d6:	647b      	str	r3, [r7, #68]	@ 0x44
    }

    /* Return index after public key. */
    *inOutIdx = srcIdx;
 80156d8:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 80156da:	687b      	ldr	r3, [r7, #4]
 80156dc:	601a      	str	r2, [r3, #0]

    /* Return error code. */
    return ret;
 80156de:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
}
 80156e0:	4618      	mov	r0, r3
 80156e2:	374c      	adds	r7, #76	@ 0x4c
 80156e4:	46bd      	mov	sp, r7
 80156e6:	bd90      	pop	{r4, r7, pc}

080156e8 <HashIdAlg>:
 *
 * @param [in] oidSum  Signature id.
 * @return  Hash algorithm id.
 */
int HashIdAlg(word32 oidSum)
{
 80156e8:	b480      	push	{r7}
 80156ea:	b083      	sub	sp, #12
 80156ec:	af00      	add	r7, sp, #0
 80156ee:	6078      	str	r0, [r7, #4]
    if (oidSum == SM2k) {
        return WC_SM3;
    }
#endif
#if defined(NO_SHA) || (!defined(NO_SHA256) && defined(WC_ASN_HASH_SHA256))
    return WC_SHA256;
 80156f0:	2306      	movs	r3, #6
#else
    return WC_SHA;
#endif
}
 80156f2:	4618      	mov	r0, r3
 80156f4:	370c      	adds	r7, #12
 80156f6:	46bd      	mov	sp, r7
 80156f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80156fc:	4770      	bx	lr

080156fe <CalcHashId>:
 * @param [out] hash  Buffer to hold hash.
 * @return  0 on success.
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
int CalcHashId(const byte* data, word32 len, byte* hash)
{
 80156fe:	b580      	push	{r7, lr}
 8015700:	b084      	sub	sp, #16
 8015702:	af00      	add	r7, sp, #0
 8015704:	60f8      	str	r0, [r7, #12]
 8015706:	60b9      	str	r1, [r7, #8]
 8015708:	607a      	str	r2, [r7, #4]
    /* Use default hash algorithm. */
    return CalcHashId_ex(data, len, hash,
 801570a:	2306      	movs	r3, #6
 801570c:	687a      	ldr	r2, [r7, #4]
 801570e:	68b9      	ldr	r1, [r7, #8]
 8015710:	68f8      	ldr	r0, [r7, #12]
 8015712:	f000 f805 	bl	8015720 <CalcHashId_ex>
 8015716:	4603      	mov	r3, r0
        WC_SHA256
#else
        WC_SHA
#endif
        );
}
 8015718:	4618      	mov	r0, r3
 801571a:	3710      	adds	r7, #16
 801571c:	46bd      	mov	sp, r7
 801571e:	bd80      	pop	{r7, pc}

08015720 <CalcHashId_ex>:
 * @param [out] hash  Buffer to hold hash.
 * @return  0 on success.
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
int CalcHashId_ex(const byte* data, word32 len, byte* hash, int hashAlg)
{
 8015720:	b580      	push	{r7, lr}
 8015722:	b086      	sub	sp, #24
 8015724:	af00      	add	r7, sp, #0
 8015726:	60f8      	str	r0, [r7, #12]
 8015728:	60b9      	str	r1, [r7, #8]
 801572a:	607a      	str	r2, [r7, #4]
 801572c:	603b      	str	r3, [r7, #0]
        ret = wc_Sm3Hash(data, len, hash);
    }
    else
#endif
#if defined(NO_SHA) || (!defined(NO_SHA256) && defined(WC_ASN_HASH_SHA256))
    if (hashAlg == WC_SHA256) {
 801572e:	683b      	ldr	r3, [r7, #0]
 8015730:	2b06      	cmp	r3, #6
 8015732:	d106      	bne.n	8015742 <CalcHashId_ex+0x22>
        ret = wc_Sha256Hash(data, len, hash);
 8015734:	687a      	ldr	r2, [r7, #4]
 8015736:	68b9      	ldr	r1, [r7, #8]
 8015738:	68f8      	ldr	r0, [r7, #12]
 801573a:	f008 feff 	bl	801e53c <wc_Sha256Hash>
 801573e:	6178      	str	r0, [r7, #20]
 8015740:	e002      	b.n	8015748 <CalcHashId_ex+0x28>
    (void)data;
    (void)len;
    (void)hash;
#endif
    {
        ret = NOT_COMPILED_IN;
 8015742:	f06f 03ad 	mvn.w	r3, #173	@ 0xad
 8015746:	617b      	str	r3, [r7, #20]
    }

    return ret;
 8015748:	697b      	ldr	r3, [r7, #20]
}
 801574a:	4618      	mov	r0, r3
 801574c:	3718      	adds	r7, #24
 801574e:	46bd      	mov	sp, r7
 8015750:	bd80      	pop	{r7, pc}

08015752 <GetHashId>:
 * @param [out] hash  Buffer to hold hash.
 * @return  0 on success.
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
static int GetHashId(const byte* id, int length, byte* hash, int hashAlg)
{
 8015752:	b580      	push	{r7, lr}
 8015754:	b086      	sub	sp, #24
 8015756:	af00      	add	r7, sp, #0
 8015758:	60f8      	str	r0, [r7, #12]
 801575a:	60b9      	str	r1, [r7, #8]
 801575c:	607a      	str	r2, [r7, #4]
 801575e:	603b      	str	r3, [r7, #0]
    int ret;

#if defined(WOLFSSL_SM2) && defined(WOLFSSL_SM3)
    if (length == wc_HashGetDigestSize(wc_HashTypeConvert(hashAlg)))
#else
    if (length == KEYID_SIZE)
 8015760:	68bb      	ldr	r3, [r7, #8]
 8015762:	2b20      	cmp	r3, #32
 8015764:	d108      	bne.n	8015778 <GetHashId+0x26>
#endif
    {
    #if defined(WOLFSSL_SM2) && defined(WOLFSSL_SM3)
        XMEMSET(hash + length, 0, KEYID_SIZE - length);
    #endif
        XMEMCPY(hash, id, (size_t)length);
 8015766:	68bb      	ldr	r3, [r7, #8]
 8015768:	461a      	mov	r2, r3
 801576a:	68f9      	ldr	r1, [r7, #12]
 801576c:	6878      	ldr	r0, [r7, #4]
 801576e:	f012 ff15 	bl	802859c <memcpy>
        ret = 0;
 8015772:	2300      	movs	r3, #0
 8015774:	617b      	str	r3, [r7, #20]
 8015776:	e006      	b.n	8015786 <GetHashId+0x34>
    }
    else {
        ret = CalcHashId_ex(id, (word32)length, hash, hashAlg);
 8015778:	68b9      	ldr	r1, [r7, #8]
 801577a:	683b      	ldr	r3, [r7, #0]
 801577c:	687a      	ldr	r2, [r7, #4]
 801577e:	68f8      	ldr	r0, [r7, #12]
 8015780:	f7ff ffce 	bl	8015720 <CalcHashId_ex>
 8015784:	6178      	str	r0, [r7, #20]
    }

    return ret;
 8015786:	697b      	ldr	r3, [r7, #20]
}
 8015788:	4618      	mov	r0, r3
 801578a:	3718      	adds	r7, #24
 801578c:	46bd      	mov	sp, r7
 801578e:	bd80      	pop	{r7, pc}

08015790 <AddDNSEntryToList>:
 * @param [in, out] lst      Linked list of DNS name entries.
 * @param [in]      entry    Entry to add to the list
 * @return  0 on success.
 */
static int AddDNSEntryToList(DNS_entry** lst, DNS_entry* entry)
{
 8015790:	b480      	push	{r7}
 8015792:	b085      	sub	sp, #20
 8015794:	af00      	add	r7, sp, #0
 8015796:	6078      	str	r0, [r7, #4]
 8015798:	6039      	str	r1, [r7, #0]
#if defined(OPENSSL_EXTRA) && !defined(WOLFSSL_ALT_NAMES_NO_REV)
    entry->next = NULL;
 801579a:	683b      	ldr	r3, [r7, #0]
 801579c:	2200      	movs	r2, #0
 801579e:	601a      	str	r2, [r3, #0]
    if (*lst == NULL) {
 80157a0:	687b      	ldr	r3, [r7, #4]
 80157a2:	681b      	ldr	r3, [r3, #0]
 80157a4:	2b00      	cmp	r3, #0
 80157a6:	d103      	bne.n	80157b0 <AddDNSEntryToList+0x20>
        /* First on list */
        *lst = entry;
 80157a8:	687b      	ldr	r3, [r7, #4]
 80157aa:	683a      	ldr	r2, [r7, #0]
 80157ac:	601a      	str	r2, [r3, #0]
 80157ae:	e00d      	b.n	80157cc <AddDNSEntryToList+0x3c>
    }
    else {
        DNS_entry* temp = *lst;
 80157b0:	687b      	ldr	r3, [r7, #4]
 80157b2:	681b      	ldr	r3, [r3, #0]
 80157b4:	60fb      	str	r3, [r7, #12]

        /* Find end */
        for (; (temp->next != NULL); temp = temp->next);
 80157b6:	e002      	b.n	80157be <AddDNSEntryToList+0x2e>
 80157b8:	68fb      	ldr	r3, [r7, #12]
 80157ba:	681b      	ldr	r3, [r3, #0]
 80157bc:	60fb      	str	r3, [r7, #12]
 80157be:	68fb      	ldr	r3, [r7, #12]
 80157c0:	681b      	ldr	r3, [r3, #0]
 80157c2:	2b00      	cmp	r3, #0
 80157c4:	d1f8      	bne.n	80157b8 <AddDNSEntryToList+0x28>

        /* Add to end */
        temp->next = entry;
 80157c6:	68fb      	ldr	r3, [r7, #12]
 80157c8:	683a      	ldr	r2, [r7, #0]
 80157ca:	601a      	str	r2, [r3, #0]
    /* Prepend entry to linked list. */
    entry->next = *lst;
    *lst = entry;
#endif

    return 0;
 80157cc:	2300      	movs	r3, #0
}
 80157ce:	4618      	mov	r0, r3
 80157d0:	3714      	adds	r7, #20
 80157d2:	46bd      	mov	sp, r7
 80157d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80157d8:	4770      	bx	lr

080157da <SetDNSEntry>:
 * @return  0 on success.
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
static int SetDNSEntry(void* heap, const char* str, int strLen,
                       int type, DNS_entry** entries)
{
 80157da:	b580      	push	{r7, lr}
 80157dc:	b088      	sub	sp, #32
 80157de:	af00      	add	r7, sp, #0
 80157e0:	60f8      	str	r0, [r7, #12]
 80157e2:	60b9      	str	r1, [r7, #8]
 80157e4:	607a      	str	r2, [r7, #4]
 80157e6:	603b      	str	r3, [r7, #0]
    DNS_entry* dnsEntry;
    int ret = 0;
 80157e8:	2300      	movs	r3, #0
 80157ea:	61fb      	str	r3, [r7, #28]

    /* TODO: consider one malloc. */
    /* Allocate DNS Entry object. */
    dnsEntry = AltNameNew(heap);
 80157ec:	68f8      	ldr	r0, [r7, #12]
 80157ee:	f7ff fce8 	bl	80151c2 <AltNameNew>
 80157f2:	61b8      	str	r0, [r7, #24]
    if (dnsEntry == NULL) {
 80157f4:	69bb      	ldr	r3, [r7, #24]
 80157f6:	2b00      	cmp	r3, #0
 80157f8:	d102      	bne.n	8015800 <SetDNSEntry+0x26>
        ret = MEMORY_E;
 80157fa:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 80157fe:	61fb      	str	r3, [r7, #28]
    }
    if (ret == 0) {
 8015800:	69fb      	ldr	r3, [r7, #28]
 8015802:	2b00      	cmp	r3, #0
 8015804:	d10e      	bne.n	8015824 <SetDNSEntry+0x4a>
        /* Allocate DNS Entry name - length of string plus 1 for NUL. */
        dnsEntry->name = (char*)XMALLOC((size_t)strLen + 1, heap,
 8015806:	687b      	ldr	r3, [r7, #4]
 8015808:	3301      	adds	r3, #1
 801580a:	4618      	mov	r0, r3
 801580c:	f009 f93c 	bl	801ea88 <wolfSSL_Malloc>
 8015810:	4602      	mov	r2, r0
 8015812:	69bb      	ldr	r3, [r7, #24]
 8015814:	60da      	str	r2, [r3, #12]
                                                          DYNAMIC_TYPE_ALTNAME);
        if (dnsEntry->name == NULL) {
 8015816:	69bb      	ldr	r3, [r7, #24]
 8015818:	68db      	ldr	r3, [r3, #12]
 801581a:	2b00      	cmp	r3, #0
 801581c:	d102      	bne.n	8015824 <SetDNSEntry+0x4a>
            ret = MEMORY_E;
 801581e:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8015822:	61fb      	str	r3, [r7, #28]
        }
    }
    if (ret == 0) {
 8015824:	69fb      	ldr	r3, [r7, #28]
 8015826:	2b00      	cmp	r3, #0
 8015828:	d112      	bne.n	8015850 <SetDNSEntry+0x76>
        /* Set tag type, name length, name and NUL terminate name. */
        dnsEntry->type = type;
 801582a:	69bb      	ldr	r3, [r7, #24]
 801582c:	683a      	ldr	r2, [r7, #0]
 801582e:	605a      	str	r2, [r3, #4]
        dnsEntry->len = strLen;
 8015830:	69bb      	ldr	r3, [r7, #24]
 8015832:	687a      	ldr	r2, [r7, #4]
 8015834:	609a      	str	r2, [r3, #8]
        XMEMCPY(dnsEntry->name, str, (size_t)strLen);
 8015836:	69bb      	ldr	r3, [r7, #24]
 8015838:	68db      	ldr	r3, [r3, #12]
 801583a:	687a      	ldr	r2, [r7, #4]
 801583c:	68b9      	ldr	r1, [r7, #8]
 801583e:	4618      	mov	r0, r3
 8015840:	f012 feac 	bl	802859c <memcpy>
        dnsEntry->name[strLen] = '\0';
 8015844:	69bb      	ldr	r3, [r7, #24]
 8015846:	68da      	ldr	r2, [r3, #12]
 8015848:	687b      	ldr	r3, [r7, #4]
 801584a:	4413      	add	r3, r2
 801584c:	2200      	movs	r2, #0
 801584e:	701a      	strb	r2, [r3, #0]
#ifdef WOLFSSL_IP_ALT_NAME
    /* store IP addresses as a string */
    if (ret == 0 && type == ASN_IP_TYPE)
        ret = GenerateDNSEntryIPString(dnsEntry, heap);
#endif
    if (ret == 0) {
 8015850:	69fb      	ldr	r3, [r7, #28]
 8015852:	2b00      	cmp	r3, #0
 8015854:	d104      	bne.n	8015860 <SetDNSEntry+0x86>
        ret = AddDNSEntryToList(entries, dnsEntry);
 8015856:	69b9      	ldr	r1, [r7, #24]
 8015858:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801585a:	f7ff ff99 	bl	8015790 <AddDNSEntryToList>
 801585e:	61f8      	str	r0, [r7, #28]
    }

    /* failure cleanup */
    if (ret != 0 && dnsEntry != NULL) {
 8015860:	69fb      	ldr	r3, [r7, #28]
 8015862:	2b00      	cmp	r3, #0
 8015864:	d013      	beq.n	801588e <SetDNSEntry+0xb4>
 8015866:	69bb      	ldr	r3, [r7, #24]
 8015868:	2b00      	cmp	r3, #0
 801586a:	d010      	beq.n	801588e <SetDNSEntry+0xb4>
        XFREE(dnsEntry->name, heap, DYNAMIC_TYPE_ALTNAME);
 801586c:	69bb      	ldr	r3, [r7, #24]
 801586e:	68db      	ldr	r3, [r3, #12]
 8015870:	617b      	str	r3, [r7, #20]
 8015872:	697b      	ldr	r3, [r7, #20]
 8015874:	2b00      	cmp	r3, #0
 8015876:	d002      	beq.n	801587e <SetDNSEntry+0xa4>
 8015878:	6978      	ldr	r0, [r7, #20]
 801587a:	f009 f921 	bl	801eac0 <wolfSSL_Free>
        XFREE(dnsEntry, heap, DYNAMIC_TYPE_ALTNAME);
 801587e:	69bb      	ldr	r3, [r7, #24]
 8015880:	613b      	str	r3, [r7, #16]
 8015882:	693b      	ldr	r3, [r7, #16]
 8015884:	2b00      	cmp	r3, #0
 8015886:	d002      	beq.n	801588e <SetDNSEntry+0xb4>
 8015888:	6938      	ldr	r0, [r7, #16]
 801588a:	f009 f919 	bl	801eac0 <wolfSSL_Free>
    }

    return ret;
 801588e:	69fb      	ldr	r3, [r7, #28]
}
 8015890:	4618      	mov	r0, r3
 8015892:	3720      	adds	r7, #32
 8015894:	46bd      	mov	sp, r7
 8015896:	bd80      	pop	{r7, pc}

08015898 <SetSubject>:
 * @param [in]      tag     BER tag representing encoding of string.
 * @return  0 on success, negative values on failure.
 */
static int SetSubject(DecodedCert* cert, int id, byte* str, int strLen,
                      byte tag)
{
 8015898:	b480      	push	{r7}
 801589a:	b087      	sub	sp, #28
 801589c:	af00      	add	r7, sp, #0
 801589e:	60f8      	str	r0, [r7, #12]
 80158a0:	60b9      	str	r1, [r7, #8]
 80158a2:	607a      	str	r2, [r7, #4]
 80158a4:	603b      	str	r3, [r7, #0]
    int ret = 0;
 80158a6:	2300      	movs	r3, #0
 80158a8:	617b      	str	r3, [r7, #20]

    /* Put string and encoding into certificate. */
    if (id == ASN_COMMON_NAME) {
 80158aa:	68bb      	ldr	r3, [r7, #8]
 80158ac:	2b03      	cmp	r3, #3
 80158ae:	d10d      	bne.n	80158cc <SetSubject+0x34>
        cert->subjectCN = (char *)str;
 80158b0:	68fb      	ldr	r3, [r7, #12]
 80158b2:	687a      	ldr	r2, [r7, #4]
 80158b4:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
        cert->subjectCNLen = (int)strLen;
 80158b8:	68fb      	ldr	r3, [r7, #12]
 80158ba:	683a      	ldr	r2, [r7, #0]
 80158bc:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
        cert->subjectCNEnc = (char)tag;
 80158c0:	68fb      	ldr	r3, [r7, #12]
 80158c2:	f897 2020 	ldrb.w	r2, [r7, #32]
 80158c6:	f883 208c 	strb.w	r2, [r3, #140]	@ 0x8c
 80158ca:	e00b      	b.n	80158e4 <SetSubject+0x4c>
        SetCertNameSubjectEnc(cert, id, tag);
    }
#endif
#if !defined(IGNORE_NAME_CONSTRAINTS) || \
     defined(WOLFSSL_CERT_GEN) || defined(WOLFSSL_CERT_EXT)
    else if (id == ASN_EMAIL) {
 80158cc:	68bb      	ldr	r3, [r7, #8]
 80158ce:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 80158d2:	d107      	bne.n	80158e4 <SetSubject+0x4c>
        cert->subjectEmail = (char*)str;
 80158d4:	68fb      	ldr	r3, [r7, #12]
 80158d6:	687a      	ldr	r2, [r7, #4]
 80158d8:	f8c3 245c 	str.w	r2, [r3, #1116]	@ 0x45c
        cert->subjectEmailLen = strLen;
 80158dc:	68fb      	ldr	r3, [r7, #12]
 80158de:	683a      	ldr	r2, [r7, #0]
 80158e0:	f8c3 2460 	str.w	r2, [r3, #1120]	@ 0x460
        cert->subjectJSLen = strLen;
        cert->subjectJSEnc = (char)tag;
    }
#endif

    return ret;
 80158e4:	697b      	ldr	r3, [r7, #20]
}
 80158e6:	4618      	mov	r0, r3
 80158e8:	371c      	adds	r7, #28
 80158ea:	46bd      	mov	sp, r7
 80158ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 80158f0:	4770      	bx	lr
	...

080158f4 <GetRDN>:
 * @return  MEMORY_E when dynamic memory allocation fails.
 * @return  ASN_PARSE_E when type not supported.
 */
static int GetRDN(DecodedCert* cert, char* full, word32* idx, int* nid,
                  int isSubject, ASNGetData* dataASN)
{
 80158f4:	b580      	push	{r7, lr}
 80158f6:	b090      	sub	sp, #64	@ 0x40
 80158f8:	af02      	add	r7, sp, #8
 80158fa:	60f8      	str	r0, [r7, #12]
 80158fc:	60b9      	str	r1, [r7, #8]
 80158fe:	607a      	str	r2, [r7, #4]
 8015900:	603b      	str	r3, [r7, #0]
    int         ret = 0;
 8015902:	2300      	movs	r3, #0
 8015904:	637b      	str	r3, [r7, #52]	@ 0x34
    const char* typeStr = NULL;
 8015906:	2300      	movs	r3, #0
 8015908:	633b      	str	r3, [r7, #48]	@ 0x30
    byte        typeStrLen = 0;
 801590a:	2300      	movs	r3, #0
 801590c:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    byte*       oid;
    word32      oidSz;
    int         id = 0;
 8015910:	2300      	movs	r3, #0
 8015912:	62bb      	str	r3, [r7, #40]	@ 0x28

    (void)nid;

    /* Get name type OID from data items. */
    GetASN_OIDData(&dataASN[RDNASN_IDX_ATTR_TYPE], &oid, &oidSz);
 8015914:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8015916:	3338      	adds	r3, #56	@ 0x38
 8015918:	689b      	ldr	r3, [r3, #8]
 801591a:	623b      	str	r3, [r7, #32]
 801591c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801591e:	3338      	adds	r3, #56	@ 0x38
 8015920:	68db      	ldr	r3, [r3, #12]
 8015922:	61fb      	str	r3, [r7, #28]

    /* v1 name types */
    if ((oidSz == 3) && (oid[0] == 0x55) && (oid[1] == 0x04)) {
 8015924:	69fb      	ldr	r3, [r7, #28]
 8015926:	2b03      	cmp	r3, #3
 8015928:	d146      	bne.n	80159b8 <GetRDN+0xc4>
 801592a:	6a3b      	ldr	r3, [r7, #32]
 801592c:	781b      	ldrb	r3, [r3, #0]
 801592e:	2b55      	cmp	r3, #85	@ 0x55
 8015930:	d142      	bne.n	80159b8 <GetRDN+0xc4>
 8015932:	6a3b      	ldr	r3, [r7, #32]
 8015934:	3301      	adds	r3, #1
 8015936:	781b      	ldrb	r3, [r3, #0]
 8015938:	2b04      	cmp	r3, #4
 801593a:	d13d      	bne.n	80159b8 <GetRDN+0xc4>
        id = oid[2];
 801593c:	6a3b      	ldr	r3, [r7, #32]
 801593e:	3302      	adds	r3, #2
 8015940:	781b      	ldrb	r3, [r3, #0]
 8015942:	62bb      	str	r3, [r7, #40]	@ 0x28
        /* Check range of supported ids in table. */
        if (ValidCertNameSubject(id)) {
 8015944:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8015946:	2b02      	cmp	r3, #2
 8015948:	f340 80ed 	ble.w	8015b26 <GetRDN+0x232>
 801594c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801594e:	3b02      	subs	r3, #2
 8015950:	2210      	movs	r2, #16
 8015952:	4293      	cmp	r3, r2
 8015954:	f300 80e7 	bgt.w	8015b26 <GetRDN+0x232>
 8015958:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801595a:	1eda      	subs	r2, r3, #3
 801595c:	499c      	ldr	r1, [pc, #624]	@ (8015bd0 <GetRDN+0x2dc>)
 801595e:	4613      	mov	r3, r2
 8015960:	005b      	lsls	r3, r3, #1
 8015962:	4413      	add	r3, r2
 8015964:	009b      	lsls	r3, r3, #2
 8015966:	440b      	add	r3, r1
 8015968:	3304      	adds	r3, #4
 801596a:	781b      	ldrb	r3, [r3, #0]
 801596c:	2b00      	cmp	r3, #0
 801596e:	f000 80da 	beq.w	8015b26 <GetRDN+0x232>
            /* Get the type string, length and NID from table. */
            typeStr = GetCertNameSubjectStr(id);
 8015972:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8015974:	1eda      	subs	r2, r3, #3
 8015976:	4996      	ldr	r1, [pc, #600]	@ (8015bd0 <GetRDN+0x2dc>)
 8015978:	4613      	mov	r3, r2
 801597a:	005b      	lsls	r3, r3, #1
 801597c:	4413      	add	r3, r2
 801597e:	009b      	lsls	r3, r3, #2
 8015980:	440b      	add	r3, r1
 8015982:	681b      	ldr	r3, [r3, #0]
 8015984:	633b      	str	r3, [r7, #48]	@ 0x30
            typeStrLen = GetCertNameSubjectStrLen(id);
 8015986:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8015988:	1eda      	subs	r2, r3, #3
 801598a:	4991      	ldr	r1, [pc, #580]	@ (8015bd0 <GetRDN+0x2dc>)
 801598c:	4613      	mov	r3, r2
 801598e:	005b      	lsls	r3, r3, #1
 8015990:	4413      	add	r3, r2
 8015992:	009b      	lsls	r3, r3, #2
 8015994:	440b      	add	r3, r1
 8015996:	3304      	adds	r3, #4
 8015998:	781b      	ldrb	r3, [r3, #0]
 801599a:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
        #ifdef WOLFSSL_X509_NAME_AVAILABLE
            *nid = GetCertNameSubjectNID(id);
 801599e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80159a0:	1eda      	subs	r2, r3, #3
 80159a2:	498b      	ldr	r1, [pc, #556]	@ (8015bd0 <GetRDN+0x2dc>)
 80159a4:	4613      	mov	r3, r2
 80159a6:	005b      	lsls	r3, r3, #1
 80159a8:	4413      	add	r3, r2
 80159aa:	009b      	lsls	r3, r3, #2
 80159ac:	440b      	add	r3, r1
 80159ae:	3308      	adds	r3, #8
 80159b0:	681a      	ldr	r2, [r3, #0]
 80159b2:	683b      	ldr	r3, [r7, #0]
 80159b4:	601a      	str	r2, [r3, #0]
        if (ValidCertNameSubject(id)) {
 80159b6:	e0b6      	b.n	8015b26 <GetRDN+0x232>
        #endif
        }
    }
    else if (oidSz == sizeof(attrEmailOid) && XMEMCMP(oid, attrEmailOid, oidSz) == 0) {
 80159b8:	69fb      	ldr	r3, [r7, #28]
 80159ba:	2b09      	cmp	r3, #9
 80159bc:	d114      	bne.n	80159e8 <GetRDN+0xf4>
 80159be:	6a3b      	ldr	r3, [r7, #32]
 80159c0:	69fa      	ldr	r2, [r7, #28]
 80159c2:	4984      	ldr	r1, [pc, #528]	@ (8015bd4 <GetRDN+0x2e0>)
 80159c4:	4618      	mov	r0, r3
 80159c6:	f012 fd55 	bl	8028474 <memcmp>
 80159ca:	4603      	mov	r3, r0
 80159cc:	2b00      	cmp	r3, #0
 80159ce:	d10b      	bne.n	80159e8 <GetRDN+0xf4>
        /* Set the email id, type string, length and NID. */
        id = ASN_EMAIL;
 80159d0:	f44f 7380 	mov.w	r3, #256	@ 0x100
 80159d4:	62bb      	str	r3, [r7, #40]	@ 0x28
        typeStr =  WOLFSSL_EMAIL_ADDR;
 80159d6:	4b80      	ldr	r3, [pc, #512]	@ (8015bd8 <GetRDN+0x2e4>)
 80159d8:	633b      	str	r3, [r7, #48]	@ 0x30
        typeStrLen = sizeof(WOLFSSL_EMAIL_ADDR) - 1;
 80159da:	230e      	movs	r3, #14
 80159dc:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    #ifdef WOLFSSL_X509_NAME_AVAILABLE
        *nid = WC_NID_emailAddress;
 80159e0:	683b      	ldr	r3, [r7, #0]
 80159e2:	2230      	movs	r2, #48	@ 0x30
 80159e4:	601a      	str	r2, [r3, #0]
 80159e6:	e09f      	b.n	8015b28 <GetRDN+0x234>
    #endif
    }
    else if (oidSz == sizeof(uidOid) && XMEMCMP(oid, uidOid, oidSz) == 0) {
 80159e8:	69fb      	ldr	r3, [r7, #28]
 80159ea:	2b0a      	cmp	r3, #10
 80159ec:	d114      	bne.n	8015a18 <GetRDN+0x124>
 80159ee:	6a3b      	ldr	r3, [r7, #32]
 80159f0:	69fa      	ldr	r2, [r7, #28]
 80159f2:	497a      	ldr	r1, [pc, #488]	@ (8015bdc <GetRDN+0x2e8>)
 80159f4:	4618      	mov	r0, r3
 80159f6:	f012 fd3d 	bl	8028474 <memcmp>
 80159fa:	4603      	mov	r3, r0
 80159fc:	2b00      	cmp	r3, #0
 80159fe:	d10b      	bne.n	8015a18 <GetRDN+0x124>
        /* Set the user id, type string, length and NID. */
        id = ASN_USER_ID;
 8015a00:	2312      	movs	r3, #18
 8015a02:	62bb      	str	r3, [r7, #40]	@ 0x28
        typeStr = WOLFSSL_USER_ID;
 8015a04:	4b76      	ldr	r3, [pc, #472]	@ (8015be0 <GetRDN+0x2ec>)
 8015a06:	633b      	str	r3, [r7, #48]	@ 0x30
        typeStrLen = sizeof(WOLFSSL_USER_ID) - 1;
 8015a08:	2305      	movs	r3, #5
 8015a0a:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    #ifdef WOLFSSL_X509_NAME_AVAILABLE
        *nid = WC_NID_userId;
 8015a0e:	683b      	ldr	r3, [r7, #0]
 8015a10:	f44f 72e5 	mov.w	r2, #458	@ 0x1ca
 8015a14:	601a      	str	r2, [r3, #0]
 8015a16:	e087      	b.n	8015b28 <GetRDN+0x234>
    #endif
    }
    else if (oidSz == sizeof(dcOid) && XMEMCMP(oid, dcOid, oidSz) == 0) {
 8015a18:	69fb      	ldr	r3, [r7, #28]
 8015a1a:	2b0a      	cmp	r3, #10
 8015a1c:	d114      	bne.n	8015a48 <GetRDN+0x154>
 8015a1e:	6a3b      	ldr	r3, [r7, #32]
 8015a20:	69fa      	ldr	r2, [r7, #28]
 8015a22:	4970      	ldr	r1, [pc, #448]	@ (8015be4 <GetRDN+0x2f0>)
 8015a24:	4618      	mov	r0, r3
 8015a26:	f012 fd25 	bl	8028474 <memcmp>
 8015a2a:	4603      	mov	r3, r0
 8015a2c:	2b00      	cmp	r3, #0
 8015a2e:	d10b      	bne.n	8015a48 <GetRDN+0x154>
        /* Set the domain component, type string, length and NID. */
        id = ASN_DC;
 8015a30:	f44f 7381 	mov.w	r3, #258	@ 0x102
 8015a34:	62bb      	str	r3, [r7, #40]	@ 0x28
        typeStr = WOLFSSL_DOMAIN_COMPONENT;
 8015a36:	4b6c      	ldr	r3, [pc, #432]	@ (8015be8 <GetRDN+0x2f4>)
 8015a38:	633b      	str	r3, [r7, #48]	@ 0x30
        typeStrLen = sizeof(WOLFSSL_DOMAIN_COMPONENT) - 1;
 8015a3a:	2304      	movs	r3, #4
 8015a3c:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    #ifdef WOLFSSL_X509_NAME_AVAILABLE
        *nid = WC_NID_domainComponent;
 8015a40:	683b      	ldr	r3, [r7, #0]
 8015a42:	2219      	movs	r2, #25
 8015a44:	601a      	str	r2, [r3, #0]
 8015a46:	e06f      	b.n	8015b28 <GetRDN+0x234>
    #endif
    }
    else if (oidSz == sizeof(rfc822Mlbx) && XMEMCMP(oid, rfc822Mlbx, oidSz) == 0) {
 8015a48:	69fb      	ldr	r3, [r7, #28]
 8015a4a:	2b0a      	cmp	r3, #10
 8015a4c:	d114      	bne.n	8015a78 <GetRDN+0x184>
 8015a4e:	6a3b      	ldr	r3, [r7, #32]
 8015a50:	69fa      	ldr	r2, [r7, #28]
 8015a52:	4966      	ldr	r1, [pc, #408]	@ (8015bec <GetRDN+0x2f8>)
 8015a54:	4618      	mov	r0, r3
 8015a56:	f012 fd0d 	bl	8028474 <memcmp>
 8015a5a:	4603      	mov	r3, r0
 8015a5c:	2b00      	cmp	r3, #0
 8015a5e:	d10b      	bne.n	8015a78 <GetRDN+0x184>
        /* Set the RFC822 mailbox, type string, length and NID. */
        id = ASN_RFC822_MAILBOX;
 8015a60:	2314      	movs	r3, #20
 8015a62:	62bb      	str	r3, [r7, #40]	@ 0x28
        typeStr = WOLFSSL_RFC822_MAILBOX;
 8015a64:	4b62      	ldr	r3, [pc, #392]	@ (8015bf0 <GetRDN+0x2fc>)
 8015a66:	633b      	str	r3, [r7, #48]	@ 0x30
        typeStrLen = sizeof(WOLFSSL_RFC822_MAILBOX) - 1;
 8015a68:	230f      	movs	r3, #15
 8015a6a:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    #ifdef WOLFSSL_X509_NAME_AVAILABLE
        *nid = WC_NID_rfc822Mailbox;
 8015a6e:	683b      	ldr	r3, [r7, #0]
 8015a70:	f44f 72e6 	mov.w	r2, #460	@ 0x1cc
 8015a74:	601a      	str	r2, [r3, #0]
 8015a76:	e057      	b.n	8015b28 <GetRDN+0x234>
    #endif
    }
    else if (oidSz == sizeof(fvrtDrk) && XMEMCMP(oid, fvrtDrk, oidSz) == 0) {
 8015a78:	69fb      	ldr	r3, [r7, #28]
 8015a7a:	2b0a      	cmp	r3, #10
 8015a7c:	d114      	bne.n	8015aa8 <GetRDN+0x1b4>
 8015a7e:	6a3b      	ldr	r3, [r7, #32]
 8015a80:	69fa      	ldr	r2, [r7, #28]
 8015a82:	495c      	ldr	r1, [pc, #368]	@ (8015bf4 <GetRDN+0x300>)
 8015a84:	4618      	mov	r0, r3
 8015a86:	f012 fcf5 	bl	8028474 <memcmp>
 8015a8a:	4603      	mov	r3, r0
 8015a8c:	2b00      	cmp	r3, #0
 8015a8e:	d10b      	bne.n	8015aa8 <GetRDN+0x1b4>
        /* Set the favourite drink, type string, length and NID. */
        id = ASN_FAVOURITE_DRINK;
 8015a90:	2313      	movs	r3, #19
 8015a92:	62bb      	str	r3, [r7, #40]	@ 0x28
        typeStr = WOLFSSL_FAVOURITE_DRINK;
 8015a94:	4b58      	ldr	r3, [pc, #352]	@ (8015bf8 <GetRDN+0x304>)
 8015a96:	633b      	str	r3, [r7, #48]	@ 0x30
        typeStrLen = sizeof(WOLFSSL_FAVOURITE_DRINK) - 1;
 8015a98:	2310      	movs	r3, #16
 8015a9a:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    #ifdef WOLFSSL_X509_NAME_AVAILABLE
        *nid = WC_NID_favouriteDrink;
 8015a9e:	683b      	ldr	r3, [r7, #0]
 8015aa0:	f44f 72e7 	mov.w	r2, #462	@ 0x1ce
 8015aa4:	601a      	str	r2, [r3, #0]
 8015aa6:	e03f      	b.n	8015b28 <GetRDN+0x234>
        *nid = WC_NID_pkcs9_contentType;
    #endif
    }
#endif
    /* Other OIDs that start with the same values. */
    else if (oidSz == sizeof(dcOid) && XMEMCMP(oid, dcOid, oidSz-1) == 0) {
 8015aa8:	69fb      	ldr	r3, [r7, #28]
 8015aaa:	2b0a      	cmp	r3, #10
 8015aac:	d10d      	bne.n	8015aca <GetRDN+0x1d6>
 8015aae:	6a38      	ldr	r0, [r7, #32]
 8015ab0:	69fb      	ldr	r3, [r7, #28]
 8015ab2:	3b01      	subs	r3, #1
 8015ab4:	461a      	mov	r2, r3
 8015ab6:	494b      	ldr	r1, [pc, #300]	@ (8015be4 <GetRDN+0x2f0>)
 8015ab8:	f012 fcdc 	bl	8028474 <memcmp>
 8015abc:	4603      	mov	r3, r0
 8015abe:	2b00      	cmp	r3, #0
 8015ac0:	d103      	bne.n	8015aca <GetRDN+0x1d6>
        WOLFSSL_MSG("Unknown pilot attribute type");
        WOLFSSL_ERROR_VERBOSE(ASN_PARSE_E);
        ret = ASN_PARSE_E;
 8015ac2:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8015ac6:	637b      	str	r3, [r7, #52]	@ 0x34
 8015ac8:	e02e      	b.n	8015b28 <GetRDN+0x234>
    }
    else if (oidSz == ASN_JOI_PREFIX_SZ + 1 &&
 8015aca:	69fb      	ldr	r3, [r7, #28]
 8015acc:	2b0b      	cmp	r3, #11
 8015ace:	d12b      	bne.n	8015b28 <GetRDN+0x234>
                         XMEMCMP(oid, ASN_JOI_PREFIX, ASN_JOI_PREFIX_SZ) == 0) {
 8015ad0:	6a3b      	ldr	r3, [r7, #32]
 8015ad2:	220a      	movs	r2, #10
 8015ad4:	4949      	ldr	r1, [pc, #292]	@ (8015bfc <GetRDN+0x308>)
 8015ad6:	4618      	mov	r0, r3
 8015ad8:	f012 fccc 	bl	8028474 <memcmp>
 8015adc:	4603      	mov	r3, r0
    else if (oidSz == ASN_JOI_PREFIX_SZ + 1 &&
 8015ade:	2b00      	cmp	r3, #0
 8015ae0:	d122      	bne.n	8015b28 <GetRDN+0x234>
        /* Set the jurisdiction id. */
        id = 0x200 + oid[ASN_JOI_PREFIX_SZ];
 8015ae2:	6a3b      	ldr	r3, [r7, #32]
 8015ae4:	330a      	adds	r3, #10
 8015ae6:	781b      	ldrb	r3, [r3, #0]
 8015ae8:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8015aec:	62bb      	str	r3, [r7, #40]	@ 0x28

        /* Set the jurisdiction type string, length and NID if known. */
        if (oid[ASN_JOI_PREFIX_SZ] == ASN_JOI_C) {
 8015aee:	6a3b      	ldr	r3, [r7, #32]
 8015af0:	330a      	adds	r3, #10
 8015af2:	781b      	ldrb	r3, [r3, #0]
 8015af4:	2b03      	cmp	r3, #3
 8015af6:	d108      	bne.n	8015b0a <GetRDN+0x216>
            typeStr = WOLFSSL_JOI_C;
 8015af8:	4b41      	ldr	r3, [pc, #260]	@ (8015c00 <GetRDN+0x30c>)
 8015afa:	633b      	str	r3, [r7, #48]	@ 0x30
            typeStrLen = sizeof(WOLFSSL_JOI_C) - 1;
 8015afc:	230f      	movs	r3, #15
 8015afe:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
        #ifdef WOLFSSL_X509_NAME_AVAILABLE
            *nid = WC_NID_jurisdictionCountryName;
 8015b02:	683b      	ldr	r3, [r7, #0]
 8015b04:	220c      	movs	r2, #12
 8015b06:	601a      	str	r2, [r3, #0]
 8015b08:	e00e      	b.n	8015b28 <GetRDN+0x234>
        #endif /* WOLFSSL_X509_NAME_AVAILABLE */
        }
        else if (oid[ASN_JOI_PREFIX_SZ] == ASN_JOI_ST) {
 8015b0a:	6a3b      	ldr	r3, [r7, #32]
 8015b0c:	330a      	adds	r3, #10
 8015b0e:	781b      	ldrb	r3, [r3, #0]
 8015b10:	2b02      	cmp	r3, #2
 8015b12:	d109      	bne.n	8015b28 <GetRDN+0x234>
            typeStr = WOLFSSL_JOI_ST;
 8015b14:	4b3b      	ldr	r3, [pc, #236]	@ (8015c04 <GetRDN+0x310>)
 8015b16:	633b      	str	r3, [r7, #48]	@ 0x30
            typeStrLen = sizeof(WOLFSSL_JOI_ST) - 1;
 8015b18:	2310      	movs	r3, #16
 8015b1a:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
        #ifdef WOLFSSL_X509_NAME_AVAILABLE
            *nid = WC_NID_jurisdictionStateOrProvinceName;
 8015b1e:	683b      	ldr	r3, [r7, #0]
 8015b20:	220d      	movs	r2, #13
 8015b22:	601a      	str	r2, [r3, #0]
 8015b24:	e000      	b.n	8015b28 <GetRDN+0x234>
        if (ValidCertNameSubject(id)) {
 8015b26:	bf00      	nop
        else {
            WOLFSSL_MSG("Unknown Jurisdiction, skipping");
        }
    }

    if ((ret == 0) && (typeStr != NULL)) {
 8015b28:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8015b2a:	2b00      	cmp	r3, #0
 8015b2c:	d14b      	bne.n	8015bc6 <GetRDN+0x2d2>
 8015b2e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8015b30:	2b00      	cmp	r3, #0
 8015b32:	d048      	beq.n	8015bc6 <GetRDN+0x2d2>
        /* OID type to store for subject name and add to full string. */
        byte*  str;
        word32 strLen;
        byte   tag = dataASN[RDNASN_IDX_ATTR_VAL].tag;
 8015b34:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8015b36:	3354      	adds	r3, #84	@ 0x54
 8015b38:	7e5b      	ldrb	r3, [r3, #25]
 8015b3a:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

        /* Get the string reference and length. */
        GetASN_GetRef(&dataASN[RDNASN_IDX_ATTR_VAL], &str, &strLen);
 8015b3e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8015b40:	3354      	adds	r3, #84	@ 0x54
 8015b42:	689b      	ldr	r3, [r3, #8]
 8015b44:	61bb      	str	r3, [r7, #24]
 8015b46:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8015b48:	3354      	adds	r3, #84	@ 0x54
 8015b4a:	68db      	ldr	r3, [r3, #12]
 8015b4c:	617b      	str	r3, [r7, #20]

        if (isSubject) {
 8015b4e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8015b50:	2b00      	cmp	r3, #0
 8015b52:	d00b      	beq.n	8015b6c <GetRDN+0x278>
            /* Store subject field components. */
            ret = SetSubject(cert, id, str, (int)strLen, tag);
 8015b54:	69ba      	ldr	r2, [r7, #24]
 8015b56:	697b      	ldr	r3, [r7, #20]
 8015b58:	4619      	mov	r1, r3
 8015b5a:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8015b5e:	9300      	str	r3, [sp, #0]
 8015b60:	460b      	mov	r3, r1
 8015b62:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 8015b64:	68f8      	ldr	r0, [r7, #12]
 8015b66:	f7ff fe97 	bl	8015898 <SetSubject>
 8015b6a:	6378      	str	r0, [r7, #52]	@ 0x34
        /* Put issuer common name string and encoding into certificate. */
        else {
            ret = SetIssuer(cert, id, str, (int)strLen, tag);
        }
    #endif
        if (ret == 0) {
 8015b6c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8015b6e:	2b00      	cmp	r3, #0
 8015b70:	d129      	bne.n	8015bc6 <GetRDN+0x2d2>
            /* Check there is space for this in the full name string and
             * terminating NUL character. */
            if ((typeStrLen + strLen) < (word32)(WC_ASN_NAME_MAX - *idx))
 8015b72:	f897 202f 	ldrb.w	r2, [r7, #47]	@ 0x2f
 8015b76:	697b      	ldr	r3, [r7, #20]
 8015b78:	441a      	add	r2, r3
 8015b7a:	687b      	ldr	r3, [r7, #4]
 8015b7c:	681b      	ldr	r3, [r3, #0]
 8015b7e:	f5c3 73b4 	rsb	r3, r3, #360	@ 0x168
 8015b82:	429a      	cmp	r2, r3
 8015b84:	d21f      	bcs.n	8015bc6 <GetRDN+0x2d2>
            {
                /* Add RDN to full string. */
                XMEMCPY(&full[*idx], typeStr, typeStrLen);
 8015b86:	687b      	ldr	r3, [r7, #4]
 8015b88:	681b      	ldr	r3, [r3, #0]
 8015b8a:	68ba      	ldr	r2, [r7, #8]
 8015b8c:	4413      	add	r3, r2
 8015b8e:	f897 202f 	ldrb.w	r2, [r7, #47]	@ 0x2f
 8015b92:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 8015b94:	4618      	mov	r0, r3
 8015b96:	f012 fd01 	bl	802859c <memcpy>
                *idx += typeStrLen;
 8015b9a:	687b      	ldr	r3, [r7, #4]
 8015b9c:	681a      	ldr	r2, [r3, #0]
 8015b9e:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8015ba2:	441a      	add	r2, r3
 8015ba4:	687b      	ldr	r3, [r7, #4]
 8015ba6:	601a      	str	r2, [r3, #0]
                XMEMCPY(&full[*idx], str, strLen);
 8015ba8:	687b      	ldr	r3, [r7, #4]
 8015baa:	681b      	ldr	r3, [r3, #0]
 8015bac:	68ba      	ldr	r2, [r7, #8]
 8015bae:	4413      	add	r3, r2
 8015bb0:	69b9      	ldr	r1, [r7, #24]
 8015bb2:	697a      	ldr	r2, [r7, #20]
 8015bb4:	4618      	mov	r0, r3
 8015bb6:	f012 fcf1 	bl	802859c <memcpy>
                *idx += strLen;
 8015bba:	687b      	ldr	r3, [r7, #4]
 8015bbc:	681a      	ldr	r2, [r3, #0]
 8015bbe:	697b      	ldr	r3, [r7, #20]
 8015bc0:	441a      	add	r2, r3
 8015bc2:	687b      	ldr	r3, [r7, #4]
 8015bc4:	601a      	str	r2, [r3, #0]
                WOLFSSL_MSG("ASN Name too big, skipping");
            }
        }
    }

    return ret;
 8015bc6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
 8015bc8:	4618      	mov	r0, r3
 8015bca:	3738      	adds	r7, #56	@ 0x38
 8015bcc:	46bd      	mov	sp, r7
 8015bce:	bd80      	pop	{r7, pc}
 8015bd0:	08033824 	.word	0x08033824
 8015bd4:	080336ec 	.word	0x080336ec
 8015bd8:	0802f7f4 	.word	0x0802f7f4
 8015bdc:	08033710 	.word	0x08033710
 8015be0:	0802f804 	.word	0x0802f804
 8015be4:	08033734 	.word	0x08033734
 8015be8:	0802f80c 	.word	0x0802f80c
 8015bec:	0803371c 	.word	0x0803371c
 8015bf0:	0802f814 	.word	0x0802f814
 8015bf4:	08033728 	.word	0x08033728
 8015bf8:	0802f824 	.word	0x0802f824
 8015bfc:	0802f838 	.word	0x0802f838
 8015c00:	0802f844 	.word	0x0802f844
 8015c04:	0802f854 	.word	0x0802f854

08015c08 <GetCertName>:
 * @return  ASN_UNKNOWN_OID_E when the OID cannot be verified.
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
static int GetCertName(DecodedCert* cert, char* full, byte* hash, int nameType,
                       const byte* input, word32* inOutIdx, word32 maxIdx)
{
 8015c08:	b5b0      	push	{r4, r5, r7, lr}
 8015c0a:	b094      	sub	sp, #80	@ 0x50
 8015c0c:	af04      	add	r7, sp, #16
 8015c0e:	60f8      	str	r0, [r7, #12]
 8015c10:	60b9      	str	r1, [r7, #8]
 8015c12:	607a      	str	r2, [r7, #4]
 8015c14:	603b      	str	r3, [r7, #0]

    *inOutIdx = srcIdx;

    return 0;
#else
    DECL_ASNGETDATA(dataASN, rdnASN_Length);
 8015c16:	2300      	movs	r3, #0
 8015c18:	63fb      	str	r3, [r7, #60]	@ 0x3c
    int    ret = 0;
 8015c1a:	2300      	movs	r3, #0
 8015c1c:	63bb      	str	r3, [r7, #56]	@ 0x38
    word32 idx = 0;
 8015c1e:	2300      	movs	r3, #0
 8015c20:	627b      	str	r3, [r7, #36]	@ 0x24
    int    len = 0;
 8015c22:	2300      	movs	r3, #0
 8015c24:	623b      	str	r3, [r7, #32]
    word32 srcIdx = *inOutIdx;
 8015c26:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8015c28:	681b      	ldr	r3, [r3, #0]
 8015c2a:	61fb      	str	r3, [r7, #28]
#ifdef WOLFSSL_X509_NAME_AVAILABLE
    WOLFSSL_X509_NAME* dName = NULL;
 8015c2c:	2300      	movs	r3, #0
 8015c2e:	637b      	str	r3, [r7, #52]	@ 0x34
    WOLFSSL_MSG("Getting Cert Name");

    /* For OCSP, RFC2560 section 4.1.1 states the issuer hash should be
     * calculated over the entire DER encoding of the Name field, including
     * the tag and length. */
    if (CalcHashId_ex(input + srcIdx, maxIdx - srcIdx, hash,
 8015c30:	69fb      	ldr	r3, [r7, #28]
 8015c32:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 8015c34:	18d4      	adds	r4, r2, r3
 8015c36:	69fb      	ldr	r3, [r7, #28]
 8015c38:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8015c3a:	1ad5      	subs	r5, r2, r3
 8015c3c:	68fb      	ldr	r3, [r7, #12]
 8015c3e:	699b      	ldr	r3, [r3, #24]
 8015c40:	4618      	mov	r0, r3
 8015c42:	f7ff fd51 	bl	80156e8 <HashIdAlg>
 8015c46:	4603      	mov	r3, r0
 8015c48:	687a      	ldr	r2, [r7, #4]
 8015c4a:	4629      	mov	r1, r5
 8015c4c:	4620      	mov	r0, r4
 8015c4e:	f7ff fd67 	bl	8015720 <CalcHashId_ex>
 8015c52:	4603      	mov	r3, r0
 8015c54:	2b00      	cmp	r3, #0
 8015c56:	d002      	beq.n	8015c5e <GetCertName+0x56>
            HashIdAlg(cert->signatureOID)) != 0) {
        ret = ASN_PARSE_E;
 8015c58:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8015c5c:	63bb      	str	r3, [r7, #56]	@ 0x38
    }

    CALLOC_ASNGETDATA(dataASN, rdnASN_Length, ret, cert->heap);
 8015c5e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015c60:	2b00      	cmp	r3, #0
 8015c62:	d109      	bne.n	8015c78 <GetCertName+0x70>
 8015c64:	2070      	movs	r0, #112	@ 0x70
 8015c66:	f008 ff0f 	bl	801ea88 <wolfSSL_Malloc>
 8015c6a:	63f8      	str	r0, [r7, #60]	@ 0x3c
 8015c6c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015c6e:	2b00      	cmp	r3, #0
 8015c70:	d102      	bne.n	8015c78 <GetCertName+0x70>
 8015c72:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8015c76:	63bb      	str	r3, [r7, #56]	@ 0x38
 8015c78:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015c7a:	2b00      	cmp	r3, #0
 8015c7c:	d104      	bne.n	8015c88 <GetCertName+0x80>
 8015c7e:	2270      	movs	r2, #112	@ 0x70
 8015c80:	2100      	movs	r1, #0
 8015c82:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8015c84:	f012 fc20 	bl	80284c8 <memset>

#ifdef WOLFSSL_X509_NAME_AVAILABLE
    if (ret == 0) {
 8015c88:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015c8a:	2b00      	cmp	r3, #0
 8015c8c:	d10c      	bne.n	8015ca8 <GetCertName+0xa0>
        /* Create an X509_NAME to hold data for OpenSSL compatibility APIs. */
        dName = wolfSSL_X509_NAME_new_ex(cert->heap);
 8015c8e:	68fb      	ldr	r3, [r7, #12]
 8015c90:	f8d3 3370 	ldr.w	r3, [r3, #880]	@ 0x370
 8015c94:	4618      	mov	r0, r3
 8015c96:	f7f8 fc84 	bl	800e5a2 <wolfSSL_X509_NAME_new_ex>
 8015c9a:	6378      	str	r0, [r7, #52]	@ 0x34
        if (dName == NULL) {
 8015c9c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8015c9e:	2b00      	cmp	r3, #0
 8015ca0:	d102      	bne.n	8015ca8 <GetCertName+0xa0>
            ret = MEMORY_E;
 8015ca2:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8015ca6:	63bb      	str	r3, [r7, #56]	@ 0x38
        }
    }
#endif /* WOLFSSL_X509_NAME_AVAILABLE */

    if (ret == 0) {
 8015ca8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015caa:	2b00      	cmp	r3, #0
 8015cac:	d10a      	bne.n	8015cc4 <GetCertName+0xbc>
        /* Expecting a SEQUENCE using up all data. */
        ret = GetASN_Sequence(input, &srcIdx, &len, maxIdx, 1);
 8015cae:	f107 0220 	add.w	r2, r7, #32
 8015cb2:	f107 011c 	add.w	r1, r7, #28
 8015cb6:	2301      	movs	r3, #1
 8015cb8:	9300      	str	r3, [sp, #0]
 8015cba:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8015cbc:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 8015cbe:	f7fd ffc6 	bl	8013c4e <GetASN_Sequence>
 8015cc2:	63b8      	str	r0, [r7, #56]	@ 0x38
    }
    if (ret == 0) {
 8015cc4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015cc6:	2b00      	cmp	r3, #0
 8015cc8:	f040 808a 	bne.w	8015de0 <GetCertName+0x1d8>
            cert->issuerRawLen = len;
        }
    #endif
    #if !defined(IGNORE_NAME_CONSTRAINTS) || defined(WOLFSSL_CERT_EXT)
        /* Store pointer and length to raw subject. */
        if (nameType == ASN_SUBJECT) {
 8015ccc:	683b      	ldr	r3, [r7, #0]
 8015cce:	2b01      	cmp	r3, #1
 8015cd0:	d17f      	bne.n	8015dd2 <GetCertName+0x1ca>
            cert->subjectRaw = &input[srcIdx];
 8015cd2:	69fb      	ldr	r3, [r7, #28]
 8015cd4:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 8015cd6:	441a      	add	r2, r3
 8015cd8:	68fb      	ldr	r3, [r7, #12]
 8015cda:	f8c3 2454 	str.w	r2, [r3, #1108]	@ 0x454
            cert->subjectRawLen = len;
 8015cde:	6a3a      	ldr	r2, [r7, #32]
 8015ce0:	68fb      	ldr	r3, [r7, #12]
 8015ce2:	f8c3 2458 	str.w	r2, [r3, #1112]	@ 0x458
        }
    #endif

        /* Process all RDNs in name. */
        while ((ret == 0) && (srcIdx < maxIdx)) {
 8015ce6:	e074      	b.n	8015dd2 <GetCertName+0x1ca>
            int nid = 0;
 8015ce8:	2300      	movs	r3, #0
 8015cea:	61bb      	str	r3, [r7, #24]

            /* Initialize for data and setup RDN choice. */
            GetASN_Choice(&dataASN[RDNASN_IDX_ATTR_VAL], rdnChoice);
 8015cec:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015cee:	3354      	adds	r3, #84	@ 0x54
 8015cf0:	220b      	movs	r2, #11
 8015cf2:	761a      	strb	r2, [r3, #24]
 8015cf4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015cf6:	3354      	adds	r3, #84	@ 0x54
 8015cf8:	4a4f      	ldr	r2, [pc, #316]	@ (8015e38 <GetCertName+0x230>)
 8015cfa:	609a      	str	r2, [r3, #8]
            /* Ignore type OID as too many to store in table. */
            GetASN_OID(&dataASN[RDNASN_IDX_ATTR_TYPE], oidIgnoreType);
 8015cfc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015cfe:	3338      	adds	r3, #56	@ 0x38
 8015d00:	2215      	movs	r2, #21
 8015d02:	611a      	str	r2, [r3, #16]
            /* Parse RDN. */
            ret = GetASN_Items(rdnASN, dataASN, rdnASN_Length, 1, input,
 8015d04:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8015d06:	9302      	str	r3, [sp, #8]
 8015d08:	f107 031c 	add.w	r3, r7, #28
 8015d0c:	9301      	str	r3, [sp, #4]
 8015d0e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8015d10:	9300      	str	r3, [sp, #0]
 8015d12:	2301      	movs	r3, #1
 8015d14:	2204      	movs	r2, #4
 8015d16:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 8015d18:	4848      	ldr	r0, [pc, #288]	@ (8015e3c <GetCertName+0x234>)
 8015d1a:	f7fd fcf1 	bl	8013700 <GetASN_Items>
 8015d1e:	63b8      	str	r0, [r7, #56]	@ 0x38
                               &srcIdx, maxIdx);
            if (ret == 0) {
 8015d20:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015d22:	2b00      	cmp	r3, #0
 8015d24:	d113      	bne.n	8015d4e <GetCertName+0x146>
                /* Put RDN data into certificate. */
                ret = GetRDN(cert, full, &idx, &nid, nameType == ASN_SUBJECT,
 8015d26:	683b      	ldr	r3, [r7, #0]
 8015d28:	2b01      	cmp	r3, #1
 8015d2a:	bf0c      	ite	eq
 8015d2c:	2301      	moveq	r3, #1
 8015d2e:	2300      	movne	r3, #0
 8015d30:	b2db      	uxtb	r3, r3
 8015d32:	4618      	mov	r0, r3
 8015d34:	f107 0118 	add.w	r1, r7, #24
 8015d38:	f107 0224 	add.w	r2, r7, #36	@ 0x24
 8015d3c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015d3e:	9301      	str	r3, [sp, #4]
 8015d40:	9000      	str	r0, [sp, #0]
 8015d42:	460b      	mov	r3, r1
 8015d44:	68b9      	ldr	r1, [r7, #8]
 8015d46:	68f8      	ldr	r0, [r7, #12]
 8015d48:	f7ff fdd4 	bl	80158f4 <GetRDN>
 8015d4c:	63b8      	str	r0, [r7, #56]	@ 0x38
                             dataASN);
            }
        #ifdef WOLFSSL_X509_NAME_AVAILABLE
            /* TODO: push this back up to ssl.c
             * (do parsing for WOLFSSL_X509_NAME on demand) */
            if (ret == 0) {
 8015d4e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015d50:	2b00      	cmp	r3, #0
 8015d52:	d13e      	bne.n	8015dd2 <GetCertName+0x1ca>
                int enc;
                byte*  str;
                word32 strLen;
                byte   tag = dataASN[RDNASN_IDX_ATTR_VAL].tag;
 8015d54:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015d56:	3354      	adds	r3, #84	@ 0x54
 8015d58:	7e5b      	ldrb	r3, [r3, #25]
 8015d5a:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f

                /* Get string reference. */
                GetASN_GetRef(&dataASN[RDNASN_IDX_ATTR_VAL], &str, &strLen);
 8015d5e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015d60:	3354      	adds	r3, #84	@ 0x54
 8015d62:	689b      	ldr	r3, [r3, #8]
 8015d64:	617b      	str	r3, [r7, #20]
 8015d66:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015d68:	3354      	adds	r3, #84	@ 0x54
 8015d6a:	68db      	ldr	r3, [r3, #12]
 8015d6c:	613b      	str	r3, [r7, #16]

            #ifndef WOLFSSL_NO_ASN_STRICT
                /* RFC 5280 section 4.1.2.4 lists a DirectoryString as being
                 * 1..MAX in length */
                if (ret == 0 && strLen < 1) {
 8015d6e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015d70:	2b00      	cmp	r3, #0
 8015d72:	d105      	bne.n	8015d80 <GetCertName+0x178>
 8015d74:	693b      	ldr	r3, [r7, #16]
 8015d76:	2b00      	cmp	r3, #0
 8015d78:	d102      	bne.n	8015d80 <GetCertName+0x178>
                    WOLFSSL_MSG("Non conforming DirectoryString of length 0 was"
                                " found");
                    WOLFSSL_MSG("Use WOLFSSL_NO_ASN_STRICT if wanting to allow"
                                " empty DirectoryString's");
                    ret = ASN_PARSE_E;
 8015d7a:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8015d7e:	63bb      	str	r3, [r7, #56]	@ 0x38
                }
            #endif

                /* Convert BER tag to a OpenSSL type. */
                switch (tag) {
 8015d80:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8015d84:	2b0c      	cmp	r3, #12
 8015d86:	d002      	beq.n	8015d8e <GetCertName+0x186>
 8015d88:	2b13      	cmp	r3, #19
 8015d8a:	d004      	beq.n	8015d96 <GetCertName+0x18e>
 8015d8c:	e006      	b.n	8015d9c <GetCertName+0x194>
                    case CTC_UTF8:
                        enc = WOLFSSL_MBSTRING_UTF8;
 8015d8e:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8015d92:	633b      	str	r3, [r7, #48]	@ 0x30
                        break;
 8015d94:	e005      	b.n	8015da2 <GetCertName+0x19a>
                    case CTC_PRINTABLE:
                        enc = WOLFSSL_V_ASN1_PRINTABLESTRING;
 8015d96:	2313      	movs	r3, #19
 8015d98:	633b      	str	r3, [r7, #48]	@ 0x30
                        break;
 8015d9a:	e002      	b.n	8015da2 <GetCertName+0x19a>
                    default:
                        WOLFSSL_MSG("Unknown encoding type, default UTF8");
                        enc = WOLFSSL_MBSTRING_UTF8;
 8015d9c:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8015da0:	633b      	str	r3, [r7, #48]	@ 0x30
                }
                if (nid != 0) {
 8015da2:	69bb      	ldr	r3, [r7, #24]
 8015da4:	2b00      	cmp	r3, #0
 8015da6:	d014      	beq.n	8015dd2 <GetCertName+0x1ca>
                    /* Add an entry to the X509_NAME. */
                    if (wolfSSL_X509_NAME_add_entry_by_NID(dName, nid, enc, str,
 8015da8:	69b9      	ldr	r1, [r7, #24]
 8015daa:	697b      	ldr	r3, [r7, #20]
 8015dac:	693a      	ldr	r2, [r7, #16]
 8015dae:	4610      	mov	r0, r2
 8015db0:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8015db4:	9202      	str	r2, [sp, #8]
 8015db6:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8015dba:	9201      	str	r2, [sp, #4]
 8015dbc:	9000      	str	r0, [sp, #0]
 8015dbe:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8015dc0:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 8015dc2:	f7f8 fe83 	bl	800eacc <wolfSSL_X509_NAME_add_entry_by_NID>
 8015dc6:	4603      	mov	r3, r0
 8015dc8:	2b01      	cmp	r3, #1
 8015dca:	d002      	beq.n	8015dd2 <GetCertName+0x1ca>
                            (int)strLen, -1, -1) != WOLFSSL_SUCCESS) {
                        ret = ASN_PARSE_E;
 8015dcc:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8015dd0:	63bb      	str	r3, [r7, #56]	@ 0x38
        while ((ret == 0) && (srcIdx < maxIdx)) {
 8015dd2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015dd4:	2b00      	cmp	r3, #0
 8015dd6:	d103      	bne.n	8015de0 <GetCertName+0x1d8>
 8015dd8:	69fb      	ldr	r3, [r7, #28]
 8015dda:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8015ddc:	429a      	cmp	r2, r3
 8015dde:	d883      	bhi.n	8015ce8 <GetCertName+0xe0>
                }
            }
        #endif
        }
    }
    if (ret == 0) {
 8015de0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015de2:	2b00      	cmp	r3, #0
 8015de4:	d114      	bne.n	8015e10 <GetCertName+0x208>
        /* Terminate string. */
        full[idx] = 0;
 8015de6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8015de8:	68ba      	ldr	r2, [r7, #8]
 8015dea:	4413      	add	r3, r2
 8015dec:	2200      	movs	r2, #0
 8015dee:	701a      	strb	r2, [r3, #0]
        /* Return index into encoding after name. */
        *inOutIdx = srcIdx;
 8015df0:	69fa      	ldr	r2, [r7, #28]
 8015df2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8015df4:	601a      	str	r2, [r3, #0]

#ifdef WOLFSSL_X509_NAME_AVAILABLE
        /* Store X509_NAME in certificate. */
        if (nameType == ASN_ISSUER) {
 8015df6:	683b      	ldr	r3, [r7, #0]
 8015df8:	2b00      	cmp	r3, #0
 8015dfa:	d104      	bne.n	8015e06 <GetCertName+0x1fe>
            (defined(HAVE_PKCS7) || defined(WOLFSSL_CERT_EXT))
            dName->rawLen = (int)min((word32)cert->issuerRawLen,
                WC_ASN_NAME_MAX);
            XMEMCPY(dName->raw, cert->issuerRaw, (size_t)dName->rawLen);
        #endif
            cert->issuerName = dName;
 8015dfc:	68fb      	ldr	r3, [r7, #12]
 8015dfe:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8015e00:	f8c3 2464 	str.w	r2, [r3, #1124]	@ 0x464
 8015e04:	e007      	b.n	8015e16 <GetCertName+0x20e>
        #if defined(OPENSSL_ALL) || defined(WOLFSSL_NGINX)
            dName->rawLen = (int)min((word32)cert->subjectRawLen,
                WC_ASN_NAME_MAX);
            XMEMCPY(dName->raw, cert->subjectRaw, (size_t)dName->rawLen);
        #endif
            cert->subjectName = dName;
 8015e06:	68fb      	ldr	r3, [r7, #12]
 8015e08:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8015e0a:	f8c3 2468 	str.w	r2, [r3, #1128]	@ 0x468
 8015e0e:	e002      	b.n	8015e16 <GetCertName+0x20e>
        }
    }
    else {
        /* Dispose of unused X509_NAME. */
        wolfSSL_X509_NAME_free(dName);
 8015e10:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 8015e12:	f7f8 fbb0 	bl	800e576 <wolfSSL_X509_NAME_free>
#endif
    }

    FREE_ASNGETDATA(dataASN, cert->heap);
 8015e16:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015e18:	2b00      	cmp	r3, #0
 8015e1a:	d007      	beq.n	8015e2c <GetCertName+0x224>
 8015e1c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015e1e:	62bb      	str	r3, [r7, #40]	@ 0x28
 8015e20:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8015e22:	2b00      	cmp	r3, #0
 8015e24:	d002      	beq.n	8015e2c <GetCertName+0x224>
 8015e26:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8015e28:	f008 fe4a 	bl	801eac0 <wolfSSL_Free>
    return ret;
 8015e2c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 8015e2e:	4618      	mov	r0, r3
 8015e30:	3740      	adds	r7, #64	@ 0x40
 8015e32:	46bd      	mov	sp, r7
 8015e34:	bdb0      	pop	{r4, r5, r7, pc}
 8015e36:	bf00      	nop
 8015e38:	080338f4 	.word	0x080338f4
 8015e3c:	080338e4 	.word	0x080338e4

08015e40 <DecodeToKey>:
 * @return  ASN_OBJECT_ID_E when the expected OBJECT_ID tag is not found.
 * @return  ASN_BITSTR_E when the expected BIT_STRING tag is not found.
 * @return  ASN_EXPECT_0_E when the INTEGER has the MSB set.
 */
int DecodeToKey(DecodedCert* cert, int verify)
{
 8015e40:	b580      	push	{r7, lr}
 8015e42:	b086      	sub	sp, #24
 8015e44:	af02      	add	r7, sp, #8
 8015e46:	6078      	str	r0, [r7, #4]
 8015e48:	6039      	str	r1, [r7, #0]
        return badDate;

    return ret;
#else
    int ret;
    int badDate = 0;
 8015e4a:	2300      	movs	r3, #0
 8015e4c:	60bb      	str	r3, [r7, #8]
     * This is required to parse a potential alternative public key in the
     * SubjectAlternativeKey extension. */
    ret = DecodeCertInternal(cert, verify, NULL, &badDate, 0, 0);
#else
    /* Call internal version and stop after public key. */
    ret = DecodeCertInternal(cert, verify, NULL, &badDate, 0, 1);
 8015e4e:	f107 0308 	add.w	r3, r7, #8
 8015e52:	2201      	movs	r2, #1
 8015e54:	9201      	str	r2, [sp, #4]
 8015e56:	2200      	movs	r2, #0
 8015e58:	9200      	str	r2, [sp, #0]
 8015e5a:	2200      	movs	r2, #0
 8015e5c:	6839      	ldr	r1, [r7, #0]
 8015e5e:	6878      	ldr	r0, [r7, #4]
 8015e60:	f002 f8ae 	bl	8017fc0 <DecodeCertInternal>
 8015e64:	60f8      	str	r0, [r7, #12]
#endif
    /* Always return date errors. */
    if (ret == 0) {
 8015e66:	68fb      	ldr	r3, [r7, #12]
 8015e68:	2b00      	cmp	r3, #0
 8015e6a:	d101      	bne.n	8015e70 <DecodeToKey+0x30>
        ret = badDate;
 8015e6c:	68bb      	ldr	r3, [r7, #8]
 8015e6e:	60fb      	str	r3, [r7, #12]
    }
    return ret;
 8015e70:	68fb      	ldr	r3, [r7, #12]
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 8015e72:	4618      	mov	r0, r3
 8015e74:	3710      	adds	r7, #16
 8015e76:	46bd      	mov	sp, r7
 8015e78:	bd80      	pop	{r7, pc}

08015e7a <SetLength>:
 * @param [in]  length  Value to encode.
 * @param [out] output  Buffer to encode into.
 * @return  Number of bytes encoded.
 */
word32 SetLength(word32 length, byte* output)
{
 8015e7a:	b580      	push	{r7, lr}
 8015e7c:	b084      	sub	sp, #16
 8015e7e:	af00      	add	r7, sp, #0
 8015e80:	6078      	str	r0, [r7, #4]
 8015e82:	6039      	str	r1, [r7, #0]
    /* Start encoding at start of buffer. */
    word32 i = 0;
 8015e84:	2300      	movs	r3, #0
 8015e86:	60fb      	str	r3, [r7, #12]

    if (length < ASN_LONG_LENGTH) {
 8015e88:	687b      	ldr	r3, [r7, #4]
 8015e8a:	2b7f      	cmp	r3, #127	@ 0x7f
 8015e8c:	d80c      	bhi.n	8015ea8 <SetLength+0x2e>
        /* Only one byte needed to encode. */
        if (output) {
 8015e8e:	683b      	ldr	r3, [r7, #0]
 8015e90:	2b00      	cmp	r3, #0
 8015e92:	d005      	beq.n	8015ea0 <SetLength+0x26>
            /* Write out length value. */
            output[i] = (byte)length;
 8015e94:	683a      	ldr	r2, [r7, #0]
 8015e96:	68fb      	ldr	r3, [r7, #12]
 8015e98:	4413      	add	r3, r2
 8015e9a:	687a      	ldr	r2, [r7, #4]
 8015e9c:	b2d2      	uxtb	r2, r2
 8015e9e:	701a      	strb	r2, [r3, #0]
        }
        /* Skip over length. */
        i++;
 8015ea0:	68fb      	ldr	r3, [r7, #12]
 8015ea2:	3301      	adds	r3, #1
 8015ea4:	60fb      	str	r3, [r7, #12]
 8015ea6:	e02a      	b.n	8015efe <SetLength+0x84>
    }
    else {
        /* Calculate the number of bytes required to encode value. */
        byte j = (byte)BytePrecision(length);
 8015ea8:	6878      	ldr	r0, [r7, #4]
 8015eaa:	f7fc fc4a 	bl	8012742 <BytePrecision>
 8015eae:	4603      	mov	r3, r0
 8015eb0:	72fb      	strb	r3, [r7, #11]

        if (output) {
 8015eb2:	683b      	ldr	r3, [r7, #0]
 8015eb4:	2b00      	cmp	r3, #0
 8015eb6:	d007      	beq.n	8015ec8 <SetLength+0x4e>
            /* Encode count byte. */
            output[i] = (byte)(j | ASN_LONG_LENGTH);
 8015eb8:	683a      	ldr	r2, [r7, #0]
 8015eba:	68fb      	ldr	r3, [r7, #12]
 8015ebc:	4413      	add	r3, r2
 8015ebe:	7afa      	ldrb	r2, [r7, #11]
 8015ec0:	f062 027f 	orn	r2, r2, #127	@ 0x7f
 8015ec4:	b2d2      	uxtb	r2, r2
 8015ec6:	701a      	strb	r2, [r3, #0]
        }
        /* Skip over count byte. */
        i++;
 8015ec8:	68fb      	ldr	r3, [r7, #12]
 8015eca:	3301      	adds	r3, #1
 8015ecc:	60fb      	str	r3, [r7, #12]

        /* Encode value as a big-endian byte array. */
        for (; j > 0; --j) {
 8015ece:	e013      	b.n	8015ef8 <SetLength+0x7e>
            if (output) {
 8015ed0:	683b      	ldr	r3, [r7, #0]
 8015ed2:	2b00      	cmp	r3, #0
 8015ed4:	d00a      	beq.n	8015eec <SetLength+0x72>
                /* Encode next most-significant byte. */
                output[i] = (byte)(length >> ((j - 1) * WOLFSSL_BIT_SIZE));
 8015ed6:	7afb      	ldrb	r3, [r7, #11]
 8015ed8:	3b01      	subs	r3, #1
 8015eda:	00db      	lsls	r3, r3, #3
 8015edc:	687a      	ldr	r2, [r7, #4]
 8015ede:	fa22 f103 	lsr.w	r1, r2, r3
 8015ee2:	683a      	ldr	r2, [r7, #0]
 8015ee4:	68fb      	ldr	r3, [r7, #12]
 8015ee6:	4413      	add	r3, r2
 8015ee8:	b2ca      	uxtb	r2, r1
 8015eea:	701a      	strb	r2, [r3, #0]
            }
            /* Skip over byte. */
            i++;
 8015eec:	68fb      	ldr	r3, [r7, #12]
 8015eee:	3301      	adds	r3, #1
 8015ef0:	60fb      	str	r3, [r7, #12]
        for (; j > 0; --j) {
 8015ef2:	7afb      	ldrb	r3, [r7, #11]
 8015ef4:	3b01      	subs	r3, #1
 8015ef6:	72fb      	strb	r3, [r7, #11]
 8015ef8:	7afb      	ldrb	r3, [r7, #11]
 8015efa:	2b00      	cmp	r3, #0
 8015efc:	d1e8      	bne.n	8015ed0 <SetLength+0x56>
        }
    }

    /* Return number of bytes in encoded length. */
    return i;
 8015efe:	68fb      	ldr	r3, [r7, #12]
}
 8015f00:	4618      	mov	r0, r3
 8015f02:	3710      	adds	r7, #16
 8015f04:	46bd      	mov	sp, r7
 8015f06:	bd80      	pop	{r7, pc}

08015f08 <IsSigAlgoECDSA>:
 * @param [in] algoOID  Signature algorithm identifier.
 * @return  1 when algorithm is using ECDSA.
 * @return  0 otherwise.
 */
static WC_INLINE int IsSigAlgoECDSA(word32 algoOID)
{
 8015f08:	b480      	push	{r7}
 8015f0a:	b083      	sub	sp, #12
 8015f0c:	af00      	add	r7, sp, #0
 8015f0e:	6078      	str	r0, [r7, #4]
    /* ECDSA sigAlgo must not have ASN1 NULL parameters */
    if (algoOID == CTC_SHAwECDSA || algoOID == CTC_SHA256wECDSA ||
 8015f10:	687b      	ldr	r3, [r7, #4]
 8015f12:	f5b3 7f02 	cmp.w	r3, #520	@ 0x208
 8015f16:	d00d      	beq.n	8015f34 <IsSigAlgoECDSA+0x2c>
 8015f18:	687b      	ldr	r3, [r7, #4]
 8015f1a:	f5b3 7f03 	cmp.w	r3, #524	@ 0x20c
 8015f1e:	d009      	beq.n	8015f34 <IsSigAlgoECDSA+0x2c>
 8015f20:	687b      	ldr	r3, [r7, #4]
 8015f22:	f240 220d 	movw	r2, #525	@ 0x20d
 8015f26:	4293      	cmp	r3, r2
 8015f28:	d004      	beq.n	8015f34 <IsSigAlgoECDSA+0x2c>
        algoOID == CTC_SHA384wECDSA || algoOID == CTC_SHA512wECDSA) {
 8015f2a:	687b      	ldr	r3, [r7, #4]
 8015f2c:	f240 220e 	movw	r2, #526	@ 0x20e
 8015f30:	4293      	cmp	r3, r2
 8015f32:	d101      	bne.n	8015f38 <IsSigAlgoECDSA+0x30>
        return 1;
 8015f34:	2301      	movs	r3, #1
 8015f36:	e000      	b.n	8015f3a <IsSigAlgoECDSA+0x32>
    }

    return 0;
 8015f38:	2300      	movs	r3, #0
}
 8015f3a:	4618      	mov	r0, r3
 8015f3c:	370c      	adds	r7, #12
 8015f3e:	46bd      	mov	sp, r7
 8015f40:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015f44:	4770      	bx	lr

08015f46 <IsSigAlgoECC>:
 * @param [in] algoOID  Algorithm OID.
 * @return  1 when is EC signing algorithm.
 * @return  0 otherwise.
 */
static WC_INLINE int IsSigAlgoECC(word32 algoOID)
{
 8015f46:	b580      	push	{r7, lr}
 8015f48:	b082      	sub	sp, #8
 8015f4a:	af00      	add	r7, sp, #0
 8015f4c:	6078      	str	r0, [r7, #4]
    (void)algoOID;

    return (0
        #ifdef HAVE_ECC
              || IsSigAlgoECDSA(algoOID)
 8015f4e:	6878      	ldr	r0, [r7, #4]
 8015f50:	f7ff ffda 	bl	8015f08 <IsSigAlgoECDSA>
 8015f54:	4603      	mov	r3, r0
 8015f56:	2b00      	cmp	r3, #0
 8015f58:	bf14      	ite	ne
 8015f5a:	2301      	movne	r3, #1
 8015f5c:	2300      	moveq	r3, #0
 8015f5e:	b2db      	uxtb	r3, r3
              || (algoOID == SPHINCS_SMALL_LEVEL1k)
              || (algoOID == SPHINCS_SMALL_LEVEL3k)
              || (algoOID == SPHINCS_SMALL_LEVEL5k)
        #endif
    );
}
 8015f60:	4618      	mov	r0, r3
 8015f62:	3708      	adds	r7, #8
 8015f64:	46bd      	mov	sp, r7
 8015f66:	bd80      	pop	{r7, pc}

08015f68 <wc_EncodeSignature>:
 * @return  Encoded data size on success.
 * @return  0 when dynamic memory allocation fails.
 */
word32 wc_EncodeSignature(byte* out, const byte* digest, word32 digSz,
                          int hashOID)
{
 8015f68:	b590      	push	{r4, r7, lr}
 8015f6a:	b091      	sub	sp, #68	@ 0x44
 8015f6c:	af00      	add	r7, sp, #0
 8015f6e:	60f8      	str	r0, [r7, #12]
 8015f70:	60b9      	str	r1, [r7, #8]
 8015f72:	607a      	str	r2, [r7, #4]
 8015f74:	603b      	str	r3, [r7, #0]
    XMEMCPY(out + seqSz, algoArray, algoSz);
    XMEMCPY(out + seqSz + algoSz, digArray, encDigSz);

    return encDigSz + algoSz + seqSz;
#else
    DECL_ASNSETDATA(dataASN, digestInfoASN_Length);
 8015f76:	2300      	movs	r3, #0
 8015f78:	63fb      	str	r3, [r7, #60]	@ 0x3c
    int ret = 0;
 8015f7a:	2300      	movs	r3, #0
 8015f7c:	63bb      	str	r3, [r7, #56]	@ 0x38
    int sz = 0;
 8015f7e:	2300      	movs	r3, #0
 8015f80:	633b      	str	r3, [r7, #48]	@ 0x30
    unsigned char dgst[WC_MAX_DIGEST_SIZE];

    CALLOC_ASNSETDATA(dataASN, digestInfoASN_Length, ret, NULL);
 8015f82:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015f84:	2b00      	cmp	r3, #0
 8015f86:	d109      	bne.n	8015f9c <wc_EncodeSignature+0x34>
 8015f88:	208c      	movs	r0, #140	@ 0x8c
 8015f8a:	f008 fd7d 	bl	801ea88 <wolfSSL_Malloc>
 8015f8e:	63f8      	str	r0, [r7, #60]	@ 0x3c
 8015f90:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015f92:	2b00      	cmp	r3, #0
 8015f94:	d102      	bne.n	8015f9c <wc_EncodeSignature+0x34>
 8015f96:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8015f9a:	63bb      	str	r3, [r7, #56]	@ 0x38
 8015f9c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015f9e:	2b00      	cmp	r3, #0
 8015fa0:	d104      	bne.n	8015fac <wc_EncodeSignature+0x44>
 8015fa2:	2264      	movs	r2, #100	@ 0x64
 8015fa4:	2100      	movs	r1, #0
 8015fa6:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8015fa8:	f012 fa8e 	bl	80284c8 <memset>

    if (ret == 0) {
 8015fac:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015fae:	2b00      	cmp	r3, #0
 8015fb0:	d12a      	bne.n	8016008 <wc_EncodeSignature+0xa0>
        /* Set hash OID and type. */
        SetASN_OID(&dataASN[DIGESTINFOASN_IDX_DIGALGO_OID], (word32)hashOID,
 8015fb2:	6838      	ldr	r0, [r7, #0]
 8015fb4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015fb6:	3328      	adds	r3, #40	@ 0x28
 8015fb8:	f103 020c 	add.w	r2, r3, #12
 8015fbc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015fbe:	f103 0428 	add.w	r4, r3, #40	@ 0x28
 8015fc2:	2100      	movs	r1, #0
 8015fc4:	f7fe f864 	bl	8014090 <OidFromId>
 8015fc8:	4603      	mov	r3, r0
 8015fca:	60a3      	str	r3, [r4, #8]
                   oidHashType);
        /* Set digest. */
        if (digest == out) {
 8015fcc:	68ba      	ldr	r2, [r7, #8]
 8015fce:	68fb      	ldr	r3, [r7, #12]
 8015fd0:	429a      	cmp	r2, r3
 8015fd2:	d109      	bne.n	8015fe8 <wc_EncodeSignature+0x80>
            XMEMCPY(dgst, digest, digSz);
 8015fd4:	f107 0310 	add.w	r3, r7, #16
 8015fd8:	687a      	ldr	r2, [r7, #4]
 8015fda:	68b9      	ldr	r1, [r7, #8]
 8015fdc:	4618      	mov	r0, r3
 8015fde:	f012 fadd 	bl	802859c <memcpy>
            digest = dgst;
 8015fe2:	f107 0310 	add.w	r3, r7, #16
 8015fe6:	60bb      	str	r3, [r7, #8]
        }
        SetASN_Buffer(&dataASN[DIGESTINFOASN_IDX_DIGEST], digest, digSz);
 8015fe8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015fea:	3350      	adds	r3, #80	@ 0x50
 8015fec:	68ba      	ldr	r2, [r7, #8]
 8015fee:	609a      	str	r2, [r3, #8]
 8015ff0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015ff2:	3350      	adds	r3, #80	@ 0x50
 8015ff4:	687a      	ldr	r2, [r7, #4]
 8015ff6:	60da      	str	r2, [r3, #12]

        /* Calculate size of encoding. */
        ret = SizeASN_Items(digestInfoASN, dataASN, digestInfoASN_Length, &sz);
 8015ff8:	f107 0330 	add.w	r3, r7, #48	@ 0x30
 8015ffc:	2205      	movs	r2, #5
 8015ffe:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 8016000:	4810      	ldr	r0, [pc, #64]	@ (8016044 <wc_EncodeSignature+0xdc>)
 8016002:	f7fc fcdf 	bl	80129c4 <SizeASN_Items>
 8016006:	63b8      	str	r0, [r7, #56]	@ 0x38
    }
    if (ret == 0) {
 8016008:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801600a:	2b00      	cmp	r3, #0
 801600c:	d108      	bne.n	8016020 <wc_EncodeSignature+0xb8>
        /* Encode PKCS#1 v1.5 RSA signature. */
        SetASN_Items(digestInfoASN, dataASN, digestInfoASN_Length, out);
 801600e:	68fb      	ldr	r3, [r7, #12]
 8016010:	2205      	movs	r2, #5
 8016012:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 8016014:	480b      	ldr	r0, [pc, #44]	@ (8016044 <wc_EncodeSignature+0xdc>)
 8016016:	f7fc fed9 	bl	8012dcc <SetASN_Items>
        ret = sz;
 801601a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801601c:	63bb      	str	r3, [r7, #56]	@ 0x38
 801601e:	e001      	b.n	8016024 <wc_EncodeSignature+0xbc>
    }
    else {
        /* Unsigned return type so 0 indicates error. */
        ret = 0;
 8016020:	2300      	movs	r3, #0
 8016022:	63bb      	str	r3, [r7, #56]	@ 0x38
    }

    FREE_ASNSETDATA(dataASN, NULL);
 8016024:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8016026:	2b00      	cmp	r3, #0
 8016028:	d007      	beq.n	801603a <wc_EncodeSignature+0xd2>
 801602a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801602c:	637b      	str	r3, [r7, #52]	@ 0x34
 801602e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8016030:	2b00      	cmp	r3, #0
 8016032:	d002      	beq.n	801603a <wc_EncodeSignature+0xd2>
 8016034:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 8016036:	f008 fd43 	bl	801eac0 <wolfSSL_Free>
    return (word32)ret;
 801603a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
#endif
}
 801603c:	4618      	mov	r0, r3
 801603e:	3744      	adds	r7, #68	@ 0x44
 8016040:	46bd      	mov	sp, r7
 8016042:	bd90      	pop	{r4, r7, pc}
 8016044:	080338fc 	.word	0x080338fc

08016048 <InitSignatureCtx>:
 * @param [in, out] sigCtx  Signature context object.
 * @param [in]      heap    Dynamic memory hint.
 * @param [in]      devId   Hardware device identifier.
 */
void InitSignatureCtx(SignatureCtx* sigCtx, void* heap, int devId)
{
 8016048:	b580      	push	{r7, lr}
 801604a:	b084      	sub	sp, #16
 801604c:	af00      	add	r7, sp, #0
 801604e:	60f8      	str	r0, [r7, #12]
 8016050:	60b9      	str	r1, [r7, #8]
 8016052:	607a      	str	r2, [r7, #4]
    if (sigCtx) {
 8016054:	68fb      	ldr	r3, [r7, #12]
 8016056:	2b00      	cmp	r3, #0
 8016058:	d00a      	beq.n	8016070 <InitSignatureCtx+0x28>
        XMEMSET(sigCtx, 0, sizeof(SignatureCtx));
 801605a:	2238      	movs	r2, #56	@ 0x38
 801605c:	2100      	movs	r1, #0
 801605e:	68f8      	ldr	r0, [r7, #12]
 8016060:	f012 fa32 	bl	80284c8 <memset>
        sigCtx->devId = devId;
 8016064:	68fb      	ldr	r3, [r7, #12]
 8016066:	687a      	ldr	r2, [r7, #4]
 8016068:	619a      	str	r2, [r3, #24]
        sigCtx->heap = heap;
 801606a:	68fb      	ldr	r3, [r7, #12]
 801606c:	68ba      	ldr	r2, [r7, #8]
 801606e:	601a      	str	r2, [r3, #0]
    }
}
 8016070:	bf00      	nop
 8016072:	3710      	adds	r7, #16
 8016074:	46bd      	mov	sp, r7
 8016076:	bd80      	pop	{r7, pc}

08016078 <FreeSignatureCtx>:
/* Free dynamic data in a signature context object.
 *
 * @param [in, out] sigCtx  Signature context object.
 */
void FreeSignatureCtx(SignatureCtx* sigCtx)
{
 8016078:	b580      	push	{r7, lr}
 801607a:	b086      	sub	sp, #24
 801607c:	af00      	add	r7, sp, #0
 801607e:	6078      	str	r0, [r7, #4]
    if (sigCtx == NULL)
 8016080:	687b      	ldr	r3, [r7, #4]
 8016082:	2b00      	cmp	r3, #0
 8016084:	d059      	beq.n	801613a <FreeSignatureCtx+0xc2>
        return;

    XFREE(sigCtx->digest, sigCtx->heap, DYNAMIC_TYPE_DIGEST);
 8016086:	687b      	ldr	r3, [r7, #4]
 8016088:	685b      	ldr	r3, [r3, #4]
 801608a:	617b      	str	r3, [r7, #20]
 801608c:	697b      	ldr	r3, [r7, #20]
 801608e:	2b00      	cmp	r3, #0
 8016090:	d002      	beq.n	8016098 <FreeSignatureCtx+0x20>
 8016092:	6978      	ldr	r0, [r7, #20]
 8016094:	f008 fd14 	bl	801eac0 <wolfSSL_Free>
    sigCtx->digest = NULL;
 8016098:	687b      	ldr	r3, [r7, #4]
 801609a:	2200      	movs	r2, #0
 801609c:	605a      	str	r2, [r3, #4]
#if !(defined(NO_RSA) && defined(NO_DSA))
    XFREE(sigCtx->sigCpy, sigCtx->heap, DYNAMIC_TYPE_SIGNATURE);
 801609e:	687b      	ldr	r3, [r7, #4]
 80160a0:	68db      	ldr	r3, [r3, #12]
 80160a2:	613b      	str	r3, [r7, #16]
 80160a4:	693b      	ldr	r3, [r7, #16]
 80160a6:	2b00      	cmp	r3, #0
 80160a8:	d002      	beq.n	80160b0 <FreeSignatureCtx+0x38>
 80160aa:	6938      	ldr	r0, [r7, #16]
 80160ac:	f008 fd08 	bl	801eac0 <wolfSSL_Free>
    sigCtx->sigCpy = NULL;
 80160b0:	687b      	ldr	r3, [r7, #4]
 80160b2:	2200      	movs	r2, #0
 80160b4:	60da      	str	r2, [r3, #12]
#endif
#ifndef NO_ASN_CRYPT
    if (sigCtx->key.ptr) {
 80160b6:	687b      	ldr	r3, [r7, #4]
 80160b8:	695b      	ldr	r3, [r3, #20]
 80160ba:	2b00      	cmp	r3, #0
 80160bc:	d039      	beq.n	8016132 <FreeSignatureCtx+0xba>
        switch (sigCtx->keyOID) {
 80160be:	687b      	ldr	r3, [r7, #4]
 80160c0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80160c2:	f240 228e 	movw	r2, #654	@ 0x28e
 80160c6:	4293      	cmp	r3, r2
 80160c8:	d00b      	beq.n	80160e2 <FreeSignatureCtx+0x6a>
 80160ca:	f240 228e 	movw	r2, #654	@ 0x28e
 80160ce:	4293      	cmp	r3, r2
 80160d0:	d82b      	bhi.n	801612a <FreeSignatureCtx+0xb2>
 80160d2:	f240 2206 	movw	r2, #518	@ 0x206
 80160d6:	4293      	cmp	r3, r2
 80160d8:	d015      	beq.n	8016106 <FreeSignatureCtx+0x8e>
 80160da:	f240 2285 	movw	r2, #645	@ 0x285
 80160de:	4293      	cmp	r3, r2
 80160e0:	d123      	bne.n	801612a <FreeSignatureCtx+0xb2>
        #ifndef NO_RSA
            #ifdef WC_RSA_PSS
            case RSAPSSk:
            #endif
            case RSAk:
                wc_FreeRsaKey(sigCtx->key.rsa);
 80160e2:	687b      	ldr	r3, [r7, #4]
 80160e4:	695b      	ldr	r3, [r3, #20]
 80160e6:	4618      	mov	r0, r3
 80160e8:	f009 ff52 	bl	801ff90 <wc_FreeRsaKey>
                XFREE(sigCtx->key.rsa, sigCtx->heap, DYNAMIC_TYPE_RSA);
 80160ec:	687b      	ldr	r3, [r7, #4]
 80160ee:	695b      	ldr	r3, [r3, #20]
 80160f0:	60fb      	str	r3, [r7, #12]
 80160f2:	68fb      	ldr	r3, [r7, #12]
 80160f4:	2b00      	cmp	r3, #0
 80160f6:	d002      	beq.n	80160fe <FreeSignatureCtx+0x86>
 80160f8:	68f8      	ldr	r0, [r7, #12]
 80160fa:	f008 fce1 	bl	801eac0 <wolfSSL_Free>
                sigCtx->key.rsa = NULL;
 80160fe:	687b      	ldr	r3, [r7, #4]
 8016100:	2200      	movs	r2, #0
 8016102:	615a      	str	r2, [r3, #20]
                break;
 8016104:	e012      	b.n	801612c <FreeSignatureCtx+0xb4>
                    XFREE(sigCtx->key.ecc->nb_ctx, sigCtx->heap,
                          DYNAMIC_TYPE_TMP_BUFFER);
                }
            #endif /* WC_ECC_NONBLOCK && WOLFSSL_ASYNC_CRYPT_SW &&
                      WC_ASYNC_ENABLE_ECC */
                wc_ecc_free(sigCtx->key.ecc);
 8016106:	687b      	ldr	r3, [r7, #4]
 8016108:	695b      	ldr	r3, [r3, #20]
 801610a:	4618      	mov	r0, r3
 801610c:	f006 ff05 	bl	801cf1a <wc_ecc_free>
                XFREE(sigCtx->key.ecc, sigCtx->heap, DYNAMIC_TYPE_ECC);
 8016110:	687b      	ldr	r3, [r7, #4]
 8016112:	695b      	ldr	r3, [r3, #20]
 8016114:	60bb      	str	r3, [r7, #8]
 8016116:	68bb      	ldr	r3, [r7, #8]
 8016118:	2b00      	cmp	r3, #0
 801611a:	d002      	beq.n	8016122 <FreeSignatureCtx+0xaa>
 801611c:	68b8      	ldr	r0, [r7, #8]
 801611e:	f008 fccf 	bl	801eac0 <wolfSSL_Free>
                sigCtx->key.ecc = NULL;
 8016122:	687b      	ldr	r3, [r7, #4]
 8016124:	2200      	movs	r2, #0
 8016126:	615a      	str	r2, [r3, #20]
                break;
 8016128:	e000      	b.n	801612c <FreeSignatureCtx+0xb4>
                      DYNAMIC_TYPE_SPHINCS);
                sigCtx->key.sphincs = NULL;
                break;
        #endif /* HAVE_SPHINCS */
            default:
                break;
 801612a:	bf00      	nop
        } /* switch (keyOID) */
        sigCtx->key.ptr = NULL;
 801612c:	687b      	ldr	r3, [r7, #4]
 801612e:	2200      	movs	r2, #0
 8016130:	615a      	str	r2, [r3, #20]
    }
#endif

    /* reset state, we are done */
    sigCtx->state = SIG_STATE_BEGIN;
 8016132:	687b      	ldr	r3, [r7, #4]
 8016134:	2200      	movs	r2, #0
 8016136:	61da      	str	r2, [r3, #28]
 8016138:	e000      	b.n	801613c <FreeSignatureCtx+0xc4>
        return;
 801613a:	bf00      	nop
}
 801613c:	3718      	adds	r7, #24
 801613e:	46bd      	mov	sp, r7
 8016140:	bd80      	pop	{r7, pc}

08016142 <HashForSignature>:

#if !defined(NO_ASN_CRYPT) && !defined(NO_HASH_WRAPPER)
static int HashForSignature(const byte* buf, word32 bufSz, word32 sigOID,
                            byte* digest, int* typeH, int* digestSz, int verify)
{
 8016142:	b580      	push	{r7, lr}
 8016144:	b086      	sub	sp, #24
 8016146:	af00      	add	r7, sp, #0
 8016148:	60f8      	str	r0, [r7, #12]
 801614a:	60b9      	str	r1, [r7, #8]
 801614c:	607a      	str	r2, [r7, #4]
 801614e:	603b      	str	r3, [r7, #0]
    int ret = 0;
 8016150:	2300      	movs	r3, #0
 8016152:	617b      	str	r3, [r7, #20]

    switch (sigOID) {
 8016154:	687b      	ldr	r3, [r7, #4]
 8016156:	f240 228f 	movw	r2, #655	@ 0x28f
 801615a:	4293      	cmp	r3, r2
 801615c:	d00b      	beq.n	8016176 <HashForSignature+0x34>
 801615e:	687b      	ldr	r3, [r7, #4]
 8016160:	f5b3 7f24 	cmp.w	r3, #656	@ 0x290
 8016164:	d218      	bcs.n	8016198 <HashForSignature+0x56>
 8016166:	687b      	ldr	r3, [r7, #4]
 8016168:	f5b3 7fd0 	cmp.w	r3, #416	@ 0x1a0
 801616c:	d003      	beq.n	8016176 <HashForSignature+0x34>
 801616e:	687b      	ldr	r3, [r7, #4]
 8016170:	f5b3 7f03 	cmp.w	r3, #524	@ 0x20c
 8016174:	d110      	bne.n	8016198 <HashForSignature+0x56>
    #endif
    #ifndef NO_SHA256
        case CTC_SHA256wRSA:
        case CTC_SHA256wECDSA:
        case CTC_SHA256wDSA:
            if ((ret = wc_Sha256Hash(buf, bufSz, digest)) == 0) {
 8016176:	683a      	ldr	r2, [r7, #0]
 8016178:	68b9      	ldr	r1, [r7, #8]
 801617a:	68f8      	ldr	r0, [r7, #12]
 801617c:	f008 f9de 	bl	801e53c <wc_Sha256Hash>
 8016180:	6178      	str	r0, [r7, #20]
 8016182:	697b      	ldr	r3, [r7, #20]
 8016184:	2b00      	cmp	r3, #0
 8016186:	d10b      	bne.n	80161a0 <HashForSignature+0x5e>
                *typeH    = SHA256h;
 8016188:	6a3b      	ldr	r3, [r7, #32]
 801618a:	f44f 72cf 	mov.w	r2, #414	@ 0x19e
 801618e:	601a      	str	r2, [r3, #0]
                *digestSz = WC_SHA256_DIGEST_SIZE;
 8016190:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016192:	2220      	movs	r2, #32
 8016194:	601a      	str	r2, [r3, #0]
            }
            break;
 8016196:	e003      	b.n	80161a0 <HashForSignature+0x5e>
            /* Hashes done in signing operation. */
            break;
    #endif

        default:
            ret = HASH_TYPE_E;
 8016198:	f06f 03e7 	mvn.w	r3, #231	@ 0xe7
 801619c:	617b      	str	r3, [r7, #20]
 801619e:	e000      	b.n	80161a2 <HashForSignature+0x60>
            break;
 80161a0:	bf00      	nop
    (void)digest;
    (void)digestSz;
    (void)typeH;
    (void)verify;

    return ret;
 80161a2:	697b      	ldr	r3, [r7, #20]
}
 80161a4:	4618      	mov	r0, r3
 80161a6:	3718      	adds	r7, #24
 80161a8:	46bd      	mov	sp, r7
 80161aa:	bd80      	pop	{r7, pc}

080161ac <ConfirmSignature>:
    const byte* buf, word32 bufSz,
    const byte* key, word32 keySz, word32 keyOID,
    const byte* sig, word32 sigSz, word32 sigOID,
    const byte* sigParams, word32 sigParamsSz,
    byte* rsaKeyIdx)
{
 80161ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80161b0:	b092      	sub	sp, #72	@ 0x48
 80161b2:	af04      	add	r7, sp, #16
 80161b4:	6178      	str	r0, [r7, #20]
 80161b6:	6139      	str	r1, [r7, #16]
 80161b8:	60fa      	str	r2, [r7, #12]
 80161ba:	60bb      	str	r3, [r7, #8]
    int ret = WC_NO_ERR_TRACE(ASN_SIG_CONFIRM_E); /* default to failure */
 80161bc:	f06f 039a 	mvn.w	r3, #154	@ 0x9a
 80161c0:	637b      	str	r3, [r7, #52]	@ 0x34
#if defined(WOLFSSL_RENESAS_TSIP_TLS) || defined(WOLFSSL_RENESAS_FSPSM_TLS)
    CertAttribute* certatt = NULL;
#endif

    if (sigCtx == NULL || buf == NULL || bufSz == 0 || key == NULL ||
 80161c2:	697b      	ldr	r3, [r7, #20]
 80161c4:	2b00      	cmp	r3, #0
 80161c6:	d011      	beq.n	80161ec <ConfirmSignature+0x40>
 80161c8:	693b      	ldr	r3, [r7, #16]
 80161ca:	2b00      	cmp	r3, #0
 80161cc:	d00e      	beq.n	80161ec <ConfirmSignature+0x40>
 80161ce:	68fb      	ldr	r3, [r7, #12]
 80161d0:	2b00      	cmp	r3, #0
 80161d2:	d00b      	beq.n	80161ec <ConfirmSignature+0x40>
 80161d4:	68bb      	ldr	r3, [r7, #8]
 80161d6:	2b00      	cmp	r3, #0
 80161d8:	d008      	beq.n	80161ec <ConfirmSignature+0x40>
 80161da:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80161dc:	2b00      	cmp	r3, #0
 80161de:	d005      	beq.n	80161ec <ConfirmSignature+0x40>
        keySz == 0 || sig == NULL || sigSz == 0) {
 80161e0:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80161e2:	2b00      	cmp	r3, #0
 80161e4:	d002      	beq.n	80161ec <ConfirmSignature+0x40>
 80161e6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80161e8:	2b00      	cmp	r3, #0
 80161ea:	d102      	bne.n	80161f2 <ConfirmSignature+0x46>
        return BAD_FUNC_ARG;
 80161ec:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80161f0:	e219      	b.n	8016626 <ConfirmSignature+0x47a>
        certatt->certSz = bufSz;
    }
#endif

#ifndef NO_ASN_CRYPT
    switch (sigCtx->state) {
 80161f2:	697b      	ldr	r3, [r7, #20]
 80161f4:	69db      	ldr	r3, [r3, #28]
 80161f6:	2b04      	cmp	r3, #4
 80161f8:	f200 8202 	bhi.w	8016600 <ConfirmSignature+0x454>
 80161fc:	a201      	add	r2, pc, #4	@ (adr r2, 8016204 <ConfirmSignature+0x58>)
 80161fe:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8016202:	bf00      	nop
 8016204:	08016219 	.word	0x08016219
 8016208:	08016255 	.word	0x08016255
 801620c:	08016303 	.word	0x08016303
 8016210:	0801643d 	.word	0x0801643d
 8016214:	080164f3 	.word	0x080164f3
        case SIG_STATE_BEGIN:
        {
            sigCtx->keyOID = keyOID; /* must set early for cleanup */
 8016218:	697b      	ldr	r3, [r7, #20]
 801621a:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801621c:	629a      	str	r2, [r3, #40]	@ 0x28

            sigCtx->digest = (byte*)XMALLOC(WC_MAX_DIGEST_SIZE, sigCtx->heap,
 801621e:	2020      	movs	r0, #32
 8016220:	f008 fc32 	bl	801ea88 <wolfSSL_Malloc>
 8016224:	4602      	mov	r2, r0
 8016226:	697b      	ldr	r3, [r7, #20]
 8016228:	605a      	str	r2, [r3, #4]
                                                    DYNAMIC_TYPE_DIGEST);
            if (sigCtx->digest == NULL) {
 801622a:	697b      	ldr	r3, [r7, #20]
 801622c:	685b      	ldr	r3, [r3, #4]
 801622e:	2b00      	cmp	r3, #0
 8016230:	d103      	bne.n	801623a <ConfirmSignature+0x8e>
                ERROR_OUT(MEMORY_E, exit_cs);
 8016232:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8016236:	637b      	str	r3, [r7, #52]	@ 0x34
 8016238:	e1f1      	b.n	801661e <ConfirmSignature+0x472>
            }

        #if !defined(NO_RSA) && defined(WC_RSA_PSS)
            /* RSA PSS Defaults */
            sigCtx->hash = WC_HASH_TYPE_SHA;
 801623a:	697b      	ldr	r3, [r7, #20]
 801623c:	2204      	movs	r2, #4
 801623e:	f883 202c 	strb.w	r2, [r3, #44]	@ 0x2c
            sigCtx->mgf = WC_MGF1SHA1;
 8016242:	697b      	ldr	r3, [r7, #20]
 8016244:	221a      	movs	r2, #26
 8016246:	631a      	str	r2, [r3, #48]	@ 0x30
            sigCtx->saltLen = 20;
 8016248:	697b      	ldr	r3, [r7, #20]
 801624a:	2214      	movs	r2, #20
 801624c:	635a      	str	r2, [r3, #52]	@ 0x34
        #endif

            sigCtx->state = SIG_STATE_HASH;
 801624e:	697b      	ldr	r3, [r7, #20]
 8016250:	2201      	movs	r2, #1
 8016252:	61da      	str	r2, [r3, #28]
        FALL_THROUGH;

        case SIG_STATE_HASH:
        {
        #if !defined(NO_RSA) && defined(WC_RSA_PSS)
            if (sigOID == RSAPSSk) {
 8016254:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8016256:	f240 228e 	movw	r2, #654	@ 0x28e
 801625a:	4293      	cmp	r3, r2
 801625c:	d139      	bne.n	80162d2 <ConfirmSignature+0x126>
                word32 fakeSigOID = 0;
 801625e:	2300      	movs	r3, #0
 8016260:	623b      	str	r3, [r7, #32]
                ret = DecodeRsaPssParams(sigParams, sigParamsSz, &sigCtx->hash,
 8016262:	697b      	ldr	r3, [r7, #20]
 8016264:	f103 022c 	add.w	r2, r3, #44	@ 0x2c
 8016268:	697b      	ldr	r3, [r7, #20]
 801626a:	f103 0130 	add.w	r1, r3, #48	@ 0x30
 801626e:	697b      	ldr	r3, [r7, #20]
 8016270:	3334      	adds	r3, #52	@ 0x34
 8016272:	9300      	str	r3, [sp, #0]
 8016274:	460b      	mov	r3, r1
 8016276:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 8016278:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 801627a:	f7fe fb4b 	bl	8014914 <DecodeRsaPssParams>
 801627e:	6378      	str	r0, [r7, #52]	@ 0x34
                    &sigCtx->mgf, &sigCtx->saltLen);
                if (ret != 0) {
 8016280:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8016282:	2b00      	cmp	r3, #0
 8016284:	f040 81be 	bne.w	8016604 <ConfirmSignature+0x458>
                    goto exit_cs;
                }
                ret = RsaPssHashOidToSigOid(sigCtx->hash, &fakeSigOID);
 8016288:	697b      	ldr	r3, [r7, #20]
 801628a:	f893 302c 	ldrb.w	r3, [r3, #44]	@ 0x2c
 801628e:	461a      	mov	r2, r3
 8016290:	f107 0320 	add.w	r3, r7, #32
 8016294:	4619      	mov	r1, r3
 8016296:	4610      	mov	r0, r2
 8016298:	f7fe fb22 	bl	80148e0 <RsaPssHashOidToSigOid>
 801629c:	6378      	str	r0, [r7, #52]	@ 0x34
                if (ret != 0) {
 801629e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80162a0:	2b00      	cmp	r3, #0
 80162a2:	f040 81b1 	bne.w	8016608 <ConfirmSignature+0x45c>
                    goto exit_cs;
                }
                /* Decode parameters. */
                ret = HashForSignature(buf, bufSz, fakeSigOID, sigCtx->digest,
 80162a6:	6a39      	ldr	r1, [r7, #32]
 80162a8:	697b      	ldr	r3, [r7, #20]
 80162aa:	6858      	ldr	r0, [r3, #4]
 80162ac:	697b      	ldr	r3, [r7, #20]
 80162ae:	3320      	adds	r3, #32
 80162b0:	697a      	ldr	r2, [r7, #20]
 80162b2:	3224      	adds	r2, #36	@ 0x24
 80162b4:	2401      	movs	r4, #1
 80162b6:	9402      	str	r4, [sp, #8]
 80162b8:	9201      	str	r2, [sp, #4]
 80162ba:	9300      	str	r3, [sp, #0]
 80162bc:	4603      	mov	r3, r0
 80162be:	460a      	mov	r2, r1
 80162c0:	68f9      	ldr	r1, [r7, #12]
 80162c2:	6938      	ldr	r0, [r7, #16]
 80162c4:	f7ff ff3d 	bl	8016142 <HashForSignature>
 80162c8:	6378      	str	r0, [r7, #52]	@ 0x34
                    &sigCtx->typeH, &sigCtx->digestSz, 1);
                if (ret != 0) {
 80162ca:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80162cc:	2b00      	cmp	r3, #0
 80162ce:	d015      	beq.n	80162fc <ConfirmSignature+0x150>
                    goto exit_cs;
 80162d0:	e1a5      	b.n	801661e <ConfirmSignature+0x472>
                ; /* SM2 hash requires public key. Done later. */
            }
            else
        #endif
            {
                ret = HashForSignature(buf, bufSz, sigOID, sigCtx->digest,
 80162d2:	697b      	ldr	r3, [r7, #20]
 80162d4:	6859      	ldr	r1, [r3, #4]
 80162d6:	697b      	ldr	r3, [r7, #20]
 80162d8:	3320      	adds	r3, #32
 80162da:	697a      	ldr	r2, [r7, #20]
 80162dc:	3224      	adds	r2, #36	@ 0x24
 80162de:	2001      	movs	r0, #1
 80162e0:	9002      	str	r0, [sp, #8]
 80162e2:	9201      	str	r2, [sp, #4]
 80162e4:	9300      	str	r3, [sp, #0]
 80162e6:	460b      	mov	r3, r1
 80162e8:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 80162ea:	68f9      	ldr	r1, [r7, #12]
 80162ec:	6938      	ldr	r0, [r7, #16]
 80162ee:	f7ff ff28 	bl	8016142 <HashForSignature>
 80162f2:	6378      	str	r0, [r7, #52]	@ 0x34
                                       &sigCtx->typeH, &sigCtx->digestSz, 1);
                if (ret != 0) {
 80162f4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80162f6:	2b00      	cmp	r3, #0
 80162f8:	f040 8188 	bne.w	801660c <ConfirmSignature+0x460>
                    goto exit_cs;
                }
            }

            sigCtx->state = SIG_STATE_KEY;
 80162fc:	697b      	ldr	r3, [r7, #20]
 80162fe:	2202      	movs	r2, #2
 8016300:	61da      	str	r2, [r3, #28]
        } /* SIG_STATE_HASH */
        FALL_THROUGH;

        case SIG_STATE_KEY:
        {
            switch (keyOID) {
 8016302:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8016304:	f240 228e 	movw	r2, #654	@ 0x28e
 8016308:	4293      	cmp	r3, r2
 801630a:	d00f      	beq.n	801632c <ConfirmSignature+0x180>
 801630c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801630e:	f240 228e 	movw	r2, #654	@ 0x28e
 8016312:	4293      	cmp	r3, r2
 8016314:	f200 8086 	bhi.w	8016424 <ConfirmSignature+0x278>
 8016318:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801631a:	f240 2206 	movw	r2, #518	@ 0x206
 801631e:	4293      	cmp	r3, r2
 8016320:	d051      	beq.n	80163c6 <ConfirmSignature+0x21a>
 8016322:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8016324:	f240 2285 	movw	r2, #645	@ 0x285
 8016328:	4293      	cmp	r3, r2
 801632a:	d17b      	bne.n	8016424 <ConfirmSignature+0x278>
                #ifdef WC_RSA_PSS
                case RSAPSSk:
                #endif
                case RSAk:
                {
                    word32 idx = 0;
 801632c:	2300      	movs	r3, #0
 801632e:	61fb      	str	r3, [r7, #28]

                    sigCtx->key.rsa = (RsaKey*)XMALLOC(sizeof(RsaKey),
 8016330:	f241 107c 	movw	r0, #4476	@ 0x117c
 8016334:	f008 fba8 	bl	801ea88 <wolfSSL_Malloc>
 8016338:	4602      	mov	r2, r0
 801633a:	697b      	ldr	r3, [r7, #20]
 801633c:	615a      	str	r2, [r3, #20]
                                                sigCtx->heap, DYNAMIC_TYPE_RSA);
                    if (sigCtx->key.rsa == NULL) {
 801633e:	697b      	ldr	r3, [r7, #20]
 8016340:	695b      	ldr	r3, [r3, #20]
 8016342:	2b00      	cmp	r3, #0
 8016344:	d103      	bne.n	801634e <ConfirmSignature+0x1a2>
                        ERROR_OUT(MEMORY_E, exit_cs);
 8016346:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801634a:	637b      	str	r3, [r7, #52]	@ 0x34
 801634c:	e167      	b.n	801661e <ConfirmSignature+0x472>
                    }
                    if ((ret = wc_InitRsaKey_ex(sigCtx->key.rsa, sigCtx->heap,
 801634e:	697b      	ldr	r3, [r7, #20]
 8016350:	6958      	ldr	r0, [r3, #20]
 8016352:	697b      	ldr	r3, [r7, #20]
 8016354:	6819      	ldr	r1, [r3, #0]
 8016356:	697b      	ldr	r3, [r7, #20]
 8016358:	699b      	ldr	r3, [r3, #24]
 801635a:	461a      	mov	r2, r3
 801635c:	f009 fd84 	bl	801fe68 <wc_InitRsaKey_ex>
 8016360:	6378      	str	r0, [r7, #52]	@ 0x34
 8016362:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8016364:	2b00      	cmp	r3, #0
 8016366:	f040 8153 	bne.w	8016610 <ConfirmSignature+0x464>
                                                        sigCtx->devId)) != 0) {
                        goto exit_cs;
                    }
                    sigCtx->sigCpy = (byte*)XMALLOC(sigSz, sigCtx->heap,
 801636a:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801636c:	f008 fb8c 	bl	801ea88 <wolfSSL_Malloc>
 8016370:	4602      	mov	r2, r0
 8016372:	697b      	ldr	r3, [r7, #20]
 8016374:	60da      	str	r2, [r3, #12]
                                                        DYNAMIC_TYPE_SIGNATURE);
                    if (sigCtx->sigCpy == NULL) {
 8016376:	697b      	ldr	r3, [r7, #20]
 8016378:	68db      	ldr	r3, [r3, #12]
 801637a:	2b00      	cmp	r3, #0
 801637c:	d103      	bne.n	8016386 <ConfirmSignature+0x1da>
                        ERROR_OUT(MEMORY_E, exit_cs);
 801637e:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8016382:	637b      	str	r3, [r7, #52]	@ 0x34
 8016384:	e14b      	b.n	801661e <ConfirmSignature+0x472>
                    }
                    if (sigSz > MAX_ENCODED_SIG_SZ) {
 8016386:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8016388:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 801638c:	d903      	bls.n	8016396 <ConfirmSignature+0x1ea>
                        WOLFSSL_MSG("Verify Signature is too big");
                        ERROR_OUT(BUFFER_E, exit_cs);
 801638e:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8016392:	637b      	str	r3, [r7, #52]	@ 0x34
 8016394:	e143      	b.n	801661e <ConfirmSignature+0x472>
                    }
                    if ((ret = wc_RsaPublicKeyDecode(key, &idx, sigCtx->key.rsa,
 8016396:	697b      	ldr	r3, [r7, #20]
 8016398:	695a      	ldr	r2, [r3, #20]
 801639a:	f107 011c 	add.w	r1, r7, #28
 801639e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80163a0:	68b8      	ldr	r0, [r7, #8]
 80163a2:	f7fe fe65 	bl	8015070 <wc_RsaPublicKeyDecode>
 80163a6:	6378      	str	r0, [r7, #52]	@ 0x34
 80163a8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80163aa:	2b00      	cmp	r3, #0
 80163ac:	f040 8132 	bne.w	8016614 <ConfirmSignature+0x468>
                                                                 keySz)) != 0) {
                        WOLFSSL_MSG("ASN Key decode error RSA");
                        WOLFSSL_ERROR_VERBOSE(ret);
                        goto exit_cs;
                    }
                    XMEMCPY(sigCtx->sigCpy, sig, sigSz);
 80163b0:	697b      	ldr	r3, [r7, #20]
 80163b2:	68db      	ldr	r3, [r3, #12]
 80163b4:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 80163b6:	6db9      	ldr	r1, [r7, #88]	@ 0x58
 80163b8:	4618      	mov	r0, r3
 80163ba:	f012 f8ef 	bl	802859c <memcpy>
                    sigCtx->out = NULL;
 80163be:	697b      	ldr	r3, [r7, #20]
 80163c0:	2200      	movs	r2, #0
 80163c2:	609a      	str	r2, [r3, #8]
 80163c4:	e033      	b.n	801642e <ConfirmSignature+0x282>
            #if defined(WOLFSSL_SM2) && defined(WOLFSSL_SM3)
                case SM2k:
            #endif
                case ECDSAk:
                {
                    word32 idx = 0;
 80163c6:	2300      	movs	r3, #0
 80163c8:	61bb      	str	r3, [r7, #24]
                defined(WC_ASYNC_ENABLE_ECC)
                    ecc_nb_ctx_t* nbCtx;
            #endif /* WC_ECC_NONBLOCK && WOLFSSL_ASYNC_CRYPT_SW &&
                      WC_ASYNC_ENABLE_ECC */

                    sigCtx->verify = 0;
 80163ca:	697b      	ldr	r3, [r7, #20]
 80163cc:	2200      	movs	r2, #0
 80163ce:	611a      	str	r2, [r3, #16]
                    sigCtx->key.ecc = (ecc_key*)XMALLOC(sizeof(ecc_key),
 80163d0:	f44f 70b8 	mov.w	r0, #368	@ 0x170
 80163d4:	f008 fb58 	bl	801ea88 <wolfSSL_Malloc>
 80163d8:	4602      	mov	r2, r0
 80163da:	697b      	ldr	r3, [r7, #20]
 80163dc:	615a      	str	r2, [r3, #20]
                                                sigCtx->heap, DYNAMIC_TYPE_ECC);
                    if (sigCtx->key.ecc == NULL) {
 80163de:	697b      	ldr	r3, [r7, #20]
 80163e0:	695b      	ldr	r3, [r3, #20]
 80163e2:	2b00      	cmp	r3, #0
 80163e4:	d103      	bne.n	80163ee <ConfirmSignature+0x242>
                        ERROR_OUT(MEMORY_E, exit_cs);
 80163e6:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 80163ea:	637b      	str	r3, [r7, #52]	@ 0x34
 80163ec:	e117      	b.n	801661e <ConfirmSignature+0x472>
                    }
                    if ((ret = wc_ecc_init_ex(sigCtx->key.ecc, sigCtx->heap,
 80163ee:	697b      	ldr	r3, [r7, #20]
 80163f0:	6958      	ldr	r0, [r3, #20]
 80163f2:	697b      	ldr	r3, [r7, #20]
 80163f4:	6819      	ldr	r1, [r3, #0]
 80163f6:	697b      	ldr	r3, [r7, #20]
 80163f8:	699b      	ldr	r3, [r3, #24]
 80163fa:	461a      	mov	r2, r3
 80163fc:	f006 fcf2 	bl	801cde4 <wc_ecc_init_ex>
 8016400:	6378      	str	r0, [r7, #52]	@ 0x34
 8016402:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8016404:	2b00      	cmp	r3, #0
 8016406:	f2c0 8107 	blt.w	8016618 <ConfirmSignature+0x46c>
                            goto exit_cs;
                        }
                    }
            #endif /* WC_ECC_NONBLOCK && WOLFSSL_ASYNC_CRYPT_SW &&
                      WC_ASYNC_ENABLE_ECC */
                    ret = wc_EccPublicKeyDecode(key, &idx, sigCtx->key.ecc,
 801640a:	697b      	ldr	r3, [r7, #20]
 801640c:	695a      	ldr	r2, [r3, #20]
 801640e:	f107 0118 	add.w	r1, r7, #24
 8016412:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8016414:	68b8      	ldr	r0, [r7, #8]
 8016416:	f003 fd95 	bl	8019f44 <wc_EccPublicKeyDecode>
 801641a:	6378      	str	r0, [r7, #52]	@ 0x34
                                                                         keySz);
                    if (ret < 0) {
 801641c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801641e:	2b00      	cmp	r3, #0
 8016420:	da04      	bge.n	801642c <ConfirmSignature+0x280>
                        WOLFSSL_MSG("ASN Key import error ECC");
                        WOLFSSL_ERROR_VERBOSE(ret);
                        goto exit_cs;
 8016422:	e0fc      	b.n	801661e <ConfirmSignature+0x472>
                    break;
                }
            #endif /* HAVE_SPHINCS */
                default:
                    WOLFSSL_MSG("Verify Key type unknown");
                    ret = ASN_UNKNOWN_OID_E;
 8016424:	f06f 0393 	mvn.w	r3, #147	@ 0x93
 8016428:	637b      	str	r3, [r7, #52]	@ 0x34
                    WOLFSSL_ERROR_VERBOSE(ret);
                    break;
 801642a:	e000      	b.n	801642e <ConfirmSignature+0x282>
                    break;
 801642c:	bf00      	nop
            } /* switch (keyOID) */

            if (ret != 0) {
 801642e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8016430:	2b00      	cmp	r3, #0
 8016432:	f040 80f3 	bne.w	801661c <ConfirmSignature+0x470>
                goto exit_cs;
            }

            sigCtx->state = SIG_STATE_DO;
 8016436:	697b      	ldr	r3, [r7, #20]
 8016438:	2203      	movs	r2, #3
 801643a:	61da      	str	r2, [r3, #28]
        } /* SIG_STATE_KEY */
        FALL_THROUGH;

        case SIG_STATE_DO:
        {
            switch (keyOID) {
 801643c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801643e:	f240 228e 	movw	r2, #654	@ 0x28e
 8016442:	4293      	cmp	r3, r2
 8016444:	d00e      	beq.n	8016464 <ConfirmSignature+0x2b8>
 8016446:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8016448:	f240 228e 	movw	r2, #654	@ 0x28e
 801644c:	4293      	cmp	r3, r2
 801644e:	d845      	bhi.n	80164dc <ConfirmSignature+0x330>
 8016450:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8016452:	f240 2206 	movw	r2, #518	@ 0x206
 8016456:	4293      	cmp	r3, r2
 8016458:	d02d      	beq.n	80164b6 <ConfirmSignature+0x30a>
 801645a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801645c:	f240 2285 	movw	r2, #645	@ 0x285
 8016460:	4293      	cmp	r3, r2
 8016462:	d13b      	bne.n	80164dc <ConfirmSignature+0x330>
            #ifndef NO_RSA
                case RSAk:
                #ifdef WC_RSA_PSS
                case RSAPSSk:
                if (sigOID == RSAPSSk) {
 8016464:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8016466:	f240 228e 	movw	r2, #654	@ 0x28e
 801646a:	4293      	cmp	r3, r2
 801646c:	d117      	bne.n	801649e <ConfirmSignature+0x2f2>
                    /* TODO: pkCbRsaPss - RSA PSS callback. */
                    ret = wc_RsaPSS_VerifyInline_ex(sigCtx->sigCpy, sigSz,
 801646e:	697b      	ldr	r3, [r7, #20]
 8016470:	68d8      	ldr	r0, [r3, #12]
 8016472:	697b      	ldr	r3, [r7, #20]
 8016474:	f103 0408 	add.w	r4, r3, #8
 8016478:	697b      	ldr	r3, [r7, #20]
 801647a:	f893 502c 	ldrb.w	r5, [r3, #44]	@ 0x2c
 801647e:	697b      	ldr	r3, [r7, #20]
 8016480:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8016482:	697a      	ldr	r2, [r7, #20]
 8016484:	6b52      	ldr	r2, [r2, #52]	@ 0x34
                        &sigCtx->out, sigCtx->hash, sigCtx->mgf,
                        sigCtx->saltLen, sigCtx->key.rsa);
 8016486:	6979      	ldr	r1, [r7, #20]
 8016488:	6949      	ldr	r1, [r1, #20]
                    ret = wc_RsaPSS_VerifyInline_ex(sigCtx->sigCpy, sigSz,
 801648a:	9102      	str	r1, [sp, #8]
 801648c:	9201      	str	r2, [sp, #4]
 801648e:	9300      	str	r3, [sp, #0]
 8016490:	462b      	mov	r3, r5
 8016492:	4622      	mov	r2, r4
 8016494:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 8016496:	f00a fedf 	bl	8021258 <wc_RsaPSS_VerifyInline_ex>
 801649a:	6378      	str	r0, [r7, #52]	@ 0x34
                    {
                        ret = wc_RsaSSL_VerifyInline(sigCtx->sigCpy, sigSz,
                                                 &sigCtx->out, sigCtx->key.rsa);
                    }
                }
                break;
 801649c:	e01f      	b.n	80164de <ConfirmSignature+0x332>
                        ret = wc_RsaSSL_VerifyInline(sigCtx->sigCpy, sigSz,
 801649e:	697b      	ldr	r3, [r7, #20]
 80164a0:	68d8      	ldr	r0, [r3, #12]
 80164a2:	697b      	ldr	r3, [r7, #20]
 80164a4:	f103 0208 	add.w	r2, r3, #8
                                                 &sigCtx->out, sigCtx->key.rsa);
 80164a8:	697b      	ldr	r3, [r7, #20]
 80164aa:	695b      	ldr	r3, [r3, #20]
                        ret = wc_RsaSSL_VerifyInline(sigCtx->sigCpy, sigSz,
 80164ac:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 80164ae:	f00a fea4 	bl	80211fa <wc_RsaSSL_VerifyInline>
 80164b2:	6378      	str	r0, [r7, #52]	@ 0x34
                break;
 80164b4:	e013      	b.n	80164de <ConfirmSignature+0x332>
                    if (!sigCtx->pkCbEcc ||
                        ret == WC_NO_ERR_TRACE(CRYPTOCB_UNAVAILABLE))
                #endif /* WOLFSSL_RENESAS_FSPSM_TLS */
                #endif /* HAVE_PK_CALLBACKS */
                    {
                        ret = wc_ecc_verify_hash(sig, sigSz, sigCtx->digest,
 80164b6:	697b      	ldr	r3, [r7, #20]
 80164b8:	6859      	ldr	r1, [r3, #4]
                            (word32)sigCtx->digestSz, &sigCtx->verify,
 80164ba:	697b      	ldr	r3, [r7, #20]
 80164bc:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
                        ret = wc_ecc_verify_hash(sig, sigSz, sigCtx->digest,
 80164be:	4618      	mov	r0, r3
 80164c0:	697b      	ldr	r3, [r7, #20]
 80164c2:	3310      	adds	r3, #16
                            sigCtx->key.ecc);
 80164c4:	697a      	ldr	r2, [r7, #20]
 80164c6:	6952      	ldr	r2, [r2, #20]
                        ret = wc_ecc_verify_hash(sig, sigSz, sigCtx->digest,
 80164c8:	9201      	str	r2, [sp, #4]
 80164ca:	9300      	str	r3, [sp, #0]
 80164cc:	4603      	mov	r3, r0
 80164ce:	460a      	mov	r2, r1
 80164d0:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 80164d2:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 80164d4:	f007 f9b2 	bl	801d83c <wc_ecc_verify_hash>
 80164d8:	6378      	str	r0, [r7, #52]	@ 0x34
                    }
                    break;
 80164da:	e000      	b.n	80164de <ConfirmSignature+0x332>
                                                sigCtx->key.sphincs);
                    break;
                }
            #endif /* HAVE_SPHINCS */
                default:
                    break;
 80164dc:	bf00      	nop
            if (ret == WC_NO_ERR_TRACE(WC_PENDING_E)) {
                goto exit_cs;
            }
        #endif

            if (ret < 0) {
 80164de:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80164e0:	2b00      	cmp	r3, #0
 80164e2:	da03      	bge.n	80164ec <ConfirmSignature+0x340>
                /* treat all errors as ASN_SIG_CONFIRM_E */
                ret = ASN_SIG_CONFIRM_E;
 80164e4:	f06f 039a 	mvn.w	r3, #154	@ 0x9a
 80164e8:	637b      	str	r3, [r7, #52]	@ 0x34
                WOLFSSL_ERROR_VERBOSE(ret);
                goto exit_cs;
 80164ea:	e098      	b.n	801661e <ConfirmSignature+0x472>
            }

            sigCtx->state = SIG_STATE_CHECK;
 80164ec:	697b      	ldr	r3, [r7, #20]
 80164ee:	2204      	movs	r2, #4
 80164f0:	61da      	str	r2, [r3, #28]
        } /* SIG_STATE_DO */
        FALL_THROUGH;

        case SIG_STATE_CHECK:
        {
            switch (keyOID) {
 80164f2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80164f4:	f240 228e 	movw	r2, #654	@ 0x28e
 80164f8:	4293      	cmp	r3, r2
 80164fa:	d00e      	beq.n	801651a <ConfirmSignature+0x36e>
 80164fc:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80164fe:	f240 228e 	movw	r2, #654	@ 0x28e
 8016502:	4293      	cmp	r3, r2
 8016504:	d878      	bhi.n	80165f8 <ConfirmSignature+0x44c>
 8016506:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8016508:	f240 2206 	movw	r2, #518	@ 0x206
 801650c:	4293      	cmp	r3, r2
 801650e:	d068      	beq.n	80165e2 <ConfirmSignature+0x436>
 8016510:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8016512:	f240 2285 	movw	r2, #645	@ 0x285
 8016516:	4293      	cmp	r3, r2
 8016518:	d16e      	bne.n	80165f8 <ConfirmSignature+0x44c>
            #ifndef NO_RSA
                case RSAk:
                #ifdef WC_RSA_PSS
                case RSAPSSk:
                if (sigOID == RSAPSSk) {
 801651a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801651c:	f240 228e 	movw	r2, #654	@ 0x28e
 8016520:	4293      	cmp	r3, r2
 8016522:	d123      	bne.n	801656c <ConfirmSignature+0x3c0>
                       (HAVE_FIPS_VERSION == 2))
                    ret = wc_RsaPSS_CheckPadding_ex(sigCtx->digest,
                        sigCtx->digestSz, sigCtx->out, ret, sigCtx->hash,
                        sigCtx->saltLen, 0);
                #else
                    ret = wc_RsaPSS_CheckPadding_ex2(sigCtx->digest,
 8016524:	697b      	ldr	r3, [r7, #20]
 8016526:	685e      	ldr	r6, [r3, #4]
                        (word32)sigCtx->digestSz, sigCtx->out, (word32)ret, sigCtx->hash,
 8016528:	697b      	ldr	r3, [r7, #20]
 801652a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
                    ret = wc_RsaPSS_CheckPadding_ex2(sigCtx->digest,
 801652c:	4698      	mov	r8, r3
 801652e:	697b      	ldr	r3, [r7, #20]
 8016530:	689b      	ldr	r3, [r3, #8]
 8016532:	607b      	str	r3, [r7, #4]
 8016534:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 8016536:	6039      	str	r1, [r7, #0]
 8016538:	697b      	ldr	r3, [r7, #20]
 801653a:	f893 402c 	ldrb.w	r4, [r3, #44]	@ 0x2c
 801653e:	697b      	ldr	r3, [r7, #20]
 8016540:	6b5d      	ldr	r5, [r3, #52]	@ 0x34
                        sigCtx->saltLen, wc_RsaEncryptSize(sigCtx->key.rsa) * 8,
 8016542:	697b      	ldr	r3, [r7, #20]
 8016544:	695b      	ldr	r3, [r3, #20]
 8016546:	4618      	mov	r0, r3
 8016548:	f00a ff4c 	bl	80213e4 <wc_RsaEncryptSize>
 801654c:	4603      	mov	r3, r0
                    ret = wc_RsaPSS_CheckPadding_ex2(sigCtx->digest,
 801654e:	00db      	lsls	r3, r3, #3
 8016550:	697a      	ldr	r2, [r7, #20]
 8016552:	6812      	ldr	r2, [r2, #0]
 8016554:	9203      	str	r2, [sp, #12]
 8016556:	9302      	str	r3, [sp, #8]
 8016558:	9501      	str	r5, [sp, #4]
 801655a:	9400      	str	r4, [sp, #0]
 801655c:	683b      	ldr	r3, [r7, #0]
 801655e:	687a      	ldr	r2, [r7, #4]
 8016560:	4641      	mov	r1, r8
 8016562:	4630      	mov	r0, r6
 8016564:	f00a fea7 	bl	80212b6 <wc_RsaPSS_CheckPadding_ex2>
 8016568:	6378      	str	r0, [r7, #52]	@ 0x34
                        sigCtx->heap);
                #endif
                    break;
 801656a:	e048      	b.n	80165fe <ConfirmSignature+0x452>
                #if defined(WOLFSSL_RENESAS_TSIP_TLS) || \
                                            defined(WOLFSSL_RENESAS_FSPSM_TLS)
                    if (sigCtx->CertAtt.verifyByTSIP_SCE == 1) break;
                #endif
                #ifdef WOLFSSL_SMALL_STACK
                    byte* encodedSig = (byte*)XMALLOC(MAX_ENCODED_SIG_SZ,
 801656c:	f44f 7000 	mov.w	r0, #512	@ 0x200
 8016570:	f008 fa8a 	bl	801ea88 <wolfSSL_Malloc>
 8016574:	6338      	str	r0, [r7, #48]	@ 0x30
                                        sigCtx->heap, DYNAMIC_TYPE_TMP_BUFFER);
                    if (encodedSig == NULL) {
 8016576:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016578:	2b00      	cmp	r3, #0
 801657a:	d103      	bne.n	8016584 <ConfirmSignature+0x3d8>
                        ERROR_OUT(MEMORY_E, exit_cs);
 801657c:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8016580:	637b      	str	r3, [r7, #52]	@ 0x34
 8016582:	e04c      	b.n	801661e <ConfirmSignature+0x472>
                    }
                #else
                    byte encodedSig[MAX_ENCODED_SIG_SZ];
                #endif

                    verifySz = ret;
 8016584:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8016586:	62fb      	str	r3, [r7, #44]	@ 0x2c

                    /* make sure we're right justified */
                    encodedSigSz = (int)wc_EncodeSignature(encodedSig,
                            sigCtx->digest, (word32)sigCtx->digestSz,
 8016588:	697b      	ldr	r3, [r7, #20]
 801658a:	6859      	ldr	r1, [r3, #4]
 801658c:	697b      	ldr	r3, [r7, #20]
 801658e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
                    encodedSigSz = (int)wc_EncodeSignature(encodedSig,
 8016590:	461a      	mov	r2, r3
 8016592:	697b      	ldr	r3, [r7, #20]
 8016594:	6a1b      	ldr	r3, [r3, #32]
 8016596:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 8016598:	f7ff fce6 	bl	8015f68 <wc_EncodeSignature>
 801659c:	4603      	mov	r3, r0
 801659e:	62bb      	str	r3, [r7, #40]	@ 0x28
                            sigCtx->typeH);
                    if (encodedSigSz == verifySz && sigCtx->out != NULL &&
 80165a0:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80165a2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80165a4:	429a      	cmp	r2, r3
 80165a6:	d110      	bne.n	80165ca <ConfirmSignature+0x41e>
 80165a8:	697b      	ldr	r3, [r7, #20]
 80165aa:	689b      	ldr	r3, [r3, #8]
 80165ac:	2b00      	cmp	r3, #0
 80165ae:	d00c      	beq.n	80165ca <ConfirmSignature+0x41e>
                        XMEMCMP(sigCtx->out, encodedSig,
 80165b0:	697b      	ldr	r3, [r7, #20]
 80165b2:	689b      	ldr	r3, [r3, #8]
 80165b4:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80165b6:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 80165b8:	4618      	mov	r0, r3
 80165ba:	f011 ff5b 	bl	8028474 <memcmp>
 80165be:	4603      	mov	r3, r0
                    if (encodedSigSz == verifySz && sigCtx->out != NULL &&
 80165c0:	2b00      	cmp	r3, #0
 80165c2:	d102      	bne.n	80165ca <ConfirmSignature+0x41e>
                            (size_t)encodedSigSz) == 0) {
                        ret = 0;
 80165c4:	2300      	movs	r3, #0
 80165c6:	637b      	str	r3, [r7, #52]	@ 0x34
 80165c8:	e002      	b.n	80165d0 <ConfirmSignature+0x424>
                    }
                    else {
                        WOLFSSL_MSG("RSA SSL verify match encode error");
                        ret = ASN_SIG_CONFIRM_E;
 80165ca:	f06f 039a 	mvn.w	r3, #154	@ 0x9a
 80165ce:	637b      	str	r3, [r7, #52]	@ 0x34
                        WOLFSSL_ERROR_VERBOSE(ret);
                    }

                #ifdef WOLFSSL_SMALL_STACK
                    XFREE(encodedSig, sigCtx->heap, DYNAMIC_TYPE_TMP_BUFFER);
 80165d0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80165d2:	627b      	str	r3, [r7, #36]	@ 0x24
 80165d4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80165d6:	2b00      	cmp	r3, #0
 80165d8:	d010      	beq.n	80165fc <ConfirmSignature+0x450>
 80165da:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 80165dc:	f008 fa70 	bl	801eac0 <wolfSSL_Free>
                #endif
                    break;
 80165e0:	e00c      	b.n	80165fc <ConfirmSignature+0x450>
            #if defined(WOLFSSL_SM2) && defined(WOLFSSL_SM3)
                case SM2k:
            #endif
                case ECDSAk:
                {
                    if (sigCtx->verify == 1) {
 80165e2:	697b      	ldr	r3, [r7, #20]
 80165e4:	691b      	ldr	r3, [r3, #16]
 80165e6:	2b01      	cmp	r3, #1
 80165e8:	d102      	bne.n	80165f0 <ConfirmSignature+0x444>
                        ret = 0;
 80165ea:	2300      	movs	r3, #0
 80165ec:	637b      	str	r3, [r7, #52]	@ 0x34
                    else {
                        WOLFSSL_MSG("ECC Verify didn't match");
                        ret = ASN_SIG_CONFIRM_E;
                        WOLFSSL_ERROR_VERBOSE(ret);
                    }
                    break;
 80165ee:	e006      	b.n	80165fe <ConfirmSignature+0x452>
                        ret = ASN_SIG_CONFIRM_E;
 80165f0:	f06f 039a 	mvn.w	r3, #154	@ 0x9a
 80165f4:	637b      	str	r3, [r7, #52]	@ 0x34
                    break;
 80165f6:	e002      	b.n	80165fe <ConfirmSignature+0x452>
                    }
                    break;
                }
            #endif /* HAVE_SPHINCS */
                default:
                    break;
 80165f8:	bf00      	nop
 80165fa:	e010      	b.n	801661e <ConfirmSignature+0x472>
                    break;
 80165fc:	bf00      	nop
            }  /* switch (keyOID) */

            break;
 80165fe:	e00e      	b.n	801661e <ConfirmSignature+0x472>
        } /* SIG_STATE_CHECK */

        default:
            break;
 8016600:	bf00      	nop
 8016602:	e00c      	b.n	801661e <ConfirmSignature+0x472>
                    goto exit_cs;
 8016604:	bf00      	nop
 8016606:	e00a      	b.n	801661e <ConfirmSignature+0x472>
                    goto exit_cs;
 8016608:	bf00      	nop
 801660a:	e008      	b.n	801661e <ConfirmSignature+0x472>
                    goto exit_cs;
 801660c:	bf00      	nop
 801660e:	e006      	b.n	801661e <ConfirmSignature+0x472>
                        goto exit_cs;
 8016610:	bf00      	nop
 8016612:	e004      	b.n	801661e <ConfirmSignature+0x472>
                        goto exit_cs;
 8016614:	bf00      	nop
 8016616:	e002      	b.n	801661e <ConfirmSignature+0x472>
                        goto exit_cs;
 8016618:	bf00      	nop
 801661a:	e000      	b.n	801661e <ConfirmSignature+0x472>
                goto exit_cs;
 801661c:	bf00      	nop
#ifdef WOLFSSL_ASYNC_CRYPT
    if (ret == WC_NO_ERR_TRACE(WC_PENDING_E))
        return ret;
#endif

    FreeSignatureCtx(sigCtx);
 801661e:	6978      	ldr	r0, [r7, #20]
 8016620:	f7ff fd2a 	bl	8016078 <FreeSignatureCtx>

    return ret;
 8016624:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
 8016626:	4618      	mov	r0, r3
 8016628:	3738      	adds	r7, #56	@ 0x38
 801662a:	46bd      	mov	sp, r7
 801662c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08016630 <MatchBaseName>:

#ifndef IGNORE_NAME_CONSTRAINTS

static int MatchBaseName(int type, const char* name, int nameSz,
                         const char* base, int baseSz)
{
 8016630:	b580      	push	{r7, lr}
 8016632:	b088      	sub	sp, #32
 8016634:	af00      	add	r7, sp, #0
 8016636:	60f8      	str	r0, [r7, #12]
 8016638:	60b9      	str	r1, [r7, #8]
 801663a:	607a      	str	r2, [r7, #4]
 801663c:	603b      	str	r3, [r7, #0]
    if (base == NULL || baseSz <= 0 || name == NULL || nameSz <= 0 ||
 801663e:	683b      	ldr	r3, [r7, #0]
 8016640:	2b00      	cmp	r3, #0
 8016642:	d019      	beq.n	8016678 <MatchBaseName+0x48>
 8016644:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8016646:	2b00      	cmp	r3, #0
 8016648:	dd16      	ble.n	8016678 <MatchBaseName+0x48>
 801664a:	68bb      	ldr	r3, [r7, #8]
 801664c:	2b00      	cmp	r3, #0
 801664e:	d013      	beq.n	8016678 <MatchBaseName+0x48>
 8016650:	687b      	ldr	r3, [r7, #4]
 8016652:	2b00      	cmp	r3, #0
 8016654:	dd10      	ble.n	8016678 <MatchBaseName+0x48>
            name[0] == '.' || nameSz < baseSz ||
 8016656:	68bb      	ldr	r3, [r7, #8]
 8016658:	781b      	ldrb	r3, [r3, #0]
    if (base == NULL || baseSz <= 0 || name == NULL || nameSz <= 0 ||
 801665a:	2b2e      	cmp	r3, #46	@ 0x2e
 801665c:	d00c      	beq.n	8016678 <MatchBaseName+0x48>
            name[0] == '.' || nameSz < baseSz ||
 801665e:	687a      	ldr	r2, [r7, #4]
 8016660:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8016662:	429a      	cmp	r2, r3
 8016664:	db08      	blt.n	8016678 <MatchBaseName+0x48>
 8016666:	68fb      	ldr	r3, [r7, #12]
 8016668:	2b01      	cmp	r3, #1
 801666a:	d007      	beq.n	801667c <MatchBaseName+0x4c>
            (type != ASN_RFC822_TYPE && type != ASN_DNS_TYPE &&
 801666c:	68fb      	ldr	r3, [r7, #12]
 801666e:	2b02      	cmp	r3, #2
 8016670:	d004      	beq.n	801667c <MatchBaseName+0x4c>
 8016672:	68fb      	ldr	r3, [r7, #12]
 8016674:	2b04      	cmp	r3, #4
 8016676:	d001      	beq.n	801667c <MatchBaseName+0x4c>
             type != ASN_DIR_TYPE)) {
        return 0;
 8016678:	2300      	movs	r3, #0
 801667a:	e0a2      	b.n	80167c2 <MatchBaseName+0x192>
    }

    if (type == ASN_DIR_TYPE)
 801667c:	68fb      	ldr	r3, [r7, #12]
 801667e:	2b04      	cmp	r3, #4
 8016680:	d10c      	bne.n	801669c <MatchBaseName+0x6c>
        return XMEMCMP(name, base, (size_t)baseSz) == 0;
 8016682:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8016684:	461a      	mov	r2, r3
 8016686:	6839      	ldr	r1, [r7, #0]
 8016688:	68b8      	ldr	r0, [r7, #8]
 801668a:	f011 fef3 	bl	8028474 <memcmp>
 801668e:	4603      	mov	r3, r0
 8016690:	2b00      	cmp	r3, #0
 8016692:	bf0c      	ite	eq
 8016694:	2301      	moveq	r3, #1
 8016696:	2300      	movne	r3, #0
 8016698:	b2db      	uxtb	r3, r3
 801669a:	e092      	b.n	80167c2 <MatchBaseName+0x192>

    /* If an email type, handle special cases where the base is only
     * a domain, or is an email address itself. */
    if (type == ASN_RFC822_TYPE) {
 801669c:	68fb      	ldr	r3, [r7, #12]
 801669e:	2b01      	cmp	r3, #1
 80166a0:	d146      	bne.n	8016730 <MatchBaseName+0x100>
        const char* p = NULL;
 80166a2:	2300      	movs	r3, #0
 80166a4:	61fb      	str	r3, [r7, #28]
        int count = 0;
 80166a6:	2300      	movs	r3, #0
 80166a8:	61bb      	str	r3, [r7, #24]

        if (base[0] != '.') {
 80166aa:	683b      	ldr	r3, [r7, #0]
 80166ac:	781b      	ldrb	r3, [r3, #0]
 80166ae:	2b2e      	cmp	r3, #46	@ 0x2e
 80166b0:	d018      	beq.n	80166e4 <MatchBaseName+0xb4>
            p = base;
 80166b2:	683b      	ldr	r3, [r7, #0]
 80166b4:	61fb      	str	r3, [r7, #28]
            count = 0;
 80166b6:	2300      	movs	r3, #0
 80166b8:	61bb      	str	r3, [r7, #24]

            /* find the '@' in the base */
            while (*p != '@' && count < baseSz) {
 80166ba:	e005      	b.n	80166c8 <MatchBaseName+0x98>
                count++;
 80166bc:	69bb      	ldr	r3, [r7, #24]
 80166be:	3301      	adds	r3, #1
 80166c0:	61bb      	str	r3, [r7, #24]
                p++;
 80166c2:	69fb      	ldr	r3, [r7, #28]
 80166c4:	3301      	adds	r3, #1
 80166c6:	61fb      	str	r3, [r7, #28]
            while (*p != '@' && count < baseSz) {
 80166c8:	69fb      	ldr	r3, [r7, #28]
 80166ca:	781b      	ldrb	r3, [r3, #0]
 80166cc:	2b40      	cmp	r3, #64	@ 0x40
 80166ce:	d003      	beq.n	80166d8 <MatchBaseName+0xa8>
 80166d0:	69ba      	ldr	r2, [r7, #24]
 80166d2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80166d4:	429a      	cmp	r2, r3
 80166d6:	dbf1      	blt.n	80166bc <MatchBaseName+0x8c>
            }

            /* No '@' in base, reset p to NULL */
            if (count >= baseSz)
 80166d8:	69ba      	ldr	r2, [r7, #24]
 80166da:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80166dc:	429a      	cmp	r2, r3
 80166de:	db01      	blt.n	80166e4 <MatchBaseName+0xb4>
                p = NULL;
 80166e0:	2300      	movs	r3, #0
 80166e2:	61fb      	str	r3, [r7, #28]
        }

        if (p == NULL) {
 80166e4:	69fb      	ldr	r3, [r7, #28]
 80166e6:	2b00      	cmp	r3, #0
 80166e8:	d122      	bne.n	8016730 <MatchBaseName+0x100>
            /* Base isn't an email address, it is a domain name,
             * wind the name forward one character past its '@'. */
            p = name;
 80166ea:	68bb      	ldr	r3, [r7, #8]
 80166ec:	61fb      	str	r3, [r7, #28]
            count = 0;
 80166ee:	2300      	movs	r3, #0
 80166f0:	61bb      	str	r3, [r7, #24]
            while (*p != '@' && count < baseSz) {
 80166f2:	e005      	b.n	8016700 <MatchBaseName+0xd0>
                count++;
 80166f4:	69bb      	ldr	r3, [r7, #24]
 80166f6:	3301      	adds	r3, #1
 80166f8:	61bb      	str	r3, [r7, #24]
                p++;
 80166fa:	69fb      	ldr	r3, [r7, #28]
 80166fc:	3301      	adds	r3, #1
 80166fe:	61fb      	str	r3, [r7, #28]
            while (*p != '@' && count < baseSz) {
 8016700:	69fb      	ldr	r3, [r7, #28]
 8016702:	781b      	ldrb	r3, [r3, #0]
 8016704:	2b40      	cmp	r3, #64	@ 0x40
 8016706:	d003      	beq.n	8016710 <MatchBaseName+0xe0>
 8016708:	69ba      	ldr	r2, [r7, #24]
 801670a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801670c:	429a      	cmp	r2, r3
 801670e:	dbf1      	blt.n	80166f4 <MatchBaseName+0xc4>
            }

            if (count < baseSz && *p == '@') {
 8016710:	69ba      	ldr	r2, [r7, #24]
 8016712:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8016714:	429a      	cmp	r2, r3
 8016716:	da0b      	bge.n	8016730 <MatchBaseName+0x100>
 8016718:	69fb      	ldr	r3, [r7, #28]
 801671a:	781b      	ldrb	r3, [r3, #0]
 801671c:	2b40      	cmp	r3, #64	@ 0x40
 801671e:	d107      	bne.n	8016730 <MatchBaseName+0x100>
                name = p + 1;
 8016720:	69fb      	ldr	r3, [r7, #28]
 8016722:	3301      	adds	r3, #1
 8016724:	60bb      	str	r3, [r7, #8]
                nameSz -= count + 1;
 8016726:	69bb      	ldr	r3, [r7, #24]
 8016728:	3301      	adds	r3, #1
 801672a:	687a      	ldr	r2, [r7, #4]
 801672c:	1ad3      	subs	r3, r2, r3
 801672e:	607b      	str	r3, [r7, #4]
    /* RFC 5280 section 4.2.1.10
     * "...Any DNS name that can be constructed by simply adding zero or more
     *  labels to the left-hand side of the name satisfies the name constraint."
     * i.e www.host.example.com works for host.example.com name constraint and
     * host1.example.com does not. */
    if (type == ASN_DNS_TYPE || (type == ASN_RFC822_TYPE && base[0] == '.')) {
 8016730:	68fb      	ldr	r3, [r7, #12]
 8016732:	2b02      	cmp	r3, #2
 8016734:	d006      	beq.n	8016744 <MatchBaseName+0x114>
 8016736:	68fb      	ldr	r3, [r7, #12]
 8016738:	2b01      	cmp	r3, #1
 801673a:	d13e      	bne.n	80167ba <MatchBaseName+0x18a>
 801673c:	683b      	ldr	r3, [r7, #0]
 801673e:	781b      	ldrb	r3, [r3, #0]
 8016740:	2b2e      	cmp	r3, #46	@ 0x2e
 8016742:	d13a      	bne.n	80167ba <MatchBaseName+0x18a>
        int szAdjust = nameSz - baseSz;
 8016744:	687a      	ldr	r2, [r7, #4]
 8016746:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8016748:	1ad3      	subs	r3, r2, r3
 801674a:	617b      	str	r3, [r7, #20]
        name += szAdjust;
 801674c:	697b      	ldr	r3, [r7, #20]
 801674e:	68ba      	ldr	r2, [r7, #8]
 8016750:	4413      	add	r3, r2
 8016752:	60bb      	str	r3, [r7, #8]
        nameSz -= szAdjust;
 8016754:	687a      	ldr	r2, [r7, #4]
 8016756:	697b      	ldr	r3, [r7, #20]
 8016758:	1ad3      	subs	r3, r2, r3
 801675a:	607b      	str	r3, [r7, #4]
    }

    while (nameSz > 0) {
 801675c:	e02d      	b.n	80167ba <MatchBaseName+0x18a>
        if (XTOLOWER((unsigned char)*name) !=
 801675e:	68bb      	ldr	r3, [r7, #8]
 8016760:	781b      	ldrb	r3, [r3, #0]
 8016762:	74fb      	strb	r3, [r7, #19]
 8016764:	7cfb      	ldrb	r3, [r7, #19]
 8016766:	3301      	adds	r3, #1
 8016768:	4a18      	ldr	r2, [pc, #96]	@ (80167cc <MatchBaseName+0x19c>)
 801676a:	4413      	add	r3, r2
 801676c:	781b      	ldrb	r3, [r3, #0]
 801676e:	f003 0303 	and.w	r3, r3, #3
 8016772:	2b01      	cmp	r3, #1
 8016774:	d103      	bne.n	801677e <MatchBaseName+0x14e>
 8016776:	7cfb      	ldrb	r3, [r7, #19]
 8016778:	f103 0220 	add.w	r2, r3, #32
 801677c:	e000      	b.n	8016780 <MatchBaseName+0x150>
 801677e:	7cfa      	ldrb	r2, [r7, #19]
                                               XTOLOWER((unsigned char)*base))
 8016780:	683b      	ldr	r3, [r7, #0]
 8016782:	781b      	ldrb	r3, [r3, #0]
 8016784:	74bb      	strb	r3, [r7, #18]
 8016786:	7cbb      	ldrb	r3, [r7, #18]
 8016788:	3301      	adds	r3, #1
 801678a:	4910      	ldr	r1, [pc, #64]	@ (80167cc <MatchBaseName+0x19c>)
 801678c:	440b      	add	r3, r1
 801678e:	781b      	ldrb	r3, [r3, #0]
 8016790:	f003 0303 	and.w	r3, r3, #3
 8016794:	2b01      	cmp	r3, #1
 8016796:	d102      	bne.n	801679e <MatchBaseName+0x16e>
 8016798:	7cbb      	ldrb	r3, [r7, #18]
 801679a:	3320      	adds	r3, #32
 801679c:	e000      	b.n	80167a0 <MatchBaseName+0x170>
 801679e:	7cbb      	ldrb	r3, [r7, #18]
        if (XTOLOWER((unsigned char)*name) !=
 80167a0:	429a      	cmp	r2, r3
 80167a2:	d001      	beq.n	80167a8 <MatchBaseName+0x178>
            return 0;
 80167a4:	2300      	movs	r3, #0
 80167a6:	e00c      	b.n	80167c2 <MatchBaseName+0x192>
        name++;
 80167a8:	68bb      	ldr	r3, [r7, #8]
 80167aa:	3301      	adds	r3, #1
 80167ac:	60bb      	str	r3, [r7, #8]
        base++;
 80167ae:	683b      	ldr	r3, [r7, #0]
 80167b0:	3301      	adds	r3, #1
 80167b2:	603b      	str	r3, [r7, #0]
        nameSz--;
 80167b4:	687b      	ldr	r3, [r7, #4]
 80167b6:	3b01      	subs	r3, #1
 80167b8:	607b      	str	r3, [r7, #4]
    while (nameSz > 0) {
 80167ba:	687b      	ldr	r3, [r7, #4]
 80167bc:	2b00      	cmp	r3, #0
 80167be:	dcce      	bgt.n	801675e <MatchBaseName+0x12e>
    }

    return 1;
 80167c0:	2301      	movs	r3, #1
}
 80167c2:	4618      	mov	r0, r3
 80167c4:	3720      	adds	r7, #32
 80167c6:	46bd      	mov	sp, r7
 80167c8:	bd80      	pop	{r7, pc}
 80167ca:	bf00      	nop
 80167cc:	08033e08 	.word	0x08033e08

080167d0 <PermittedListOk>:
 * nameType Type of DNS name to currently searching
 * return 1 if found in list or if not needed
 * return 0 if not found in the list but is needed
 */
static int PermittedListOk(DNS_entry* name, Base_entry* dnsList, byte nameType)
{
 80167d0:	b590      	push	{r4, r7, lr}
 80167d2:	b08b      	sub	sp, #44	@ 0x2c
 80167d4:	af02      	add	r7, sp, #8
 80167d6:	60f8      	str	r0, [r7, #12]
 80167d8:	60b9      	str	r1, [r7, #8]
 80167da:	4613      	mov	r3, r2
 80167dc:	71fb      	strb	r3, [r7, #7]
    Base_entry* current = dnsList;
 80167de:	68bb      	ldr	r3, [r7, #8]
 80167e0:	61fb      	str	r3, [r7, #28]
    int match = 0;
 80167e2:	2300      	movs	r3, #0
 80167e4:	61bb      	str	r3, [r7, #24]
    int need  = 0;
 80167e6:	2300      	movs	r3, #0
 80167e8:	617b      	str	r3, [r7, #20]
    int ret   = 1; /* is ok unless needed and no match found */
 80167ea:	2301      	movs	r3, #1
 80167ec:	613b      	str	r3, [r7, #16]

    while (current != NULL) {
 80167ee:	e022      	b.n	8016836 <PermittedListOk+0x66>
        if (current->type == nameType) {
 80167f0:	69fb      	ldr	r3, [r7, #28]
 80167f2:	7b1b      	ldrb	r3, [r3, #12]
 80167f4:	79fa      	ldrb	r2, [r7, #7]
 80167f6:	429a      	cmp	r2, r3
 80167f8:	d11a      	bne.n	8016830 <PermittedListOk+0x60>
            need = 1; /* restriction on permitted names is set for this type */
 80167fa:	2301      	movs	r3, #1
 80167fc:	617b      	str	r3, [r7, #20]
            if (name->len >= current->nameSz &&
 80167fe:	68fb      	ldr	r3, [r7, #12]
 8016800:	689a      	ldr	r2, [r3, #8]
 8016802:	69fb      	ldr	r3, [r7, #28]
 8016804:	689b      	ldr	r3, [r3, #8]
 8016806:	429a      	cmp	r2, r3
 8016808:	db12      	blt.n	8016830 <PermittedListOk+0x60>
                MatchBaseName(nameType, name->name, name->len,
 801680a:	79f8      	ldrb	r0, [r7, #7]
 801680c:	68fb      	ldr	r3, [r7, #12]
 801680e:	68d9      	ldr	r1, [r3, #12]
 8016810:	68fb      	ldr	r3, [r7, #12]
 8016812:	689a      	ldr	r2, [r3, #8]
                              current->name, current->nameSz)) {
 8016814:	69fb      	ldr	r3, [r7, #28]
 8016816:	685c      	ldr	r4, [r3, #4]
                MatchBaseName(nameType, name->name, name->len,
 8016818:	69fb      	ldr	r3, [r7, #28]
 801681a:	689b      	ldr	r3, [r3, #8]
 801681c:	9300      	str	r3, [sp, #0]
 801681e:	4623      	mov	r3, r4
 8016820:	f7ff ff06 	bl	8016630 <MatchBaseName>
 8016824:	4603      	mov	r3, r0
            if (name->len >= current->nameSz &&
 8016826:	2b00      	cmp	r3, #0
 8016828:	d002      	beq.n	8016830 <PermittedListOk+0x60>
                match = 1; /* found the current name in the permitted list*/
 801682a:	2301      	movs	r3, #1
 801682c:	61bb      	str	r3, [r7, #24]
                break;
 801682e:	e005      	b.n	801683c <PermittedListOk+0x6c>
            }
        }
        current = current->next;
 8016830:	69fb      	ldr	r3, [r7, #28]
 8016832:	681b      	ldr	r3, [r3, #0]
 8016834:	61fb      	str	r3, [r7, #28]
    while (current != NULL) {
 8016836:	69fb      	ldr	r3, [r7, #28]
 8016838:	2b00      	cmp	r3, #0
 801683a:	d1d9      	bne.n	80167f0 <PermittedListOk+0x20>
    }

    /* check if permitted name restriction was set and no matching name found */
    if (need && !match)
 801683c:	697b      	ldr	r3, [r7, #20]
 801683e:	2b00      	cmp	r3, #0
 8016840:	d004      	beq.n	801684c <PermittedListOk+0x7c>
 8016842:	69bb      	ldr	r3, [r7, #24]
 8016844:	2b00      	cmp	r3, #0
 8016846:	d101      	bne.n	801684c <PermittedListOk+0x7c>
        ret = 0;
 8016848:	2300      	movs	r3, #0
 801684a:	613b      	str	r3, [r7, #16]

    return ret;
 801684c:	693b      	ldr	r3, [r7, #16]
}
 801684e:	4618      	mov	r0, r3
 8016850:	3724      	adds	r7, #36	@ 0x24
 8016852:	46bd      	mov	sp, r7
 8016854:	bd90      	pop	{r4, r7, pc}

08016856 <IsInExcludedList>:
 * dnsList  The list to search through
 * nameType Type of DNS name to currently searching
 * return 1 if found in list and 0 if not found in the list
 */
static int IsInExcludedList(DNS_entry* name, Base_entry* dnsList, byte nameType)
{
 8016856:	b590      	push	{r4, r7, lr}
 8016858:	b089      	sub	sp, #36	@ 0x24
 801685a:	af02      	add	r7, sp, #8
 801685c:	60f8      	str	r0, [r7, #12]
 801685e:	60b9      	str	r1, [r7, #8]
 8016860:	4613      	mov	r3, r2
 8016862:	71fb      	strb	r3, [r7, #7]
    int ret = 0; /* default of not found in the list */
 8016864:	2300      	movs	r3, #0
 8016866:	617b      	str	r3, [r7, #20]
    Base_entry* current = dnsList;
 8016868:	68bb      	ldr	r3, [r7, #8]
 801686a:	613b      	str	r3, [r7, #16]

    while (current != NULL) {
 801686c:	e020      	b.n	80168b0 <IsInExcludedList+0x5a>
        if (current->type == nameType) {
 801686e:	693b      	ldr	r3, [r7, #16]
 8016870:	7b1b      	ldrb	r3, [r3, #12]
 8016872:	79fa      	ldrb	r2, [r7, #7]
 8016874:	429a      	cmp	r2, r3
 8016876:	d118      	bne.n	80168aa <IsInExcludedList+0x54>
            if (name->len >= current->nameSz &&
 8016878:	68fb      	ldr	r3, [r7, #12]
 801687a:	689a      	ldr	r2, [r3, #8]
 801687c:	693b      	ldr	r3, [r7, #16]
 801687e:	689b      	ldr	r3, [r3, #8]
 8016880:	429a      	cmp	r2, r3
 8016882:	db12      	blt.n	80168aa <IsInExcludedList+0x54>
                MatchBaseName(nameType, name->name, name->len,
 8016884:	79f8      	ldrb	r0, [r7, #7]
 8016886:	68fb      	ldr	r3, [r7, #12]
 8016888:	68d9      	ldr	r1, [r3, #12]
 801688a:	68fb      	ldr	r3, [r7, #12]
 801688c:	689a      	ldr	r2, [r3, #8]
                              current->name, current->nameSz)) {
 801688e:	693b      	ldr	r3, [r7, #16]
 8016890:	685c      	ldr	r4, [r3, #4]
                MatchBaseName(nameType, name->name, name->len,
 8016892:	693b      	ldr	r3, [r7, #16]
 8016894:	689b      	ldr	r3, [r3, #8]
 8016896:	9300      	str	r3, [sp, #0]
 8016898:	4623      	mov	r3, r4
 801689a:	f7ff fec9 	bl	8016630 <MatchBaseName>
 801689e:	4603      	mov	r3, r0
            if (name->len >= current->nameSz &&
 80168a0:	2b00      	cmp	r3, #0
 80168a2:	d002      	beq.n	80168aa <IsInExcludedList+0x54>
                ret = 1;
 80168a4:	2301      	movs	r3, #1
 80168a6:	617b      	str	r3, [r7, #20]
                break;
 80168a8:	e005      	b.n	80168b6 <IsInExcludedList+0x60>
            }
        }
        current = current->next;
 80168aa:	693b      	ldr	r3, [r7, #16]
 80168ac:	681b      	ldr	r3, [r3, #0]
 80168ae:	613b      	str	r3, [r7, #16]
    while (current != NULL) {
 80168b0:	693b      	ldr	r3, [r7, #16]
 80168b2:	2b00      	cmp	r3, #0
 80168b4:	d1db      	bne.n	801686e <IsInExcludedList+0x18>
    }

    return ret;
 80168b6:	697b      	ldr	r3, [r7, #20]
}
 80168b8:	4618      	mov	r0, r3
 80168ba:	371c      	adds	r7, #28
 80168bc:	46bd      	mov	sp, r7
 80168be:	bd90      	pop	{r4, r7, pc}

080168c0 <ConfirmNameConstraints>:


static int ConfirmNameConstraints(Signer* signer, DecodedCert* cert)
{
 80168c0:	b580      	push	{r7, lr}
 80168c2:	b08a      	sub	sp, #40	@ 0x28
 80168c4:	af00      	add	r7, sp, #0
 80168c6:	6078      	str	r0, [r7, #4]
 80168c8:	6039      	str	r1, [r7, #0]
    const byte nameTypes[] = {ASN_RFC822_TYPE, ASN_DNS_TYPE, ASN_DIR_TYPE};
 80168ca:	4a5a      	ldr	r2, [pc, #360]	@ (8016a34 <ConfirmNameConstraints+0x174>)
 80168cc:	f107 031c 	add.w	r3, r7, #28
 80168d0:	6812      	ldr	r2, [r2, #0]
 80168d2:	4611      	mov	r1, r2
 80168d4:	8019      	strh	r1, [r3, #0]
 80168d6:	3302      	adds	r3, #2
 80168d8:	0c12      	lsrs	r2, r2, #16
 80168da:	701a      	strb	r2, [r3, #0]
    int i;

    if (signer == NULL || cert == NULL)
 80168dc:	687b      	ldr	r3, [r7, #4]
 80168de:	2b00      	cmp	r3, #0
 80168e0:	d002      	beq.n	80168e8 <ConfirmNameConstraints+0x28>
 80168e2:	683b      	ldr	r3, [r7, #0]
 80168e4:	2b00      	cmp	r3, #0
 80168e6:	d101      	bne.n	80168ec <ConfirmNameConstraints+0x2c>
        return 0;
 80168e8:	2300      	movs	r3, #0
 80168ea:	e09e      	b.n	8016a2a <ConfirmNameConstraints+0x16a>

    if (signer->excludedNames == NULL && signer->permittedNames == NULL)
 80168ec:	687b      	ldr	r3, [r7, #4]
 80168ee:	69db      	ldr	r3, [r3, #28]
 80168f0:	2b00      	cmp	r3, #0
 80168f2:	d105      	bne.n	8016900 <ConfirmNameConstraints+0x40>
 80168f4:	687b      	ldr	r3, [r7, #4]
 80168f6:	699b      	ldr	r3, [r3, #24]
 80168f8:	2b00      	cmp	r3, #0
 80168fa:	d101      	bne.n	8016900 <ConfirmNameConstraints+0x40>
        return 1;
 80168fc:	2301      	movs	r3, #1
 80168fe:	e094      	b.n	8016a2a <ConfirmNameConstraints+0x16a>

    for (i=0; i < (int)sizeof(nameTypes); i++) {
 8016900:	2300      	movs	r3, #0
 8016902:	627b      	str	r3, [r7, #36]	@ 0x24
 8016904:	e08c      	b.n	8016a20 <ConfirmNameConstraints+0x160>
        byte nameType = nameTypes[i];
 8016906:	f107 021c 	add.w	r2, r7, #28
 801690a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801690c:	4413      	add	r3, r2
 801690e:	781b      	ldrb	r3, [r3, #0]
 8016910:	77fb      	strb	r3, [r7, #31]
        DNS_entry* name = NULL;
 8016912:	2300      	movs	r3, #0
 8016914:	623b      	str	r3, [r7, #32]
        DNS_entry  subjectDnsName; /* temporary node used for subject name */

        XMEMSET(&subjectDnsName, 0, sizeof(DNS_entry));
 8016916:	f107 030c 	add.w	r3, r7, #12
 801691a:	2210      	movs	r2, #16
 801691c:	2100      	movs	r1, #0
 801691e:	4618      	mov	r0, r3
 8016920:	f011 fdd2 	bl	80284c8 <memset>
        switch (nameType) {
 8016924:	7ffb      	ldrb	r3, [r7, #31]
 8016926:	2b04      	cmp	r3, #4
 8016928:	d01e      	beq.n	8016968 <ConfirmNameConstraints+0xa8>
 801692a:	2b04      	cmp	r3, #4
 801692c:	dc31      	bgt.n	8016992 <ConfirmNameConstraints+0xd2>
 801692e:	2b01      	cmp	r3, #1
 8016930:	d005      	beq.n	801693e <ConfirmNameConstraints+0x7e>
 8016932:	2b02      	cmp	r3, #2
 8016934:	d12d      	bne.n	8016992 <ConfirmNameConstraints+0xd2>
            case ASN_DNS_TYPE:
                /* Should it also consider CN in subject? It could use
                 * subjectDnsName too */
                name = cert->altNames;
 8016936:	683b      	ldr	r3, [r7, #0]
 8016938:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801693a:	623b      	str	r3, [r7, #32]
                break;
 801693c:	e02e      	b.n	801699c <ConfirmNameConstraints+0xdc>
            case ASN_RFC822_TYPE:
                /* Shouldn't it validate E= in subject as well? */
                name = cert->altEmailNames;
 801693e:	683b      	ldr	r3, [r7, #0]
 8016940:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8016942:	623b      	str	r3, [r7, #32]

                /* Add subject email for checking. */
                if (cert->subjectEmail != NULL) {
 8016944:	683b      	ldr	r3, [r7, #0]
 8016946:	f8d3 345c 	ldr.w	r3, [r3, #1116]	@ 0x45c
 801694a:	2b00      	cmp	r3, #0
 801694c:	d023      	beq.n	8016996 <ConfirmNameConstraints+0xd6>
                     * "When constraints are imposed on the rfc822Name name
                     * form, but the certificate does not include a subject
                     * alternative name, the rfc822Name constraint MUST be
                     * applied to the attribute of type emailAddress in the
                     * subject distinguished name" */
                    subjectDnsName.next = NULL;
 801694e:	2300      	movs	r3, #0
 8016950:	60fb      	str	r3, [r7, #12]
                    subjectDnsName.type = ASN_RFC822_TYPE;
 8016952:	2301      	movs	r3, #1
 8016954:	613b      	str	r3, [r7, #16]
                    subjectDnsName.len  = cert->subjectEmailLen;
 8016956:	683b      	ldr	r3, [r7, #0]
 8016958:	f8d3 3460 	ldr.w	r3, [r3, #1120]	@ 0x460
 801695c:	617b      	str	r3, [r7, #20]
                    subjectDnsName.name = (char *)cert->subjectEmail;
 801695e:	683b      	ldr	r3, [r7, #0]
 8016960:	f8d3 345c 	ldr.w	r3, [r3, #1116]	@ 0x45c
 8016964:	61bb      	str	r3, [r7, #24]
                }
                break;
 8016966:	e016      	b.n	8016996 <ConfirmNameConstraints+0xd6>
            case ASN_DIR_TYPE:
            #ifndef WOLFSSL_NO_ASN_STRICT
                name = cert->altDirNames;
 8016968:	683b      	ldr	r3, [r7, #0]
 801696a:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 801696c:	623b      	str	r3, [r7, #32]
                    "Restrictions of the form directoryName MUST be
                    applied to the subject field .... and to any names
                    of type directoryName in the subjectAltName
                    extension"
                */
                if (cert->subjectRaw != NULL) {
 801696e:	683b      	ldr	r3, [r7, #0]
 8016970:	f8d3 3454 	ldr.w	r3, [r3, #1108]	@ 0x454
 8016974:	2b00      	cmp	r3, #0
 8016976:	d010      	beq.n	801699a <ConfirmNameConstraints+0xda>
                    subjectDnsName.next = NULL;
 8016978:	2300      	movs	r3, #0
 801697a:	60fb      	str	r3, [r7, #12]
                    subjectDnsName.type = ASN_DIR_TYPE;
 801697c:	2304      	movs	r3, #4
 801697e:	613b      	str	r3, [r7, #16]
                    subjectDnsName.len = cert->subjectRawLen;
 8016980:	683b      	ldr	r3, [r7, #0]
 8016982:	f8d3 3458 	ldr.w	r3, [r3, #1112]	@ 0x458
 8016986:	617b      	str	r3, [r7, #20]
                    subjectDnsName.name = (char *)cert->subjectRaw;
 8016988:	683b      	ldr	r3, [r7, #0]
 801698a:	f8d3 3454 	ldr.w	r3, [r3, #1108]	@ 0x454
 801698e:	61bb      	str	r3, [r7, #24]
                }
                break;
 8016990:	e003      	b.n	801699a <ConfirmNameConstraints+0xda>
            default:
                /* Other types of names are ignored for now.
                 * Shouldn't it be rejected if it there is a altNamesByType[nameType]
                 * and signer->extNameConstraintCrit is set? */
                return 0;
 8016992:	2300      	movs	r3, #0
 8016994:	e049      	b.n	8016a2a <ConfirmNameConstraints+0x16a>
                break;
 8016996:	bf00      	nop
 8016998:	e01c      	b.n	80169d4 <ConfirmNameConstraints+0x114>
                break;
 801699a:	bf00      	nop
        }

        while (name != NULL) {
 801699c:	e01a      	b.n	80169d4 <ConfirmNameConstraints+0x114>
            if (IsInExcludedList(name, signer->excludedNames, nameType) == 1) {
 801699e:	687b      	ldr	r3, [r7, #4]
 80169a0:	69db      	ldr	r3, [r3, #28]
 80169a2:	7ffa      	ldrb	r2, [r7, #31]
 80169a4:	4619      	mov	r1, r3
 80169a6:	6a38      	ldr	r0, [r7, #32]
 80169a8:	f7ff ff55 	bl	8016856 <IsInExcludedList>
 80169ac:	4603      	mov	r3, r0
 80169ae:	2b01      	cmp	r3, #1
 80169b0:	d101      	bne.n	80169b6 <ConfirmNameConstraints+0xf6>
                WOLFSSL_MSG("Excluded name was found!");
                return 0;
 80169b2:	2300      	movs	r3, #0
 80169b4:	e039      	b.n	8016a2a <ConfirmNameConstraints+0x16a>
            }

            /* Check against the permitted list */
            if (PermittedListOk(name, signer->permittedNames, nameType) != 1) {
 80169b6:	687b      	ldr	r3, [r7, #4]
 80169b8:	699b      	ldr	r3, [r3, #24]
 80169ba:	7ffa      	ldrb	r2, [r7, #31]
 80169bc:	4619      	mov	r1, r3
 80169be:	6a38      	ldr	r0, [r7, #32]
 80169c0:	f7ff ff06 	bl	80167d0 <PermittedListOk>
 80169c4:	4603      	mov	r3, r0
 80169c6:	2b01      	cmp	r3, #1
 80169c8:	d001      	beq.n	80169ce <ConfirmNameConstraints+0x10e>
                WOLFSSL_MSG("Permitted name was not found!");
                return 0;
 80169ca:	2300      	movs	r3, #0
 80169cc:	e02d      	b.n	8016a2a <ConfirmNameConstraints+0x16a>
            }

            name = name->next;
 80169ce:	6a3b      	ldr	r3, [r7, #32]
 80169d0:	681b      	ldr	r3, [r3, #0]
 80169d2:	623b      	str	r3, [r7, #32]
        while (name != NULL) {
 80169d4:	6a3b      	ldr	r3, [r7, #32]
 80169d6:	2b00      	cmp	r3, #0
 80169d8:	d1e1      	bne.n	801699e <ConfirmNameConstraints+0xde>
        }

        /* handle comparing against subject name too */
        if (subjectDnsName.len > 0 && subjectDnsName.name != NULL) {
 80169da:	697b      	ldr	r3, [r7, #20]
 80169dc:	2b00      	cmp	r3, #0
 80169de:	dd1c      	ble.n	8016a1a <ConfirmNameConstraints+0x15a>
 80169e0:	69bb      	ldr	r3, [r7, #24]
 80169e2:	2b00      	cmp	r3, #0
 80169e4:	d019      	beq.n	8016a1a <ConfirmNameConstraints+0x15a>
            if (IsInExcludedList(&subjectDnsName, signer->excludedNames,
 80169e6:	687b      	ldr	r3, [r7, #4]
 80169e8:	69d9      	ldr	r1, [r3, #28]
 80169ea:	7ffa      	ldrb	r2, [r7, #31]
 80169ec:	f107 030c 	add.w	r3, r7, #12
 80169f0:	4618      	mov	r0, r3
 80169f2:	f7ff ff30 	bl	8016856 <IsInExcludedList>
 80169f6:	4603      	mov	r3, r0
 80169f8:	2b01      	cmp	r3, #1
 80169fa:	d101      	bne.n	8016a00 <ConfirmNameConstraints+0x140>
                        nameType) == 1) {
                WOLFSSL_MSG("Excluded name was found!");
                return 0;
 80169fc:	2300      	movs	r3, #0
 80169fe:	e014      	b.n	8016a2a <ConfirmNameConstraints+0x16a>
            }

            /* Check against the permitted list */
            if (PermittedListOk(&subjectDnsName, signer->permittedNames,
 8016a00:	687b      	ldr	r3, [r7, #4]
 8016a02:	6999      	ldr	r1, [r3, #24]
 8016a04:	7ffa      	ldrb	r2, [r7, #31]
 8016a06:	f107 030c 	add.w	r3, r7, #12
 8016a0a:	4618      	mov	r0, r3
 8016a0c:	f7ff fee0 	bl	80167d0 <PermittedListOk>
 8016a10:	4603      	mov	r3, r0
 8016a12:	2b01      	cmp	r3, #1
 8016a14:	d001      	beq.n	8016a1a <ConfirmNameConstraints+0x15a>
                        nameType) != 1) {
                WOLFSSL_MSG("Permitted name was not found!");
                return 0;
 8016a16:	2300      	movs	r3, #0
 8016a18:	e007      	b.n	8016a2a <ConfirmNameConstraints+0x16a>
    for (i=0; i < (int)sizeof(nameTypes); i++) {
 8016a1a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016a1c:	3301      	adds	r3, #1
 8016a1e:	627b      	str	r3, [r7, #36]	@ 0x24
 8016a20:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016a22:	2b02      	cmp	r3, #2
 8016a24:	f77f af6f 	ble.w	8016906 <ConfirmNameConstraints+0x46>
            }
        }
    }

    return 1;
 8016a28:	2301      	movs	r3, #1
}
 8016a2a:	4618      	mov	r0, r3
 8016a2c:	3728      	adds	r7, #40	@ 0x28
 8016a2e:	46bd      	mov	sp, r7
 8016a30:	bd80      	pop	{r7, pc}
 8016a32:	bf00      	nop
 8016a34:	0802f868 	.word	0x0802f868

08016a38 <DecodeGeneralName>:
 * @return  ASN_UNKNOWN_OID_E when the OID cannot be verified.
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
static int DecodeGeneralName(const byte* input, word32* inOutIdx, byte tag,
                             int len, DecodedCert* cert)
{
 8016a38:	b580      	push	{r7, lr}
 8016a3a:	b08c      	sub	sp, #48	@ 0x30
 8016a3c:	af02      	add	r7, sp, #8
 8016a3e:	60f8      	str	r0, [r7, #12]
 8016a40:	60b9      	str	r1, [r7, #8]
 8016a42:	603b      	str	r3, [r7, #0]
 8016a44:	4613      	mov	r3, r2
 8016a46:	71fb      	strb	r3, [r7, #7]
    int ret = 0;
 8016a48:	2300      	movs	r3, #0
 8016a4a:	627b      	str	r3, [r7, #36]	@ 0x24
    word32 idx = *inOutIdx;
 8016a4c:	68bb      	ldr	r3, [r7, #8]
 8016a4e:	681b      	ldr	r3, [r3, #0]
 8016a50:	623b      	str	r3, [r7, #32]

    /* GeneralName choice: dnsName */
    if (tag == (ASN_CONTEXT_SPECIFIC | ASN_DNS_TYPE)) {
 8016a52:	79fb      	ldrb	r3, [r7, #7]
 8016a54:	2b82      	cmp	r3, #130	@ 0x82
 8016a56:	d116      	bne.n	8016a86 <DecodeGeneralName+0x4e>
        ret = SetDNSEntry(cert->heap, (const char*)(input + idx), len,
 8016a58:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016a5a:	f8d3 0370 	ldr.w	r0, [r3, #880]	@ 0x370
 8016a5e:	68fa      	ldr	r2, [r7, #12]
 8016a60:	6a3b      	ldr	r3, [r7, #32]
 8016a62:	18d1      	adds	r1, r2, r3
 8016a64:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016a66:	332c      	adds	r3, #44	@ 0x2c
 8016a68:	9300      	str	r3, [sp, #0]
 8016a6a:	2302      	movs	r3, #2
 8016a6c:	683a      	ldr	r2, [r7, #0]
 8016a6e:	f7fe feb4 	bl	80157da <SetDNSEntry>
 8016a72:	6278      	str	r0, [r7, #36]	@ 0x24
                ASN_DNS_TYPE, &cert->altNames);
        if (ret == 0) {
 8016a74:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016a76:	2b00      	cmp	r3, #0
 8016a78:	f040 809b 	bne.w	8016bb2 <DecodeGeneralName+0x17a>
            idx += (word32)len;
 8016a7c:	683b      	ldr	r3, [r7, #0]
 8016a7e:	6a3a      	ldr	r2, [r7, #32]
 8016a80:	4413      	add	r3, r2
 8016a82:	623b      	str	r3, [r7, #32]
 8016a84:	e095      	b.n	8016bb2 <DecodeGeneralName+0x17a>
        }
    }
#ifndef IGNORE_NAME_CONSTRAINTS
    /* GeneralName choice: directoryName */
    else if (tag == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | ASN_DIR_TYPE)) {
 8016a86:	79fb      	ldrb	r3, [r7, #7]
 8016a88:	2ba4      	cmp	r3, #164	@ 0xa4
 8016a8a:	d129      	bne.n	8016ae0 <DecodeGeneralName+0xa8>
        int strLen;
        word32 idxDir = idx;
 8016a8c:	6a3b      	ldr	r3, [r7, #32]
 8016a8e:	617b      	str	r3, [r7, #20]

        /* Expecting a SEQUENCE using up all data. */
        if (GetASN_Sequence(input, &idxDir, &strLen, idx + (word32)len, 1) < 0)
 8016a90:	683a      	ldr	r2, [r7, #0]
 8016a92:	6a3b      	ldr	r3, [r7, #32]
 8016a94:	4413      	add	r3, r2
 8016a96:	f107 0218 	add.w	r2, r7, #24
 8016a9a:	f107 0114 	add.w	r1, r7, #20
 8016a9e:	2001      	movs	r0, #1
 8016aa0:	9000      	str	r0, [sp, #0]
 8016aa2:	68f8      	ldr	r0, [r7, #12]
 8016aa4:	f7fd f8d3 	bl	8013c4e <GetASN_Sequence>
 8016aa8:	4603      	mov	r3, r0
 8016aaa:	2b00      	cmp	r3, #0
 8016aac:	da02      	bge.n	8016ab4 <DecodeGeneralName+0x7c>
        {
            WOLFSSL_MSG("\tfail: seq length");
            return ASN_PARSE_E;
 8016aae:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8016ab2:	e085      	b.n	8016bc0 <DecodeGeneralName+0x188>
        }

        ret = SetDNSEntry(cert->heap, (const char*)(input + idxDir), strLen,
 8016ab4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016ab6:	f8d3 0370 	ldr.w	r0, [r3, #880]	@ 0x370
 8016aba:	697b      	ldr	r3, [r7, #20]
 8016abc:	68fa      	ldr	r2, [r7, #12]
 8016abe:	18d1      	adds	r1, r2, r3
 8016ac0:	69ba      	ldr	r2, [r7, #24]
 8016ac2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016ac4:	3334      	adds	r3, #52	@ 0x34
 8016ac6:	9300      	str	r3, [sp, #0]
 8016ac8:	2304      	movs	r3, #4
 8016aca:	f7fe fe86 	bl	80157da <SetDNSEntry>
 8016ace:	6278      	str	r0, [r7, #36]	@ 0x24
                ASN_DIR_TYPE, &cert->altDirNames);
        if (ret == 0) {
 8016ad0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016ad2:	2b00      	cmp	r3, #0
 8016ad4:	d16d      	bne.n	8016bb2 <DecodeGeneralName+0x17a>
            idx += (word32)len;
 8016ad6:	683b      	ldr	r3, [r7, #0]
 8016ad8:	6a3a      	ldr	r2, [r7, #32]
 8016ada:	4413      	add	r3, r2
 8016adc:	623b      	str	r3, [r7, #32]
 8016ade:	e068      	b.n	8016bb2 <DecodeGeneralName+0x17a>
        }
    }
    /* GeneralName choice: rfc822Name */
    else if (tag == (ASN_CONTEXT_SPECIFIC | ASN_RFC822_TYPE)) {
 8016ae0:	79fb      	ldrb	r3, [r7, #7]
 8016ae2:	2b81      	cmp	r3, #129	@ 0x81
 8016ae4:	d115      	bne.n	8016b12 <DecodeGeneralName+0xda>
        ret = SetDNSEntry(cert->heap, (const char*)(input + idx), len,
 8016ae6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016ae8:	f8d3 0370 	ldr.w	r0, [r3, #880]	@ 0x370
 8016aec:	68fa      	ldr	r2, [r7, #12]
 8016aee:	6a3b      	ldr	r3, [r7, #32]
 8016af0:	18d1      	adds	r1, r2, r3
 8016af2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016af4:	3330      	adds	r3, #48	@ 0x30
 8016af6:	9300      	str	r3, [sp, #0]
 8016af8:	2301      	movs	r3, #1
 8016afa:	683a      	ldr	r2, [r7, #0]
 8016afc:	f7fe fe6d 	bl	80157da <SetDNSEntry>
 8016b00:	6278      	str	r0, [r7, #36]	@ 0x24
                ASN_RFC822_TYPE, &cert->altEmailNames);
        if (ret == 0) {
 8016b02:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016b04:	2b00      	cmp	r3, #0
 8016b06:	d154      	bne.n	8016bb2 <DecodeGeneralName+0x17a>
            idx += (word32)len;
 8016b08:	683b      	ldr	r3, [r7, #0]
 8016b0a:	6a3a      	ldr	r2, [r7, #32]
 8016b0c:	4413      	add	r3, r2
 8016b0e:	623b      	str	r3, [r7, #32]
 8016b10:	e04f      	b.n	8016bb2 <DecodeGeneralName+0x17a>
        }
    }
    /* GeneralName choice: uniformResourceIdentifier */
    else if (tag == (ASN_CONTEXT_SPECIFIC | ASN_URI_TYPE)) {
 8016b12:	79fb      	ldrb	r3, [r7, #7]
 8016b14:	2b86      	cmp	r3, #134	@ 0x86
 8016b16:	d148      	bne.n	8016baa <DecodeGeneralName+0x172>
            hier-part, it must come after the ':' (see RFC 3986 Sec 3). */
        {
            int i;

            /* skip past scheme (i.e http,ftp,...) finding first ':' char */
            for (i = 0; i < len; i++) {
 8016b18:	2300      	movs	r3, #0
 8016b1a:	61fb      	str	r3, [r7, #28]
 8016b1c:	e014      	b.n	8016b48 <DecodeGeneralName+0x110>
                if (input[idx + (word32)i] == ':') {
 8016b1e:	69fa      	ldr	r2, [r7, #28]
 8016b20:	6a3b      	ldr	r3, [r7, #32]
 8016b22:	4413      	add	r3, r2
 8016b24:	68fa      	ldr	r2, [r7, #12]
 8016b26:	4413      	add	r3, r2
 8016b28:	781b      	ldrb	r3, [r3, #0]
 8016b2a:	2b3a      	cmp	r3, #58	@ 0x3a
 8016b2c:	d011      	beq.n	8016b52 <DecodeGeneralName+0x11a>
                    break;
                }
                if (input[idx + (word32)i] == '/') {
 8016b2e:	69fa      	ldr	r2, [r7, #28]
 8016b30:	6a3b      	ldr	r3, [r7, #32]
 8016b32:	4413      	add	r3, r2
 8016b34:	68fa      	ldr	r2, [r7, #12]
 8016b36:	4413      	add	r3, r2
 8016b38:	781b      	ldrb	r3, [r3, #0]
 8016b3a:	2b2f      	cmp	r3, #47	@ 0x2f
 8016b3c:	d101      	bne.n	8016b42 <DecodeGeneralName+0x10a>
                    i = len; /* error, found relative path since '/' was
 8016b3e:	683b      	ldr	r3, [r7, #0]
 8016b40:	61fb      	str	r3, [r7, #28]
            for (i = 0; i < len; i++) {
 8016b42:	69fb      	ldr	r3, [r7, #28]
 8016b44:	3301      	adds	r3, #1
 8016b46:	61fb      	str	r3, [r7, #28]
 8016b48:	69fa      	ldr	r2, [r7, #28]
 8016b4a:	683b      	ldr	r3, [r7, #0]
 8016b4c:	429a      	cmp	r2, r3
 8016b4e:	dbe6      	blt.n	8016b1e <DecodeGeneralName+0xe6>
 8016b50:	e000      	b.n	8016b54 <DecodeGeneralName+0x11c>
                    break;
 8016b52:	bf00      	nop
                              * value in next if statement. */
                }
            }

            /* test hier-part is empty */
            if (i == 0 || i == len) {
 8016b54:	69fb      	ldr	r3, [r7, #28]
 8016b56:	2b00      	cmp	r3, #0
 8016b58:	d003      	beq.n	8016b62 <DecodeGeneralName+0x12a>
 8016b5a:	69fa      	ldr	r2, [r7, #28]
 8016b5c:	683b      	ldr	r3, [r7, #0]
 8016b5e:	429a      	cmp	r2, r3
 8016b60:	d102      	bne.n	8016b68 <DecodeGeneralName+0x130>
                WOLFSSL_MSG("\tEmpty or malformed URI");
                WOLFSSL_ERROR_VERBOSE(ASN_ALT_NAME_E);
                return ASN_ALT_NAME_E;
 8016b62:	f06f 03a0 	mvn.w	r3, #160	@ 0xa0
 8016b66:	e02b      	b.n	8016bc0 <DecodeGeneralName+0x188>
            }

            /* test if scheme is missing  */
            if (input[idx + (word32)i] != ':') {
 8016b68:	69fa      	ldr	r2, [r7, #28]
 8016b6a:	6a3b      	ldr	r3, [r7, #32]
 8016b6c:	4413      	add	r3, r2
 8016b6e:	68fa      	ldr	r2, [r7, #12]
 8016b70:	4413      	add	r3, r2
 8016b72:	781b      	ldrb	r3, [r3, #0]
 8016b74:	2b3a      	cmp	r3, #58	@ 0x3a
 8016b76:	d002      	beq.n	8016b7e <DecodeGeneralName+0x146>
                WOLFSSL_MSG("\tAlt Name must be absolute URI");
                WOLFSSL_ERROR_VERBOSE(ASN_ALT_NAME_E);
                return ASN_ALT_NAME_E;
 8016b78:	f06f 03a0 	mvn.w	r3, #160	@ 0xa0
 8016b7c:	e020      	b.n	8016bc0 <DecodeGeneralName+0x188>
            }
        }
    #endif

        ret = SetDNSEntry(cert->heap, (const char*)(input + idx), len,
 8016b7e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016b80:	f8d3 0370 	ldr.w	r0, [r3, #880]	@ 0x370
 8016b84:	68fa      	ldr	r2, [r7, #12]
 8016b86:	6a3b      	ldr	r3, [r7, #32]
 8016b88:	18d1      	adds	r1, r2, r3
 8016b8a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016b8c:	332c      	adds	r3, #44	@ 0x2c
 8016b8e:	9300      	str	r3, [sp, #0]
 8016b90:	2306      	movs	r3, #6
 8016b92:	683a      	ldr	r2, [r7, #0]
 8016b94:	f7fe fe21 	bl	80157da <SetDNSEntry>
 8016b98:	6278      	str	r0, [r7, #36]	@ 0x24
                ASN_URI_TYPE, &cert->altNames);
        if (ret == 0) {
 8016b9a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016b9c:	2b00      	cmp	r3, #0
 8016b9e:	d108      	bne.n	8016bb2 <DecodeGeneralName+0x17a>
            idx += (word32)len;
 8016ba0:	683b      	ldr	r3, [r7, #0]
 8016ba2:	6a3a      	ldr	r2, [r7, #32]
 8016ba4:	4413      	add	r3, r2
 8016ba6:	623b      	str	r3, [r7, #32]
 8016ba8:	e003      	b.n	8016bb2 <DecodeGeneralName+0x17a>
    }
#endif
    /* GeneralName choice: dNSName, x400Address, ediPartyName */
    else {
        WOLFSSL_MSG("\tUnsupported name type, skipping");
        idx += (word32)len;
 8016baa:	683b      	ldr	r3, [r7, #0]
 8016bac:	6a3a      	ldr	r2, [r7, #32]
 8016bae:	4413      	add	r3, r2
 8016bb0:	623b      	str	r3, [r7, #32]
    }

    if (ret == 0) {
 8016bb2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016bb4:	2b00      	cmp	r3, #0
 8016bb6:	d102      	bne.n	8016bbe <DecodeGeneralName+0x186>
        /* Return index of next encoded byte. */
        *inOutIdx = idx;
 8016bb8:	68bb      	ldr	r3, [r7, #8]
 8016bba:	6a3a      	ldr	r2, [r7, #32]
 8016bbc:	601a      	str	r2, [r3, #0]
    }
    return ret;
 8016bbe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 8016bc0:	4618      	mov	r0, r3
 8016bc2:	3728      	adds	r7, #40	@ 0x28
 8016bc4:	46bd      	mov	sp, r7
 8016bc6:	bd80      	pop	{r7, pc}

08016bc8 <DecodeAltNames>:
 * @return  BUFFER_E when data in buffer is too small.
 * @return  ASN_UNKNOWN_OID_E when the OID cannot be verified.
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
static int DecodeAltNames(const byte* input, word32 sz, DecodedCert* cert)
{
 8016bc8:	b580      	push	{r7, lr}
 8016bca:	b094      	sub	sp, #80	@ 0x50
 8016bcc:	af04      	add	r7, sp, #16
 8016bce:	60f8      	str	r0, [r7, #12]
 8016bd0:	60b9      	str	r1, [r7, #8]
 8016bd2:	607a      	str	r2, [r7, #4]
        }
    }

    return 0;
#else
    word32 idx = 0;
 8016bd4:	2300      	movs	r3, #0
 8016bd6:	637b      	str	r3, [r7, #52]	@ 0x34
    int length = 0;
 8016bd8:	2300      	movs	r3, #0
 8016bda:	633b      	str	r3, [r7, #48]	@ 0x30
    int ret = 0;
 8016bdc:	2300      	movs	r3, #0
 8016bde:	63fb      	str	r3, [r7, #60]	@ 0x3c
    word32 numNames = 0;
 8016be0:	2300      	movs	r3, #0
 8016be2:	63bb      	str	r3, [r7, #56]	@ 0x38

    WOLFSSL_ENTER("DecodeAltNames");

    /* Get SEQUENCE and expect all data to be accounted for. */
    if (GetASN_Sequence(input, &idx, &length, sz, 1) != 0) {
 8016be4:	f107 0230 	add.w	r2, r7, #48	@ 0x30
 8016be8:	f107 0134 	add.w	r1, r7, #52	@ 0x34
 8016bec:	2301      	movs	r3, #1
 8016bee:	9300      	str	r3, [sp, #0]
 8016bf0:	68bb      	ldr	r3, [r7, #8]
 8016bf2:	68f8      	ldr	r0, [r7, #12]
 8016bf4:	f7fd f82b 	bl	8013c4e <GetASN_Sequence>
 8016bf8:	4603      	mov	r3, r0
 8016bfa:	2b00      	cmp	r3, #0
 8016bfc:	d002      	beq.n	8016c04 <DecodeAltNames+0x3c>
        WOLFSSL_MSG("\tBad Sequence");
        ret = ASN_PARSE_E;
 8016bfe:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8016c02:	63fb      	str	r3, [r7, #60]	@ 0x3c
    }

    if ((ret == 0) && (length == 0)) {
 8016c04:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8016c06:	2b00      	cmp	r3, #0
 8016c08:	d105      	bne.n	8016c16 <DecodeAltNames+0x4e>
 8016c0a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016c0c:	2b00      	cmp	r3, #0
 8016c0e:	d102      	bne.n	8016c16 <DecodeAltNames+0x4e>
        /* RFC 5280 4.2.1.6.  Subject Alternative Name
           If the subjectAltName extension is present, the sequence MUST
           contain at least one entry. */
        WOLFSSL_ERROR_VERBOSE(ASN_PARSE_E);
        ret = ASN_PARSE_E;
 8016c10:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8016c14:	63fb      	str	r3, [r7, #60]	@ 0x3c
    }
    if (ret == 0) {
 8016c16:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8016c18:	2b00      	cmp	r3, #0
 8016c1a:	d147      	bne.n	8016cac <DecodeAltNames+0xe4>
    #ifdef OPENSSL_ALL
        cert->extSubjAltNameSrc = input;
        cert->extSubjAltNameSz = sz;
    #endif

        cert->weOwnAltNames = 1;
 8016c1c:	687a      	ldr	r2, [r7, #4]
 8016c1e:	f892 34b4 	ldrb.w	r3, [r2, #1204]	@ 0x4b4
 8016c22:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8016c26:	f882 34b4 	strb.w	r3, [r2, #1204]	@ 0x4b4

        if ((word32)length + idx != sz) {
 8016c2a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016c2c:	461a      	mov	r2, r3
 8016c2e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8016c30:	4413      	add	r3, r2
 8016c32:	68ba      	ldr	r2, [r7, #8]
 8016c34:	429a      	cmp	r2, r3
 8016c36:	d039      	beq.n	8016cac <DecodeAltNames+0xe4>
            ret = ASN_PARSE_E;
 8016c38:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8016c3c:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
    }

    while ((ret == 0) && (idx < sz)) {
 8016c3e:	e035      	b.n	8016cac <DecodeAltNames+0xe4>
        ASNGetData dataASN[altNameASN_Length];

        numNames++;
 8016c40:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8016c42:	3301      	adds	r3, #1
 8016c44:	63bb      	str	r3, [r7, #56]	@ 0x38
        if (numNames > WOLFSSL_MAX_ALT_NAMES) {
 8016c46:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8016c48:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8016c4c:	d903      	bls.n	8016c56 <DecodeAltNames+0x8e>
            WOLFSSL_MSG("\tToo many subject alternative names");
            ret = ASN_ALT_NAME_E;
 8016c4e:	f06f 03a0 	mvn.w	r3, #160	@ 0xa0
 8016c52:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8016c54:	e031      	b.n	8016cba <DecodeAltNames+0xf2>
            break;
        }

        /* Clear dynamic data items. */
        XMEMSET(dataASN, 0, sizeof(dataASN));
 8016c56:	f107 0314 	add.w	r3, r7, #20
 8016c5a:	221c      	movs	r2, #28
 8016c5c:	2100      	movs	r1, #0
 8016c5e:	4618      	mov	r0, r3
 8016c60:	f011 fc32 	bl	80284c8 <memset>
        /* Parse GeneralName with the choices supported. */
        GetASN_Choice(&dataASN[ALTNAMEASN_IDX_GN], generalNameChoice);
 8016c64:	230b      	movs	r3, #11
 8016c66:	f887 302c 	strb.w	r3, [r7, #44]	@ 0x2c
 8016c6a:	4b16      	ldr	r3, [pc, #88]	@ (8016cc4 <DecodeAltNames+0xfc>)
 8016c6c:	61fb      	str	r3, [r7, #28]
        /* Decode a GeneralName choice. */
        ret = GetASN_Items(altNameASN, dataASN, altNameASN_Length, 0, input,
 8016c6e:	f107 0114 	add.w	r1, r7, #20
 8016c72:	68bb      	ldr	r3, [r7, #8]
 8016c74:	9302      	str	r3, [sp, #8]
 8016c76:	f107 0334 	add.w	r3, r7, #52	@ 0x34
 8016c7a:	9301      	str	r3, [sp, #4]
 8016c7c:	68fb      	ldr	r3, [r7, #12]
 8016c7e:	9300      	str	r3, [sp, #0]
 8016c80:	2300      	movs	r3, #0
 8016c82:	2201      	movs	r2, #1
 8016c84:	4810      	ldr	r0, [pc, #64]	@ (8016cc8 <DecodeAltNames+0x100>)
 8016c86:	f7fc fd3b 	bl	8013700 <GetASN_Items>
 8016c8a:	63f8      	str	r0, [r7, #60]	@ 0x3c
                           &idx, sz);
        if (ret == 0) {
 8016c8c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8016c8e:	2b00      	cmp	r3, #0
 8016c90:	d10c      	bne.n	8016cac <DecodeAltNames+0xe4>
            ret = DecodeGeneralName(input, &idx, dataASN[ALTNAMEASN_IDX_GN].tag,
 8016c92:	f897 202d 	ldrb.w	r2, [r7, #45]	@ 0x2d
                                  (int)dataASN[ALTNAMEASN_IDX_GN].length, cert);
 8016c96:	69bb      	ldr	r3, [r7, #24]
            ret = DecodeGeneralName(input, &idx, dataASN[ALTNAMEASN_IDX_GN].tag,
 8016c98:	4618      	mov	r0, r3
 8016c9a:	f107 0134 	add.w	r1, r7, #52	@ 0x34
 8016c9e:	687b      	ldr	r3, [r7, #4]
 8016ca0:	9300      	str	r3, [sp, #0]
 8016ca2:	4603      	mov	r3, r0
 8016ca4:	68f8      	ldr	r0, [r7, #12]
 8016ca6:	f7ff fec7 	bl	8016a38 <DecodeGeneralName>
 8016caa:	63f8      	str	r0, [r7, #60]	@ 0x3c
    while ((ret == 0) && (idx < sz)) {
 8016cac:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8016cae:	2b00      	cmp	r3, #0
 8016cb0:	d103      	bne.n	8016cba <DecodeAltNames+0xf2>
 8016cb2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8016cb4:	68ba      	ldr	r2, [r7, #8]
 8016cb6:	429a      	cmp	r2, r3
 8016cb8:	d8c2      	bhi.n	8016c40 <DecodeAltNames+0x78>
        }
    }

    return ret;
 8016cba:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
#endif
}
 8016cbc:	4618      	mov	r0, r3
 8016cbe:	3740      	adds	r7, #64	@ 0x40
 8016cc0:	46bd      	mov	sp, r7
 8016cc2:	bd80      	pop	{r7, pc}
 8016cc4:	08033910 	.word	0x08033910
 8016cc8:	0803391c 	.word	0x0803391c

08016ccc <DecodeBasicCaConstraint>:
 * @return  BUFFER_E when data in buffer is too small.
 * @return  ASN_EXPECT_0_E when the INTEGER has the MSB set or NULL has a
 *          non-zero length.
 */
static int DecodeBasicCaConstraint(const byte* input, int sz, DecodedCert* cert)
{
 8016ccc:	b580      	push	{r7, lr}
 8016cce:	b08e      	sub	sp, #56	@ 0x38
 8016cd0:	af04      	add	r7, sp, #16
 8016cd2:	60f8      	str	r0, [r7, #12]
 8016cd4:	60b9      	str	r1, [r7, #8]
 8016cd6:	607a      	str	r2, [r7, #4]
    cert->pathLength = (byte)ret;
    cert->pathLengthSet = 1;

    return 0;
#else
    DECL_ASNGETDATA(dataASN, basicConsASN_Length);
 8016cd8:	2300      	movs	r3, #0
 8016cda:	627b      	str	r3, [r7, #36]	@ 0x24
    int ret = 0;
 8016cdc:	2300      	movs	r3, #0
 8016cde:	623b      	str	r3, [r7, #32]
    word32 idx = 0;
 8016ce0:	2300      	movs	r3, #0
 8016ce2:	61bb      	str	r3, [r7, #24]
    byte isCA = 0;
 8016ce4:	2300      	movs	r3, #0
 8016ce6:	75fb      	strb	r3, [r7, #23]

    WOLFSSL_ENTER("DecodeBasicCaConstraint");

    CALLOC_ASNGETDATA(dataASN, basicConsASN_Length, ret, cert->heap);
 8016ce8:	6a3b      	ldr	r3, [r7, #32]
 8016cea:	2b00      	cmp	r3, #0
 8016cec:	d109      	bne.n	8016d02 <DecodeBasicCaConstraint+0x36>
 8016cee:	2054      	movs	r0, #84	@ 0x54
 8016cf0:	f007 feca 	bl	801ea88 <wolfSSL_Malloc>
 8016cf4:	6278      	str	r0, [r7, #36]	@ 0x24
 8016cf6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016cf8:	2b00      	cmp	r3, #0
 8016cfa:	d102      	bne.n	8016d02 <DecodeBasicCaConstraint+0x36>
 8016cfc:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8016d00:	623b      	str	r3, [r7, #32]
 8016d02:	6a3b      	ldr	r3, [r7, #32]
 8016d04:	2b00      	cmp	r3, #0
 8016d06:	d104      	bne.n	8016d12 <DecodeBasicCaConstraint+0x46>
 8016d08:	2254      	movs	r2, #84	@ 0x54
 8016d0a:	2100      	movs	r1, #0
 8016d0c:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8016d0e:	f011 fbdb 	bl	80284c8 <memset>

    if (ret == 0) {
 8016d12:	6a3b      	ldr	r3, [r7, #32]
 8016d14:	2b00      	cmp	r3, #0
 8016d16:	d120      	bne.n	8016d5a <DecodeBasicCaConstraint+0x8e>
        /* Get the CA boolean and path length when present. */
        GetASN_Boolean(&dataASN[BASICCONSASN_IDX_CA], &isCA);
 8016d18:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016d1a:	331c      	adds	r3, #28
 8016d1c:	2200      	movs	r2, #0
 8016d1e:	761a      	strb	r2, [r3, #24]
 8016d20:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016d22:	331c      	adds	r3, #28
 8016d24:	f107 0217 	add.w	r2, r7, #23
 8016d28:	609a      	str	r2, [r3, #8]
        GetASN_Int8Bit(&dataASN[BASICCONSASN_IDX_PLEN], &cert->pathLength);
 8016d2a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016d2c:	3338      	adds	r3, #56	@ 0x38
 8016d2e:	2201      	movs	r2, #1
 8016d30:	761a      	strb	r2, [r3, #24]
 8016d32:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016d34:	3338      	adds	r3, #56	@ 0x38
 8016d36:	687a      	ldr	r2, [r7, #4]
 8016d38:	f202 421c 	addw	r2, r2, #1052	@ 0x41c
 8016d3c:	609a      	str	r2, [r3, #8]

        ret = GetASN_Items(basicConsASN, dataASN, basicConsASN_Length, 1, input,
 8016d3e:	68bb      	ldr	r3, [r7, #8]
 8016d40:	9302      	str	r3, [sp, #8]
 8016d42:	f107 0318 	add.w	r3, r7, #24
 8016d46:	9301      	str	r3, [sp, #4]
 8016d48:	68fb      	ldr	r3, [r7, #12]
 8016d4a:	9300      	str	r3, [sp, #0]
 8016d4c:	2301      	movs	r3, #1
 8016d4e:	2203      	movs	r2, #3
 8016d50:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8016d52:	482e      	ldr	r0, [pc, #184]	@ (8016e0c <DecodeBasicCaConstraint+0x140>)
 8016d54:	f7fc fcd4 	bl	8013700 <GetASN_Items>
 8016d58:	6238      	str	r0, [r7, #32]
                           &idx, (word32)sz);
    }

    /* Empty SEQUENCE is OK - nothing to store. */
    if ((ret == 0) && (dataASN[BASICCONSASN_IDX_SEQ].length != 0)) {
 8016d5a:	6a3b      	ldr	r3, [r7, #32]
 8016d5c:	2b00      	cmp	r3, #0
 8016d5e:	d145      	bne.n	8016dec <DecodeBasicCaConstraint+0x120>
 8016d60:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016d62:	685b      	ldr	r3, [r3, #4]
 8016d64:	2b00      	cmp	r3, #0
 8016d66:	d041      	beq.n	8016dec <DecodeBasicCaConstraint+0x120>
        /* Bad encoding when CA Boolean is false
         * (default when not present). */
#if !defined(ASN_TEMPLATE_SKIP_ISCA_CHECK) && \
    !defined(WOLFSSL_ALLOW_ENCODING_CA_FALSE)
        if ((dataASN[BASICCONSASN_IDX_CA].length != 0) && (!isCA)) {
 8016d68:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016d6a:	331c      	adds	r3, #28
 8016d6c:	685b      	ldr	r3, [r3, #4]
 8016d6e:	2b00      	cmp	r3, #0
 8016d70:	d005      	beq.n	8016d7e <DecodeBasicCaConstraint+0xb2>
 8016d72:	7dfb      	ldrb	r3, [r7, #23]
 8016d74:	2b00      	cmp	r3, #0
 8016d76:	d102      	bne.n	8016d7e <DecodeBasicCaConstraint+0xb2>
            WOLFSSL_ERROR_VERBOSE(ASN_PARSE_E);
            ret = ASN_PARSE_E;
 8016d78:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8016d7c:	623b      	str	r3, [r7, #32]
        }
#endif
        /* Path length must be a 7-bit value. */
        if ((ret == 0) && (cert->pathLength >= (1 << 7))) {
 8016d7e:	6a3b      	ldr	r3, [r7, #32]
 8016d80:	2b00      	cmp	r3, #0
 8016d82:	d108      	bne.n	8016d96 <DecodeBasicCaConstraint+0xca>
 8016d84:	687b      	ldr	r3, [r7, #4]
 8016d86:	f893 341c 	ldrb.w	r3, [r3, #1052]	@ 0x41c
 8016d8a:	b25b      	sxtb	r3, r3
 8016d8c:	2b00      	cmp	r3, #0
 8016d8e:	da02      	bge.n	8016d96 <DecodeBasicCaConstraint+0xca>
            WOLFSSL_ERROR_VERBOSE(ASN_PARSE_E);
            ret = ASN_PARSE_E;
 8016d90:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8016d94:	623b      	str	r3, [r7, #32]
        }
        if ((ret == 0) && cert->pathLength > WOLFSSL_MAX_PATH_LEN) {
 8016d96:	6a3b      	ldr	r3, [r7, #32]
 8016d98:	2b00      	cmp	r3, #0
 8016d9a:	d108      	bne.n	8016dae <DecodeBasicCaConstraint+0xe2>
 8016d9c:	687b      	ldr	r3, [r7, #4]
 8016d9e:	f893 341c 	ldrb.w	r3, [r3, #1052]	@ 0x41c
 8016da2:	b25b      	sxtb	r3, r3
 8016da4:	2b00      	cmp	r3, #0
 8016da6:	da02      	bge.n	8016dae <DecodeBasicCaConstraint+0xe2>
            WOLFSSL_ERROR_VERBOSE(ASN_PATHLEN_SIZE_E);
            ret = ASN_PATHLEN_SIZE_E;
 8016da8:	f06f 03ec 	mvn.w	r3, #236	@ 0xec
 8016dac:	623b      	str	r3, [r7, #32]
        }
        /* Store CA boolean and whether a path length was seen. */
        if (ret == 0) {
 8016dae:	6a3b      	ldr	r3, [r7, #32]
 8016db0:	2b00      	cmp	r3, #0
 8016db2:	d11b      	bne.n	8016dec <DecodeBasicCaConstraint+0x120>
            /* isCA in certificate is a 1 bit of a byte. */
            cert->isCA = isCA ? 1 : 0;
 8016db4:	7dfb      	ldrb	r3, [r7, #23]
 8016db6:	2b00      	cmp	r3, #0
 8016db8:	bf14      	ite	ne
 8016dba:	2301      	movne	r3, #1
 8016dbc:	2300      	moveq	r3, #0
 8016dbe:	b2d9      	uxtb	r1, r3
 8016dc0:	687a      	ldr	r2, [r7, #4]
 8016dc2:	f892 34b4 	ldrb.w	r3, [r2, #1204]	@ 0x4b4
 8016dc6:	f361 1304 	bfi	r3, r1, #4, #1
 8016dca:	f882 34b4 	strb.w	r3, [r2, #1204]	@ 0x4b4
            cert->pathLengthSet = (dataASN[BASICCONSASN_IDX_PLEN].length > 0);
 8016dce:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016dd0:	3338      	adds	r3, #56	@ 0x38
 8016dd2:	685b      	ldr	r3, [r3, #4]
 8016dd4:	2b00      	cmp	r3, #0
 8016dd6:	bf14      	ite	ne
 8016dd8:	2301      	movne	r3, #1
 8016dda:	2300      	moveq	r3, #0
 8016ddc:	b2d9      	uxtb	r1, r3
 8016dde:	687a      	ldr	r2, [r7, #4]
 8016de0:	f892 34b4 	ldrb.w	r3, [r2, #1204]	@ 0x4b4
 8016de4:	f361 1345 	bfi	r3, r1, #5, #1
 8016de8:	f882 34b4 	strb.w	r3, [r2, #1204]	@ 0x4b4
        }
    }

    FREE_ASNGETDATA(dataASN, cert->heap);
 8016dec:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016dee:	2b00      	cmp	r3, #0
 8016df0:	d007      	beq.n	8016e02 <DecodeBasicCaConstraint+0x136>
 8016df2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016df4:	61fb      	str	r3, [r7, #28]
 8016df6:	69fb      	ldr	r3, [r7, #28]
 8016df8:	2b00      	cmp	r3, #0
 8016dfa:	d002      	beq.n	8016e02 <DecodeBasicCaConstraint+0x136>
 8016dfc:	69f8      	ldr	r0, [r7, #28]
 8016dfe:	f007 fe5f 	bl	801eac0 <wolfSSL_Free>
    return ret;
 8016e02:	6a3b      	ldr	r3, [r7, #32]
#endif
}
 8016e04:	4618      	mov	r0, r3
 8016e06:	3728      	adds	r7, #40	@ 0x28
 8016e08:	46bd      	mov	sp, r7
 8016e0a:	bd80      	pop	{r7, pc}
 8016e0c:	08033920 	.word	0x08033920

08016e10 <DecodePolicyConstraints>:


static int DecodePolicyConstraints(const byte* input, int sz, DecodedCert* cert)
{
 8016e10:	b580      	push	{r7, lr}
 8016e12:	b08a      	sub	sp, #40	@ 0x28
 8016e14:	af00      	add	r7, sp, #0
 8016e16:	60f8      	str	r0, [r7, #12]
 8016e18:	60b9      	str	r1, [r7, #8]
 8016e1a:	607a      	str	r2, [r7, #4]
    word32 idx = 0;
 8016e1c:	2300      	movs	r3, #0
 8016e1e:	623b      	str	r3, [r7, #32]
    int length = 0;
 8016e20:	2300      	movs	r3, #0
 8016e22:	61fb      	str	r3, [r7, #28]
    int skipLength = 0;
 8016e24:	2300      	movs	r3, #0
 8016e26:	61bb      	str	r3, [r7, #24]
    int ret;
    byte tag;

    WOLFSSL_ENTER("DecodePolicyConstraints");

    if (GetSequence(input, &idx, &length, (word32)sz) < 0) {
 8016e28:	68bb      	ldr	r3, [r7, #8]
 8016e2a:	f107 021c 	add.w	r2, r7, #28
 8016e2e:	f107 0120 	add.w	r1, r7, #32
 8016e32:	68f8      	ldr	r0, [r7, #12]
 8016e34:	f7fd f8a8 	bl	8013f88 <GetSequence>
 8016e38:	4603      	mov	r3, r0
 8016e3a:	2b00      	cmp	r3, #0
 8016e3c:	da02      	bge.n	8016e44 <DecodePolicyConstraints+0x34>
        WOLFSSL_MSG("\tfail: bad SEQUENCE");
        return ASN_PARSE_E;
 8016e3e:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8016e42:	e04f      	b.n	8016ee4 <DecodePolicyConstraints+0xd4>
    }

    if (length == 0)
 8016e44:	69fb      	ldr	r3, [r7, #28]
 8016e46:	2b00      	cmp	r3, #0
 8016e48:	d102      	bne.n	8016e50 <DecodePolicyConstraints+0x40>
        return ASN_PARSE_E;
 8016e4a:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8016e4e:	e049      	b.n	8016ee4 <DecodePolicyConstraints+0xd4>

    if (GetASNTag(input, &idx, &tag, (word32)sz) < 0) {
 8016e50:	68bb      	ldr	r3, [r7, #8]
 8016e52:	f107 0217 	add.w	r2, r7, #23
 8016e56:	f107 0120 	add.w	r1, r7, #32
 8016e5a:	68f8      	ldr	r0, [r7, #12]
 8016e5c:	f7fc ffdf 	bl	8013e1e <GetASNTag>
 8016e60:	4603      	mov	r3, r0
 8016e62:	2b00      	cmp	r3, #0
 8016e64:	da02      	bge.n	8016e6c <DecodePolicyConstraints+0x5c>
        WOLFSSL_MSG("\tfail: bad TAG");
        return ASN_PARSE_E;
 8016e66:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8016e6a:	e03b      	b.n	8016ee4 <DecodePolicyConstraints+0xd4>
    }

    if (tag == (ASN_CONTEXT_SPECIFIC | 0)) {
 8016e6c:	7dfb      	ldrb	r3, [r7, #23]
 8016e6e:	2b80      	cmp	r3, #128	@ 0x80
 8016e70:	d107      	bne.n	8016e82 <DecodePolicyConstraints+0x72>
        /* requireExplicitPolicy */
        cert->extPolicyConstRxpSet = 1;
 8016e72:	687a      	ldr	r2, [r7, #4]
 8016e74:	f892 34b5 	ldrb.w	r3, [r2, #1205]	@ 0x4b5
 8016e78:	f043 0320 	orr.w	r3, r3, #32
 8016e7c:	f882 34b5 	strb.w	r3, [r2, #1205]	@ 0x4b5
 8016e80:	e00d      	b.n	8016e9e <DecodePolicyConstraints+0x8e>
    }
    else if (tag == (ASN_CONTEXT_SPECIFIC | 1)) {
 8016e82:	7dfb      	ldrb	r3, [r7, #23]
 8016e84:	2b81      	cmp	r3, #129	@ 0x81
 8016e86:	d107      	bne.n	8016e98 <DecodePolicyConstraints+0x88>
        /* inhibitPolicyMapping */
        cert->extPolicyConstIpmSet = 1;
 8016e88:	687a      	ldr	r2, [r7, #4]
 8016e8a:	f892 34b5 	ldrb.w	r3, [r2, #1205]	@ 0x4b5
 8016e8e:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8016e92:	f882 34b5 	strb.w	r3, [r2, #1205]	@ 0x4b5
 8016e96:	e002      	b.n	8016e9e <DecodePolicyConstraints+0x8e>
    }
    else {
        WOLFSSL_MSG("\tfail: invalid TAG");
        return ASN_PARSE_E;
 8016e98:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8016e9c:	e022      	b.n	8016ee4 <DecodePolicyConstraints+0xd4>
    }

    ret = GetLength(input, &idx, &skipLength, (word32)sz);
 8016e9e:	68bb      	ldr	r3, [r7, #8]
 8016ea0:	f107 0218 	add.w	r2, r7, #24
 8016ea4:	f107 0120 	add.w	r1, r7, #32
 8016ea8:	68f8      	ldr	r0, [r7, #12]
 8016eaa:	f7fc ff20 	bl	8013cee <GetLength>
 8016eae:	6278      	str	r0, [r7, #36]	@ 0x24
    if (ret < 0) {
 8016eb0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016eb2:	2b00      	cmp	r3, #0
 8016eb4:	da01      	bge.n	8016eba <DecodePolicyConstraints+0xaa>
        WOLFSSL_MSG("\tfail: invalid length");
        return ret;
 8016eb6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016eb8:	e014      	b.n	8016ee4 <DecodePolicyConstraints+0xd4>
    }
    if (skipLength > 1) {
 8016eba:	69bb      	ldr	r3, [r7, #24]
 8016ebc:	2b01      	cmp	r3, #1
 8016ebe:	dd02      	ble.n	8016ec6 <DecodePolicyConstraints+0xb6>
        WOLFSSL_MSG("\tfail: skip value too big");
        return BUFFER_E;
 8016ec0:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8016ec4:	e00e      	b.n	8016ee4 <DecodePolicyConstraints+0xd4>
    }
    if (idx >= (word32)sz) {
 8016ec6:	6a3a      	ldr	r2, [r7, #32]
 8016ec8:	68bb      	ldr	r3, [r7, #8]
 8016eca:	429a      	cmp	r2, r3
 8016ecc:	d302      	bcc.n	8016ed4 <DecodePolicyConstraints+0xc4>
        WOLFSSL_MSG("\tfail: no policy const skip to read");
        return BUFFER_E;
 8016ece:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8016ed2:	e007      	b.n	8016ee4 <DecodePolicyConstraints+0xd4>
    }
    cert->policyConstSkip = input[idx];
 8016ed4:	6a3b      	ldr	r3, [r7, #32]
 8016ed6:	68fa      	ldr	r2, [r7, #12]
 8016ed8:	4413      	add	r3, r2
 8016eda:	781a      	ldrb	r2, [r3, #0]
 8016edc:	687b      	ldr	r3, [r7, #4]
 8016ede:	f883 241e 	strb.w	r2, [r3, #1054]	@ 0x41e

    return 0;
 8016ee2:	2300      	movs	r3, #0
}
 8016ee4:	4618      	mov	r0, r3
 8016ee6:	3728      	adds	r7, #40	@ 0x28
 8016ee8:	46bd      	mov	sp, r7
 8016eea:	bd80      	pop	{r7, pc}

08016eec <DecodeCrlDist>:
 * @return  ASN_PARSE_E when BER encoded data does not match ASN.1 items or
 *          is invalid.
 * @return  BUFFER_E when data in buffer is too small.
 */
static int DecodeCrlDist(const byte* input, word32 sz, DecodedCert* cert)
{
 8016eec:	b580      	push	{r7, lr}
 8016eee:	b08e      	sub	sp, #56	@ 0x38
 8016ef0:	af04      	add	r7, sp, #16
 8016ef2:	60f8      	str	r0, [r7, #12]
 8016ef4:	60b9      	str	r1, [r7, #8]
 8016ef6:	607a      	str	r2, [r7, #4]
                   "but we only use the first one.");
    }

    return 0;
#else
    DECL_ASNGETDATA(dataASN, crlDistASN_Length);
 8016ef8:	2300      	movs	r3, #0
 8016efa:	627b      	str	r3, [r7, #36]	@ 0x24
    word32 idx = 0;
 8016efc:	2300      	movs	r3, #0
 8016efe:	61bb      	str	r3, [r7, #24]
    int ret = 0;
 8016f00:	2300      	movs	r3, #0
 8016f02:	623b      	str	r3, [r7, #32]
    word16 reason;
#endif

    WOLFSSL_ENTER("DecodeCrlDist");

    CALLOC_ASNGETDATA(dataASN, crlDistASN_Length, ret, cert->heap);
 8016f04:	6a3b      	ldr	r3, [r7, #32]
 8016f06:	2b00      	cmp	r3, #0
 8016f08:	d109      	bne.n	8016f1e <DecodeCrlDist+0x32>
 8016f0a:	20e0      	movs	r0, #224	@ 0xe0
 8016f0c:	f007 fdbc 	bl	801ea88 <wolfSSL_Malloc>
 8016f10:	6278      	str	r0, [r7, #36]	@ 0x24
 8016f12:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016f14:	2b00      	cmp	r3, #0
 8016f16:	d102      	bne.n	8016f1e <DecodeCrlDist+0x32>
 8016f18:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8016f1c:	623b      	str	r3, [r7, #32]
 8016f1e:	6a3b      	ldr	r3, [r7, #32]
 8016f20:	2b00      	cmp	r3, #0
 8016f22:	d104      	bne.n	8016f2e <DecodeCrlDist+0x42>
 8016f24:	22e0      	movs	r2, #224	@ 0xe0
 8016f26:	2100      	movs	r1, #0
 8016f28:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8016f2a:	f011 facd 	bl	80284c8 <memset>

    cert->extCrlInfoRaw = input;
 8016f2e:	687b      	ldr	r3, [r7, #4]
 8016f30:	68fa      	ldr	r2, [r7, #12]
 8016f32:	f8c3 23b4 	str.w	r2, [r3, #948]	@ 0x3b4
    cert->extCrlInfoRawSz = (int)sz;
 8016f36:	68ba      	ldr	r2, [r7, #8]
 8016f38:	687b      	ldr	r3, [r7, #4]
 8016f3a:	f8c3 23b8 	str.w	r2, [r3, #952]	@ 0x3b8

    if  (ret == 0) {
 8016f3e:	6a3b      	ldr	r3, [r7, #32]
 8016f40:	2b00      	cmp	r3, #0
 8016f42:	d115      	bne.n	8016f70 <DecodeCrlDist+0x84>
        /* Get the GeneralName choice */
        GetASN_Choice(&dataASN[CRLDISTASN_IDX_DP_DISTPOINT_FN_GN], generalNameChoice);
 8016f44:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016f46:	3370      	adds	r3, #112	@ 0x70
 8016f48:	220b      	movs	r2, #11
 8016f4a:	761a      	strb	r2, [r3, #24]
 8016f4c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016f4e:	3370      	adds	r3, #112	@ 0x70
 8016f50:	4a1c      	ldr	r2, [pc, #112]	@ (8016fc4 <DecodeCrlDist+0xd8>)
 8016f52:	609a      	str	r2, [r3, #8]
        /* Parse CRL distribution point. */
        ret = GetASN_Items(crlDistASN, dataASN, crlDistASN_Length, 0, input,
 8016f54:	68bb      	ldr	r3, [r7, #8]
 8016f56:	9302      	str	r3, [sp, #8]
 8016f58:	f107 0318 	add.w	r3, r7, #24
 8016f5c:	9301      	str	r3, [sp, #4]
 8016f5e:	68fb      	ldr	r3, [r7, #12]
 8016f60:	9300      	str	r3, [sp, #0]
 8016f62:	2300      	movs	r3, #0
 8016f64:	2208      	movs	r2, #8
 8016f66:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8016f68:	4817      	ldr	r0, [pc, #92]	@ (8016fc8 <DecodeCrlDist+0xdc>)
 8016f6a:	f7fc fbc9 	bl	8013700 <GetASN_Items>
 8016f6e:	6238      	str	r0, [r7, #32]
                           &idx, sz);
    }
    if (ret == 0) {
 8016f70:	6a3b      	ldr	r3, [r7, #32]
 8016f72:	2b00      	cmp	r3, #0
 8016f74:	d113      	bne.n	8016f9e <DecodeCrlDist+0xb2>
        /* If the choice was a URI, store it in certificate. */
        if (dataASN[CRLDISTASN_IDX_DP_DISTPOINT_FN_GN].tag == GENERALNAME_URI) {
 8016f76:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016f78:	3370      	adds	r3, #112	@ 0x70
 8016f7a:	7e5b      	ldrb	r3, [r3, #25]
 8016f7c:	2b86      	cmp	r3, #134	@ 0x86
 8016f7e:	d10e      	bne.n	8016f9e <DecodeCrlDist+0xb2>
            word32 sz32;
            GetASN_GetConstRef(&dataASN[CRLDISTASN_IDX_DP_DISTPOINT_FN_GN],
 8016f80:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016f82:	3370      	adds	r3, #112	@ 0x70
 8016f84:	689a      	ldr	r2, [r3, #8]
 8016f86:	687b      	ldr	r3, [r7, #4]
 8016f88:	f8c3 23bc 	str.w	r2, [r3, #956]	@ 0x3bc
 8016f8c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016f8e:	3370      	adds	r3, #112	@ 0x70
 8016f90:	68db      	ldr	r3, [r3, #12]
 8016f92:	617b      	str	r3, [r7, #20]
                    &cert->extCrlInfo, &sz32);
            cert->extCrlInfoSz = (int)sz32;
 8016f94:	697b      	ldr	r3, [r7, #20]
 8016f96:	461a      	mov	r2, r3
 8016f98:	687b      	ldr	r3, [r7, #4]
 8016f9a:	f8c3 23c0 	str.w	r2, [r3, #960]	@ 0x3c0
        }
    #endif
    }

    /* Only parsing the first one. */
    if (ret == 0 && idx < (word32)sz) {
 8016f9e:	6a3b      	ldr	r3, [r7, #32]
 8016fa0:	2b00      	cmp	r3, #0
        WOLFSSL_MSG("\tThere are more CRL Distribution Point records, "
                    "but we only use the first one.");
    }
    /* TODO: validate other points. */

    FREE_ASNGETDATA(dataASN, cert->heap);
 8016fa2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016fa4:	2b00      	cmp	r3, #0
 8016fa6:	d007      	beq.n	8016fb8 <DecodeCrlDist+0xcc>
 8016fa8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016faa:	61fb      	str	r3, [r7, #28]
 8016fac:	69fb      	ldr	r3, [r7, #28]
 8016fae:	2b00      	cmp	r3, #0
 8016fb0:	d002      	beq.n	8016fb8 <DecodeCrlDist+0xcc>
 8016fb2:	69f8      	ldr	r0, [r7, #28]
 8016fb4:	f007 fd84 	bl	801eac0 <wolfSSL_Free>
    return ret;
 8016fb8:	6a3b      	ldr	r3, [r7, #32]
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 8016fba:	4618      	mov	r0, r3
 8016fbc:	3728      	adds	r7, #40	@ 0x28
 8016fbe:	46bd      	mov	sp, r7
 8016fc0:	bd80      	pop	{r7, pc}
 8016fc2:	bf00      	nop
 8016fc4:	08033910 	.word	0x08033910
 8016fc8:	0803392c 	.word	0x0803392c

08016fcc <DecodeAuthInfo>:
 * @return  BUFFER_E when data in buffer is too small.
 * @return  ASN_OBJECT_ID_E when the expected OBJECT_ID tag is not found.
 * @return  ASN_UNKNOWN_OID_E when the OID cannot be verified.
 */
static int DecodeAuthInfo(const byte* input, word32 sz, DecodedCert* cert)
{
 8016fcc:	b580      	push	{r7, lr}
 8016fce:	b0a2      	sub	sp, #136	@ 0x88
 8016fd0:	af04      	add	r7, sp, #16
 8016fd2:	60f8      	str	r0, [r7, #12]
 8016fd4:	60b9      	str	r1, [r7, #8]
 8016fd6:	607a      	str	r2, [r7, #4]
        idx += (word32)length;
    }

    return 0;
#else
    word32 idx = 0;
 8016fd8:	2300      	movs	r3, #0
 8016fda:	673b      	str	r3, [r7, #112]	@ 0x70
    int length = 0;
 8016fdc:	2300      	movs	r3, #0
 8016fde:	66fb      	str	r3, [r7, #108]	@ 0x6c
    int ret    = 0;
 8016fe0:	2300      	movs	r3, #0
 8016fe2:	677b      	str	r3, [r7, #116]	@ 0x74

    WOLFSSL_ENTER("DecodeAuthInfo");

    /* Unwrap the list of AIAs */
    if (GetASN_Sequence(input, &idx, &length, sz, 1) < 0) {
 8016fe4:	f107 026c 	add.w	r2, r7, #108	@ 0x6c
 8016fe8:	f107 0170 	add.w	r1, r7, #112	@ 0x70
 8016fec:	2301      	movs	r3, #1
 8016fee:	9300      	str	r3, [sp, #0]
 8016ff0:	68bb      	ldr	r3, [r7, #8]
 8016ff2:	68f8      	ldr	r0, [r7, #12]
 8016ff4:	f7fc fe2b 	bl	8013c4e <GetASN_Sequence>
 8016ff8:	4603      	mov	r3, r0
 8016ffa:	2b00      	cmp	r3, #0
 8016ffc:	da52      	bge.n	80170a4 <DecodeAuthInfo+0xd8>
        ret = ASN_PARSE_E;
 8016ffe:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8017002:	677b      	str	r3, [r7, #116]	@ 0x74
    }

    while ((ret == 0) && (idx < (word32)sz)) {
 8017004:	e04e      	b.n	80170a4 <DecodeAuthInfo+0xd8>
        ASNGetData dataASN[accessDescASN_Length];

        /* Clear dynamic data and retrieve OID and name. */
        XMEMSET(dataASN, 0, sizeof(dataASN));
 8017006:	f107 0314 	add.w	r3, r7, #20
 801700a:	2254      	movs	r2, #84	@ 0x54
 801700c:	2100      	movs	r1, #0
 801700e:	4618      	mov	r0, r3
 8017010:	f011 fa5a 	bl	80284c8 <memset>
        GetASN_OID(&dataASN[ACCESSDESCASN_IDX_METH], oidCertAuthInfoType);
 8017014:	2307      	movs	r3, #7
 8017016:	643b      	str	r3, [r7, #64]	@ 0x40
        GetASN_Choice(&dataASN[ACCESSDESCASN_IDX_LOC], generalNameChoice);
 8017018:	230b      	movs	r3, #11
 801701a:	f887 3064 	strb.w	r3, [r7, #100]	@ 0x64
 801701e:	4b27      	ldr	r3, [pc, #156]	@ (80170bc <DecodeAuthInfo+0xf0>)
 8017020:	657b      	str	r3, [r7, #84]	@ 0x54
        /* Parse AccessDescription. */
        ret = GetASN_Items(accessDescASN, dataASN, accessDescASN_Length, 0,
 8017022:	f107 0114 	add.w	r1, r7, #20
 8017026:	68bb      	ldr	r3, [r7, #8]
 8017028:	9302      	str	r3, [sp, #8]
 801702a:	f107 0370 	add.w	r3, r7, #112	@ 0x70
 801702e:	9301      	str	r3, [sp, #4]
 8017030:	68fb      	ldr	r3, [r7, #12]
 8017032:	9300      	str	r3, [sp, #0]
 8017034:	2300      	movs	r3, #0
 8017036:	2203      	movs	r2, #3
 8017038:	4821      	ldr	r0, [pc, #132]	@ (80170c0 <DecodeAuthInfo+0xf4>)
 801703a:	f7fc fb61 	bl	8013700 <GetASN_Items>
 801703e:	6778      	str	r0, [r7, #116]	@ 0x74
                           input, &idx, sz);
        if (ret == 0) {
 8017040:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8017042:	2b00      	cmp	r3, #0
 8017044:	d12e      	bne.n	80170a4 <DecodeAuthInfo+0xd8>
            word32 sz32;

            /* Check we have OCSP and URI. */
            if ((dataASN[ACCESSDESCASN_IDX_METH].data.oid.sum == AIA_OCSP_OID) &&
 8017046:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8017048:	2b74      	cmp	r3, #116	@ 0x74
 801704a:	d114      	bne.n	8017076 <DecodeAuthInfo+0xaa>
                    (dataASN[ACCESSDESCASN_IDX_LOC].tag == GENERALNAME_URI) &&
 801704c:	f897 3065 	ldrb.w	r3, [r7, #101]	@ 0x65
            if ((dataASN[ACCESSDESCASN_IDX_METH].data.oid.sum == AIA_OCSP_OID) &&
 8017050:	2b86      	cmp	r3, #134	@ 0x86
 8017052:	d110      	bne.n	8017076 <DecodeAuthInfo+0xaa>
                    (cert->extAuthInfo == NULL)) {
 8017054:	687b      	ldr	r3, [r7, #4]
 8017056:	f8d3 33a4 	ldr.w	r3, [r3, #932]	@ 0x3a4
                    (dataASN[ACCESSDESCASN_IDX_LOC].tag == GENERALNAME_URI) &&
 801705a:	2b00      	cmp	r3, #0
 801705c:	d10b      	bne.n	8017076 <DecodeAuthInfo+0xaa>
                /* Store URI for OCSP lookup. */
                GetASN_GetConstRef(&dataASN[ACCESSDESCASN_IDX_LOC],
 801705e:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8017060:	687b      	ldr	r3, [r7, #4]
 8017062:	f8c3 23a4 	str.w	r2, [r3, #932]	@ 0x3a4
 8017066:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8017068:	66bb      	str	r3, [r7, #104]	@ 0x68
                        &cert->extAuthInfo, &sz32);
                cert->extAuthInfoSz = (int)sz32;
 801706a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801706c:	461a      	mov	r2, r3
 801706e:	687b      	ldr	r3, [r7, #4]
 8017070:	f8c3 23a8 	str.w	r2, [r3, #936]	@ 0x3a8
 8017074:	e016      	b.n	80170a4 <DecodeAuthInfo+0xd8>
            }
        #ifdef WOLFSSL_ASN_CA_ISSUER
            /* Check we have CA Issuer and URI. */
            else if ((dataASN[ACCESSDESCASN_IDX_METH].data.oid.sum ==
 8017076:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8017078:	2b75      	cmp	r3, #117	@ 0x75
 801707a:	d113      	bne.n	80170a4 <DecodeAuthInfo+0xd8>
                        AIA_CA_ISSUER_OID) &&
                    (dataASN[ACCESSDESCASN_IDX_LOC].tag == GENERALNAME_URI) &&
 801707c:	f897 3065 	ldrb.w	r3, [r7, #101]	@ 0x65
                        AIA_CA_ISSUER_OID) &&
 8017080:	2b86      	cmp	r3, #134	@ 0x86
 8017082:	d10f      	bne.n	80170a4 <DecodeAuthInfo+0xd8>
                    (cert->extAuthInfoCaIssuer == NULL)) {
 8017084:	687b      	ldr	r3, [r7, #4]
 8017086:	f8d3 33ac 	ldr.w	r3, [r3, #940]	@ 0x3ac
                    (dataASN[ACCESSDESCASN_IDX_LOC].tag == GENERALNAME_URI) &&
 801708a:	2b00      	cmp	r3, #0
 801708c:	d10a      	bne.n	80170a4 <DecodeAuthInfo+0xd8>
                /* Set CaIssuers entry */
                GetASN_GetConstRef(&dataASN[ACCESSDESCASN_IDX_LOC],
 801708e:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8017090:	687b      	ldr	r3, [r7, #4]
 8017092:	f8c3 23ac 	str.w	r2, [r3, #940]	@ 0x3ac
 8017096:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8017098:	66bb      	str	r3, [r7, #104]	@ 0x68
                        &cert->extAuthInfoCaIssuer, &sz32);
                cert->extAuthInfoCaIssuerSz = (int)sz32;
 801709a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801709c:	461a      	mov	r2, r3
 801709e:	687b      	ldr	r3, [r7, #4]
 80170a0:	f8c3 23b0 	str.w	r2, [r3, #944]	@ 0x3b0
    while ((ret == 0) && (idx < (word32)sz)) {
 80170a4:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80170a6:	2b00      	cmp	r3, #0
 80170a8:	d103      	bne.n	80170b2 <DecodeAuthInfo+0xe6>
 80170aa:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 80170ac:	68ba      	ldr	r2, [r7, #8]
 80170ae:	429a      	cmp	r2, r3
 80170b0:	d8a9      	bhi.n	8017006 <DecodeAuthInfo+0x3a>
        #endif
            /* Otherwise skip. */
        }
    }

    return ret;
 80170b2:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
#endif
}
 80170b4:	4618      	mov	r0, r3
 80170b6:	3778      	adds	r7, #120	@ 0x78
 80170b8:	46bd      	mov	sp, r7
 80170ba:	bd80      	pop	{r7, pc}
 80170bc:	08033910 	.word	0x08033910
 80170c0:	0803394c 	.word	0x0803394c

080170c4 <DecodeAuthKeyId>:
 * @return  ASN_PARSE_E when BER encoded data does not match ASN.1 items or
 *          is invalid.
 * @return  BUFFER_E when data in buffer is too small.
 */
static int DecodeAuthKeyId(const byte* input, word32 sz, DecodedCert* cert)
{
 80170c4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80170c6:	b095      	sub	sp, #84	@ 0x54
 80170c8:	af04      	add	r7, sp, #16
 80170ca:	60f8      	str	r0, [r7, #12]
 80170cc:	60b9      	str	r1, [r7, #8]
 80170ce:	607a      	str	r2, [r7, #4]
#endif /* OPENSSL_EXTRA */

    return GetHashId(input + idx, length, cert->extAuthKeyId,
        HashIdAlg(cert->signatureOID));
#else
    DECL_ASNGETDATA(dataASN, authKeyIdASN_Length);
 80170d0:	2300      	movs	r3, #0
 80170d2:	63fb      	str	r3, [r7, #60]	@ 0x3c
    int ret = 0;
 80170d4:	2300      	movs	r3, #0
 80170d6:	63bb      	str	r3, [r7, #56]	@ 0x38

    WOLFSSL_ENTER("DecodeAuthKeyId");

    CALLOC_ASNGETDATA(dataASN, authKeyIdASN_Length, ret, cert->heap);
 80170d8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80170da:	2b00      	cmp	r3, #0
 80170dc:	d109      	bne.n	80170f2 <DecodeAuthKeyId+0x2e>
 80170de:	2070      	movs	r0, #112	@ 0x70
 80170e0:	f007 fcd2 	bl	801ea88 <wolfSSL_Malloc>
 80170e4:	63f8      	str	r0, [r7, #60]	@ 0x3c
 80170e6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80170e8:	2b00      	cmp	r3, #0
 80170ea:	d102      	bne.n	80170f2 <DecodeAuthKeyId+0x2e>
 80170ec:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 80170f0:	63bb      	str	r3, [r7, #56]	@ 0x38
 80170f2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80170f4:	2b00      	cmp	r3, #0
 80170f6:	d104      	bne.n	8017102 <DecodeAuthKeyId+0x3e>
 80170f8:	2270      	movs	r2, #112	@ 0x70
 80170fa:	2100      	movs	r1, #0
 80170fc:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 80170fe:	f011 f9e3 	bl	80284c8 <memset>

    if (ret == 0) {
 8017102:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017104:	2b00      	cmp	r3, #0
 8017106:	d10f      	bne.n	8017128 <DecodeAuthKeyId+0x64>
        /* Parse an authority key identifier. */
        word32 idx = 0;
 8017108:	2300      	movs	r3, #0
 801710a:	633b      	str	r3, [r7, #48]	@ 0x30
        ret = GetASN_Items(authKeyIdASN, dataASN, authKeyIdASN_Length, 1, input,
 801710c:	68bb      	ldr	r3, [r7, #8]
 801710e:	9302      	str	r3, [sp, #8]
 8017110:	f107 0330 	add.w	r3, r7, #48	@ 0x30
 8017114:	9301      	str	r3, [sp, #4]
 8017116:	68fb      	ldr	r3, [r7, #12]
 8017118:	9300      	str	r3, [sp, #0]
 801711a:	2301      	movs	r3, #1
 801711c:	2204      	movs	r2, #4
 801711e:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 8017120:	484d      	ldr	r0, [pc, #308]	@ (8017258 <DecodeAuthKeyId+0x194>)
 8017122:	f7fc faed 	bl	8013700 <GetASN_Items>
 8017126:	63b8      	str	r0, [r7, #56]	@ 0x38
                           &idx, sz);
    }
    /* Each field is optional */
    if (ret == 0 && dataASN[AUTHKEYIDASN_IDX_KEYID].data.ref.data != NULL) {
 8017128:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801712a:	2b00      	cmp	r3, #0
 801712c:	d126      	bne.n	801717c <DecodeAuthKeyId+0xb8>
 801712e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8017130:	331c      	adds	r3, #28
 8017132:	689b      	ldr	r3, [r3, #8]
 8017134:	2b00      	cmp	r3, #0
 8017136:	d021      	beq.n	801717c <DecodeAuthKeyId+0xb8>
#ifdef OPENSSL_EXTRA
        GetASN_GetConstRef(&dataASN[AUTHKEYIDASN_IDX_KEYID],
 8017138:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801713a:	331c      	adds	r3, #28
 801713c:	689a      	ldr	r2, [r3, #8]
 801713e:	687b      	ldr	r3, [r7, #4]
 8017140:	f8c3 2438 	str.w	r2, [r3, #1080]	@ 0x438
 8017144:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8017146:	331c      	adds	r3, #28
 8017148:	68da      	ldr	r2, [r3, #12]
 801714a:	687b      	ldr	r3, [r7, #4]
 801714c:	f8c3 2408 	str.w	r2, [r3, #1032]	@ 0x408
                &cert->extAuthKeyIdSrc, &cert->extAuthKeyIdSz);
#endif /* OPENSSL_EXTRA */
        /* Get the hash or hash of the hash if wrong size. */
        ret = GetHashId(dataASN[AUTHKEYIDASN_IDX_KEYID].data.ref.data,
 8017150:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8017152:	331c      	adds	r3, #28
 8017154:	689c      	ldr	r4, [r3, #8]
                    (int)dataASN[AUTHKEYIDASN_IDX_KEYID].data.ref.length,
 8017156:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8017158:	331c      	adds	r3, #28
 801715a:	68db      	ldr	r3, [r3, #12]
        ret = GetHashId(dataASN[AUTHKEYIDASN_IDX_KEYID].data.ref.data,
 801715c:	461e      	mov	r6, r3
                    cert->extAuthKeyId, HashIdAlg(cert->signatureOID));
 801715e:	687b      	ldr	r3, [r7, #4]
 8017160:	f503 757a 	add.w	r5, r3, #1000	@ 0x3e8
        ret = GetHashId(dataASN[AUTHKEYIDASN_IDX_KEYID].data.ref.data,
 8017164:	687b      	ldr	r3, [r7, #4]
 8017166:	699b      	ldr	r3, [r3, #24]
 8017168:	4618      	mov	r0, r3
 801716a:	f7fe fabd 	bl	80156e8 <HashIdAlg>
 801716e:	4603      	mov	r3, r0
 8017170:	462a      	mov	r2, r5
 8017172:	4631      	mov	r1, r6
 8017174:	4620      	mov	r0, r4
 8017176:	f7fe faec 	bl	8015752 <GetHashId>
 801717a:	63b8      	str	r0, [r7, #56]	@ 0x38
    }
#ifdef WOLFSSL_AKID_NAME
    if (ret == 0 && dataASN[AUTHKEYIDASN_IDX_ISSUER].data.ref.data != NULL) {
 801717c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801717e:	2b00      	cmp	r3, #0
 8017180:	d130      	bne.n	80171e4 <DecodeAuthKeyId+0x120>
 8017182:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8017184:	3338      	adds	r3, #56	@ 0x38
 8017186:	689b      	ldr	r3, [r3, #8]
 8017188:	2b00      	cmp	r3, #0
 801718a:	d02b      	beq.n	80171e4 <DecodeAuthKeyId+0x120>
        /* We only support using one (first) name. Parse the name to perform
         * a sanity check. */
        word32 idx = 0;
 801718c:	2300      	movs	r3, #0
 801718e:	62fb      	str	r3, [r7, #44]	@ 0x2c
        ASNGetData nameASN[altNameASN_Length];
        XMEMSET(nameASN, 0, sizeof(nameASN));
 8017190:	f107 0310 	add.w	r3, r7, #16
 8017194:	221c      	movs	r2, #28
 8017196:	2100      	movs	r1, #0
 8017198:	4618      	mov	r0, r3
 801719a:	f011 f995 	bl	80284c8 <memset>
        /* Parse GeneralName with the choices supported. */
        GetASN_Choice(&nameASN[ALTNAMEASN_IDX_GN], generalNameChoice);
 801719e:	230b      	movs	r3, #11
 80171a0:	f887 3028 	strb.w	r3, [r7, #40]	@ 0x28
 80171a4:	4b2d      	ldr	r3, [pc, #180]	@ (801725c <DecodeAuthKeyId+0x198>)
 80171a6:	61bb      	str	r3, [r7, #24]
        /* Decode a GeneralName choice. */
        ret = GetASN_Items(altNameASN, nameASN, altNameASN_Length, 0,
                dataASN[AUTHKEYIDASN_IDX_ISSUER].data.ref.data, &idx,
 80171a8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80171aa:	3338      	adds	r3, #56	@ 0x38
        ret = GetASN_Items(altNameASN, nameASN, altNameASN_Length, 0,
 80171ac:	689b      	ldr	r3, [r3, #8]
                dataASN[AUTHKEYIDASN_IDX_ISSUER].data.ref.length);
 80171ae:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80171b0:	3238      	adds	r2, #56	@ 0x38
        ret = GetASN_Items(altNameASN, nameASN, altNameASN_Length, 0,
 80171b2:	68d2      	ldr	r2, [r2, #12]
 80171b4:	f107 0110 	add.w	r1, r7, #16
 80171b8:	9202      	str	r2, [sp, #8]
 80171ba:	f107 022c 	add.w	r2, r7, #44	@ 0x2c
 80171be:	9201      	str	r2, [sp, #4]
 80171c0:	9300      	str	r3, [sp, #0]
 80171c2:	2300      	movs	r3, #0
 80171c4:	2201      	movs	r2, #1
 80171c6:	4826      	ldr	r0, [pc, #152]	@ (8017260 <DecodeAuthKeyId+0x19c>)
 80171c8:	f7fc fa9a 	bl	8013700 <GetASN_Items>
 80171cc:	63b8      	str	r0, [r7, #56]	@ 0x38

        if (ret == 0) {
 80171ce:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80171d0:	2b00      	cmp	r3, #0
 80171d2:	d107      	bne.n	80171e4 <DecodeAuthKeyId+0x120>
            GetASN_GetConstRef(&nameASN[ALTNAMEASN_IDX_GN],
 80171d4:	69ba      	ldr	r2, [r7, #24]
 80171d6:	687b      	ldr	r3, [r7, #4]
 80171d8:	f8c3 240c 	str.w	r2, [r3, #1036]	@ 0x40c
 80171dc:	69fa      	ldr	r2, [r7, #28]
 80171de:	687b      	ldr	r3, [r7, #4]
 80171e0:	f8c3 2410 	str.w	r2, [r3, #1040]	@ 0x410
                    &cert->extAuthKeyIdIssuer, &cert->extAuthKeyIdIssuerSz);
        }
    }
    if (ret == 0 && dataASN[AUTHKEYIDASN_IDX_SERIAL].data.ref.data != NULL) {
 80171e4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80171e6:	2b00      	cmp	r3, #0
 80171e8:	d110      	bne.n	801720c <DecodeAuthKeyId+0x148>
 80171ea:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80171ec:	3354      	adds	r3, #84	@ 0x54
 80171ee:	689b      	ldr	r3, [r3, #8]
 80171f0:	2b00      	cmp	r3, #0
 80171f2:	d00b      	beq.n	801720c <DecodeAuthKeyId+0x148>
        GetASN_GetConstRef(&dataASN[AUTHKEYIDASN_IDX_SERIAL],
 80171f4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80171f6:	3354      	adds	r3, #84	@ 0x54
 80171f8:	689a      	ldr	r2, [r3, #8]
 80171fa:	687b      	ldr	r3, [r7, #4]
 80171fc:	f8c3 2414 	str.w	r2, [r3, #1044]	@ 0x414
 8017200:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8017202:	3354      	adds	r3, #84	@ 0x54
 8017204:	68da      	ldr	r2, [r3, #12]
 8017206:	687b      	ldr	r3, [r7, #4]
 8017208:	f8c3 2418 	str.w	r2, [r3, #1048]	@ 0x418
                &cert->extAuthKeyIdIssuerSN, &cert->extAuthKeyIdIssuerSNSz);
    }
    if (ret == 0) {
 801720c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801720e:	2b00      	cmp	r3, #0
 8017210:	d107      	bne.n	8017222 <DecodeAuthKeyId+0x15e>
        if ((cert->extAuthKeyIdIssuerSz > 0) ^
 8017212:	687b      	ldr	r3, [r7, #4]
 8017214:	f8d3 3410 	ldr.w	r3, [r3, #1040]	@ 0x410
 8017218:	2b00      	cmp	r3, #0
                (cert->extAuthKeyIdIssuerSNSz > 0)) {
 801721a:	687b      	ldr	r3, [r7, #4]
 801721c:	f8d3 3418 	ldr.w	r3, [r3, #1048]	@ 0x418
        if ((cert->extAuthKeyIdIssuerSz > 0) ^
 8017220:	2b00      	cmp	r3, #0
            WOLFSSL_MSG("authorityCertIssuer and authorityCertSerialNumber MUST"
                       " both be present or both be absent");
        }
    }
#endif /* WOLFSSL_AKID_NAME */
    if (ret == 0) {
 8017222:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017224:	2b00      	cmp	r3, #0
 8017226:	d107      	bne.n	8017238 <DecodeAuthKeyId+0x174>
#if defined(OPENSSL_EXTRA) && defined(WOLFSSL_AKID_NAME)
        /* Store the raw authority key id. */
        cert->extRawAuthKeyIdSrc = input;
 8017228:	687b      	ldr	r3, [r7, #4]
 801722a:	68fa      	ldr	r2, [r7, #12]
 801722c:	f8c3 2430 	str.w	r2, [r3, #1072]	@ 0x430
        cert->extRawAuthKeyIdSz = sz;
 8017230:	687b      	ldr	r3, [r7, #4]
 8017232:	68ba      	ldr	r2, [r7, #8]
 8017234:	f8c3 2434 	str.w	r2, [r3, #1076]	@ 0x434
#endif /* OPENSSL_EXTRA */
    }

    FREE_ASNGETDATA(dataASN, cert->heap);
 8017238:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801723a:	2b00      	cmp	r3, #0
 801723c:	d007      	beq.n	801724e <DecodeAuthKeyId+0x18a>
 801723e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8017240:	637b      	str	r3, [r7, #52]	@ 0x34
 8017242:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8017244:	2b00      	cmp	r3, #0
 8017246:	d002      	beq.n	801724e <DecodeAuthKeyId+0x18a>
 8017248:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801724a:	f007 fc39 	bl	801eac0 <wolfSSL_Free>
    return ret;
 801724e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 8017250:	4618      	mov	r0, r3
 8017252:	3744      	adds	r7, #68	@ 0x44
 8017254:	46bd      	mov	sp, r7
 8017256:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8017258:	08033958 	.word	0x08033958
 801725c:	08033910 	.word	0x08033910
 8017260:	0803391c 	.word	0x0803391c

08017264 <DecodeSubjKeyId>:
 * @return  ASN_PARSE_E when the OCTET_STRING tag is not found or length is
 *          invalid.
 * @return  MEMORY_E on dynamic memory allocation failure.
 */
static int DecodeSubjKeyId(const byte* input, word32 sz, DecodedCert* cert)
{
 8017264:	b5f0      	push	{r4, r5, r6, r7, lr}
 8017266:	b089      	sub	sp, #36	@ 0x24
 8017268:	af00      	add	r7, sp, #0
 801726a:	60f8      	str	r0, [r7, #12]
 801726c:	60b9      	str	r1, [r7, #8]
 801726e:	607a      	str	r2, [r7, #4]
    word32 idx = 0;
 8017270:	2300      	movs	r3, #0
 8017272:	61bb      	str	r3, [r7, #24]
    int length = 0;
 8017274:	2300      	movs	r3, #0
 8017276:	617b      	str	r3, [r7, #20]
    int ret = 0;
 8017278:	2300      	movs	r3, #0
 801727a:	61fb      	str	r3, [r7, #28]

    WOLFSSL_ENTER("DecodeSubjKeyId");

    ret = GetOctetString(input, &idx, &length, sz);
 801727c:	f107 0214 	add.w	r2, r7, #20
 8017280:	f107 0118 	add.w	r1, r7, #24
 8017284:	68bb      	ldr	r3, [r7, #8]
 8017286:	68f8      	ldr	r0, [r7, #12]
 8017288:	f7fc fea8 	bl	8013fdc <GetOctetString>
 801728c:	61f8      	str	r0, [r7, #28]
    if (ret > 0) {
 801728e:	69fb      	ldr	r3, [r7, #28]
 8017290:	2b00      	cmp	r3, #0
 8017292:	dd1d      	ble.n	80172d0 <DecodeSubjKeyId+0x6c>
        cert->extSubjKeyIdSz = (word32)length;
 8017294:	697b      	ldr	r3, [r7, #20]
 8017296:	461a      	mov	r2, r3
 8017298:	687b      	ldr	r3, [r7, #4]
 801729a:	f8c3 23e4 	str.w	r2, [r3, #996]	@ 0x3e4
    #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
        cert->extSubjKeyIdSrc = &input[idx];
 801729e:	69bb      	ldr	r3, [r7, #24]
 80172a0:	68fa      	ldr	r2, [r7, #12]
 80172a2:	441a      	add	r2, r3
 80172a4:	687b      	ldr	r3, [r7, #4]
 80172a6:	f8c3 243c 	str.w	r2, [r3, #1084]	@ 0x43c
    #endif /* OPENSSL_EXTRA */

        /* Get the hash or hash of the hash if wrong size. */
        ret = GetHashId(input + idx, length, cert->extSubjKeyId,
 80172aa:	69bb      	ldr	r3, [r7, #24]
 80172ac:	68fa      	ldr	r2, [r7, #12]
 80172ae:	18d4      	adds	r4, r2, r3
 80172b0:	697d      	ldr	r5, [r7, #20]
 80172b2:	687b      	ldr	r3, [r7, #4]
 80172b4:	f503 7671 	add.w	r6, r3, #964	@ 0x3c4
 80172b8:	687b      	ldr	r3, [r7, #4]
 80172ba:	699b      	ldr	r3, [r3, #24]
 80172bc:	4618      	mov	r0, r3
 80172be:	f7fe fa13 	bl	80156e8 <HashIdAlg>
 80172c2:	4603      	mov	r3, r0
 80172c4:	4632      	mov	r2, r6
 80172c6:	4629      	mov	r1, r5
 80172c8:	4620      	mov	r0, r4
 80172ca:	f7fe fa42 	bl	8015752 <GetHashId>
 80172ce:	61f8      	str	r0, [r7, #28]
            HashIdAlg(cert->signatureOID));
    }

    return ret;
 80172d0:	69fb      	ldr	r3, [r7, #28]
}
 80172d2:	4618      	mov	r0, r3
 80172d4:	3724      	adds	r7, #36	@ 0x24
 80172d6:	46bd      	mov	sp, r7
 80172d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

080172dc <DecodeKeyUsage>:
 * @return  ASN_PARSE_E when BER encoded data does not match ASN.1 items or
 *          is invalid.
 * @return  MEMORY_E on dynamic memory allocation failure.
 */
static int DecodeKeyUsage(const byte* input, word32 sz, DecodedCert* cert)
{
 80172dc:	b580      	push	{r7, lr}
 80172de:	b094      	sub	sp, #80	@ 0x50
 80172e0:	af04      	add	r7, sp, #16
 80172e2:	60f8      	str	r0, [r7, #12]
 80172e4:	60b9      	str	r1, [r7, #8]
 80172e6:	607a      	str	r2, [r7, #4]
        cert->extKeyUsage |= (word16)(input[idx+1] << 8);

    return 0;
#else
    ASNGetData dataASN[keyUsageASN_Length];
    word32 idx = 0;
 80172e8:	2300      	movs	r3, #0
 80172ea:	61fb      	str	r3, [r7, #28]
    byte keyUsage[2];
    word32 keyUsageSz = sizeof(keyUsage);
 80172ec:	2302      	movs	r3, #2
 80172ee:	617b      	str	r3, [r7, #20]
    int ret;
    WOLFSSL_ENTER("DecodeKeyUsage");

    /* Clear dynamic data and set where to store extended key usage. */
    XMEMSET(dataASN, 0, sizeof(dataASN));
 80172f0:	f107 0320 	add.w	r3, r7, #32
 80172f4:	221c      	movs	r2, #28
 80172f6:	2100      	movs	r1, #0
 80172f8:	4618      	mov	r0, r3
 80172fa:	f011 f8e5 	bl	80284c8 <memset>
    XMEMSET(keyUsage, 0, sizeof(keyUsage));
 80172fe:	f107 0318 	add.w	r3, r7, #24
 8017302:	2202      	movs	r2, #2
 8017304:	2100      	movs	r1, #0
 8017306:	4618      	mov	r0, r3
 8017308:	f011 f8de 	bl	80284c8 <memset>
    GetASN_Buffer(&dataASN[KEYUSAGEASN_IDX_STR], keyUsage, &keyUsageSz);
 801730c:	2305      	movs	r3, #5
 801730e:	f887 3038 	strb.w	r3, [r7, #56]	@ 0x38
 8017312:	f107 0318 	add.w	r3, r7, #24
 8017316:	62bb      	str	r3, [r7, #40]	@ 0x28
 8017318:	f107 0314 	add.w	r3, r7, #20
 801731c:	62fb      	str	r3, [r7, #44]	@ 0x2c
    /* Parse key usage. */
    ret = GetASN_Items(keyUsageASN, dataASN, keyUsageASN_Length, 0, input,
 801731e:	f107 0120 	add.w	r1, r7, #32
 8017322:	68bb      	ldr	r3, [r7, #8]
 8017324:	9302      	str	r3, [sp, #8]
 8017326:	f107 031c 	add.w	r3, r7, #28
 801732a:	9301      	str	r3, [sp, #4]
 801732c:	68fb      	ldr	r3, [r7, #12]
 801732e:	9300      	str	r3, [sp, #0]
 8017330:	2300      	movs	r3, #0
 8017332:	2201      	movs	r2, #1
 8017334:	480f      	ldr	r0, [pc, #60]	@ (8017374 <DecodeKeyUsage+0x98>)
 8017336:	f7fc f9e3 	bl	8013700 <GetASN_Items>
 801733a:	63f8      	str	r0, [r7, #60]	@ 0x3c
                        &idx, sz);
    if (ret == 0) {
 801733c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801733e:	2b00      	cmp	r3, #0
 8017340:	d112      	bne.n	8017368 <DecodeKeyUsage+0x8c>
        /* Decode the bit string number as LE */
        cert->extKeyUsage = (word16)(keyUsage[0]);
 8017342:	7e3b      	ldrb	r3, [r7, #24]
 8017344:	461a      	mov	r2, r3
 8017346:	687b      	ldr	r3, [r7, #4]
 8017348:	f8a3 2420 	strh.w	r2, [r3, #1056]	@ 0x420
        if (keyUsageSz == 2)
 801734c:	697b      	ldr	r3, [r7, #20]
 801734e:	2b02      	cmp	r3, #2
 8017350:	d10a      	bne.n	8017368 <DecodeKeyUsage+0x8c>
            cert->extKeyUsage |= (word16)(keyUsage[1] << 8);
 8017352:	687b      	ldr	r3, [r7, #4]
 8017354:	f8b3 2420 	ldrh.w	r2, [r3, #1056]	@ 0x420
 8017358:	7e7b      	ldrb	r3, [r7, #25]
 801735a:	021b      	lsls	r3, r3, #8
 801735c:	b29b      	uxth	r3, r3
 801735e:	4313      	orrs	r3, r2
 8017360:	b29a      	uxth	r2, r3
 8017362:	687b      	ldr	r3, [r7, #4]
 8017364:	f8a3 2420 	strh.w	r2, [r3, #1056]	@ 0x420
    }
    return ret;
 8017368:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 801736a:	4618      	mov	r0, r3
 801736c:	3740      	adds	r7, #64	@ 0x40
 801736e:	46bd      	mov	sp, r7
 8017370:	bd80      	pop	{r7, pc}
 8017372:	bf00      	nop
 8017374:	08033968 	.word	0x08033968

08017378 <DecodeExtKeyUsage>:
 * @return  ASN_PARSE_E when BER encoded data does not match ASN.1 items or
 *          is invalid.
 * @return  MEMORY_E on dynamic memory allocation failure.
 */
static int DecodeExtKeyUsage(const byte* input, word32 sz, DecodedCert* cert)
{
 8017378:	b580      	push	{r7, lr}
 801737a:	b092      	sub	sp, #72	@ 0x48
 801737c:	af04      	add	r7, sp, #16
 801737e:	60f8      	str	r0, [r7, #12]
 8017380:	60b9      	str	r1, [r7, #8]
 8017382:	607a      	str	r2, [r7, #4]
    #endif
    }

    return 0;
#else
    word32 idx = 0;
 8017384:	2300      	movs	r3, #0
 8017386:	633b      	str	r3, [r7, #48]	@ 0x30
    int length;
    int ret = 0;
 8017388:	2300      	movs	r3, #0
 801738a:	637b      	str	r3, [r7, #52]	@ 0x34

    WOLFSSL_ENTER("DecodeExtKeyUsage");

    /* Strip SEQUENCE OF and expect to account for all the data. */
    if (GetASN_Sequence(input, &idx, &length, sz, 1) < 0) {
 801738c:	f107 022c 	add.w	r2, r7, #44	@ 0x2c
 8017390:	f107 0130 	add.w	r1, r7, #48	@ 0x30
 8017394:	2301      	movs	r3, #1
 8017396:	9300      	str	r3, [sp, #0]
 8017398:	68bb      	ldr	r3, [r7, #8]
 801739a:	68f8      	ldr	r0, [r7, #12]
 801739c:	f7fc fc57 	bl	8013c4e <GetASN_Sequence>
 80173a0:	4603      	mov	r3, r0
 80173a2:	2b00      	cmp	r3, #0
 80173a4:	da02      	bge.n	80173ac <DecodeExtKeyUsage+0x34>
        WOLFSSL_MSG("\tfail: should be a SEQUENCE");
        ret = ASN_PARSE_E;
 80173a6:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80173aa:	637b      	str	r3, [r7, #52]	@ 0x34
    }

    if (ret == 0) {
 80173ac:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80173ae:	2b00      	cmp	r3, #0
 80173b0:	f040 809b 	bne.w	80174ea <DecodeExtKeyUsage+0x172>
    #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
        /* Keep reference for WOLFSSL_X509. */
        cert->extExtKeyUsageSrc = input + idx;
 80173b4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80173b6:	68fa      	ldr	r2, [r7, #12]
 80173b8:	441a      	add	r2, r3
 80173ba:	687b      	ldr	r3, [r7, #4]
 80173bc:	f8c3 2424 	str.w	r2, [r3, #1060]	@ 0x424
        cert->extExtKeyUsageSz = (word32)length;
 80173c0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80173c2:	461a      	mov	r2, r3
 80173c4:	687b      	ldr	r3, [r7, #4]
 80173c6:	f8c3 2428 	str.w	r2, [r3, #1064]	@ 0x428
    #endif
    }

    /* Check all OIDs. */
    while ((ret == 0) && (idx < (word32)sz)) {
 80173ca:	e08e      	b.n	80174ea <DecodeExtKeyUsage+0x172>
        ASNGetData dataASN[keyPurposeIdASN_Length];

        /* Clear dynamic data items and set OID type expected. */
        XMEMSET(dataASN, 0, sizeof(dataASN));
 80173cc:	f107 0310 	add.w	r3, r7, #16
 80173d0:	221c      	movs	r2, #28
 80173d2:	2100      	movs	r1, #0
 80173d4:	4618      	mov	r0, r3
 80173d6:	f011 f877 	bl	80284c8 <memset>
        GetASN_OID(&dataASN[KEYPURPOSEIDASN_IDX_OID], oidIgnoreType);
 80173da:	2315      	movs	r3, #21
 80173dc:	623b      	str	r3, [r7, #32]
        /* Decode KeyPurposeId. */
        ret = GetASN_Items(keyPurposeIdASN, dataASN, keyPurposeIdASN_Length, 0,
 80173de:	f107 0110 	add.w	r1, r7, #16
 80173e2:	68bb      	ldr	r3, [r7, #8]
 80173e4:	9302      	str	r3, [sp, #8]
 80173e6:	f107 0330 	add.w	r3, r7, #48	@ 0x30
 80173ea:	9301      	str	r3, [sp, #4]
 80173ec:	68fb      	ldr	r3, [r7, #12]
 80173ee:	9300      	str	r3, [sp, #0]
 80173f0:	2300      	movs	r3, #0
 80173f2:	2201      	movs	r2, #1
 80173f4:	4843      	ldr	r0, [pc, #268]	@ (8017504 <DecodeExtKeyUsage+0x18c>)
 80173f6:	f7fc f983 	bl	8013700 <GetASN_Items>
 80173fa:	6378      	str	r0, [r7, #52]	@ 0x34
                           input, &idx, sz);
        /* Skip unknown OIDs. */
        if (ret == WC_NO_ERR_TRACE(ASN_UNKNOWN_OID_E)) {
 80173fc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80173fe:	f113 0f94 	cmn.w	r3, #148	@ 0x94
 8017402:	d102      	bne.n	801740a <DecodeExtKeyUsage+0x92>
            ret = 0;
 8017404:	2300      	movs	r3, #0
 8017406:	637b      	str	r3, [r7, #52]	@ 0x34
 8017408:	e06f      	b.n	80174ea <DecodeExtKeyUsage+0x172>
        }
        else if (ret == 0) {
 801740a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801740c:	2b00      	cmp	r3, #0
 801740e:	d16c      	bne.n	80174ea <DecodeExtKeyUsage+0x172>
            /* Store the bit for the OID. */
            switch (dataASN[KEYPURPOSEIDASN_IDX_OID].data.oid.sum) {
 8017410:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8017412:	2b4f      	cmp	r3, #79	@ 0x4f
 8017414:	d81a      	bhi.n	801744c <DecodeExtKeyUsage+0xd4>
 8017416:	2b47      	cmp	r3, #71	@ 0x47
 8017418:	d360      	bcc.n	80174dc <DecodeExtKeyUsage+0x164>
 801741a:	3b47      	subs	r3, #71	@ 0x47
 801741c:	2b08      	cmp	r3, #8
 801741e:	d85d      	bhi.n	80174dc <DecodeExtKeyUsage+0x164>
 8017420:	a201      	add	r2, pc, #4	@ (adr r2, 8017428 <DecodeExtKeyUsage+0xb0>)
 8017422:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8017426:	bf00      	nop
 8017428:	08017465 	.word	0x08017465
 801742c:	08017479 	.word	0x08017479
 8017430:	0801748d 	.word	0x0801748d
 8017434:	080174a1 	.word	0x080174a1
 8017438:	080174dd 	.word	0x080174dd
 801743c:	080174dd 	.word	0x080174dd
 8017440:	080174dd 	.word	0x080174dd
 8017444:	080174b5 	.word	0x080174b5
 8017448:	080174c9 	.word	0x080174c9
 801744c:	2b97      	cmp	r3, #151	@ 0x97
 801744e:	d145      	bne.n	80174dc <DecodeExtKeyUsage+0x164>
                case EKU_ANY_OID:
                    cert->extExtKeyUsage |= EXTKEYUSE_ANY;
 8017450:	687b      	ldr	r3, [r7, #4]
 8017452:	f893 3422 	ldrb.w	r3, [r3, #1058]	@ 0x422
 8017456:	f043 0301 	orr.w	r3, r3, #1
 801745a:	b2da      	uxtb	r2, r3
 801745c:	687b      	ldr	r3, [r7, #4]
 801745e:	f883 2422 	strb.w	r2, [r3, #1058]	@ 0x422
                    break;
 8017462:	e03b      	b.n	80174dc <DecodeExtKeyUsage+0x164>
                case EKU_SERVER_AUTH_OID:
                    cert->extExtKeyUsage |= EXTKEYUSE_SERVER_AUTH;
 8017464:	687b      	ldr	r3, [r7, #4]
 8017466:	f893 3422 	ldrb.w	r3, [r3, #1058]	@ 0x422
 801746a:	f043 0302 	orr.w	r3, r3, #2
 801746e:	b2da      	uxtb	r2, r3
 8017470:	687b      	ldr	r3, [r7, #4]
 8017472:	f883 2422 	strb.w	r2, [r3, #1058]	@ 0x422
                    break;
 8017476:	e031      	b.n	80174dc <DecodeExtKeyUsage+0x164>
                case EKU_CLIENT_AUTH_OID:
                    cert->extExtKeyUsage |= EXTKEYUSE_CLIENT_AUTH;
 8017478:	687b      	ldr	r3, [r7, #4]
 801747a:	f893 3422 	ldrb.w	r3, [r3, #1058]	@ 0x422
 801747e:	f043 0304 	orr.w	r3, r3, #4
 8017482:	b2da      	uxtb	r2, r3
 8017484:	687b      	ldr	r3, [r7, #4]
 8017486:	f883 2422 	strb.w	r2, [r3, #1058]	@ 0x422
                    break;
 801748a:	e027      	b.n	80174dc <DecodeExtKeyUsage+0x164>
                case EKU_CODESIGNING_OID:
                    cert->extExtKeyUsage |= EXTKEYUSE_CODESIGN;
 801748c:	687b      	ldr	r3, [r7, #4]
 801748e:	f893 3422 	ldrb.w	r3, [r3, #1058]	@ 0x422
 8017492:	f043 0308 	orr.w	r3, r3, #8
 8017496:	b2da      	uxtb	r2, r3
 8017498:	687b      	ldr	r3, [r7, #4]
 801749a:	f883 2422 	strb.w	r2, [r3, #1058]	@ 0x422
                    break;
 801749e:	e01d      	b.n	80174dc <DecodeExtKeyUsage+0x164>
                case EKU_EMAILPROTECT_OID:
                    cert->extExtKeyUsage |= EXTKEYUSE_EMAILPROT;
 80174a0:	687b      	ldr	r3, [r7, #4]
 80174a2:	f893 3422 	ldrb.w	r3, [r3, #1058]	@ 0x422
 80174a6:	f043 0310 	orr.w	r3, r3, #16
 80174aa:	b2da      	uxtb	r2, r3
 80174ac:	687b      	ldr	r3, [r7, #4]
 80174ae:	f883 2422 	strb.w	r2, [r3, #1058]	@ 0x422
                    break;
 80174b2:	e013      	b.n	80174dc <DecodeExtKeyUsage+0x164>
                case EKU_TIMESTAMP_OID:
                    cert->extExtKeyUsage |= EXTKEYUSE_TIMESTAMP;
 80174b4:	687b      	ldr	r3, [r7, #4]
 80174b6:	f893 3422 	ldrb.w	r3, [r3, #1058]	@ 0x422
 80174ba:	f043 0320 	orr.w	r3, r3, #32
 80174be:	b2da      	uxtb	r2, r3
 80174c0:	687b      	ldr	r3, [r7, #4]
 80174c2:	f883 2422 	strb.w	r2, [r3, #1058]	@ 0x422
                    break;
 80174c6:	e009      	b.n	80174dc <DecodeExtKeyUsage+0x164>
                case EKU_OCSP_SIGN_OID:
                    cert->extExtKeyUsage |= EXTKEYUSE_OCSP_SIGN;
 80174c8:	687b      	ldr	r3, [r7, #4]
 80174ca:	f893 3422 	ldrb.w	r3, [r3, #1058]	@ 0x422
 80174ce:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 80174d2:	b2da      	uxtb	r2, r3
 80174d4:	687b      	ldr	r3, [r7, #4]
 80174d6:	f883 2422 	strb.w	r2, [r3, #1058]	@ 0x422
                    break;
 80174da:	bf00      	nop
            }

        #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
            /* Keep count for WOLFSSL_X509. */
            cert->extExtKeyUsageCount++;
 80174dc:	687b      	ldr	r3, [r7, #4]
 80174de:	f8d3 342c 	ldr.w	r3, [r3, #1068]	@ 0x42c
 80174e2:	1c5a      	adds	r2, r3, #1
 80174e4:	687b      	ldr	r3, [r7, #4]
 80174e6:	f8c3 242c 	str.w	r2, [r3, #1068]	@ 0x42c
    while ((ret == 0) && (idx < (word32)sz)) {
 80174ea:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80174ec:	2b00      	cmp	r3, #0
 80174ee:	d104      	bne.n	80174fa <DecodeExtKeyUsage+0x182>
 80174f0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80174f2:	68ba      	ldr	r2, [r7, #8]
 80174f4:	429a      	cmp	r2, r3
 80174f6:	f63f af69 	bhi.w	80173cc <DecodeExtKeyUsage+0x54>
        #endif
        }
    }

    return ret;
 80174fa:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 80174fc:	4618      	mov	r0, r3
 80174fe:	3738      	adds	r7, #56	@ 0x38
 8017500:	46bd      	mov	sp, r7
 8017502:	bd80      	pop	{r7, pc}
 8017504:	0803396c 	.word	0x0803396c

08017508 <DecodeNsCertType>:

#ifndef IGNORE_NETSCAPE_CERT_TYPE

static int DecodeNsCertType(const byte* input, int sz, DecodedCert* cert)
{
 8017508:	b580      	push	{r7, lr}
 801750a:	b088      	sub	sp, #32
 801750c:	af02      	add	r7, sp, #8
 801750e:	60f8      	str	r0, [r7, #12]
 8017510:	60b9      	str	r1, [r7, #8]
 8017512:	607a      	str	r2, [r7, #4]
    word32 idx = 0;
 8017514:	2300      	movs	r3, #0
 8017516:	617b      	str	r3, [r7, #20]
    int len = 0;
 8017518:	2300      	movs	r3, #0
 801751a:	613b      	str	r3, [r7, #16]

    WOLFSSL_ENTER("DecodeNsCertType");

    if (CheckBitString(input, &idx, &len, (word32)sz, 0, NULL) < 0)
 801751c:	68bb      	ldr	r3, [r7, #8]
 801751e:	f107 0210 	add.w	r2, r7, #16
 8017522:	f107 0114 	add.w	r1, r7, #20
 8017526:	2000      	movs	r0, #0
 8017528:	9001      	str	r0, [sp, #4]
 801752a:	2000      	movs	r0, #0
 801752c:	9000      	str	r0, [sp, #0]
 801752e:	68f8      	ldr	r0, [r7, #12]
 8017530:	f7fc fd68 	bl	8014004 <CheckBitString>
 8017534:	4603      	mov	r3, r0
 8017536:	2b00      	cmp	r3, #0
 8017538:	da02      	bge.n	8017540 <DecodeNsCertType+0x38>
        return ASN_PARSE_E;
 801753a:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801753e:	e00e      	b.n	801755e <DecodeNsCertType+0x56>

    /* Don't need to worry about unused bits as CheckBitString makes sure
     * they're zero. */
    if (idx < (word32)sz)
 8017540:	697a      	ldr	r2, [r7, #20]
 8017542:	68bb      	ldr	r3, [r7, #8]
 8017544:	429a      	cmp	r2, r3
 8017546:	d208      	bcs.n	801755a <DecodeNsCertType+0x52>
        cert->nsCertType = input[idx];
 8017548:	697b      	ldr	r3, [r7, #20]
 801754a:	68fa      	ldr	r2, [r7, #12]
 801754c:	4413      	add	r3, r2
 801754e:	781a      	ldrb	r2, [r3, #0]
 8017550:	687b      	ldr	r3, [r7, #4]
 8017552:	f883 246c 	strb.w	r2, [r3, #1132]	@ 0x46c
    else
        return ASN_PARSE_E;

    return 0;
 8017556:	2300      	movs	r3, #0
 8017558:	e001      	b.n	801755e <DecodeNsCertType+0x56>
        return ASN_PARSE_E;
 801755a:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
}
 801755e:	4618      	mov	r0, r3
 8017560:	3718      	adds	r7, #24
 8017562:	46bd      	mov	sp, r7
 8017564:	bd80      	pop	{r7, pc}

08017566 <DecodeSubtreeGeneralName>:
 * @return  MEMORY_E when dynamic memory allocation fails.
 * @return  ASN_PARSE_E when SEQUENCE is not found as expected.
 */
static int DecodeSubtreeGeneralName(const byte* input, word32 sz, byte tag,
                                    Base_entry** head, void* heap)
{
 8017566:	b580      	push	{r7, lr}
 8017568:	b08c      	sub	sp, #48	@ 0x30
 801756a:	af02      	add	r7, sp, #8
 801756c:	60f8      	str	r0, [r7, #12]
 801756e:	60b9      	str	r1, [r7, #8]
 8017570:	603b      	str	r3, [r7, #0]
 8017572:	4613      	mov	r3, r2
 8017574:	71fb      	strb	r3, [r7, #7]
    Base_entry* entry = NULL;
 8017576:	2300      	movs	r3, #0
 8017578:	627b      	str	r3, [r7, #36]	@ 0x24
    word32 nameIdx = 0;
 801757a:	2300      	movs	r3, #0
 801757c:	617b      	str	r3, [r7, #20]
    word32 len = sz;
 801757e:	68bb      	ldr	r3, [r7, #8]
 8017580:	623b      	str	r3, [r7, #32]
    int strLen;
    int ret = 0;
 8017582:	2300      	movs	r3, #0
 8017584:	61fb      	str	r3, [r7, #28]

    (void)heap;

    /* if constructed has leading sequence */
    if ((tag & ASN_CONSTRUCTED) == ASN_CONSTRUCTED) {
 8017586:	79fb      	ldrb	r3, [r7, #7]
 8017588:	f003 0320 	and.w	r3, r3, #32
 801758c:	2b00      	cmp	r3, #0
 801758e:	d015      	beq.n	80175bc <DecodeSubtreeGeneralName+0x56>
        ret = GetASN_Sequence(input, &nameIdx, &strLen, sz, 0);
 8017590:	f107 0210 	add.w	r2, r7, #16
 8017594:	f107 0114 	add.w	r1, r7, #20
 8017598:	2300      	movs	r3, #0
 801759a:	9300      	str	r3, [sp, #0]
 801759c:	68bb      	ldr	r3, [r7, #8]
 801759e:	68f8      	ldr	r0, [r7, #12]
 80175a0:	f7fc fb55 	bl	8013c4e <GetASN_Sequence>
 80175a4:	61f8      	str	r0, [r7, #28]
        if (ret < 0) {
 80175a6:	69fb      	ldr	r3, [r7, #28]
 80175a8:	2b00      	cmp	r3, #0
 80175aa:	da03      	bge.n	80175b4 <DecodeSubtreeGeneralName+0x4e>
            ret = ASN_PARSE_E;
 80175ac:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80175b0:	61fb      	str	r3, [r7, #28]
 80175b2:	e003      	b.n	80175bc <DecodeSubtreeGeneralName+0x56>
        }
        else {
            len = (word32)strLen;
 80175b4:	693b      	ldr	r3, [r7, #16]
 80175b6:	623b      	str	r3, [r7, #32]
            ret = 0;
 80175b8:	2300      	movs	r3, #0
 80175ba:	61fb      	str	r3, [r7, #28]
        }
    }
    if (ret == 0) {
 80175bc:	69fb      	ldr	r3, [r7, #28]
 80175be:	2b00      	cmp	r3, #0
 80175c0:	d109      	bne.n	80175d6 <DecodeSubtreeGeneralName+0x70>
        /* TODO: consider one malloc. */
        /* Allocate Base Entry object. */
        entry = (Base_entry*)XMALLOC(sizeof(Base_entry), heap,
 80175c2:	2010      	movs	r0, #16
 80175c4:	f007 fa60 	bl	801ea88 <wolfSSL_Malloc>
 80175c8:	6278      	str	r0, [r7, #36]	@ 0x24
                                     DYNAMIC_TYPE_ALTNAME);
        if (entry == NULL) {
 80175ca:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80175cc:	2b00      	cmp	r3, #0
 80175ce:	d102      	bne.n	80175d6 <DecodeSubtreeGeneralName+0x70>
            ret = MEMORY_E;
 80175d0:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 80175d4:	61fb      	str	r3, [r7, #28]
        }
    }
    if (ret == 0) {
 80175d6:	69fb      	ldr	r3, [r7, #28]
 80175d8:	2b00      	cmp	r3, #0
 80175da:	d116      	bne.n	801760a <DecodeSubtreeGeneralName+0xa4>
        /* Allocate name. */
        entry->name = (char*)XMALLOC(len + 1, heap, DYNAMIC_TYPE_ALTNAME);
 80175dc:	6a3b      	ldr	r3, [r7, #32]
 80175de:	3301      	adds	r3, #1
 80175e0:	4618      	mov	r0, r3
 80175e2:	f007 fa51 	bl	801ea88 <wolfSSL_Malloc>
 80175e6:	4602      	mov	r2, r0
 80175e8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80175ea:	605a      	str	r2, [r3, #4]
        if (entry->name == NULL) {
 80175ec:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80175ee:	685b      	ldr	r3, [r3, #4]
 80175f0:	2b00      	cmp	r3, #0
 80175f2:	d10a      	bne.n	801760a <DecodeSubtreeGeneralName+0xa4>
            XFREE(entry, heap, DYNAMIC_TYPE_ALTNAME);
 80175f4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80175f6:	61bb      	str	r3, [r7, #24]
 80175f8:	69bb      	ldr	r3, [r7, #24]
 80175fa:	2b00      	cmp	r3, #0
 80175fc:	d002      	beq.n	8017604 <DecodeSubtreeGeneralName+0x9e>
 80175fe:	69b8      	ldr	r0, [r7, #24]
 8017600:	f007 fa5e 	bl	801eac0 <wolfSSL_Free>
            ret = MEMORY_E;
 8017604:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8017608:	61fb      	str	r3, [r7, #28]
        }
    }
    if (ret == 0) {
 801760a:	69fb      	ldr	r3, [r7, #28]
 801760c:	2b00      	cmp	r3, #0
 801760e:	d11e      	bne.n	801764e <DecodeSubtreeGeneralName+0xe8>
        /* Store name, size and tag in object. */
        XMEMCPY(entry->name, &input[nameIdx], len);
 8017610:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8017612:	6858      	ldr	r0, [r3, #4]
 8017614:	697b      	ldr	r3, [r7, #20]
 8017616:	68fa      	ldr	r2, [r7, #12]
 8017618:	4413      	add	r3, r2
 801761a:	6a3a      	ldr	r2, [r7, #32]
 801761c:	4619      	mov	r1, r3
 801761e:	f010 ffbd 	bl	802859c <memcpy>
        entry->name[len] = '\0';
 8017622:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8017624:	685a      	ldr	r2, [r3, #4]
 8017626:	6a3b      	ldr	r3, [r7, #32]
 8017628:	4413      	add	r3, r2
 801762a:	2200      	movs	r2, #0
 801762c:	701a      	strb	r2, [r3, #0]
        entry->nameSz = (int)len;
 801762e:	6a3a      	ldr	r2, [r7, #32]
 8017630:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8017632:	609a      	str	r2, [r3, #8]
        entry->type = tag & ASN_TYPE_MASK;
 8017634:	79fb      	ldrb	r3, [r7, #7]
 8017636:	f003 031f 	and.w	r3, r3, #31
 801763a:	b2da      	uxtb	r2, r3
 801763c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801763e:	731a      	strb	r2, [r3, #12]

        /* Put entry at front of linked list. */
        entry->next = *head;
 8017640:	683b      	ldr	r3, [r7, #0]
 8017642:	681a      	ldr	r2, [r3, #0]
 8017644:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8017646:	601a      	str	r2, [r3, #0]
        *head = entry;
 8017648:	683b      	ldr	r3, [r7, #0]
 801764a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801764c:	601a      	str	r2, [r3, #0]
    }

    return ret;
 801764e:	69fb      	ldr	r3, [r7, #28]
}
 8017650:	4618      	mov	r0, r3
 8017652:	3728      	adds	r7, #40	@ 0x28
 8017654:	46bd      	mov	sp, r7
 8017656:	bd80      	pop	{r7, pc}

08017658 <DecodeSubtree>:
 * @return  MEMORY_E when dynamic memory allocation fails.
 * @return  ASN_PARSE_E when SEQUENCE is not found as expected.
 */
static int DecodeSubtree(const byte* input, word32 sz, Base_entry** head,
                         word32 limit, void* heap)
{
 8017658:	b580      	push	{r7, lr}
 801765a:	b090      	sub	sp, #64	@ 0x40
 801765c:	af04      	add	r7, sp, #16
 801765e:	60f8      	str	r0, [r7, #12]
 8017660:	60b9      	str	r1, [r7, #8]
 8017662:	607a      	str	r2, [r7, #4]
 8017664:	603b      	str	r3, [r7, #0]
        idx += (word32)seqLength;
    }

    return ret;
#else
    DECL_ASNGETDATA(dataASN, subTreeASN_Length);
 8017666:	2300      	movs	r3, #0
 8017668:	62fb      	str	r3, [r7, #44]	@ 0x2c
    word32 idx = 0;
 801766a:	2300      	movs	r3, #0
 801766c:	61bb      	str	r3, [r7, #24]
    int ret = 0;
 801766e:	2300      	movs	r3, #0
 8017670:	62bb      	str	r3, [r7, #40]	@ 0x28
    word32 cnt = 0;
 8017672:	2300      	movs	r3, #0
 8017674:	627b      	str	r3, [r7, #36]	@ 0x24

    (void)heap;

    ALLOC_ASNGETDATA(dataASN, subTreeASN_Length, ret, heap);
 8017676:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8017678:	2b00      	cmp	r3, #0
 801767a:	d16b      	bne.n	8017754 <DecodeSubtree+0xfc>
 801767c:	2070      	movs	r0, #112	@ 0x70
 801767e:	f007 fa03 	bl	801ea88 <wolfSSL_Malloc>
 8017682:	62f8      	str	r0, [r7, #44]	@ 0x2c
 8017684:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017686:	2b00      	cmp	r3, #0
 8017688:	d164      	bne.n	8017754 <DecodeSubtree+0xfc>
 801768a:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801768e:	62bb      	str	r3, [r7, #40]	@ 0x28

    /* Process all subtrees. */
    while ((ret == 0) && (idx < (word32)sz)) {
 8017690:	e060      	b.n	8017754 <DecodeSubtree+0xfc>
        byte minVal = 0;
 8017692:	2300      	movs	r3, #0
 8017694:	75fb      	strb	r3, [r7, #23]
        byte maxVal = 0;
 8017696:	2300      	movs	r3, #0
 8017698:	75bb      	strb	r3, [r7, #22]
        if (limit > 0) {
 801769a:	683b      	ldr	r3, [r7, #0]
 801769c:	2b00      	cmp	r3, #0
 801769e:	d00a      	beq.n	80176b6 <DecodeSubtree+0x5e>
            cnt++;
 80176a0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80176a2:	3301      	adds	r3, #1
 80176a4:	627b      	str	r3, [r7, #36]	@ 0x24
            if (cnt > limit) {
 80176a6:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80176a8:	683b      	ldr	r3, [r7, #0]
 80176aa:	429a      	cmp	r2, r3
 80176ac:	d903      	bls.n	80176b6 <DecodeSubtree+0x5e>
                WOLFSSL_MSG("too many name constraints");
                ret = ASN_NAME_INVALID_E;
 80176ae:	f06f 03c5 	mvn.w	r3, #197	@ 0xc5
 80176b2:	62bb      	str	r3, [r7, #40]	@ 0x28
 80176b4:	e055      	b.n	8017762 <DecodeSubtree+0x10a>
        }

        /* Clear dynamic data and set choice for GeneralName and location to
         * store minimum and maximum.
         */
        XMEMSET(dataASN, 0, sizeof(*dataASN) * subTreeASN_Length);
 80176b6:	2270      	movs	r2, #112	@ 0x70
 80176b8:	2100      	movs	r1, #0
 80176ba:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 80176bc:	f010 ff04 	bl	80284c8 <memset>
        GetASN_Choice(&dataASN[SUBTREEASN_IDX_BASE], generalNameChoice);
 80176c0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80176c2:	331c      	adds	r3, #28
 80176c4:	220b      	movs	r2, #11
 80176c6:	761a      	strb	r2, [r3, #24]
 80176c8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80176ca:	331c      	adds	r3, #28
 80176cc:	4a2d      	ldr	r2, [pc, #180]	@ (8017784 <DecodeSubtree+0x12c>)
 80176ce:	609a      	str	r2, [r3, #8]
        GetASN_Int8Bit(&dataASN[SUBTREEASN_IDX_MIN], &minVal);
 80176d0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80176d2:	3338      	adds	r3, #56	@ 0x38
 80176d4:	2201      	movs	r2, #1
 80176d6:	761a      	strb	r2, [r3, #24]
 80176d8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80176da:	3338      	adds	r3, #56	@ 0x38
 80176dc:	f107 0217 	add.w	r2, r7, #23
 80176e0:	609a      	str	r2, [r3, #8]
        GetASN_Int8Bit(&dataASN[SUBTREEASN_IDX_MAX], &maxVal);
 80176e2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80176e4:	3354      	adds	r3, #84	@ 0x54
 80176e6:	2201      	movs	r2, #1
 80176e8:	761a      	strb	r2, [r3, #24]
 80176ea:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80176ec:	3354      	adds	r3, #84	@ 0x54
 80176ee:	f107 0216 	add.w	r2, r7, #22
 80176f2:	609a      	str	r2, [r3, #8]
        /* Parse GeneralSubtree. */
        ret = GetASN_Items(subTreeASN, dataASN, subTreeASN_Length, 0, input,
 80176f4:	68bb      	ldr	r3, [r7, #8]
 80176f6:	9302      	str	r3, [sp, #8]
 80176f8:	f107 0318 	add.w	r3, r7, #24
 80176fc:	9301      	str	r3, [sp, #4]
 80176fe:	68fb      	ldr	r3, [r7, #12]
 8017700:	9300      	str	r3, [sp, #0]
 8017702:	2300      	movs	r3, #0
 8017704:	2204      	movs	r2, #4
 8017706:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8017708:	481f      	ldr	r0, [pc, #124]	@ (8017788 <DecodeSubtree+0x130>)
 801770a:	f7fb fff9 	bl	8013700 <GetASN_Items>
 801770e:	62b8      	str	r0, [r7, #40]	@ 0x28
                           &idx, sz);
        if (ret == 0) {
 8017710:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8017712:	2b00      	cmp	r3, #0
 8017714:	d11e      	bne.n	8017754 <DecodeSubtree+0xfc>
            byte t = dataASN[SUBTREEASN_IDX_BASE].tag;
 8017716:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017718:	331c      	adds	r3, #28
 801771a:	7e5b      	ldrb	r3, [r3, #25]
 801771c:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23

            /* Check GeneralName tag is one of the types we can handle. */
            if (t == (ASN_CONTEXT_SPECIFIC | ASN_DNS_TYPE) ||
 8017720:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 8017724:	2b82      	cmp	r3, #130	@ 0x82
 8017726:	d007      	beq.n	8017738 <DecodeSubtree+0xe0>
 8017728:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 801772c:	2b81      	cmp	r3, #129	@ 0x81
 801772e:	d003      	beq.n	8017738 <DecodeSubtree+0xe0>
                t == (ASN_CONTEXT_SPECIFIC | ASN_RFC822_TYPE) ||
 8017730:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 8017734:	2ba4      	cmp	r3, #164	@ 0xa4
 8017736:	d10d      	bne.n	8017754 <DecodeSubtree+0xfc>
                t == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | ASN_DIR_TYPE)) {
                /* Parse the general name and store a new entry. */
                ret = DecodeSubtreeGeneralName(input +
                    GetASNItem_DataIdx(dataASN[SUBTREEASN_IDX_BASE], input),
 8017738:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801773a:	331c      	adds	r3, #28
                ret = DecodeSubtreeGeneralName(input +
 801773c:	6898      	ldr	r0, [r3, #8]
                    dataASN[SUBTREEASN_IDX_BASE].length, t, head, heap);
 801773e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017740:	331c      	adds	r3, #28
                ret = DecodeSubtreeGeneralName(input +
 8017742:	6859      	ldr	r1, [r3, #4]
 8017744:	f897 2023 	ldrb.w	r2, [r7, #35]	@ 0x23
 8017748:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801774a:	9300      	str	r3, [sp, #0]
 801774c:	687b      	ldr	r3, [r7, #4]
 801774e:	f7ff ff0a 	bl	8017566 <DecodeSubtreeGeneralName>
 8017752:	62b8      	str	r0, [r7, #40]	@ 0x28
    while ((ret == 0) && (idx < (word32)sz)) {
 8017754:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8017756:	2b00      	cmp	r3, #0
 8017758:	d103      	bne.n	8017762 <DecodeSubtree+0x10a>
 801775a:	69bb      	ldr	r3, [r7, #24]
 801775c:	68ba      	ldr	r2, [r7, #8]
 801775e:	429a      	cmp	r2, r3
 8017760:	d897      	bhi.n	8017692 <DecodeSubtree+0x3a>
            }
            /* Skip entry. */
        }
    }

    FREE_ASNGETDATA(dataASN, heap);
 8017762:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017764:	2b00      	cmp	r3, #0
 8017766:	d007      	beq.n	8017778 <DecodeSubtree+0x120>
 8017768:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801776a:	61fb      	str	r3, [r7, #28]
 801776c:	69fb      	ldr	r3, [r7, #28]
 801776e:	2b00      	cmp	r3, #0
 8017770:	d002      	beq.n	8017778 <DecodeSubtree+0x120>
 8017772:	69f8      	ldr	r0, [r7, #28]
 8017774:	f007 f9a4 	bl	801eac0 <wolfSSL_Free>
    return ret;
 8017778:	6abb      	ldr	r3, [r7, #40]	@ 0x28
#endif
}
 801777a:	4618      	mov	r0, r3
 801777c:	3730      	adds	r7, #48	@ 0x30
 801777e:	46bd      	mov	sp, r7
 8017780:	bd80      	pop	{r7, pc}
 8017782:	bf00      	nop
 8017784:	08033910 	.word	0x08033910
 8017788:	08033970 	.word	0x08033970

0801778c <DecodeNameConstraints>:
 *          is invalid.
 * @return  MEMORY_E on dynamic memory allocation failure.
 */
static int DecodeNameConstraints(const byte* input, word32 sz,
    DecodedCert* cert)
{
 801778c:	b580      	push	{r7, lr}
 801778e:	b08c      	sub	sp, #48	@ 0x30
 8017790:	af04      	add	r7, sp, #16
 8017792:	60f8      	str	r0, [r7, #12]
 8017794:	60b9      	str	r1, [r7, #8]
 8017796:	607a      	str	r2, [r7, #4]
        idx += (word32)length;
    }

    return 0;
#else
    DECL_ASNGETDATA(dataASN, nameConstraintsASN_Length);
 8017798:	2300      	movs	r3, #0
 801779a:	61fb      	str	r3, [r7, #28]
    word32 idx = 0;
 801779c:	2300      	movs	r3, #0
 801779e:	613b      	str	r3, [r7, #16]
    int    ret = 0;
 80177a0:	2300      	movs	r3, #0
 80177a2:	61bb      	str	r3, [r7, #24]

    CALLOC_ASNGETDATA(dataASN, nameConstraintsASN_Length, ret, cert->heap);
 80177a4:	69bb      	ldr	r3, [r7, #24]
 80177a6:	2b00      	cmp	r3, #0
 80177a8:	d109      	bne.n	80177be <DecodeNameConstraints+0x32>
 80177aa:	2054      	movs	r0, #84	@ 0x54
 80177ac:	f007 f96c 	bl	801ea88 <wolfSSL_Malloc>
 80177b0:	61f8      	str	r0, [r7, #28]
 80177b2:	69fb      	ldr	r3, [r7, #28]
 80177b4:	2b00      	cmp	r3, #0
 80177b6:	d102      	bne.n	80177be <DecodeNameConstraints+0x32>
 80177b8:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 80177bc:	61bb      	str	r3, [r7, #24]
 80177be:	69bb      	ldr	r3, [r7, #24]
 80177c0:	2b00      	cmp	r3, #0
 80177c2:	d104      	bne.n	80177ce <DecodeNameConstraints+0x42>
 80177c4:	2254      	movs	r2, #84	@ 0x54
 80177c6:	2100      	movs	r1, #0
 80177c8:	69f8      	ldr	r0, [r7, #28]
 80177ca:	f010 fe7d 	bl	80284c8 <memset>

    if (ret == 0) {
 80177ce:	69bb      	ldr	r3, [r7, #24]
 80177d0:	2b00      	cmp	r3, #0
 80177d2:	d10d      	bne.n	80177f0 <DecodeNameConstraints+0x64>
        /* Parse NameConstraints. */
        ret = GetASN_Items(nameConstraintsASN, dataASN,
 80177d4:	68bb      	ldr	r3, [r7, #8]
 80177d6:	9302      	str	r3, [sp, #8]
 80177d8:	f107 0310 	add.w	r3, r7, #16
 80177dc:	9301      	str	r3, [sp, #4]
 80177de:	68fb      	ldr	r3, [r7, #12]
 80177e0:	9300      	str	r3, [sp, #0]
 80177e2:	2301      	movs	r3, #1
 80177e4:	2203      	movs	r2, #3
 80177e6:	69f9      	ldr	r1, [r7, #28]
 80177e8:	4822      	ldr	r0, [pc, #136]	@ (8017874 <DecodeNameConstraints+0xe8>)
 80177ea:	f7fb ff89 	bl	8013700 <GetASN_Items>
 80177ee:	61b8      	str	r0, [r7, #24]
                           nameConstraintsASN_Length, 1, input, &idx, sz);
    }
    if (ret == 0) {
 80177f0:	69bb      	ldr	r3, [r7, #24]
 80177f2:	2b00      	cmp	r3, #0
 80177f4:	d115      	bne.n	8017822 <DecodeNameConstraints+0x96>
        /* If there was a permittedSubtrees then parse it. */
        if (dataASN[NAMECONSTRAINTSASN_IDX_PERMIT].data.ref.data != NULL) {
 80177f6:	69fb      	ldr	r3, [r7, #28]
 80177f8:	331c      	adds	r3, #28
 80177fa:	689b      	ldr	r3, [r3, #8]
 80177fc:	2b00      	cmp	r3, #0
 80177fe:	d010      	beq.n	8017822 <DecodeNameConstraints+0x96>
            ret = DecodeSubtree(
                    dataASN[NAMECONSTRAINTSASN_IDX_PERMIT].data.ref.data,
 8017800:	69fb      	ldr	r3, [r7, #28]
 8017802:	331c      	adds	r3, #28
            ret = DecodeSubtree(
 8017804:	6898      	ldr	r0, [r3, #8]
                    dataASN[NAMECONSTRAINTSASN_IDX_PERMIT].data.ref.length,
 8017806:	69fb      	ldr	r3, [r7, #28]
 8017808:	331c      	adds	r3, #28
            ret = DecodeSubtree(
 801780a:	68d9      	ldr	r1, [r3, #12]
 801780c:	687b      	ldr	r3, [r7, #4]
 801780e:	f103 0238 	add.w	r2, r3, #56	@ 0x38
 8017812:	687b      	ldr	r3, [r7, #4]
 8017814:	f8d3 3370 	ldr.w	r3, [r3, #880]	@ 0x370
 8017818:	9300      	str	r3, [sp, #0]
 801781a:	2380      	movs	r3, #128	@ 0x80
 801781c:	f7ff ff1c 	bl	8017658 <DecodeSubtree>
 8017820:	61b8      	str	r0, [r7, #24]
                    &cert->permittedNames, WOLFSSL_MAX_NAME_CONSTRAINTS,
                    cert->heap);
        }
    }
    if (ret == 0) {
 8017822:	69bb      	ldr	r3, [r7, #24]
 8017824:	2b00      	cmp	r3, #0
 8017826:	d115      	bne.n	8017854 <DecodeNameConstraints+0xc8>
        /* If there was a excludedSubtrees then parse it. */
        if (dataASN[NAMECONSTRAINTSASN_IDX_EXCLUDE].data.ref.data != NULL) {
 8017828:	69fb      	ldr	r3, [r7, #28]
 801782a:	3338      	adds	r3, #56	@ 0x38
 801782c:	689b      	ldr	r3, [r3, #8]
 801782e:	2b00      	cmp	r3, #0
 8017830:	d010      	beq.n	8017854 <DecodeNameConstraints+0xc8>
            ret = DecodeSubtree(
                    dataASN[NAMECONSTRAINTSASN_IDX_EXCLUDE].data.ref.data,
 8017832:	69fb      	ldr	r3, [r7, #28]
 8017834:	3338      	adds	r3, #56	@ 0x38
            ret = DecodeSubtree(
 8017836:	6898      	ldr	r0, [r3, #8]
                    dataASN[NAMECONSTRAINTSASN_IDX_EXCLUDE].data.ref.length,
 8017838:	69fb      	ldr	r3, [r7, #28]
 801783a:	3338      	adds	r3, #56	@ 0x38
            ret = DecodeSubtree(
 801783c:	68d9      	ldr	r1, [r3, #12]
 801783e:	687b      	ldr	r3, [r7, #4]
 8017840:	f103 023c 	add.w	r2, r3, #60	@ 0x3c
 8017844:	687b      	ldr	r3, [r7, #4]
 8017846:	f8d3 3370 	ldr.w	r3, [r3, #880]	@ 0x370
 801784a:	9300      	str	r3, [sp, #0]
 801784c:	2380      	movs	r3, #128	@ 0x80
 801784e:	f7ff ff03 	bl	8017658 <DecodeSubtree>
 8017852:	61b8      	str	r0, [r7, #24]
                    &cert->excludedNames, WOLFSSL_MAX_NAME_CONSTRAINTS,
                    cert->heap);
        }
    }

    FREE_ASNGETDATA(dataASN, cert->heap);
 8017854:	69fb      	ldr	r3, [r7, #28]
 8017856:	2b00      	cmp	r3, #0
 8017858:	d007      	beq.n	801786a <DecodeNameConstraints+0xde>
 801785a:	69fb      	ldr	r3, [r7, #28]
 801785c:	617b      	str	r3, [r7, #20]
 801785e:	697b      	ldr	r3, [r7, #20]
 8017860:	2b00      	cmp	r3, #0
 8017862:	d002      	beq.n	801786a <DecodeNameConstraints+0xde>
 8017864:	6978      	ldr	r0, [r7, #20]
 8017866:	f007 f92b 	bl	801eac0 <wolfSSL_Free>

    return ret;
 801786a:	69bb      	ldr	r3, [r7, #24]
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 801786c:	4618      	mov	r0, r3
 801786e:	3720      	adds	r7, #32
 8017870:	46bd      	mov	sp, r7
 8017872:	bd80      	pop	{r7, pc}
 8017874:	08033980 	.word	0x08033980

08017878 <DecodeExtensionType>:
 * @return  Other negative values on error.
 */
static int DecodeExtensionType(const byte* input, word32 length, word32 oid,
                               byte critical, DecodedCert* cert,
                               int *isUnknownExt)
{
 8017878:	b580      	push	{r7, lr}
 801787a:	b086      	sub	sp, #24
 801787c:	af00      	add	r7, sp, #0
 801787e:	60f8      	str	r0, [r7, #12]
 8017880:	60b9      	str	r1, [r7, #8]
 8017882:	607a      	str	r2, [r7, #4]
 8017884:	70fb      	strb	r3, [r7, #3]
    int ret = 0;
 8017886:	2300      	movs	r3, #0
 8017888:	617b      	str	r3, [r7, #20]
    word32 idx = 0;
 801788a:	2300      	movs	r3, #0
 801788c:	613b      	str	r3, [r7, #16]

    if (isUnknownExt != NULL)
 801788e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8017890:	2b00      	cmp	r3, #0
 8017892:	d002      	beq.n	801789a <DecodeExtensionType+0x22>
        *isUnknownExt = 0;
 8017894:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8017896:	2200      	movs	r2, #0
 8017898:	601a      	str	r2, [r3, #0]

    switch (oid) {
 801789a:	687b      	ldr	r3, [r7, #4]
 801789c:	f240 22f1 	movw	r2, #753	@ 0x2f1
 80178a0:	4293      	cmp	r3, r2
 80178a2:	f000 8243 	beq.w	8017d2c <DecodeExtensionType+0x4b4>
 80178a6:	687b      	ldr	r3, [r7, #4]
 80178a8:	f240 22f1 	movw	r2, #753	@ 0x2f1
 80178ac:	4293      	cmp	r3, r2
 80178ae:	f200 8278 	bhi.w	8017da2 <DecodeExtensionType+0x52a>
 80178b2:	687b      	ldr	r3, [r7, #4]
 80178b4:	2b45      	cmp	r3, #69	@ 0x45
 80178b6:	f000 80c2 	beq.w	8017a3e <DecodeExtensionType+0x1c6>
 80178ba:	687b      	ldr	r3, [r7, #4]
 80178bc:	2b45      	cmp	r3, #69	@ 0x45
 80178be:	f0c0 8270 	bcc.w	8017da2 <DecodeExtensionType+0x52a>
 80178c2:	687b      	ldr	r3, [r7, #4]
 80178c4:	2ba8      	cmp	r3, #168	@ 0xa8
 80178c6:	f200 826c 	bhi.w	8017da2 <DecodeExtensionType+0x52a>
 80178ca:	687b      	ldr	r3, [r7, #4]
 80178cc:	2b80      	cmp	r3, #128	@ 0x80
 80178ce:	f0c0 8268 	bcc.w	8017da2 <DecodeExtensionType+0x52a>
 80178d2:	687b      	ldr	r3, [r7, #4]
 80178d4:	3b80      	subs	r3, #128	@ 0x80
 80178d6:	2b28      	cmp	r3, #40	@ 0x28
 80178d8:	f200 8263 	bhi.w	8017da2 <DecodeExtensionType+0x52a>
 80178dc:	a201      	add	r2, pc, #4	@ (adr r2, 80178e4 <DecodeExtensionType+0x6c>)
 80178de:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80178e2:	bf00      	nop
 80178e4:	08017b67 	.word	0x08017b67
 80178e8:	08017be5 	.word	0x08017be5
 80178ec:	08017da3 	.word	0x08017da3
 80178f0:	08017aad 	.word	0x08017aad
 80178f4:	08017da3 	.word	0x08017da3
 80178f8:	08017989 	.word	0x08017989
 80178fc:	08017da3 	.word	0x08017da3
 8017900:	08017da3 	.word	0x08017da3
 8017904:	08017da3 	.word	0x08017da3
 8017908:	08017da3 	.word	0x08017da3
 801790c:	08017da3 	.word	0x08017da3
 8017910:	08017da3 	.word	0x08017da3
 8017914:	08017da3 	.word	0x08017da3
 8017918:	08017da3 	.word	0x08017da3
 801791c:	08017da3 	.word	0x08017da3
 8017920:	08017da3 	.word	0x08017da3
 8017924:	08017c99 	.word	0x08017c99
 8017928:	080179e5 	.word	0x080179e5
 801792c:	08017bd5 	.word	0x08017bd5
 8017930:	08017da3 	.word	0x08017da3
 8017934:	08017da3 	.word	0x08017da3
 8017938:	08017af9 	.word	0x08017af9
 801793c:	08017d47 	.word	0x08017d47
 8017940:	08017c3f 	.word	0x08017c3f
 8017944:	08017da3 	.word	0x08017da3
 8017948:	08017da3 	.word	0x08017da3
 801794c:	08017da3 	.word	0x08017da3
 8017950:	08017da3 	.word	0x08017da3
 8017954:	08017da3 	.word	0x08017da3
 8017958:	08017da3 	.word	0x08017da3
 801795c:	08017da3 	.word	0x08017da3
 8017960:	08017da3 	.word	0x08017da3
 8017964:	08017da3 	.word	0x08017da3
 8017968:	08017da3 	.word	0x08017da3
 801796c:	08017da3 	.word	0x08017da3
 8017970:	08017da3 	.word	0x08017da3
 8017974:	08017da3 	.word	0x08017da3
 8017978:	08017da3 	.word	0x08017da3
 801797c:	08017da3 	.word	0x08017da3
 8017980:	08017da3 	.word	0x08017da3
 8017984:	08017d07 	.word	0x08017d07
        /* Basic Constraints. */
        case BASIC_CA_OID:
            VERIFY_AND_SET_OID(cert->extBasicConstSet);
 8017988:	6a3b      	ldr	r3, [r7, #32]
 801798a:	f893 34b5 	ldrb.w	r3, [r3, #1205]	@ 0x4b5
 801798e:	f003 0308 	and.w	r3, r3, #8
 8017992:	b2db      	uxtb	r3, r3
 8017994:	2b00      	cmp	r3, #0
 8017996:	d11e      	bne.n	80179d6 <DecodeExtensionType+0x15e>
 8017998:	6a3a      	ldr	r2, [r7, #32]
 801799a:	f892 34b5 	ldrb.w	r3, [r2, #1205]	@ 0x4b5
 801799e:	f043 0308 	orr.w	r3, r3, #8
 80179a2:	f882 34b5 	strb.w	r3, [r2, #1205]	@ 0x4b5
            cert->extBasicConstCrit = critical ? 1 : 0;
 80179a6:	78fb      	ldrb	r3, [r7, #3]
 80179a8:	2b00      	cmp	r3, #0
 80179aa:	bf14      	ite	ne
 80179ac:	2301      	movne	r3, #1
 80179ae:	2300      	moveq	r3, #0
 80179b0:	b2d9      	uxtb	r1, r3
 80179b2:	6a3a      	ldr	r2, [r7, #32]
 80179b4:	f892 34b6 	ldrb.w	r3, [r2, #1206]	@ 0x4b6
 80179b8:	f361 1304 	bfi	r3, r1, #4, #1
 80179bc:	f882 34b6 	strb.w	r3, [r2, #1206]	@ 0x4b6
            if (DecodeBasicCaConstraint(input, (int)length, cert) < 0) {
 80179c0:	68bb      	ldr	r3, [r7, #8]
 80179c2:	6a3a      	ldr	r2, [r7, #32]
 80179c4:	4619      	mov	r1, r3
 80179c6:	68f8      	ldr	r0, [r7, #12]
 80179c8:	f7ff f980 	bl	8016ccc <DecodeBasicCaConstraint>
 80179cc:	4603      	mov	r3, r0
 80179ce:	2b00      	cmp	r3, #0
 80179d0:	f280 81f4 	bge.w	8017dbc <DecodeExtensionType+0x544>
 80179d4:	e002      	b.n	80179dc <DecodeExtensionType+0x164>
            VERIFY_AND_SET_OID(cert->extBasicConstSet);
 80179d6:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 80179da:	e207      	b.n	8017dec <DecodeExtensionType+0x574>
                ret = ASN_PARSE_E;
 80179dc:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80179e0:	617b      	str	r3, [r7, #20]
            }
            break;
 80179e2:	e1eb      	b.n	8017dbc <DecodeExtensionType+0x544>

        /* CRL Distribution point. */
        case CRL_DIST_OID:
            VERIFY_AND_SET_OID(cert->extCRLdistSet);
 80179e4:	6a3b      	ldr	r3, [r7, #32]
 80179e6:	f893 34b5 	ldrb.w	r3, [r3, #1205]	@ 0x4b5
 80179ea:	f003 0302 	and.w	r3, r3, #2
 80179ee:	b2db      	uxtb	r3, r3
 80179f0:	2b00      	cmp	r3, #0
 80179f2:	d11d      	bne.n	8017a30 <DecodeExtensionType+0x1b8>
 80179f4:	6a3a      	ldr	r2, [r7, #32]
 80179f6:	f892 34b5 	ldrb.w	r3, [r2, #1205]	@ 0x4b5
 80179fa:	f043 0302 	orr.w	r3, r3, #2
 80179fe:	f882 34b5 	strb.w	r3, [r2, #1205]	@ 0x4b5
            cert->extCRLdistCrit = critical ? 1 : 0;
 8017a02:	78fb      	ldrb	r3, [r7, #3]
 8017a04:	2b00      	cmp	r3, #0
 8017a06:	bf14      	ite	ne
 8017a08:	2301      	movne	r3, #1
 8017a0a:	2300      	moveq	r3, #0
 8017a0c:	b2d9      	uxtb	r1, r3
 8017a0e:	6a3a      	ldr	r2, [r7, #32]
 8017a10:	f892 34b6 	ldrb.w	r3, [r2, #1206]	@ 0x4b6
 8017a14:	f361 0382 	bfi	r3, r1, #2, #1
 8017a18:	f882 34b6 	strb.w	r3, [r2, #1206]	@ 0x4b6
            if (DecodeCrlDist(input, length, cert) < 0) {
 8017a1c:	6a3a      	ldr	r2, [r7, #32]
 8017a1e:	68b9      	ldr	r1, [r7, #8]
 8017a20:	68f8      	ldr	r0, [r7, #12]
 8017a22:	f7ff fa63 	bl	8016eec <DecodeCrlDist>
 8017a26:	4603      	mov	r3, r0
 8017a28:	2b00      	cmp	r3, #0
 8017a2a:	f280 81c9 	bge.w	8017dc0 <DecodeExtensionType+0x548>
 8017a2e:	e002      	b.n	8017a36 <DecodeExtensionType+0x1be>
            VERIFY_AND_SET_OID(cert->extCRLdistSet);
 8017a30:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 8017a34:	e1da      	b.n	8017dec <DecodeExtensionType+0x574>
                ret = ASN_PARSE_E;
 8017a36:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8017a3a:	617b      	str	r3, [r7, #20]
            }
            break;
 8017a3c:	e1c0      	b.n	8017dc0 <DecodeExtensionType+0x548>

        /* Authority information access. */
        case AUTH_INFO_OID:
            VERIFY_AND_SET_OID(cert->extAuthInfoSet);
 8017a3e:	6a3b      	ldr	r3, [r7, #32]
 8017a40:	f893 34b5 	ldrb.w	r3, [r3, #1205]	@ 0x4b5
 8017a44:	f003 0304 	and.w	r3, r3, #4
 8017a48:	b2db      	uxtb	r3, r3
 8017a4a:	2b00      	cmp	r3, #0
 8017a4c:	d117      	bne.n	8017a7e <DecodeExtensionType+0x206>
 8017a4e:	6a3a      	ldr	r2, [r7, #32]
 8017a50:	f892 34b5 	ldrb.w	r3, [r2, #1205]	@ 0x4b5
 8017a54:	f043 0304 	orr.w	r3, r3, #4
 8017a58:	f882 34b5 	strb.w	r3, [r2, #1205]	@ 0x4b5
            cert->extAuthInfoCrit = critical ? 1 : 0;
 8017a5c:	78fb      	ldrb	r3, [r7, #3]
 8017a5e:	2b00      	cmp	r3, #0
 8017a60:	bf14      	ite	ne
 8017a62:	2301      	movne	r3, #1
 8017a64:	2300      	moveq	r3, #0
 8017a66:	b2d9      	uxtb	r1, r3
 8017a68:	6a3a      	ldr	r2, [r7, #32]
 8017a6a:	f892 34b6 	ldrb.w	r3, [r2, #1206]	@ 0x4b6
 8017a6e:	f361 03c3 	bfi	r3, r1, #3, #1
 8017a72:	f882 34b6 	strb.w	r3, [r2, #1206]	@ 0x4b6
        #ifndef WOLFSSL_ALLOW_CRIT_AIA
            /* This check is added due to RFC 5280 section 4.2.2.1
            * stating that conforming CA's must mark this extension
            * as non-critical. When parsing extensions check that
            * certificate was made in compliance with this. */
            if (critical) {
 8017a76:	78fb      	ldrb	r3, [r7, #3]
 8017a78:	2b00      	cmp	r3, #0
 8017a7a:	d006      	beq.n	8017a8a <DecodeExtensionType+0x212>
 8017a7c:	e002      	b.n	8017a84 <DecodeExtensionType+0x20c>
            VERIFY_AND_SET_OID(cert->extAuthInfoSet);
 8017a7e:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 8017a82:	e1b3      	b.n	8017dec <DecodeExtensionType+0x574>
                WOLFSSL_MSG("Critical Authority Information Access is not"
                            "allowed");
                WOLFSSL_MSG("Use macro WOLFSSL_ALLOW_CRIT_AIA if wanted");
                ret = ASN_CRIT_EXT_E;
 8017a84:	f06f 039f 	mvn.w	r3, #159	@ 0x9f
 8017a88:	617b      	str	r3, [r7, #20]
            }
        #endif
            if ((ret == 0) && (DecodeAuthInfo(input, length, cert) < 0)) {
 8017a8a:	697b      	ldr	r3, [r7, #20]
 8017a8c:	2b00      	cmp	r3, #0
 8017a8e:	f040 8199 	bne.w	8017dc4 <DecodeExtensionType+0x54c>
 8017a92:	6a3a      	ldr	r2, [r7, #32]
 8017a94:	68b9      	ldr	r1, [r7, #8]
 8017a96:	68f8      	ldr	r0, [r7, #12]
 8017a98:	f7ff fa98 	bl	8016fcc <DecodeAuthInfo>
 8017a9c:	4603      	mov	r3, r0
 8017a9e:	2b00      	cmp	r3, #0
 8017aa0:	f280 8190 	bge.w	8017dc4 <DecodeExtensionType+0x54c>
                ret = ASN_PARSE_E;
 8017aa4:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8017aa8:	617b      	str	r3, [r7, #20]
            }
            break;
 8017aaa:	e18b      	b.n	8017dc4 <DecodeExtensionType+0x54c>

        /* Subject alternative name. */
        case ALT_NAMES_OID:
            VERIFY_AND_SET_OID(cert->extSubjAltNameSet);
 8017aac:	6a3b      	ldr	r3, [r7, #32]
 8017aae:	f893 34b5 	ldrb.w	r3, [r3, #1205]	@ 0x4b5
 8017ab2:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 8017ab6:	b2db      	uxtb	r3, r3
 8017ab8:	2b00      	cmp	r3, #0
 8017aba:	d11a      	bne.n	8017af2 <DecodeExtensionType+0x27a>
 8017abc:	6a3a      	ldr	r2, [r7, #32]
 8017abe:	f892 34b5 	ldrb.w	r3, [r2, #1205]	@ 0x4b5
 8017ac2:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8017ac6:	f882 34b5 	strb.w	r3, [r2, #1205]	@ 0x4b5
            cert->extSubjAltNameCrit = critical ? 1 : 0;
 8017aca:	78fb      	ldrb	r3, [r7, #3]
 8017acc:	2b00      	cmp	r3, #0
 8017ace:	bf14      	ite	ne
 8017ad0:	2301      	movne	r3, #1
 8017ad2:	2300      	moveq	r3, #0
 8017ad4:	b2d9      	uxtb	r1, r3
 8017ad6:	6a3a      	ldr	r2, [r7, #32]
 8017ad8:	f892 34b6 	ldrb.w	r3, [r2, #1206]	@ 0x4b6
 8017adc:	f361 1386 	bfi	r3, r1, #6, #1
 8017ae0:	f882 34b6 	strb.w	r3, [r2, #1206]	@ 0x4b6
            ret = DecodeAltNames(input, length, cert);
 8017ae4:	6a3a      	ldr	r2, [r7, #32]
 8017ae6:	68b9      	ldr	r1, [r7, #8]
 8017ae8:	68f8      	ldr	r0, [r7, #12]
 8017aea:	f7ff f86d 	bl	8016bc8 <DecodeAltNames>
 8017aee:	6178      	str	r0, [r7, #20]
            break;
 8017af0:	e17b      	b.n	8017dea <DecodeExtensionType+0x572>
            VERIFY_AND_SET_OID(cert->extSubjAltNameSet);
 8017af2:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 8017af6:	e179      	b.n	8017dec <DecodeExtensionType+0x574>

        /* Authority Key Identifier. */
        case AUTH_KEY_OID:
            VERIFY_AND_SET_OID(cert->extAuthKeyIdSet);
 8017af8:	6a3b      	ldr	r3, [r7, #32]
 8017afa:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 8017afe:	f003 0304 	and.w	r3, r3, #4
 8017b02:	b2db      	uxtb	r3, r3
 8017b04:	2b00      	cmp	r3, #0
 8017b06:	d117      	bne.n	8017b38 <DecodeExtensionType+0x2c0>
 8017b08:	6a3a      	ldr	r2, [r7, #32]
 8017b0a:	f892 34b4 	ldrb.w	r3, [r2, #1204]	@ 0x4b4
 8017b0e:	f043 0304 	orr.w	r3, r3, #4
 8017b12:	f882 34b4 	strb.w	r3, [r2, #1204]	@ 0x4b4
            cert->extAuthKeyIdCrit = critical ? 1 : 0;
 8017b16:	78fb      	ldrb	r3, [r7, #3]
 8017b18:	2b00      	cmp	r3, #0
 8017b1a:	bf14      	ite	ne
 8017b1c:	2301      	movne	r3, #1
 8017b1e:	2300      	moveq	r3, #0
 8017b20:	b2d9      	uxtb	r1, r3
 8017b22:	6a3a      	ldr	r2, [r7, #32]
 8017b24:	f892 34b6 	ldrb.w	r3, [r2, #1206]	@ 0x4b6
 8017b28:	f361 13c7 	bfi	r3, r1, #7, #1
 8017b2c:	f882 34b6 	strb.w	r3, [r2, #1206]	@ 0x4b6
        #ifndef WOLFSSL_ALLOW_CRIT_AKID
            /* This check is added due to RFC 5280 section 4.2.1.1
             * stating that conforming CA's must mark this extension
             * as non-critical. When parsing extensions check that
             * certificate was made in compliance with this. */
            if (critical) {
 8017b30:	78fb      	ldrb	r3, [r7, #3]
 8017b32:	2b00      	cmp	r3, #0
 8017b34:	d006      	beq.n	8017b44 <DecodeExtensionType+0x2cc>
 8017b36:	e002      	b.n	8017b3e <DecodeExtensionType+0x2c6>
            VERIFY_AND_SET_OID(cert->extAuthKeyIdSet);
 8017b38:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 8017b3c:	e156      	b.n	8017dec <DecodeExtensionType+0x574>
                WOLFSSL_MSG("Critical Auth Key ID is not allowed");
                WOLFSSL_MSG("Use macro WOLFSSL_ALLOW_CRIT_AKID if wanted");
                ret = ASN_CRIT_EXT_E;
 8017b3e:	f06f 039f 	mvn.w	r3, #159	@ 0x9f
 8017b42:	617b      	str	r3, [r7, #20]
            }
        #endif
            if ((ret == 0) && (DecodeAuthKeyId(input, length, cert) < 0)) {
 8017b44:	697b      	ldr	r3, [r7, #20]
 8017b46:	2b00      	cmp	r3, #0
 8017b48:	f040 813e 	bne.w	8017dc8 <DecodeExtensionType+0x550>
 8017b4c:	6a3a      	ldr	r2, [r7, #32]
 8017b4e:	68b9      	ldr	r1, [r7, #8]
 8017b50:	68f8      	ldr	r0, [r7, #12]
 8017b52:	f7ff fab7 	bl	80170c4 <DecodeAuthKeyId>
 8017b56:	4603      	mov	r3, r0
 8017b58:	2b00      	cmp	r3, #0
 8017b5a:	f280 8135 	bge.w	8017dc8 <DecodeExtensionType+0x550>
                ret = ASN_PARSE_E;
 8017b5e:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8017b62:	617b      	str	r3, [r7, #20]
            }
            break;
 8017b64:	e130      	b.n	8017dc8 <DecodeExtensionType+0x550>

        /* Subject Key Identifier. */
        case SUBJ_KEY_OID:
            VERIFY_AND_SET_OID(cert->extSubjKeyIdSet);
 8017b66:	6a3b      	ldr	r3, [r7, #32]
 8017b68:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 8017b6c:	f003 0302 	and.w	r3, r3, #2
 8017b70:	b2db      	uxtb	r3, r3
 8017b72:	2b00      	cmp	r3, #0
 8017b74:	d117      	bne.n	8017ba6 <DecodeExtensionType+0x32e>
 8017b76:	6a3a      	ldr	r2, [r7, #32]
 8017b78:	f892 34b4 	ldrb.w	r3, [r2, #1204]	@ 0x4b4
 8017b7c:	f043 0302 	orr.w	r3, r3, #2
 8017b80:	f882 34b4 	strb.w	r3, [r2, #1204]	@ 0x4b4
            cert->extSubjKeyIdCrit = critical ? 1 : 0;
 8017b84:	78fb      	ldrb	r3, [r7, #3]
 8017b86:	2b00      	cmp	r3, #0
 8017b88:	bf14      	ite	ne
 8017b8a:	2301      	movne	r3, #1
 8017b8c:	2300      	moveq	r3, #0
 8017b8e:	b2d9      	uxtb	r1, r3
 8017b90:	6a3a      	ldr	r2, [r7, #32]
 8017b92:	f892 34b7 	ldrb.w	r3, [r2, #1207]	@ 0x4b7
 8017b96:	f361 0341 	bfi	r3, r1, #1, #1
 8017b9a:	f882 34b7 	strb.w	r3, [r2, #1207]	@ 0x4b7
        #ifndef WOLFSSL_ALLOW_CRIT_SKID
            /* This check is added due to RFC 5280 section 4.2.1.2
             * stating that conforming CA's must mark this extension
             * as non-critical. When parsing extensions check that
             * certificate was made in compliance with this. */
            if (critical) {
 8017b9e:	78fb      	ldrb	r3, [r7, #3]
 8017ba0:	2b00      	cmp	r3, #0
 8017ba2:	d006      	beq.n	8017bb2 <DecodeExtensionType+0x33a>
 8017ba4:	e002      	b.n	8017bac <DecodeExtensionType+0x334>
            VERIFY_AND_SET_OID(cert->extSubjKeyIdSet);
 8017ba6:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 8017baa:	e11f      	b.n	8017dec <DecodeExtensionType+0x574>
                WOLFSSL_MSG("Critical Subject Key ID is not allowed");
                WOLFSSL_MSG("Use macro WOLFSSL_ALLOW_CRIT_SKID if wanted");
                ret = ASN_CRIT_EXT_E;
 8017bac:	f06f 039f 	mvn.w	r3, #159	@ 0x9f
 8017bb0:	617b      	str	r3, [r7, #20]
            }
        #endif

            if ((ret == 0) && (DecodeSubjKeyId(input, length, cert) < 0)) {
 8017bb2:	697b      	ldr	r3, [r7, #20]
 8017bb4:	2b00      	cmp	r3, #0
 8017bb6:	f040 8109 	bne.w	8017dcc <DecodeExtensionType+0x554>
 8017bba:	6a3a      	ldr	r2, [r7, #32]
 8017bbc:	68b9      	ldr	r1, [r7, #8]
 8017bbe:	68f8      	ldr	r0, [r7, #12]
 8017bc0:	f7ff fb50 	bl	8017264 <DecodeSubjKeyId>
 8017bc4:	4603      	mov	r3, r0
 8017bc6:	2b00      	cmp	r3, #0
 8017bc8:	f280 8100 	bge.w	8017dcc <DecodeExtensionType+0x554>
                ret = ASN_PARSE_E;
 8017bcc:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8017bd0:	617b      	str	r3, [r7, #20]
            }
            break;
 8017bd2:	e0fb      	b.n	8017dcc <DecodeExtensionType+0x554>
                ret = ASN_PARSE_E;
            }
        #else
            WOLFSSL_MSG("Certificate Policy extension not supported.");
            #ifndef WOLFSSL_NO_ASN_STRICT
            if (critical) {
 8017bd4:	78fb      	ldrb	r3, [r7, #3]
 8017bd6:	2b00      	cmp	r3, #0
 8017bd8:	f000 80fa 	beq.w	8017dd0 <DecodeExtensionType+0x558>
                WOLFSSL_ERROR_VERBOSE(ASN_CRIT_EXT_E);
                ret = ASN_CRIT_EXT_E;
 8017bdc:	f06f 039f 	mvn.w	r3, #159	@ 0x9f
 8017be0:	617b      	str	r3, [r7, #20]
            }
            #endif
        #endif
            break;
 8017be2:	e0f5      	b.n	8017dd0 <DecodeExtensionType+0x558>

        /* Key usage. */
        case KEY_USAGE_OID:
            VERIFY_AND_SET_OID(cert->extKeyUsageSet);
 8017be4:	6a3b      	ldr	r3, [r7, #32]
 8017be6:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 8017bea:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 8017bee:	b2db      	uxtb	r3, r3
 8017bf0:	2b00      	cmp	r3, #0
 8017bf2:	d11d      	bne.n	8017c30 <DecodeExtensionType+0x3b8>
 8017bf4:	6a3a      	ldr	r2, [r7, #32]
 8017bf6:	f892 34b4 	ldrb.w	r3, [r2, #1204]	@ 0x4b4
 8017bfa:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8017bfe:	f882 34b4 	strb.w	r3, [r2, #1204]	@ 0x4b4
            cert->extKeyUsageCrit = critical ? 1 : 0;
 8017c02:	78fb      	ldrb	r3, [r7, #3]
 8017c04:	2b00      	cmp	r3, #0
 8017c06:	bf14      	ite	ne
 8017c08:	2301      	movne	r3, #1
 8017c0a:	2300      	moveq	r3, #0
 8017c0c:	b2d9      	uxtb	r1, r3
 8017c0e:	6a3a      	ldr	r2, [r7, #32]
 8017c10:	f892 34b7 	ldrb.w	r3, [r2, #1207]	@ 0x4b7
 8017c14:	f361 0382 	bfi	r3, r1, #2, #1
 8017c18:	f882 34b7 	strb.w	r3, [r2, #1207]	@ 0x4b7
            if (DecodeKeyUsage(input, length, cert) < 0) {
 8017c1c:	6a3a      	ldr	r2, [r7, #32]
 8017c1e:	68b9      	ldr	r1, [r7, #8]
 8017c20:	68f8      	ldr	r0, [r7, #12]
 8017c22:	f7ff fb5b 	bl	80172dc <DecodeKeyUsage>
 8017c26:	4603      	mov	r3, r0
 8017c28:	2b00      	cmp	r3, #0
 8017c2a:	f280 80d3 	bge.w	8017dd4 <DecodeExtensionType+0x55c>
 8017c2e:	e002      	b.n	8017c36 <DecodeExtensionType+0x3be>
            VERIFY_AND_SET_OID(cert->extKeyUsageSet);
 8017c30:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 8017c34:	e0da      	b.n	8017dec <DecodeExtensionType+0x574>
                ret = ASN_PARSE_E;
 8017c36:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8017c3a:	617b      	str	r3, [r7, #20]
            }
            break;
 8017c3c:	e0ca      	b.n	8017dd4 <DecodeExtensionType+0x55c>

        /* Extended key usage. */
        case EXT_KEY_USAGE_OID:
            VERIFY_AND_SET_OID(cert->extExtKeyUsageSet);
 8017c3e:	6a3b      	ldr	r3, [r7, #32]
 8017c40:	f893 34b5 	ldrb.w	r3, [r3, #1205]	@ 0x4b5
 8017c44:	f003 0301 	and.w	r3, r3, #1
 8017c48:	b2db      	uxtb	r3, r3
 8017c4a:	2b00      	cmp	r3, #0
 8017c4c:	d11d      	bne.n	8017c8a <DecodeExtensionType+0x412>
 8017c4e:	6a3a      	ldr	r2, [r7, #32]
 8017c50:	f892 34b5 	ldrb.w	r3, [r2, #1205]	@ 0x4b5
 8017c54:	f043 0301 	orr.w	r3, r3, #1
 8017c58:	f882 34b5 	strb.w	r3, [r2, #1205]	@ 0x4b5
            cert->extExtKeyUsageCrit = critical ? 1 : 0;
 8017c5c:	78fb      	ldrb	r3, [r7, #3]
 8017c5e:	2b00      	cmp	r3, #0
 8017c60:	bf14      	ite	ne
 8017c62:	2301      	movne	r3, #1
 8017c64:	2300      	moveq	r3, #0
 8017c66:	b2d9      	uxtb	r1, r3
 8017c68:	6a3a      	ldr	r2, [r7, #32]
 8017c6a:	f892 34b7 	ldrb.w	r3, [r2, #1207]	@ 0x4b7
 8017c6e:	f361 03c3 	bfi	r3, r1, #3, #1
 8017c72:	f882 34b7 	strb.w	r3, [r2, #1207]	@ 0x4b7
            if (DecodeExtKeyUsage(input, length, cert) < 0) {
 8017c76:	6a3a      	ldr	r2, [r7, #32]
 8017c78:	68b9      	ldr	r1, [r7, #8]
 8017c7a:	68f8      	ldr	r0, [r7, #12]
 8017c7c:	f7ff fb7c 	bl	8017378 <DecodeExtKeyUsage>
 8017c80:	4603      	mov	r3, r0
 8017c82:	2b00      	cmp	r3, #0
 8017c84:	f280 80a8 	bge.w	8017dd8 <DecodeExtensionType+0x560>
 8017c88:	e002      	b.n	8017c90 <DecodeExtensionType+0x418>
            VERIFY_AND_SET_OID(cert->extExtKeyUsageSet);
 8017c8a:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 8017c8e:	e0ad      	b.n	8017dec <DecodeExtensionType+0x574>
                ret = ASN_PARSE_E;
 8017c90:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8017c94:	617b      	str	r3, [r7, #20]
            }
            break;
 8017c96:	e09f      	b.n	8017dd8 <DecodeExtensionType+0x560>
        case NAME_CONS_OID:
        #ifndef WOLFSSL_NO_ASN_STRICT
            /* Verify RFC 5280 Sec 4.2.1.10 rule:
                "The name constraints extension,
                which MUST be used only in a CA certificate" */
            if (!cert->isCA) {
 8017c98:	6a3b      	ldr	r3, [r7, #32]
 8017c9a:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 8017c9e:	f003 0310 	and.w	r3, r3, #16
 8017ca2:	b2db      	uxtb	r3, r3
 8017ca4:	2b00      	cmp	r3, #0
 8017ca6:	d102      	bne.n	8017cae <DecodeExtensionType+0x436>
                WOLFSSL_MSG("Name constraints allowed only for CA certs");
                WOLFSSL_ERROR_VERBOSE(ASN_NAME_INVALID_E);
                ret = ASN_NAME_INVALID_E;
 8017ca8:	f06f 03c5 	mvn.w	r3, #197	@ 0xc5
 8017cac:	617b      	str	r3, [r7, #20]
            }
        #endif
            VERIFY_AND_SET_OID(cert->extNameConstraintSet);
 8017cae:	6a3b      	ldr	r3, [r7, #32]
 8017cb0:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 8017cb4:	f003 0308 	and.w	r3, r3, #8
 8017cb8:	b2db      	uxtb	r3, r3
 8017cba:	2b00      	cmp	r3, #0
 8017cbc:	d11c      	bne.n	8017cf8 <DecodeExtensionType+0x480>
 8017cbe:	6a3a      	ldr	r2, [r7, #32]
 8017cc0:	f892 34b4 	ldrb.w	r3, [r2, #1204]	@ 0x4b4
 8017cc4:	f043 0308 	orr.w	r3, r3, #8
 8017cc8:	f882 34b4 	strb.w	r3, [r2, #1204]	@ 0x4b4
            cert->extNameConstraintCrit = critical ? 1 : 0;
 8017ccc:	78fb      	ldrb	r3, [r7, #3]
 8017cce:	2b00      	cmp	r3, #0
 8017cd0:	bf14      	ite	ne
 8017cd2:	2301      	movne	r3, #1
 8017cd4:	2300      	moveq	r3, #0
 8017cd6:	b2d9      	uxtb	r1, r3
 8017cd8:	6a3a      	ldr	r2, [r7, #32]
 8017cda:	f892 34b7 	ldrb.w	r3, [r2, #1207]	@ 0x4b7
 8017cde:	f361 0300 	bfi	r3, r1, #0, #1
 8017ce2:	f882 34b7 	strb.w	r3, [r2, #1207]	@ 0x4b7
            if (DecodeNameConstraints(input, length, cert) < 0) {
 8017ce6:	6a3a      	ldr	r2, [r7, #32]
 8017ce8:	68b9      	ldr	r1, [r7, #8]
 8017cea:	68f8      	ldr	r0, [r7, #12]
 8017cec:	f7ff fd4e 	bl	801778c <DecodeNameConstraints>
 8017cf0:	4603      	mov	r3, r0
 8017cf2:	2b00      	cmp	r3, #0
 8017cf4:	da72      	bge.n	8017ddc <DecodeExtensionType+0x564>
 8017cf6:	e002      	b.n	8017cfe <DecodeExtensionType+0x486>
            VERIFY_AND_SET_OID(cert->extNameConstraintSet);
 8017cf8:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 8017cfc:	e076      	b.n	8017dec <DecodeExtensionType+0x574>
                ret = ASN_PARSE_E;
 8017cfe:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8017d02:	617b      	str	r3, [r7, #20]
            }
            break;
 8017d04:	e06a      	b.n	8017ddc <DecodeExtensionType+0x564>
        #endif /* IGNORE_NAME_CONSTRAINTS */

        /* Inhibit anyPolicy. */
        case INHIBIT_ANY_OID:
            VERIFY_AND_SET_OID(cert->inhibitAnyOidSet);
 8017d06:	6a3b      	ldr	r3, [r7, #32]
 8017d08:	f893 34b6 	ldrb.w	r3, [r3, #1206]	@ 0x4b6
 8017d0c:	f003 0301 	and.w	r3, r3, #1
 8017d10:	b2db      	uxtb	r3, r3
 8017d12:	2b00      	cmp	r3, #0
 8017d14:	d107      	bne.n	8017d26 <DecodeExtensionType+0x4ae>
 8017d16:	6a3a      	ldr	r2, [r7, #32]
 8017d18:	f892 34b6 	ldrb.w	r3, [r2, #1206]	@ 0x4b6
 8017d1c:	f043 0301 	orr.w	r3, r3, #1
 8017d20:	f882 34b6 	strb.w	r3, [r2, #1206]	@ 0x4b6
            WOLFSSL_MSG("Inhibit anyPolicy extension not supported yet.");
            break;
 8017d24:	e061      	b.n	8017dea <DecodeExtensionType+0x572>
            VERIFY_AND_SET_OID(cert->inhibitAnyOidSet);
 8017d26:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 8017d2a:	e05f      	b.n	8017dec <DecodeExtensionType+0x574>

   #ifndef IGNORE_NETSCAPE_CERT_TYPE
        /* Netscape's certificate type. */
        case NETSCAPE_CT_OID:
            if (DecodeNsCertType(input, (int)length, cert) < 0)
 8017d2c:	68bb      	ldr	r3, [r7, #8]
 8017d2e:	6a3a      	ldr	r2, [r7, #32]
 8017d30:	4619      	mov	r1, r3
 8017d32:	68f8      	ldr	r0, [r7, #12]
 8017d34:	f7ff fbe8 	bl	8017508 <DecodeNsCertType>
 8017d38:	4603      	mov	r3, r0
 8017d3a:	2b00      	cmp	r3, #0
 8017d3c:	da50      	bge.n	8017de0 <DecodeExtensionType+0x568>
                ret = ASN_PARSE_E;
 8017d3e:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8017d42:	617b      	str	r3, [r7, #20]
            break;
 8017d44:	e04c      	b.n	8017de0 <DecodeExtensionType+0x568>
                ret = ASN_PARSE_E;
            }
            break;
    #endif
        case POLICY_CONST_OID:
            VERIFY_AND_SET_OID(cert->extPolicyConstSet);
 8017d46:	6a3b      	ldr	r3, [r7, #32]
 8017d48:	f893 34b5 	ldrb.w	r3, [r3, #1205]	@ 0x4b5
 8017d4c:	f003 0310 	and.w	r3, r3, #16
 8017d50:	b2db      	uxtb	r3, r3
 8017d52:	2b00      	cmp	r3, #0
 8017d54:	d11f      	bne.n	8017d96 <DecodeExtensionType+0x51e>
 8017d56:	6a3a      	ldr	r2, [r7, #32]
 8017d58:	f892 34b5 	ldrb.w	r3, [r2, #1205]	@ 0x4b5
 8017d5c:	f043 0310 	orr.w	r3, r3, #16
 8017d60:	f882 34b5 	strb.w	r3, [r2, #1205]	@ 0x4b5
            cert->extPolicyConstCrit = critical ? 1 : 0;
 8017d64:	78fb      	ldrb	r3, [r7, #3]
 8017d66:	2b00      	cmp	r3, #0
 8017d68:	bf14      	ite	ne
 8017d6a:	2301      	movne	r3, #1
 8017d6c:	2300      	moveq	r3, #0
 8017d6e:	b2d9      	uxtb	r1, r3
 8017d70:	6a3a      	ldr	r2, [r7, #32]
 8017d72:	f892 34b6 	ldrb.w	r3, [r2, #1206]	@ 0x4b6
 8017d76:	f361 1345 	bfi	r3, r1, #5, #1
 8017d7a:	f882 34b6 	strb.w	r3, [r2, #1206]	@ 0x4b6
            if (DecodePolicyConstraints(&input[idx], (int)length, cert) < 0)
 8017d7e:	68fa      	ldr	r2, [r7, #12]
 8017d80:	693b      	ldr	r3, [r7, #16]
 8017d82:	4413      	add	r3, r2
 8017d84:	68b9      	ldr	r1, [r7, #8]
 8017d86:	6a3a      	ldr	r2, [r7, #32]
 8017d88:	4618      	mov	r0, r3
 8017d8a:	f7ff f841 	bl	8016e10 <DecodePolicyConstraints>
 8017d8e:	4603      	mov	r3, r0
 8017d90:	2b00      	cmp	r3, #0
 8017d92:	da27      	bge.n	8017de4 <DecodeExtensionType+0x56c>
 8017d94:	e002      	b.n	8017d9c <DecodeExtensionType+0x524>
            VERIFY_AND_SET_OID(cert->extPolicyConstSet);
 8017d96:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 8017d9a:	e027      	b.n	8017dec <DecodeExtensionType+0x574>
                return ASN_PARSE_E;
 8017d9c:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8017da0:	e024      	b.n	8017dec <DecodeExtensionType+0x574>
            if (DecodeAltSigVal(&input[idx], length, cert) < 0)
                return ASN_PARSE_E;
            break;
    #endif /* WOLFSSL_DUAL_ALG_CERTS */
        default:
            if (isUnknownExt != NULL)
 8017da2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8017da4:	2b00      	cmp	r3, #0
 8017da6:	d002      	beq.n	8017dae <DecodeExtensionType+0x536>
                *isUnknownExt = 1;
 8017da8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8017daa:	2201      	movs	r2, #1
 8017dac:	601a      	str	r2, [r3, #0]
        #ifndef WOLFSSL_NO_ASN_STRICT
            /* While it is a failure to not support critical extensions,
             * still parse the certificate ignoring the unsupported
             * extension to allow caller to accept it with the verify
             * callback. */
            if (critical) {
 8017dae:	78fb      	ldrb	r3, [r7, #3]
 8017db0:	2b00      	cmp	r3, #0
 8017db2:	d019      	beq.n	8017de8 <DecodeExtensionType+0x570>
                WOLFSSL_ERROR_VERBOSE(ASN_CRIT_EXT_E);
                ret = ASN_CRIT_EXT_E;
 8017db4:	f06f 039f 	mvn.w	r3, #159	@ 0x9f
 8017db8:	617b      	str	r3, [r7, #20]
            }
        #endif
            break;
 8017dba:	e015      	b.n	8017de8 <DecodeExtensionType+0x570>
            break;
 8017dbc:	bf00      	nop
 8017dbe:	e014      	b.n	8017dea <DecodeExtensionType+0x572>
            break;
 8017dc0:	bf00      	nop
 8017dc2:	e012      	b.n	8017dea <DecodeExtensionType+0x572>
            break;
 8017dc4:	bf00      	nop
 8017dc6:	e010      	b.n	8017dea <DecodeExtensionType+0x572>
            break;
 8017dc8:	bf00      	nop
 8017dca:	e00e      	b.n	8017dea <DecodeExtensionType+0x572>
            break;
 8017dcc:	bf00      	nop
 8017dce:	e00c      	b.n	8017dea <DecodeExtensionType+0x572>
            break;
 8017dd0:	bf00      	nop
 8017dd2:	e00a      	b.n	8017dea <DecodeExtensionType+0x572>
            break;
 8017dd4:	bf00      	nop
 8017dd6:	e008      	b.n	8017dea <DecodeExtensionType+0x572>
            break;
 8017dd8:	bf00      	nop
 8017dda:	e006      	b.n	8017dea <DecodeExtensionType+0x572>
            break;
 8017ddc:	bf00      	nop
 8017dde:	e004      	b.n	8017dea <DecodeExtensionType+0x572>
            break;
 8017de0:	bf00      	nop
 8017de2:	e002      	b.n	8017dea <DecodeExtensionType+0x572>
            break;
 8017de4:	bf00      	nop
 8017de6:	e000      	b.n	8017dea <DecodeExtensionType+0x572>
            break;
 8017de8:	bf00      	nop
    }

    return ret;
 8017dea:	697b      	ldr	r3, [r7, #20]
}
 8017dec:	4618      	mov	r0, r3
 8017dee:	3718      	adds	r7, #24
 8017df0:	46bd      	mov	sp, r7
 8017df2:	bd80      	pop	{r7, pc}

08017df4 <DecodeCertExtensions>:
/*
 *  Processing the Certificate Extensions. This does not modify the current
 *  index. It is works starting with the recorded extensions pointer.
 */
static int DecodeCertExtensions(DecodedCert* cert)
{
 8017df4:	b580      	push	{r7, lr}
 8017df6:	b0a0      	sub	sp, #128	@ 0x80
 8017df8:	af04      	add	r7, sp, #16
 8017dfa:	6078      	str	r0, [r7, #4]

    ret = criticalFail ? ASN_CRIT_EXT_E : 0;
end:
    return ret;
#else
    DECL_ASNGETDATA(dataASN, certExtASN_Length);
 8017dfc:	2300      	movs	r3, #0
 8017dfe:	66fb      	str	r3, [r7, #108]	@ 0x6c
    ASNGetData dataExtsASN[certExtHdrASN_Length];
    int ret = 0;
 8017e00:	2300      	movs	r3, #0
 8017e02:	66bb      	str	r3, [r7, #104]	@ 0x68
    const byte* input = cert->extensions;
 8017e04:	687b      	ldr	r3, [r7, #4]
 8017e06:	f8d3 3398 	ldr.w	r3, [r3, #920]	@ 0x398
 8017e0a:	663b      	str	r3, [r7, #96]	@ 0x60
    int sz = cert->extensionsSz;
 8017e0c:	687b      	ldr	r3, [r7, #4]
 8017e0e:	f8d3 339c 	ldr.w	r3, [r3, #924]	@ 0x39c
 8017e12:	65fb      	str	r3, [r7, #92]	@ 0x5c
    word32 idx = 0;
 8017e14:	2300      	movs	r3, #0
 8017e16:	613b      	str	r3, [r7, #16]
    int criticalRet = 0;
 8017e18:	2300      	movs	r3, #0
 8017e1a:	667b      	str	r3, [r7, #100]	@ 0x64
    int offset = 0;
 8017e1c:	2300      	movs	r3, #0
 8017e1e:	65bb      	str	r3, [r7, #88]	@ 0x58

    WOLFSSL_ENTER("DecodeCertExtensions");

    if (input == NULL || sz == 0)
 8017e20:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8017e22:	2b00      	cmp	r3, #0
 8017e24:	d002      	beq.n	8017e2c <DecodeCertExtensions+0x38>
 8017e26:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8017e28:	2b00      	cmp	r3, #0
 8017e2a:	d102      	bne.n	8017e32 <DecodeCertExtensions+0x3e>
        ret = BAD_FUNC_ARG;
 8017e2c:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8017e30:	66bb      	str	r3, [r7, #104]	@ 0x68

    ALLOC_ASNGETDATA(dataASN, certExtASN_Length, ret, cert->heap);
 8017e32:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8017e34:	2b00      	cmp	r3, #0
 8017e36:	d109      	bne.n	8017e4c <DecodeCertExtensions+0x58>
 8017e38:	2070      	movs	r0, #112	@ 0x70
 8017e3a:	f006 fe25 	bl	801ea88 <wolfSSL_Malloc>
 8017e3e:	66f8      	str	r0, [r7, #108]	@ 0x6c
 8017e40:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8017e42:	2b00      	cmp	r3, #0
 8017e44:	d102      	bne.n	8017e4c <DecodeCertExtensions+0x58>
 8017e46:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8017e4a:	66bb      	str	r3, [r7, #104]	@ 0x68
#ifdef WOLFSSL_CERT_REQ
    if (cert->isCSR) {
        offset = CERTEXTHDRASN_IDX_EXTSEQ;
    }
#endif
    if (ret == 0) {
 8017e4c:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8017e4e:	2b00      	cmp	r3, #0
 8017e50:	d16e      	bne.n	8017f30 <DecodeCertExtensions+0x13c>
        /* Clear dynamic data. */
        XMEMSET(dataExtsASN, 0, sizeof(dataExtsASN));
 8017e52:	f107 0314 	add.w	r3, r7, #20
 8017e56:	2238      	movs	r2, #56	@ 0x38
 8017e58:	2100      	movs	r1, #0
 8017e5a:	4618      	mov	r0, r3
 8017e5c:	f010 fb34 	bl	80284c8 <memset>
        /* Parse extensions header. */
        ret = GetASN_Items(certExtHdrASN + offset, dataExtsASN + offset,
 8017e60:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8017e62:	009b      	lsls	r3, r3, #2
 8017e64:	4a40      	ldr	r2, [pc, #256]	@ (8017f68 <DecodeCertExtensions+0x174>)
 8017e66:	1898      	adds	r0, r3, r2
 8017e68:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8017e6a:	4613      	mov	r3, r2
 8017e6c:	00db      	lsls	r3, r3, #3
 8017e6e:	1a9b      	subs	r3, r3, r2
 8017e70:	009b      	lsls	r3, r3, #2
 8017e72:	461a      	mov	r2, r3
 8017e74:	f107 0314 	add.w	r3, r7, #20
 8017e78:	1899      	adds	r1, r3, r2
                           (int)(certExtHdrASN_Length - (size_t)offset), 0,
 8017e7a:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8017e7c:	f1c3 0302 	rsb	r3, r3, #2
        ret = GetASN_Items(certExtHdrASN + offset, dataExtsASN + offset,
 8017e80:	461a      	mov	r2, r3
 8017e82:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8017e84:	9302      	str	r3, [sp, #8]
 8017e86:	f107 0310 	add.w	r3, r7, #16
 8017e8a:	9301      	str	r3, [sp, #4]
 8017e8c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8017e8e:	9300      	str	r3, [sp, #0]
 8017e90:	2300      	movs	r3, #0
 8017e92:	f7fb fc35 	bl	8013700 <GetASN_Items>
 8017e96:	66b8      	str	r0, [r7, #104]	@ 0x68
                           input, &idx, (word32)sz);
    }
    /* Parse each extension. */
    while ((ret == 0) && (idx < (word32)sz)) {
 8017e98:	e04a      	b.n	8017f30 <DecodeCertExtensions+0x13c>
        byte critical = 0;
 8017e9a:	2300      	movs	r3, #0
 8017e9c:	73fb      	strb	r3, [r7, #15]
        int isUnknownExt = 0;
 8017e9e:	2300      	movs	r3, #0
 8017ea0:	60bb      	str	r3, [r7, #8]

        /* Clear dynamic data. */
        XMEMSET(dataASN, 0, sizeof(*dataASN) * certExtASN_Length);
 8017ea2:	2270      	movs	r2, #112	@ 0x70
 8017ea4:	2100      	movs	r1, #0
 8017ea6:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 8017ea8:	f010 fb0e 	bl	80284c8 <memset>
        /* Ensure OID is an extension type. */
        GetASN_OID(&dataASN[CERTEXTASN_IDX_OID], oidCertExtType);
 8017eac:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8017eae:	331c      	adds	r3, #28
 8017eb0:	2206      	movs	r2, #6
 8017eb2:	611a      	str	r2, [r3, #16]
        /* Set criticality variable. */
        GetASN_Int8Bit(&dataASN[CERTEXTASN_IDX_CRIT], &critical);
 8017eb4:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8017eb6:	3338      	adds	r3, #56	@ 0x38
 8017eb8:	2201      	movs	r2, #1
 8017eba:	761a      	strb	r2, [r3, #24]
 8017ebc:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8017ebe:	3338      	adds	r3, #56	@ 0x38
 8017ec0:	f107 020f 	add.w	r2, r7, #15
 8017ec4:	609a      	str	r2, [r3, #8]
        /* Parse extension wrapper. */
        ret = GetASN_Items(certExtASN, dataASN, certExtASN_Length, 0, input,
 8017ec6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8017ec8:	9302      	str	r3, [sp, #8]
 8017eca:	f107 0310 	add.w	r3, r7, #16
 8017ece:	9301      	str	r3, [sp, #4]
 8017ed0:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8017ed2:	9300      	str	r3, [sp, #0]
 8017ed4:	2300      	movs	r3, #0
 8017ed6:	2204      	movs	r2, #4
 8017ed8:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 8017eda:	4824      	ldr	r0, [pc, #144]	@ (8017f6c <DecodeCertExtensions+0x178>)
 8017edc:	f7fb fc10 	bl	8013700 <GetASN_Items>
 8017ee0:	66b8      	str	r0, [r7, #104]	@ 0x68
                           &idx, (word32)sz);
        if (ret == 0) {
 8017ee2:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8017ee4:	2b00      	cmp	r3, #0
 8017ee6:	d11a      	bne.n	8017f1e <DecodeCertExtensions+0x12a>
            word32 oid = dataASN[CERTEXTASN_IDX_OID].data.oid.sum;
 8017ee8:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8017eea:	331c      	adds	r3, #28
 8017eec:	695b      	ldr	r3, [r3, #20]
 8017eee:	657b      	str	r3, [r7, #84]	@ 0x54
            word32 length = dataASN[CERTEXTASN_IDX_VAL].length;
 8017ef0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8017ef2:	3354      	adds	r3, #84	@ 0x54
 8017ef4:	685b      	ldr	r3, [r3, #4]
 8017ef6:	653b      	str	r3, [r7, #80]	@ 0x50

            /* Decode the extension by type. */
            ret = DecodeExtensionType(input + idx, length, oid, critical, cert,
 8017ef8:	693b      	ldr	r3, [r7, #16]
 8017efa:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8017efc:	18d0      	adds	r0, r2, r3
 8017efe:	7bfa      	ldrb	r2, [r7, #15]
 8017f00:	f107 0308 	add.w	r3, r7, #8
 8017f04:	9301      	str	r3, [sp, #4]
 8017f06:	687b      	ldr	r3, [r7, #4]
 8017f08:	9300      	str	r3, [sp, #0]
 8017f0a:	4613      	mov	r3, r2
 8017f0c:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8017f0e:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 8017f10:	f7ff fcb2 	bl	8017878 <DecodeExtensionType>
 8017f14:	66b8      	str	r0, [r7, #104]	@ 0x68
#else
            (void)isUnknownExt;
#endif

            /* Move index on to next extension. */
            idx += length;
 8017f16:	693a      	ldr	r2, [r7, #16]
 8017f18:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8017f1a:	4413      	add	r3, r2
 8017f1c:	613b      	str	r3, [r7, #16]
        }
        /* Don't fail criticality until all other extensions have been checked.
         */
        if (ret == WC_NO_ERR_TRACE(ASN_CRIT_EXT_E)) {
 8017f1e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8017f20:	f113 0fa0 	cmn.w	r3, #160	@ 0xa0
 8017f24:	d104      	bne.n	8017f30 <DecodeCertExtensions+0x13c>
            criticalRet = ASN_CRIT_EXT_E;
 8017f26:	f06f 039f 	mvn.w	r3, #159	@ 0x9f
 8017f2a:	667b      	str	r3, [r7, #100]	@ 0x64
            ret = 0;
 8017f2c:	2300      	movs	r3, #0
 8017f2e:	66bb      	str	r3, [r7, #104]	@ 0x68
    while ((ret == 0) && (idx < (word32)sz)) {
 8017f30:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8017f32:	2b00      	cmp	r3, #0
 8017f34:	d103      	bne.n	8017f3e <DecodeCertExtensions+0x14a>
 8017f36:	693a      	ldr	r2, [r7, #16]
 8017f38:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8017f3a:	429a      	cmp	r2, r3
 8017f3c:	d3ad      	bcc.n	8017e9a <DecodeCertExtensions+0xa6>
        }
    }

    if (ret == 0) {
 8017f3e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8017f40:	2b00      	cmp	r3, #0
 8017f42:	d101      	bne.n	8017f48 <DecodeCertExtensions+0x154>
        /* Use criticality return. */
        ret = criticalRet;
 8017f44:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8017f46:	66bb      	str	r3, [r7, #104]	@ 0x68
    }

    FREE_ASNGETDATA(dataASN, cert->heap);
 8017f48:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8017f4a:	2b00      	cmp	r3, #0
 8017f4c:	d007      	beq.n	8017f5e <DecodeCertExtensions+0x16a>
 8017f4e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8017f50:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8017f52:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8017f54:	2b00      	cmp	r3, #0
 8017f56:	d002      	beq.n	8017f5e <DecodeCertExtensions+0x16a>
 8017f58:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 8017f5a:	f006 fdb1 	bl	801eac0 <wolfSSL_Free>
    return ret;
 8017f5e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
#endif
}
 8017f60:	4618      	mov	r0, r3
 8017f62:	3770      	adds	r7, #112	@ 0x70
 8017f64:	46bd      	mov	sp, r7
 8017f66:	bd80      	pop	{r7, pc}
 8017f68:	0803398c 	.word	0x0803398c
 8017f6c:	08033994 	.word	0x08033994

08017f70 <CheckDate>:
 * @return  ASN_DATE_SZ_E when time data is not supported.
 * @return  ASN_BEFORE_DATE_E when ASN_BEFORE date is invalid.
 * @return  ASN_AFTER_DATE_E when ASN_AFTER date is invalid.
 */
static int CheckDate(ASNGetData *dataASN, int dateType)
{
 8017f70:	b480      	push	{r7}
 8017f72:	b085      	sub	sp, #20
 8017f74:	af00      	add	r7, sp, #0
 8017f76:	6078      	str	r0, [r7, #4]
 8017f78:	6039      	str	r1, [r7, #0]
    int ret = 0;
 8017f7a:	2300      	movs	r3, #0
 8017f7c:	60fb      	str	r3, [r7, #12]

    /* Check BER tag is valid. */
    if ((dataASN->tag != ASN_UTC_TIME) &&
 8017f7e:	687b      	ldr	r3, [r7, #4]
 8017f80:	7e5b      	ldrb	r3, [r3, #25]
 8017f82:	2b17      	cmp	r3, #23
 8017f84:	d006      	beq.n	8017f94 <CheckDate+0x24>
            (dataASN->tag != ASN_GENERALIZED_TIME)) {
 8017f86:	687b      	ldr	r3, [r7, #4]
 8017f88:	7e5b      	ldrb	r3, [r3, #25]
    if ((dataASN->tag != ASN_UTC_TIME) &&
 8017f8a:	2b18      	cmp	r3, #24
 8017f8c:	d002      	beq.n	8017f94 <CheckDate+0x24>
        ret = ASN_TIME_E;
 8017f8e:	f06f 0398 	mvn.w	r3, #152	@ 0x98
 8017f92:	60fb      	str	r3, [r7, #12]
    }
    /* Check date length is valid. */
    if ((ret == 0) && ((dataASN->length > MAX_DATE_SIZE) ||
 8017f94:	68fb      	ldr	r3, [r7, #12]
 8017f96:	2b00      	cmp	r3, #0
 8017f98:	d10a      	bne.n	8017fb0 <CheckDate+0x40>
 8017f9a:	687b      	ldr	r3, [r7, #4]
 8017f9c:	685b      	ldr	r3, [r3, #4]
 8017f9e:	2b20      	cmp	r3, #32
 8017fa0:	d803      	bhi.n	8017faa <CheckDate+0x3a>
                       (dataASN->length < MIN_DATE_SIZE))) {
 8017fa2:	687b      	ldr	r3, [r7, #4]
 8017fa4:	685b      	ldr	r3, [r3, #4]
    if ((ret == 0) && ((dataASN->length > MAX_DATE_SIZE) ||
 8017fa6:	2b0b      	cmp	r3, #11
 8017fa8:	d802      	bhi.n	8017fb0 <CheckDate+0x40>
        ret = ASN_DATE_SZ_E;
 8017faa:	f06f 0394 	mvn.w	r3, #148	@ 0x94
 8017fae:	60fb      	str	r3, [r7, #12]
        }
    }
#endif
    (void)dateType;

    return ret;
 8017fb0:	68fb      	ldr	r3, [r7, #12]
}
 8017fb2:	4618      	mov	r0, r3
 8017fb4:	3714      	adds	r7, #20
 8017fb6:	46bd      	mov	sp, r7
 8017fb8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017fbc:	4770      	bx	lr
	...

08017fc0 <DecodeCertInternal>:
 * @return  ASN_UNKNOWN_OID_E when the OID cannot be verified.
 */
static int DecodeCertInternal(DecodedCert* cert, int verify, int* criticalExt,
                              int* badDateRet, int stopAtPubKey,
                              int stopAfterPubKey)
{
 8017fc0:	b580      	push	{r7, lr}
 8017fc2:	b09c      	sub	sp, #112	@ 0x70
 8017fc4:	af04      	add	r7, sp, #16
 8017fc6:	60f8      	str	r0, [r7, #12]
 8017fc8:	60b9      	str	r1, [r7, #8]
 8017fca:	607a      	str	r2, [r7, #4]
 8017fcc:	603b      	str	r3, [r7, #0]
    DECL_ASNGETDATA(dataASN, x509CertASN_Length);
 8017fce:	2300      	movs	r3, #0
 8017fd0:	65fb      	str	r3, [r7, #92]	@ 0x5c
    int ret = 0;
 8017fd2:	2300      	movs	r3, #0
 8017fd4:	65bb      	str	r3, [r7, #88]	@ 0x58
    int badDate = 0;
 8017fd6:	2300      	movs	r3, #0
 8017fd8:	657b      	str	r3, [r7, #84]	@ 0x54
    byte version = 0;
 8017fda:	2300      	movs	r3, #0
 8017fdc:	76fb      	strb	r3, [r7, #27]
    word32 idx;
    word32 serialSz = 0;
 8017fde:	2300      	movs	r3, #0
 8017fe0:	613b      	str	r3, [r7, #16]
    const unsigned char* issuer = NULL;
 8017fe2:	2300      	movs	r3, #0
 8017fe4:	653b      	str	r3, [r7, #80]	@ 0x50
    word32 issuerSz = 0;
 8017fe6:	2300      	movs	r3, #0
 8017fe8:	64fb      	str	r3, [r7, #76]	@ 0x4c
    const unsigned char* subject = NULL;
 8017fea:	2300      	movs	r3, #0
 8017fec:	64bb      	str	r3, [r7, #72]	@ 0x48
    word32 subjectSz = 0;
 8017fee:	2300      	movs	r3, #0
 8017ff0:	647b      	str	r3, [r7, #68]	@ 0x44
    word32 pubKeyOffset = 0;
 8017ff2:	2300      	movs	r3, #0
 8017ff4:	643b      	str	r3, [r7, #64]	@ 0x40
    word32 pubKeyEnd = 0;
 8017ff6:	2300      	movs	r3, #0
 8017ff8:	63fb      	str	r3, [r7, #60]	@ 0x3c
    int done = 0;
 8017ffa:	2300      	movs	r3, #0
 8017ffc:	63bb      	str	r3, [r7, #56]	@ 0x38
    else {
        ret = 0;    /* proceed to the original x509 parsing */
    }
#endif /* HAVE_RPK */

    CALLOC_ASNGETDATA(dataASN, x509CertASN_Length, ret, cert->heap);
 8017ffe:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8018000:	2b00      	cmp	r3, #0
 8018002:	d10a      	bne.n	801801a <DecodeCertInternal+0x5a>
 8018004:	f44f 7060 	mov.w	r0, #896	@ 0x380
 8018008:	f006 fd3e 	bl	801ea88 <wolfSSL_Malloc>
 801800c:	65f8      	str	r0, [r7, #92]	@ 0x5c
 801800e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018010:	2b00      	cmp	r3, #0
 8018012:	d102      	bne.n	801801a <DecodeCertInternal+0x5a>
 8018014:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8018018:	65bb      	str	r3, [r7, #88]	@ 0x58
 801801a:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801801c:	2b00      	cmp	r3, #0
 801801e:	d105      	bne.n	801802c <DecodeCertInternal+0x6c>
 8018020:	f44f 7260 	mov.w	r2, #896	@ 0x380
 8018024:	2100      	movs	r1, #0
 8018026:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8018028:	f010 fa4e 	bl	80284c8 <memset>

    if (ret == 0) {
 801802c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801802e:	2b00      	cmp	r3, #0
 8018030:	d141      	bne.n	80180b6 <DecodeCertInternal+0xf6>
        version = 0;
 8018032:	2300      	movs	r3, #0
 8018034:	76fb      	strb	r3, [r7, #27]
        serialSz = EXTERNAL_SERIAL_SIZE;
 8018036:	2320      	movs	r3, #32
 8018038:	613b      	str	r3, [r7, #16]

        /* Get the version and put the serial number into the buffer. */
        GetASN_Int8Bit(&dataASN[X509CERTASN_IDX_TBS_VER_INT], &version);
 801803a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801803c:	3354      	adds	r3, #84	@ 0x54
 801803e:	2201      	movs	r2, #1
 8018040:	761a      	strb	r2, [r3, #24]
 8018042:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018044:	3354      	adds	r3, #84	@ 0x54
 8018046:	f107 021b 	add.w	r2, r7, #27
 801804a:	609a      	str	r2, [r3, #8]
        GetASN_Buffer(&dataASN[X509CERTASN_IDX_TBS_SERIAL], cert->serial,
 801804c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801804e:	3370      	adds	r3, #112	@ 0x70
 8018050:	2205      	movs	r2, #5
 8018052:	761a      	strb	r2, [r3, #24]
 8018054:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018056:	3370      	adds	r3, #112	@ 0x70
 8018058:	68fa      	ldr	r2, [r7, #12]
 801805a:	f502 725d 	add.w	r2, r2, #884	@ 0x374
 801805e:	609a      	str	r2, [r3, #8]
 8018060:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018062:	3370      	adds	r3, #112	@ 0x70
 8018064:	f107 0210 	add.w	r2, r7, #16
 8018068:	60da      	str	r2, [r3, #12]
                &serialSz);
        /* Check OID types for signature, algorithm, ECC curve and sigAlg. */
        GetASN_OID(&dataASN[X509CERTASN_IDX_TBS_ALGOID_OID], oidSigType);
 801806a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801806c:	33a8      	adds	r3, #168	@ 0xa8
 801806e:	2201      	movs	r2, #1
 8018070:	611a      	str	r2, [r3, #16]
        GetASN_OID(&dataASN[X509CERTASN_IDX_TBS_SPUBKEYINFO_ALGO_OID],
 8018072:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018074:	f503 73fc 	add.w	r3, r3, #504	@ 0x1f8
 8018078:	2202      	movs	r2, #2
 801807a:	611a      	str	r2, [r3, #16]
                oidKeyType);
        GetASN_OID(&dataASN[X509CERTASN_IDX_TBS_SPUBKEYINFO_ALGO_CURVEID],
 801807c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801807e:	f503 730c 	add.w	r3, r3, #560	@ 0x230
 8018082:	2203      	movs	r2, #3
 8018084:	611a      	str	r2, [r3, #16]
                oidCurveType);
        GetASN_OID(&dataASN[X509CERTASN_IDX_SIGALGO_OID], oidSigType);
 8018086:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018088:	f503 7344 	add.w	r3, r3, #784	@ 0x310
 801808c:	2201      	movs	r2, #1
 801808e:	611a      	str	r2, [r3, #16]
        /* Parse the X509 certificate. */
        ret = GetASN_Items(x509CertASN, dataASN, x509CertASN_Length, 1,
 8018090:	68fb      	ldr	r3, [r7, #12]
 8018092:	f8d3 3364 	ldr.w	r3, [r3, #868]	@ 0x364
 8018096:	68fa      	ldr	r2, [r7, #12]
 8018098:	f502 725a 	add.w	r2, r2, #872	@ 0x368
 801809c:	68f9      	ldr	r1, [r7, #12]
 801809e:	f8d1 136c 	ldr.w	r1, [r1, #876]	@ 0x36c
 80180a2:	9102      	str	r1, [sp, #8]
 80180a4:	9201      	str	r2, [sp, #4]
 80180a6:	9300      	str	r3, [sp, #0]
 80180a8:	2301      	movs	r3, #1
 80180aa:	2220      	movs	r2, #32
 80180ac:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 80180ae:	48a6      	ldr	r0, [pc, #664]	@ (8018348 <DecodeCertInternal+0x388>)
 80180b0:	f7fb fb26 	bl	8013700 <GetASN_Items>
 80180b4:	65b8      	str	r0, [r7, #88]	@ 0x58
            ret = ASN_PARSE_E;
        }
#endif
    }
    /* Check version is valid/supported - can't be negative. */
    if ((ret == 0) && (version > MAX_X509_VERSION)) {
 80180b6:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80180b8:	2b00      	cmp	r3, #0
 80180ba:	d105      	bne.n	80180c8 <DecodeCertInternal+0x108>
 80180bc:	7efb      	ldrb	r3, [r7, #27]
 80180be:	2b03      	cmp	r3, #3
 80180c0:	d902      	bls.n	80180c8 <DecodeCertInternal+0x108>
        WOLFSSL_MSG("Unexpected certificate version");
        WOLFSSL_ERROR_VERBOSE(ASN_PARSE_E);
        ret = ASN_PARSE_E;
 80180c2:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80180c6:	65bb      	str	r3, [r7, #88]	@ 0x58
    }
    if (ret == 0) {
 80180c8:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80180ca:	2b00      	cmp	r3, #0
 80180cc:	f040 8107 	bne.w	80182de <DecodeCertInternal+0x31e>
        int i;

        pubKeyOffset = dataASN[X509CERTASN_IDX_TBS_SPUBKEYINFO_SEQ].offset;
 80180d0:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80180d2:	f503 73e0 	add.w	r3, r3, #448	@ 0x1c0
 80180d6:	681b      	ldr	r3, [r3, #0]
 80180d8:	643b      	str	r3, [r7, #64]	@ 0x40
        /* Set fields extracted from data. */
        cert->version = version;
 80180da:	7efb      	ldrb	r3, [r7, #27]
 80180dc:	461a      	mov	r2, r3
 80180de:	68fb      	ldr	r3, [r7, #12]
 80180e0:	629a      	str	r2, [r3, #40]	@ 0x28
        cert->serialSz = (int)serialSz;
 80180e2:	693b      	ldr	r3, [r7, #16]
 80180e4:	461a      	mov	r2, r3
 80180e6:	68fb      	ldr	r3, [r7, #12]
 80180e8:	f8c3 2394 	str.w	r2, [r3, #916]	@ 0x394
        !defined(WOLFSSL_ASN_ALLOW_0_SERIAL)
        /* RFC 5280 section 4.1.2.2 states that non-conforming CAs may issue
         * a negative or zero serial number and should be handled gracefully.
         * Since it is a non-conforming CA that issues a serial of 0 then we
         * treat it as an error here. */
        if (cert->serialSz == 1 && cert->serial[0] == 0) {
 80180ec:	68fb      	ldr	r3, [r7, #12]
 80180ee:	f8d3 3394 	ldr.w	r3, [r3, #916]	@ 0x394
 80180f2:	2b01      	cmp	r3, #1
 80180f4:	d107      	bne.n	8018106 <DecodeCertInternal+0x146>
 80180f6:	68fb      	ldr	r3, [r7, #12]
 80180f8:	f893 3374 	ldrb.w	r3, [r3, #884]	@ 0x374
 80180fc:	2b00      	cmp	r3, #0
 80180fe:	d102      	bne.n	8018106 <DecodeCertInternal+0x146>
            WOLFSSL_MSG("Error serial number of 0, use WOLFSSL_NO_ASN_STRICT "
                "if wanted");
            ret = ASN_PARSE_E;
 8018100:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8018104:	65bb      	str	r3, [r7, #88]	@ 0x58
        }
    #endif
        if (cert->serialSz == 0) {
 8018106:	68fb      	ldr	r3, [r7, #12]
 8018108:	f8d3 3394 	ldr.w	r3, [r3, #916]	@ 0x394
 801810c:	2b00      	cmp	r3, #0
 801810e:	d102      	bne.n	8018116 <DecodeCertInternal+0x156>
            WOLFSSL_MSG("Error serial size is zero. Should be at least one "
                        "even with no serial number.");
            ret = ASN_PARSE_E;
 8018110:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8018114:	65bb      	str	r3, [r7, #88]	@ 0x58
        }

        cert->signatureOID = dataASN[X509CERTASN_IDX_TBS_ALGOID_OID].data.oid.sum;
 8018116:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018118:	33a8      	adds	r3, #168	@ 0xa8
 801811a:	695a      	ldr	r2, [r3, #20]
 801811c:	68fb      	ldr	r3, [r7, #12]
 801811e:	619a      	str	r2, [r3, #24]
        cert->keyOID = dataASN[X509CERTASN_IDX_TBS_SPUBKEYINFO_ALGO_OID].data.oid.sum;
 8018120:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018122:	f503 73fc 	add.w	r3, r3, #504	@ 0x1f8
 8018126:	695a      	ldr	r2, [r3, #20]
 8018128:	68fb      	ldr	r3, [r7, #12]
 801812a:	61da      	str	r2, [r3, #28]
        cert->certBegin = dataASN[X509CERTASN_IDX_TBS_SEQ].offset;
 801812c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801812e:	331c      	adds	r3, #28
 8018130:	681a      	ldr	r2, [r3, #0]
 8018132:	68fb      	ldr	r3, [r7, #12]
 8018134:	60da      	str	r2, [r3, #12]

        /* No bad date error - don't always care. */
        badDate = 0;
 8018136:	2300      	movs	r3, #0
 8018138:	657b      	str	r3, [r7, #84]	@ 0x54
        /* Find the item with the ASN_BEFORE date and check it. */
        i = (dataASN[X509CERTASN_IDX_TBS_VALIDITY_NOTB_UTC].tag != 0)
 801813a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801813c:	f503 739a 	add.w	r3, r3, #308	@ 0x134
 8018140:	7e5b      	ldrb	r3, [r3, #25]
                ? X509CERTASN_IDX_TBS_VALIDITY_NOTB_UTC
                : X509CERTASN_IDX_TBS_VALIDITY_NOTB_GT;
 8018142:	2b00      	cmp	r3, #0
 8018144:	d001      	beq.n	801814a <DecodeCertInternal+0x18a>
 8018146:	230b      	movs	r3, #11
 8018148:	e000      	b.n	801814c <DecodeCertInternal+0x18c>
 801814a:	230c      	movs	r3, #12
        i = (dataASN[X509CERTASN_IDX_TBS_VALIDITY_NOTB_UTC].tag != 0)
 801814c:	633b      	str	r3, [r7, #48]	@ 0x30
        if ((CheckDate(&dataASN[i], ASN_BEFORE) < 0) && (verify != NO_VERIFY) &&
 801814e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8018150:	4613      	mov	r3, r2
 8018152:	00db      	lsls	r3, r3, #3
 8018154:	1a9b      	subs	r3, r3, r2
 8018156:	009b      	lsls	r3, r3, #2
 8018158:	461a      	mov	r2, r3
 801815a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801815c:	4413      	add	r3, r2
 801815e:	2100      	movs	r1, #0
 8018160:	4618      	mov	r0, r3
 8018162:	f7ff ff05 	bl	8017f70 <CheckDate>
 8018166:	4603      	mov	r3, r0
 8018168:	2b00      	cmp	r3, #0
 801816a:	da08      	bge.n	801817e <DecodeCertInternal+0x1be>
 801816c:	68bb      	ldr	r3, [r7, #8]
 801816e:	2b00      	cmp	r3, #0
 8018170:	d005      	beq.n	801817e <DecodeCertInternal+0x1be>
 8018172:	68bb      	ldr	r3, [r7, #8]
 8018174:	2b05      	cmp	r3, #5
 8018176:	d002      	beq.n	801817e <DecodeCertInternal+0x1be>
                (verify != VERIFY_SKIP_DATE)) {
            badDate = ASN_BEFORE_DATE_E;
 8018178:	f06f 0395 	mvn.w	r3, #149	@ 0x95
 801817c:	657b      	str	r3, [r7, #84]	@ 0x54
        }
        /* Store reference to ASN_BEFORE date. */
        cert->beforeDate = GetASNItem_Addr(dataASN[i], cert->source);
 801817e:	68fb      	ldr	r3, [r7, #12]
 8018180:	f8d3 1364 	ldr.w	r1, [r3, #868]	@ 0x364
 8018184:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8018186:	4613      	mov	r3, r2
 8018188:	00db      	lsls	r3, r3, #3
 801818a:	1a9b      	subs	r3, r3, r2
 801818c:	009b      	lsls	r3, r3, #2
 801818e:	461a      	mov	r2, r3
 8018190:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018192:	4413      	add	r3, r2
 8018194:	681b      	ldr	r3, [r3, #0]
 8018196:	18ca      	adds	r2, r1, r3
 8018198:	68fb      	ldr	r3, [r7, #12]
 801819a:	f8c3 2444 	str.w	r2, [r3, #1092]	@ 0x444
        cert->beforeDateLen = (int)GetASNItem_Length(dataASN[i], cert->source);
 801819e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80181a0:	4613      	mov	r3, r2
 80181a2:	00db      	lsls	r3, r3, #3
 80181a4:	1a9b      	subs	r3, r3, r2
 80181a6:	009b      	lsls	r3, r3, #2
 80181a8:	461a      	mov	r2, r3
 80181aa:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80181ac:	4413      	add	r3, r2
 80181ae:	6859      	ldr	r1, [r3, #4]
 80181b0:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80181b2:	4613      	mov	r3, r2
 80181b4:	00db      	lsls	r3, r3, #3
 80181b6:	1a9b      	subs	r3, r3, r2
 80181b8:	009b      	lsls	r3, r3, #2
 80181ba:	461a      	mov	r2, r3
 80181bc:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80181be:	4413      	add	r3, r2
 80181c0:	689a      	ldr	r2, [r3, #8]
 80181c2:	68fb      	ldr	r3, [r7, #12]
 80181c4:	f8d3 3364 	ldr.w	r3, [r3, #868]	@ 0x364
 80181c8:	1ad3      	subs	r3, r2, r3
 80181ca:	4419      	add	r1, r3
 80181cc:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80181ce:	4613      	mov	r3, r2
 80181d0:	00db      	lsls	r3, r3, #3
 80181d2:	1a9b      	subs	r3, r3, r2
 80181d4:	009b      	lsls	r3, r3, #2
 80181d6:	461a      	mov	r2, r3
 80181d8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80181da:	4413      	add	r3, r2
 80181dc:	681b      	ldr	r3, [r3, #0]
 80181de:	1acb      	subs	r3, r1, r3
 80181e0:	461a      	mov	r2, r3
 80181e2:	68fb      	ldr	r3, [r7, #12]
 80181e4:	f8c3 2448 	str.w	r2, [r3, #1096]	@ 0x448

        /* Find the item with the ASN_AFTER date and check it. */
        i = (dataASN[X509CERTASN_IDX_TBS_VALIDITY_NOTA_UTC].tag != 0)
 80181e8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80181ea:	f503 73b6 	add.w	r3, r3, #364	@ 0x16c
 80181ee:	7e5b      	ldrb	r3, [r3, #25]
                ? X509CERTASN_IDX_TBS_VALIDITY_NOTA_UTC
                : X509CERTASN_IDX_TBS_VALIDITY_NOTA_GT;
 80181f0:	2b00      	cmp	r3, #0
 80181f2:	d001      	beq.n	80181f8 <DecodeCertInternal+0x238>
 80181f4:	230d      	movs	r3, #13
 80181f6:	e000      	b.n	80181fa <DecodeCertInternal+0x23a>
 80181f8:	230e      	movs	r3, #14
        i = (dataASN[X509CERTASN_IDX_TBS_VALIDITY_NOTA_UTC].tag != 0)
 80181fa:	633b      	str	r3, [r7, #48]	@ 0x30
        if ((CheckDate(&dataASN[i], ASN_AFTER) < 0) && (verify != NO_VERIFY) &&
 80181fc:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80181fe:	4613      	mov	r3, r2
 8018200:	00db      	lsls	r3, r3, #3
 8018202:	1a9b      	subs	r3, r3, r2
 8018204:	009b      	lsls	r3, r3, #2
 8018206:	461a      	mov	r2, r3
 8018208:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801820a:	4413      	add	r3, r2
 801820c:	2101      	movs	r1, #1
 801820e:	4618      	mov	r0, r3
 8018210:	f7ff feae 	bl	8017f70 <CheckDate>
 8018214:	4603      	mov	r3, r0
 8018216:	2b00      	cmp	r3, #0
 8018218:	da08      	bge.n	801822c <DecodeCertInternal+0x26c>
 801821a:	68bb      	ldr	r3, [r7, #8]
 801821c:	2b00      	cmp	r3, #0
 801821e:	d005      	beq.n	801822c <DecodeCertInternal+0x26c>
 8018220:	68bb      	ldr	r3, [r7, #8]
 8018222:	2b05      	cmp	r3, #5
 8018224:	d002      	beq.n	801822c <DecodeCertInternal+0x26c>
                (verify != VERIFY_SKIP_DATE)) {
            badDate = ASN_AFTER_DATE_E;
 8018226:	f06f 0396 	mvn.w	r3, #150	@ 0x96
 801822a:	657b      	str	r3, [r7, #84]	@ 0x54
        }
        /* Store reference to ASN_AFTER date. */
        cert->afterDate = GetASNItem_Addr(dataASN[i], cert->source);
 801822c:	68fb      	ldr	r3, [r7, #12]
 801822e:	f8d3 1364 	ldr.w	r1, [r3, #868]	@ 0x364
 8018232:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8018234:	4613      	mov	r3, r2
 8018236:	00db      	lsls	r3, r3, #3
 8018238:	1a9b      	subs	r3, r3, r2
 801823a:	009b      	lsls	r3, r3, #2
 801823c:	461a      	mov	r2, r3
 801823e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018240:	4413      	add	r3, r2
 8018242:	681b      	ldr	r3, [r3, #0]
 8018244:	18ca      	adds	r2, r1, r3
 8018246:	68fb      	ldr	r3, [r7, #12]
 8018248:	f8c3 244c 	str.w	r2, [r3, #1100]	@ 0x44c
        cert->afterDateLen = (int)GetASNItem_Length(dataASN[i], cert->source);
 801824c:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801824e:	4613      	mov	r3, r2
 8018250:	00db      	lsls	r3, r3, #3
 8018252:	1a9b      	subs	r3, r3, r2
 8018254:	009b      	lsls	r3, r3, #2
 8018256:	461a      	mov	r2, r3
 8018258:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801825a:	4413      	add	r3, r2
 801825c:	6859      	ldr	r1, [r3, #4]
 801825e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8018260:	4613      	mov	r3, r2
 8018262:	00db      	lsls	r3, r3, #3
 8018264:	1a9b      	subs	r3, r3, r2
 8018266:	009b      	lsls	r3, r3, #2
 8018268:	461a      	mov	r2, r3
 801826a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801826c:	4413      	add	r3, r2
 801826e:	689a      	ldr	r2, [r3, #8]
 8018270:	68fb      	ldr	r3, [r7, #12]
 8018272:	f8d3 3364 	ldr.w	r3, [r3, #868]	@ 0x364
 8018276:	1ad3      	subs	r3, r2, r3
 8018278:	4419      	add	r1, r3
 801827a:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801827c:	4613      	mov	r3, r2
 801827e:	00db      	lsls	r3, r3, #3
 8018280:	1a9b      	subs	r3, r3, r2
 8018282:	009b      	lsls	r3, r3, #2
 8018284:	461a      	mov	r2, r3
 8018286:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018288:	4413      	add	r3, r2
 801828a:	681b      	ldr	r3, [r3, #0]
 801828c:	1acb      	subs	r3, r1, r3
 801828e:	461a      	mov	r2, r3
 8018290:	68fb      	ldr	r3, [r7, #12]
 8018292:	f8c3 2450 	str.w	r2, [r3, #1104]	@ 0x450

        /* Get the issuer name. */
        issuer = cert->source + dataASN[X509CERTASN_IDX_TBS_ISSUER_SEQ].offset;
 8018296:	68fb      	ldr	r3, [r7, #12]
 8018298:	f8d3 2364 	ldr.w	r2, [r3, #868]	@ 0x364
 801829c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801829e:	33fc      	adds	r3, #252	@ 0xfc
 80182a0:	681b      	ldr	r3, [r3, #0]
 80182a2:	4413      	add	r3, r2
 80182a4:	653b      	str	r3, [r7, #80]	@ 0x50
        issuerSz = dataASN[X509CERTASN_IDX_TBS_VALIDITY_SEQ].offset -
 80182a6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80182a8:	f503 738c 	add.w	r3, r3, #280	@ 0x118
 80182ac:	681a      	ldr	r2, [r3, #0]
            dataASN[X509CERTASN_IDX_TBS_ISSUER_SEQ].offset;
 80182ae:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80182b0:	33fc      	adds	r3, #252	@ 0xfc
 80182b2:	681b      	ldr	r3, [r3, #0]
        issuerSz = dataASN[X509CERTASN_IDX_TBS_VALIDITY_SEQ].offset -
 80182b4:	1ad3      	subs	r3, r2, r3
 80182b6:	64fb      	str	r3, [r7, #76]	@ 0x4c

        /* Get the subject name. */
        subject = cert->source +
 80182b8:	68fb      	ldr	r3, [r7, #12]
 80182ba:	f8d3 2364 	ldr.w	r2, [r3, #868]	@ 0x364
            dataASN[X509CERTASN_IDX_TBS_SUBJECT_SEQ].offset;
 80182be:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80182c0:	f503 73d2 	add.w	r3, r3, #420	@ 0x1a4
 80182c4:	681b      	ldr	r3, [r3, #0]
        subject = cert->source +
 80182c6:	4413      	add	r3, r2
 80182c8:	64bb      	str	r3, [r7, #72]	@ 0x48
        subjectSz = dataASN[X509CERTASN_IDX_TBS_SPUBKEYINFO_SEQ].offset -
 80182ca:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80182cc:	f503 73e0 	add.w	r3, r3, #448	@ 0x1c0
 80182d0:	681a      	ldr	r2, [r3, #0]
            dataASN[X509CERTASN_IDX_TBS_SUBJECT_SEQ].offset;
 80182d2:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80182d4:	f503 73d2 	add.w	r3, r3, #420	@ 0x1a4
 80182d8:	681b      	ldr	r3, [r3, #0]
        subjectSz = dataASN[X509CERTASN_IDX_TBS_SPUBKEYINFO_SEQ].offset -
 80182da:	1ad3      	subs	r3, r2, r3
 80182dc:	647b      	str	r3, [r7, #68]	@ 0x44
    }
    if ((ret == 0) && stopAtPubKey) {
 80182de:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80182e0:	2b00      	cmp	r3, #0
 80182e2:	d10a      	bne.n	80182fa <DecodeCertInternal+0x33a>
 80182e4:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80182e6:	2b00      	cmp	r3, #0
 80182e8:	d007      	beq.n	80182fa <DecodeCertInternal+0x33a>
        /* Return any bad date error through badDateRet and return offset of
         * subjectPublicKeyInfo.
         */
        if (badDateRet != NULL) {
 80182ea:	683b      	ldr	r3, [r7, #0]
 80182ec:	2b00      	cmp	r3, #0
 80182ee:	d002      	beq.n	80182f6 <DecodeCertInternal+0x336>
            *badDateRet = badDate;
 80182f0:	683b      	ldr	r3, [r7, #0]
 80182f2:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 80182f4:	601a      	str	r2, [r3, #0]
        }
        done = 1;
 80182f6:	2301      	movs	r3, #1
 80182f8:	63bb      	str	r3, [r7, #56]	@ 0x38
    }

    if ((ret == 0) && (!done)) {
 80182fa:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80182fc:	2b00      	cmp	r3, #0
 80182fe:	f040 80a7 	bne.w	8018450 <DecodeCertInternal+0x490>
 8018302:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8018304:	2b00      	cmp	r3, #0
 8018306:	f040 80a3 	bne.w	8018450 <DecodeCertInternal+0x490>
        /* Store the signature information. */
        cert->sigIndex = dataASN[X509CERTASN_IDX_SIGALGO_SEQ].offset;
 801830a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801830c:	f503 733d 	add.w	r3, r3, #756	@ 0x2f4
 8018310:	681a      	ldr	r2, [r3, #0]
 8018312:	68fb      	ldr	r3, [r7, #12]
 8018314:	611a      	str	r2, [r3, #16]
        GetASN_GetConstRef(&dataASN[X509CERTASN_IDX_SIGNATURE],
 8018316:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018318:	f503 7359 	add.w	r3, r3, #868	@ 0x364
 801831c:	689a      	ldr	r2, [r3, #8]
 801831e:	68fb      	ldr	r3, [r7, #12]
 8018320:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
 8018324:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018326:	f503 7359 	add.w	r3, r3, #868	@ 0x364
 801832a:	68da      	ldr	r2, [r3, #12]
 801832c:	68fb      	ldr	r3, [r7, #12]
 801832e:	615a      	str	r2, [r3, #20]
                &cert->signature, &cert->sigLength);
        /* Make sure 'signature' and 'signatureAlgorithm' are the same. */
        if (dataASN[X509CERTASN_IDX_SIGALGO_OID].data.oid.sum
 8018330:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018332:	f503 7344 	add.w	r3, r3, #784	@ 0x310
 8018336:	695a      	ldr	r2, [r3, #20]
                != cert->signatureOID) {
 8018338:	68fb      	ldr	r3, [r7, #12]
 801833a:	699b      	ldr	r3, [r3, #24]
        if (dataASN[X509CERTASN_IDX_SIGALGO_OID].data.oid.sum
 801833c:	429a      	cmp	r2, r3
 801833e:	d005      	beq.n	801834c <DecodeCertInternal+0x38c>
            WOLFSSL_ERROR_VERBOSE(ASN_SIG_OID_E);
            ret = ASN_SIG_OID_E;
 8018340:	f06f 0397 	mvn.w	r3, #151	@ 0x97
 8018344:	65bb      	str	r3, [r7, #88]	@ 0x58
 8018346:	e083      	b.n	8018450 <DecodeCertInternal+0x490>
 8018348:	080339a4 	.word	0x080339a4
        }
        /* Parameters not allowed after ECDSA or EdDSA algorithm OID. */
        else if (IsSigAlgoECC(cert->signatureOID)) {
 801834c:	68fb      	ldr	r3, [r7, #12]
 801834e:	699b      	ldr	r3, [r3, #24]
 8018350:	4618      	mov	r0, r3
 8018352:	f7fd fdf8 	bl	8015f46 <IsSigAlgoECC>
 8018356:	4603      	mov	r3, r0
 8018358:	2b00      	cmp	r3, #0
 801835a:	d012      	beq.n	8018382 <DecodeCertInternal+0x3c2>
        #ifndef WOLFSSL_ECC_SIGALG_PARAMS_NULL_ALLOWED
            if (dataASN[X509CERTASN_IDX_SIGALGO_PARAMS_NULL].tag != 0) {
 801835c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801835e:	f503 734b 	add.w	r3, r3, #812	@ 0x32c
 8018362:	7e5b      	ldrb	r3, [r3, #25]
 8018364:	2b00      	cmp	r3, #0
 8018366:	d002      	beq.n	801836e <DecodeCertInternal+0x3ae>
                WOLFSSL_ERROR_VERBOSE(ASN_PARSE_E);
                ret = ASN_PARSE_E;
 8018368:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801836c:	65bb      	str	r3, [r7, #88]	@ 0x58
            }
        #endif
        #ifdef WC_RSA_PSS
            if (dataASN[X509CERTASN_IDX_SIGALGO_PARAMS].tag != 0) {
 801836e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018370:	f503 7352 	add.w	r3, r3, #840	@ 0x348
 8018374:	7e5b      	ldrb	r3, [r3, #25]
 8018376:	2b00      	cmp	r3, #0
 8018378:	d06a      	beq.n	8018450 <DecodeCertInternal+0x490>
                WOLFSSL_ERROR_VERBOSE(ASN_PARSE_E);
                ret = ASN_PARSE_E;
 801837a:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801837e:	65bb      	str	r3, [r7, #88]	@ 0x58
 8018380:	e066      	b.n	8018450 <DecodeCertInternal+0x490>
            }
        #endif
        }
    #ifdef WC_RSA_PSS
        /* Check parameters starting with a SEQUENCE. */
        else if (dataASN[X509CERTASN_IDX_SIGALGO_PARAMS].tag != 0) {
 8018382:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018384:	f503 7352 	add.w	r3, r3, #840	@ 0x348
 8018388:	7e5b      	ldrb	r3, [r3, #25]
 801838a:	2b00      	cmp	r3, #0
 801838c:	d060      	beq.n	8018450 <DecodeCertInternal+0x490>
            word32 oid = dataASN[X509CERTASN_IDX_SIGALGO_OID].data.oid.sum;
 801838e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018390:	f503 7344 	add.w	r3, r3, #784	@ 0x310
 8018394:	695b      	ldr	r3, [r3, #20]
 8018396:	62fb      	str	r3, [r7, #44]	@ 0x2c
            word32 sigAlgParamsSz = 0;
 8018398:	2300      	movs	r3, #0
 801839a:	637b      	str	r3, [r7, #52]	@ 0x34

            /* Parameters only with RSA PSS. */
            if (oid != CTC_RSASSAPSS) {
 801839c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801839e:	f240 228e 	movw	r2, #654	@ 0x28e
 80183a2:	4293      	cmp	r3, r2
 80183a4:	d002      	beq.n	80183ac <DecodeCertInternal+0x3ec>
                WOLFSSL_ERROR_VERBOSE(ASN_PARSE_E);
                ret = ASN_PARSE_E;
 80183a6:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80183aa:	65bb      	str	r3, [r7, #88]	@ 0x58
            }
            if (ret == 0) {
 80183ac:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80183ae:	2b00      	cmp	r3, #0
 80183b0:	d142      	bne.n	8018438 <DecodeCertInternal+0x478>
                word32 tbsParamsSz;
                const byte* sigAlgParams;

                /* Check RSA PSS parameters are the same. */
                tbsParams =
                    GetASNItem_Addr(dataASN[X509CERTASN_IDX_TBS_ALGOID_PARAMS],
 80183b2:	68fb      	ldr	r3, [r7, #12]
 80183b4:	f8d3 2364 	ldr.w	r2, [r3, #868]	@ 0x364
 80183b8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80183ba:	33e0      	adds	r3, #224	@ 0xe0
 80183bc:	681b      	ldr	r3, [r3, #0]
                tbsParams =
 80183be:	4413      	add	r3, r2
 80183c0:	62bb      	str	r3, [r7, #40]	@ 0x28
                        cert->source);
                tbsParamsSz =
                    GetASNItem_Length(dataASN[X509CERTASN_IDX_TBS_ALGOID_PARAMS],
 80183c2:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80183c4:	33e0      	adds	r3, #224	@ 0xe0
 80183c6:	685b      	ldr	r3, [r3, #4]
 80183c8:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 80183ca:	32e0      	adds	r2, #224	@ 0xe0
 80183cc:	6891      	ldr	r1, [r2, #8]
 80183ce:	68fa      	ldr	r2, [r7, #12]
 80183d0:	f8d2 2364 	ldr.w	r2, [r2, #868]	@ 0x364
 80183d4:	1a8a      	subs	r2, r1, r2
 80183d6:	441a      	add	r2, r3
 80183d8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80183da:	33e0      	adds	r3, #224	@ 0xe0
 80183dc:	681b      	ldr	r3, [r3, #0]
                tbsParamsSz =
 80183de:	1ad3      	subs	r3, r2, r3
 80183e0:	627b      	str	r3, [r7, #36]	@ 0x24
                        cert->source);
                sigAlgParams =
                    GetASNItem_Addr(dataASN[X509CERTASN_IDX_SIGALGO_PARAMS],
 80183e2:	68fb      	ldr	r3, [r7, #12]
 80183e4:	f8d3 2364 	ldr.w	r2, [r3, #868]	@ 0x364
 80183e8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80183ea:	f503 7352 	add.w	r3, r3, #840	@ 0x348
 80183ee:	681b      	ldr	r3, [r3, #0]
                sigAlgParams =
 80183f0:	4413      	add	r3, r2
 80183f2:	623b      	str	r3, [r7, #32]
                        cert->source);
                sigAlgParamsSz =
                    GetASNItem_Length(dataASN[X509CERTASN_IDX_SIGALGO_PARAMS],
 80183f4:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80183f6:	f503 7352 	add.w	r3, r3, #840	@ 0x348
 80183fa:	685b      	ldr	r3, [r3, #4]
 80183fc:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 80183fe:	f502 7252 	add.w	r2, r2, #840	@ 0x348
 8018402:	6891      	ldr	r1, [r2, #8]
 8018404:	68fa      	ldr	r2, [r7, #12]
 8018406:	f8d2 2364 	ldr.w	r2, [r2, #868]	@ 0x364
 801840a:	1a8a      	subs	r2, r1, r2
 801840c:	441a      	add	r2, r3
 801840e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018410:	f503 7352 	add.w	r3, r3, #840	@ 0x348
 8018414:	681b      	ldr	r3, [r3, #0]
                sigAlgParamsSz =
 8018416:	1ad3      	subs	r3, r2, r3
 8018418:	637b      	str	r3, [r7, #52]	@ 0x34
                        cert->source);
                if ((tbsParamsSz != sigAlgParamsSz) ||
 801841a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801841c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801841e:	429a      	cmp	r2, r3
 8018420:	d107      	bne.n	8018432 <DecodeCertInternal+0x472>
                        (XMEMCMP(tbsParams, sigAlgParams, tbsParamsSz) != 0)) {
 8018422:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8018424:	6a39      	ldr	r1, [r7, #32]
 8018426:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8018428:	f010 f824 	bl	8028474 <memcmp>
 801842c:	4603      	mov	r3, r0
                if ((tbsParamsSz != sigAlgParamsSz) ||
 801842e:	2b00      	cmp	r3, #0
 8018430:	d002      	beq.n	8018438 <DecodeCertInternal+0x478>
                    WOLFSSL_ERROR_VERBOSE(ASN_PARSE_E);
                    ret = ASN_PARSE_E;
 8018432:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8018436:	65bb      	str	r3, [r7, #88]	@ 0x58
                }
            }
            if (ret == 0) {
 8018438:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801843a:	2b00      	cmp	r3, #0
 801843c:	d108      	bne.n	8018450 <DecodeCertInternal+0x490>
                /* Store parameters for use in signature verification. */
                cert->sigParamsIndex =
                    dataASN[X509CERTASN_IDX_SIGALGO_PARAMS].offset;
 801843e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018440:	f503 7352 	add.w	r3, r3, #840	@ 0x348
 8018444:	681a      	ldr	r2, [r3, #0]
                cert->sigParamsIndex =
 8018446:	68fb      	ldr	r3, [r7, #12]
 8018448:	621a      	str	r2, [r3, #32]
                cert->sigParamsLength = sigAlgParamsSz;
 801844a:	68fb      	ldr	r3, [r7, #12]
 801844c:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 801844e:	625a      	str	r2, [r3, #36]	@ 0x24
            }
        }
    #endif
    }
    if ((ret == 0) && (!done)) {
 8018450:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8018452:	2b00      	cmp	r3, #0
 8018454:	d112      	bne.n	801847c <DecodeCertInternal+0x4bc>
 8018456:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8018458:	2b00      	cmp	r3, #0
 801845a:	d10f      	bne.n	801847c <DecodeCertInternal+0x4bc>
        pubKeyEnd = dataASN[X509CERTASN_IDX_TBS_ISSUERUID].offset;
 801845c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801845e:	f503 7321 	add.w	r3, r3, #644	@ 0x284
 8018462:	681b      	ldr	r3, [r3, #0]
 8018464:	63fb      	str	r3, [r7, #60]	@ 0x3c
        if (stopAfterPubKey) {
 8018466:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8018468:	2b00      	cmp	r3, #0
 801846a:	d007      	beq.n	801847c <DecodeCertInternal+0x4bc>
            /* Return any bad date error through badDateRed and return offset
             * after subjectPublicKeyInfo.
             */
            if (badDateRet != NULL) {
 801846c:	683b      	ldr	r3, [r7, #0]
 801846e:	2b00      	cmp	r3, #0
 8018470:	d002      	beq.n	8018478 <DecodeCertInternal+0x4b8>
                *badDateRet = badDate;
 8018472:	683b      	ldr	r3, [r7, #0]
 8018474:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8018476:	601a      	str	r2, [r3, #0]
            }
            done = 1;
 8018478:	2301      	movs	r3, #1
 801847a:	63bb      	str	r3, [r7, #56]	@ 0x38
        }
    }
    if ((ret == 0) && (!done) &&
 801847c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801847e:	2b00      	cmp	r3, #0
 8018480:	d141      	bne.n	8018506 <DecodeCertInternal+0x546>
 8018482:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8018484:	2b00      	cmp	r3, #0
 8018486:	d13e      	bne.n	8018506 <DecodeCertInternal+0x546>
            (dataASN[X509CERTASN_IDX_TBS_EXT_SEQ].data.ref.data != NULL)) {
 8018488:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801848a:	f503 7336 	add.w	r3, r3, #728	@ 0x2d8
 801848e:	689b      	ldr	r3, [r3, #8]
    if ((ret == 0) && (!done) &&
 8018490:	2b00      	cmp	r3, #0
 8018492:	d038      	beq.n	8018506 <DecodeCertInternal+0x546>
    #ifndef ALLOW_V1_EXTENSIONS
        /* Certificate extensions were only defined in version 2. */
        if (cert->version < 2) {
 8018494:	68fb      	ldr	r3, [r7, #12]
 8018496:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8018498:	2b01      	cmp	r3, #1
 801849a:	dc02      	bgt.n	80184a2 <DecodeCertInternal+0x4e2>
            WOLFSSL_MSG("\tv1 and v2 certs not allowed extensions");
            WOLFSSL_ERROR_VERBOSE(ASN_VERSION_E);
            ret = ASN_VERSION_E;
 801849c:	f06f 038c 	mvn.w	r3, #140	@ 0x8c
 80184a0:	65bb      	str	r3, [r7, #88]	@ 0x58
        }
    #endif
        if (ret == 0) {
 80184a2:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80184a4:	2b00      	cmp	r3, #0
 80184a6:	d12e      	bne.n	8018506 <DecodeCertInternal+0x546>
            /* Save references to extension data. */
            cert->extensions    = GetASNItem_Addr(
 80184a8:	68fb      	ldr	r3, [r7, #12]
 80184aa:	f8d3 2364 	ldr.w	r2, [r3, #868]	@ 0x364
 80184ae:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80184b0:	f503 732f 	add.w	r3, r3, #700	@ 0x2bc
 80184b4:	681b      	ldr	r3, [r3, #0]
 80184b6:	441a      	add	r2, r3
 80184b8:	68fb      	ldr	r3, [r7, #12]
 80184ba:	f8c3 2398 	str.w	r2, [r3, #920]	@ 0x398
                    dataASN[X509CERTASN_IDX_TBS_EXT], cert->source);
            cert->extensionsSz  = (int)GetASNItem_Length(
 80184be:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80184c0:	f503 732f 	add.w	r3, r3, #700	@ 0x2bc
 80184c4:	685b      	ldr	r3, [r3, #4]
 80184c6:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 80184c8:	f502 722f 	add.w	r2, r2, #700	@ 0x2bc
 80184cc:	6891      	ldr	r1, [r2, #8]
 80184ce:	68fa      	ldr	r2, [r7, #12]
 80184d0:	f8d2 2364 	ldr.w	r2, [r2, #868]	@ 0x364
 80184d4:	1a8a      	subs	r2, r1, r2
 80184d6:	441a      	add	r2, r3
 80184d8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80184da:	f503 732f 	add.w	r3, r3, #700	@ 0x2bc
 80184de:	681b      	ldr	r3, [r3, #0]
 80184e0:	1ad3      	subs	r3, r2, r3
 80184e2:	461a      	mov	r2, r3
 80184e4:	68fb      	ldr	r3, [r7, #12]
 80184e6:	f8c3 239c 	str.w	r2, [r3, #924]	@ 0x39c
                    dataASN[X509CERTASN_IDX_TBS_EXT], cert->source);
            cert->extensionsIdx = dataASN[X509CERTASN_IDX_TBS_EXT].offset;
 80184ea:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80184ec:	f503 732f 	add.w	r3, r3, #700	@ 0x2bc
 80184f0:	681a      	ldr	r2, [r3, #0]
 80184f2:	68fb      	ldr	r3, [r7, #12]
 80184f4:	f8c3 23a0 	str.w	r2, [r3, #928]	@ 0x3a0
            /* Advance past extensions. */
            cert->srcIdx = dataASN[X509CERTASN_IDX_SIGALGO_SEQ].offset;
 80184f8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80184fa:	f503 733d 	add.w	r3, r3, #756	@ 0x2f4
 80184fe:	681a      	ldr	r2, [r3, #0]
 8018500:	68fb      	ldr	r3, [r7, #12]
 8018502:	f8c3 2368 	str.w	r2, [r3, #872]	@ 0x368
        }
    }

    /* Dispose of memory before allocating for extension decoding. */
    FREE_ASNGETDATA(dataASN, cert->heap);
 8018506:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018508:	2b00      	cmp	r3, #0
 801850a:	d007      	beq.n	801851c <DecodeCertInternal+0x55c>
 801850c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801850e:	61fb      	str	r3, [r7, #28]
 8018510:	69fb      	ldr	r3, [r7, #28]
 8018512:	2b00      	cmp	r3, #0
 8018514:	d002      	beq.n	801851c <DecodeCertInternal+0x55c>
 8018516:	69f8      	ldr	r0, [r7, #28]
 8018518:	f006 fad2 	bl	801eac0 <wolfSSL_Free>

    if ((ret == 0) && (issuer != NULL)) {
 801851c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801851e:	2b00      	cmp	r3, #0
 8018520:	d116      	bne.n	8018550 <DecodeCertInternal+0x590>
 8018522:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8018524:	2b00      	cmp	r3, #0
 8018526:	d013      	beq.n	8018550 <DecodeCertInternal+0x590>
        idx = 0;
 8018528:	2300      	movs	r3, #0
 801852a:	617b      	str	r3, [r7, #20]
        /* Put issuer into cert and calculate hash. */
        ret = GetCertName(cert, cert->issuer, cert->issuerHash, ASN_ISSUER, issuer,
 801852c:	68fb      	ldr	r3, [r7, #12]
 801852e:	f103 018d 	add.w	r1, r3, #141	@ 0x8d
 8018532:	68fb      	ldr	r3, [r7, #12]
 8018534:	f103 0260 	add.w	r2, r3, #96	@ 0x60
 8018538:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801853a:	9302      	str	r3, [sp, #8]
 801853c:	f107 0314 	add.w	r3, r7, #20
 8018540:	9301      	str	r3, [sp, #4]
 8018542:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8018544:	9300      	str	r3, [sp, #0]
 8018546:	2300      	movs	r3, #0
 8018548:	68f8      	ldr	r0, [r7, #12]
 801854a:	f7fd fb5d 	bl	8015c08 <GetCertName>
 801854e:	65b8      	str	r0, [r7, #88]	@ 0x58
            &idx, issuerSz);
    }
    if ((ret == 0) && (subject != NULL)) {
 8018550:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8018552:	2b00      	cmp	r3, #0
 8018554:	d116      	bne.n	8018584 <DecodeCertInternal+0x5c4>
 8018556:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8018558:	2b00      	cmp	r3, #0
 801855a:	d013      	beq.n	8018584 <DecodeCertInternal+0x5c4>
        idx = 0;
 801855c:	2300      	movs	r3, #0
 801855e:	617b      	str	r3, [r7, #20]
        /* Put subject into cert and calculate hash. */
        ret = GetCertName(cert, cert->subject, cert->subjectHash, ASN_SUBJECT,
 8018560:	68fb      	ldr	r3, [r7, #12]
 8018562:	f203 11f5 	addw	r1, r3, #501	@ 0x1f5
 8018566:	68fb      	ldr	r3, [r7, #12]
 8018568:	f103 0240 	add.w	r2, r3, #64	@ 0x40
 801856c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801856e:	9302      	str	r3, [sp, #8]
 8018570:	f107 0314 	add.w	r3, r7, #20
 8018574:	9301      	str	r3, [sp, #4]
 8018576:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8018578:	9300      	str	r3, [sp, #0]
 801857a:	2301      	movs	r3, #1
 801857c:	68f8      	ldr	r0, [r7, #12]
 801857e:	f7fd fb43 	bl	8015c08 <GetCertName>
 8018582:	65b8      	str	r0, [r7, #88]	@ 0x58
            subject, &idx, subjectSz);
    }
    if (ret == 0) {
 8018584:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8018586:	2b00      	cmp	r3, #0
 8018588:	d11a      	bne.n	80185c0 <DecodeCertInternal+0x600>
            cert->selfSigned = 1;
        }
        else
    #endif
        {
            cert->selfSigned = (XMEMCMP(cert->issuerHash, cert->subjectHash,
 801858a:	68fb      	ldr	r3, [r7, #12]
 801858c:	f103 0060 	add.w	r0, r3, #96	@ 0x60
 8018590:	68fb      	ldr	r3, [r7, #12]
 8018592:	3340      	adds	r3, #64	@ 0x40
 8018594:	2220      	movs	r2, #32
 8018596:	4619      	mov	r1, r3
 8018598:	f00f ff6c 	bl	8028474 <memcmp>
 801859c:	4603      	mov	r3, r0
                                        KEYID_SIZE) == 0);
 801859e:	2b00      	cmp	r3, #0
 80185a0:	bf0c      	ite	eq
 80185a2:	2301      	moveq	r3, #1
 80185a4:	2300      	movne	r3, #0
 80185a6:	b2d9      	uxtb	r1, r3
            cert->selfSigned = (XMEMCMP(cert->issuerHash, cert->subjectHash,
 80185a8:	68fa      	ldr	r2, [r7, #12]
 80185aa:	f892 34b6 	ldrb.w	r3, [r2, #1206]	@ 0x4b6
 80185ae:	f361 0341 	bfi	r3, r1, #1, #1
 80185b2:	f882 34b6 	strb.w	r3, [r2, #1206]	@ 0x4b6
        }
        if (stopAtPubKey) {
 80185b6:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80185b8:	2b00      	cmp	r3, #0
 80185ba:	d001      	beq.n	80185c0 <DecodeCertInternal+0x600>
            ret = (int)pubKeyOffset;
 80185bc:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80185be:	65bb      	str	r3, [r7, #88]	@ 0x58
        }
    }

    if ((ret == 0) && (!stopAtPubKey)) {
 80185c0:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80185c2:	2b00      	cmp	r3, #0
 80185c4:	d10e      	bne.n	80185e4 <DecodeCertInternal+0x624>
 80185c6:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80185c8:	2b00      	cmp	r3, #0
 80185ca:	d10b      	bne.n	80185e4 <DecodeCertInternal+0x624>
        /* Parse the public key. */
        idx = pubKeyOffset;
 80185cc:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80185ce:	617b      	str	r3, [r7, #20]
        ret = GetCertKey(cert, cert->source, &idx, pubKeyEnd);
 80185d0:	68fb      	ldr	r3, [r7, #12]
 80185d2:	f8d3 1364 	ldr.w	r1, [r3, #868]	@ 0x364
 80185d6:	f107 0214 	add.w	r2, r7, #20
 80185da:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80185dc:	68f8      	ldr	r0, [r7, #12]
 80185de:	f7fc ff8f 	bl	8015500 <GetCertKey>
 80185e2:	65b8      	str	r0, [r7, #88]	@ 0x58
    }
    if ((ret == 0) && (!stopAtPubKey) && (!stopAfterPubKey) &&
 80185e4:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80185e6:	2b00      	cmp	r3, #0
 80185e8:	d11e      	bne.n	8018628 <DecodeCertInternal+0x668>
 80185ea:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80185ec:	2b00      	cmp	r3, #0
 80185ee:	d11b      	bne.n	8018628 <DecodeCertInternal+0x668>
 80185f0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80185f2:	2b00      	cmp	r3, #0
 80185f4:	d118      	bne.n	8018628 <DecodeCertInternal+0x668>
            (cert->extensions != NULL)) {
 80185f6:	68fb      	ldr	r3, [r7, #12]
 80185f8:	f8d3 3398 	ldr.w	r3, [r3, #920]	@ 0x398
    if ((ret == 0) && (!stopAtPubKey) && (!stopAfterPubKey) &&
 80185fc:	2b00      	cmp	r3, #0
 80185fe:	d013      	beq.n	8018628 <DecodeCertInternal+0x668>
        /* Decode the extension data starting at [3]. */
        ret = DecodeCertExtensions(cert);
 8018600:	68f8      	ldr	r0, [r7, #12]
 8018602:	f7ff fbf7 	bl	8017df4 <DecodeCertExtensions>
 8018606:	65b8      	str	r0, [r7, #88]	@ 0x58
        if (criticalExt != NULL) {
 8018608:	687b      	ldr	r3, [r7, #4]
 801860a:	2b00      	cmp	r3, #0
 801860c:	d00c      	beq.n	8018628 <DecodeCertInternal+0x668>
            if (ret == WC_NO_ERR_TRACE(ASN_CRIT_EXT_E)) {
 801860e:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8018610:	f113 0fa0 	cmn.w	r3, #160	@ 0xa0
 8018614:	d105      	bne.n	8018622 <DecodeCertInternal+0x662>
                /* Return critical extension not recognized. */
                *criticalExt = ret;
 8018616:	687b      	ldr	r3, [r7, #4]
 8018618:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 801861a:	601a      	str	r2, [r3, #0]
                ret = 0;
 801861c:	2300      	movs	r3, #0
 801861e:	65bb      	str	r3, [r7, #88]	@ 0x58
 8018620:	e002      	b.n	8018628 <DecodeCertInternal+0x668>
            }
            else {
                /* No critical extension error. */
                *criticalExt = 0;
 8018622:	687b      	ldr	r3, [r7, #4]
 8018624:	2200      	movs	r2, #0
 8018626:	601a      	str	r2, [r3, #0]
            }
        }
    }

    if ((ret == 0) && (!done) && (badDate != 0)) {
 8018628:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801862a:	2b00      	cmp	r3, #0
 801862c:	d107      	bne.n	801863e <DecodeCertInternal+0x67e>
 801862e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8018630:	2b00      	cmp	r3, #0
 8018632:	d104      	bne.n	801863e <DecodeCertInternal+0x67e>
 8018634:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8018636:	2b00      	cmp	r3, #0
 8018638:	d001      	beq.n	801863e <DecodeCertInternal+0x67e>
        /* Parsed whole certificate fine but return any date errors. */
        ret = badDate;
 801863a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801863c:	65bb      	str	r3, [r7, #88]	@ 0x58
    }

    return ret;
 801863e:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
}
 8018640:	4618      	mov	r0, r3
 8018642:	3760      	adds	r7, #96	@ 0x60
 8018644:	46bd      	mov	sp, r7
 8018646:	bd80      	pop	{r7, pc}

08018648 <DecodeCert>:
 * @return  ASN_EXPECT_0_E when the INTEGER has the MSB set or NULL has a
 *          non-zero length.
 * @return  ASN_UNKNOWN_OID_E when the OID cannot be verified.
 */
int DecodeCert(DecodedCert* cert, int verify, int* criticalExt)
{
 8018648:	b580      	push	{r7, lr}
 801864a:	b086      	sub	sp, #24
 801864c:	af02      	add	r7, sp, #8
 801864e:	60f8      	str	r0, [r7, #12]
 8018650:	60b9      	str	r1, [r7, #8]
 8018652:	607a      	str	r2, [r7, #4]
    return DecodeCertInternal(cert, verify, criticalExt, NULL, 0, 0);
 8018654:	2300      	movs	r3, #0
 8018656:	9301      	str	r3, [sp, #4]
 8018658:	2300      	movs	r3, #0
 801865a:	9300      	str	r3, [sp, #0]
 801865c:	2300      	movs	r3, #0
 801865e:	687a      	ldr	r2, [r7, #4]
 8018660:	68b9      	ldr	r1, [r7, #8]
 8018662:	68f8      	ldr	r0, [r7, #12]
 8018664:	f7ff fcac 	bl	8017fc0 <DecodeCertInternal>
 8018668:	4603      	mov	r3, r0
}
 801866a:	4618      	mov	r0, r3
 801866c:	3710      	adds	r7, #16
 801866e:	46bd      	mov	sp, r7
 8018670:	bd80      	pop	{r7, pc}

08018672 <ParseCert>:
#endif /* WOLFSSL_CERT_REQ */

#endif

int ParseCert(DecodedCert* cert, int type, int verify, void* cm)
{
 8018672:	b580      	push	{r7, lr}
 8018674:	b088      	sub	sp, #32
 8018676:	af02      	add	r7, sp, #8
 8018678:	60f8      	str	r0, [r7, #12]
 801867a:	60b9      	str	r1, [r7, #8]
 801867c:	607a      	str	r2, [r7, #4]
 801867e:	603b      	str	r3, [r7, #0]
#if (!defined(WOLFSSL_NO_MALLOC) && !defined(NO_WOLFSSL_CM_VERIFY)) || \
    defined(WOLFSSL_DYN_CERT)
    char* ptr;
#endif

    ret = ParseCertRelative(cert, type, verify, cm, NULL);
 8018680:	2300      	movs	r3, #0
 8018682:	9300      	str	r3, [sp, #0]
 8018684:	683b      	ldr	r3, [r7, #0]
 8018686:	687a      	ldr	r2, [r7, #4]
 8018688:	68b9      	ldr	r1, [r7, #8]
 801868a:	68f8      	ldr	r0, [r7, #12]
 801868c:	f000 f869 	bl	8018762 <ParseCertRelative>
 8018690:	6178      	str	r0, [r7, #20]
    if (ret < 0)
 8018692:	697b      	ldr	r3, [r7, #20]
 8018694:	2b00      	cmp	r3, #0
 8018696:	da01      	bge.n	801869c <ParseCert+0x2a>
        return ret;
 8018698:	697b      	ldr	r3, [r7, #20]
 801869a:	e05e      	b.n	801875a <ParseCert+0xe8>

#if (!defined(WOLFSSL_NO_MALLOC) && !defined(NO_WOLFSSL_CM_VERIFY)) || \
    defined(WOLFSSL_DYN_CERT)
    /* cert->subjectCN not stored as copy of WOLFSSL_NO_MALLOC defined */
    if (cert->subjectCNLen > 0) {
 801869c:	68fb      	ldr	r3, [r7, #12]
 801869e:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 80186a2:	2b00      	cmp	r3, #0
 80186a4:	dd2a      	ble.n	80186fc <ParseCert+0x8a>
        ptr = (char*)XMALLOC((size_t)cert->subjectCNLen + 1, cert->heap,
 80186a6:	68fb      	ldr	r3, [r7, #12]
 80186a8:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 80186ac:	3301      	adds	r3, #1
 80186ae:	4618      	mov	r0, r3
 80186b0:	f006 f9ea 	bl	801ea88 <wolfSSL_Malloc>
 80186b4:	6138      	str	r0, [r7, #16]
                              DYNAMIC_TYPE_SUBJECT_CN);
        if (ptr == NULL)
 80186b6:	693b      	ldr	r3, [r7, #16]
 80186b8:	2b00      	cmp	r3, #0
 80186ba:	d102      	bne.n	80186c2 <ParseCert+0x50>
            return MEMORY_E;
 80186bc:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 80186c0:	e04b      	b.n	801875a <ParseCert+0xe8>
        XMEMCPY(ptr, cert->subjectCN, (size_t)cert->subjectCNLen);
 80186c2:	68fb      	ldr	r3, [r7, #12]
 80186c4:	f8d3 1084 	ldr.w	r1, [r3, #132]	@ 0x84
 80186c8:	68fb      	ldr	r3, [r7, #12]
 80186ca:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 80186ce:	461a      	mov	r2, r3
 80186d0:	6938      	ldr	r0, [r7, #16]
 80186d2:	f00f ff63 	bl	802859c <memcpy>
        ptr[cert->subjectCNLen] = '\0';
 80186d6:	68fb      	ldr	r3, [r7, #12]
 80186d8:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 80186dc:	461a      	mov	r2, r3
 80186de:	693b      	ldr	r3, [r7, #16]
 80186e0:	4413      	add	r3, r2
 80186e2:	2200      	movs	r2, #0
 80186e4:	701a      	strb	r2, [r3, #0]
        cert->subjectCN = ptr;
 80186e6:	68fb      	ldr	r3, [r7, #12]
 80186e8:	693a      	ldr	r2, [r7, #16]
 80186ea:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
        cert->subjectCNStored = 1;
 80186ee:	68fa      	ldr	r2, [r7, #12]
 80186f0:	f892 34b4 	ldrb.w	r3, [r2, #1204]	@ 0x4b4
 80186f4:	f043 0301 	orr.w	r3, r3, #1
 80186f8:	f882 34b4 	strb.w	r3, [r2, #1204]	@ 0x4b4
#endif

#if (!defined(WOLFSSL_NO_MALLOC) && !defined(NO_WOLFSSL_CM_VERIFY)) || \
    defined(WOLFSSL_DYN_CERT)
    /* cert->publicKey not stored as copy if WOLFSSL_NO_MALLOC defined */
    if ((cert->keyOID == RSAk
 80186fc:	68fb      	ldr	r3, [r7, #12]
 80186fe:	69db      	ldr	r3, [r3, #28]
 8018700:	f240 2285 	movw	r2, #645	@ 0x285
 8018704:	4293      	cmp	r3, r2
 8018706:	d005      	beq.n	8018714 <ParseCert+0xa2>
    #ifdef WC_RSA_PSS
         || cert->keyOID == RSAPSSk
 8018708:	68fb      	ldr	r3, [r7, #12]
 801870a:	69db      	ldr	r3, [r3, #28]
 801870c:	f240 228e 	movw	r2, #654	@ 0x28e
 8018710:	4293      	cmp	r3, r2
 8018712:	d121      	bne.n	8018758 <ParseCert+0xe6>
    #endif
         ) && cert->publicKey != NULL && cert->pubKeySize > 0) {
 8018714:	68fb      	ldr	r3, [r7, #12]
 8018716:	681b      	ldr	r3, [r3, #0]
 8018718:	2b00      	cmp	r3, #0
 801871a:	d01d      	beq.n	8018758 <ParseCert+0xe6>
 801871c:	68fb      	ldr	r3, [r7, #12]
 801871e:	685b      	ldr	r3, [r3, #4]
 8018720:	2b00      	cmp	r3, #0
 8018722:	d019      	beq.n	8018758 <ParseCert+0xe6>
        ptr = (char*)XMALLOC(cert->pubKeySize, cert->heap,
 8018724:	68fb      	ldr	r3, [r7, #12]
 8018726:	685b      	ldr	r3, [r3, #4]
 8018728:	4618      	mov	r0, r3
 801872a:	f006 f9ad 	bl	801ea88 <wolfSSL_Malloc>
 801872e:	6138      	str	r0, [r7, #16]
                              DYNAMIC_TYPE_PUBLIC_KEY);
        if (ptr == NULL)
 8018730:	693b      	ldr	r3, [r7, #16]
 8018732:	2b00      	cmp	r3, #0
 8018734:	d102      	bne.n	801873c <ParseCert+0xca>
            return MEMORY_E;
 8018736:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801873a:	e00e      	b.n	801875a <ParseCert+0xe8>
        XMEMCPY(ptr, cert->publicKey, cert->pubKeySize);
 801873c:	68fb      	ldr	r3, [r7, #12]
 801873e:	6819      	ldr	r1, [r3, #0]
 8018740:	68fb      	ldr	r3, [r7, #12]
 8018742:	685b      	ldr	r3, [r3, #4]
 8018744:	461a      	mov	r2, r3
 8018746:	6938      	ldr	r0, [r7, #16]
 8018748:	f00f ff28 	bl	802859c <memcpy>
        cert->publicKey = (byte *)ptr;
 801874c:	68fb      	ldr	r3, [r7, #12]
 801874e:	693a      	ldr	r2, [r7, #16]
 8018750:	601a      	str	r2, [r3, #0]
        cert->pubKeyStored = 1;
 8018752:	68fb      	ldr	r3, [r7, #12]
 8018754:	2201      	movs	r2, #1
 8018756:	609a      	str	r2, [r3, #8]
    }
#endif

    return ret;
 8018758:	697b      	ldr	r3, [r7, #20]
}
 801875a:	4618      	mov	r0, r3
 801875c:	3718      	adds	r7, #24
 801875e:	46bd      	mov	sp, r7
 8018760:	bd80      	pop	{r7, pc}

08018762 <ParseCertRelative>:
    }
    return NULL;
}

int ParseCertRelative(DecodedCert* cert, int type, int verify, void* cm, Signer *extraCAList)
{
 8018762:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8018766:	b092      	sub	sp, #72	@ 0x48
 8018768:	af08      	add	r7, sp, #32
 801876a:	6178      	str	r0, [r7, #20]
 801876c:	6139      	str	r1, [r7, #16]
 801876e:	60fa      	str	r2, [r7, #12]
 8018770:	60bb      	str	r3, [r7, #8]
    int    ret = 0;
 8018772:	2300      	movs	r3, #0
 8018774:	627b      	str	r3, [r7, #36]	@ 0x24
    int    idx = 0;
#endif
    byte*  sce_tsip_encRsaKeyIdx;
    (void)extraCAList;

    if (cert == NULL) {
 8018776:	697b      	ldr	r3, [r7, #20]
 8018778:	2b00      	cmp	r3, #0
 801877a:	d102      	bne.n	8018782 <ParseCertRelative+0x20>
        return BAD_FUNC_ARG;
 801877c:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8018780:	e202      	b.n	8018b88 <ParseCertRelative+0x426>
#ifdef WOLFSSL_CERT_REQ
    if (type == CERTREQ_TYPE)
        cert->isCSR = 1;
#endif

    if (cert->sigCtx.state == SIG_STATE_BEGIN) {
 8018782:	697b      	ldr	r3, [r7, #20]
 8018784:	f8d3 3490 	ldr.w	r3, [r3, #1168]	@ 0x490
 8018788:	2b00      	cmp	r3, #0
 801878a:	f040 816f 	bne.w	8018a6c <ParseCertRelative+0x30a>
            }
        }
        else
#endif
        {
            ret = DecodeCert(cert, verify, &cert->criticalExt);
 801878e:	697b      	ldr	r3, [r7, #20]
 8018790:	f503 6396 	add.w	r3, r3, #1200	@ 0x4b0
 8018794:	461a      	mov	r2, r3
 8018796:	68f9      	ldr	r1, [r7, #12]
 8018798:	6978      	ldr	r0, [r7, #20]
 801879a:	f7ff ff55 	bl	8018648 <DecodeCert>
 801879e:	6278      	str	r0, [r7, #36]	@ 0x24
            if (ret == WC_NO_ERR_TRACE(ASN_BEFORE_DATE_E) ||
 80187a0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80187a2:	f113 0f96 	cmn.w	r3, #150	@ 0x96
 80187a6:	d003      	beq.n	80187b0 <ParseCertRelative+0x4e>
 80187a8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80187aa:	f113 0f97 	cmn.w	r3, #151	@ 0x97
 80187ae:	d109      	bne.n	80187c4 <ParseCertRelative+0x62>
                ret == WC_NO_ERR_TRACE(ASN_AFTER_DATE_E)) {
                cert->badDate = ret;
 80187b0:	697b      	ldr	r3, [r7, #20]
 80187b2:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80187b4:	f8c3 24ac 	str.w	r2, [r3, #1196]	@ 0x4ac
                if (verify == VERIFY_SKIP_DATE)
 80187b8:	68fb      	ldr	r3, [r7, #12]
 80187ba:	2b05      	cmp	r3, #5
 80187bc:	d107      	bne.n	80187ce <ParseCertRelative+0x6c>
                    ret = 0;
 80187be:	2300      	movs	r3, #0
 80187c0:	627b      	str	r3, [r7, #36]	@ 0x24
                if (verify == VERIFY_SKIP_DATE)
 80187c2:	e004      	b.n	80187ce <ParseCertRelative+0x6c>
            }
            else if (ret < 0) {
 80187c4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80187c6:	2b00      	cmp	r3, #0
 80187c8:	da01      	bge.n	80187ce <ParseCertRelative+0x6c>
                WOLFSSL_ERROR_VERBOSE(ret);
                return ret;
 80187ca:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80187cc:	e1dc      	b.n	8018b88 <ParseCertRelative+0x426>

    #ifndef ALLOW_INVALID_CERTSIGN
        /* https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.9
         *   If the cA boolean is not asserted, then the keyCertSign bit in the
         *   key usage extension MUST NOT be asserted. */
        if (!cert->isCA && cert->extKeyUsageSet &&
 80187ce:	697b      	ldr	r3, [r7, #20]
 80187d0:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 80187d4:	f003 0310 	and.w	r3, r3, #16
 80187d8:	b2db      	uxtb	r3, r3
 80187da:	2b00      	cmp	r3, #0
 80187dc:	d111      	bne.n	8018802 <ParseCertRelative+0xa0>
 80187de:	697b      	ldr	r3, [r7, #20]
 80187e0:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 80187e4:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 80187e8:	b2db      	uxtb	r3, r3
 80187ea:	2b00      	cmp	r3, #0
 80187ec:	d009      	beq.n	8018802 <ParseCertRelative+0xa0>
                (cert->extKeyUsage & KEYUSE_KEY_CERT_SIGN) != 0) {
 80187ee:	697b      	ldr	r3, [r7, #20]
 80187f0:	f8b3 3420 	ldrh.w	r3, [r3, #1056]	@ 0x420
 80187f4:	f003 0304 	and.w	r3, r3, #4
        if (!cert->isCA && cert->extKeyUsageSet &&
 80187f8:	2b00      	cmp	r3, #0
 80187fa:	d002      	beq.n	8018802 <ParseCertRelative+0xa0>
            WOLFSSL_ERROR_VERBOSE(KEYUSAGE_E);
            return KEYUSAGE_E;
 80187fc:	f06f 03e1 	mvn.w	r3, #225	@ 0xe1
 8018800:	e1c2      	b.n	8018b88 <ParseCertRelative+0x426>
        }
    #endif

    #ifndef NO_SKID
        if (cert->extSubjKeyIdSet == 0 && cert->publicKey != NULL &&
 8018802:	697b      	ldr	r3, [r7, #20]
 8018804:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 8018808:	f003 0302 	and.w	r3, r3, #2
 801880c:	b2db      	uxtb	r3, r3
 801880e:	2b00      	cmp	r3, #0
 8018810:	d13a      	bne.n	8018888 <ParseCertRelative+0x126>
 8018812:	697b      	ldr	r3, [r7, #20]
 8018814:	681b      	ldr	r3, [r3, #0]
 8018816:	2b00      	cmp	r3, #0
 8018818:	d036      	beq.n	8018888 <ParseCertRelative+0x126>
                                                         cert->pubKeySize > 0) {
 801881a:	697b      	ldr	r3, [r7, #20]
 801881c:	685b      	ldr	r3, [r3, #4]
        if (cert->extSubjKeyIdSet == 0 && cert->publicKey != NULL &&
 801881e:	2b00      	cmp	r3, #0
 8018820:	d032      	beq.n	8018888 <ParseCertRelative+0x126>
            if (cert->signatureOID == CTC_SM3wSM2) {
 8018822:	697b      	ldr	r3, [r7, #20]
 8018824:	699b      	ldr	r3, [r3, #24]
 8018826:	f5b3 7f39 	cmp.w	r3, #740	@ 0x2e4
 801882a:	d115      	bne.n	8018858 <ParseCertRelative+0xf6>
                /* TODO: GmSSL creates IDs this way but whole public key info
                 * block should be hashed. */
                ret = CalcHashId_ex(cert->publicKey + cert->pubKeySize - 65, 65,
 801882c:	697b      	ldr	r3, [r7, #20]
 801882e:	681a      	ldr	r2, [r3, #0]
 8018830:	697b      	ldr	r3, [r7, #20]
 8018832:	685b      	ldr	r3, [r3, #4]
 8018834:	3b41      	subs	r3, #65	@ 0x41
 8018836:	18d4      	adds	r4, r2, r3
                    cert->extSubjKeyId, HashIdAlg(cert->signatureOID));
 8018838:	697b      	ldr	r3, [r7, #20]
 801883a:	f503 7571 	add.w	r5, r3, #964	@ 0x3c4
                ret = CalcHashId_ex(cert->publicKey + cert->pubKeySize - 65, 65,
 801883e:	697b      	ldr	r3, [r7, #20]
 8018840:	699b      	ldr	r3, [r3, #24]
 8018842:	4618      	mov	r0, r3
 8018844:	f7fc ff50 	bl	80156e8 <HashIdAlg>
 8018848:	4603      	mov	r3, r0
 801884a:	462a      	mov	r2, r5
 801884c:	2141      	movs	r1, #65	@ 0x41
 801884e:	4620      	mov	r0, r4
 8018850:	f7fc ff66 	bl	8015720 <CalcHashId_ex>
 8018854:	6278      	str	r0, [r7, #36]	@ 0x24
 8018856:	e012      	b.n	801887e <ParseCertRelative+0x11c>
            }
            else {
                ret = CalcHashId_ex(cert->publicKey, cert->pubKeySize,
 8018858:	697b      	ldr	r3, [r7, #20]
 801885a:	681c      	ldr	r4, [r3, #0]
 801885c:	697b      	ldr	r3, [r7, #20]
 801885e:	685d      	ldr	r5, [r3, #4]
                    cert->extSubjKeyId, HashIdAlg(cert->signatureOID));
 8018860:	697b      	ldr	r3, [r7, #20]
 8018862:	f503 7671 	add.w	r6, r3, #964	@ 0x3c4
                ret = CalcHashId_ex(cert->publicKey, cert->pubKeySize,
 8018866:	697b      	ldr	r3, [r7, #20]
 8018868:	699b      	ldr	r3, [r3, #24]
 801886a:	4618      	mov	r0, r3
 801886c:	f7fc ff3c 	bl	80156e8 <HashIdAlg>
 8018870:	4603      	mov	r3, r0
 8018872:	4632      	mov	r2, r6
 8018874:	4629      	mov	r1, r5
 8018876:	4620      	mov	r0, r4
 8018878:	f7fc ff52 	bl	8015720 <CalcHashId_ex>
 801887c:	6278      	str	r0, [r7, #36]	@ 0x24
            }
            if (ret != 0) {
 801887e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018880:	2b00      	cmp	r3, #0
 8018882:	d001      	beq.n	8018888 <ParseCertRelative+0x126>
                WOLFSSL_ERROR_VERBOSE(ret);
                return ret;
 8018884:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018886:	e17f      	b.n	8018b88 <ParseCertRelative+0x426>
            }
        }
    #endif /* !NO_SKID */

        if (!cert->selfSigned || (verify != NO_VERIFY && type != CA_TYPE &&
 8018888:	697b      	ldr	r3, [r7, #20]
 801888a:	f893 34b6 	ldrb.w	r3, [r3, #1206]	@ 0x4b6
 801888e:	f003 0302 	and.w	r3, r3, #2
 8018892:	b2db      	uxtb	r3, r3
 8018894:	2b00      	cmp	r3, #0
 8018896:	d00b      	beq.n	80188b0 <ParseCertRelative+0x14e>
 8018898:	68fb      	ldr	r3, [r7, #12]
 801889a:	2b00      	cmp	r3, #0
 801889c:	f000 8090 	beq.w	80189c0 <ParseCertRelative+0x25e>
 80188a0:	693b      	ldr	r3, [r7, #16]
 80188a2:	2b06      	cmp	r3, #6
 80188a4:	f000 808c 	beq.w	80189c0 <ParseCertRelative+0x25e>
 80188a8:	693b      	ldr	r3, [r7, #16]
 80188aa:	2b11      	cmp	r3, #17
 80188ac:	f000 8088 	beq.w	80189c0 <ParseCertRelative+0x25e>
                                                   type != TRUSTED_PEER_TYPE)) {
            cert->ca = NULL;
 80188b0:	697b      	ldr	r3, [r7, #20]
 80188b2:	2200      	movs	r2, #0
 80188b4:	f8c3 2470 	str.w	r2, [r3, #1136]	@ 0x470
        if (extraCAList != NULL) {
            cert->ca = findSignerByName(extraCAList, cert->issuerHash);
        }
#endif
    #ifndef NO_SKID
            if (cert->ca == NULL && cert->extAuthKeyIdSet) {
 80188b8:	697b      	ldr	r3, [r7, #20]
 80188ba:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 80188be:	2b00      	cmp	r3, #0
 80188c0:	d12c      	bne.n	801891c <ParseCertRelative+0x1ba>
 80188c2:	697b      	ldr	r3, [r7, #20]
 80188c4:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 80188c8:	f003 0304 	and.w	r3, r3, #4
 80188cc:	b2db      	uxtb	r3, r3
 80188ce:	2b00      	cmp	r3, #0
 80188d0:	d024      	beq.n	801891c <ParseCertRelative+0x1ba>
                cert->ca = GetCA(cm, cert->extAuthKeyId);
 80188d2:	697b      	ldr	r3, [r7, #20]
 80188d4:	f503 737a 	add.w	r3, r3, #1000	@ 0x3e8
 80188d8:	4619      	mov	r1, r3
 80188da:	68b8      	ldr	r0, [r7, #8]
 80188dc:	f7f3 fcfa 	bl	800c2d4 <GetCA>
 80188e0:	4602      	mov	r2, r0
 80188e2:	697b      	ldr	r3, [r7, #20]
 80188e4:	f8c3 2470 	str.w	r2, [r3, #1136]	@ 0x470
        #ifdef WOLFSSL_AKID_NAME
                if (cert->ca == NULL) {
 80188e8:	697b      	ldr	r3, [r7, #20]
 80188ea:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 80188ee:	2b00      	cmp	r3, #0
 80188f0:	d114      	bne.n	801891c <ParseCertRelative+0x1ba>
                    cert->ca = GetCAByAKID(cm, cert->extAuthKeyIdIssuer,
 80188f2:	697b      	ldr	r3, [r7, #20]
 80188f4:	f8d3 140c 	ldr.w	r1, [r3, #1036]	@ 0x40c
 80188f8:	697b      	ldr	r3, [r7, #20]
 80188fa:	f8d3 2410 	ldr.w	r2, [r3, #1040]	@ 0x410
 80188fe:	697b      	ldr	r3, [r7, #20]
 8018900:	f8d3 0414 	ldr.w	r0, [r3, #1044]	@ 0x414
 8018904:	697b      	ldr	r3, [r7, #20]
 8018906:	f8d3 3418 	ldr.w	r3, [r3, #1048]	@ 0x418
 801890a:	9300      	str	r3, [sp, #0]
 801890c:	4603      	mov	r3, r0
 801890e:	68b8      	ldr	r0, [r7, #8]
 8018910:	f7f3 fd26 	bl	800c360 <GetCAByAKID>
 8018914:	4602      	mov	r2, r0
 8018916:	697b      	ldr	r3, [r7, #20]
 8018918:	f8c3 2470 	str.w	r2, [r3, #1136]	@ 0x470
                        cert->extAuthKeyIdIssuerSz, cert->extAuthKeyIdIssuerSN,
                        cert->extAuthKeyIdIssuerSNSz);
                }
        #endif
            }
            if (cert->ca == NULL && cert->extSubjKeyIdSet
 801891c:	697b      	ldr	r3, [r7, #20]
 801891e:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 8018922:	2b00      	cmp	r3, #0
 8018924:	d115      	bne.n	8018952 <ParseCertRelative+0x1f0>
 8018926:	697b      	ldr	r3, [r7, #20]
 8018928:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 801892c:	f003 0302 	and.w	r3, r3, #2
 8018930:	b2db      	uxtb	r3, r3
 8018932:	2b00      	cmp	r3, #0
 8018934:	d00d      	beq.n	8018952 <ParseCertRelative+0x1f0>
                                 && verify != VERIFY_OCSP) {
 8018936:	68fb      	ldr	r3, [r7, #12]
 8018938:	2b03      	cmp	r3, #3
 801893a:	d00a      	beq.n	8018952 <ParseCertRelative+0x1f0>
                cert->ca = GetCA(cm, cert->extSubjKeyId);
 801893c:	697b      	ldr	r3, [r7, #20]
 801893e:	f503 7371 	add.w	r3, r3, #964	@ 0x3c4
 8018942:	4619      	mov	r1, r3
 8018944:	68b8      	ldr	r0, [r7, #8]
 8018946:	f7f3 fcc5 	bl	800c2d4 <GetCA>
 801894a:	4602      	mov	r2, r0
 801894c:	697b      	ldr	r3, [r7, #20]
 801894e:	f8c3 2470 	str.w	r2, [r3, #1136]	@ 0x470
            }
            if (cert->ca != NULL && XMEMCMP(cert->issuerHash,
 8018952:	697b      	ldr	r3, [r7, #20]
 8018954:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 8018958:	2b00      	cmp	r3, #0
 801895a:	d011      	beq.n	8018980 <ParseCertRelative+0x21e>
 801895c:	697b      	ldr	r3, [r7, #20]
 801895e:	f103 0060 	add.w	r0, r3, #96	@ 0x60
 8018962:	697b      	ldr	r3, [r7, #20]
 8018964:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 8018968:	3320      	adds	r3, #32
 801896a:	2220      	movs	r2, #32
 801896c:	4619      	mov	r1, r3
 801896e:	f00f fd81 	bl	8028474 <memcmp>
 8018972:	4603      	mov	r3, r0
 8018974:	2b00      	cmp	r3, #0
 8018976:	d003      	beq.n	8018980 <ParseCertRelative+0x21e>
                    cert->ca->subjectNameHash, KEYID_SIZE) != 0) {
                cert->ca = NULL;
 8018978:	697b      	ldr	r3, [r7, #20]
 801897a:	2200      	movs	r2, #0
 801897c:	f8c3 2470 	str.w	r2, [r3, #1136]	@ 0x470
            }
            if (cert->ca == NULL) {
 8018980:	697b      	ldr	r3, [r7, #20]
 8018982:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 8018986:	2b00      	cmp	r3, #0
 8018988:	d11a      	bne.n	80189c0 <ParseCertRelative+0x25e>
                cert->ca = GetCAByName(cm, cert->issuerHash);
 801898a:	697b      	ldr	r3, [r7, #20]
 801898c:	3360      	adds	r3, #96	@ 0x60
 801898e:	4619      	mov	r1, r3
 8018990:	68b8      	ldr	r0, [r7, #8]
 8018992:	f7f3 fd5d 	bl	800c450 <GetCAByName>
 8018996:	4602      	mov	r2, r0
 8018998:	697b      	ldr	r3, [r7, #20]
 801899a:	f8c3 2470 	str.w	r2, [r3, #1136]	@ 0x470
                /* If AKID is available then this CA doesn't have the public
                 * key required */
                if (cert->ca && cert->extAuthKeyIdSet) {
 801899e:	697b      	ldr	r3, [r7, #20]
 80189a0:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 80189a4:	2b00      	cmp	r3, #0
 80189a6:	d00b      	beq.n	80189c0 <ParseCertRelative+0x25e>
 80189a8:	697b      	ldr	r3, [r7, #20]
 80189aa:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 80189ae:	f003 0304 	and.w	r3, r3, #4
 80189b2:	b2db      	uxtb	r3, r3
 80189b4:	2b00      	cmp	r3, #0
 80189b6:	d003      	beq.n	80189c0 <ParseCertRelative+0x25e>
                    WOLFSSL_MSG("CA SKID doesn't match AKID");
                    cert->ca = NULL;
 80189b8:	697b      	ldr	r3, [r7, #20]
 80189ba:	2200      	movs	r2, #0
 80189bc:	f8c3 2470 	str.w	r2, [r3, #1136]	@ 0x470
                WOLFSSL_MSG("CA found");
            }
        }

        /* Set to WOLFSSL_MAX_PATH_LEN by default in InitDecodedCert_ex */
        if (cert->pathLengthSet)
 80189c0:	697b      	ldr	r3, [r7, #20]
 80189c2:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 80189c6:	f003 0320 	and.w	r3, r3, #32
 80189ca:	b2db      	uxtb	r3, r3
 80189cc:	2b00      	cmp	r3, #0
 80189ce:	d005      	beq.n	80189dc <ParseCertRelative+0x27a>
            cert->maxPathLen = cert->pathLength;
 80189d0:	697b      	ldr	r3, [r7, #20]
 80189d2:	f893 241c 	ldrb.w	r2, [r3, #1052]	@ 0x41c
 80189d6:	697b      	ldr	r3, [r7, #20]
 80189d8:	f883 241d 	strb.w	r2, [r3, #1053]	@ 0x41d

        if (!cert->selfSigned) {
 80189dc:	697b      	ldr	r3, [r7, #20]
 80189de:	f893 34b6 	ldrb.w	r3, [r3, #1206]	@ 0x4b6
 80189e2:	f003 0302 	and.w	r3, r3, #2
 80189e6:	b2db      	uxtb	r3, r3
 80189e8:	2b00      	cmp	r3, #0
 80189ea:	d13f      	bne.n	8018a6c <ParseCertRelative+0x30a>
            /* Need to perform a pathlen check on anything that will be used
             * to sign certificates later on. Otherwise, pathLen doesn't
             * mean anything.
             * Nothing to check if we don't have the issuer of this cert. */
            if (type != CERT_TYPE && cert->isCA && cert->extKeyUsageSet &&
 80189ec:	693b      	ldr	r3, [r7, #16]
 80189ee:	2b00      	cmp	r3, #0
 80189f0:	d03c      	beq.n	8018a6c <ParseCertRelative+0x30a>
 80189f2:	697b      	ldr	r3, [r7, #20]
 80189f4:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 80189f8:	f003 0310 	and.w	r3, r3, #16
 80189fc:	b2db      	uxtb	r3, r3
 80189fe:	2b00      	cmp	r3, #0
 8018a00:	d034      	beq.n	8018a6c <ParseCertRelative+0x30a>
 8018a02:	697b      	ldr	r3, [r7, #20]
 8018a04:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 8018a08:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 8018a0c:	b2db      	uxtb	r3, r3
 8018a0e:	2b00      	cmp	r3, #0
 8018a10:	d02c      	beq.n	8018a6c <ParseCertRelative+0x30a>
                (cert->extKeyUsage & KEYUSE_KEY_CERT_SIGN) != 0 && cert->ca) {
 8018a12:	697b      	ldr	r3, [r7, #20]
 8018a14:	f8b3 3420 	ldrh.w	r3, [r3, #1056]	@ 0x420
 8018a18:	f003 0304 	and.w	r3, r3, #4
            if (type != CERT_TYPE && cert->isCA && cert->extKeyUsageSet &&
 8018a1c:	2b00      	cmp	r3, #0
 8018a1e:	d025      	beq.n	8018a6c <ParseCertRelative+0x30a>
                (cert->extKeyUsage & KEYUSE_KEY_CERT_SIGN) != 0 && cert->ca) {
 8018a20:	697b      	ldr	r3, [r7, #20]
 8018a22:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 8018a26:	2b00      	cmp	r3, #0
 8018a28:	d020      	beq.n	8018a6c <ParseCertRelative+0x30a>
                if (cert->ca->maxPathLen == 0) {
 8018a2a:	697b      	ldr	r3, [r7, #20]
 8018a2c:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 8018a30:	7a9b      	ldrb	r3, [r3, #10]
 8018a32:	2b00      	cmp	r3, #0
 8018a34:	d109      	bne.n	8018a4a <ParseCertRelative+0x2e8>
                    /* This cert CAN NOT be used as an intermediate cert. The
                     * issuer does not allow it. */
                    cert->maxPathLen = 0;
 8018a36:	697b      	ldr	r3, [r7, #20]
 8018a38:	2200      	movs	r2, #0
 8018a3a:	f883 241d 	strb.w	r2, [r3, #1053]	@ 0x41d
                    if (verify != NO_VERIFY) {
 8018a3e:	68fb      	ldr	r3, [r7, #12]
 8018a40:	2b00      	cmp	r3, #0
 8018a42:	d013      	beq.n	8018a6c <ParseCertRelative+0x30a>
                        WOLFSSL_MSG("\tNon-entity cert, maxPathLen is 0");
                        WOLFSSL_MSG("\tmaxPathLen status: ERROR");
                        WOLFSSL_ERROR_VERBOSE(ASN_PATHLEN_INV_E);
                        return ASN_PATHLEN_INV_E;
 8018a44:	f06f 03ed 	mvn.w	r3, #237	@ 0xed
 8018a48:	e09e      	b.n	8018b88 <ParseCertRelative+0x426>
                    }
                }
                else {
                    cert->maxPathLen = (byte)min(cert->ca->maxPathLen - 1U,
 8018a4a:	697b      	ldr	r3, [r7, #20]
 8018a4c:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 8018a50:	7a9b      	ldrb	r3, [r3, #10]
 8018a52:	1e5a      	subs	r2, r3, #1
                                           cert->maxPathLen);
 8018a54:	697b      	ldr	r3, [r7, #20]
 8018a56:	f893 341d 	ldrb.w	r3, [r3, #1053]	@ 0x41d
                    cert->maxPathLen = (byte)min(cert->ca->maxPathLen - 1U,
 8018a5a:	4619      	mov	r1, r3
 8018a5c:	4610      	mov	r0, r2
 8018a5e:	f7f9 fe31 	bl	80126c4 <min>
 8018a62:	4603      	mov	r3, r0
 8018a64:	b2da      	uxtb	r2, r3
 8018a66:	697b      	ldr	r3, [r7, #20]
 8018a68:	f883 241d 	strb.w	r2, [r3, #1053]	@ 0x41d
    }

    sce_tsip_encRsaKeyIdx = cert->sce_tsip_encRsaKeyIdx;

#else
    sce_tsip_encRsaKeyIdx = NULL;
 8018a6c:	2300      	movs	r3, #0
 8018a6e:	623b      	str	r3, [r7, #32]
#endif

    if (verify != NO_VERIFY && type != CA_TYPE && type != TRUSTED_PEER_TYPE) {
 8018a70:	68fb      	ldr	r3, [r7, #12]
 8018a72:	2b00      	cmp	r3, #0
 8018a74:	d072      	beq.n	8018b5c <ParseCertRelative+0x3fa>
 8018a76:	693b      	ldr	r3, [r7, #16]
 8018a78:	2b06      	cmp	r3, #6
 8018a7a:	d06f      	beq.n	8018b5c <ParseCertRelative+0x3fa>
 8018a7c:	693b      	ldr	r3, [r7, #16]
 8018a7e:	2b11      	cmp	r3, #17
 8018a80:	d06c      	beq.n	8018b5c <ParseCertRelative+0x3fa>
        if (cert->ca) {
 8018a82:	697b      	ldr	r3, [r7, #20]
 8018a84:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 8018a88:	2b00      	cmp	r3, #0
 8018a8a:	d064      	beq.n	8018b56 <ParseCertRelative+0x3f4>
            if (verify == VERIFY || verify == VERIFY_OCSP ||
 8018a8c:	68fb      	ldr	r3, [r7, #12]
 8018a8e:	2b01      	cmp	r3, #1
 8018a90:	d005      	beq.n	8018a9e <ParseCertRelative+0x33c>
 8018a92:	68fb      	ldr	r3, [r7, #12]
 8018a94:	2b03      	cmp	r3, #3
 8018a96:	d002      	beq.n	8018a9e <ParseCertRelative+0x33c>
 8018a98:	68fb      	ldr	r3, [r7, #12]
 8018a9a:	2b05      	cmp	r3, #5
 8018a9c:	d142      	bne.n	8018b24 <ParseCertRelative+0x3c2>
                                                 verify == VERIFY_SKIP_DATE) {
                word32 keyOID = cert->ca->keyOID;
 8018a9e:	697b      	ldr	r3, [r7, #20]
 8018aa0:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 8018aa4:	685b      	ldr	r3, [r3, #4]
 8018aa6:	61fb      	str	r3, [r7, #28]
                if (cert->selfSigned && (cert->signatureOID == CTC_SM3wSM2)) {
                    keyOID = SM2k;
                }
            #endif
                /* try to confirm/verify signature */
                if ((ret = ConfirmSignature(&cert->sigCtx,
 8018aa8:	697b      	ldr	r3, [r7, #20]
 8018aaa:	f203 4c74 	addw	ip, r3, #1140	@ 0x474
                        cert->source + cert->certBegin,
 8018aae:	697b      	ldr	r3, [r7, #20]
 8018ab0:	f8d3 2364 	ldr.w	r2, [r3, #868]	@ 0x364
 8018ab4:	697b      	ldr	r3, [r7, #20]
 8018ab6:	68db      	ldr	r3, [r3, #12]
                if ((ret = ConfirmSignature(&cert->sigCtx,
 8018ab8:	eb02 0e03 	add.w	lr, r2, r3
                        cert->sigIndex - cert->certBegin,
 8018abc:	697b      	ldr	r3, [r7, #20]
 8018abe:	691a      	ldr	r2, [r3, #16]
 8018ac0:	697b      	ldr	r3, [r7, #20]
 8018ac2:	68db      	ldr	r3, [r3, #12]
                if ((ret = ConfirmSignature(&cert->sigCtx,
 8018ac4:	eba2 0803 	sub.w	r8, r2, r3
                        cert->ca->publicKey, cert->ca->pubKeySize,
 8018ac8:	697b      	ldr	r3, [r7, #20]
 8018aca:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
                if ((ret = ConfirmSignature(&cert->sigCtx,
 8018ace:	68db      	ldr	r3, [r3, #12]
 8018ad0:	607b      	str	r3, [r7, #4]
                        cert->ca->publicKey, cert->ca->pubKeySize,
 8018ad2:	697b      	ldr	r3, [r7, #20]
 8018ad4:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
                if ((ret = ConfirmSignature(&cert->sigCtx,
 8018ad8:	681b      	ldr	r3, [r3, #0]
 8018ada:	697a      	ldr	r2, [r7, #20]
 8018adc:	f8d2 2080 	ldr.w	r2, [r2, #128]	@ 0x80
 8018ae0:	6979      	ldr	r1, [r7, #20]
 8018ae2:	6949      	ldr	r1, [r1, #20]
 8018ae4:	6978      	ldr	r0, [r7, #20]
 8018ae6:	6980      	ldr	r0, [r0, #24]
                        keyOID, cert->signature, cert->sigLength,
                        cert->signatureOID,
                    #ifdef WC_RSA_PSS
                        cert->source + cert->sigParamsIndex,
 8018ae8:	697c      	ldr	r4, [r7, #20]
 8018aea:	f8d4 5364 	ldr.w	r5, [r4, #868]	@ 0x364
 8018aee:	697c      	ldr	r4, [r7, #20]
 8018af0:	6a24      	ldr	r4, [r4, #32]
                if ((ret = ConfirmSignature(&cert->sigCtx,
 8018af2:	442c      	add	r4, r5
 8018af4:	697d      	ldr	r5, [r7, #20]
 8018af6:	6a6d      	ldr	r5, [r5, #36]	@ 0x24
 8018af8:	6a3e      	ldr	r6, [r7, #32]
 8018afa:	9607      	str	r6, [sp, #28]
 8018afc:	9506      	str	r5, [sp, #24]
 8018afe:	9405      	str	r4, [sp, #20]
 8018b00:	9004      	str	r0, [sp, #16]
 8018b02:	9103      	str	r1, [sp, #12]
 8018b04:	9202      	str	r2, [sp, #8]
 8018b06:	69fa      	ldr	r2, [r7, #28]
 8018b08:	9201      	str	r2, [sp, #4]
 8018b0a:	9300      	str	r3, [sp, #0]
 8018b0c:	687b      	ldr	r3, [r7, #4]
 8018b0e:	4642      	mov	r2, r8
 8018b10:	4671      	mov	r1, lr
 8018b12:	4660      	mov	r0, ip
 8018b14:	f7fd fb4a 	bl	80161ac <ConfirmSignature>
 8018b18:	6278      	str	r0, [r7, #36]	@ 0x24
 8018b1a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018b1c:	2b00      	cmp	r3, #0
 8018b1e:	d001      	beq.n	8018b24 <ParseCertRelative+0x3c2>
                        sce_tsip_encRsaKeyIdx)) != 0) {
                    if (ret != WC_NO_ERR_TRACE(WC_PENDING_E)) {
                        WOLFSSL_MSG("Confirm signature failed");
                    }
                    WOLFSSL_ERROR_VERBOSE(ret);
                    return ret;
 8018b20:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018b22:	e031      	b.n	8018b88 <ParseCertRelative+0x426>
                    }
                }
            #endif /* WOLFSSL_DUAL_ALG_CERTS */
            }
        #ifndef IGNORE_NAME_CONSTRAINTS
            if (verify == VERIFY || verify == VERIFY_OCSP ||
 8018b24:	68fb      	ldr	r3, [r7, #12]
 8018b26:	2b01      	cmp	r3, #1
 8018b28:	d008      	beq.n	8018b3c <ParseCertRelative+0x3da>
 8018b2a:	68fb      	ldr	r3, [r7, #12]
 8018b2c:	2b03      	cmp	r3, #3
 8018b2e:	d005      	beq.n	8018b3c <ParseCertRelative+0x3da>
 8018b30:	68fb      	ldr	r3, [r7, #12]
 8018b32:	2b04      	cmp	r3, #4
 8018b34:	d002      	beq.n	8018b3c <ParseCertRelative+0x3da>
                        verify == VERIFY_NAME || verify == VERIFY_SKIP_DATE) {
 8018b36:	68fb      	ldr	r3, [r7, #12]
 8018b38:	2b05      	cmp	r3, #5
 8018b3a:	d10f      	bne.n	8018b5c <ParseCertRelative+0x3fa>
                /* check that this cert's name is permitted by the signer's
                 * name constraints */
                if (!ConfirmNameConstraints(cert->ca, cert)) {
 8018b3c:	697b      	ldr	r3, [r7, #20]
 8018b3e:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 8018b42:	6979      	ldr	r1, [r7, #20]
 8018b44:	4618      	mov	r0, r3
 8018b46:	f7fd febb 	bl	80168c0 <ConfirmNameConstraints>
 8018b4a:	4603      	mov	r3, r0
 8018b4c:	2b00      	cmp	r3, #0
 8018b4e:	d105      	bne.n	8018b5c <ParseCertRelative+0x3fa>
                    WOLFSSL_MSG("Confirm name constraint failed");
                    WOLFSSL_ERROR_VERBOSE(ASN_NAME_INVALID_E);
                    return ASN_NAME_INVALID_E;
 8018b50:	f06f 03c5 	mvn.w	r3, #197	@ 0xc5
 8018b54:	e018      	b.n	8018b88 <ParseCertRelative+0x426>
            }
            else
#endif
            {
                WOLFSSL_ERROR_VERBOSE(ASN_NO_SIGNER_E);
                return ASN_NO_SIGNER_E;
 8018b56:	f06f 03bb 	mvn.w	r3, #187	@ 0xbb
 8018b5a:	e015      	b.n	8018b88 <ParseCertRelative+0x426>

#if defined(WOLFSSL_NO_TRUSTED_CERTS_VERIFY) && !defined(NO_SKID)
exit_pcr:
#endif

    if (cert->badDate != 0) {
 8018b5c:	697b      	ldr	r3, [r7, #20]
 8018b5e:	f8d3 34ac 	ldr.w	r3, [r3, #1196]	@ 0x4ac
 8018b62:	2b00      	cmp	r3, #0
 8018b64:	d006      	beq.n	8018b74 <ParseCertRelative+0x412>
        if (verify != VERIFY_SKIP_DATE) {
 8018b66:	68fb      	ldr	r3, [r7, #12]
 8018b68:	2b05      	cmp	r3, #5
 8018b6a:	d003      	beq.n	8018b74 <ParseCertRelative+0x412>
            return cert->badDate;
 8018b6c:	697b      	ldr	r3, [r7, #20]
 8018b6e:	f8d3 34ac 	ldr.w	r3, [r3, #1196]	@ 0x4ac
 8018b72:	e009      	b.n	8018b88 <ParseCertRelative+0x426>
        }
        WOLFSSL_MSG("Date error: Verify option is skipping");
    }

    if (cert->criticalExt != 0)
 8018b74:	697b      	ldr	r3, [r7, #20]
 8018b76:	f8d3 34b0 	ldr.w	r3, [r3, #1200]	@ 0x4b0
 8018b7a:	2b00      	cmp	r3, #0
 8018b7c:	d003      	beq.n	8018b86 <ParseCertRelative+0x424>
        return cert->criticalExt;
 8018b7e:	697b      	ldr	r3, [r7, #20]
 8018b80:	f8d3 34b0 	ldr.w	r3, [r3, #1200]	@ 0x4b0
 8018b84:	e000      	b.n	8018b88 <ParseCertRelative+0x426>

    return ret;
 8018b86:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 8018b88:	4618      	mov	r0, r3
 8018b8a:	3728      	adds	r7, #40	@ 0x28
 8018b8c:	46bd      	mov	sp, r7
 8018b8e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08018b92 <FillSigner>:

int FillSigner(Signer* signer, DecodedCert* cert, int type, DerBuffer *der)
{
 8018b92:	b580      	push	{r7, lr}
 8018b94:	b086      	sub	sp, #24
 8018b96:	af00      	add	r7, sp, #0
 8018b98:	60f8      	str	r0, [r7, #12]
 8018b9a:	60b9      	str	r1, [r7, #8]
 8018b9c:	607a      	str	r2, [r7, #4]
 8018b9e:	603b      	str	r3, [r7, #0]
    int ret = 0;
 8018ba0:	2300      	movs	r3, #0
 8018ba2:	617b      	str	r3, [r7, #20]

    if (signer == NULL || cert == NULL)
 8018ba4:	68fb      	ldr	r3, [r7, #12]
 8018ba6:	2b00      	cmp	r3, #0
 8018ba8:	d002      	beq.n	8018bb0 <FillSigner+0x1e>
 8018baa:	68bb      	ldr	r3, [r7, #8]
 8018bac:	2b00      	cmp	r3, #0
 8018bae:	d102      	bne.n	8018bb6 <FillSigner+0x24>
        return BAD_FUNC_ARG;
 8018bb0:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8018bb4:	e08c      	b.n	8018cd0 <FillSigner+0x13e>
        }
    }
#endif /* WOLFSSL_DUAL_ALG_CERTS */

#if defined(WOLFSSL_AKID_NAME) || defined(HAVE_CRL)
    if (ret == 0 && signer != NULL)
 8018bb6:	697b      	ldr	r3, [r7, #20]
 8018bb8:	2b00      	cmp	r3, #0
 8018bba:	d10f      	bne.n	8018bdc <FillSigner+0x4a>
 8018bbc:	68fb      	ldr	r3, [r7, #12]
 8018bbe:	2b00      	cmp	r3, #0
 8018bc0:	d00c      	beq.n	8018bdc <FillSigner+0x4a>
        ret = CalcHashId(cert->serial, (word32)cert->serialSz,
 8018bc2:	68bb      	ldr	r3, [r7, #8]
 8018bc4:	f503 705d 	add.w	r0, r3, #884	@ 0x374
 8018bc8:	68bb      	ldr	r3, [r7, #8]
 8018bca:	f8d3 3394 	ldr.w	r3, [r3, #916]	@ 0x394
 8018bce:	4619      	mov	r1, r3
                         signer->serialHash);
 8018bd0:	68fb      	ldr	r3, [r7, #12]
 8018bd2:	3360      	adds	r3, #96	@ 0x60
        ret = CalcHashId(cert->serial, (word32)cert->serialSz,
 8018bd4:	461a      	mov	r2, r3
 8018bd6:	f7fc fd92 	bl	80156fe <CalcHashId>
 8018bda:	6178      	str	r0, [r7, #20]
#endif
    if (ret == 0 && signer != NULL) {
 8018bdc:	697b      	ldr	r3, [r7, #20]
 8018bde:	2b00      	cmp	r3, #0
 8018be0:	d175      	bne.n	8018cce <FillSigner+0x13c>
 8018be2:	68fb      	ldr	r3, [r7, #12]
 8018be4:	2b00      	cmp	r3, #0
 8018be6:	d072      	beq.n	8018cce <FillSigner+0x13c>
    if (ret == 0 && signer != NULL) {
        XMEMCPY(signer->derCert->buffer, der->buffer, der->length);
    #else
    (void)der;
    #endif
        signer->keyOID         = cert->keyOID;
 8018be8:	68bb      	ldr	r3, [r7, #8]
 8018bea:	69da      	ldr	r2, [r3, #28]
 8018bec:	68fb      	ldr	r3, [r7, #12]
 8018bee:	605a      	str	r2, [r3, #4]
        if (cert->pubKeyStored) {
 8018bf0:	68bb      	ldr	r3, [r7, #8]
 8018bf2:	689b      	ldr	r3, [r3, #8]
 8018bf4:	2b00      	cmp	r3, #0
 8018bf6:	d007      	beq.n	8018c08 <FillSigner+0x76>
            signer->publicKey      = cert->publicKey;
 8018bf8:	68bb      	ldr	r3, [r7, #8]
 8018bfa:	681a      	ldr	r2, [r3, #0]
 8018bfc:	68fb      	ldr	r3, [r7, #12]
 8018bfe:	60da      	str	r2, [r3, #12]
            signer->pubKeySize     = cert->pubKeySize;
 8018c00:	68bb      	ldr	r3, [r7, #8]
 8018c02:	685a      	ldr	r2, [r3, #4]
 8018c04:	68fb      	ldr	r3, [r7, #12]
 8018c06:	601a      	str	r2, [r3, #0]
        }

        if (cert->subjectCNStored) {
 8018c08:	68bb      	ldr	r3, [r7, #8]
 8018c0a:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 8018c0e:	f003 0301 	and.w	r3, r3, #1
 8018c12:	b2db      	uxtb	r3, r3
 8018c14:	2b00      	cmp	r3, #0
 8018c16:	d009      	beq.n	8018c2c <FillSigner+0x9a>
            signer->nameLen        = cert->subjectCNLen;
 8018c18:	68bb      	ldr	r3, [r7, #8]
 8018c1a:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
 8018c1e:	68fb      	ldr	r3, [r7, #12]
 8018c20:	611a      	str	r2, [r3, #16]
            signer->name           = cert->subjectCN;
 8018c22:	68bb      	ldr	r3, [r7, #8]
 8018c24:	f8d3 2084 	ldr.w	r2, [r3, #132]	@ 0x84
 8018c28:	68fb      	ldr	r3, [r7, #12]
 8018c2a:	615a      	str	r2, [r3, #20]
        }
        signer->maxPathLen     = cert->maxPathLen;
 8018c2c:	68bb      	ldr	r3, [r7, #8]
 8018c2e:	f893 241d 	ldrb.w	r2, [r3, #1053]	@ 0x41d
 8018c32:	68fb      	ldr	r3, [r7, #12]
 8018c34:	729a      	strb	r2, [r3, #10]
        signer->selfSigned     = cert->selfSigned;
 8018c36:	68bb      	ldr	r3, [r7, #8]
 8018c38:	f893 34b6 	ldrb.w	r3, [r3, #1206]	@ 0x4b6
 8018c3c:	f3c3 0340 	ubfx	r3, r3, #1, #1
 8018c40:	b2d9      	uxtb	r1, r3
 8018c42:	68fa      	ldr	r2, [r7, #12]
 8018c44:	7ad3      	ldrb	r3, [r2, #11]
 8018c46:	f361 0300 	bfi	r3, r1, #0, #1
 8018c4a:	72d3      	strb	r3, [r2, #11]
    #ifndef IGNORE_NAME_CONSTRAINTS
        signer->permittedNames = cert->permittedNames;
 8018c4c:	68bb      	ldr	r3, [r7, #8]
 8018c4e:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 8018c50:	68fb      	ldr	r3, [r7, #12]
 8018c52:	619a      	str	r2, [r3, #24]
        signer->excludedNames  = cert->excludedNames;
 8018c54:	68bb      	ldr	r3, [r7, #8]
 8018c56:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8018c58:	68fb      	ldr	r3, [r7, #12]
 8018c5a:	61da      	str	r2, [r3, #28]
    #endif
    #ifndef NO_SKID
        XMEMCPY(signer->subjectKeyIdHash, cert->extSubjKeyId,
 8018c5c:	68fb      	ldr	r3, [r7, #12]
 8018c5e:	f103 0040 	add.w	r0, r3, #64	@ 0x40
 8018c62:	68bb      	ldr	r3, [r7, #8]
 8018c64:	f503 7371 	add.w	r3, r3, #964	@ 0x3c4
 8018c68:	2220      	movs	r2, #32
 8018c6a:	4619      	mov	r1, r3
 8018c6c:	f00f fc96 	bl	802859c <memcpy>
                SIGNER_DIGEST_SIZE);
    #endif
        XMEMCPY(signer->subjectNameHash, cert->subjectHash,
 8018c70:	68fb      	ldr	r3, [r7, #12]
 8018c72:	f103 0020 	add.w	r0, r3, #32
 8018c76:	68bb      	ldr	r3, [r7, #8]
 8018c78:	3340      	adds	r3, #64	@ 0x40
 8018c7a:	2220      	movs	r2, #32
 8018c7c:	4619      	mov	r1, r3
 8018c7e:	f00f fc8d 	bl	802859c <memcpy>
    #endif
    #ifdef HAVE_OCSP
        XMEMCPY(signer->subjectKeyHash, cert->subjectKeyHash,
                KEYID_SIZE);
    #endif
        signer->keyUsage = cert->extKeyUsageSet ? cert->extKeyUsage
 8018c82:	68bb      	ldr	r3, [r7, #8]
 8018c84:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 8018c88:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 8018c8c:	b2db      	uxtb	r3, r3
 8018c8e:	2b00      	cmp	r3, #0
 8018c90:	d003      	beq.n	8018c9a <FillSigner+0x108>
 8018c92:	68bb      	ldr	r3, [r7, #8]
 8018c94:	f8b3 2420 	ldrh.w	r2, [r3, #1056]	@ 0x420
 8018c98:	e001      	b.n	8018c9e <FillSigner+0x10c>
 8018c9a:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 8018c9e:	68fb      	ldr	r3, [r7, #12]
 8018ca0:	811a      	strh	r2, [r3, #8]
                                                : 0xFFFF;
        signer->next    = NULL; /* If Key Usage not set, all uses valid. */
 8018ca2:	68fb      	ldr	r3, [r7, #12]
 8018ca4:	2200      	movs	r2, #0
 8018ca6:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
        cert->publicKey = 0;    /* in case lock fails don't free here.   */
 8018caa:	68bb      	ldr	r3, [r7, #8]
 8018cac:	2200      	movs	r2, #0
 8018cae:	601a      	str	r2, [r3, #0]
        cert->subjectCN = 0;
 8018cb0:	68bb      	ldr	r3, [r7, #8]
 8018cb2:	2200      	movs	r2, #0
 8018cb4:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
    #ifndef IGNORE_NAME_CONSTRAINTS
        cert->permittedNames = NULL;
 8018cb8:	68bb      	ldr	r3, [r7, #8]
 8018cba:	2200      	movs	r2, #0
 8018cbc:	639a      	str	r2, [r3, #56]	@ 0x38
        cert->excludedNames = NULL;
 8018cbe:	68bb      	ldr	r3, [r7, #8]
 8018cc0:	2200      	movs	r2, #0
 8018cc2:	63da      	str	r2, [r3, #60]	@ 0x3c
    #endif
        signer->type = (byte)type;
 8018cc4:	687b      	ldr	r3, [r7, #4]
 8018cc6:	b2da      	uxtb	r2, r3
 8018cc8:	68fb      	ldr	r3, [r7, #12]
 8018cca:	f883 2080 	strb.w	r2, [r3, #128]	@ 0x80
    }
    return ret;
 8018cce:	697b      	ldr	r3, [r7, #20]
}
 8018cd0:	4618      	mov	r0, r3
 8018cd2:	3718      	adds	r7, #24
 8018cd4:	46bd      	mov	sp, r7
 8018cd6:	bd80      	pop	{r7, pc}

08018cd8 <MakeSigner>:

/* Create and init an new signer */
Signer* MakeSigner(void* heap)
{
 8018cd8:	b580      	push	{r7, lr}
 8018cda:	b084      	sub	sp, #16
 8018cdc:	af00      	add	r7, sp, #0
 8018cde:	6078      	str	r0, [r7, #4]
    Signer* signer = (Signer*) XMALLOC(sizeof(Signer), heap,
 8018ce0:	2088      	movs	r0, #136	@ 0x88
 8018ce2:	f005 fed1 	bl	801ea88 <wolfSSL_Malloc>
 8018ce6:	60f8      	str	r0, [r7, #12]
                                       DYNAMIC_TYPE_SIGNER);
    if (signer) {
 8018ce8:	68fb      	ldr	r3, [r7, #12]
 8018cea:	2b00      	cmp	r3, #0
 8018cec:	d004      	beq.n	8018cf8 <MakeSigner+0x20>
        XMEMSET(signer, 0, sizeof(Signer));
 8018cee:	2288      	movs	r2, #136	@ 0x88
 8018cf0:	2100      	movs	r1, #0
 8018cf2:	68f8      	ldr	r0, [r7, #12]
 8018cf4:	f00f fbe8 	bl	80284c8 <memset>
    }
    (void)heap;

    return signer;
 8018cf8:	68fb      	ldr	r3, [r7, #12]
}
 8018cfa:	4618      	mov	r0, r3
 8018cfc:	3710      	adds	r7, #16
 8018cfe:	46bd      	mov	sp, r7
 8018d00:	bd80      	pop	{r7, pc}

08018d02 <FreeSigner>:
 * @param [in, out] signer  On in, signer object.
 *                          On out, pointer is no longer valid.
 * @param [in]      heap    Dynamic memory hint.
 */
void FreeSigner(Signer* signer, void* heap)
{
 8018d02:	b580      	push	{r7, lr}
 8018d04:	b086      	sub	sp, #24
 8018d06:	af00      	add	r7, sp, #0
 8018d08:	6078      	str	r0, [r7, #4]
 8018d0a:	6039      	str	r1, [r7, #0]
    (void)signer;
    (void)heap;
    XFREE(signer->name, heap, DYNAMIC_TYPE_SUBJECT_CN);
 8018d0c:	687b      	ldr	r3, [r7, #4]
 8018d0e:	695b      	ldr	r3, [r3, #20]
 8018d10:	617b      	str	r3, [r7, #20]
 8018d12:	697b      	ldr	r3, [r7, #20]
 8018d14:	2b00      	cmp	r3, #0
 8018d16:	d002      	beq.n	8018d1e <FreeSigner+0x1c>
 8018d18:	6978      	ldr	r0, [r7, #20]
 8018d1a:	f005 fed1 	bl	801eac0 <wolfSSL_Free>
    XFREE((void*)signer->publicKey, heap, DYNAMIC_TYPE_PUBLIC_KEY);
 8018d1e:	687b      	ldr	r3, [r7, #4]
 8018d20:	68db      	ldr	r3, [r3, #12]
 8018d22:	613b      	str	r3, [r7, #16]
 8018d24:	693b      	ldr	r3, [r7, #16]
 8018d26:	2b00      	cmp	r3, #0
 8018d28:	d002      	beq.n	8018d30 <FreeSigner+0x2e>
 8018d2a:	6938      	ldr	r0, [r7, #16]
 8018d2c:	f005 fec8 	bl	801eac0 <wolfSSL_Free>
#ifdef WOLFSSL_DUAL_ALG_CERTS
    XFREE(signer->sapkiDer, heap, DYNAMIC_TYPE_PUBLIC_KEY);
#endif
#ifndef IGNORE_NAME_CONSTRAINTS
    if (signer->permittedNames)
 8018d30:	687b      	ldr	r3, [r7, #4]
 8018d32:	699b      	ldr	r3, [r3, #24]
 8018d34:	2b00      	cmp	r3, #0
 8018d36:	d005      	beq.n	8018d44 <FreeSigner+0x42>
        FreeNameSubtrees(signer->permittedNames, heap);
 8018d38:	687b      	ldr	r3, [r7, #4]
 8018d3a:	699b      	ldr	r3, [r3, #24]
 8018d3c:	6839      	ldr	r1, [r7, #0]
 8018d3e:	4618      	mov	r0, r3
 8018d40:	f7fc fa84 	bl	801524c <FreeNameSubtrees>
    if (signer->excludedNames)
 8018d44:	687b      	ldr	r3, [r7, #4]
 8018d46:	69db      	ldr	r3, [r3, #28]
 8018d48:	2b00      	cmp	r3, #0
 8018d4a:	d005      	beq.n	8018d58 <FreeSigner+0x56>
        FreeNameSubtrees(signer->excludedNames, heap);
 8018d4c:	687b      	ldr	r3, [r7, #4]
 8018d4e:	69db      	ldr	r3, [r3, #28]
 8018d50:	6839      	ldr	r1, [r7, #0]
 8018d52:	4618      	mov	r0, r3
 8018d54:	f7fc fa7a 	bl	801524c <FreeNameSubtrees>
#endif
#ifdef WOLFSSL_SIGNER_DER_CERT
    FreeDer(&signer->derCert);
#endif
    XFREE(signer, heap, DYNAMIC_TYPE_SIGNER);
 8018d58:	687b      	ldr	r3, [r7, #4]
 8018d5a:	60fb      	str	r3, [r7, #12]
 8018d5c:	68fb      	ldr	r3, [r7, #12]
 8018d5e:	2b00      	cmp	r3, #0
 8018d60:	d002      	beq.n	8018d68 <FreeSigner+0x66>
 8018d62:	68f8      	ldr	r0, [r7, #12]
 8018d64:	f005 feac 	bl	801eac0 <wolfSSL_Free>
}
 8018d68:	bf00      	nop
 8018d6a:	3718      	adds	r7, #24
 8018d6c:	46bd      	mov	sp, r7
 8018d6e:	bd80      	pop	{r7, pc}

08018d70 <FreeSignerTable>:
 * @param [in, out] table   Array of signer objects.
 * @param [in]      rows    Number of entries in table.
 * @param [in]      heap    Dynamic memory hint.
 */
void FreeSignerTable(Signer** table, int rows, void* heap)
{
 8018d70:	b580      	push	{r7, lr}
 8018d72:	b088      	sub	sp, #32
 8018d74:	af00      	add	r7, sp, #0
 8018d76:	60f8      	str	r0, [r7, #12]
 8018d78:	60b9      	str	r1, [r7, #8]
 8018d7a:	607a      	str	r2, [r7, #4]
    int i;

    for (i = 0; i < rows; i++) {
 8018d7c:	2300      	movs	r3, #0
 8018d7e:	61fb      	str	r3, [r7, #28]
 8018d80:	e01c      	b.n	8018dbc <FreeSignerTable+0x4c>
        Signer* signer = table[i];
 8018d82:	69fb      	ldr	r3, [r7, #28]
 8018d84:	009b      	lsls	r3, r3, #2
 8018d86:	68fa      	ldr	r2, [r7, #12]
 8018d88:	4413      	add	r3, r2
 8018d8a:	681b      	ldr	r3, [r3, #0]
 8018d8c:	61bb      	str	r3, [r7, #24]
        while (signer) {
 8018d8e:	e009      	b.n	8018da4 <FreeSignerTable+0x34>
            Signer* next = signer->next;
 8018d90:	69bb      	ldr	r3, [r7, #24]
 8018d92:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 8018d96:	617b      	str	r3, [r7, #20]
            FreeSigner(signer, heap);
 8018d98:	6879      	ldr	r1, [r7, #4]
 8018d9a:	69b8      	ldr	r0, [r7, #24]
 8018d9c:	f7ff ffb1 	bl	8018d02 <FreeSigner>
            signer = next;
 8018da0:	697b      	ldr	r3, [r7, #20]
 8018da2:	61bb      	str	r3, [r7, #24]
        while (signer) {
 8018da4:	69bb      	ldr	r3, [r7, #24]
 8018da6:	2b00      	cmp	r3, #0
 8018da8:	d1f2      	bne.n	8018d90 <FreeSignerTable+0x20>
        }
        table[i] = NULL;
 8018daa:	69fb      	ldr	r3, [r7, #28]
 8018dac:	009b      	lsls	r3, r3, #2
 8018dae:	68fa      	ldr	r2, [r7, #12]
 8018db0:	4413      	add	r3, r2
 8018db2:	2200      	movs	r2, #0
 8018db4:	601a      	str	r2, [r3, #0]
    for (i = 0; i < rows; i++) {
 8018db6:	69fb      	ldr	r3, [r7, #28]
 8018db8:	3301      	adds	r3, #1
 8018dba:	61fb      	str	r3, [r7, #28]
 8018dbc:	69fa      	ldr	r2, [r7, #28]
 8018dbe:	68bb      	ldr	r3, [r7, #8]
 8018dc0:	429a      	cmp	r2, r3
 8018dc2:	dbde      	blt.n	8018d82 <FreeSignerTable+0x12>
    }
}
 8018dc4:	bf00      	nop
 8018dc6:	bf00      	nop
 8018dc8:	3720      	adds	r7, #32
 8018dca:	46bd      	mov	sp, r7
 8018dcc:	bd80      	pop	{r7, pc}
	...

08018dd0 <AllocDer>:
#ifndef NO_CERTS

/* TODO: consider moving PEM code out to a different file. */

int AllocDer(DerBuffer** pDer, word32 length, int type, void* heap)
{
 8018dd0:	b580      	push	{r7, lr}
 8018dd2:	b088      	sub	sp, #32
 8018dd4:	af00      	add	r7, sp, #0
 8018dd6:	60f8      	str	r0, [r7, #12]
 8018dd8:	60b9      	str	r1, [r7, #8]
 8018dda:	607a      	str	r2, [r7, #4]
 8018ddc:	603b      	str	r3, [r7, #0]
    int ret = WC_NO_ERR_TRACE(BAD_FUNC_ARG);
 8018dde:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8018de2:	61fb      	str	r3, [r7, #28]
    if (pDer) {
 8018de4:	68fb      	ldr	r3, [r7, #12]
 8018de6:	2b00      	cmp	r3, #0
 8018de8:	f000 80a1 	beq.w	8018f2e <AllocDer+0x15e>
        int dynType = 0;
 8018dec:	2300      	movs	r3, #0
 8018dee:	61bb      	str	r3, [r7, #24]
        DerBuffer* der;

        /* Determine dynamic type */
        switch (type) {
 8018df0:	687b      	ldr	r3, [r7, #4]
 8018df2:	2b2a      	cmp	r3, #42	@ 0x2a
 8018df4:	d86a      	bhi.n	8018ecc <AllocDer+0xfc>
 8018df6:	a201      	add	r2, pc, #4	@ (adr r2, 8018dfc <AllocDer+0x2c>)
 8018df8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8018dfc:	08018eaf 	.word	0x08018eaf
 8018e00:	08018ecd 	.word	0x08018ecd
 8018e04:	08018ecd 	.word	0x08018ecd
 8018e08:	08018ecd 	.word	0x08018ecd
 8018e0c:	08018ecd 	.word	0x08018ecd
 8018e10:	08018eb5 	.word	0x08018eb5
 8018e14:	08018ea9 	.word	0x08018ea9
 8018e18:	08018ecd 	.word	0x08018ecd
 8018e1c:	08018ecd 	.word	0x08018ecd
 8018e20:	08018ecd 	.word	0x08018ecd
 8018e24:	08018ecd 	.word	0x08018ecd
 8018e28:	08018ebb 	.word	0x08018ebb
 8018e2c:	08018ec1 	.word	0x08018ec1
 8018e30:	08018ec7 	.word	0x08018ec7
 8018e34:	08018ecd 	.word	0x08018ecd
 8018e38:	08018ecd 	.word	0x08018ecd
 8018e3c:	08018ecd 	.word	0x08018ecd
 8018e40:	08018ecd 	.word	0x08018ecd
 8018e44:	08018ecd 	.word	0x08018ecd
 8018e48:	08018ecd 	.word	0x08018ecd
 8018e4c:	08018ecd 	.word	0x08018ecd
 8018e50:	08018ecd 	.word	0x08018ecd
 8018e54:	08018ecd 	.word	0x08018ecd
 8018e58:	08018ecd 	.word	0x08018ecd
 8018e5c:	08018ecd 	.word	0x08018ecd
 8018e60:	08018ecd 	.word	0x08018ecd
 8018e64:	08018ecd 	.word	0x08018ecd
 8018e68:	08018ecd 	.word	0x08018ecd
 8018e6c:	08018ecd 	.word	0x08018ecd
 8018e70:	08018ecd 	.word	0x08018ecd
 8018e74:	08018ecd 	.word	0x08018ecd
 8018e78:	08018ecd 	.word	0x08018ecd
 8018e7c:	08018ecd 	.word	0x08018ecd
 8018e80:	08018ecd 	.word	0x08018ecd
 8018e84:	08018ecd 	.word	0x08018ecd
 8018e88:	08018ecd 	.word	0x08018ecd
 8018e8c:	08018ecd 	.word	0x08018ecd
 8018e90:	08018ecd 	.word	0x08018ecd
 8018e94:	08018ecd 	.word	0x08018ecd
 8018e98:	08018ecd 	.word	0x08018ecd
 8018e9c:	08018ecd 	.word	0x08018ecd
 8018ea0:	08018ecd 	.word	0x08018ecd
 8018ea4:	08018eaf 	.word	0x08018eaf
            case CA_TYPE:   dynType = DYNAMIC_TYPE_CA;   break;
 8018ea8:	2301      	movs	r3, #1
 8018eaa:	61bb      	str	r3, [r7, #24]
 8018eac:	e011      	b.n	8018ed2 <AllocDer+0x102>
            case CHAIN_CERT_TYPE:
            case CERT_TYPE: dynType = DYNAMIC_TYPE_CERT; break;
 8018eae:	2302      	movs	r3, #2
 8018eb0:	61bb      	str	r3, [r7, #24]
 8018eb2:	e00e      	b.n	8018ed2 <AllocDer+0x102>
            case CRL_TYPE:  dynType = DYNAMIC_TYPE_CRL;  break;
 8018eb4:	2316      	movs	r3, #22
 8018eb6:	61bb      	str	r3, [r7, #24]
 8018eb8:	e00b      	b.n	8018ed2 <AllocDer+0x102>
            case DSA_TYPE:  dynType = DYNAMIC_TYPE_DSA;  break;
 8018eba:	2315      	movs	r3, #21
 8018ebc:	61bb      	str	r3, [r7, #24]
 8018ebe:	e008      	b.n	8018ed2 <AllocDer+0x102>
            case ECC_TYPE:  dynType = DYNAMIC_TYPE_ECC;  break;
 8018ec0:	2325      	movs	r3, #37	@ 0x25
 8018ec2:	61bb      	str	r3, [r7, #24]
 8018ec4:	e005      	b.n	8018ed2 <AllocDer+0x102>
            case RSA_TYPE:  dynType = DYNAMIC_TYPE_RSA;  break;
 8018ec6:	230a      	movs	r3, #10
 8018ec8:	61bb      	str	r3, [r7, #24]
 8018eca:	e002      	b.n	8018ed2 <AllocDer+0x102>
            default:        dynType = DYNAMIC_TYPE_KEY;  break;
 8018ecc:	2303      	movs	r3, #3
 8018ece:	61bb      	str	r3, [r7, #24]
 8018ed0:	bf00      	nop
        }

        /* Setup new buffer */
        *pDer = (DerBuffer*)XMALLOC(sizeof(DerBuffer) + length, heap, dynType);
 8018ed2:	68bb      	ldr	r3, [r7, #8]
 8018ed4:	3314      	adds	r3, #20
 8018ed6:	4618      	mov	r0, r3
 8018ed8:	f005 fdd6 	bl	801ea88 <wolfSSL_Malloc>
 8018edc:	4602      	mov	r2, r0
 8018ede:	68fb      	ldr	r3, [r7, #12]
 8018ee0:	601a      	str	r2, [r3, #0]
        if (*pDer == NULL) {
 8018ee2:	68fb      	ldr	r3, [r7, #12]
 8018ee4:	681b      	ldr	r3, [r3, #0]
 8018ee6:	2b00      	cmp	r3, #0
 8018ee8:	d102      	bne.n	8018ef0 <AllocDer+0x120>
            return MEMORY_E;
 8018eea:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8018eee:	e022      	b.n	8018f36 <AllocDer+0x166>
        }
        XMEMSET(*pDer, 0, sizeof(DerBuffer) + length);
 8018ef0:	68fb      	ldr	r3, [r7, #12]
 8018ef2:	6818      	ldr	r0, [r3, #0]
 8018ef4:	68bb      	ldr	r3, [r7, #8]
 8018ef6:	3314      	adds	r3, #20
 8018ef8:	461a      	mov	r2, r3
 8018efa:	2100      	movs	r1, #0
 8018efc:	f00f fae4 	bl	80284c8 <memset>

        der = *pDer;
 8018f00:	68fb      	ldr	r3, [r7, #12]
 8018f02:	681b      	ldr	r3, [r3, #0]
 8018f04:	617b      	str	r3, [r7, #20]
        der->type = type;
 8018f06:	697b      	ldr	r3, [r7, #20]
 8018f08:	687a      	ldr	r2, [r7, #4]
 8018f0a:	60da      	str	r2, [r3, #12]
        der->dynType = dynType; /* Cache this for FreeDer */
 8018f0c:	697b      	ldr	r3, [r7, #20]
 8018f0e:	69ba      	ldr	r2, [r7, #24]
 8018f10:	611a      	str	r2, [r3, #16]
        der->heap = heap;
 8018f12:	697b      	ldr	r3, [r7, #20]
 8018f14:	683a      	ldr	r2, [r7, #0]
 8018f16:	605a      	str	r2, [r3, #4]
        der->buffer = (byte*)der + sizeof(DerBuffer);
 8018f18:	697b      	ldr	r3, [r7, #20]
 8018f1a:	f103 0214 	add.w	r2, r3, #20
 8018f1e:	697b      	ldr	r3, [r7, #20]
 8018f20:	601a      	str	r2, [r3, #0]
        der->length = length;
 8018f22:	697b      	ldr	r3, [r7, #20]
 8018f24:	68ba      	ldr	r2, [r7, #8]
 8018f26:	609a      	str	r2, [r3, #8]
        ret = 0; /* Success */
 8018f28:	2300      	movs	r3, #0
 8018f2a:	61fb      	str	r3, [r7, #28]
 8018f2c:	e002      	b.n	8018f34 <AllocDer+0x164>
    } else {
        ret = BAD_FUNC_ARG;
 8018f2e:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8018f32:	61fb      	str	r3, [r7, #28]
    }
    return ret;
 8018f34:	69fb      	ldr	r3, [r7, #28]
}
 8018f36:	4618      	mov	r0, r3
 8018f38:	3720      	adds	r7, #32
 8018f3a:	46bd      	mov	sp, r7
 8018f3c:	bd80      	pop	{r7, pc}
 8018f3e:	bf00      	nop

08018f40 <AllocCopyDer>:

int AllocCopyDer(DerBuffer** pDer, const unsigned char* buff, word32 length,
    int type, void* heap)
{
 8018f40:	b580      	push	{r7, lr}
 8018f42:	b086      	sub	sp, #24
 8018f44:	af00      	add	r7, sp, #0
 8018f46:	60f8      	str	r0, [r7, #12]
 8018f48:	60b9      	str	r1, [r7, #8]
 8018f4a:	607a      	str	r2, [r7, #4]
 8018f4c:	603b      	str	r3, [r7, #0]
    int ret = AllocDer(pDer, length, type, heap);
 8018f4e:	6a3b      	ldr	r3, [r7, #32]
 8018f50:	683a      	ldr	r2, [r7, #0]
 8018f52:	6879      	ldr	r1, [r7, #4]
 8018f54:	68f8      	ldr	r0, [r7, #12]
 8018f56:	f7ff ff3b 	bl	8018dd0 <AllocDer>
 8018f5a:	6178      	str	r0, [r7, #20]
    if (ret == 0) {
 8018f5c:	697b      	ldr	r3, [r7, #20]
 8018f5e:	2b00      	cmp	r3, #0
 8018f60:	d107      	bne.n	8018f72 <AllocCopyDer+0x32>
        XMEMCPY((*pDer)->buffer, buff, length);
 8018f62:	68fb      	ldr	r3, [r7, #12]
 8018f64:	681b      	ldr	r3, [r3, #0]
 8018f66:	681b      	ldr	r3, [r3, #0]
 8018f68:	687a      	ldr	r2, [r7, #4]
 8018f6a:	68b9      	ldr	r1, [r7, #8]
 8018f6c:	4618      	mov	r0, r3
 8018f6e:	f00f fb15 	bl	802859c <memcpy>
    }

    return ret;
 8018f72:	697b      	ldr	r3, [r7, #20]
}
 8018f74:	4618      	mov	r0, r3
 8018f76:	3718      	adds	r7, #24
 8018f78:	46bd      	mov	sp, r7
 8018f7a:	bd80      	pop	{r7, pc}

08018f7c <FreeDer>:

void FreeDer(DerBuffer** pDer)
{
 8018f7c:	b580      	push	{r7, lr}
 8018f7e:	b084      	sub	sp, #16
 8018f80:	af00      	add	r7, sp, #0
 8018f82:	6078      	str	r0, [r7, #4]
    if (pDer && *pDer) {
 8018f84:	687b      	ldr	r3, [r7, #4]
 8018f86:	2b00      	cmp	r3, #0
 8018f88:	d02b      	beq.n	8018fe2 <FreeDer+0x66>
 8018f8a:	687b      	ldr	r3, [r7, #4]
 8018f8c:	681b      	ldr	r3, [r3, #0]
 8018f8e:	2b00      	cmp	r3, #0
 8018f90:	d027      	beq.n	8018fe2 <FreeDer+0x66>
        DerBuffer* der = (DerBuffer*)*pDer;
 8018f92:	687b      	ldr	r3, [r7, #4]
 8018f94:	681b      	ldr	r3, [r3, #0]
 8018f96:	60fb      	str	r3, [r7, #12]

        /* ForceZero private keys */
        if (((der->type == PRIVATEKEY_TYPE) ||
 8018f98:	68fb      	ldr	r3, [r7, #12]
 8018f9a:	68db      	ldr	r3, [r3, #12]
 8018f9c:	2b01      	cmp	r3, #1
 8018f9e:	d003      	beq.n	8018fa8 <FreeDer+0x2c>
             (der->type == ALT_PRIVATEKEY_TYPE)) && der->buffer != NULL) {
 8018fa0:	68fb      	ldr	r3, [r7, #12]
 8018fa2:	68db      	ldr	r3, [r3, #12]
        if (((der->type == PRIVATEKEY_TYPE) ||
 8018fa4:	2b02      	cmp	r3, #2
 8018fa6:	d10b      	bne.n	8018fc0 <FreeDer+0x44>
             (der->type == ALT_PRIVATEKEY_TYPE)) && der->buffer != NULL) {
 8018fa8:	68fb      	ldr	r3, [r7, #12]
 8018faa:	681b      	ldr	r3, [r3, #0]
 8018fac:	2b00      	cmp	r3, #0
 8018fae:	d007      	beq.n	8018fc0 <FreeDer+0x44>
            ForceZero(der->buffer, der->length);
 8018fb0:	68fb      	ldr	r3, [r7, #12]
 8018fb2:	681a      	ldr	r2, [r3, #0]
 8018fb4:	68fb      	ldr	r3, [r7, #12]
 8018fb6:	689b      	ldr	r3, [r3, #8]
 8018fb8:	4619      	mov	r1, r3
 8018fba:	4610      	mov	r0, r2
 8018fbc:	f7f9 fb69 	bl	8012692 <ForceZero>
        }
        der->buffer = NULL;
 8018fc0:	68fb      	ldr	r3, [r7, #12]
 8018fc2:	2200      	movs	r2, #0
 8018fc4:	601a      	str	r2, [r3, #0]
        der->length = 0;
 8018fc6:	68fb      	ldr	r3, [r7, #12]
 8018fc8:	2200      	movs	r2, #0
 8018fca:	609a      	str	r2, [r3, #8]
        XFREE(der, der->heap, der->dynType);
 8018fcc:	68fb      	ldr	r3, [r7, #12]
 8018fce:	60bb      	str	r3, [r7, #8]
 8018fd0:	68bb      	ldr	r3, [r7, #8]
 8018fd2:	2b00      	cmp	r3, #0
 8018fd4:	d002      	beq.n	8018fdc <FreeDer+0x60>
 8018fd6:	68b8      	ldr	r0, [r7, #8]
 8018fd8:	f005 fd72 	bl	801eac0 <wolfSSL_Free>

        *pDer = NULL;
 8018fdc:	687b      	ldr	r3, [r7, #4]
 8018fde:	2200      	movs	r2, #0
 8018fe0:	601a      	str	r2, [r3, #0]
    }
}
 8018fe2:	bf00      	nop
 8018fe4:	3710      	adds	r7, #16
 8018fe6:	46bd      	mov	sp, r7
 8018fe8:	bd80      	pop	{r7, pc}

08018fea <SkipEndOfLineChars>:
                                             "-----END X509 CRL-----");

#ifdef WOLFSSL_PEM_TO_DER
static WC_INLINE const char* SkipEndOfLineChars(const char* line,
                                                const char* endOfLine)
{
 8018fea:	b480      	push	{r7}
 8018fec:	b083      	sub	sp, #12
 8018fee:	af00      	add	r7, sp, #0
 8018ff0:	6078      	str	r0, [r7, #4]
 8018ff2:	6039      	str	r1, [r7, #0]
    /* eat end of line characters */
    while (line < endOfLine &&
 8018ff4:	e002      	b.n	8018ffc <SkipEndOfLineChars+0x12>
              (line[0] == '\r' || line[0] == '\n')) {
        line++;
 8018ff6:	687b      	ldr	r3, [r7, #4]
 8018ff8:	3301      	adds	r3, #1
 8018ffa:	607b      	str	r3, [r7, #4]
    while (line < endOfLine &&
 8018ffc:	687a      	ldr	r2, [r7, #4]
 8018ffe:	683b      	ldr	r3, [r7, #0]
 8019000:	429a      	cmp	r2, r3
 8019002:	d207      	bcs.n	8019014 <SkipEndOfLineChars+0x2a>
              (line[0] == '\r' || line[0] == '\n')) {
 8019004:	687b      	ldr	r3, [r7, #4]
 8019006:	781b      	ldrb	r3, [r3, #0]
    while (line < endOfLine &&
 8019008:	2b0d      	cmp	r3, #13
 801900a:	d0f4      	beq.n	8018ff6 <SkipEndOfLineChars+0xc>
              (line[0] == '\r' || line[0] == '\n')) {
 801900c:	687b      	ldr	r3, [r7, #4]
 801900e:	781b      	ldrb	r3, [r3, #0]
 8019010:	2b0a      	cmp	r3, #10
 8019012:	d0f0      	beq.n	8018ff6 <SkipEndOfLineChars+0xc>
    }
    return line;
 8019014:	687b      	ldr	r3, [r7, #4]
}
 8019016:	4618      	mov	r0, r3
 8019018:	370c      	adds	r7, #12
 801901a:	46bd      	mov	sp, r7
 801901c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019020:	4770      	bx	lr
	...

08019024 <wc_PemGetHeaderFooter>:
#endif

int wc_PemGetHeaderFooter(int type, const char** header, const char** footer)
{
 8019024:	b480      	push	{r7}
 8019026:	b087      	sub	sp, #28
 8019028:	af00      	add	r7, sp, #0
 801902a:	60f8      	str	r0, [r7, #12]
 801902c:	60b9      	str	r1, [r7, #8]
 801902e:	607a      	str	r2, [r7, #4]
    int ret = WC_NO_ERR_TRACE(BAD_FUNC_ARG);
 8019030:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8019034:	617b      	str	r3, [r7, #20]

    switch (type) {
 8019036:	68fb      	ldr	r3, [r7, #12]
 8019038:	2b2a      	cmp	r3, #42	@ 0x2a
 801903a:	f200 80fe 	bhi.w	801923a <wc_PemGetHeaderFooter+0x216>
 801903e:	a201      	add	r2, pc, #4	@ (adr r2, 8019044 <wc_PemGetHeaderFooter+0x20>)
 8019040:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8019044:	080190f1 	.word	0x080190f1
 8019048:	080191a5 	.word	0x080191a5
 801904c:	0801923b 	.word	0x0801923b
 8019050:	0801912d 	.word	0x0801912d
 8019054:	0801923b 	.word	0x0801923b
 8019058:	0801910f 	.word	0x0801910f
 801905c:	080190f1 	.word	0x080190f1
 8019060:	08019169 	.word	0x08019169
 8019064:	0801923b 	.word	0x0801923b
 8019068:	0801923b 	.word	0x0801923b
 801906c:	0801923b 	.word	0x0801923b
 8019070:	0801923b 	.word	0x0801923b
 8019074:	08019169 	.word	0x08019169
 8019078:	080191a5 	.word	0x080191a5
 801907c:	080191c3 	.word	0x080191c3
 8019080:	080191e1 	.word	0x080191e1
 8019084:	080191c3 	.word	0x080191c3
 8019088:	080190f1 	.word	0x080190f1
 801908c:	0801923b 	.word	0x0801923b
 8019090:	0801923b 	.word	0x0801923b
 8019094:	0801923b 	.word	0x0801923b
 8019098:	0801923b 	.word	0x0801923b
 801909c:	080191ff 	.word	0x080191ff
 80190a0:	0801921d 	.word	0x0801921d
 80190a4:	0801923b 	.word	0x0801923b
 80190a8:	080191ff 	.word	0x080191ff
 80190ac:	0801914b 	.word	0x0801914b
 80190b0:	0801923b 	.word	0x0801923b
 80190b4:	0801923b 	.word	0x0801923b
 80190b8:	0801923b 	.word	0x0801923b
 80190bc:	0801923b 	.word	0x0801923b
 80190c0:	0801923b 	.word	0x0801923b
 80190c4:	0801923b 	.word	0x0801923b
 80190c8:	0801923b 	.word	0x0801923b
 80190cc:	0801923b 	.word	0x0801923b
 80190d0:	0801923b 	.word	0x0801923b
 80190d4:	0801923b 	.word	0x0801923b
 80190d8:	0801923b 	.word	0x0801923b
 80190dc:	0801923b 	.word	0x0801923b
 80190e0:	0801923b 	.word	0x0801923b
 80190e4:	0801923b 	.word	0x0801923b
 80190e8:	08019187 	.word	0x08019187
 80190ec:	080190f1 	.word	0x080190f1
        case CA_TYPE:       /* same as below */
        case TRUSTED_PEER_TYPE:
        case CHAIN_CERT_TYPE:
        case CERT_TYPE:
            if (header) *header = BEGIN_CERT;
 80190f0:	68bb      	ldr	r3, [r7, #8]
 80190f2:	2b00      	cmp	r3, #0
 80190f4:	d002      	beq.n	80190fc <wc_PemGetHeaderFooter+0xd8>
 80190f6:	4a56      	ldr	r2, [pc, #344]	@ (8019250 <wc_PemGetHeaderFooter+0x22c>)
 80190f8:	68bb      	ldr	r3, [r7, #8]
 80190fa:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_CERT;
 80190fc:	687b      	ldr	r3, [r7, #4]
 80190fe:	2b00      	cmp	r3, #0
 8019100:	d002      	beq.n	8019108 <wc_PemGetHeaderFooter+0xe4>
 8019102:	4a54      	ldr	r2, [pc, #336]	@ (8019254 <wc_PemGetHeaderFooter+0x230>)
 8019104:	687b      	ldr	r3, [r7, #4]
 8019106:	601a      	str	r2, [r3, #0]
            ret = 0;
 8019108:	2300      	movs	r3, #0
 801910a:	617b      	str	r3, [r7, #20]
            break;
 801910c:	e099      	b.n	8019242 <wc_PemGetHeaderFooter+0x21e>

        case CRL_TYPE:
            if (header) *header = BEGIN_X509_CRL;
 801910e:	68bb      	ldr	r3, [r7, #8]
 8019110:	2b00      	cmp	r3, #0
 8019112:	d002      	beq.n	801911a <wc_PemGetHeaderFooter+0xf6>
 8019114:	4a50      	ldr	r2, [pc, #320]	@ (8019258 <wc_PemGetHeaderFooter+0x234>)
 8019116:	68bb      	ldr	r3, [r7, #8]
 8019118:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_X509_CRL;
 801911a:	687b      	ldr	r3, [r7, #4]
 801911c:	2b00      	cmp	r3, #0
 801911e:	d002      	beq.n	8019126 <wc_PemGetHeaderFooter+0x102>
 8019120:	4a4e      	ldr	r2, [pc, #312]	@ (801925c <wc_PemGetHeaderFooter+0x238>)
 8019122:	687b      	ldr	r3, [r7, #4]
 8019124:	601a      	str	r2, [r3, #0]
            ret = 0;
 8019126:	2300      	movs	r3, #0
 8019128:	617b      	str	r3, [r7, #20]
            break;
 801912a:	e08a      	b.n	8019242 <wc_PemGetHeaderFooter+0x21e>
    #ifndef NO_DH
        case DH_PARAM_TYPE:
            if (header) *header = BEGIN_DH_PARAM;
 801912c:	68bb      	ldr	r3, [r7, #8]
 801912e:	2b00      	cmp	r3, #0
 8019130:	d002      	beq.n	8019138 <wc_PemGetHeaderFooter+0x114>
 8019132:	4a4b      	ldr	r2, [pc, #300]	@ (8019260 <wc_PemGetHeaderFooter+0x23c>)
 8019134:	68bb      	ldr	r3, [r7, #8]
 8019136:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_DH_PARAM;
 8019138:	687b      	ldr	r3, [r7, #4]
 801913a:	2b00      	cmp	r3, #0
 801913c:	d002      	beq.n	8019144 <wc_PemGetHeaderFooter+0x120>
 801913e:	4a49      	ldr	r2, [pc, #292]	@ (8019264 <wc_PemGetHeaderFooter+0x240>)
 8019140:	687b      	ldr	r3, [r7, #4]
 8019142:	601a      	str	r2, [r3, #0]
            ret = 0;
 8019144:	2300      	movs	r3, #0
 8019146:	617b      	str	r3, [r7, #20]
            break;
 8019148:	e07b      	b.n	8019242 <wc_PemGetHeaderFooter+0x21e>
        case X942_PARAM_TYPE:
            if (header) *header = BEGIN_X942_PARAM;
 801914a:	68bb      	ldr	r3, [r7, #8]
 801914c:	2b00      	cmp	r3, #0
 801914e:	d002      	beq.n	8019156 <wc_PemGetHeaderFooter+0x132>
 8019150:	4a45      	ldr	r2, [pc, #276]	@ (8019268 <wc_PemGetHeaderFooter+0x244>)
 8019152:	68bb      	ldr	r3, [r7, #8]
 8019154:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_X942_PARAM;
 8019156:	687b      	ldr	r3, [r7, #4]
 8019158:	2b00      	cmp	r3, #0
 801915a:	d002      	beq.n	8019162 <wc_PemGetHeaderFooter+0x13e>
 801915c:	4a43      	ldr	r2, [pc, #268]	@ (801926c <wc_PemGetHeaderFooter+0x248>)
 801915e:	687b      	ldr	r3, [r7, #4]
 8019160:	601a      	str	r2, [r3, #0]
            ret = 0;
 8019162:	2300      	movs	r3, #0
 8019164:	617b      	str	r3, [r7, #20]
            break;
 8019166:	e06c      	b.n	8019242 <wc_PemGetHeaderFooter+0x21e>
            break;
    #endif
    #ifdef HAVE_ECC
        case ECC_TYPE:
        case ECC_PRIVATEKEY_TYPE:
            if (header) *header = BEGIN_EC_PRIV;
 8019168:	68bb      	ldr	r3, [r7, #8]
 801916a:	2b00      	cmp	r3, #0
 801916c:	d002      	beq.n	8019174 <wc_PemGetHeaderFooter+0x150>
 801916e:	4a40      	ldr	r2, [pc, #256]	@ (8019270 <wc_PemGetHeaderFooter+0x24c>)
 8019170:	68bb      	ldr	r3, [r7, #8]
 8019172:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_EC_PRIV;
 8019174:	687b      	ldr	r3, [r7, #4]
 8019176:	2b00      	cmp	r3, #0
 8019178:	d002      	beq.n	8019180 <wc_PemGetHeaderFooter+0x15c>
 801917a:	4a3e      	ldr	r2, [pc, #248]	@ (8019274 <wc_PemGetHeaderFooter+0x250>)
 801917c:	687b      	ldr	r3, [r7, #4]
 801917e:	601a      	str	r2, [r3, #0]
            ret = 0;
 8019180:	2300      	movs	r3, #0
 8019182:	617b      	str	r3, [r7, #20]
            break;
 8019184:	e05d      	b.n	8019242 <wc_PemGetHeaderFooter+0x21e>
    #ifdef OPENSSL_EXTRA
        case ECC_PARAM_TYPE:
            if (header) *header = BEGIN_EC_PARAM;
 8019186:	68bb      	ldr	r3, [r7, #8]
 8019188:	2b00      	cmp	r3, #0
 801918a:	d002      	beq.n	8019192 <wc_PemGetHeaderFooter+0x16e>
 801918c:	4a3a      	ldr	r2, [pc, #232]	@ (8019278 <wc_PemGetHeaderFooter+0x254>)
 801918e:	68bb      	ldr	r3, [r7, #8]
 8019190:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_EC_PARAM;
 8019192:	687b      	ldr	r3, [r7, #4]
 8019194:	2b00      	cmp	r3, #0
 8019196:	d002      	beq.n	801919e <wc_PemGetHeaderFooter+0x17a>
 8019198:	4a38      	ldr	r2, [pc, #224]	@ (801927c <wc_PemGetHeaderFooter+0x258>)
 801919a:	687b      	ldr	r3, [r7, #4]
 801919c:	601a      	str	r2, [r3, #0]
            ret = 0;
 801919e:	2300      	movs	r3, #0
 80191a0:	617b      	str	r3, [r7, #20]
            break;
 80191a2:	e04e      	b.n	8019242 <wc_PemGetHeaderFooter+0x21e>
        case RSA_TYPE:
        case PRIVATEKEY_TYPE:
    #ifdef WOLFSSL_DUAL_ALG_CERTS
        case ALT_PRIVATEKEY_TYPE:
    #endif
            if (header) *header = BEGIN_RSA_PRIV;
 80191a4:	68bb      	ldr	r3, [r7, #8]
 80191a6:	2b00      	cmp	r3, #0
 80191a8:	d002      	beq.n	80191b0 <wc_PemGetHeaderFooter+0x18c>
 80191aa:	4a35      	ldr	r2, [pc, #212]	@ (8019280 <wc_PemGetHeaderFooter+0x25c>)
 80191ac:	68bb      	ldr	r3, [r7, #8]
 80191ae:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_RSA_PRIV;
 80191b0:	687b      	ldr	r3, [r7, #4]
 80191b2:	2b00      	cmp	r3, #0
 80191b4:	d002      	beq.n	80191bc <wc_PemGetHeaderFooter+0x198>
 80191b6:	4a33      	ldr	r2, [pc, #204]	@ (8019284 <wc_PemGetHeaderFooter+0x260>)
 80191b8:	687b      	ldr	r3, [r7, #4]
 80191ba:	601a      	str	r2, [r3, #0]
            ret = 0;
 80191bc:	2300      	movs	r3, #0
 80191be:	617b      	str	r3, [r7, #20]
            break;
 80191c0:	e03f      	b.n	8019242 <wc_PemGetHeaderFooter+0x21e>
            ret = 0;
            break;
#endif /* HAVE_SPHINCS */
        case PUBLICKEY_TYPE:
        case ECC_PUBLICKEY_TYPE:
            if (header) *header = BEGIN_PUB_KEY;
 80191c2:	68bb      	ldr	r3, [r7, #8]
 80191c4:	2b00      	cmp	r3, #0
 80191c6:	d002      	beq.n	80191ce <wc_PemGetHeaderFooter+0x1aa>
 80191c8:	4a2f      	ldr	r2, [pc, #188]	@ (8019288 <wc_PemGetHeaderFooter+0x264>)
 80191ca:	68bb      	ldr	r3, [r7, #8]
 80191cc:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_PUB_KEY;
 80191ce:	687b      	ldr	r3, [r7, #4]
 80191d0:	2b00      	cmp	r3, #0
 80191d2:	d002      	beq.n	80191da <wc_PemGetHeaderFooter+0x1b6>
 80191d4:	4a2d      	ldr	r2, [pc, #180]	@ (801928c <wc_PemGetHeaderFooter+0x268>)
 80191d6:	687b      	ldr	r3, [r7, #4]
 80191d8:	601a      	str	r2, [r3, #0]
            ret = 0;
 80191da:	2300      	movs	r3, #0
 80191dc:	617b      	str	r3, [r7, #20]
            break;
 80191de:	e030      	b.n	8019242 <wc_PemGetHeaderFooter+0x21e>
        case RSA_PUBLICKEY_TYPE:
            if (header) *header = BEGIN_RSA_PUB;
 80191e0:	68bb      	ldr	r3, [r7, #8]
 80191e2:	2b00      	cmp	r3, #0
 80191e4:	d002      	beq.n	80191ec <wc_PemGetHeaderFooter+0x1c8>
 80191e6:	4a2a      	ldr	r2, [pc, #168]	@ (8019290 <wc_PemGetHeaderFooter+0x26c>)
 80191e8:	68bb      	ldr	r3, [r7, #8]
 80191ea:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_RSA_PUB;
 80191ec:	687b      	ldr	r3, [r7, #4]
 80191ee:	2b00      	cmp	r3, #0
 80191f0:	d002      	beq.n	80191f8 <wc_PemGetHeaderFooter+0x1d4>
 80191f2:	4a28      	ldr	r2, [pc, #160]	@ (8019294 <wc_PemGetHeaderFooter+0x270>)
 80191f4:	687b      	ldr	r3, [r7, #4]
 80191f6:	601a      	str	r2, [r3, #0]
            ret = 0;
 80191f8:	2300      	movs	r3, #0
 80191fa:	617b      	str	r3, [r7, #20]
            break;
 80191fc:	e021      	b.n	8019242 <wc_PemGetHeaderFooter+0x21e>
    #ifndef NO_DH
        case DH_PRIVATEKEY_TYPE:
    #endif
        case PKCS8_PRIVATEKEY_TYPE:
            if (header) *header = BEGIN_PRIV_KEY;
 80191fe:	68bb      	ldr	r3, [r7, #8]
 8019200:	2b00      	cmp	r3, #0
 8019202:	d002      	beq.n	801920a <wc_PemGetHeaderFooter+0x1e6>
 8019204:	4a24      	ldr	r2, [pc, #144]	@ (8019298 <wc_PemGetHeaderFooter+0x274>)
 8019206:	68bb      	ldr	r3, [r7, #8]
 8019208:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_PRIV_KEY;
 801920a:	687b      	ldr	r3, [r7, #4]
 801920c:	2b00      	cmp	r3, #0
 801920e:	d002      	beq.n	8019216 <wc_PemGetHeaderFooter+0x1f2>
 8019210:	4a22      	ldr	r2, [pc, #136]	@ (801929c <wc_PemGetHeaderFooter+0x278>)
 8019212:	687b      	ldr	r3, [r7, #4]
 8019214:	601a      	str	r2, [r3, #0]
            ret = 0;
 8019216:	2300      	movs	r3, #0
 8019218:	617b      	str	r3, [r7, #20]
            break;
 801921a:	e012      	b.n	8019242 <wc_PemGetHeaderFooter+0x21e>
        case PKCS8_ENC_PRIVATEKEY_TYPE:
            if (header) *header = BEGIN_ENC_PRIV_KEY;
 801921c:	68bb      	ldr	r3, [r7, #8]
 801921e:	2b00      	cmp	r3, #0
 8019220:	d002      	beq.n	8019228 <wc_PemGetHeaderFooter+0x204>
 8019222:	4a1f      	ldr	r2, [pc, #124]	@ (80192a0 <wc_PemGetHeaderFooter+0x27c>)
 8019224:	68bb      	ldr	r3, [r7, #8]
 8019226:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_ENC_PRIV_KEY;
 8019228:	687b      	ldr	r3, [r7, #4]
 801922a:	2b00      	cmp	r3, #0
 801922c:	d002      	beq.n	8019234 <wc_PemGetHeaderFooter+0x210>
 801922e:	4a1d      	ldr	r2, [pc, #116]	@ (80192a4 <wc_PemGetHeaderFooter+0x280>)
 8019230:	687b      	ldr	r3, [r7, #4]
 8019232:	601a      	str	r2, [r3, #0]
            ret = 0;
 8019234:	2300      	movs	r3, #0
 8019236:	617b      	str	r3, [r7, #20]
            break;
 8019238:	e003      	b.n	8019242 <wc_PemGetHeaderFooter+0x21e>
        default:
            ret = BAD_FUNC_ARG;
 801923a:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801923e:	617b      	str	r3, [r7, #20]
            break;
 8019240:	bf00      	nop
    }
    return ret;
 8019242:	697b      	ldr	r3, [r7, #20]
}
 8019244:	4618      	mov	r0, r3
 8019246:	371c      	adds	r7, #28
 8019248:	46bd      	mov	sp, r7
 801924a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801924e:	4770      	bx	lr
 8019250:	0802f878 	.word	0x0802f878
 8019254:	0802f894 	.word	0x0802f894
 8019258:	0802f934 	.word	0x0802f934
 801925c:	0802f950 	.word	0x0802f950
 8019260:	0802f8b0 	.word	0x0802f8b0
 8019264:	0802f8d0 	.word	0x0802f8d0
 8019268:	0802f8ec 	.word	0x0802f8ec
 801926c:	0802f910 	.word	0x0802f910
 8019270:	0802fa6c 	.word	0x0802fa6c
 8019274:	0802fa8c 	.word	0x0802fa8c
 8019278:	0802faac 	.word	0x0802faac
 801927c:	0802facc 	.word	0x0802facc
 8019280:	0802f968 	.word	0x0802f968
 8019284:	0802f988 	.word	0x0802f988
 8019288:	0802fb28 	.word	0x0802fb28
 801928c:	0802fb44 	.word	0x0802fb44
 8019290:	0802f9a8 	.word	0x0802f9a8
 8019294:	0802f9c8 	.word	0x0802f9c8
 8019298:	0802f9e8 	.word	0x0802f9e8
 801929c:	0802fa04 	.word	0x0802fa04
 80192a0:	0802fa20 	.word	0x0802fa20
 80192a4:	0802fa48 	.word	0x0802fa48

080192a8 <wc_EncryptedInfoGet>:
#if !defined(NO_AES) && defined(HAVE_AES_CBC) && defined(WOLFSSL_AES_256)
    static wcchar kEncTypeAesCbc256 = "AES-256-CBC";
#endif

int wc_EncryptedInfoGet(EncryptedInfo* info, const char* cipherInfo)
{
 80192a8:	b580      	push	{r7, lr}
 80192aa:	b084      	sub	sp, #16
 80192ac:	af00      	add	r7, sp, #0
 80192ae:	6078      	str	r0, [r7, #4]
 80192b0:	6039      	str	r1, [r7, #0]
    int ret = 0;
 80192b2:	2300      	movs	r3, #0
 80192b4:	60fb      	str	r3, [r7, #12]

    if (info == NULL || cipherInfo == NULL)
 80192b6:	687b      	ldr	r3, [r7, #4]
 80192b8:	2b00      	cmp	r3, #0
 80192ba:	d002      	beq.n	80192c2 <wc_EncryptedInfoGet+0x1a>
 80192bc:	683b      	ldr	r3, [r7, #0]
 80192be:	2b00      	cmp	r3, #0
 80192c0:	d102      	bne.n	80192c8 <wc_EncryptedInfoGet+0x20>
        return BAD_FUNC_ARG;
 80192c2:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80192c6:	e045      	b.n	8019354 <wc_EncryptedInfoGet+0xac>
#endif
    }
    else
#endif /* !NO_DES3 */
#if !defined(NO_AES) && defined(HAVE_AES_CBC) && defined(WOLFSSL_AES_128)
    if (XSTRCMP(cipherInfo, kEncTypeAesCbc128) == 0) {
 80192c8:	4b24      	ldr	r3, [pc, #144]	@ (801935c <wc_EncryptedInfoGet+0xb4>)
 80192ca:	4619      	mov	r1, r3
 80192cc:	6838      	ldr	r0, [r7, #0]
 80192ce:	f7e6 ff7f 	bl	80001d0 <strcmp>
 80192d2:	4603      	mov	r3, r0
 80192d4:	2b00      	cmp	r3, #0
 80192d6:	d10d      	bne.n	80192f4 <wc_EncryptedInfoGet+0x4c>
        info->cipherType = WC_CIPHER_AES_CBC;
 80192d8:	687b      	ldr	r3, [r7, #4]
 80192da:	2202      	movs	r2, #2
 80192dc:	60da      	str	r2, [r3, #12]
        info->keySz = AES_128_KEY_SIZE;
 80192de:	687b      	ldr	r3, [r7, #4]
 80192e0:	2210      	movs	r2, #16
 80192e2:	611a      	str	r2, [r3, #16]
        if (info->ivSz == 0) info->ivSz  = AES_IV_SIZE;
 80192e4:	687b      	ldr	r3, [r7, #4]
 80192e6:	695b      	ldr	r3, [r3, #20]
 80192e8:	2b00      	cmp	r3, #0
 80192ea:	d132      	bne.n	8019352 <wc_EncryptedInfoGet+0xaa>
 80192ec:	687b      	ldr	r3, [r7, #4]
 80192ee:	2210      	movs	r2, #16
 80192f0:	615a      	str	r2, [r3, #20]
 80192f2:	e02e      	b.n	8019352 <wc_EncryptedInfoGet+0xaa>
    }
    else
#endif
#if !defined(NO_AES) && defined(HAVE_AES_CBC) && defined(WOLFSSL_AES_192)
    if (XSTRCMP(cipherInfo, kEncTypeAesCbc192) == 0) {
 80192f4:	4b1a      	ldr	r3, [pc, #104]	@ (8019360 <wc_EncryptedInfoGet+0xb8>)
 80192f6:	4619      	mov	r1, r3
 80192f8:	6838      	ldr	r0, [r7, #0]
 80192fa:	f7e6 ff69 	bl	80001d0 <strcmp>
 80192fe:	4603      	mov	r3, r0
 8019300:	2b00      	cmp	r3, #0
 8019302:	d10d      	bne.n	8019320 <wc_EncryptedInfoGet+0x78>
        info->cipherType = WC_CIPHER_AES_CBC;
 8019304:	687b      	ldr	r3, [r7, #4]
 8019306:	2202      	movs	r2, #2
 8019308:	60da      	str	r2, [r3, #12]
        info->keySz = AES_192_KEY_SIZE;
 801930a:	687b      	ldr	r3, [r7, #4]
 801930c:	2218      	movs	r2, #24
 801930e:	611a      	str	r2, [r3, #16]
        if (info->ivSz == 0) info->ivSz  = AES_IV_SIZE;
 8019310:	687b      	ldr	r3, [r7, #4]
 8019312:	695b      	ldr	r3, [r3, #20]
 8019314:	2b00      	cmp	r3, #0
 8019316:	d11c      	bne.n	8019352 <wc_EncryptedInfoGet+0xaa>
 8019318:	687b      	ldr	r3, [r7, #4]
 801931a:	2210      	movs	r2, #16
 801931c:	615a      	str	r2, [r3, #20]
 801931e:	e018      	b.n	8019352 <wc_EncryptedInfoGet+0xaa>
    }
    else
#endif
#if !defined(NO_AES) && defined(HAVE_AES_CBC) && defined(WOLFSSL_AES_256)
    if (XSTRCMP(cipherInfo, kEncTypeAesCbc256) == 0) {
 8019320:	4b10      	ldr	r3, [pc, #64]	@ (8019364 <wc_EncryptedInfoGet+0xbc>)
 8019322:	4619      	mov	r1, r3
 8019324:	6838      	ldr	r0, [r7, #0]
 8019326:	f7e6 ff53 	bl	80001d0 <strcmp>
 801932a:	4603      	mov	r3, r0
 801932c:	2b00      	cmp	r3, #0
 801932e:	d10d      	bne.n	801934c <wc_EncryptedInfoGet+0xa4>
        info->cipherType = WC_CIPHER_AES_CBC;
 8019330:	687b      	ldr	r3, [r7, #4]
 8019332:	2202      	movs	r2, #2
 8019334:	60da      	str	r2, [r3, #12]
        info->keySz = AES_256_KEY_SIZE;
 8019336:	687b      	ldr	r3, [r7, #4]
 8019338:	2220      	movs	r2, #32
 801933a:	611a      	str	r2, [r3, #16]
        if (info->ivSz == 0) info->ivSz  = AES_IV_SIZE;
 801933c:	687b      	ldr	r3, [r7, #4]
 801933e:	695b      	ldr	r3, [r3, #20]
 8019340:	2b00      	cmp	r3, #0
 8019342:	d106      	bne.n	8019352 <wc_EncryptedInfoGet+0xaa>
 8019344:	687b      	ldr	r3, [r7, #4]
 8019346:	2210      	movs	r2, #16
 8019348:	615a      	str	r2, [r3, #20]
 801934a:	e002      	b.n	8019352 <wc_EncryptedInfoGet+0xaa>
    }
    else
#endif
    {
        ret = NOT_COMPILED_IN;
 801934c:	f06f 03ad 	mvn.w	r3, #173	@ 0xad
 8019350:	60fb      	str	r3, [r7, #12]
    }
    return ret;
 8019352:	68fb      	ldr	r3, [r7, #12]
}
 8019354:	4618      	mov	r0, r3
 8019356:	3710      	adds	r7, #16
 8019358:	46bd      	mov	sp, r7
 801935a:	bd80      	pop	{r7, pc}
 801935c:	0802fb78 	.word	0x0802fb78
 8019360:	0802fb84 	.word	0x0802fb84
 8019364:	0802fb90 	.word	0x0802fb90

08019368 <wc_EncryptedInfoParse>:

int wc_EncryptedInfoParse(EncryptedInfo* info, const char** pBuffer,
                          size_t bufSz)
{
 8019368:	b590      	push	{r4, r7, lr}
 801936a:	b08f      	sub	sp, #60	@ 0x3c
 801936c:	af00      	add	r7, sp, #0
 801936e:	60f8      	str	r0, [r7, #12]
 8019370:	60b9      	str	r1, [r7, #8]
 8019372:	607a      	str	r2, [r7, #4]
    int         err = 0;
 8019374:	2300      	movs	r3, #0
 8019376:	637b      	str	r3, [r7, #52]	@ 0x34
    const char* bufferStart;
    const char* bufferEnd;
    char*       line;

    if (info == NULL || pBuffer == NULL || bufSz == 0)
 8019378:	68fb      	ldr	r3, [r7, #12]
 801937a:	2b00      	cmp	r3, #0
 801937c:	d005      	beq.n	801938a <wc_EncryptedInfoParse+0x22>
 801937e:	68bb      	ldr	r3, [r7, #8]
 8019380:	2b00      	cmp	r3, #0
 8019382:	d002      	beq.n	801938a <wc_EncryptedInfoParse+0x22>
 8019384:	687b      	ldr	r3, [r7, #4]
 8019386:	2b00      	cmp	r3, #0
 8019388:	d102      	bne.n	8019390 <wc_EncryptedInfoParse+0x28>
        return BAD_FUNC_ARG;
 801938a:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801938e:	e106      	b.n	801959e <wc_EncryptedInfoParse+0x236>

    bufferStart = *pBuffer;
 8019390:	68bb      	ldr	r3, [r7, #8]
 8019392:	681b      	ldr	r3, [r3, #0]
 8019394:	62bb      	str	r3, [r7, #40]	@ 0x28
    bufferEnd = bufferStart + bufSz;
 8019396:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8019398:	687b      	ldr	r3, [r7, #4]
 801939a:	4413      	add	r3, r2
 801939c:	627b      	str	r3, [r7, #36]	@ 0x24

    /* find encrypted info marker */
    line = XSTRNSTR(bufferStart, kProcTypeHeader,
 801939e:	4c82      	ldr	r4, [pc, #520]	@ (80195a8 <wc_EncryptedInfoParse+0x240>)
 80193a0:	214c      	movs	r1, #76	@ 0x4c
 80193a2:	6878      	ldr	r0, [r7, #4]
 80193a4:	f7f9 f98e 	bl	80126c4 <min>
 80193a8:	4603      	mov	r3, r0
 80193aa:	461a      	mov	r2, r3
 80193ac:	4621      	mov	r1, r4
 80193ae:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 80193b0:	f00e f810 	bl	80273d4 <mystrnstr>
 80193b4:	6238      	str	r0, [r7, #32]
                    min((word32)bufSz, PEM_LINE_LEN));
    if (line != NULL) {
 80193b6:	6a3b      	ldr	r3, [r7, #32]
 80193b8:	2b00      	cmp	r3, #0
 80193ba:	f000 80ef 	beq.w	801959c <wc_EncryptedInfoParse+0x234>
        word32      lineSz;
        char*       finish;
        char*       start;
        word32      startSz;
        const char* newline = NULL;
 80193be:	2300      	movs	r3, #0
 80193c0:	62fb      	str	r3, [r7, #44]	@ 0x2c

        if (line >= bufferEnd) {
 80193c2:	6a3a      	ldr	r2, [r7, #32]
 80193c4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80193c6:	429a      	cmp	r2, r3
 80193c8:	d302      	bcc.n	80193d0 <wc_EncryptedInfoParse+0x68>
            return BUFFER_E;
 80193ca:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 80193ce:	e0e6      	b.n	801959e <wc_EncryptedInfoParse+0x236>
        }

        lineSz = (word32)(bufferEnd - line);
 80193d0:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80193d2:	6a3b      	ldr	r3, [r7, #32]
 80193d4:	1ad3      	subs	r3, r2, r3
 80193d6:	61fb      	str	r3, [r7, #28]

        /* find DEC-Info marker */
        start = XSTRNSTR(line, kDecInfoHeader, min(lineSz, PEM_LINE_LEN));
 80193d8:	4c74      	ldr	r4, [pc, #464]	@ (80195ac <wc_EncryptedInfoParse+0x244>)
 80193da:	214c      	movs	r1, #76	@ 0x4c
 80193dc:	69f8      	ldr	r0, [r7, #28]
 80193de:	f7f9 f971 	bl	80126c4 <min>
 80193e2:	4603      	mov	r3, r0
 80193e4:	461a      	mov	r2, r3
 80193e6:	4621      	mov	r1, r4
 80193e8:	6a38      	ldr	r0, [r7, #32]
 80193ea:	f00d fff3 	bl	80273d4 <mystrnstr>
 80193ee:	6338      	str	r0, [r7, #48]	@ 0x30

        if (start == NULL)
 80193f0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80193f2:	2b00      	cmp	r3, #0
 80193f4:	d102      	bne.n	80193fc <wc_EncryptedInfoParse+0x94>
            return BUFFER_E;
 80193f6:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 80193fa:	e0d0      	b.n	801959e <wc_EncryptedInfoParse+0x236>

        /* skip dec-info and ": " */
        start += XSTRLEN(kDecInfoHeader);
 80193fc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80193fe:	3308      	adds	r3, #8
 8019400:	633b      	str	r3, [r7, #48]	@ 0x30
        if (start >= bufferEnd)
 8019402:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8019404:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8019406:	429a      	cmp	r2, r3
 8019408:	d302      	bcc.n	8019410 <wc_EncryptedInfoParse+0xa8>
            return BUFFER_E;
 801940a:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 801940e:	e0c6      	b.n	801959e <wc_EncryptedInfoParse+0x236>

        if (start[0] == ':') {
 8019410:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8019412:	781b      	ldrb	r3, [r3, #0]
 8019414:	2b3a      	cmp	r3, #58	@ 0x3a
 8019416:	d109      	bne.n	801942c <wc_EncryptedInfoParse+0xc4>
            start++;
 8019418:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801941a:	3301      	adds	r3, #1
 801941c:	633b      	str	r3, [r7, #48]	@ 0x30
            if (start >= bufferEnd)
 801941e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8019420:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8019422:	429a      	cmp	r2, r3
 8019424:	d302      	bcc.n	801942c <wc_EncryptedInfoParse+0xc4>
                return BUFFER_E;
 8019426:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 801942a:	e0b8      	b.n	801959e <wc_EncryptedInfoParse+0x236>
        }
        if (start[0] == ' ')
 801942c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801942e:	781b      	ldrb	r3, [r3, #0]
 8019430:	2b20      	cmp	r3, #32
 8019432:	d102      	bne.n	801943a <wc_EncryptedInfoParse+0xd2>
            start++;
 8019434:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8019436:	3301      	adds	r3, #1
 8019438:	633b      	str	r3, [r7, #48]	@ 0x30

        startSz = (word32)(bufferEnd - start);
 801943a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801943c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801943e:	1ad3      	subs	r3, r2, r3
 8019440:	61bb      	str	r3, [r7, #24]
        finish = XSTRNSTR(start, ",", min(startSz, PEM_LINE_LEN));
 8019442:	214c      	movs	r1, #76	@ 0x4c
 8019444:	69b8      	ldr	r0, [r7, #24]
 8019446:	f7f9 f93d 	bl	80126c4 <min>
 801944a:	4603      	mov	r3, r0
 801944c:	461a      	mov	r2, r3
 801944e:	4958      	ldr	r1, [pc, #352]	@ (80195b0 <wc_EncryptedInfoParse+0x248>)
 8019450:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 8019452:	f00d ffbf 	bl	80273d4 <mystrnstr>
 8019456:	6178      	str	r0, [r7, #20]

        if ((start != NULL) && (finish != NULL) && (start < finish)) {
 8019458:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801945a:	2b00      	cmp	r3, #0
 801945c:	f000 809b 	beq.w	8019596 <wc_EncryptedInfoParse+0x22e>
 8019460:	697b      	ldr	r3, [r7, #20]
 8019462:	2b00      	cmp	r3, #0
 8019464:	f000 8097 	beq.w	8019596 <wc_EncryptedInfoParse+0x22e>
 8019468:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801946a:	697b      	ldr	r3, [r7, #20]
 801946c:	429a      	cmp	r2, r3
 801946e:	f080 8092 	bcs.w	8019596 <wc_EncryptedInfoParse+0x22e>
            word32 finishSz;

            if (finish >= bufferEnd) {
 8019472:	697a      	ldr	r2, [r7, #20]
 8019474:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8019476:	429a      	cmp	r2, r3
 8019478:	d302      	bcc.n	8019480 <wc_EncryptedInfoParse+0x118>
                return BUFFER_E;
 801947a:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 801947e:	e08e      	b.n	801959e <wc_EncryptedInfoParse+0x236>
            }

            finishSz = (word32)(bufferEnd - finish);
 8019480:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8019482:	697b      	ldr	r3, [r7, #20]
 8019484:	1ad3      	subs	r3, r2, r3
 8019486:	613b      	str	r3, [r7, #16]
            newline = XSTRNSTR(finish, "\r", min(finishSz, PEM_LINE_LEN));
 8019488:	214c      	movs	r1, #76	@ 0x4c
 801948a:	6938      	ldr	r0, [r7, #16]
 801948c:	f7f9 f91a 	bl	80126c4 <min>
 8019490:	4603      	mov	r3, r0
 8019492:	461a      	mov	r2, r3
 8019494:	4947      	ldr	r1, [pc, #284]	@ (80195b4 <wc_EncryptedInfoParse+0x24c>)
 8019496:	6978      	ldr	r0, [r7, #20]
 8019498:	f00d ff9c 	bl	80273d4 <mystrnstr>
 801949c:	62f8      	str	r0, [r7, #44]	@ 0x2c

            /* get cipher name */
            if (NAME_SZ < (finish - start)) /* buffer size of info->name */
 801949e:	697a      	ldr	r2, [r7, #20]
 80194a0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80194a2:	1ad3      	subs	r3, r2, r3
 80194a4:	2b50      	cmp	r3, #80	@ 0x50
 80194a6:	dd02      	ble.n	80194ae <wc_EncryptedInfoParse+0x146>
                return BUFFER_E;
 80194a8:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 80194ac:	e077      	b.n	801959e <wc_EncryptedInfoParse+0x236>
            if (XMEMCPY(info->name, start, (size_t)(finish - start)) == NULL)
 80194ae:	68fb      	ldr	r3, [r7, #12]
 80194b0:	f103 0018 	add.w	r0, r3, #24
 80194b4:	697a      	ldr	r2, [r7, #20]
 80194b6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80194b8:	1ad3      	subs	r3, r2, r3
 80194ba:	461a      	mov	r2, r3
 80194bc:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 80194be:	f00f f86d 	bl	802859c <memcpy>
 80194c2:	4603      	mov	r3, r0
 80194c4:	2b00      	cmp	r3, #0
 80194c6:	d102      	bne.n	80194ce <wc_EncryptedInfoParse+0x166>
                return BUFFER_E;
 80194c8:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 80194cc:	e067      	b.n	801959e <wc_EncryptedInfoParse+0x236>
            info->name[finish - start] = '\0'; /* null term */
 80194ce:	697a      	ldr	r2, [r7, #20]
 80194d0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80194d2:	1ad3      	subs	r3, r2, r3
 80194d4:	68fa      	ldr	r2, [r7, #12]
 80194d6:	4413      	add	r3, r2
 80194d8:	2200      	movs	r2, #0
 80194da:	761a      	strb	r2, [r3, #24]

            /* populate info */
            err = wc_EncryptedInfoGet(info, info->name);
 80194dc:	68fb      	ldr	r3, [r7, #12]
 80194de:	3318      	adds	r3, #24
 80194e0:	4619      	mov	r1, r3
 80194e2:	68f8      	ldr	r0, [r7, #12]
 80194e4:	f7ff fee0 	bl	80192a8 <wc_EncryptedInfoGet>
 80194e8:	6378      	str	r0, [r7, #52]	@ 0x34
            if (err != 0)
 80194ea:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80194ec:	2b00      	cmp	r3, #0
 80194ee:	d001      	beq.n	80194f4 <wc_EncryptedInfoParse+0x18c>
                return err;
 80194f0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80194f2:	e054      	b.n	801959e <wc_EncryptedInfoParse+0x236>

            /* get IV */
            if (finishSz < info->ivSz + 1)
 80194f4:	68fb      	ldr	r3, [r7, #12]
 80194f6:	695b      	ldr	r3, [r3, #20]
 80194f8:	3301      	adds	r3, #1
 80194fa:	693a      	ldr	r2, [r7, #16]
 80194fc:	429a      	cmp	r2, r3
 80194fe:	d202      	bcs.n	8019506 <wc_EncryptedInfoParse+0x19e>
                return BUFFER_E;
 8019500:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8019504:	e04b      	b.n	801959e <wc_EncryptedInfoParse+0x236>

            if (newline == NULL) {
 8019506:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019508:	2b00      	cmp	r3, #0
 801950a:	d10a      	bne.n	8019522 <wc_EncryptedInfoParse+0x1ba>
                newline = XSTRNSTR(finish, "\n", min(finishSz,
 801950c:	214c      	movs	r1, #76	@ 0x4c
 801950e:	6938      	ldr	r0, [r7, #16]
 8019510:	f7f9 f8d8 	bl	80126c4 <min>
 8019514:	4603      	mov	r3, r0
 8019516:	461a      	mov	r2, r3
 8019518:	4927      	ldr	r1, [pc, #156]	@ (80195b8 <wc_EncryptedInfoParse+0x250>)
 801951a:	6978      	ldr	r0, [r7, #20]
 801951c:	f00d ff5a 	bl	80273d4 <mystrnstr>
 8019520:	62f8      	str	r0, [r7, #44]	@ 0x2c
                                                     PEM_LINE_LEN));
            }
            if ((newline != NULL) && (newline > finish)) {
 8019522:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019524:	2b00      	cmp	r3, #0
 8019526:	d033      	beq.n	8019590 <wc_EncryptedInfoParse+0x228>
 8019528:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801952a:	697b      	ldr	r3, [r7, #20]
 801952c:	429a      	cmp	r2, r3
 801952e:	d92f      	bls.n	8019590 <wc_EncryptedInfoParse+0x228>
                finish++;
 8019530:	697b      	ldr	r3, [r7, #20]
 8019532:	3301      	adds	r3, #1
 8019534:	617b      	str	r3, [r7, #20]
                info->ivSz = (word32)(newline - finish);
 8019536:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8019538:	697b      	ldr	r3, [r7, #20]
 801953a:	1ad3      	subs	r3, r2, r3
 801953c:	461a      	mov	r2, r3
 801953e:	68fb      	ldr	r3, [r7, #12]
 8019540:	615a      	str	r2, [r3, #20]
                if (info->ivSz > IV_SZ)
 8019542:	68fb      	ldr	r3, [r7, #12]
 8019544:	695b      	ldr	r3, [r3, #20]
 8019546:	2b20      	cmp	r3, #32
 8019548:	d902      	bls.n	8019550 <wc_EncryptedInfoParse+0x1e8>
                    return BUFFER_E;
 801954a:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 801954e:	e026      	b.n	801959e <wc_EncryptedInfoParse+0x236>
                if (XMEMCPY(info->iv, finish, info->ivSz) == NULL)
 8019550:	68fb      	ldr	r3, [r7, #12]
 8019552:	f103 0068 	add.w	r0, r3, #104	@ 0x68
 8019556:	68fb      	ldr	r3, [r7, #12]
 8019558:	695b      	ldr	r3, [r3, #20]
 801955a:	461a      	mov	r2, r3
 801955c:	6979      	ldr	r1, [r7, #20]
 801955e:	f00f f81d 	bl	802859c <memcpy>
 8019562:	4603      	mov	r3, r0
 8019564:	2b00      	cmp	r3, #0
 8019566:	d102      	bne.n	801956e <wc_EncryptedInfoParse+0x206>
                    return BUFFER_E;
 8019568:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 801956c:	e017      	b.n	801959e <wc_EncryptedInfoParse+0x236>
                info->set = 1;
 801956e:	68fa      	ldr	r2, [r7, #12]
 8019570:	f892 3088 	ldrb.w	r3, [r2, #136]	@ 0x88
 8019574:	f043 0301 	orr.w	r3, r3, #1
 8019578:	f882 3088 	strb.w	r3, [r2, #136]	@ 0x88
        if ((start != NULL) && (finish != NULL) && (start < finish)) {
 801957c:	bf00      	nop
        }
        else
            return BUFFER_E;

        /* eat end of line characters */
        newline = SkipEndOfLineChars(newline, bufferEnd);
 801957e:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8019580:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8019582:	f7ff fd32 	bl	8018fea <SkipEndOfLineChars>
 8019586:	62f8      	str	r0, [r7, #44]	@ 0x2c

        /* return new headerEnd */

        *pBuffer = newline;
 8019588:	68bb      	ldr	r3, [r7, #8]
 801958a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801958c:	601a      	str	r2, [r3, #0]
 801958e:	e005      	b.n	801959c <wc_EncryptedInfoParse+0x234>
                return BUFFER_E;
 8019590:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8019594:	e003      	b.n	801959e <wc_EncryptedInfoParse+0x236>
            return BUFFER_E;
 8019596:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 801959a:	e000      	b.n	801959e <wc_EncryptedInfoParse+0x236>
    }

    return err;
 801959c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
 801959e:	4618      	mov	r0, r3
 80195a0:	373c      	adds	r7, #60	@ 0x3c
 80195a2:	46bd      	mov	sp, r7
 80195a4:	bd90      	pop	{r4, r7, pc}
 80195a6:	bf00      	nop
 80195a8:	0802fb60 	.word	0x0802fb60
 80195ac:	0802fb6c 	.word	0x0802fb6c
 80195b0:	0802fb9c 	.word	0x0802fb9c
 80195b4:	0802fba0 	.word	0x0802fba0
 80195b8:	0802fba4 	.word	0x0802fba4

080195bc <PemToDer>:

/* Remove PEM header/footer, convert to ASN1, store any encrypted data
   info->consumed tracks of PEM bytes consumed in case multiple parts */
int PemToDer(const unsigned char* buff, long longSz, int type,
              DerBuffer** pDer, void* heap, EncryptedInfo* info, int* keyFormat)
{
 80195bc:	b590      	push	{r4, r7, lr}
 80195be:	b0c3      	sub	sp, #268	@ 0x10c
 80195c0:	af02      	add	r7, sp, #8
 80195c2:	60f8      	str	r0, [r7, #12]
 80195c4:	60b9      	str	r1, [r7, #8]
 80195c6:	607a      	str	r2, [r7, #4]
 80195c8:	f507 7280 	add.w	r2, r7, #256	@ 0x100
 80195cc:	f5a2 7280 	sub.w	r2, r2, #256	@ 0x100
 80195d0:	6013      	str	r3, [r2, #0]
    const char* header      = NULL;
 80195d2:	2300      	movs	r3, #0
 80195d4:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
    const char* footer      = NULL;
 80195d8:	2300      	movs	r3, #0
 80195da:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
    const char* headerEnd   = NULL;
 80195de:	2300      	movs	r3, #0
 80195e0:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    const char* footerEnd   = NULL;
 80195e4:	2300      	movs	r3, #0
 80195e6:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
    const char* consumedEnd = NULL;
 80195ea:	2300      	movs	r3, #0
 80195ec:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
    const char* bufferEnd   = (const char*)(buff + longSz);
 80195f0:	68bb      	ldr	r3, [r7, #8]
 80195f2:	68fa      	ldr	r2, [r7, #12]
 80195f4:	4413      	add	r3, r2
 80195f6:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    long        neededSz;
    int         ret         = 0;
 80195fa:	2300      	movs	r3, #0
 80195fc:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
    word32      sz          = (word32)longSz;
 8019600:	68bb      	ldr	r3, [r7, #8]
 8019602:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    int         encrypted_key = 0;
 8019606:	2300      	movs	r3, #0
 8019608:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    DerBuffer*  der;
    word32      algId = 0;
 801960c:	2300      	movs	r3, #0
 801960e:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
#endif

    WOLFSSL_ENTER("PemToDer");

    /* get PEM header and footer based on type */
    ret = wc_PemGetHeaderFooter(type, &header, &footer);
 8019612:	f107 02c0 	add.w	r2, r7, #192	@ 0xc0
 8019616:	f107 03c4 	add.w	r3, r7, #196	@ 0xc4
 801961a:	4619      	mov	r1, r3
 801961c:	6878      	ldr	r0, [r7, #4]
 801961e:	f7ff fd01 	bl	8019024 <wc_PemGetHeaderFooter>
 8019622:	f8c7 00f8 	str.w	r0, [r7, #248]	@ 0xf8
    if (ret != 0)
 8019626:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 801962a:	2b00      	cmp	r3, #0
 801962c:	d002      	beq.n	8019634 <PemToDer+0x78>
        return ret;
 801962e:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8019632:	e36c      	b.n	8019d0e <PemToDer+0x752>

    /* map header if not found for type */
    for (;;) {
        headerEnd = XSTRNSTR((char*)buff, header, sz);
 8019634:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8019638:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 801963c:	4619      	mov	r1, r3
 801963e:	68f8      	ldr	r0, [r7, #12]
 8019640:	f00d fec8 	bl	80273d4 <mystrnstr>
 8019644:	4603      	mov	r3, r0
 8019646:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
        if (headerEnd) {
 801964a:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 801964e:	2b00      	cmp	r3, #0
 8019650:	d150      	bne.n	80196f4 <PemToDer+0x138>
            break;
        }

        if (type == PRIVATEKEY_TYPE
 8019652:	687b      	ldr	r3, [r7, #4]
 8019654:	2b01      	cmp	r3, #1
 8019656:	d12f      	bne.n	80196b8 <PemToDer+0xfc>
#ifdef WOLFSSL_DUAL_ALG_CERTS
            || type == ALT_PRIVATEKEY_TYPE
#endif
           ) {
            if (header == BEGIN_RSA_PRIV) {
 8019658:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 801965c:	4aa1      	ldr	r2, [pc, #644]	@ (80198e4 <PemToDer+0x328>)
 801965e:	4293      	cmp	r3, r2
 8019660:	d106      	bne.n	8019670 <PemToDer+0xb4>
                header = BEGIN_PRIV_KEY;
 8019662:	4ba1      	ldr	r3, [pc, #644]	@ (80198e8 <PemToDer+0x32c>)
 8019664:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
                footer = END_PRIV_KEY;
 8019668:	4ba0      	ldr	r3, [pc, #640]	@ (80198ec <PemToDer+0x330>)
 801966a:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 801966e:	e7e1      	b.n	8019634 <PemToDer+0x78>
            }
            else if (header == BEGIN_PRIV_KEY) {
 8019670:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8019674:	4a9c      	ldr	r2, [pc, #624]	@ (80198e8 <PemToDer+0x32c>)
 8019676:	4293      	cmp	r3, r2
 8019678:	d106      	bne.n	8019688 <PemToDer+0xcc>
                header = BEGIN_ENC_PRIV_KEY;
 801967a:	4b9d      	ldr	r3, [pc, #628]	@ (80198f0 <PemToDer+0x334>)
 801967c:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
                footer = END_ENC_PRIV_KEY;
 8019680:	4b9c      	ldr	r3, [pc, #624]	@ (80198f4 <PemToDer+0x338>)
 8019682:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 8019686:	e7d5      	b.n	8019634 <PemToDer+0x78>
            }
#ifdef HAVE_ECC
            else if (header == BEGIN_ENC_PRIV_KEY) {
 8019688:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 801968c:	4a98      	ldr	r2, [pc, #608]	@ (80198f0 <PemToDer+0x334>)
 801968e:	4293      	cmp	r3, r2
 8019690:	d106      	bne.n	80196a0 <PemToDer+0xe4>
                header = BEGIN_EC_PRIV;
 8019692:	4b99      	ldr	r3, [pc, #612]	@ (80198f8 <PemToDer+0x33c>)
 8019694:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
                footer = END_EC_PRIV;
 8019698:	4b98      	ldr	r3, [pc, #608]	@ (80198fc <PemToDer+0x340>)
 801969a:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 801969e:	e7c9      	b.n	8019634 <PemToDer+0x78>
            }
            else if (header == BEGIN_EC_PRIV) {
 80196a0:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80196a4:	4a94      	ldr	r2, [pc, #592]	@ (80198f8 <PemToDer+0x33c>)
 80196a6:	4293      	cmp	r3, r2
 80196a8:	d126      	bne.n	80196f8 <PemToDer+0x13c>
                header = BEGIN_DSA_PRIV;
 80196aa:	4b95      	ldr	r3, [pc, #596]	@ (8019900 <PemToDer+0x344>)
 80196ac:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
                footer = END_DSA_PRIV;
 80196b0:	4b94      	ldr	r3, [pc, #592]	@ (8019904 <PemToDer+0x348>)
 80196b2:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 80196b6:	e7bd      	b.n	8019634 <PemToDer+0x78>
            #else
                break;
            #endif
            }
        }
        else if (type == PUBLICKEY_TYPE) {
 80196b8:	687b      	ldr	r3, [r7, #4]
 80196ba:	2b0e      	cmp	r3, #14
 80196bc:	d10b      	bne.n	80196d6 <PemToDer+0x11a>
            if (header == BEGIN_PUB_KEY) {
 80196be:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80196c2:	4a91      	ldr	r2, [pc, #580]	@ (8019908 <PemToDer+0x34c>)
 80196c4:	4293      	cmp	r3, r2
 80196c6:	d119      	bne.n	80196fc <PemToDer+0x140>
                header = BEGIN_RSA_PUB;
 80196c8:	4b90      	ldr	r3, [pc, #576]	@ (801990c <PemToDer+0x350>)
 80196ca:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
                footer = END_RSA_PUB;
 80196ce:	4b90      	ldr	r3, [pc, #576]	@ (8019910 <PemToDer+0x354>)
 80196d0:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 80196d4:	e7ae      	b.n	8019634 <PemToDer+0x78>
            else {
                break;
            }
        }
#if defined(HAVE_ECC) && defined(OPENSSL_EXTRA)
        else if (type == ECC_PARAM_TYPE) {
 80196d6:	687b      	ldr	r3, [r7, #4]
 80196d8:	2b29      	cmp	r3, #41	@ 0x29
 80196da:	d111      	bne.n	8019700 <PemToDer+0x144>
            if (header == BEGIN_EC_PARAM) {
 80196dc:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80196e0:	4a8c      	ldr	r2, [pc, #560]	@ (8019914 <PemToDer+0x358>)
 80196e2:	4293      	cmp	r3, r2
 80196e4:	d10e      	bne.n	8019704 <PemToDer+0x148>
                header = BEGIN_EC_PARAM;
 80196e6:	4b8b      	ldr	r3, [pc, #556]	@ (8019914 <PemToDer+0x358>)
 80196e8:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
                footer = END_EC_PARAM;
 80196ec:	4b8a      	ldr	r3, [pc, #552]	@ (8019918 <PemToDer+0x35c>)
 80196ee:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
        headerEnd = XSTRNSTR((char*)buff, header, sz);
 80196f2:	e79f      	b.n	8019634 <PemToDer+0x78>
            break;
 80196f4:	bf00      	nop
 80196f6:	e006      	b.n	8019706 <PemToDer+0x14a>
                break;
 80196f8:	bf00      	nop
 80196fa:	e004      	b.n	8019706 <PemToDer+0x14a>
                break;
 80196fc:	bf00      	nop
 80196fe:	e002      	b.n	8019706 <PemToDer+0x14a>
            header =  BEGIN_X509_CRL;
            footer = END_X509_CRL;
        }
#endif
        else {
            break;
 8019700:	bf00      	nop
 8019702:	e000      	b.n	8019706 <PemToDer+0x14a>
                break;
 8019704:	bf00      	nop
        }
    }

    if (!headerEnd) {
 8019706:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 801970a:	2b00      	cmp	r3, #0
 801970c:	f040 8110 	bne.w	8019930 <PemToDer+0x374>
#ifdef OPENSSL_EXTRA
        if (type == PRIVATEKEY_TYPE
 8019710:	687b      	ldr	r3, [r7, #4]
 8019712:	2b01      	cmp	r3, #1
 8019714:	f040 80d4 	bne.w	80198c0 <PemToDer+0x304>
#ifdef WOLFSSL_DUAL_ALG_CERTS
            || type == ALT_PRIVATEKEY_TYPE
#endif
           ) {
            /* see if there is a -----BEGIN * PRIVATE KEY----- header */
            headerEnd = XSTRNSTR((char*)buff, PRIV_KEY_SUFFIX, sz);
 8019718:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 801971c:	497f      	ldr	r1, [pc, #508]	@ (801991c <PemToDer+0x360>)
 801971e:	68f8      	ldr	r0, [r7, #12]
 8019720:	f00d fe58 	bl	80273d4 <mystrnstr>
 8019724:	4603      	mov	r3, r0
 8019726:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
            if (headerEnd) {
 801972a:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 801972e:	2b00      	cmp	r3, #0
 8019730:	f000 80c6 	beq.w	80198c0 <PemToDer+0x304>
                const char* beginEnd;
                unsigned int endLen;

                beginEnd = headerEnd + XSTR_SIZEOF(PRIV_KEY_SUFFIX);
 8019734:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8019738:	3310      	adds	r3, #16
 801973a:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
                if (beginEnd >= (char*)buff + sz) {
 801973e:	68fa      	ldr	r2, [r7, #12]
 8019740:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 8019744:	4413      	add	r3, r2
 8019746:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 801974a:	429a      	cmp	r2, r3
 801974c:	d307      	bcc.n	801975e <PemToDer+0x1a2>
                    return BUFFER_E;
 801974e:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8019752:	e2dc      	b.n	8019d0e <PemToDer+0x752>
                /* back up to BEGIN_PRIV_KEY_PREFIX */
                while (headerEnd > (char*)buff &&
                        XSTRNCMP(headerEnd, BEGIN_PRIV_KEY_PREFIX,
                                XSTR_SIZEOF(BEGIN_PRIV_KEY_PREFIX)) != 0 &&
                        *headerEnd != '\n') {
                    headerEnd--;
 8019754:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8019758:	3b01      	subs	r3, #1
 801975a:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
                while (headerEnd > (char*)buff &&
 801975e:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
                                XSTR_SIZEOF(BEGIN_PRIV_KEY_PREFIX)) != 0 &&
 8019762:	68fa      	ldr	r2, [r7, #12]
 8019764:	429a      	cmp	r2, r3
 8019766:	d20e      	bcs.n	8019786 <PemToDer+0x1ca>
                        XSTRNCMP(headerEnd, BEGIN_PRIV_KEY_PREFIX,
 8019768:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 801976c:	220a      	movs	r2, #10
 801976e:	496c      	ldr	r1, [pc, #432]	@ (8019920 <PemToDer+0x364>)
 8019770:	4618      	mov	r0, r3
 8019772:	f00e feb1 	bl	80284d8 <strncmp>
 8019776:	4603      	mov	r3, r0
                while (headerEnd > (char*)buff &&
 8019778:	2b00      	cmp	r3, #0
 801977a:	d004      	beq.n	8019786 <PemToDer+0x1ca>
                        *headerEnd != '\n') {
 801977c:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8019780:	781b      	ldrb	r3, [r3, #0]
                                XSTR_SIZEOF(BEGIN_PRIV_KEY_PREFIX)) != 0 &&
 8019782:	2b0a      	cmp	r3, #10
 8019784:	d1e6      	bne.n	8019754 <PemToDer+0x198>
                }
                if (headerEnd <= (char*)buff ||
 8019786:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 801978a:	68fa      	ldr	r2, [r7, #12]
 801978c:	429a      	cmp	r2, r3
 801978e:	d210      	bcs.n	80197b2 <PemToDer+0x1f6>
                        XSTRNCMP(headerEnd, BEGIN_PRIV_KEY_PREFIX,
 8019790:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8019794:	220a      	movs	r2, #10
 8019796:	4962      	ldr	r1, [pc, #392]	@ (8019920 <PemToDer+0x364>)
 8019798:	4618      	mov	r0, r3
 801979a:	f00e fe9d 	bl	80284d8 <strncmp>
 801979e:	4603      	mov	r3, r0
                if (headerEnd <= (char*)buff ||
 80197a0:	2b00      	cmp	r3, #0
 80197a2:	d106      	bne.n	80197b2 <PemToDer+0x1f6>
                        XSTR_SIZEOF(BEGIN_PRIV_KEY_PREFIX)) != 0 ||
                        beginEnd - headerEnd > PEM_LINE_LEN) {
 80197a4:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 80197a8:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 80197ac:	1ad3      	subs	r3, r2, r3
                        XSTR_SIZEOF(BEGIN_PRIV_KEY_PREFIX)) != 0 ||
 80197ae:	2b4c      	cmp	r3, #76	@ 0x4c
 80197b0:	dd0c      	ble.n	80197cc <PemToDer+0x210>
                    WOLFSSL_MSG("Couldn't find PEM header");
                    WOLFSSL_ERROR(ASN_NO_PEM_HEADER);
 80197b2:	2300      	movs	r3, #0
 80197b4:	9300      	str	r3, [sp, #0]
 80197b6:	4b5b      	ldr	r3, [pc, #364]	@ (8019924 <PemToDer+0x368>)
 80197b8:	f246 32f1 	movw	r2, #25585	@ 0x63f1
 80197bc:	495a      	ldr	r1, [pc, #360]	@ (8019928 <PemToDer+0x36c>)
 80197be:	f06f 00a1 	mvn.w	r0, #161	@ 0xa1
 80197c2:	f005 f915 	bl	801e9f0 <WOLFSSL_ERROR_LINE>
                    return ASN_NO_PEM_HEADER;
 80197c6:	f06f 03a1 	mvn.w	r3, #161	@ 0xa1
 80197ca:	e2a0      	b.n	8019d0e <PemToDer+0x752>
                }

                /* headerEnd now points to beginning of header */
                XMEMCPY(beginBuf, headerEnd, (size_t)(beginEnd - headerEnd));
 80197cc:	f8d7 10bc 	ldr.w	r1, [r7, #188]	@ 0xbc
 80197d0:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 80197d4:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 80197d8:	1ad3      	subs	r3, r2, r3
 80197da:	461a      	mov	r2, r3
 80197dc:	f107 0364 	add.w	r3, r7, #100	@ 0x64
 80197e0:	4618      	mov	r0, r3
 80197e2:	f00e fedb 	bl	802859c <memcpy>
                beginBuf[beginEnd - headerEnd] = '\0';
 80197e6:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 80197ea:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 80197ee:	1ad3      	subs	r3, r2, r3
 80197f0:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80197f4:	443b      	add	r3, r7
 80197f6:	2200      	movs	r2, #0
 80197f8:	f803 2c9c 	strb.w	r2, [r3, #-156]
                /* look for matching footer */
                footer = XSTRNSTR(beginEnd,
 80197fc:	f107 0364 	add.w	r3, r7, #100	@ 0x64
 8019800:	330a      	adds	r3, #10
 8019802:	68f9      	ldr	r1, [r7, #12]
 8019804:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 8019808:	4411      	add	r1, r2
 801980a:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 801980e:	1a8a      	subs	r2, r1, r2
 8019810:	4619      	mov	r1, r3
 8019812:	f8d7 00e4 	ldr.w	r0, [r7, #228]	@ 0xe4
 8019816:	f00d fddd 	bl	80273d4 <mystrnstr>
 801981a:	4603      	mov	r3, r0
 801981c:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
                                beginBuf + XSTR_SIZEOF(BEGIN_PRIV_KEY_PREFIX),
                                (unsigned int)((char*)buff + sz - beginEnd));
                if (!footer) {
 8019820:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8019824:	2b00      	cmp	r3, #0
 8019826:	d10c      	bne.n	8019842 <PemToDer+0x286>
                    WOLFSSL_MSG("Couldn't find PEM footer");
                    WOLFSSL_ERROR(ASN_NO_PEM_HEADER);
 8019828:	2300      	movs	r3, #0
 801982a:	9300      	str	r3, [sp, #0]
 801982c:	4b3d      	ldr	r3, [pc, #244]	@ (8019924 <PemToDer+0x368>)
 801982e:	f246 32fe 	movw	r2, #25598	@ 0x63fe
 8019832:	493d      	ldr	r1, [pc, #244]	@ (8019928 <PemToDer+0x36c>)
 8019834:	f06f 00a1 	mvn.w	r0, #161	@ 0xa1
 8019838:	f005 f8da 	bl	801e9f0 <WOLFSSL_ERROR_LINE>
                    return ASN_NO_PEM_HEADER;
 801983c:	f06f 03a1 	mvn.w	r3, #161	@ 0xa1
 8019840:	e265      	b.n	8019d0e <PemToDer+0x752>
                }

                footer -= XSTR_SIZEOF(END_PRIV_KEY_PREFIX);
 8019842:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8019846:	3b08      	subs	r3, #8
 8019848:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
                if (footer > (char*)buff + sz - XSTR_SIZEOF(END_PRIV_KEY_PREFIX)
 801984c:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 8019850:	3b08      	subs	r3, #8
 8019852:	68fa      	ldr	r2, [r7, #12]
 8019854:	441a      	add	r2, r3
 8019856:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 801985a:	429a      	cmp	r2, r3
 801985c:	d309      	bcc.n	8019872 <PemToDer+0x2b6>
                        || XSTRNCMP(footer, END_PRIV_KEY_PREFIX,
 801985e:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8019862:	2208      	movs	r2, #8
 8019864:	4931      	ldr	r1, [pc, #196]	@ (801992c <PemToDer+0x370>)
 8019866:	4618      	mov	r0, r3
 8019868:	f00e fe36 	bl	80284d8 <strncmp>
 801986c:	4603      	mov	r3, r0
 801986e:	2b00      	cmp	r3, #0
 8019870:	d002      	beq.n	8019878 <PemToDer+0x2bc>
                            XSTR_SIZEOF(END_PRIV_KEY_PREFIX)) != 0) {
                    WOLFSSL_MSG("Unexpected footer for PEM");
                    return BUFFER_E;
 8019872:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8019876:	e24a      	b.n	8019d0e <PemToDer+0x752>
                }

                endLen = (unsigned int)((size_t)(beginEnd - headerEnd) -
 8019878:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 801987c:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 8019880:	1ad3      	subs	r3, r2, r3
 8019882:	3b02      	subs	r3, #2
 8019884:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
                            (XSTR_SIZEOF(BEGIN_PRIV_KEY_PREFIX) -
                                    XSTR_SIZEOF(END_PRIV_KEY_PREFIX)));
                XMEMCPY(endBuf, footer, (size_t)endLen);
 8019888:	f8d7 10c0 	ldr.w	r1, [r7, #192]	@ 0xc0
 801988c:	f107 0314 	add.w	r3, r7, #20
 8019890:	f8d7 20e0 	ldr.w	r2, [r7, #224]	@ 0xe0
 8019894:	4618      	mov	r0, r3
 8019896:	f00e fe81 	bl	802859c <memcpy>
                endBuf[endLen] = '\0';
 801989a:	f107 0214 	add.w	r2, r7, #20
 801989e:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 80198a2:	4413      	add	r3, r2
 80198a4:	2200      	movs	r2, #0
 80198a6:	701a      	strb	r2, [r3, #0]

                header = beginBuf;
 80198a8:	f107 0364 	add.w	r3, r7, #100	@ 0x64
 80198ac:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
                footer = endBuf;
 80198b0:	f107 0314 	add.w	r3, r7, #20
 80198b4:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
                headerEnd = beginEnd;
 80198b8:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 80198bc:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
            }
        }

        if (!headerEnd) {
 80198c0:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 80198c4:	2b00      	cmp	r3, #0
 80198c6:	d13e      	bne.n	8019946 <PemToDer+0x38a>
            WOLFSSL_MSG("Couldn't find PEM header");
            WOLFSSL_ERROR(ASN_NO_PEM_HEADER);
 80198c8:	2300      	movs	r3, #0
 80198ca:	9300      	str	r3, [sp, #0]
 80198cc:	4b15      	ldr	r3, [pc, #84]	@ (8019924 <PemToDer+0x368>)
 80198ce:	f246 4218 	movw	r2, #25624	@ 0x6418
 80198d2:	4915      	ldr	r1, [pc, #84]	@ (8019928 <PemToDer+0x36c>)
 80198d4:	f06f 00a1 	mvn.w	r0, #161	@ 0xa1
 80198d8:	f005 f88a 	bl	801e9f0 <WOLFSSL_ERROR_LINE>
            return ASN_NO_PEM_HEADER;
 80198dc:	f06f 03a1 	mvn.w	r3, #161	@ 0xa1
 80198e0:	e215      	b.n	8019d0e <PemToDer+0x752>
 80198e2:	bf00      	nop
 80198e4:	0802f968 	.word	0x0802f968
 80198e8:	0802f9e8 	.word	0x0802f9e8
 80198ec:	0802fa04 	.word	0x0802fa04
 80198f0:	0802fa20 	.word	0x0802fa20
 80198f4:	0802fa48 	.word	0x0802fa48
 80198f8:	0802fa6c 	.word	0x0802fa6c
 80198fc:	0802fa8c 	.word	0x0802fa8c
 8019900:	0802fae8 	.word	0x0802fae8
 8019904:	0802fb08 	.word	0x0802fb08
 8019908:	0802fb28 	.word	0x0802fb28
 801990c:	0802f9a8 	.word	0x0802f9a8
 8019910:	0802f9c8 	.word	0x0802f9c8
 8019914:	0802faac 	.word	0x0802faac
 8019918:	0802facc 	.word	0x0802facc
 801991c:	08033a30 	.word	0x08033a30
 8019920:	08033a24 	.word	0x08033a24
 8019924:	0802fbc0 	.word	0x0802fbc0
 8019928:	08033a7c 	.word	0x08033a7c
 801992c:	08033a44 	.word	0x08033a44
#else
        WOLFSSL_MSG("Couldn't find PEM header");
        return ASN_NO_PEM_HEADER;
#endif
    } else {
        headerEnd += XSTRLEN(header);
 8019930:	f8d7 40bc 	ldr.w	r4, [r7, #188]	@ 0xbc
 8019934:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8019938:	4618      	mov	r0, r3
 801993a:	f7e6 fc53 	bl	80001e4 <strlen>
 801993e:	4603      	mov	r3, r0
 8019940:	4423      	add	r3, r4
 8019942:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    }

    /* eat end of line characters */
    headerEnd = SkipEndOfLineChars(headerEnd, bufferEnd);
 8019946:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 801994a:	f8d7 10ec 	ldr.w	r1, [r7, #236]	@ 0xec
 801994e:	4618      	mov	r0, r3
 8019950:	f7ff fb4b 	bl	8018fea <SkipEndOfLineChars>
 8019954:	4603      	mov	r3, r0
 8019956:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc

    if (keyFormat) {
 801995a:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 801995e:	2b00      	cmp	r3, #0
 8019960:	d016      	beq.n	8019990 <PemToDer+0x3d4>
        /* keyFormat is Key_Sum enum */
        if (type == PRIVATEKEY_TYPE
 8019962:	687b      	ldr	r3, [r7, #4]
 8019964:	2b01      	cmp	r3, #1
 8019966:	d113      	bne.n	8019990 <PemToDer+0x3d4>
        #ifdef WOLFSSL_DUAL_ALG_CERTS
            || type == ALT_PRIVATEKEY_TYPE
        #endif
           ) {
        #ifndef NO_RSA
            if (header == BEGIN_RSA_PRIV)
 8019968:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 801996c:	4aaf      	ldr	r2, [pc, #700]	@ (8019c2c <PemToDer+0x670>)
 801996e:	4293      	cmp	r3, r2
 8019970:	d104      	bne.n	801997c <PemToDer+0x3c0>
                *keyFormat = RSAk;
 8019972:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8019976:	f240 2285 	movw	r2, #645	@ 0x285
 801997a:	601a      	str	r2, [r3, #0]
        #endif
        #ifdef HAVE_ECC
            if (header == BEGIN_EC_PRIV)
 801997c:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8019980:	4aab      	ldr	r2, [pc, #684]	@ (8019c30 <PemToDer+0x674>)
 8019982:	4293      	cmp	r3, r2
 8019984:	d104      	bne.n	8019990 <PemToDer+0x3d4>
                *keyFormat = ECDSAk;
 8019986:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 801998a:	f240 2206 	movw	r2, #518	@ 0x206
 801998e:	601a      	str	r2, [r3, #0]
        }
    #endif
    }

#ifdef WOLFSSL_ENCRYPTED_KEYS
    if (info) {
 8019990:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8019994:	2b00      	cmp	r3, #0
 8019996:	d021      	beq.n	80199dc <PemToDer+0x420>
        ret = wc_EncryptedInfoParse(info, &headerEnd,
                                    (size_t)(bufferEnd - headerEnd));
 8019998:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 801999c:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 80199a0:	1ad3      	subs	r3, r2, r3
        ret = wc_EncryptedInfoParse(info, &headerEnd,
 80199a2:	461a      	mov	r2, r3
 80199a4:	f107 03bc 	add.w	r3, r7, #188	@ 0xbc
 80199a8:	4619      	mov	r1, r3
 80199aa:	f8d7 0114 	ldr.w	r0, [r7, #276]	@ 0x114
 80199ae:	f7ff fcdb 	bl	8019368 <wc_EncryptedInfoParse>
 80199b2:	f8c7 00f8 	str.w	r0, [r7, #248]	@ 0xf8
        if (ret < 0)
 80199b6:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 80199ba:	2b00      	cmp	r3, #0
 80199bc:	da02      	bge.n	80199c4 <PemToDer+0x408>
            return ret;
 80199be:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 80199c2:	e1a4      	b.n	8019d0e <PemToDer+0x752>
        if (info->set)
 80199c4:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80199c8:	f893 3088 	ldrb.w	r3, [r3, #136]	@ 0x88
 80199cc:	f003 0301 	and.w	r3, r3, #1
 80199d0:	b2db      	uxtb	r3, r3
 80199d2:	2b00      	cmp	r3, #0
 80199d4:	d002      	beq.n	80199dc <PemToDer+0x420>
            encrypted_key = 1;
 80199d6:	2301      	movs	r3, #1
 80199d8:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    }
#endif /* WOLFSSL_ENCRYPTED_KEYS */

    /* find footer */
    footerEnd = XSTRNSTR(headerEnd, footer, (unsigned int)((char*)buff +
 80199dc:	f8d7 00bc 	ldr.w	r0, [r7, #188]	@ 0xbc
 80199e0:	f8d7 10c0 	ldr.w	r1, [r7, #192]	@ 0xc0
 80199e4:	68fa      	ldr	r2, [r7, #12]
 80199e6:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 80199ea:	441a      	add	r2, r3
 80199ec:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 80199f0:	1ad3      	subs	r3, r2, r3
 80199f2:	461a      	mov	r2, r3
 80199f4:	f00d fcee 	bl	80273d4 <mystrnstr>
 80199f8:	f8c7 00f0 	str.w	r0, [r7, #240]	@ 0xf0
        sz - headerEnd));
    if (!footerEnd) {
 80199fc:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 8019a00:	2b00      	cmp	r3, #0
 8019a02:	d10a      	bne.n	8019a1a <PemToDer+0x45e>
        if (info)
 8019a04:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8019a08:	2b00      	cmp	r3, #0
 8019a0a:	d003      	beq.n	8019a14 <PemToDer+0x458>
            info->consumed = longSz; /* No more certs if no footer */
 8019a0c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8019a10:	68ba      	ldr	r2, [r7, #8]
 8019a12:	601a      	str	r2, [r3, #0]
        return BUFFER_E;
 8019a14:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8019a18:	e179      	b.n	8019d0e <PemToDer+0x752>
    }

    consumedEnd = footerEnd + XSTRLEN(footer);
 8019a1a:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8019a1e:	4618      	mov	r0, r3
 8019a20:	f7e6 fbe0 	bl	80001e4 <strlen>
 8019a24:	4602      	mov	r2, r0
 8019a26:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 8019a2a:	4413      	add	r3, r2
 8019a2c:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc

    if (consumedEnd < bufferEnd) { /* handle no end of line on last line */
 8019a30:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 8019a34:	f8d7 30ec 	ldr.w	r3, [r7, #236]	@ 0xec
 8019a38:	429a      	cmp	r2, r3
 8019a3a:	d217      	bcs.n	8019a6c <PemToDer+0x4b0>
        /* eat end of line characters */
        consumedEnd = SkipEndOfLineChars(consumedEnd, bufferEnd);
 8019a3c:	f8d7 10ec 	ldr.w	r1, [r7, #236]	@ 0xec
 8019a40:	f8d7 00fc 	ldr.w	r0, [r7, #252]	@ 0xfc
 8019a44:	f7ff fad1 	bl	8018fea <SkipEndOfLineChars>
 8019a48:	f8c7 00fc 	str.w	r0, [r7, #252]	@ 0xfc
        /* skip possible null term */
        if (consumedEnd < bufferEnd && consumedEnd[0] == '\0')
 8019a4c:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 8019a50:	f8d7 30ec 	ldr.w	r3, [r7, #236]	@ 0xec
 8019a54:	429a      	cmp	r2, r3
 8019a56:	d209      	bcs.n	8019a6c <PemToDer+0x4b0>
 8019a58:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 8019a5c:	781b      	ldrb	r3, [r3, #0]
 8019a5e:	2b00      	cmp	r3, #0
 8019a60:	d104      	bne.n	8019a6c <PemToDer+0x4b0>
            consumedEnd++;
 8019a62:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 8019a66:	3301      	adds	r3, #1
 8019a68:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
    }

    if (info)
 8019a6c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8019a70:	2b00      	cmp	r3, #0
 8019a72:	d006      	beq.n	8019a82 <PemToDer+0x4c6>
        info->consumed = (long)(consumedEnd - (const char*)buff);
 8019a74:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 8019a78:	68fb      	ldr	r3, [r7, #12]
 8019a7a:	1ad2      	subs	r2, r2, r3
 8019a7c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8019a80:	601a      	str	r2, [r3, #0]

    /* set up der buffer */
    neededSz = (long)(footerEnd - headerEnd);
 8019a82:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8019a86:	f8d7 20f0 	ldr.w	r2, [r7, #240]	@ 0xf0
 8019a8a:	1ad3      	subs	r3, r2, r3
 8019a8c:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    if (neededSz > (long)sz || neededSz <= 0)
 8019a90:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 8019a94:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 8019a98:	429a      	cmp	r2, r3
 8019a9a:	dc03      	bgt.n	8019aa4 <PemToDer+0x4e8>
 8019a9c:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 8019aa0:	2b00      	cmp	r3, #0
 8019aa2:	dc02      	bgt.n	8019aaa <PemToDer+0x4ee>
        return BUFFER_E;
 8019aa4:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8019aa8:	e131      	b.n	8019d0e <PemToDer+0x752>

    ret = AllocDer(pDer, (word32)neededSz, type, heap);
 8019aaa:	f8d7 10dc 	ldr.w	r1, [r7, #220]	@ 0xdc
 8019aae:	f507 7380 	add.w	r3, r7, #256	@ 0x100
 8019ab2:	f5a3 7080 	sub.w	r0, r3, #256	@ 0x100
 8019ab6:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8019aba:	687a      	ldr	r2, [r7, #4]
 8019abc:	6800      	ldr	r0, [r0, #0]
 8019abe:	f7ff f987 	bl	8018dd0 <AllocDer>
 8019ac2:	f8c7 00f8 	str.w	r0, [r7, #248]	@ 0xf8
    if (ret < 0) {
 8019ac6:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8019aca:	2b00      	cmp	r3, #0
 8019acc:	da02      	bge.n	8019ad4 <PemToDer+0x518>
        return ret;
 8019ace:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8019ad2:	e11c      	b.n	8019d0e <PemToDer+0x752>
    }
    der = *pDer;
 8019ad4:	f507 7380 	add.w	r3, r7, #256	@ 0x100
 8019ad8:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 8019adc:	681b      	ldr	r3, [r3, #0]
 8019ade:	681b      	ldr	r3, [r3, #0]
 8019ae0:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8

    if (Base64_Decode((byte*)headerEnd, (word32)neededSz,
 8019ae4:	f8d7 00bc 	ldr.w	r0, [r7, #188]	@ 0xbc
 8019ae8:	f8d7 10dc 	ldr.w	r1, [r7, #220]	@ 0xdc
 8019aec:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8019af0:	681a      	ldr	r2, [r3, #0]
 8019af2:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8019af6:	3308      	adds	r3, #8
 8019af8:	f000 fc14 	bl	801a324 <Base64_Decode>
 8019afc:	4603      	mov	r3, r0
 8019afe:	2b00      	cmp	r3, #0
 8019b00:	da0c      	bge.n	8019b1c <PemToDer+0x560>
                      der->buffer, &der->length) < 0) {
        WOLFSSL_ERROR(BUFFER_E);
 8019b02:	2300      	movs	r3, #0
 8019b04:	9300      	str	r3, [sp, #0]
 8019b06:	4b4b      	ldr	r3, [pc, #300]	@ (8019c34 <PemToDer+0x678>)
 8019b08:	f246 4272 	movw	r2, #25714	@ 0x6472
 8019b0c:	494a      	ldr	r1, [pc, #296]	@ (8019c38 <PemToDer+0x67c>)
 8019b0e:	f06f 0083 	mvn.w	r0, #131	@ 0x83
 8019b12:	f004 ff6d 	bl	801e9f0 <WOLFSSL_ERROR_LINE>
        return BUFFER_E;
 8019b16:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8019b1a:	e0f8      	b.n	8019d0e <PemToDer+0x752>
    }

    if ((header == BEGIN_PRIV_KEY
 8019b1c:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8019b20:	4a46      	ldr	r2, [pc, #280]	@ (8019c3c <PemToDer+0x680>)
 8019b22:	4293      	cmp	r3, r2
 8019b24:	d00a      	beq.n	8019b3c <PemToDer+0x580>
#ifdef OPENSSL_EXTRA
         || header == beginBuf
 8019b26:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 8019b2a:	f107 0364 	add.w	r3, r7, #100	@ 0x64
 8019b2e:	429a      	cmp	r2, r3
 8019b30:	d004      	beq.n	8019b3c <PemToDer+0x580>
#endif
#ifdef HAVE_ECC
         || header == BEGIN_EC_PRIV
 8019b32:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8019b36:	4a3e      	ldr	r2, [pc, #248]	@ (8019c30 <PemToDer+0x674>)
 8019b38:	4293      	cmp	r3, r2
 8019b3a:	d124      	bne.n	8019b86 <PemToDer+0x5ca>
#endif
        ) && !encrypted_key)
 8019b3c:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8019b40:	2b00      	cmp	r3, #0
 8019b42:	d120      	bne.n	8019b86 <PemToDer+0x5ca>
    {
        /* detect pkcs8 key and get alg type */
        /* keep PKCS8 header */
        idx = 0;
 8019b44:	2300      	movs	r3, #0
 8019b46:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
        ret = ToTraditionalInline_ex(der->buffer, &idx, der->length, &algId);
 8019b4a:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8019b4e:	6818      	ldr	r0, [r3, #0]
 8019b50:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8019b54:	689a      	ldr	r2, [r3, #8]
 8019b56:	f107 03b8 	add.w	r3, r7, #184	@ 0xb8
 8019b5a:	f107 01b4 	add.w	r1, r7, #180	@ 0xb4
 8019b5e:	f7fb f991 	bl	8014e84 <ToTraditionalInline_ex>
 8019b62:	f8c7 00f8 	str.w	r0, [r7, #248]	@ 0xf8
        if (ret > 0) {
 8019b66:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8019b6a:	2b00      	cmp	r3, #0
 8019b6c:	dd09      	ble.n	8019b82 <PemToDer+0x5c6>
            if (keyFormat)
 8019b6e:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8019b72:	2b00      	cmp	r3, #0
 8019b74:	d005      	beq.n	8019b82 <PemToDer+0x5c6>
                *keyFormat = (int)algId;
 8019b76:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8019b7a:	461a      	mov	r2, r3
 8019b7c:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8019b80:	601a      	str	r2, [r3, #0]
        }
        else {
            /* ignore failure here and assume key is not pkcs8 wrapped */
        }
        return 0;
 8019b82:	2300      	movs	r3, #0
 8019b84:	e0c3      	b.n	8019d0e <PemToDer+0x752>
    }

#ifdef WOLFSSL_ENCRYPTED_KEYS
    if (encrypted_key || header == BEGIN_ENC_PRIV_KEY) {
 8019b86:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8019b8a:	2b00      	cmp	r3, #0
 8019b8c:	d105      	bne.n	8019b9a <PemToDer+0x5de>
 8019b8e:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8019b92:	4a2b      	ldr	r2, [pc, #172]	@ (8019c40 <PemToDer+0x684>)
 8019b94:	4293      	cmp	r3, r2
 8019b96:	f040 80b8 	bne.w	8019d0a <PemToDer+0x74e>
        int   passwordSz = NAME_SZ;
 8019b9a:	2350      	movs	r3, #80	@ 0x50
 8019b9c:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
    #ifdef WOLFSSL_SMALL_STACK
        char* password = NULL;
 8019ba0:	2300      	movs	r3, #0
 8019ba2:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
    #else
        char  password[NAME_SZ];
    #endif

        if (!info || !info->passwd_cb) {
 8019ba6:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8019baa:	2b00      	cmp	r3, #0
 8019bac:	d004      	beq.n	8019bb8 <PemToDer+0x5fc>
 8019bae:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8019bb2:	685b      	ldr	r3, [r3, #4]
 8019bb4:	2b00      	cmp	r3, #0
 8019bb6:	d102      	bne.n	8019bbe <PemToDer+0x602>
            WOLFSSL_MSG("No password callback set");
            WOLFSSL_ERROR_VERBOSE(NO_PASSWORD);
            return NO_PASSWORD;
 8019bb8:	f06f 03af 	mvn.w	r3, #175	@ 0xaf
 8019bbc:	e0a7      	b.n	8019d0e <PemToDer+0x752>
        }

    #ifdef WOLFSSL_SMALL_STACK
        password = (char*)XMALLOC(passwordSz, heap, DYNAMIC_TYPE_STRING);
 8019bbe:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8019bc2:	4618      	mov	r0, r3
 8019bc4:	f004 ff60 	bl	801ea88 <wolfSSL_Malloc>
 8019bc8:	f8c7 00d0 	str.w	r0, [r7, #208]	@ 0xd0
        if (password == NULL) {
 8019bcc:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8019bd0:	2b00      	cmp	r3, #0
 8019bd2:	d102      	bne.n	8019bda <PemToDer+0x61e>
            return MEMORY_E;
 8019bd4:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8019bd8:	e099      	b.n	8019d0e <PemToDer+0x752>
        }
    #endif

        /* get password */
        ret = info->passwd_cb(password, passwordSz, PEM_PASS_READ,
 8019bda:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8019bde:	685c      	ldr	r4, [r3, #4]
 8019be0:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8019be4:	689b      	ldr	r3, [r3, #8]
 8019be6:	2200      	movs	r2, #0
 8019be8:	f8d7 10d4 	ldr.w	r1, [r7, #212]	@ 0xd4
 8019bec:	f8d7 00d0 	ldr.w	r0, [r7, #208]	@ 0xd0
 8019bf0:	47a0      	blx	r4
 8019bf2:	f8c7 00f8 	str.w	r0, [r7, #248]	@ 0xf8
            info->passwd_userdata);
        if (ret >= 0) {
 8019bf6:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8019bfa:	2b00      	cmp	r3, #0
 8019bfc:	db6f      	blt.n	8019cde <PemToDer+0x722>
            passwordSz = ret;
 8019bfe:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8019c02:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
        #ifdef WOLFSSL_CHECK_MEM_ZERO
            wc_MemZero_Add("PEM password", password, passwordSz);
        #endif

            /* convert and adjust length */
            if (header == BEGIN_ENC_PRIV_KEY) {
 8019c06:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8019c0a:	4a0d      	ldr	r2, [pc, #52]	@ (8019c40 <PemToDer+0x684>)
 8019c0c:	4293      	cmp	r3, r2
 8019c0e:	d104      	bne.n	8019c1a <PemToDer+0x65e>
                        ret = 0;
                    }
                }
            #else
                WOLFSSL_ERROR_VERBOSE(NOT_COMPILED_IN);
                ret = NOT_COMPILED_IN;
 8019c10:	f06f 03ad 	mvn.w	r3, #173	@ 0xad
 8019c14:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
 8019c18:	e04c      	b.n	8019cb4 <PemToDer+0x6f8>
            #endif
            }
            /* decrypt the key */
            else {
                if (passwordSz == 0) {
 8019c1a:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8019c1e:	2b00      	cmp	r3, #0
 8019c20:	d110      	bne.n	8019c44 <PemToDer+0x688>
                    /* The key is encrypted but does not have a password */
                    WOLFSSL_MSG("No password for encrypted key");
                    WOLFSSL_ERROR_VERBOSE(NO_PASSWORD);
                    ret = NO_PASSWORD;
 8019c22:	f06f 03af 	mvn.w	r3, #175	@ 0xaf
 8019c26:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
 8019c2a:	e043      	b.n	8019cb4 <PemToDer+0x6f8>
 8019c2c:	0802f968 	.word	0x0802f968
 8019c30:	0802fa6c 	.word	0x0802fa6c
 8019c34:	0802fbc0 	.word	0x0802fbc0
 8019c38:	08033a7c 	.word	0x08033a7c
 8019c3c:	0802f9e8 	.word	0x0802f9e8
 8019c40:	0802fa20 	.word	0x0802fa20
                else {
                #if ((defined(WOLFSSL_ENCRYPTED_KEYS) && !defined(NO_DES3)) || \
                         (!defined(NO_AES) && defined(HAVE_AES_CBC) && \
                          defined(HAVE_AES_DECRYPT))) && \
                        !defined(NO_WOLFSSL_SKIP_TRAILING_PAD)
                    int     padVal = 0;
 8019c44:	2300      	movs	r3, #0
 8019c46:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
                #endif

                    ret = wc_BufferKeyDecrypt(info, der->buffer, der->length,
 8019c4a:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8019c4e:	6819      	ldr	r1, [r3, #0]
 8019c50:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8019c54:	689a      	ldr	r2, [r3, #8]
 8019c56:	2303      	movs	r3, #3
 8019c58:	9301      	str	r3, [sp, #4]
 8019c5a:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8019c5e:	9300      	str	r3, [sp, #0]
 8019c60:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8019c64:	f8d7 0114 	ldr.w	r0, [r7, #276]	@ 0x114
 8019c68:	f00d fa95 	bl	8027196 <wc_BufferKeyDecrypt>
 8019c6c:	f8c7 00f8 	str.w	r0, [r7, #248]	@ 0xf8
                        }
                    }
                #endif /* !NO_DES3 */
                #if !defined(NO_AES) && defined(HAVE_AES_CBC) && \
                    defined(HAVE_AES_DECRYPT)
                    if (info->cipherType == WC_CIPHER_AES_CBC) {
 8019c70:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8019c74:	68db      	ldr	r3, [r3, #12]
 8019c76:	2b02      	cmp	r3, #2
 8019c78:	d11c      	bne.n	8019cb4 <PemToDer+0x6f8>
                        if (der->length > WC_AES_BLOCK_SIZE) {
 8019c7a:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8019c7e:	689b      	ldr	r3, [r3, #8]
 8019c80:	2b10      	cmp	r3, #16
 8019c82:	d917      	bls.n	8019cb4 <PemToDer+0x6f8>
                            padVal = der->buffer[der->length-1];
 8019c84:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8019c88:	681a      	ldr	r2, [r3, #0]
 8019c8a:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8019c8e:	689b      	ldr	r3, [r3, #8]
 8019c90:	3b01      	subs	r3, #1
 8019c92:	4413      	add	r3, r2
 8019c94:	781b      	ldrb	r3, [r3, #0]
 8019c96:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
                            if (padVal <= WC_AES_BLOCK_SIZE) {
 8019c9a:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8019c9e:	2b10      	cmp	r3, #16
 8019ca0:	dc08      	bgt.n	8019cb4 <PemToDer+0x6f8>
                                der->length -= (word32)padVal;
 8019ca2:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8019ca6:	689a      	ldr	r2, [r3, #8]
 8019ca8:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8019cac:	1ad2      	subs	r2, r2, r3
 8019cae:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8019cb2:	609a      	str	r2, [r3, #8]
                #endif
#endif /* !NO_WOLFSSL_SKIP_TRAILING_PAD */
                }
            }
#ifdef OPENSSL_EXTRA
            if (ret) {
 8019cb4:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8019cb8:	2b00      	cmp	r3, #0
 8019cba:	d008      	beq.n	8019cce <PemToDer+0x712>
                WOLFSSL_PEMerr(0, WOLFSSL_PEM_R_BAD_DECRYPT_E);
 8019cbc:	f246 43fd 	movw	r3, #25853	@ 0x64fd
 8019cc0:	9300      	str	r3, [sp, #0]
 8019cc2:	4b15      	ldr	r3, [pc, #84]	@ (8019d18 <PemToDer+0x75c>)
 8019cc4:	4a15      	ldr	r2, [pc, #84]	@ (8019d1c <PemToDer+0x760>)
 8019cc6:	2100      	movs	r1, #0
 8019cc8:	2009      	movs	r0, #9
 8019cca:	f7f3 ff8d 	bl	800dbe8 <wolfSSL_ERR_put_error>
            }
#endif
            ForceZero(password, (word32)passwordSz);
 8019cce:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8019cd2:	4619      	mov	r1, r3
 8019cd4:	f8d7 00d0 	ldr.w	r0, [r7, #208]	@ 0xd0
 8019cd8:	f7f8 fcdb 	bl	8012692 <ForceZero>
 8019cdc:	e009      	b.n	8019cf2 <PemToDer+0x736>
        }
#ifdef OPENSSL_EXTRA
        else {
            WOLFSSL_PEMerr(0, WOLFSSL_PEM_R_BAD_PASSWORD_READ_E);
 8019cde:	f246 5304 	movw	r3, #25860	@ 0x6504
 8019ce2:	9300      	str	r3, [sp, #0]
 8019ce4:	4b0c      	ldr	r3, [pc, #48]	@ (8019d18 <PemToDer+0x75c>)
 8019ce6:	f46f 72fe 	mvn.w	r2, #508	@ 0x1fc
 8019cea:	2100      	movs	r1, #0
 8019cec:	2009      	movs	r0, #9
 8019cee:	f7f3 ff7b 	bl	800dbe8 <wolfSSL_ERR_put_error>
        }
#endif

    #ifdef WOLFSSL_SMALL_STACK
        XFREE(password, heap, DYNAMIC_TYPE_STRING);
 8019cf2:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8019cf6:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 8019cfa:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8019cfe:	2b00      	cmp	r3, #0
 8019d00:	d003      	beq.n	8019d0a <PemToDer+0x74e>
 8019d02:	f8d7 00c8 	ldr.w	r0, [r7, #200]	@ 0xc8
 8019d06:	f004 fedb 	bl	801eac0 <wolfSSL_Free>
        wc_MemZero_Check(password, NAME_SZ);
    #endif
    }
#endif /* WOLFSSL_ENCRYPTED_KEYS */

    return ret;
 8019d0a:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
}
 8019d0e:	4618      	mov	r0, r3
 8019d10:	f507 7782 	add.w	r7, r7, #260	@ 0x104
 8019d14:	46bd      	mov	sp, r7
 8019d16:	bd90      	pop	{r4, r7, pc}
 8019d18:	0802fbc0 	.word	0x0802fbc0
 8019d1c:	fffffe02 	.word	0xfffffe02

08019d20 <DecodeECC_DSA_Sig_Ex>:
    return DecodeECC_DSA_Sig_Ex(sig, sigLen, r, s, 1);
}

int DecodeECC_DSA_Sig_Ex(const byte* sig, word32 sigLen, mp_int* r, mp_int* s,
    int init)
{
 8019d20:	b580      	push	{r7, lr}
 8019d22:	b0a0      	sub	sp, #128	@ 0x80
 8019d24:	af04      	add	r7, sp, #16
 8019d26:	60f8      	str	r0, [r7, #12]
 8019d28:	60b9      	str	r1, [r7, #8]
 8019d2a:	607a      	str	r2, [r7, #4]
 8019d2c:	603b      	str	r3, [r7, #0]
#endif

    return 0;
#else
    ASNGetData dataASN[dsaSigASN_Length];
    word32 idx = 0;
 8019d2e:	2300      	movs	r3, #0
 8019d30:	617b      	str	r3, [r7, #20]
    int ret;

    /* Clear dynamic data and set mp_ints to put r and s into. */
    XMEMSET(dataASN, 0, sizeof(dataASN));
 8019d32:	f107 0318 	add.w	r3, r7, #24
 8019d36:	2254      	movs	r2, #84	@ 0x54
 8019d38:	2100      	movs	r1, #0
 8019d3a:	4618      	mov	r0, r3
 8019d3c:	f00e fbc4 	bl	80284c8 <memset>
    if (init) {
 8019d40:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8019d42:	2b00      	cmp	r3, #0
 8019d44:	d00a      	beq.n	8019d5c <DecodeECC_DSA_Sig_Ex+0x3c>
        GetASN_MP(&dataASN[DSASIGASN_IDX_R], r);
 8019d46:	2308      	movs	r3, #8
 8019d48:	f887 304c 	strb.w	r3, [r7, #76]	@ 0x4c
 8019d4c:	687b      	ldr	r3, [r7, #4]
 8019d4e:	63fb      	str	r3, [r7, #60]	@ 0x3c
        GetASN_MP(&dataASN[DSASIGASN_IDX_S], s);
 8019d50:	2308      	movs	r3, #8
 8019d52:	f887 3068 	strb.w	r3, [r7, #104]	@ 0x68
 8019d56:	683b      	ldr	r3, [r7, #0]
 8019d58:	65bb      	str	r3, [r7, #88]	@ 0x58
 8019d5a:	e009      	b.n	8019d70 <DecodeECC_DSA_Sig_Ex+0x50>
    }
    else {
        GetASN_MP_Inited(&dataASN[DSASIGASN_IDX_R], r);
 8019d5c:	2309      	movs	r3, #9
 8019d5e:	f887 304c 	strb.w	r3, [r7, #76]	@ 0x4c
 8019d62:	687b      	ldr	r3, [r7, #4]
 8019d64:	63fb      	str	r3, [r7, #60]	@ 0x3c
        GetASN_MP_Inited(&dataASN[DSASIGASN_IDX_S], s);
 8019d66:	2309      	movs	r3, #9
 8019d68:	f887 3068 	strb.w	r3, [r7, #104]	@ 0x68
 8019d6c:	683b      	ldr	r3, [r7, #0]
 8019d6e:	65bb      	str	r3, [r7, #88]	@ 0x58
    }

    /* Decode the DSA signature. */
    ret = GetASN_Items(dsaSigASN, dataASN, dsaSigASN_Length, 0, sig, &idx,
 8019d70:	f107 0118 	add.w	r1, r7, #24
 8019d74:	68bb      	ldr	r3, [r7, #8]
 8019d76:	9302      	str	r3, [sp, #8]
 8019d78:	f107 0314 	add.w	r3, r7, #20
 8019d7c:	9301      	str	r3, [sp, #4]
 8019d7e:	68fb      	ldr	r3, [r7, #12]
 8019d80:	9300      	str	r3, [sp, #0]
 8019d82:	2300      	movs	r3, #0
 8019d84:	2203      	movs	r2, #3
 8019d86:	4811      	ldr	r0, [pc, #68]	@ (8019dcc <DecodeECC_DSA_Sig_Ex+0xac>)
 8019d88:	f7f9 fcba 	bl	8013700 <GetASN_Items>
 8019d8c:	66f8      	str	r0, [r7, #108]	@ 0x6c
                       sigLen);

    if (ret != 0) {
 8019d8e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8019d90:	2b00      	cmp	r3, #0
 8019d92:	d002      	beq.n	8019d9a <DecodeECC_DSA_Sig_Ex+0x7a>
        ret = ASN_ECC_KEY_E;
 8019d94:	f06f 03aa 	mvn.w	r3, #170	@ 0xaa
 8019d98:	66fb      	str	r3, [r7, #108]	@ 0x6c
    }

#ifndef NO_STRICT_ECDSA_LEN
    /* sanity check that the index has been advanced all the way to the end of
     * the buffer */
    if ((ret == 0) && (idx != sigLen)) {
 8019d9a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8019d9c:	2b00      	cmp	r3, #0
 8019d9e:	d106      	bne.n	8019dae <DecodeECC_DSA_Sig_Ex+0x8e>
 8019da0:	697b      	ldr	r3, [r7, #20]
 8019da2:	68ba      	ldr	r2, [r7, #8]
 8019da4:	429a      	cmp	r2, r3
 8019da6:	d002      	beq.n	8019dae <DecodeECC_DSA_Sig_Ex+0x8e>
        ret = ASN_ECC_KEY_E;
 8019da8:	f06f 03aa 	mvn.w	r3, #170	@ 0xaa
 8019dac:	66fb      	str	r3, [r7, #108]	@ 0x6c
    }
#endif
    if (ret != 0) {
 8019dae:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8019db0:	2b00      	cmp	r3, #0
 8019db2:	d005      	beq.n	8019dc0 <DecodeECC_DSA_Sig_Ex+0xa0>
        mp_clear(r);
 8019db4:	6878      	ldr	r0, [r7, #4]
 8019db6:	f00c fcf6 	bl	80267a6 <mp_clear>
        mp_clear(s);
 8019dba:	6838      	ldr	r0, [r7, #0]
 8019dbc:	f00c fcf3 	bl	80267a6 <mp_clear>
    }

    return ret;
 8019dc0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 8019dc2:	4618      	mov	r0, r3
 8019dc4:	3770      	adds	r7, #112	@ 0x70
 8019dc6:	46bd      	mov	sp, r7
 8019dc8:	bd80      	pop	{r7, pc}
 8019dca:	bf00      	nop
 8019dcc:	08033a50 	.word	0x08033a50

08019dd0 <wc_EccPrivateKeyDecode>:
#endif

WOLFSSL_ABI
int wc_EccPrivateKeyDecode(const byte* input, word32* inOutIdx, ecc_key* key,
                        word32 inSz)
{
 8019dd0:	b590      	push	{r4, r7, lr}
 8019dd2:	b091      	sub	sp, #68	@ 0x44
 8019dd4:	af04      	add	r7, sp, #16
 8019dd6:	60f8      	str	r0, [r7, #12]
 8019dd8:	60b9      	str	r1, [r7, #8]
 8019dda:	607a      	str	r2, [r7, #4]
 8019ddc:	603b      	str	r3, [r7, #0]
    XFREE(pub,  key->heap, DYNAMIC_TYPE_TMP_BUFFER);
#endif

    return ret;
#else
    DECL_ASNGETDATA(dataASN, eccKeyASN_Length);
 8019dde:	2300      	movs	r3, #0
 8019de0:	62fb      	str	r3, [r7, #44]	@ 0x2c
    byte version = 0;
 8019de2:	2300      	movs	r3, #0
 8019de4:	77fb      	strb	r3, [r7, #31]
    int ret = 0;
 8019de6:	2300      	movs	r3, #0
 8019de8:	62bb      	str	r3, [r7, #40]	@ 0x28
    int curve_id = ECC_CURVE_DEF;
 8019dea:	2300      	movs	r3, #0
 8019dec:	627b      	str	r3, [r7, #36]	@ 0x24
#if defined(HAVE_PKCS8) || defined(HAVE_PKCS12) || defined(WOLFSSL_SM2)
    word32 algId = 0;
 8019dee:	2300      	movs	r3, #0
 8019df0:	61bb      	str	r3, [r7, #24]
    word32 eccOid = 0;
 8019df2:	2300      	movs	r3, #0
 8019df4:	617b      	str	r3, [r7, #20]
#endif

    /* Validate parameters. */
    if ((input == NULL) || (inOutIdx == NULL) || (key == NULL) || (inSz == 0)) {
 8019df6:	68fb      	ldr	r3, [r7, #12]
 8019df8:	2b00      	cmp	r3, #0
 8019dfa:	d008      	beq.n	8019e0e <wc_EccPrivateKeyDecode+0x3e>
 8019dfc:	68bb      	ldr	r3, [r7, #8]
 8019dfe:	2b00      	cmp	r3, #0
 8019e00:	d005      	beq.n	8019e0e <wc_EccPrivateKeyDecode+0x3e>
 8019e02:	687b      	ldr	r3, [r7, #4]
 8019e04:	2b00      	cmp	r3, #0
 8019e06:	d002      	beq.n	8019e0e <wc_EccPrivateKeyDecode+0x3e>
 8019e08:	683b      	ldr	r3, [r7, #0]
 8019e0a:	2b00      	cmp	r3, #0
 8019e0c:	d102      	bne.n	8019e14 <wc_EccPrivateKeyDecode+0x44>
        ret = BAD_FUNC_ARG;
 8019e0e:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8019e12:	62bb      	str	r3, [r7, #40]	@ 0x28
    }

#if defined(HAVE_PKCS8) || defined(HAVE_PKCS12) || defined(WOLFSSL_SM2)
    /* if has pkcs8 header skip it */
    if (ToTraditionalInline_ex2(input, inOutIdx, inSz, &algId, &eccOid) < 0) {
 8019e14:	f107 0218 	add.w	r2, r7, #24
 8019e18:	f107 0314 	add.w	r3, r7, #20
 8019e1c:	9300      	str	r3, [sp, #0]
 8019e1e:	4613      	mov	r3, r2
 8019e20:	683a      	ldr	r2, [r7, #0]
 8019e22:	68b9      	ldr	r1, [r7, #8]
 8019e24:	68f8      	ldr	r0, [r7, #12]
 8019e26:	f7fa ff1b 	bl	8014c60 <ToTraditionalInline_ex2>
 8019e2a:	4603      	mov	r3, r0
 8019e2c:	2b00      	cmp	r3, #0
 8019e2e:	db06      	blt.n	8019e3e <wc_EccPrivateKeyDecode+0x6e>
        /* ignore error, did not have pkcs8 header */
    }
    else {
        curve_id = wc_ecc_get_oid(eccOid, NULL, NULL);
 8019e30:	697b      	ldr	r3, [r7, #20]
 8019e32:	2200      	movs	r2, #0
 8019e34:	2100      	movs	r1, #0
 8019e36:	4618      	mov	r0, r3
 8019e38:	f004 fa3e 	bl	801e2b8 <wc_ecc_get_oid>
 8019e3c:	6278      	str	r0, [r7, #36]	@ 0x24
    }
#endif

    CALLOC_ASNGETDATA(dataASN, eccKeyASN_Length, ret, key->heap);
 8019e3e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8019e40:	2b00      	cmp	r3, #0
 8019e42:	d109      	bne.n	8019e58 <wc_EccPrivateKeyDecode+0x88>
 8019e44:	20e0      	movs	r0, #224	@ 0xe0
 8019e46:	f004 fe1f 	bl	801ea88 <wolfSSL_Malloc>
 8019e4a:	62f8      	str	r0, [r7, #44]	@ 0x2c
 8019e4c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019e4e:	2b00      	cmp	r3, #0
 8019e50:	d102      	bne.n	8019e58 <wc_EccPrivateKeyDecode+0x88>
 8019e52:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8019e56:	62bb      	str	r3, [r7, #40]	@ 0x28
 8019e58:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8019e5a:	2b00      	cmp	r3, #0
 8019e5c:	d104      	bne.n	8019e68 <wc_EccPrivateKeyDecode+0x98>
 8019e5e:	22e0      	movs	r2, #224	@ 0xe0
 8019e60:	2100      	movs	r1, #0
 8019e62:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8019e64:	f00e fb30 	bl	80284c8 <memset>

    if (ret == 0) {
 8019e68:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8019e6a:	2b00      	cmp	r3, #0
 8019e6c:	d119      	bne.n	8019ea2 <wc_EccPrivateKeyDecode+0xd2>
        /* Get the version and set the expected OID type. */
        GetASN_Int8Bit(&dataASN[ECCKEYASN_IDX_VER], &version);
 8019e6e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019e70:	331c      	adds	r3, #28
 8019e72:	2201      	movs	r2, #1
 8019e74:	761a      	strb	r2, [r3, #24]
 8019e76:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019e78:	331c      	adds	r3, #28
 8019e7a:	f107 021f 	add.w	r2, r7, #31
 8019e7e:	609a      	str	r2, [r3, #8]
        GetASN_OID(&dataASN[ECCKEYASN_IDX_CURVEID], oidCurveType);
 8019e80:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019e82:	3370      	adds	r3, #112	@ 0x70
 8019e84:	2203      	movs	r2, #3
 8019e86:	611a      	str	r2, [r3, #16]
        /* Decode the private ECC key. */
        ret = GetASN_Items(eccKeyASN, dataASN, eccKeyASN_Length, 1, input,
 8019e88:	683b      	ldr	r3, [r7, #0]
 8019e8a:	9302      	str	r3, [sp, #8]
 8019e8c:	68bb      	ldr	r3, [r7, #8]
 8019e8e:	9301      	str	r3, [sp, #4]
 8019e90:	68fb      	ldr	r3, [r7, #12]
 8019e92:	9300      	str	r3, [sp, #0]
 8019e94:	2301      	movs	r3, #1
 8019e96:	2208      	movs	r2, #8
 8019e98:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8019e9a:	4829      	ldr	r0, [pc, #164]	@ (8019f40 <wc_EccPrivateKeyDecode+0x170>)
 8019e9c:	f7f9 fc30 	bl	8013700 <GetASN_Items>
 8019ea0:	62b8      	str	r0, [r7, #40]	@ 0x28
                           inOutIdx, inSz);
    }
    /* Only version 1 supported. */
    if (ret == 0) {
 8019ea2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8019ea4:	2b00      	cmp	r3, #0
 8019ea6:	d105      	bne.n	8019eb4 <wc_EccPrivateKeyDecode+0xe4>
        if (version != 1) {
 8019ea8:	7ffb      	ldrb	r3, [r7, #31]
 8019eaa:	2b01      	cmp	r3, #1
 8019eac:	d002      	beq.n	8019eb4 <wc_EccPrivateKeyDecode+0xe4>
            ret = ASN_PARSE_E;
 8019eae:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8019eb2:	62bb      	str	r3, [r7, #40]	@ 0x28
        }
    }
    /* Curve Parameters are optional. */
    if ((ret == 0) && (dataASN[ECCKEYASN_IDX_PARAMS].tag != 0)) {
 8019eb4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8019eb6:	2b00      	cmp	r3, #0
 8019eb8:	d11a      	bne.n	8019ef0 <wc_EccPrivateKeyDecode+0x120>
 8019eba:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019ebc:	3354      	adds	r3, #84	@ 0x54
 8019ebe:	7e5b      	ldrb	r3, [r3, #25]
 8019ec0:	2b00      	cmp	r3, #0
 8019ec2:	d015      	beq.n	8019ef0 <wc_EccPrivateKeyDecode+0x120>
        if (dataASN[ECCKEYASN_IDX_CURVEID].tag != 0) {
 8019ec4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019ec6:	3370      	adds	r3, #112	@ 0x70
 8019ec8:	7e5b      	ldrb	r3, [r3, #25]
 8019eca:	2b00      	cmp	r3, #0
 8019ecc:	d00d      	beq.n	8019eea <wc_EccPrivateKeyDecode+0x11a>
            /* Named curve - check and get id. */
            curve_id = CheckCurve(dataASN[ECCKEYASN_IDX_CURVEID].data.oid.sum);
 8019ece:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019ed0:	3370      	adds	r3, #112	@ 0x70
 8019ed2:	695b      	ldr	r3, [r3, #20]
 8019ed4:	4618      	mov	r0, r3
 8019ed6:	f7fa fbf1 	bl	80146bc <CheckCurve>
 8019eda:	6278      	str	r0, [r7, #36]	@ 0x24
            if (curve_id < 0) {
 8019edc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8019ede:	2b00      	cmp	r3, #0
 8019ee0:	da06      	bge.n	8019ef0 <wc_EccPrivateKeyDecode+0x120>
                ret = ECC_CURVE_OID_E;
 8019ee2:	f06f 03ab 	mvn.w	r3, #171	@ 0xab
 8019ee6:	62bb      	str	r3, [r7, #40]	@ 0x28
 8019ee8:	e002      	b.n	8019ef0 <wc_EccPrivateKeyDecode+0x120>
                    dataASN[ECCKEYASN_IDX_CURVEPARAMS].data.ref.data,
                    dataASN[ECCKEYASN_IDX_CURVEPARAMS].data.ref.length, key,
                    key->heap, NULL);
    #else
            /* Explicit parameters not supported in build configuration. */
            ret = ASN_PARSE_E;
 8019eea:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8019eee:	62bb      	str	r3, [r7, #40]	@ 0x28
    #endif
        }
    }
    if (ret == 0) {
 8019ef0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8019ef2:	2b00      	cmp	r3, #0
 8019ef4:	d113      	bne.n	8019f1e <wc_EccPrivateKeyDecode+0x14e>
        /* Import private key value and public point (may be NULL). */
        ret = wc_ecc_import_private_key_ex(
                dataASN[ECCKEYASN_IDX_PKEY].data.ref.data,
 8019ef6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019ef8:	3338      	adds	r3, #56	@ 0x38
        ret = wc_ecc_import_private_key_ex(
 8019efa:	6898      	ldr	r0, [r3, #8]
                dataASN[ECCKEYASN_IDX_PKEY].data.ref.length,
 8019efc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019efe:	3338      	adds	r3, #56	@ 0x38
        ret = wc_ecc_import_private_key_ex(
 8019f00:	68d9      	ldr	r1, [r3, #12]
                dataASN[ECCKEYASN_IDX_PUBKEY_VAL].data.ref.data,
 8019f02:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019f04:	33c4      	adds	r3, #196	@ 0xc4
        ret = wc_ecc_import_private_key_ex(
 8019f06:	689a      	ldr	r2, [r3, #8]
                dataASN[ECCKEYASN_IDX_PUBKEY_VAL].data.ref.length,
 8019f08:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019f0a:	33c4      	adds	r3, #196	@ 0xc4
        ret = wc_ecc_import_private_key_ex(
 8019f0c:	68dc      	ldr	r4, [r3, #12]
 8019f0e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8019f10:	9301      	str	r3, [sp, #4]
 8019f12:	687b      	ldr	r3, [r7, #4]
 8019f14:	9300      	str	r3, [sp, #0]
 8019f16:	4623      	mov	r3, r4
 8019f18:	f004 f933 	bl	801e182 <wc_ecc_import_private_key_ex>
 8019f1c:	62b8      	str	r0, [r7, #40]	@ 0x28
                key, curve_id);
    }

    FREE_ASNGETDATA(dataASN, key->heap);
 8019f1e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019f20:	2b00      	cmp	r3, #0
 8019f22:	d007      	beq.n	8019f34 <wc_EccPrivateKeyDecode+0x164>
 8019f24:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019f26:	623b      	str	r3, [r7, #32]
 8019f28:	6a3b      	ldr	r3, [r7, #32]
 8019f2a:	2b00      	cmp	r3, #0
 8019f2c:	d002      	beq.n	8019f34 <wc_EccPrivateKeyDecode+0x164>
 8019f2e:	6a38      	ldr	r0, [r7, #32]
 8019f30:	f004 fdc6 	bl	801eac0 <wolfSSL_Free>
    return ret;
 8019f34:	6abb      	ldr	r3, [r7, #40]	@ 0x28
#endif
}
 8019f36:	4618      	mov	r0, r3
 8019f38:	3734      	adds	r7, #52	@ 0x34
 8019f3a:	46bd      	mov	sp, r7
 8019f3c:	bd90      	pop	{r4, r7, pc}
 8019f3e:	bf00      	nop
 8019f40:	08033a5c 	.word	0x08033a5c

08019f44 <wc_EccPublicKeyDecode>:
#endif /* WOLFSSL_CUSTOM_CURVES */

WOLFSSL_ABI
int wc_EccPublicKeyDecode(const byte* input, word32* inOutIdx,
                          ecc_key* key, word32 inSz)
{
 8019f44:	b580      	push	{r7, lr}
 8019f46:	b08e      	sub	sp, #56	@ 0x38
 8019f48:	af04      	add	r7, sp, #16
 8019f4a:	60f8      	str	r0, [r7, #12]
 8019f4c:	60b9      	str	r1, [r7, #8]
 8019f4e:	607a      	str	r2, [r7, #4]
 8019f50:	603b      	str	r3, [r7, #0]
    *inOutIdx += (word32)length;

    return 0;
#else
    /* eccKeyASN is longer than eccPublicKeyASN. */
    DECL_ASNGETDATA(dataASN, eccKeyASN_Length);
 8019f52:	2300      	movs	r3, #0
 8019f54:	627b      	str	r3, [r7, #36]	@ 0x24
    int ret = 0;
 8019f56:	2300      	movs	r3, #0
 8019f58:	623b      	str	r3, [r7, #32]
    int curve_id = ECC_CURVE_DEF;
 8019f5a:	2300      	movs	r3, #0
 8019f5c:	61fb      	str	r3, [r7, #28]
    int oidIdx = ECCPUBLICKEYASN_IDX_ALGOID_CURVEID;
 8019f5e:	2303      	movs	r3, #3
 8019f60:	61bb      	str	r3, [r7, #24]
#ifdef WOLFSSL_CUSTOM_CURVES
    int specIdx = ECCPUBLICKEYASN_IDX_ALGOID_PARAMS;
#endif
    int pubIdx = ECCPUBLICKEYASN_IDX_PUBKEY;
 8019f62:	2305      	movs	r3, #5
 8019f64:	617b      	str	r3, [r7, #20]

    if ((input == NULL) || (inOutIdx == NULL) || (key == NULL) || (inSz == 0)) {
 8019f66:	68fb      	ldr	r3, [r7, #12]
 8019f68:	2b00      	cmp	r3, #0
 8019f6a:	d008      	beq.n	8019f7e <wc_EccPublicKeyDecode+0x3a>
 8019f6c:	68bb      	ldr	r3, [r7, #8]
 8019f6e:	2b00      	cmp	r3, #0
 8019f70:	d005      	beq.n	8019f7e <wc_EccPublicKeyDecode+0x3a>
 8019f72:	687b      	ldr	r3, [r7, #4]
 8019f74:	2b00      	cmp	r3, #0
 8019f76:	d002      	beq.n	8019f7e <wc_EccPublicKeyDecode+0x3a>
 8019f78:	683b      	ldr	r3, [r7, #0]
 8019f7a:	2b00      	cmp	r3, #0
 8019f7c:	d102      	bne.n	8019f84 <wc_EccPublicKeyDecode+0x40>
        ret = BAD_FUNC_ARG;
 8019f7e:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8019f82:	623b      	str	r3, [r7, #32]
    }

    ALLOC_ASNGETDATA(dataASN, eccKeyASN_Length, ret, key->heap);
 8019f84:	6a3b      	ldr	r3, [r7, #32]
 8019f86:	2b00      	cmp	r3, #0
 8019f88:	d109      	bne.n	8019f9e <wc_EccPublicKeyDecode+0x5a>
 8019f8a:	20e0      	movs	r0, #224	@ 0xe0
 8019f8c:	f004 fd7c 	bl	801ea88 <wolfSSL_Malloc>
 8019f90:	6278      	str	r0, [r7, #36]	@ 0x24
 8019f92:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8019f94:	2b00      	cmp	r3, #0
 8019f96:	d102      	bne.n	8019f9e <wc_EccPublicKeyDecode+0x5a>
 8019f98:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8019f9c:	623b      	str	r3, [r7, #32]

    if (ret == 0) {
 8019f9e:	6a3b      	ldr	r3, [r7, #32]
 8019fa0:	2b00      	cmp	r3, #0
 8019fa2:	d150      	bne.n	801a046 <wc_EccPublicKeyDecode+0x102>
        /* Clear dynamic data for ECC public key. */
        XMEMSET(dataASN, 0, sizeof(*dataASN) * eccPublicKeyASN_Length);
 8019fa4:	22a8      	movs	r2, #168	@ 0xa8
 8019fa6:	2100      	movs	r1, #0
 8019fa8:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8019faa:	f00e fa8d 	bl	80284c8 <memset>
#if !defined(WOLFSSL_SM2) || !defined(WOLFSSL_SM3)
        /* Set required ECDSA OID and ignore the curve OID type. */
        GetASN_ExpBuffer(&dataASN[ECCPUBLICKEYASN_IDX_ALGOID_OID], keyEcdsaOid,
 8019fae:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8019fb0:	3338      	adds	r3, #56	@ 0x38
 8019fb2:	2206      	movs	r2, #6
 8019fb4:	761a      	strb	r2, [r3, #24]
 8019fb6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8019fb8:	3338      	adds	r3, #56	@ 0x38
 8019fba:	4a4d      	ldr	r2, [pc, #308]	@ (801a0f0 <wc_EccPublicKeyDecode+0x1ac>)
 8019fbc:	609a      	str	r2, [r3, #8]
 8019fbe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8019fc0:	3338      	adds	r3, #56	@ 0x38
 8019fc2:	2207      	movs	r2, #7
 8019fc4:	60da      	str	r2, [r3, #12]
                sizeof(keyEcdsaOid));
#else
        GetASN_OID(&dataASN[ECCPUBLICKEYASN_IDX_ALGOID_OID], oidKeyType);
#endif
        GetASN_OID(&dataASN[oidIdx], oidCurveType);
 8019fc6:	69ba      	ldr	r2, [r7, #24]
 8019fc8:	4613      	mov	r3, r2
 8019fca:	00db      	lsls	r3, r3, #3
 8019fcc:	1a9b      	subs	r3, r3, r2
 8019fce:	009b      	lsls	r3, r3, #2
 8019fd0:	461a      	mov	r2, r3
 8019fd2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8019fd4:	4413      	add	r3, r2
 8019fd6:	2203      	movs	r2, #3
 8019fd8:	611a      	str	r2, [r3, #16]
        /* Decode the public ECC key. */
        ret = GetASN_Items(eccPublicKeyASN, dataASN, eccPublicKeyASN_Length, 1,
 8019fda:	683b      	ldr	r3, [r7, #0]
 8019fdc:	9302      	str	r3, [sp, #8]
 8019fde:	68bb      	ldr	r3, [r7, #8]
 8019fe0:	9301      	str	r3, [sp, #4]
 8019fe2:	68fb      	ldr	r3, [r7, #12]
 8019fe4:	9300      	str	r3, [sp, #0]
 8019fe6:	2301      	movs	r3, #1
 8019fe8:	2206      	movs	r2, #6
 8019fea:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8019fec:	4841      	ldr	r0, [pc, #260]	@ (801a0f4 <wc_EccPublicKeyDecode+0x1b0>)
 8019fee:	f7f9 fb87 	bl	8013700 <GetASN_Items>
 8019ff2:	6238      	str	r0, [r7, #32]
                           input, inOutIdx, inSz);
        if (ret != 0) {
 8019ff4:	6a3b      	ldr	r3, [r7, #32]
 8019ff6:	2b00      	cmp	r3, #0
 8019ff8:	d025      	beq.n	801a046 <wc_EccPublicKeyDecode+0x102>
            oidIdx = ECCKEYASN_IDX_CURVEID;
 8019ffa:	2304      	movs	r3, #4
 8019ffc:	61bb      	str	r3, [r7, #24]
        #ifdef WOLFSSL_CUSTOM_CURVES
            specIdx = ECCKEYASN_IDX_CURVEPARAMS;
        #endif
            pubIdx = ECCKEYASN_IDX_PUBKEY_VAL;
 8019ffe:	2307      	movs	r3, #7
 801a000:	617b      	str	r3, [r7, #20]

            /* Clear dynamic data for ECC private key. */
            XMEMSET(dataASN, 0, sizeof(*dataASN) * eccKeyASN_Length);
 801a002:	22e0      	movs	r2, #224	@ 0xe0
 801a004:	2100      	movs	r1, #0
 801a006:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 801a008:	f00e fa5e 	bl	80284c8 <memset>
            /* Check named curve OID type. */
            GetASN_OID(&dataASN[oidIdx], oidCurveType);
 801a00c:	69ba      	ldr	r2, [r7, #24]
 801a00e:	4613      	mov	r3, r2
 801a010:	00db      	lsls	r3, r3, #3
 801a012:	1a9b      	subs	r3, r3, r2
 801a014:	009b      	lsls	r3, r3, #2
 801a016:	461a      	mov	r2, r3
 801a018:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a01a:	4413      	add	r3, r2
 801a01c:	2203      	movs	r2, #3
 801a01e:	611a      	str	r2, [r3, #16]
            /* Try private key format .*/
            ret = GetASN_Items(eccKeyASN, dataASN, eccKeyASN_Length, 1, input,
 801a020:	683b      	ldr	r3, [r7, #0]
 801a022:	9302      	str	r3, [sp, #8]
 801a024:	68bb      	ldr	r3, [r7, #8]
 801a026:	9301      	str	r3, [sp, #4]
 801a028:	68fb      	ldr	r3, [r7, #12]
 801a02a:	9300      	str	r3, [sp, #0]
 801a02c:	2301      	movs	r3, #1
 801a02e:	2208      	movs	r2, #8
 801a030:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801a032:	4831      	ldr	r0, [pc, #196]	@ (801a0f8 <wc_EccPublicKeyDecode+0x1b4>)
 801a034:	f7f9 fb64 	bl	8013700 <GetASN_Items>
 801a038:	6238      	str	r0, [r7, #32]
                               inOutIdx, inSz);
            if (ret != 0) {
 801a03a:	6a3b      	ldr	r3, [r7, #32]
 801a03c:	2b00      	cmp	r3, #0
 801a03e:	d002      	beq.n	801a046 <wc_EccPublicKeyDecode+0x102>
                ret = ASN_PARSE_E;
 801a040:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801a044:	623b      	str	r3, [r7, #32]
        if ((oidSum != ECDSAk) && (oidSum != SM2k)) {
            ret = ASN_PARSE_E;
        }
    }
#endif
    if (ret == 0) {
 801a046:	6a3b      	ldr	r3, [r7, #32]
 801a048:	2b00      	cmp	r3, #0
 801a04a:	d121      	bne.n	801a090 <wc_EccPublicKeyDecode+0x14c>
        if (dataASN[oidIdx].tag != 0) {
 801a04c:	69ba      	ldr	r2, [r7, #24]
 801a04e:	4613      	mov	r3, r2
 801a050:	00db      	lsls	r3, r3, #3
 801a052:	1a9b      	subs	r3, r3, r2
 801a054:	009b      	lsls	r3, r3, #2
 801a056:	461a      	mov	r2, r3
 801a058:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a05a:	4413      	add	r3, r2
 801a05c:	7e5b      	ldrb	r3, [r3, #25]
 801a05e:	2b00      	cmp	r3, #0
 801a060:	d013      	beq.n	801a08a <wc_EccPublicKeyDecode+0x146>
            /* Named curve - check and get id. */
            curve_id = CheckCurve(dataASN[oidIdx].data.oid.sum);
 801a062:	69ba      	ldr	r2, [r7, #24]
 801a064:	4613      	mov	r3, r2
 801a066:	00db      	lsls	r3, r3, #3
 801a068:	1a9b      	subs	r3, r3, r2
 801a06a:	009b      	lsls	r3, r3, #2
 801a06c:	461a      	mov	r2, r3
 801a06e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a070:	4413      	add	r3, r2
 801a072:	695b      	ldr	r3, [r3, #20]
 801a074:	4618      	mov	r0, r3
 801a076:	f7fa fb21 	bl	80146bc <CheckCurve>
 801a07a:	61f8      	str	r0, [r7, #28]
            if (curve_id < 0) {
 801a07c:	69fb      	ldr	r3, [r7, #28]
 801a07e:	2b00      	cmp	r3, #0
 801a080:	da06      	bge.n	801a090 <wc_EccPublicKeyDecode+0x14c>
                ret = ASN_OBJECT_ID_E;
 801a082:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 801a086:	623b      	str	r3, [r7, #32]
 801a088:	e002      	b.n	801a090 <wc_EccPublicKeyDecode+0x14c>
            ret = EccSpecifiedECDomainDecode(dataASN[specIdx].data.ref.data,
                                         dataASN[specIdx].data.ref.length, key,
                                         key->heap, NULL);
        #else
            /* Explicit parameters not supported in build configuration. */
            ret = ASN_PARSE_E;
 801a08a:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801a08e:	623b      	str	r3, [r7, #32]
        #endif
        }
    }
    if (ret == 0) {
 801a090:	6a3b      	ldr	r3, [r7, #32]
 801a092:	2b00      	cmp	r3, #0
 801a094:	d11c      	bne.n	801a0d0 <wc_EccPublicKeyDecode+0x18c>
        /* Import public point. */
        ret = wc_ecc_import_x963_ex(dataASN[pubIdx].data.ref.data,
 801a096:	697a      	ldr	r2, [r7, #20]
 801a098:	4613      	mov	r3, r2
 801a09a:	00db      	lsls	r3, r3, #3
 801a09c:	1a9b      	subs	r3, r3, r2
 801a09e:	009b      	lsls	r3, r3, #2
 801a0a0:	461a      	mov	r2, r3
 801a0a2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a0a4:	4413      	add	r3, r2
 801a0a6:	6898      	ldr	r0, [r3, #8]
                dataASN[pubIdx].data.ref.length, key, curve_id);
 801a0a8:	697a      	ldr	r2, [r7, #20]
 801a0aa:	4613      	mov	r3, r2
 801a0ac:	00db      	lsls	r3, r3, #3
 801a0ae:	1a9b      	subs	r3, r3, r2
 801a0b0:	009b      	lsls	r3, r3, #2
 801a0b2:	461a      	mov	r2, r3
 801a0b4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a0b6:	4413      	add	r3, r2
        ret = wc_ecc_import_x963_ex(dataASN[pubIdx].data.ref.data,
 801a0b8:	68d9      	ldr	r1, [r3, #12]
 801a0ba:	69fb      	ldr	r3, [r7, #28]
 801a0bc:	687a      	ldr	r2, [r7, #4]
 801a0be:	f003 ffa5 	bl	801e00c <wc_ecc_import_x963_ex>
 801a0c2:	6238      	str	r0, [r7, #32]
        if (ret != 0) {
 801a0c4:	6a3b      	ldr	r3, [r7, #32]
 801a0c6:	2b00      	cmp	r3, #0
 801a0c8:	d002      	beq.n	801a0d0 <wc_EccPublicKeyDecode+0x18c>
            ret = ASN_ECC_KEY_E;
 801a0ca:	f06f 03aa 	mvn.w	r3, #170	@ 0xaa
 801a0ce:	623b      	str	r3, [r7, #32]
        }
    }

    FREE_ASNGETDATA(dataASN, key->heap);
 801a0d0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a0d2:	2b00      	cmp	r3, #0
 801a0d4:	d007      	beq.n	801a0e6 <wc_EccPublicKeyDecode+0x1a2>
 801a0d6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a0d8:	613b      	str	r3, [r7, #16]
 801a0da:	693b      	ldr	r3, [r7, #16]
 801a0dc:	2b00      	cmp	r3, #0
 801a0de:	d002      	beq.n	801a0e6 <wc_EccPublicKeyDecode+0x1a2>
 801a0e0:	6938      	ldr	r0, [r7, #16]
 801a0e2:	f004 fced 	bl	801eac0 <wolfSSL_Free>
    return ret;
 801a0e6:	6a3b      	ldr	r3, [r7, #32]
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 801a0e8:	4618      	mov	r0, r3
 801a0ea:	3728      	adds	r7, #40	@ 0x28
 801a0ec:	46bd      	mov	sp, r7
 801a0ee:	bd80      	pop	{r7, pc}
 801a0f0:	080335e4 	.word	0x080335e4
 801a0f4:	080337f8 	.word	0x080337f8
 801a0f8:	08033a5c 	.word	0x08033a5c

0801a0fc <wc_RsaPublicKeyDecodeRaw>:
#if !defined(NO_RSA) && (!defined(NO_BIG_INT) || defined(WOLFSSL_SP_MATH))
/* import RSA public key elements (n, e) into RsaKey structure (key) */
/* this function does not use any ASN.1 parsing */
int wc_RsaPublicKeyDecodeRaw(const byte* n, word32 nSz, const byte* e,
                             word32 eSz, RsaKey* key)
{
 801a0fc:	b580      	push	{r7, lr}
 801a0fe:	b084      	sub	sp, #16
 801a100:	af00      	add	r7, sp, #0
 801a102:	60f8      	str	r0, [r7, #12]
 801a104:	60b9      	str	r1, [r7, #8]
 801a106:	607a      	str	r2, [r7, #4]
 801a108:	603b      	str	r3, [r7, #0]
    if (n == NULL || e == NULL || key == NULL)
 801a10a:	68fb      	ldr	r3, [r7, #12]
 801a10c:	2b00      	cmp	r3, #0
 801a10e:	d005      	beq.n	801a11c <wc_RsaPublicKeyDecodeRaw+0x20>
 801a110:	687b      	ldr	r3, [r7, #4]
 801a112:	2b00      	cmp	r3, #0
 801a114:	d002      	beq.n	801a11c <wc_RsaPublicKeyDecodeRaw+0x20>
 801a116:	69bb      	ldr	r3, [r7, #24]
 801a118:	2b00      	cmp	r3, #0
 801a11a:	d102      	bne.n	801a122 <wc_RsaPublicKeyDecodeRaw+0x26>
        return BAD_FUNC_ARG;
 801a11c:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801a120:	e049      	b.n	801a1b6 <wc_RsaPublicKeyDecodeRaw+0xba>

    key->type = RSA_PUBLIC;
 801a122:	69bb      	ldr	r3, [r7, #24]
 801a124:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801a128:	461a      	mov	r2, r3
 801a12a:	2300      	movs	r3, #0
 801a12c:	f8c2 3168 	str.w	r3, [r2, #360]	@ 0x168

    if (mp_init(&key->n) != MP_OKAY)
 801a130:	69bb      	ldr	r3, [r7, #24]
 801a132:	4618      	mov	r0, r3
 801a134:	f00c faad 	bl	8026692 <mp_init>
 801a138:	4603      	mov	r3, r0
 801a13a:	2b00      	cmp	r3, #0
 801a13c:	d002      	beq.n	801a144 <wc_RsaPublicKeyDecodeRaw+0x48>
        return MP_INIT_E;
 801a13e:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 801a142:	e038      	b.n	801a1b6 <wc_RsaPublicKeyDecodeRaw+0xba>

    if (mp_read_unsigned_bin(&key->n, n, nSz) != 0) {
 801a144:	69bb      	ldr	r3, [r7, #24]
 801a146:	68ba      	ldr	r2, [r7, #8]
 801a148:	68f9      	ldr	r1, [r7, #12]
 801a14a:	4618      	mov	r0, r3
 801a14c:	f00c fc7a 	bl	8026a44 <mp_read_unsigned_bin>
 801a150:	4603      	mov	r3, r0
 801a152:	2b00      	cmp	r3, #0
 801a154:	d006      	beq.n	801a164 <wc_RsaPublicKeyDecodeRaw+0x68>
        mp_clear(&key->n);
 801a156:	69bb      	ldr	r3, [r7, #24]
 801a158:	4618      	mov	r0, r3
 801a15a:	f00c fb24 	bl	80267a6 <mp_clear>
        return ASN_GETINT_E;
 801a15e:	f06f 038d 	mvn.w	r3, #141	@ 0x8d
 801a162:	e028      	b.n	801a1b6 <wc_RsaPublicKeyDecodeRaw+0xba>
        mp_clear(&key->n);
        return ASN_GETINT_E;
    }
#endif /* HAVE_WOLF_BIGINT */

    if (mp_init(&key->e) != MP_OKAY) {
 801a164:	69bb      	ldr	r3, [r7, #24]
 801a166:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 801a16a:	4618      	mov	r0, r3
 801a16c:	f00c fa91 	bl	8026692 <mp_init>
 801a170:	4603      	mov	r3, r0
 801a172:	2b00      	cmp	r3, #0
 801a174:	d006      	beq.n	801a184 <wc_RsaPublicKeyDecodeRaw+0x88>
        mp_clear(&key->n);
 801a176:	69bb      	ldr	r3, [r7, #24]
 801a178:	4618      	mov	r0, r3
 801a17a:	f00c fb14 	bl	80267a6 <mp_clear>
        return MP_INIT_E;
 801a17e:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 801a182:	e018      	b.n	801a1b6 <wc_RsaPublicKeyDecodeRaw+0xba>
    }

    if (mp_read_unsigned_bin(&key->e, e, eSz) != 0) {
 801a184:	69bb      	ldr	r3, [r7, #24]
 801a186:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 801a18a:	683a      	ldr	r2, [r7, #0]
 801a18c:	6879      	ldr	r1, [r7, #4]
 801a18e:	4618      	mov	r0, r3
 801a190:	f00c fc58 	bl	8026a44 <mp_read_unsigned_bin>
 801a194:	4603      	mov	r3, r0
 801a196:	2b00      	cmp	r3, #0
 801a198:	d00c      	beq.n	801a1b4 <wc_RsaPublicKeyDecodeRaw+0xb8>
        mp_clear(&key->n);
 801a19a:	69bb      	ldr	r3, [r7, #24]
 801a19c:	4618      	mov	r0, r3
 801a19e:	f00c fb02 	bl	80267a6 <mp_clear>
        mp_clear(&key->e);
 801a1a2:	69bb      	ldr	r3, [r7, #24]
 801a1a4:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 801a1a8:	4618      	mov	r0, r3
 801a1aa:	f00c fafc 	bl	80267a6 <mp_clear>
        return ASN_GETINT_E;
 801a1ae:	f06f 038d 	mvn.w	r3, #141	@ 0x8d
 801a1b2:	e000      	b.n	801a1b6 <wc_RsaPublicKeyDecodeRaw+0xba>
    if (wc_InitRsaHw(key) != 0) {
        return BAD_STATE_E;
    }
#endif

    return 0;
 801a1b4:	2300      	movs	r3, #0
}
 801a1b6:	4618      	mov	r0, r3
 801a1b8:	3710      	adds	r7, #16
 801a1ba:	46bd      	mov	sp, r7
 801a1bc:	bd80      	pop	{r7, pc}
	...

0801a1c0 <Base64_Char2Val>:
/* 0x78: x y z           */    49,  50,  51
                            };
#define BASE64DECODE_SZ    (byte)(sizeof(base64Decode))

static WC_INLINE byte Base64_Char2Val(byte c)
{
 801a1c0:	b480      	push	{r7}
 801a1c2:	b085      	sub	sp, #20
 801a1c4:	af00      	add	r7, sp, #0
 801a1c6:	4603      	mov	r3, r0
 801a1c8:	71fb      	strb	r3, [r7, #7]
     * 64 bytes in a cache line - first line has 64, second has 16
     */
    byte v;
    byte mask;

    c = (byte)(c - BASE64_MIN);
 801a1ca:	79fb      	ldrb	r3, [r7, #7]
 801a1cc:	3b2b      	subs	r3, #43	@ 0x2b
 801a1ce:	71fb      	strb	r3, [r7, #7]
    mask = (byte)((((byte)(0x3f - c)) >> 7) - 1);
 801a1d0:	79fb      	ldrb	r3, [r7, #7]
 801a1d2:	f1c3 033f 	rsb	r3, r3, #63	@ 0x3f
 801a1d6:	b2db      	uxtb	r3, r3
 801a1d8:	09db      	lsrs	r3, r3, #7
 801a1da:	b2db      	uxtb	r3, r3
 801a1dc:	3b01      	subs	r3, #1
 801a1de:	73fb      	strb	r3, [r7, #15]
    /* Load a value from the first cache line and use when mask set. */
    v  = (byte)(base64Decode[ c & 0x3f        ] &   mask);
 801a1e0:	79fb      	ldrb	r3, [r7, #7]
 801a1e2:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 801a1e6:	4a0f      	ldr	r2, [pc, #60]	@ (801a224 <Base64_Char2Val+0x64>)
 801a1e8:	5cd2      	ldrb	r2, [r2, r3]
 801a1ea:	7bfb      	ldrb	r3, [r7, #15]
 801a1ec:	4013      	ands	r3, r2
 801a1ee:	73bb      	strb	r3, [r7, #14]
    /* Load a value from the second cache line and use when mask not set. */
    v |= (byte)(base64Decode[(c & 0x0f) | 0x40] & (~mask));
 801a1f0:	79fb      	ldrb	r3, [r7, #7]
 801a1f2:	f003 030f 	and.w	r3, r3, #15
 801a1f6:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 801a1fa:	4a0a      	ldr	r2, [pc, #40]	@ (801a224 <Base64_Char2Val+0x64>)
 801a1fc:	5cd3      	ldrb	r3, [r2, r3]
 801a1fe:	b25a      	sxtb	r2, r3
 801a200:	f997 300f 	ldrsb.w	r3, [r7, #15]
 801a204:	43db      	mvns	r3, r3
 801a206:	b25b      	sxtb	r3, r3
 801a208:	4013      	ands	r3, r2
 801a20a:	b25b      	sxtb	r3, r3
 801a20c:	b2da      	uxtb	r2, r3
 801a20e:	7bbb      	ldrb	r3, [r7, #14]
 801a210:	4313      	orrs	r3, r2
 801a212:	73bb      	strb	r3, [r7, #14]

    return v;
 801a214:	7bbb      	ldrb	r3, [r7, #14]
#else
    return base64Decode[c - BASE64_MIN];
#endif
}
 801a216:	4618      	mov	r0, r3
 801a218:	3714      	adds	r7, #20
 801a21a:	46bd      	mov	sp, r7
 801a21c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a220:	4770      	bx	lr
 801a222:	bf00      	nop
 801a224:	08033a88 	.word	0x08033a88

0801a228 <Base64_SkipNewline>:
#endif

int Base64_SkipNewline(const byte* in, word32 *inLen,
  word32 *outJ)
{
 801a228:	b480      	push	{r7}
 801a22a:	b089      	sub	sp, #36	@ 0x24
 801a22c:	af00      	add	r7, sp, #0
 801a22e:	60f8      	str	r0, [r7, #12]
 801a230:	60b9      	str	r1, [r7, #8]
 801a232:	607a      	str	r2, [r7, #4]
    word32 len = *inLen;
 801a234:	68bb      	ldr	r3, [r7, #8]
 801a236:	681b      	ldr	r3, [r3, #0]
 801a238:	61fb      	str	r3, [r7, #28]
    word32 j = *outJ;
 801a23a:	687b      	ldr	r3, [r7, #4]
 801a23c:	681b      	ldr	r3, [r3, #0]
 801a23e:	61bb      	str	r3, [r7, #24]
    byte curChar;

    if (len == 0) {
 801a240:	69fb      	ldr	r3, [r7, #28]
 801a242:	2b00      	cmp	r3, #0
 801a244:	d102      	bne.n	801a24c <Base64_SkipNewline+0x24>
        return BUFFER_E;
 801a246:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 801a24a:	e065      	b.n	801a318 <Base64_SkipNewline+0xf0>
    }
    curChar = in[j];
 801a24c:	68fa      	ldr	r2, [r7, #12]
 801a24e:	69bb      	ldr	r3, [r7, #24]
 801a250:	4413      	add	r3, r2
 801a252:	781b      	ldrb	r3, [r3, #0]
 801a254:	75fb      	strb	r3, [r7, #23]

    while (len > 1 && curChar == ' ') {
 801a256:	e00a      	b.n	801a26e <Base64_SkipNewline+0x46>
        /* skip whitespace in the middle or end of line */
        curChar = in[++j];
 801a258:	69bb      	ldr	r3, [r7, #24]
 801a25a:	3301      	adds	r3, #1
 801a25c:	61bb      	str	r3, [r7, #24]
 801a25e:	68fa      	ldr	r2, [r7, #12]
 801a260:	69bb      	ldr	r3, [r7, #24]
 801a262:	4413      	add	r3, r2
 801a264:	781b      	ldrb	r3, [r3, #0]
 801a266:	75fb      	strb	r3, [r7, #23]
        len--;
 801a268:	69fb      	ldr	r3, [r7, #28]
 801a26a:	3b01      	subs	r3, #1
 801a26c:	61fb      	str	r3, [r7, #28]
    while (len > 1 && curChar == ' ') {
 801a26e:	69fb      	ldr	r3, [r7, #28]
 801a270:	2b01      	cmp	r3, #1
 801a272:	d902      	bls.n	801a27a <Base64_SkipNewline+0x52>
 801a274:	7dfb      	ldrb	r3, [r7, #23]
 801a276:	2b20      	cmp	r3, #32
 801a278:	d0ee      	beq.n	801a258 <Base64_SkipNewline+0x30>
    }
    if (len && (curChar == '\r' || curChar == '\n')) {
 801a27a:	69fb      	ldr	r3, [r7, #28]
 801a27c:	2b00      	cmp	r3, #0
 801a27e:	d038      	beq.n	801a2f2 <Base64_SkipNewline+0xca>
 801a280:	7dfb      	ldrb	r3, [r7, #23]
 801a282:	2b0d      	cmp	r3, #13
 801a284:	d002      	beq.n	801a28c <Base64_SkipNewline+0x64>
 801a286:	7dfb      	ldrb	r3, [r7, #23]
 801a288:	2b0a      	cmp	r3, #10
 801a28a:	d132      	bne.n	801a2f2 <Base64_SkipNewline+0xca>
        j++;
 801a28c:	69bb      	ldr	r3, [r7, #24]
 801a28e:	3301      	adds	r3, #1
 801a290:	61bb      	str	r3, [r7, #24]
        len--;
 801a292:	69fb      	ldr	r3, [r7, #28]
 801a294:	3b01      	subs	r3, #1
 801a296:	61fb      	str	r3, [r7, #28]
        if (curChar == '\r') {
 801a298:	7dfb      	ldrb	r3, [r7, #23]
 801a29a:	2b0d      	cmp	r3, #13
 801a29c:	d10c      	bne.n	801a2b8 <Base64_SkipNewline+0x90>
            if (len) {
 801a29e:	69fb      	ldr	r3, [r7, #28]
 801a2a0:	2b00      	cmp	r3, #0
 801a2a2:	d009      	beq.n	801a2b8 <Base64_SkipNewline+0x90>
                curChar = in[j++];
 801a2a4:	69bb      	ldr	r3, [r7, #24]
 801a2a6:	1c5a      	adds	r2, r3, #1
 801a2a8:	61ba      	str	r2, [r7, #24]
 801a2aa:	68fa      	ldr	r2, [r7, #12]
 801a2ac:	4413      	add	r3, r2
 801a2ae:	781b      	ldrb	r3, [r3, #0]
 801a2b0:	75fb      	strb	r3, [r7, #23]
                len--;
 801a2b2:	69fb      	ldr	r3, [r7, #28]
 801a2b4:	3b01      	subs	r3, #1
 801a2b6:	61fb      	str	r3, [r7, #28]
            }
        }
        if (curChar != '\n') {
 801a2b8:	7dfb      	ldrb	r3, [r7, #23]
 801a2ba:	2b0a      	cmp	r3, #10
 801a2bc:	d002      	beq.n	801a2c4 <Base64_SkipNewline+0x9c>
            WOLFSSL_MSG("Bad end of line in Base64 Decode");
            return ASN_INPUT_E;
 801a2be:	f06f 0399 	mvn.w	r3, #153	@ 0x99
 801a2c2:	e029      	b.n	801a318 <Base64_SkipNewline+0xf0>
        }

        if (len) {
 801a2c4:	69fb      	ldr	r3, [r7, #28]
 801a2c6:	2b00      	cmp	r3, #0
 801a2c8:	d013      	beq.n	801a2f2 <Base64_SkipNewline+0xca>
            curChar = in[j];
 801a2ca:	68fa      	ldr	r2, [r7, #12]
 801a2cc:	69bb      	ldr	r3, [r7, #24]
 801a2ce:	4413      	add	r3, r2
 801a2d0:	781b      	ldrb	r3, [r3, #0]
 801a2d2:	75fb      	strb	r3, [r7, #23]
        }
    }
    while (len && curChar == ' ') {
 801a2d4:	e00d      	b.n	801a2f2 <Base64_SkipNewline+0xca>
        if (--len > 0) {
 801a2d6:	69fb      	ldr	r3, [r7, #28]
 801a2d8:	3b01      	subs	r3, #1
 801a2da:	61fb      	str	r3, [r7, #28]
 801a2dc:	69fb      	ldr	r3, [r7, #28]
 801a2de:	2b00      	cmp	r3, #0
 801a2e0:	d007      	beq.n	801a2f2 <Base64_SkipNewline+0xca>
            curChar = in[++j];
 801a2e2:	69bb      	ldr	r3, [r7, #24]
 801a2e4:	3301      	adds	r3, #1
 801a2e6:	61bb      	str	r3, [r7, #24]
 801a2e8:	68fa      	ldr	r2, [r7, #12]
 801a2ea:	69bb      	ldr	r3, [r7, #24]
 801a2ec:	4413      	add	r3, r2
 801a2ee:	781b      	ldrb	r3, [r3, #0]
 801a2f0:	75fb      	strb	r3, [r7, #23]
    while (len && curChar == ' ') {
 801a2f2:	69fb      	ldr	r3, [r7, #28]
 801a2f4:	2b00      	cmp	r3, #0
 801a2f6:	d002      	beq.n	801a2fe <Base64_SkipNewline+0xd6>
 801a2f8:	7dfb      	ldrb	r3, [r7, #23]
 801a2fa:	2b20      	cmp	r3, #32
 801a2fc:	d0eb      	beq.n	801a2d6 <Base64_SkipNewline+0xae>
        }
    }
    if (!len) {
 801a2fe:	69fb      	ldr	r3, [r7, #28]
 801a300:	2b00      	cmp	r3, #0
 801a302:	d102      	bne.n	801a30a <Base64_SkipNewline+0xe2>
        return BUFFER_E;
 801a304:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 801a308:	e006      	b.n	801a318 <Base64_SkipNewline+0xf0>
    }
    *inLen = len;
 801a30a:	68bb      	ldr	r3, [r7, #8]
 801a30c:	69fa      	ldr	r2, [r7, #28]
 801a30e:	601a      	str	r2, [r3, #0]
    *outJ = j;
 801a310:	687b      	ldr	r3, [r7, #4]
 801a312:	69ba      	ldr	r2, [r7, #24]
 801a314:	601a      	str	r2, [r3, #0]
    return 0;
 801a316:	2300      	movs	r3, #0
}
 801a318:	4618      	mov	r0, r3
 801a31a:	3724      	adds	r7, #36	@ 0x24
 801a31c:	46bd      	mov	sp, r7
 801a31e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a322:	4770      	bx	lr

0801a324 <Base64_Decode>:

int Base64_Decode(const byte* in, word32 inLen, byte* out, word32* outLen)
{
 801a324:	b580      	push	{r7, lr}
 801a326:	b08e      	sub	sp, #56	@ 0x38
 801a328:	af00      	add	r7, sp, #0
 801a32a:	60f8      	str	r0, [r7, #12]
 801a32c:	60b9      	str	r1, [r7, #8]
 801a32e:	607a      	str	r2, [r7, #4]
 801a330:	603b      	str	r3, [r7, #0]
    word32 i = 0;
 801a332:	2300      	movs	r3, #0
 801a334:	637b      	str	r3, [r7, #52]	@ 0x34
    word32 j = 0;
 801a336:	2300      	movs	r3, #0
 801a338:	617b      	str	r3, [r7, #20]
    word32 plainSz = inLen - ((inLen + (BASE64_LINE_SZ - 1)) / BASE64_LINE_SZ );
 801a33a:	68ba      	ldr	r2, [r7, #8]
 801a33c:	68bb      	ldr	r3, [r7, #8]
 801a33e:	333f      	adds	r3, #63	@ 0x3f
 801a340:	099b      	lsrs	r3, r3, #6
 801a342:	1ad3      	subs	r3, r2, r3
 801a344:	62bb      	str	r3, [r7, #40]	@ 0x28
    int ret;
#ifndef BASE64_NO_TABLE
    const byte maxIdx = BASE64DECODE_SZ + BASE64_MIN - 1;
 801a346:	237a      	movs	r3, #122	@ 0x7a
 801a348:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
#endif

    plainSz = (plainSz * 3 + 3) / 4;
 801a34c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801a34e:	1c5a      	adds	r2, r3, #1
 801a350:	4613      	mov	r3, r2
 801a352:	005b      	lsls	r3, r3, #1
 801a354:	4413      	add	r3, r2
 801a356:	089b      	lsrs	r3, r3, #2
 801a358:	62bb      	str	r3, [r7, #40]	@ 0x28
    if (plainSz > *outLen) return BAD_FUNC_ARG;
 801a35a:	683b      	ldr	r3, [r7, #0]
 801a35c:	681b      	ldr	r3, [r3, #0]
 801a35e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801a360:	429a      	cmp	r2, r3
 801a362:	f240 812c 	bls.w	801a5be <Base64_Decode+0x29a>
 801a366:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801a36a:	e143      	b.n	801a5f4 <Base64_Decode+0x2d0>

    while (inLen > 3) {
        int pad3 = 0;
 801a36c:	2300      	movs	r3, #0
 801a36e:	633b      	str	r3, [r7, #48]	@ 0x30
        int pad4 = 0;
 801a370:	2300      	movs	r3, #0
 801a372:	62fb      	str	r3, [r7, #44]	@ 0x2c
        byte b1, b2, b3;
        byte e1, e2, e3, e4;

        if ((ret = Base64_SkipNewline(in, &inLen, &j)) != 0) {
 801a374:	f107 0214 	add.w	r2, r7, #20
 801a378:	f107 0308 	add.w	r3, r7, #8
 801a37c:	4619      	mov	r1, r3
 801a37e:	68f8      	ldr	r0, [r7, #12]
 801a380:	f7ff ff52 	bl	801a228 <Base64_SkipNewline>
 801a384:	6238      	str	r0, [r7, #32]
 801a386:	6a3b      	ldr	r3, [r7, #32]
 801a388:	2b00      	cmp	r3, #0
 801a38a:	d006      	beq.n	801a39a <Base64_Decode+0x76>
            if (ret == WC_NO_ERR_TRACE(BUFFER_E)) {
 801a38c:	6a3b      	ldr	r3, [r7, #32]
 801a38e:	f113 0f84 	cmn.w	r3, #132	@ 0x84
 801a392:	f000 8119 	beq.w	801a5c8 <Base64_Decode+0x2a4>
                /* Running out of buffer here is not an error */
                break;
            }
            return ret;
 801a396:	6a3b      	ldr	r3, [r7, #32]
 801a398:	e12c      	b.n	801a5f4 <Base64_Decode+0x2d0>
        }
        e1 = in[j++];
 801a39a:	697b      	ldr	r3, [r7, #20]
 801a39c:	1c5a      	adds	r2, r3, #1
 801a39e:	617a      	str	r2, [r7, #20]
 801a3a0:	68fa      	ldr	r2, [r7, #12]
 801a3a2:	4413      	add	r3, r2
 801a3a4:	781b      	ldrb	r3, [r3, #0]
 801a3a6:	77fb      	strb	r3, [r7, #31]
        if (e1 == '\0') {
 801a3a8:	7ffb      	ldrb	r3, [r7, #31]
 801a3aa:	2b00      	cmp	r3, #0
 801a3ac:	f000 810e 	beq.w	801a5cc <Base64_Decode+0x2a8>
            break;
        }
        inLen--;
 801a3b0:	68bb      	ldr	r3, [r7, #8]
 801a3b2:	3b01      	subs	r3, #1
 801a3b4:	60bb      	str	r3, [r7, #8]
        if ((ret = Base64_SkipNewline(in, &inLen, &j)) != 0) {
 801a3b6:	f107 0214 	add.w	r2, r7, #20
 801a3ba:	f107 0308 	add.w	r3, r7, #8
 801a3be:	4619      	mov	r1, r3
 801a3c0:	68f8      	ldr	r0, [r7, #12]
 801a3c2:	f7ff ff31 	bl	801a228 <Base64_SkipNewline>
 801a3c6:	6238      	str	r0, [r7, #32]
 801a3c8:	6a3b      	ldr	r3, [r7, #32]
 801a3ca:	2b00      	cmp	r3, #0
 801a3cc:	d001      	beq.n	801a3d2 <Base64_Decode+0xae>
            return ret;
 801a3ce:	6a3b      	ldr	r3, [r7, #32]
 801a3d0:	e110      	b.n	801a5f4 <Base64_Decode+0x2d0>
        }
        e2 = in[j++];
 801a3d2:	697b      	ldr	r3, [r7, #20]
 801a3d4:	1c5a      	adds	r2, r3, #1
 801a3d6:	617a      	str	r2, [r7, #20]
 801a3d8:	68fa      	ldr	r2, [r7, #12]
 801a3da:	4413      	add	r3, r2
 801a3dc:	781b      	ldrb	r3, [r3, #0]
 801a3de:	77bb      	strb	r3, [r7, #30]
        inLen--;
 801a3e0:	68bb      	ldr	r3, [r7, #8]
 801a3e2:	3b01      	subs	r3, #1
 801a3e4:	60bb      	str	r3, [r7, #8]
        if ((ret = Base64_SkipNewline(in, &inLen, &j)) != 0) {
 801a3e6:	f107 0214 	add.w	r2, r7, #20
 801a3ea:	f107 0308 	add.w	r3, r7, #8
 801a3ee:	4619      	mov	r1, r3
 801a3f0:	68f8      	ldr	r0, [r7, #12]
 801a3f2:	f7ff ff19 	bl	801a228 <Base64_SkipNewline>
 801a3f6:	6238      	str	r0, [r7, #32]
 801a3f8:	6a3b      	ldr	r3, [r7, #32]
 801a3fa:	2b00      	cmp	r3, #0
 801a3fc:	d001      	beq.n	801a402 <Base64_Decode+0xde>
            return ret;
 801a3fe:	6a3b      	ldr	r3, [r7, #32]
 801a400:	e0f8      	b.n	801a5f4 <Base64_Decode+0x2d0>
        }
        e3 = in[j++];
 801a402:	697b      	ldr	r3, [r7, #20]
 801a404:	1c5a      	adds	r2, r3, #1
 801a406:	617a      	str	r2, [r7, #20]
 801a408:	68fa      	ldr	r2, [r7, #12]
 801a40a:	4413      	add	r3, r2
 801a40c:	781b      	ldrb	r3, [r3, #0]
 801a40e:	777b      	strb	r3, [r7, #29]
        inLen--;
 801a410:	68bb      	ldr	r3, [r7, #8]
 801a412:	3b01      	subs	r3, #1
 801a414:	60bb      	str	r3, [r7, #8]
        if ((ret = Base64_SkipNewline(in, &inLen, &j)) != 0) {
 801a416:	f107 0214 	add.w	r2, r7, #20
 801a41a:	f107 0308 	add.w	r3, r7, #8
 801a41e:	4619      	mov	r1, r3
 801a420:	68f8      	ldr	r0, [r7, #12]
 801a422:	f7ff ff01 	bl	801a228 <Base64_SkipNewline>
 801a426:	6238      	str	r0, [r7, #32]
 801a428:	6a3b      	ldr	r3, [r7, #32]
 801a42a:	2b00      	cmp	r3, #0
 801a42c:	d001      	beq.n	801a432 <Base64_Decode+0x10e>
            return ret;
 801a42e:	6a3b      	ldr	r3, [r7, #32]
 801a430:	e0e0      	b.n	801a5f4 <Base64_Decode+0x2d0>
        }
        e4 = in[j++];
 801a432:	697b      	ldr	r3, [r7, #20]
 801a434:	1c5a      	adds	r2, r3, #1
 801a436:	617a      	str	r2, [r7, #20]
 801a438:	68fa      	ldr	r2, [r7, #12]
 801a43a:	4413      	add	r3, r2
 801a43c:	781b      	ldrb	r3, [r3, #0]
 801a43e:	773b      	strb	r3, [r7, #28]
        inLen--;
 801a440:	68bb      	ldr	r3, [r7, #8]
 801a442:	3b01      	subs	r3, #1
 801a444:	60bb      	str	r3, [r7, #8]

        if (e3 == PAD)
 801a446:	7f7b      	ldrb	r3, [r7, #29]
 801a448:	2b3d      	cmp	r3, #61	@ 0x3d
 801a44a:	d101      	bne.n	801a450 <Base64_Decode+0x12c>
            pad3 = 1;
 801a44c:	2301      	movs	r3, #1
 801a44e:	633b      	str	r3, [r7, #48]	@ 0x30
        if (e4 == PAD)
 801a450:	7f3b      	ldrb	r3, [r7, #28]
 801a452:	2b3d      	cmp	r3, #61	@ 0x3d
 801a454:	d101      	bne.n	801a45a <Base64_Decode+0x136>
            pad4 = 1;
 801a456:	2301      	movs	r3, #1
 801a458:	62fb      	str	r3, [r7, #44]	@ 0x2c

        if (pad3 && !pad4)
 801a45a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801a45c:	2b00      	cmp	r3, #0
 801a45e:	d005      	beq.n	801a46c <Base64_Decode+0x148>
 801a460:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801a462:	2b00      	cmp	r3, #0
 801a464:	d102      	bne.n	801a46c <Base64_Decode+0x148>
            return ASN_INPUT_E;
 801a466:	f06f 0399 	mvn.w	r3, #153	@ 0x99
 801a46a:	e0c3      	b.n	801a5f4 <Base64_Decode+0x2d0>

#ifndef BASE64_NO_TABLE
        if (e1 < BASE64_MIN || e2 < BASE64_MIN || e3 < BASE64_MIN ||
 801a46c:	7ffb      	ldrb	r3, [r7, #31]
 801a46e:	2b2a      	cmp	r3, #42	@ 0x2a
 801a470:	d908      	bls.n	801a484 <Base64_Decode+0x160>
 801a472:	7fbb      	ldrb	r3, [r7, #30]
 801a474:	2b2a      	cmp	r3, #42	@ 0x2a
 801a476:	d905      	bls.n	801a484 <Base64_Decode+0x160>
 801a478:	7f7b      	ldrb	r3, [r7, #29]
 801a47a:	2b2a      	cmp	r3, #42	@ 0x2a
 801a47c:	d902      	bls.n	801a484 <Base64_Decode+0x160>
 801a47e:	7f3b      	ldrb	r3, [r7, #28]
 801a480:	2b2a      	cmp	r3, #42	@ 0x2a
 801a482:	d802      	bhi.n	801a48a <Base64_Decode+0x166>
                                                              e4 < BASE64_MIN) {
            WOLFSSL_MSG("Bad Base64 Decode data, too small");
            return ASN_INPUT_E;
 801a484:	f06f 0399 	mvn.w	r3, #153	@ 0x99
 801a488:	e0b4      	b.n	801a5f4 <Base64_Decode+0x2d0>
        }

        if (e1 > maxIdx || e2 > maxIdx || e3 > maxIdx || e4 > maxIdx) {
 801a48a:	7ffa      	ldrb	r2, [r7, #31]
 801a48c:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 801a490:	429a      	cmp	r2, r3
 801a492:	d80e      	bhi.n	801a4b2 <Base64_Decode+0x18e>
 801a494:	7fba      	ldrb	r2, [r7, #30]
 801a496:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 801a49a:	429a      	cmp	r2, r3
 801a49c:	d809      	bhi.n	801a4b2 <Base64_Decode+0x18e>
 801a49e:	7f7a      	ldrb	r2, [r7, #29]
 801a4a0:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 801a4a4:	429a      	cmp	r2, r3
 801a4a6:	d804      	bhi.n	801a4b2 <Base64_Decode+0x18e>
 801a4a8:	7f3a      	ldrb	r2, [r7, #28]
 801a4aa:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 801a4ae:	429a      	cmp	r2, r3
 801a4b0:	d902      	bls.n	801a4b8 <Base64_Decode+0x194>
            WOLFSSL_MSG("Bad Base64 Decode data, too big");
            return ASN_INPUT_E;
 801a4b2:	f06f 0399 	mvn.w	r3, #153	@ 0x99
 801a4b6:	e09d      	b.n	801a5f4 <Base64_Decode+0x2d0>
        }
#endif

        if (i + 1 + !pad3 + !pad4 > *outLen) {
 801a4b8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801a4ba:	2b00      	cmp	r3, #0
 801a4bc:	bf0c      	ite	eq
 801a4be:	2301      	moveq	r3, #1
 801a4c0:	2300      	movne	r3, #0
 801a4c2:	b2db      	uxtb	r3, r3
 801a4c4:	461a      	mov	r2, r3
 801a4c6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801a4c8:	4413      	add	r3, r2
 801a4ca:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801a4cc:	2a00      	cmp	r2, #0
 801a4ce:	bf0c      	ite	eq
 801a4d0:	2201      	moveq	r2, #1
 801a4d2:	2200      	movne	r2, #0
 801a4d4:	b2d2      	uxtb	r2, r2
 801a4d6:	4413      	add	r3, r2
 801a4d8:	1c5a      	adds	r2, r3, #1
 801a4da:	683b      	ldr	r3, [r7, #0]
 801a4dc:	681b      	ldr	r3, [r3, #0]
 801a4de:	429a      	cmp	r2, r3
 801a4e0:	d902      	bls.n	801a4e8 <Base64_Decode+0x1c4>
            WOLFSSL_MSG("Bad Base64 Decode out buffer, too small");
            return BAD_FUNC_ARG;
 801a4e2:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801a4e6:	e085      	b.n	801a5f4 <Base64_Decode+0x2d0>
        }

        e1 = Base64_Char2Val(e1);
 801a4e8:	7ffb      	ldrb	r3, [r7, #31]
 801a4ea:	4618      	mov	r0, r3
 801a4ec:	f7ff fe68 	bl	801a1c0 <Base64_Char2Val>
 801a4f0:	4603      	mov	r3, r0
 801a4f2:	77fb      	strb	r3, [r7, #31]
        e2 = Base64_Char2Val(e2);
 801a4f4:	7fbb      	ldrb	r3, [r7, #30]
 801a4f6:	4618      	mov	r0, r3
 801a4f8:	f7ff fe62 	bl	801a1c0 <Base64_Char2Val>
 801a4fc:	4603      	mov	r3, r0
 801a4fe:	77bb      	strb	r3, [r7, #30]
        e3 = (byte)((e3 == PAD) ? 0 : Base64_Char2Val(e3));
 801a500:	7f7b      	ldrb	r3, [r7, #29]
 801a502:	2b3d      	cmp	r3, #61	@ 0x3d
 801a504:	d005      	beq.n	801a512 <Base64_Decode+0x1ee>
 801a506:	7f7b      	ldrb	r3, [r7, #29]
 801a508:	4618      	mov	r0, r3
 801a50a:	f7ff fe59 	bl	801a1c0 <Base64_Char2Val>
 801a50e:	4603      	mov	r3, r0
 801a510:	e000      	b.n	801a514 <Base64_Decode+0x1f0>
 801a512:	2300      	movs	r3, #0
 801a514:	777b      	strb	r3, [r7, #29]
        e4 = (byte)((e4 == PAD) ? 0 : Base64_Char2Val(e4));
 801a516:	7f3b      	ldrb	r3, [r7, #28]
 801a518:	2b3d      	cmp	r3, #61	@ 0x3d
 801a51a:	d005      	beq.n	801a528 <Base64_Decode+0x204>
 801a51c:	7f3b      	ldrb	r3, [r7, #28]
 801a51e:	4618      	mov	r0, r3
 801a520:	f7ff fe4e 	bl	801a1c0 <Base64_Char2Val>
 801a524:	4603      	mov	r3, r0
 801a526:	e000      	b.n	801a52a <Base64_Decode+0x206>
 801a528:	2300      	movs	r3, #0
 801a52a:	773b      	strb	r3, [r7, #28]

        if (e1 == BAD || e2 == BAD || e3 == BAD || e4 == BAD) {
 801a52c:	7ffb      	ldrb	r3, [r7, #31]
 801a52e:	2bff      	cmp	r3, #255	@ 0xff
 801a530:	d008      	beq.n	801a544 <Base64_Decode+0x220>
 801a532:	7fbb      	ldrb	r3, [r7, #30]
 801a534:	2bff      	cmp	r3, #255	@ 0xff
 801a536:	d005      	beq.n	801a544 <Base64_Decode+0x220>
 801a538:	7f7b      	ldrb	r3, [r7, #29]
 801a53a:	2bff      	cmp	r3, #255	@ 0xff
 801a53c:	d002      	beq.n	801a544 <Base64_Decode+0x220>
 801a53e:	7f3b      	ldrb	r3, [r7, #28]
 801a540:	2bff      	cmp	r3, #255	@ 0xff
 801a542:	d102      	bne.n	801a54a <Base64_Decode+0x226>
            WOLFSSL_MSG("Bad Base64 Decode bad character");
            return ASN_INPUT_E;
 801a544:	f06f 0399 	mvn.w	r3, #153	@ 0x99
 801a548:	e054      	b.n	801a5f4 <Base64_Decode+0x2d0>
        }

        b1 = (byte)((e1 << 2) | (e2 >> 4));
 801a54a:	f997 301f 	ldrsb.w	r3, [r7, #31]
 801a54e:	009b      	lsls	r3, r3, #2
 801a550:	b25a      	sxtb	r2, r3
 801a552:	7fbb      	ldrb	r3, [r7, #30]
 801a554:	091b      	lsrs	r3, r3, #4
 801a556:	b2db      	uxtb	r3, r3
 801a558:	b25b      	sxtb	r3, r3
 801a55a:	4313      	orrs	r3, r2
 801a55c:	b25b      	sxtb	r3, r3
 801a55e:	76fb      	strb	r3, [r7, #27]
        b2 = (byte)(((e2 & 0xF) << 4) | (e3 >> 2));
 801a560:	f997 301e 	ldrsb.w	r3, [r7, #30]
 801a564:	011b      	lsls	r3, r3, #4
 801a566:	b25a      	sxtb	r2, r3
 801a568:	7f7b      	ldrb	r3, [r7, #29]
 801a56a:	089b      	lsrs	r3, r3, #2
 801a56c:	b2db      	uxtb	r3, r3
 801a56e:	b25b      	sxtb	r3, r3
 801a570:	4313      	orrs	r3, r2
 801a572:	b25b      	sxtb	r3, r3
 801a574:	76bb      	strb	r3, [r7, #26]
        b3 = (byte)(((e3 & 0x3) << 6) | e4);
 801a576:	f997 301d 	ldrsb.w	r3, [r7, #29]
 801a57a:	019b      	lsls	r3, r3, #6
 801a57c:	b25a      	sxtb	r2, r3
 801a57e:	f997 301c 	ldrsb.w	r3, [r7, #28]
 801a582:	4313      	orrs	r3, r2
 801a584:	b25b      	sxtb	r3, r3
 801a586:	767b      	strb	r3, [r7, #25]

        out[i++] = b1;
 801a588:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801a58a:	1c5a      	adds	r2, r3, #1
 801a58c:	637a      	str	r2, [r7, #52]	@ 0x34
 801a58e:	687a      	ldr	r2, [r7, #4]
 801a590:	4413      	add	r3, r2
 801a592:	7efa      	ldrb	r2, [r7, #27]
 801a594:	701a      	strb	r2, [r3, #0]
        if (!pad3)
 801a596:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801a598:	2b00      	cmp	r3, #0
 801a59a:	d106      	bne.n	801a5aa <Base64_Decode+0x286>
            out[i++] = b2;
 801a59c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801a59e:	1c5a      	adds	r2, r3, #1
 801a5a0:	637a      	str	r2, [r7, #52]	@ 0x34
 801a5a2:	687a      	ldr	r2, [r7, #4]
 801a5a4:	4413      	add	r3, r2
 801a5a6:	7eba      	ldrb	r2, [r7, #26]
 801a5a8:	701a      	strb	r2, [r3, #0]
        if (!pad4)
 801a5aa:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801a5ac:	2b00      	cmp	r3, #0
 801a5ae:	d10f      	bne.n	801a5d0 <Base64_Decode+0x2ac>
            out[i++] = b3;
 801a5b0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801a5b2:	1c5a      	adds	r2, r3, #1
 801a5b4:	637a      	str	r2, [r7, #52]	@ 0x34
 801a5b6:	687a      	ldr	r2, [r7, #4]
 801a5b8:	4413      	add	r3, r2
 801a5ba:	7e7a      	ldrb	r2, [r7, #25]
 801a5bc:	701a      	strb	r2, [r3, #0]
    while (inLen > 3) {
 801a5be:	68bb      	ldr	r3, [r7, #8]
 801a5c0:	2b03      	cmp	r3, #3
 801a5c2:	f63f aed3 	bhi.w	801a36c <Base64_Decode+0x48>
 801a5c6:	e004      	b.n	801a5d2 <Base64_Decode+0x2ae>
                break;
 801a5c8:	bf00      	nop
 801a5ca:	e002      	b.n	801a5d2 <Base64_Decode+0x2ae>
            break;
 801a5cc:	bf00      	nop
 801a5ce:	e000      	b.n	801a5d2 <Base64_Decode+0x2ae>
        else
            break;
 801a5d0:	bf00      	nop
    }
/* If the output buffer has a room for an extra byte, add a null terminator */
    if (out && *outLen > i)
 801a5d2:	687b      	ldr	r3, [r7, #4]
 801a5d4:	2b00      	cmp	r3, #0
 801a5d6:	d009      	beq.n	801a5ec <Base64_Decode+0x2c8>
 801a5d8:	683b      	ldr	r3, [r7, #0]
 801a5da:	681b      	ldr	r3, [r3, #0]
 801a5dc:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 801a5de:	429a      	cmp	r2, r3
 801a5e0:	d204      	bcs.n	801a5ec <Base64_Decode+0x2c8>
        out[i]= '\0';
 801a5e2:	687a      	ldr	r2, [r7, #4]
 801a5e4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801a5e6:	4413      	add	r3, r2
 801a5e8:	2200      	movs	r2, #0
 801a5ea:	701a      	strb	r2, [r3, #0]

    *outLen = i;
 801a5ec:	683b      	ldr	r3, [r7, #0]
 801a5ee:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 801a5f0:	601a      	str	r2, [r3, #0]

    return 0;
 801a5f2:	2300      	movs	r3, #0
}
 801a5f4:	4618      	mov	r0, r3
 801a5f6:	3738      	adds	r7, #56	@ 0x38
 801a5f8:	46bd      	mov	sp, r7
 801a5fa:	bd80      	pop	{r7, pc}

0801a5fc <Base16_Decode>:
                           BAD, BAD,  /* G - ` */
                           10, 11, 12, 13, 14, 15   /* lower case a-f */
                         };  /* A starts at 0x41 not 0x3A */

int Base16_Decode(const byte* in, word32 inLen, byte* out, word32* outLen)
{
 801a5fc:	b480      	push	{r7}
 801a5fe:	b089      	sub	sp, #36	@ 0x24
 801a600:	af00      	add	r7, sp, #0
 801a602:	60f8      	str	r0, [r7, #12]
 801a604:	60b9      	str	r1, [r7, #8]
 801a606:	607a      	str	r2, [r7, #4]
 801a608:	603b      	str	r3, [r7, #0]
    word32 inIdx  = 0;
 801a60a:	2300      	movs	r3, #0
 801a60c:	61fb      	str	r3, [r7, #28]
    word32 outIdx = 0;
 801a60e:	2300      	movs	r3, #0
 801a610:	61bb      	str	r3, [r7, #24]

    if (in == NULL || out == NULL || outLen == NULL)
 801a612:	68fb      	ldr	r3, [r7, #12]
 801a614:	2b00      	cmp	r3, #0
 801a616:	d005      	beq.n	801a624 <Base16_Decode+0x28>
 801a618:	687b      	ldr	r3, [r7, #4]
 801a61a:	2b00      	cmp	r3, #0
 801a61c:	d002      	beq.n	801a624 <Base16_Decode+0x28>
 801a61e:	683b      	ldr	r3, [r7, #0]
 801a620:	2b00      	cmp	r3, #0
 801a622:	d102      	bne.n	801a62a <Base16_Decode+0x2e>
        return BAD_FUNC_ARG;
 801a624:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801a628:	e084      	b.n	801a734 <Base16_Decode+0x138>

    if (inLen == 1 && *outLen && in) {
 801a62a:	68bb      	ldr	r3, [r7, #8]
 801a62c:	2b01      	cmp	r3, #1
 801a62e:	d12a      	bne.n	801a686 <Base16_Decode+0x8a>
 801a630:	683b      	ldr	r3, [r7, #0]
 801a632:	681b      	ldr	r3, [r3, #0]
 801a634:	2b00      	cmp	r3, #0
 801a636:	d026      	beq.n	801a686 <Base16_Decode+0x8a>
 801a638:	68fb      	ldr	r3, [r7, #12]
 801a63a:	2b00      	cmp	r3, #0
 801a63c:	d023      	beq.n	801a686 <Base16_Decode+0x8a>
        byte b = (byte)(in[inIdx++] - BASE16_MIN);  /* 0 starts at 0x30 */
 801a63e:	69fb      	ldr	r3, [r7, #28]
 801a640:	1c5a      	adds	r2, r3, #1
 801a642:	61fa      	str	r2, [r7, #28]
 801a644:	68fa      	ldr	r2, [r7, #12]
 801a646:	4413      	add	r3, r2
 801a648:	781b      	ldrb	r3, [r3, #0]
 801a64a:	3b30      	subs	r3, #48	@ 0x30
 801a64c:	75fb      	strb	r3, [r7, #23]

        /* sanity check */
        if (b >=  sizeof(hexDecode)/sizeof(hexDecode[0]))
 801a64e:	7dfb      	ldrb	r3, [r7, #23]
 801a650:	2b36      	cmp	r3, #54	@ 0x36
 801a652:	d902      	bls.n	801a65a <Base16_Decode+0x5e>
            return ASN_INPUT_E;
 801a654:	f06f 0399 	mvn.w	r3, #153	@ 0x99
 801a658:	e06c      	b.n	801a734 <Base16_Decode+0x138>

        b  = hexDecode[b];
 801a65a:	7dfb      	ldrb	r3, [r7, #23]
 801a65c:	4a38      	ldr	r2, [pc, #224]	@ (801a740 <Base16_Decode+0x144>)
 801a65e:	5cd3      	ldrb	r3, [r2, r3]
 801a660:	75fb      	strb	r3, [r7, #23]

        if (b == BAD)
 801a662:	7dfb      	ldrb	r3, [r7, #23]
 801a664:	2bff      	cmp	r3, #255	@ 0xff
 801a666:	d102      	bne.n	801a66e <Base16_Decode+0x72>
            return ASN_INPUT_E;
 801a668:	f06f 0399 	mvn.w	r3, #153	@ 0x99
 801a66c:	e062      	b.n	801a734 <Base16_Decode+0x138>

        out[outIdx++] = b;
 801a66e:	69bb      	ldr	r3, [r7, #24]
 801a670:	1c5a      	adds	r2, r3, #1
 801a672:	61ba      	str	r2, [r7, #24]
 801a674:	687a      	ldr	r2, [r7, #4]
 801a676:	4413      	add	r3, r2
 801a678:	7dfa      	ldrb	r2, [r7, #23]
 801a67a:	701a      	strb	r2, [r3, #0]

        *outLen = outIdx;
 801a67c:	683b      	ldr	r3, [r7, #0]
 801a67e:	69ba      	ldr	r2, [r7, #24]
 801a680:	601a      	str	r2, [r3, #0]
        return 0;
 801a682:	2300      	movs	r3, #0
 801a684:	e056      	b.n	801a734 <Base16_Decode+0x138>
    }

    if (inLen % 2)
 801a686:	68bb      	ldr	r3, [r7, #8]
 801a688:	f003 0301 	and.w	r3, r3, #1
 801a68c:	2b00      	cmp	r3, #0
 801a68e:	d002      	beq.n	801a696 <Base16_Decode+0x9a>
        return BAD_FUNC_ARG;
 801a690:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801a694:	e04e      	b.n	801a734 <Base16_Decode+0x138>

    if (*outLen < (inLen / 2))
 801a696:	683b      	ldr	r3, [r7, #0]
 801a698:	681a      	ldr	r2, [r3, #0]
 801a69a:	68bb      	ldr	r3, [r7, #8]
 801a69c:	085b      	lsrs	r3, r3, #1
 801a69e:	429a      	cmp	r2, r3
 801a6a0:	d241      	bcs.n	801a726 <Base16_Decode+0x12a>
        return BAD_FUNC_ARG;
 801a6a2:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801a6a6:	e045      	b.n	801a734 <Base16_Decode+0x138>

    while (inLen) {
        byte b  = (byte)(in[inIdx++] - BASE16_MIN);  /* 0 starts at 0x30 */
 801a6a8:	69fb      	ldr	r3, [r7, #28]
 801a6aa:	1c5a      	adds	r2, r3, #1
 801a6ac:	61fa      	str	r2, [r7, #28]
 801a6ae:	68fa      	ldr	r2, [r7, #12]
 801a6b0:	4413      	add	r3, r2
 801a6b2:	781b      	ldrb	r3, [r3, #0]
 801a6b4:	3b30      	subs	r3, #48	@ 0x30
 801a6b6:	75bb      	strb	r3, [r7, #22]
        byte b2 = (byte)(in[inIdx++] - BASE16_MIN);
 801a6b8:	69fb      	ldr	r3, [r7, #28]
 801a6ba:	1c5a      	adds	r2, r3, #1
 801a6bc:	61fa      	str	r2, [r7, #28]
 801a6be:	68fa      	ldr	r2, [r7, #12]
 801a6c0:	4413      	add	r3, r2
 801a6c2:	781b      	ldrb	r3, [r3, #0]
 801a6c4:	3b30      	subs	r3, #48	@ 0x30
 801a6c6:	757b      	strb	r3, [r7, #21]

        /* sanity checks */
        if (b >=  sizeof(hexDecode)/sizeof(hexDecode[0]))
 801a6c8:	7dbb      	ldrb	r3, [r7, #22]
 801a6ca:	2b36      	cmp	r3, #54	@ 0x36
 801a6cc:	d902      	bls.n	801a6d4 <Base16_Decode+0xd8>
            return ASN_INPUT_E;
 801a6ce:	f06f 0399 	mvn.w	r3, #153	@ 0x99
 801a6d2:	e02f      	b.n	801a734 <Base16_Decode+0x138>
        if (b2 >= sizeof(hexDecode)/sizeof(hexDecode[0]))
 801a6d4:	7d7b      	ldrb	r3, [r7, #21]
 801a6d6:	2b36      	cmp	r3, #54	@ 0x36
 801a6d8:	d902      	bls.n	801a6e0 <Base16_Decode+0xe4>
            return ASN_INPUT_E;
 801a6da:	f06f 0399 	mvn.w	r3, #153	@ 0x99
 801a6de:	e029      	b.n	801a734 <Base16_Decode+0x138>

        b  = hexDecode[b];
 801a6e0:	7dbb      	ldrb	r3, [r7, #22]
 801a6e2:	4a17      	ldr	r2, [pc, #92]	@ (801a740 <Base16_Decode+0x144>)
 801a6e4:	5cd3      	ldrb	r3, [r2, r3]
 801a6e6:	75bb      	strb	r3, [r7, #22]
        b2 = hexDecode[b2];
 801a6e8:	7d7b      	ldrb	r3, [r7, #21]
 801a6ea:	4a15      	ldr	r2, [pc, #84]	@ (801a740 <Base16_Decode+0x144>)
 801a6ec:	5cd3      	ldrb	r3, [r2, r3]
 801a6ee:	757b      	strb	r3, [r7, #21]

        if (b == BAD || b2 == BAD)
 801a6f0:	7dbb      	ldrb	r3, [r7, #22]
 801a6f2:	2bff      	cmp	r3, #255	@ 0xff
 801a6f4:	d002      	beq.n	801a6fc <Base16_Decode+0x100>
 801a6f6:	7d7b      	ldrb	r3, [r7, #21]
 801a6f8:	2bff      	cmp	r3, #255	@ 0xff
 801a6fa:	d102      	bne.n	801a702 <Base16_Decode+0x106>
            return ASN_INPUT_E;
 801a6fc:	f06f 0399 	mvn.w	r3, #153	@ 0x99
 801a700:	e018      	b.n	801a734 <Base16_Decode+0x138>

        out[outIdx++] = (byte)((b << 4) | b2);
 801a702:	f997 3016 	ldrsb.w	r3, [r7, #22]
 801a706:	011b      	lsls	r3, r3, #4
 801a708:	b25a      	sxtb	r2, r3
 801a70a:	f997 3015 	ldrsb.w	r3, [r7, #21]
 801a70e:	4313      	orrs	r3, r2
 801a710:	b259      	sxtb	r1, r3
 801a712:	69bb      	ldr	r3, [r7, #24]
 801a714:	1c5a      	adds	r2, r3, #1
 801a716:	61ba      	str	r2, [r7, #24]
 801a718:	687a      	ldr	r2, [r7, #4]
 801a71a:	4413      	add	r3, r2
 801a71c:	b2ca      	uxtb	r2, r1
 801a71e:	701a      	strb	r2, [r3, #0]
        inLen -= 2;
 801a720:	68bb      	ldr	r3, [r7, #8]
 801a722:	3b02      	subs	r3, #2
 801a724:	60bb      	str	r3, [r7, #8]
    while (inLen) {
 801a726:	68bb      	ldr	r3, [r7, #8]
 801a728:	2b00      	cmp	r3, #0
 801a72a:	d1bd      	bne.n	801a6a8 <Base16_Decode+0xac>
    }

    *outLen = outIdx;
 801a72c:	683b      	ldr	r3, [r7, #0]
 801a72e:	69ba      	ldr	r2, [r7, #24]
 801a730:	601a      	str	r2, [r3, #0]
    return 0;
 801a732:	2300      	movs	r3, #0
}
 801a734:	4618      	mov	r0, r3
 801a736:	3724      	adds	r7, #36	@ 0x24
 801a738:	46bd      	mov	sp, r7
 801a73a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a73e:	4770      	bx	lr
 801a740:	08033ad8 	.word	0x08033ad8

0801a744 <wc_FreeDhKey>:
    return wc_InitDhKey_ex(key, NULL, INVALID_DEVID);
}


int wc_FreeDhKey(DhKey* key)
{
 801a744:	b580      	push	{r7, lr}
 801a746:	b082      	sub	sp, #8
 801a748:	af00      	add	r7, sp, #0
 801a74a:	6078      	str	r0, [r7, #4]
    if (key) {
 801a74c:	687b      	ldr	r3, [r7, #4]
 801a74e:	2b00      	cmp	r3, #0
 801a750:	d00f      	beq.n	801a772 <wc_FreeDhKey+0x2e>
        mp_clear(&key->p);
 801a752:	687b      	ldr	r3, [r7, #4]
 801a754:	4618      	mov	r0, r3
 801a756:	f00c f826 	bl	80267a6 <mp_clear>
        mp_clear(&key->g);
 801a75a:	687b      	ldr	r3, [r7, #4]
 801a75c:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 801a760:	4618      	mov	r0, r3
 801a762:	f00c f820 	bl	80267a6 <mp_clear>
        mp_clear(&key->q);
 801a766:	687b      	ldr	r3, [r7, #4]
 801a768:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 801a76c:	4618      	mov	r0, r3
 801a76e:	f00c f81a 	bl	80267a6 <mp_clear>
    #endif
    #ifdef WOLFSSL_KCAPI_DH
        KcapiDh_Free(key);
    #endif
    }
    return 0;
 801a772:	2300      	movs	r3, #0
}
 801a774:	4618      	mov	r0, r3
 801a776:	3708      	adds	r7, #8
 801a778:	46bd      	mov	sp, r7
 801a77a:	bd80      	pop	{r7, pc}

0801a77c <ForceZero>:
{
 801a77c:	b480      	push	{r7}
 801a77e:	b085      	sub	sp, #20
 801a780:	af00      	add	r7, sp, #0
 801a782:	6078      	str	r0, [r7, #4]
 801a784:	6039      	str	r1, [r7, #0]
    volatile byte* z = (volatile byte*)mem;
 801a786:	687b      	ldr	r3, [r7, #4]
 801a788:	60fb      	str	r3, [r7, #12]
    while (len--) *z++ = 0;
 801a78a:	e004      	b.n	801a796 <ForceZero+0x1a>
 801a78c:	68fb      	ldr	r3, [r7, #12]
 801a78e:	1c5a      	adds	r2, r3, #1
 801a790:	60fa      	str	r2, [r7, #12]
 801a792:	2200      	movs	r2, #0
 801a794:	701a      	strb	r2, [r3, #0]
 801a796:	683b      	ldr	r3, [r7, #0]
 801a798:	1e5a      	subs	r2, r3, #1
 801a79a:	603a      	str	r2, [r7, #0]
 801a79c:	2b00      	cmp	r3, #0
 801a79e:	d1f5      	bne.n	801a78c <ForceZero+0x10>
}
 801a7a0:	bf00      	nop
 801a7a2:	bf00      	nop
 801a7a4:	3714      	adds	r7, #20
 801a7a6:	46bd      	mov	sp, r7
 801a7a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a7ac:	4770      	bx	lr

0801a7ae <wc_ecc_curve_cache_free_spec_item>:
    #define FREE_CURVE_SPECS() WC_DO_NOTHING
#endif /* ECC_CACHE_CURVE */

static void wc_ecc_curve_cache_free_spec_item(ecc_curve_spec* curve, mp_int* item,
    byte mask)
{
 801a7ae:	b580      	push	{r7, lr}
 801a7b0:	b084      	sub	sp, #16
 801a7b2:	af00      	add	r7, sp, #0
 801a7b4:	60f8      	str	r0, [r7, #12]
 801a7b6:	60b9      	str	r1, [r7, #8]
 801a7b8:	4613      	mov	r3, r2
 801a7ba:	71fb      	strb	r3, [r7, #7]
    if (item) {
 801a7bc:	68bb      	ldr	r3, [r7, #8]
 801a7be:	2b00      	cmp	r3, #0
 801a7c0:	d002      	beq.n	801a7c8 <wc_ecc_curve_cache_free_spec_item+0x1a>
    #ifdef HAVE_WOLF_BIGINT
        wc_bigint_free(&item->raw);
    #endif
        mp_clear(item);
 801a7c2:	68b8      	ldr	r0, [r7, #8]
 801a7c4:	f00b ffef 	bl	80267a6 <mp_clear>
    }
    curve->load_mask = (byte)(curve->load_mask & ~mask);
 801a7c8:	68fb      	ldr	r3, [r7, #12]
 801a7ca:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 801a7ce:	b25a      	sxtb	r2, r3
 801a7d0:	f997 3007 	ldrsb.w	r3, [r7, #7]
 801a7d4:	43db      	mvns	r3, r3
 801a7d6:	b25b      	sxtb	r3, r3
 801a7d8:	4013      	ands	r3, r2
 801a7da:	b25b      	sxtb	r3, r3
 801a7dc:	b2da      	uxtb	r2, r3
 801a7de:	68fb      	ldr	r3, [r7, #12]
 801a7e0:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
}
 801a7e4:	bf00      	nop
 801a7e6:	3710      	adds	r7, #16
 801a7e8:	46bd      	mov	sp, r7
 801a7ea:	bd80      	pop	{r7, pc}

0801a7ec <wc_ecc_curve_cache_free_spec>:
static void wc_ecc_curve_cache_free_spec(ecc_curve_spec* curve)
{
 801a7ec:	b580      	push	{r7, lr}
 801a7ee:	b082      	sub	sp, #8
 801a7f0:	af00      	add	r7, sp, #0
 801a7f2:	6078      	str	r0, [r7, #4]
    if (curve == NULL) {
 801a7f4:	687b      	ldr	r3, [r7, #4]
 801a7f6:	2b00      	cmp	r3, #0
 801a7f8:	d058      	beq.n	801a8ac <wc_ecc_curve_cache_free_spec+0xc0>
        return;
    }

    if (curve->load_mask & ECC_CURVE_FIELD_PRIME)
 801a7fa:	687b      	ldr	r3, [r7, #4]
 801a7fc:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 801a800:	f003 0301 	and.w	r3, r3, #1
 801a804:	2b00      	cmp	r3, #0
 801a806:	d006      	beq.n	801a816 <wc_ecc_curve_cache_free_spec+0x2a>
        wc_ecc_curve_cache_free_spec_item(curve, curve->prime, ECC_CURVE_FIELD_PRIME);
 801a808:	687b      	ldr	r3, [r7, #4]
 801a80a:	685b      	ldr	r3, [r3, #4]
 801a80c:	2201      	movs	r2, #1
 801a80e:	4619      	mov	r1, r3
 801a810:	6878      	ldr	r0, [r7, #4]
 801a812:	f7ff ffcc 	bl	801a7ae <wc_ecc_curve_cache_free_spec_item>
    if (curve->load_mask & ECC_CURVE_FIELD_AF)
 801a816:	687b      	ldr	r3, [r7, #4]
 801a818:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 801a81c:	f003 0302 	and.w	r3, r3, #2
 801a820:	2b00      	cmp	r3, #0
 801a822:	d006      	beq.n	801a832 <wc_ecc_curve_cache_free_spec+0x46>
        wc_ecc_curve_cache_free_spec_item(curve, curve->Af, ECC_CURVE_FIELD_AF);
 801a824:	687b      	ldr	r3, [r7, #4]
 801a826:	689b      	ldr	r3, [r3, #8]
 801a828:	2202      	movs	r2, #2
 801a82a:	4619      	mov	r1, r3
 801a82c:	6878      	ldr	r0, [r7, #4]
 801a82e:	f7ff ffbe 	bl	801a7ae <wc_ecc_curve_cache_free_spec_item>
#ifdef USE_ECC_B_PARAM
    if (curve->load_mask & ECC_CURVE_FIELD_BF)
 801a832:	687b      	ldr	r3, [r7, #4]
 801a834:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 801a838:	f003 0304 	and.w	r3, r3, #4
 801a83c:	2b00      	cmp	r3, #0
 801a83e:	d006      	beq.n	801a84e <wc_ecc_curve_cache_free_spec+0x62>
        wc_ecc_curve_cache_free_spec_item(curve, curve->Bf, ECC_CURVE_FIELD_BF);
 801a840:	687b      	ldr	r3, [r7, #4]
 801a842:	68db      	ldr	r3, [r3, #12]
 801a844:	2204      	movs	r2, #4
 801a846:	4619      	mov	r1, r3
 801a848:	6878      	ldr	r0, [r7, #4]
 801a84a:	f7ff ffb0 	bl	801a7ae <wc_ecc_curve_cache_free_spec_item>
#endif
    if (curve->load_mask & ECC_CURVE_FIELD_ORDER)
 801a84e:	687b      	ldr	r3, [r7, #4]
 801a850:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 801a854:	f003 0308 	and.w	r3, r3, #8
 801a858:	2b00      	cmp	r3, #0
 801a85a:	d006      	beq.n	801a86a <wc_ecc_curve_cache_free_spec+0x7e>
        wc_ecc_curve_cache_free_spec_item(curve, curve->order, ECC_CURVE_FIELD_ORDER);
 801a85c:	687b      	ldr	r3, [r7, #4]
 801a85e:	691b      	ldr	r3, [r3, #16]
 801a860:	2208      	movs	r2, #8
 801a862:	4619      	mov	r1, r3
 801a864:	6878      	ldr	r0, [r7, #4]
 801a866:	f7ff ffa2 	bl	801a7ae <wc_ecc_curve_cache_free_spec_item>
    if (curve->load_mask & ECC_CURVE_FIELD_GX)
 801a86a:	687b      	ldr	r3, [r7, #4]
 801a86c:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 801a870:	f003 0310 	and.w	r3, r3, #16
 801a874:	2b00      	cmp	r3, #0
 801a876:	d006      	beq.n	801a886 <wc_ecc_curve_cache_free_spec+0x9a>
        wc_ecc_curve_cache_free_spec_item(curve, curve->Gx, ECC_CURVE_FIELD_GX);
 801a878:	687b      	ldr	r3, [r7, #4]
 801a87a:	695b      	ldr	r3, [r3, #20]
 801a87c:	2210      	movs	r2, #16
 801a87e:	4619      	mov	r1, r3
 801a880:	6878      	ldr	r0, [r7, #4]
 801a882:	f7ff ff94 	bl	801a7ae <wc_ecc_curve_cache_free_spec_item>
    if (curve->load_mask & ECC_CURVE_FIELD_GY)
 801a886:	687b      	ldr	r3, [r7, #4]
 801a888:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 801a88c:	f003 0320 	and.w	r3, r3, #32
 801a890:	2b00      	cmp	r3, #0
 801a892:	d006      	beq.n	801a8a2 <wc_ecc_curve_cache_free_spec+0xb6>
        wc_ecc_curve_cache_free_spec_item(curve, curve->Gy, ECC_CURVE_FIELD_GY);
 801a894:	687b      	ldr	r3, [r7, #4]
 801a896:	699b      	ldr	r3, [r3, #24]
 801a898:	2220      	movs	r2, #32
 801a89a:	4619      	mov	r1, r3
 801a89c:	6878      	ldr	r0, [r7, #4]
 801a89e:	f7ff ff86 	bl	801a7ae <wc_ecc_curve_cache_free_spec_item>

    curve->load_mask = 0;
 801a8a2:	687b      	ldr	r3, [r7, #4]
 801a8a4:	2200      	movs	r2, #0
 801a8a6:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
 801a8aa:	e000      	b.n	801a8ae <wc_ecc_curve_cache_free_spec+0xc2>
        return;
 801a8ac:	bf00      	nop
}
 801a8ae:	3708      	adds	r7, #8
 801a8b0:	46bd      	mov	sp, r7
 801a8b2:	bd80      	pop	{r7, pc}

0801a8b4 <wc_ecc_curve_free>:

static void wc_ecc_curve_free(ecc_curve_spec* curve)
{
 801a8b4:	b580      	push	{r7, lr}
 801a8b6:	b082      	sub	sp, #8
 801a8b8:	af00      	add	r7, sp, #0
 801a8ba:	6078      	str	r0, [r7, #4]
    if (curve) {
 801a8bc:	687b      	ldr	r3, [r7, #4]
 801a8be:	2b00      	cmp	r3, #0
 801a8c0:	d002      	beq.n	801a8c8 <wc_ecc_curve_free+0x14>
            wc_ecc_curve_cache_free_spec(curve);
            XFREE(curve, NULL, DYNAMIC_TYPE_ECC);
        }
        #endif
    #else
        wc_ecc_curve_cache_free_spec(curve);
 801a8c2:	6878      	ldr	r0, [r7, #4]
 801a8c4:	f7ff ff92 	bl	801a7ec <wc_ecc_curve_cache_free_spec>
    #endif
    }
}
 801a8c8:	bf00      	nop
 801a8ca:	3708      	adds	r7, #8
 801a8cc:	46bd      	mov	sp, r7
 801a8ce:	bd80      	pop	{r7, pc}

0801a8d0 <wc_ecc_curve_cache_load_item>:

static int wc_ecc_curve_cache_load_item(ecc_curve_spec* curve, const char* src,
    mp_int** dst, byte mask)
{
 801a8d0:	b580      	push	{r7, lr}
 801a8d2:	b086      	sub	sp, #24
 801a8d4:	af00      	add	r7, sp, #0
 801a8d6:	60f8      	str	r0, [r7, #12]
 801a8d8:	60b9      	str	r1, [r7, #8]
 801a8da:	607a      	str	r2, [r7, #4]
 801a8dc:	70fb      	strb	r3, [r7, #3]
    int err;

#ifndef ECC_CACHE_CURVE
    /* get mp_int from temp */
    if (curve->spec_use >= curve->spec_count) {
 801a8de:	68fb      	ldr	r3, [r7, #12]
 801a8e0:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 801a8e2:	68fb      	ldr	r3, [r7, #12]
 801a8e4:	6a1b      	ldr	r3, [r3, #32]
 801a8e6:	429a      	cmp	r2, r3
 801a8e8:	d302      	bcc.n	801a8f0 <wc_ecc_curve_cache_load_item+0x20>
        WOLFSSL_MSG("Invalid DECLARE_CURVE_SPECS count");
        return ECC_BAD_ARG_E;
 801a8ea:	f06f 03a9 	mvn.w	r3, #169	@ 0xa9
 801a8ee:	e028      	b.n	801a942 <wc_ecc_curve_cache_load_item+0x72>
    }
#ifdef WOLFSSL_SP_MATH_ALL
    *dst = (mp_int*)(curve->spec_ints + MP_INT_SIZEOF(MP_BITS_CNT(
        MAX_ECC_BITS_USE)) * curve->spec_use++);
#else
    *dst = &curve->spec_ints[curve->spec_use++];
 801a8f0:	68fb      	ldr	r3, [r7, #12]
 801a8f2:	69da      	ldr	r2, [r3, #28]
 801a8f4:	68fb      	ldr	r3, [r7, #12]
 801a8f6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801a8f8:	1c58      	adds	r0, r3, #1
 801a8fa:	68f9      	ldr	r1, [r7, #12]
 801a8fc:	6248      	str	r0, [r1, #36]	@ 0x24
 801a8fe:	f44f 710b 	mov.w	r1, #556	@ 0x22c
 801a902:	fb01 f303 	mul.w	r3, r1, r3
 801a906:	441a      	add	r2, r3
 801a908:	687b      	ldr	r3, [r7, #4]
 801a90a:	601a      	str	r2, [r3, #0]
#endif

#ifdef WOLFSSL_SP_MATH_ALL
    err = mp_init_size(*dst, MP_BITS_CNT(MAX_ECC_BITS_USE));
#else
    err = mp_init(*dst);
 801a90c:	687b      	ldr	r3, [r7, #4]
 801a90e:	681b      	ldr	r3, [r3, #0]
 801a910:	4618      	mov	r0, r3
 801a912:	f00b febe 	bl	8026692 <mp_init>
 801a916:	6178      	str	r0, [r7, #20]
#endif
    if (err == MP_OKAY) {
 801a918:	697b      	ldr	r3, [r7, #20]
 801a91a:	2b00      	cmp	r3, #0
 801a91c:	d110      	bne.n	801a940 <wc_ecc_curve_cache_load_item+0x70>
        curve->load_mask |= mask;
 801a91e:	68fb      	ldr	r3, [r7, #12]
 801a920:	f893 2028 	ldrb.w	r2, [r3, #40]	@ 0x28
 801a924:	78fb      	ldrb	r3, [r7, #3]
 801a926:	4313      	orrs	r3, r2
 801a928:	b2da      	uxtb	r2, r3
 801a92a:	68fb      	ldr	r3, [r7, #12]
 801a92c:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28

        err = mp_read_radix(*dst, src, MP_RADIX_HEX);
 801a930:	687b      	ldr	r3, [r7, #4]
 801a932:	681b      	ldr	r3, [r3, #0]
 801a934:	2210      	movs	r2, #16
 801a936:	68b9      	ldr	r1, [r7, #8]
 801a938:	4618      	mov	r0, r3
 801a93a:	f00c fb55 	bl	8026fe8 <mp_read_radix>
 801a93e:	6178      	str	r0, [r7, #20]
    #ifdef HAVE_WOLF_BIGINT
        if (err == MP_OKAY)
            err = wc_mp_to_bigint(*dst, &(*dst)->raw);
    #endif
    }
    return err;
 801a940:	697b      	ldr	r3, [r7, #20]
}
 801a942:	4618      	mov	r0, r3
 801a944:	3718      	adds	r7, #24
 801a946:	46bd      	mov	sp, r7
 801a948:	bd80      	pop	{r7, pc}

0801a94a <wc_ecc_curve_load>:

static int wc_ecc_curve_load(const ecc_set_type* dp, ecc_curve_spec** pCurve,
    byte load_mask)
{
 801a94a:	b580      	push	{r7, lr}
 801a94c:	b088      	sub	sp, #32
 801a94e:	af00      	add	r7, sp, #0
 801a950:	60f8      	str	r0, [r7, #12]
 801a952:	60b9      	str	r1, [r7, #8]
 801a954:	4613      	mov	r3, r2
 801a956:	71fb      	strb	r3, [r7, #7]
    int ret = 0;
 801a958:	2300      	movs	r3, #0
 801a95a:	61fb      	str	r3, [r7, #28]
    ecc_curve_spec* curve;
    byte load_items = 0; /* mask of items to load */
 801a95c:	2300      	movs	r3, #0
 801a95e:	76fb      	strb	r3, [r7, #27]
#ifdef ECC_CACHE_CURVE
    int x;
#endif

    if (dp == NULL || pCurve == NULL)
 801a960:	68fb      	ldr	r3, [r7, #12]
 801a962:	2b00      	cmp	r3, #0
 801a964:	d002      	beq.n	801a96c <wc_ecc_curve_load+0x22>
 801a966:	68bb      	ldr	r3, [r7, #8]
 801a968:	2b00      	cmp	r3, #0
 801a96a:	d102      	bne.n	801a972 <wc_ecc_curve_load+0x28>
        return BAD_FUNC_ARG;
 801a96c:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801a970:	e094      	b.n	801aa9c <wc_ecc_curve_load+0x152>
#endif /* WOLFSSL_NO_MALLOC */

    /* return new or cached curve */
    *pCurve = curve;
#else
    curve = *pCurve;
 801a972:	68bb      	ldr	r3, [r7, #8]
 801a974:	681b      	ldr	r3, [r3, #0]
 801a976:	617b      	str	r3, [r7, #20]
#endif /* ECC_CACHE_CURVE */

    /* make sure the curve is initialized */
    if (curve->dp != dp) {
 801a978:	697b      	ldr	r3, [r7, #20]
 801a97a:	681b      	ldr	r3, [r3, #0]
 801a97c:	68fa      	ldr	r2, [r7, #12]
 801a97e:	429a      	cmp	r2, r3
 801a980:	d003      	beq.n	801a98a <wc_ecc_curve_load+0x40>
        curve->load_mask = 0;
 801a982:	697b      	ldr	r3, [r7, #20]
 801a984:	2200      	movs	r2, #0
 801a986:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
        curve->order = &curve->order_lcl;
        curve->Gx = &curve->Gx_lcl;
        curve->Gy = &curve->Gy_lcl;
    #endif
    }
    curve->dp = dp; /* set dp info */
 801a98a:	697b      	ldr	r3, [r7, #20]
 801a98c:	68fa      	ldr	r2, [r7, #12]
 801a98e:	601a      	str	r2, [r3, #0]

    /* determine items to load */
    load_items = (byte)(((byte)~(word32)curve->load_mask) & load_mask);
 801a990:	697b      	ldr	r3, [r7, #20]
 801a992:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 801a996:	43db      	mvns	r3, r3
 801a998:	b2da      	uxtb	r2, r3
 801a99a:	79fb      	ldrb	r3, [r7, #7]
 801a99c:	4013      	ands	r3, r2
 801a99e:	76fb      	strb	r3, [r7, #27]
    curve->load_mask |= load_items;
 801a9a0:	697b      	ldr	r3, [r7, #20]
 801a9a2:	f893 2028 	ldrb.w	r2, [r3, #40]	@ 0x28
 801a9a6:	7efb      	ldrb	r3, [r7, #27]
 801a9a8:	4313      	orrs	r3, r2
 801a9aa:	b2da      	uxtb	r2, r3
 801a9ac:	697b      	ldr	r3, [r7, #20]
 801a9ae:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28

    /* load items */
    if (load_items & ECC_CURVE_FIELD_PRIME)
 801a9b2:	7efb      	ldrb	r3, [r7, #27]
 801a9b4:	f003 0301 	and.w	r3, r3, #1
 801a9b8:	2b00      	cmp	r3, #0
 801a9ba:	d00b      	beq.n	801a9d4 <wc_ecc_curve_load+0x8a>
        ret += wc_ecc_curve_cache_load_item(curve, dp->prime, &curve->prime,
 801a9bc:	68fb      	ldr	r3, [r7, #12]
 801a9be:	68d9      	ldr	r1, [r3, #12]
 801a9c0:	697b      	ldr	r3, [r7, #20]
 801a9c2:	1d1a      	adds	r2, r3, #4
 801a9c4:	2301      	movs	r3, #1
 801a9c6:	6978      	ldr	r0, [r7, #20]
 801a9c8:	f7ff ff82 	bl	801a8d0 <wc_ecc_curve_cache_load_item>
 801a9cc:	4602      	mov	r2, r0
 801a9ce:	69fb      	ldr	r3, [r7, #28]
 801a9d0:	4413      	add	r3, r2
 801a9d2:	61fb      	str	r3, [r7, #28]
            ECC_CURVE_FIELD_PRIME);
    if (load_items & ECC_CURVE_FIELD_AF)
 801a9d4:	7efb      	ldrb	r3, [r7, #27]
 801a9d6:	f003 0302 	and.w	r3, r3, #2
 801a9da:	2b00      	cmp	r3, #0
 801a9dc:	d00c      	beq.n	801a9f8 <wc_ecc_curve_load+0xae>
        ret += wc_ecc_curve_cache_load_item(curve, dp->Af, &curve->Af,
 801a9de:	68fb      	ldr	r3, [r7, #12]
 801a9e0:	6919      	ldr	r1, [r3, #16]
 801a9e2:	697b      	ldr	r3, [r7, #20]
 801a9e4:	f103 0208 	add.w	r2, r3, #8
 801a9e8:	2302      	movs	r3, #2
 801a9ea:	6978      	ldr	r0, [r7, #20]
 801a9ec:	f7ff ff70 	bl	801a8d0 <wc_ecc_curve_cache_load_item>
 801a9f0:	4602      	mov	r2, r0
 801a9f2:	69fb      	ldr	r3, [r7, #28]
 801a9f4:	4413      	add	r3, r2
 801a9f6:	61fb      	str	r3, [r7, #28]
            ECC_CURVE_FIELD_AF);
#ifdef USE_ECC_B_PARAM
    if (load_items & ECC_CURVE_FIELD_BF)
 801a9f8:	7efb      	ldrb	r3, [r7, #27]
 801a9fa:	f003 0304 	and.w	r3, r3, #4
 801a9fe:	2b00      	cmp	r3, #0
 801aa00:	d00c      	beq.n	801aa1c <wc_ecc_curve_load+0xd2>
        ret += wc_ecc_curve_cache_load_item(curve, dp->Bf, &curve->Bf,
 801aa02:	68fb      	ldr	r3, [r7, #12]
 801aa04:	6959      	ldr	r1, [r3, #20]
 801aa06:	697b      	ldr	r3, [r7, #20]
 801aa08:	f103 020c 	add.w	r2, r3, #12
 801aa0c:	2304      	movs	r3, #4
 801aa0e:	6978      	ldr	r0, [r7, #20]
 801aa10:	f7ff ff5e 	bl	801a8d0 <wc_ecc_curve_cache_load_item>
 801aa14:	4602      	mov	r2, r0
 801aa16:	69fb      	ldr	r3, [r7, #28]
 801aa18:	4413      	add	r3, r2
 801aa1a:	61fb      	str	r3, [r7, #28]
            ECC_CURVE_FIELD_BF);
#endif
    if (load_items & ECC_CURVE_FIELD_ORDER)
 801aa1c:	7efb      	ldrb	r3, [r7, #27]
 801aa1e:	f003 0308 	and.w	r3, r3, #8
 801aa22:	2b00      	cmp	r3, #0
 801aa24:	d00c      	beq.n	801aa40 <wc_ecc_curve_load+0xf6>
        ret += wc_ecc_curve_cache_load_item(curve, dp->order, &curve->order,
 801aa26:	68fb      	ldr	r3, [r7, #12]
 801aa28:	6999      	ldr	r1, [r3, #24]
 801aa2a:	697b      	ldr	r3, [r7, #20]
 801aa2c:	f103 0210 	add.w	r2, r3, #16
 801aa30:	2308      	movs	r3, #8
 801aa32:	6978      	ldr	r0, [r7, #20]
 801aa34:	f7ff ff4c 	bl	801a8d0 <wc_ecc_curve_cache_load_item>
 801aa38:	4602      	mov	r2, r0
 801aa3a:	69fb      	ldr	r3, [r7, #28]
 801aa3c:	4413      	add	r3, r2
 801aa3e:	61fb      	str	r3, [r7, #28]
            ECC_CURVE_FIELD_ORDER);
    if (load_items & ECC_CURVE_FIELD_GX)
 801aa40:	7efb      	ldrb	r3, [r7, #27]
 801aa42:	f003 0310 	and.w	r3, r3, #16
 801aa46:	2b00      	cmp	r3, #0
 801aa48:	d00c      	beq.n	801aa64 <wc_ecc_curve_load+0x11a>
        ret += wc_ecc_curve_cache_load_item(curve, dp->Gx, &curve->Gx,
 801aa4a:	68fb      	ldr	r3, [r7, #12]
 801aa4c:	69d9      	ldr	r1, [r3, #28]
 801aa4e:	697b      	ldr	r3, [r7, #20]
 801aa50:	f103 0214 	add.w	r2, r3, #20
 801aa54:	2310      	movs	r3, #16
 801aa56:	6978      	ldr	r0, [r7, #20]
 801aa58:	f7ff ff3a 	bl	801a8d0 <wc_ecc_curve_cache_load_item>
 801aa5c:	4602      	mov	r2, r0
 801aa5e:	69fb      	ldr	r3, [r7, #28]
 801aa60:	4413      	add	r3, r2
 801aa62:	61fb      	str	r3, [r7, #28]
            ECC_CURVE_FIELD_GX);
    if (load_items & ECC_CURVE_FIELD_GY)
 801aa64:	7efb      	ldrb	r3, [r7, #27]
 801aa66:	f003 0320 	and.w	r3, r3, #32
 801aa6a:	2b00      	cmp	r3, #0
 801aa6c:	d00c      	beq.n	801aa88 <wc_ecc_curve_load+0x13e>
        ret += wc_ecc_curve_cache_load_item(curve, dp->Gy, &curve->Gy,
 801aa6e:	68fb      	ldr	r3, [r7, #12]
 801aa70:	6a19      	ldr	r1, [r3, #32]
 801aa72:	697b      	ldr	r3, [r7, #20]
 801aa74:	f103 0218 	add.w	r2, r3, #24
 801aa78:	2320      	movs	r3, #32
 801aa7a:	6978      	ldr	r0, [r7, #20]
 801aa7c:	f7ff ff28 	bl	801a8d0 <wc_ecc_curve_cache_load_item>
 801aa80:	4602      	mov	r2, r0
 801aa82:	69fb      	ldr	r3, [r7, #28]
 801aa84:	4413      	add	r3, r2
 801aa86:	61fb      	str	r3, [r7, #28]
            ECC_CURVE_FIELD_GY);

    /* check for error */
    if (ret != 0) {
 801aa88:	69fb      	ldr	r3, [r7, #28]
 801aa8a:	2b00      	cmp	r3, #0
 801aa8c:	d005      	beq.n	801aa9a <wc_ecc_curve_load+0x150>
        wc_ecc_curve_free(curve);
 801aa8e:	6978      	ldr	r0, [r7, #20]
 801aa90:	f7ff ff10 	bl	801a8b4 <wc_ecc_curve_free>
        ret = MP_READ_E;
 801aa94:	f06f 036e 	mvn.w	r3, #110	@ 0x6e
 801aa98:	61fb      	str	r3, [r7, #28]

#if defined(ECC_CACHE_CURVE) && !defined(SINGLE_THREADED)
    wc_UnLockMutex(&ecc_curve_cache_mutex);
#endif

    return ret;
 801aa9a:	69fb      	ldr	r3, [r7, #28]
}
 801aa9c:	4618      	mov	r0, r3
 801aa9e:	3720      	adds	r7, #32
 801aaa0:	46bd      	mov	sp, r7
 801aaa2:	bd80      	pop	{r7, pc}

0801aaa4 <wc_ecc_set_curve>:
        return NULL;
    return ecc_sets[curve_idx].name;
}

int wc_ecc_set_curve(ecc_key* key, int keysize, int curve_id)
{
 801aaa4:	b480      	push	{r7}
 801aaa6:	b087      	sub	sp, #28
 801aaa8:	af00      	add	r7, sp, #0
 801aaaa:	60f8      	str	r0, [r7, #12]
 801aaac:	60b9      	str	r1, [r7, #8]
 801aaae:	607a      	str	r2, [r7, #4]
    if (key == NULL || (keysize <= 0 && curve_id < 0)) {
 801aab0:	68fb      	ldr	r3, [r7, #12]
 801aab2:	2b00      	cmp	r3, #0
 801aab4:	d005      	beq.n	801aac2 <wc_ecc_set_curve+0x1e>
 801aab6:	68bb      	ldr	r3, [r7, #8]
 801aab8:	2b00      	cmp	r3, #0
 801aaba:	dc05      	bgt.n	801aac8 <wc_ecc_set_curve+0x24>
 801aabc:	687b      	ldr	r3, [r7, #4]
 801aabe:	2b00      	cmp	r3, #0
 801aac0:	da02      	bge.n	801aac8 <wc_ecc_set_curve+0x24>
        return BAD_FUNC_ARG;
 801aac2:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801aac6:	e052      	b.n	801ab6e <wc_ecc_set_curve+0xca>
    }

    if (keysize > ECC_MAXSIZE) {
 801aac8:	68bb      	ldr	r3, [r7, #8]
 801aaca:	2b42      	cmp	r3, #66	@ 0x42
 801aacc:	dd02      	ble.n	801aad4 <wc_ecc_set_curve+0x30>
        return ECC_BAD_ARG_E;
 801aace:	f06f 03a9 	mvn.w	r3, #169	@ 0xa9
 801aad2:	e04c      	b.n	801ab6e <wc_ecc_set_curve+0xca>
    }

    /* handle custom case */
    if (key->idx != ECC_CUSTOM_IDX) {
 801aad4:	68fb      	ldr	r3, [r7, #12]
 801aad6:	685b      	ldr	r3, [r3, #4]
 801aad8:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 801aadc:	d046      	beq.n	801ab6c <wc_ecc_set_curve+0xc8>
        int x;

        /* default values */
        key->idx = 0;
 801aade:	68fb      	ldr	r3, [r7, #12]
 801aae0:	2200      	movs	r2, #0
 801aae2:	605a      	str	r2, [r3, #4]
        key->dp = NULL;
 801aae4:	68fb      	ldr	r3, [r7, #12]
 801aae6:	2200      	movs	r2, #0
 801aae8:	611a      	str	r2, [r3, #16]

        /* find ecc_set based on curve_id or key size */
        for (x = 0; ecc_sets[x].size != 0; x++) {
 801aaea:	2300      	movs	r3, #0
 801aaec:	617b      	str	r3, [r7, #20]
 801aaee:	e01b      	b.n	801ab28 <wc_ecc_set_curve+0x84>
            if (curve_id > ECC_CURVE_DEF) {
 801aaf0:	687b      	ldr	r3, [r7, #4]
 801aaf2:	2b00      	cmp	r3, #0
 801aaf4:	dd0b      	ble.n	801ab0e <wc_ecc_set_curve+0x6a>
                if (curve_id == ecc_sets[x].id)
 801aaf6:	4a21      	ldr	r2, [pc, #132]	@ (801ab7c <wc_ecc_set_curve+0xd8>)
 801aaf8:	697b      	ldr	r3, [r7, #20]
 801aafa:	2134      	movs	r1, #52	@ 0x34
 801aafc:	fb01 f303 	mul.w	r3, r1, r3
 801ab00:	4413      	add	r3, r2
 801ab02:	3304      	adds	r3, #4
 801ab04:	681b      	ldr	r3, [r3, #0]
 801ab06:	687a      	ldr	r2, [r7, #4]
 801ab08:	429a      	cmp	r2, r3
 801ab0a:	d10a      	bne.n	801ab22 <wc_ecc_set_curve+0x7e>
                  break;
 801ab0c:	e017      	b.n	801ab3e <wc_ecc_set_curve+0x9a>
            }
            else if (keysize <= ecc_sets[x].size) {
 801ab0e:	4a1b      	ldr	r2, [pc, #108]	@ (801ab7c <wc_ecc_set_curve+0xd8>)
 801ab10:	697b      	ldr	r3, [r7, #20]
 801ab12:	2134      	movs	r1, #52	@ 0x34
 801ab14:	fb01 f303 	mul.w	r3, r1, r3
 801ab18:	4413      	add	r3, r2
 801ab1a:	681b      	ldr	r3, [r3, #0]
 801ab1c:	68ba      	ldr	r2, [r7, #8]
 801ab1e:	429a      	cmp	r2, r3
 801ab20:	dd0c      	ble.n	801ab3c <wc_ecc_set_curve+0x98>
        for (x = 0; ecc_sets[x].size != 0; x++) {
 801ab22:	697b      	ldr	r3, [r7, #20]
 801ab24:	3301      	adds	r3, #1
 801ab26:	617b      	str	r3, [r7, #20]
 801ab28:	4a14      	ldr	r2, [pc, #80]	@ (801ab7c <wc_ecc_set_curve+0xd8>)
 801ab2a:	697b      	ldr	r3, [r7, #20]
 801ab2c:	2134      	movs	r1, #52	@ 0x34
 801ab2e:	fb01 f303 	mul.w	r3, r1, r3
 801ab32:	4413      	add	r3, r2
 801ab34:	681b      	ldr	r3, [r3, #0]
 801ab36:	2b00      	cmp	r3, #0
 801ab38:	d1da      	bne.n	801aaf0 <wc_ecc_set_curve+0x4c>
 801ab3a:	e000      	b.n	801ab3e <wc_ecc_set_curve+0x9a>
                break;
 801ab3c:	bf00      	nop
            }
        }
        if (ecc_sets[x].size == 0) {
 801ab3e:	4a0f      	ldr	r2, [pc, #60]	@ (801ab7c <wc_ecc_set_curve+0xd8>)
 801ab40:	697b      	ldr	r3, [r7, #20]
 801ab42:	2134      	movs	r1, #52	@ 0x34
 801ab44:	fb01 f303 	mul.w	r3, r1, r3
 801ab48:	4413      	add	r3, r2
 801ab4a:	681b      	ldr	r3, [r3, #0]
 801ab4c:	2b00      	cmp	r3, #0
 801ab4e:	d102      	bne.n	801ab56 <wc_ecc_set_curve+0xb2>
            WOLFSSL_MSG("ECC Curve not found");
            return ECC_CURVE_OID_E;
 801ab50:	f06f 03ab 	mvn.w	r3, #171	@ 0xab
 801ab54:	e00b      	b.n	801ab6e <wc_ecc_set_curve+0xca>
        }

        key->idx = x;
 801ab56:	68fb      	ldr	r3, [r7, #12]
 801ab58:	697a      	ldr	r2, [r7, #20]
 801ab5a:	605a      	str	r2, [r3, #4]
        key->dp  = &ecc_sets[x];
 801ab5c:	697b      	ldr	r3, [r7, #20]
 801ab5e:	2234      	movs	r2, #52	@ 0x34
 801ab60:	fb02 f303 	mul.w	r3, r2, r3
 801ab64:	4a05      	ldr	r2, [pc, #20]	@ (801ab7c <wc_ecc_set_curve+0xd8>)
 801ab66:	441a      	add	r2, r3
 801ab68:	68fb      	ldr	r3, [r7, #12]
 801ab6a:	611a      	str	r2, [r3, #16]
    }

    return 0;
 801ab6c:	2300      	movs	r3, #0
}
 801ab6e:	4618      	mov	r0, r3
 801ab70:	371c      	adds	r7, #28
 801ab72:	46bd      	mov	sp, r7
 801ab74:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ab78:	4770      	bx	lr
 801ab7a:	bf00      	nop
 801ab7c:	08033b18 	.word	0x08033b18

0801ab80 <alt_fp_init>:


#ifdef ALT_ECC_SIZE
static void alt_fp_init(mp_int* a)
{
 801ab80:	b580      	push	{r7, lr}
 801ab82:	b082      	sub	sp, #8
 801ab84:	af00      	add	r7, sp, #0
 801ab86:	6078      	str	r0, [r7, #4]
    a->size = FP_SIZE_ECC;
 801ab88:	687b      	ldr	r3, [r7, #4]
 801ab8a:	2211      	movs	r2, #17
 801ab8c:	609a      	str	r2, [r3, #8]
    mp_zero(a);
 801ab8e:	6878      	ldr	r0, [r7, #4]
 801ab90:	f00b fd9c 	bl	80266cc <fp_zero>
}
 801ab94:	bf00      	nop
 801ab96:	3708      	adds	r7, #8
 801ab98:	46bd      	mov	sp, r7
 801ab9a:	bd80      	pop	{r7, pc}

0801ab9c <_ecc_projective_add_point>:
   mp       The "b" value from montgomery_setup()
   return   MP_OKAY on success
*/
static int _ecc_projective_add_point(ecc_point* P, ecc_point* Q, ecc_point* R,
                                     mp_int* a, mp_int* modulus, mp_digit mp)
{
 801ab9c:	b580      	push	{r7, lr}
 801ab9e:	b0a6      	sub	sp, #152	@ 0x98
 801aba0:	af02      	add	r7, sp, #8
 801aba2:	60f8      	str	r0, [r7, #12]
 801aba4:	60b9      	str	r1, [r7, #8]
 801aba6:	607a      	str	r2, [r7, #4]
 801aba8:	603b      	str	r3, [r7, #0]
#if !defined(WOLFSSL_SP_MATH)
   DECL_MP_INT_SIZE_DYN(t1, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801abaa:	2300      	movs	r3, #0
 801abac:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
   DECL_MP_INT_SIZE_DYN(t2, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801abb0:	2300      	movs	r3, #0
 801abb2:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
#ifdef ALT_ECC_SIZE
   DECL_MP_INT_SIZE_DYN(rx, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801abb6:	2300      	movs	r3, #0
 801abb8:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
   DECL_MP_INT_SIZE_DYN(ry, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801abbc:	2300      	movs	r3, #0
 801abbe:	67fb      	str	r3, [r7, #124]	@ 0x7c
   DECL_MP_INT_SIZE_DYN(rz, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801abc0:	2300      	movs	r3, #0
 801abc2:	67bb      	str	r3, [r7, #120]	@ 0x78
#endif
   mp_int  *x, *y, *z;
   int     err;

   /* if Q == R then swap P and Q, so we don't require a local x,y,z */
   if (Q == R) {
 801abc4:	68ba      	ldr	r2, [r7, #8]
 801abc6:	687b      	ldr	r3, [r7, #4]
 801abc8:	429a      	cmp	r2, r3
 801abca:	d105      	bne.n	801abd8 <_ecc_projective_add_point+0x3c>
      ecc_point* tPt  = P;
 801abcc:	68fb      	ldr	r3, [r7, #12]
 801abce:	677b      	str	r3, [r7, #116]	@ 0x74
      P = Q;
 801abd0:	68bb      	ldr	r3, [r7, #8]
 801abd2:	60fb      	str	r3, [r7, #12]
      Q = tPt;
 801abd4:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801abd6:	60bb      	str	r3, [r7, #8]
   }
   else
#endif /* WOLFSSL_SMALL_STACK_CACHE */
#endif /* WOLFSSL_SMALL_STACK */
   {
      NEW_MP_INT_SIZE(t1, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801abd8:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801abdc:	f003 ff54 	bl	801ea88 <wolfSSL_Malloc>
 801abe0:	f8c7 0088 	str.w	r0, [r7, #136]	@ 0x88
 801abe4:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801abe8:	2b00      	cmp	r3, #0
 801abea:	d006      	beq.n	801abfa <_ecc_projective_add_point+0x5e>
 801abec:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801abf0:	2100      	movs	r1, #0
 801abf2:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801abf6:	f00d fc67 	bl	80284c8 <memset>
      NEW_MP_INT_SIZE(t2, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801abfa:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801abfe:	f003 ff43 	bl	801ea88 <wolfSSL_Malloc>
 801ac02:	f8c7 0084 	str.w	r0, [r7, #132]	@ 0x84
 801ac06:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801ac0a:	2b00      	cmp	r3, #0
 801ac0c:	d006      	beq.n	801ac1c <_ecc_projective_add_point+0x80>
 801ac0e:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801ac12:	2100      	movs	r1, #0
 801ac14:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801ac18:	f00d fc56 	bl	80284c8 <memset>
   #ifdef MP_INT_SIZE_CHECK_NULL
      if (t1 == NULL || t2 == NULL) {
 801ac1c:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801ac20:	2b00      	cmp	r3, #0
 801ac22:	d003      	beq.n	801ac2c <_ecc_projective_add_point+0x90>
 801ac24:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801ac28:	2b00      	cmp	r3, #0
 801ac2a:	d115      	bne.n	801ac58 <_ecc_projective_add_point+0xbc>
         FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801ac2c:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801ac30:	617b      	str	r3, [r7, #20]
 801ac32:	697b      	ldr	r3, [r7, #20]
 801ac34:	2b00      	cmp	r3, #0
 801ac36:	d002      	beq.n	801ac3e <_ecc_projective_add_point+0xa2>
 801ac38:	6978      	ldr	r0, [r7, #20]
 801ac3a:	f003 ff41 	bl	801eac0 <wolfSSL_Free>
         FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801ac3e:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801ac42:	613b      	str	r3, [r7, #16]
 801ac44:	693b      	ldr	r3, [r7, #16]
 801ac46:	2b00      	cmp	r3, #0
 801ac48:	d002      	beq.n	801ac50 <_ecc_projective_add_point+0xb4>
 801ac4a:	6938      	ldr	r0, [r7, #16]
 801ac4c:	f003 ff38 	bl	801eac0 <wolfSSL_Free>
         return MEMORY_E;
 801ac50:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801ac54:	f000 bc2d 	b.w	801b4b2 <_ecc_projective_add_point+0x916>
      }
   #endif
#ifdef ALT_ECC_SIZE
      NEW_MP_INT_SIZE(rx, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801ac58:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801ac5c:	f003 ff14 	bl	801ea88 <wolfSSL_Malloc>
 801ac60:	f8c7 0080 	str.w	r0, [r7, #128]	@ 0x80
 801ac64:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801ac68:	2b00      	cmp	r3, #0
 801ac6a:	d006      	beq.n	801ac7a <_ecc_projective_add_point+0xde>
 801ac6c:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801ac70:	2100      	movs	r1, #0
 801ac72:	f8d7 0080 	ldr.w	r0, [r7, #128]	@ 0x80
 801ac76:	f00d fc27 	bl	80284c8 <memset>
      NEW_MP_INT_SIZE(ry, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801ac7a:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801ac7e:	f003 ff03 	bl	801ea88 <wolfSSL_Malloc>
 801ac82:	67f8      	str	r0, [r7, #124]	@ 0x7c
 801ac84:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801ac86:	2b00      	cmp	r3, #0
 801ac88:	d005      	beq.n	801ac96 <_ecc_projective_add_point+0xfa>
 801ac8a:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801ac8e:	2100      	movs	r1, #0
 801ac90:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
 801ac92:	f00d fc19 	bl	80284c8 <memset>
      NEW_MP_INT_SIZE(rz, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801ac96:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801ac9a:	f003 fef5 	bl	801ea88 <wolfSSL_Malloc>
 801ac9e:	67b8      	str	r0, [r7, #120]	@ 0x78
 801aca0:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801aca2:	2b00      	cmp	r3, #0
 801aca4:	d005      	beq.n	801acb2 <_ecc_projective_add_point+0x116>
 801aca6:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801acaa:	2100      	movs	r1, #0
 801acac:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 801acae:	f00d fc0b 	bl	80284c8 <memset>
   #ifdef MP_INT_SIZE_CHECK_NULL
      if (rx == NULL || ry == NULL || rz == NULL) {
 801acb2:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801acb6:	2b00      	cmp	r3, #0
 801acb8:	d005      	beq.n	801acc6 <_ecc_projective_add_point+0x12a>
 801acba:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801acbc:	2b00      	cmp	r3, #0
 801acbe:	d002      	beq.n	801acc6 <_ecc_projective_add_point+0x12a>
 801acc0:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801acc2:	2b00      	cmp	r3, #0
 801acc4:	d12d      	bne.n	801ad22 <_ecc_projective_add_point+0x186>
         FREE_MP_INT_SIZE(rz, NULL, DYNAMIC_TYPE_ECC);
 801acc6:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801acc8:	62bb      	str	r3, [r7, #40]	@ 0x28
 801acca:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801accc:	2b00      	cmp	r3, #0
 801acce:	d002      	beq.n	801acd6 <_ecc_projective_add_point+0x13a>
 801acd0:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801acd2:	f003 fef5 	bl	801eac0 <wolfSSL_Free>
         FREE_MP_INT_SIZE(ry, NULL, DYNAMIC_TYPE_ECC);
 801acd6:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801acd8:	627b      	str	r3, [r7, #36]	@ 0x24
 801acda:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801acdc:	2b00      	cmp	r3, #0
 801acde:	d002      	beq.n	801ace6 <_ecc_projective_add_point+0x14a>
 801ace0:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 801ace2:	f003 feed 	bl	801eac0 <wolfSSL_Free>
         FREE_MP_INT_SIZE(rx, NULL, DYNAMIC_TYPE_ECC);
 801ace6:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801acea:	623b      	str	r3, [r7, #32]
 801acec:	6a3b      	ldr	r3, [r7, #32]
 801acee:	2b00      	cmp	r3, #0
 801acf0:	d002      	beq.n	801acf8 <_ecc_projective_add_point+0x15c>
 801acf2:	6a38      	ldr	r0, [r7, #32]
 801acf4:	f003 fee4 	bl	801eac0 <wolfSSL_Free>
         FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801acf8:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801acfc:	61fb      	str	r3, [r7, #28]
 801acfe:	69fb      	ldr	r3, [r7, #28]
 801ad00:	2b00      	cmp	r3, #0
 801ad02:	d002      	beq.n	801ad0a <_ecc_projective_add_point+0x16e>
 801ad04:	69f8      	ldr	r0, [r7, #28]
 801ad06:	f003 fedb 	bl	801eac0 <wolfSSL_Free>
         FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801ad0a:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801ad0e:	61bb      	str	r3, [r7, #24]
 801ad10:	69bb      	ldr	r3, [r7, #24]
 801ad12:	2b00      	cmp	r3, #0
 801ad14:	d002      	beq.n	801ad1c <_ecc_projective_add_point+0x180>
 801ad16:	69b8      	ldr	r0, [r7, #24]
 801ad18:	f003 fed2 	bl	801eac0 <wolfSSL_Free>
         return MEMORY_E;
 801ad1c:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801ad20:	e3c7      	b.n	801b4b2 <_ecc_projective_add_point+0x916>
      }
   #endif
#endif
   }

   err = INIT_MP_INT_SIZE(t1, mp_bitsused(modulus));
 801ad22:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801ad26:	f00b fcb4 	bl	8026692 <mp_init>
 801ad2a:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY) {
 801ad2e:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801ad32:	2b00      	cmp	r3, #0
 801ad34:	d105      	bne.n	801ad42 <_ecc_projective_add_point+0x1a6>
      err = INIT_MP_INT_SIZE(t2, mp_bitsused(modulus));
 801ad36:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801ad3a:	f00b fcaa 	bl	8026692 <mp_init>
 801ad3e:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   }
   if (err != MP_OKAY) {
 801ad42:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801ad46:	2b00      	cmp	r3, #0
 801ad48:	d02d      	beq.n	801ada6 <_ecc_projective_add_point+0x20a>
      if (R->key == NULL)
   #endif
#endif
      {
      #ifdef ALT_ECC_SIZE
         FREE_MP_INT_SIZE(rz, NULL, DYNAMIC_TYPE_ECC);
 801ad4a:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801ad4c:	63fb      	str	r3, [r7, #60]	@ 0x3c
 801ad4e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801ad50:	2b00      	cmp	r3, #0
 801ad52:	d002      	beq.n	801ad5a <_ecc_projective_add_point+0x1be>
 801ad54:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 801ad56:	f003 feb3 	bl	801eac0 <wolfSSL_Free>
         FREE_MP_INT_SIZE(ry, NULL, DYNAMIC_TYPE_ECC);
 801ad5a:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801ad5c:	63bb      	str	r3, [r7, #56]	@ 0x38
 801ad5e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801ad60:	2b00      	cmp	r3, #0
 801ad62:	d002      	beq.n	801ad6a <_ecc_projective_add_point+0x1ce>
 801ad64:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 801ad66:	f003 feab 	bl	801eac0 <wolfSSL_Free>
         FREE_MP_INT_SIZE(rx, NULL, DYNAMIC_TYPE_ECC);
 801ad6a:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801ad6e:	637b      	str	r3, [r7, #52]	@ 0x34
 801ad70:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801ad72:	2b00      	cmp	r3, #0
 801ad74:	d002      	beq.n	801ad7c <_ecc_projective_add_point+0x1e0>
 801ad76:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801ad78:	f003 fea2 	bl	801eac0 <wolfSSL_Free>
      #endif
         FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801ad7c:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801ad80:	633b      	str	r3, [r7, #48]	@ 0x30
 801ad82:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801ad84:	2b00      	cmp	r3, #0
 801ad86:	d002      	beq.n	801ad8e <_ecc_projective_add_point+0x1f2>
 801ad88:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 801ad8a:	f003 fe99 	bl	801eac0 <wolfSSL_Free>
         FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801ad8e:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801ad92:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801ad94:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801ad96:	2b00      	cmp	r3, #0
 801ad98:	d002      	beq.n	801ada0 <_ecc_projective_add_point+0x204>
 801ad9a:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 801ad9c:	f003 fe90 	bl	801eac0 <wolfSSL_Free>
      }
      return err;
 801ada0:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801ada4:	e385      	b.n	801b4b2 <_ecc_projective_add_point+0x916>
   }

   /* should we dbl instead? */
   if (err == MP_OKAY) {
 801ada6:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801adaa:	2b00      	cmp	r3, #0
 801adac:	d10b      	bne.n	801adc6 <_ecc_projective_add_point+0x22a>
#ifdef ECC_TIMING_RESISTANT
      err = mp_submod_ct(modulus, Q->y, modulus, t1);
 801adae:	68bb      	ldr	r3, [r7, #8]
 801adb0:	6859      	ldr	r1, [r3, #4]
 801adb2:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801adb6:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801adba:	f8d7 0098 	ldr.w	r0, [r7, #152]	@ 0x98
 801adbe:	f00b fd81 	bl	80268c4 <mp_submod_ct>
 801adc2:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
#else
      err = mp_sub(modulus, Q->y, t1);
#endif
   }
   if (err == MP_OKAY) {
 801adc6:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801adca:	2b00      	cmp	r3, #0
 801adcc:	d171      	bne.n	801aeb2 <_ecc_projective_add_point+0x316>
      if ( (mp_cmp(P->x, Q->x) == MP_EQ) &&
 801adce:	68fb      	ldr	r3, [r7, #12]
 801add0:	681a      	ldr	r2, [r3, #0]
 801add2:	68bb      	ldr	r3, [r7, #8]
 801add4:	681b      	ldr	r3, [r3, #0]
 801add6:	4619      	mov	r1, r3
 801add8:	4610      	mov	r0, r2
 801adda:	f00b fded 	bl	80269b8 <mp_cmp>
 801adde:	4603      	mov	r3, r0
 801ade0:	2b00      	cmp	r3, #0
 801ade2:	d166      	bne.n	801aeb2 <_ecc_projective_add_point+0x316>
           (get_digit_count(Q->z) && mp_cmp(P->z, Q->z) == MP_EQ) &&
 801ade4:	68bb      	ldr	r3, [r7, #8]
 801ade6:	689b      	ldr	r3, [r3, #8]
 801ade8:	4618      	mov	r0, r3
 801adea:	f00c fb56 	bl	802749a <get_digit_count>
 801adee:	4603      	mov	r3, r0
      if ( (mp_cmp(P->x, Q->x) == MP_EQ) &&
 801adf0:	2b00      	cmp	r3, #0
 801adf2:	d05e      	beq.n	801aeb2 <_ecc_projective_add_point+0x316>
           (get_digit_count(Q->z) && mp_cmp(P->z, Q->z) == MP_EQ) &&
 801adf4:	68fb      	ldr	r3, [r7, #12]
 801adf6:	689a      	ldr	r2, [r3, #8]
 801adf8:	68bb      	ldr	r3, [r7, #8]
 801adfa:	689b      	ldr	r3, [r3, #8]
 801adfc:	4619      	mov	r1, r3
 801adfe:	4610      	mov	r0, r2
 801ae00:	f00b fdda 	bl	80269b8 <mp_cmp>
 801ae04:	4603      	mov	r3, r0
 801ae06:	2b00      	cmp	r3, #0
 801ae08:	d153      	bne.n	801aeb2 <_ecc_projective_add_point+0x316>
           (mp_cmp(P->y, Q->y) == MP_EQ || mp_cmp(P->y, t1) == MP_EQ)) {
 801ae0a:	68fb      	ldr	r3, [r7, #12]
 801ae0c:	685a      	ldr	r2, [r3, #4]
 801ae0e:	68bb      	ldr	r3, [r7, #8]
 801ae10:	685b      	ldr	r3, [r3, #4]
 801ae12:	4619      	mov	r1, r3
 801ae14:	4610      	mov	r0, r2
 801ae16:	f00b fdcf 	bl	80269b8 <mp_cmp>
 801ae1a:	4603      	mov	r3, r0
           (get_digit_count(Q->z) && mp_cmp(P->z, Q->z) == MP_EQ) &&
 801ae1c:	2b00      	cmp	r3, #0
 801ae1e:	d009      	beq.n	801ae34 <_ecc_projective_add_point+0x298>
           (mp_cmp(P->y, Q->y) == MP_EQ || mp_cmp(P->y, t1) == MP_EQ)) {
 801ae20:	68fb      	ldr	r3, [r7, #12]
 801ae22:	685b      	ldr	r3, [r3, #4]
 801ae24:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801ae28:	4618      	mov	r0, r3
 801ae2a:	f00b fdc5 	bl	80269b8 <mp_cmp>
 801ae2e:	4603      	mov	r3, r0
 801ae30:	2b00      	cmp	r3, #0
 801ae32:	d13e      	bne.n	801aeb2 <_ecc_projective_add_point+0x316>
          mp_clear(t1);
 801ae34:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801ae38:	f00b fcb5 	bl	80267a6 <mp_clear>
          mp_clear(t2);
 801ae3c:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801ae40:	f00b fcb1 	bl	80267a6 <mp_clear>
         if (R->key == NULL)
      #endif
   #endif
         {
         #ifdef ALT_ECC_SIZE
            FREE_MP_INT_SIZE(rz, NULL, DYNAMIC_TYPE_ECC);
 801ae44:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801ae46:	673b      	str	r3, [r7, #112]	@ 0x70
 801ae48:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801ae4a:	2b00      	cmp	r3, #0
 801ae4c:	d002      	beq.n	801ae54 <_ecc_projective_add_point+0x2b8>
 801ae4e:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801ae50:	f003 fe36 	bl	801eac0 <wolfSSL_Free>
            FREE_MP_INT_SIZE(ry, NULL, DYNAMIC_TYPE_ECC);
 801ae54:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801ae56:	66fb      	str	r3, [r7, #108]	@ 0x6c
 801ae58:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801ae5a:	2b00      	cmp	r3, #0
 801ae5c:	d002      	beq.n	801ae64 <_ecc_projective_add_point+0x2c8>
 801ae5e:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 801ae60:	f003 fe2e 	bl	801eac0 <wolfSSL_Free>
            FREE_MP_INT_SIZE(rx, NULL, DYNAMIC_TYPE_ECC);
 801ae64:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801ae68:	66bb      	str	r3, [r7, #104]	@ 0x68
 801ae6a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801ae6c:	2b00      	cmp	r3, #0
 801ae6e:	d002      	beq.n	801ae76 <_ecc_projective_add_point+0x2da>
 801ae70:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 801ae72:	f003 fe25 	bl	801eac0 <wolfSSL_Free>
         #endif
            FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801ae76:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801ae7a:	667b      	str	r3, [r7, #100]	@ 0x64
 801ae7c:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801ae7e:	2b00      	cmp	r3, #0
 801ae80:	d002      	beq.n	801ae88 <_ecc_projective_add_point+0x2ec>
 801ae82:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 801ae84:	f003 fe1c 	bl	801eac0 <wolfSSL_Free>
            FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801ae88:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801ae8c:	663b      	str	r3, [r7, #96]	@ 0x60
 801ae8e:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801ae90:	2b00      	cmp	r3, #0
 801ae92:	d002      	beq.n	801ae9a <_ecc_projective_add_point+0x2fe>
 801ae94:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 801ae96:	f003 fe13 	bl	801eac0 <wolfSSL_Free>
         }
         return _ecc_projective_dbl_point(P, R, a, modulus, mp);
 801ae9a:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801ae9e:	9300      	str	r3, [sp, #0]
 801aea0:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 801aea4:	683a      	ldr	r2, [r7, #0]
 801aea6:	6879      	ldr	r1, [r7, #4]
 801aea8:	68f8      	ldr	r0, [r7, #12]
 801aeaa:	f000 fb06 	bl	801b4ba <_ecc_projective_dbl_point>
 801aeae:	4603      	mov	r3, r0
 801aeb0:	e2ff      	b.n	801b4b2 <_ecc_projective_add_point+0x916>
      }
   }

   if (err != MP_OKAY) {
 801aeb2:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801aeb6:	2b00      	cmp	r3, #0
 801aeb8:	f040 82c1 	bne.w	801b43e <_ecc_projective_add_point+0x8a2>

/* If use ALT_ECC_SIZE we need to use local stack variable since
   ecc_point x,y,z is reduced size */
#ifdef ALT_ECC_SIZE
   /* Use local stack variable */
   x = rx;
 801aebc:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801aec0:	65fb      	str	r3, [r7, #92]	@ 0x5c
   y = ry;
 801aec2:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801aec4:	65bb      	str	r3, [r7, #88]	@ 0x58
   z = rz;
 801aec6:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801aec8:	657b      	str	r3, [r7, #84]	@ 0x54

   err = INIT_MP_INT_SIZE(x, mp_bitsused(modulus));
 801aeca:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801aecc:	f00b fbe1 	bl	8026692 <mp_init>
 801aed0:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY) {
 801aed4:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801aed8:	2b00      	cmp	r3, #0
 801aeda:	d104      	bne.n	801aee6 <_ecc_projective_add_point+0x34a>
      err = INIT_MP_INT_SIZE(y, mp_bitsused(modulus));
 801aedc:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801aede:	f00b fbd8 	bl	8026692 <mp_init>
 801aee2:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   }
   if (err == MP_OKAY) {
 801aee6:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801aeea:	2b00      	cmp	r3, #0
 801aeec:	d104      	bne.n	801aef8 <_ecc_projective_add_point+0x35c>
      err = INIT_MP_INT_SIZE(z, mp_bitsused(modulus));
 801aeee:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801aef0:	f00b fbcf 	bl	8026692 <mp_init>
 801aef4:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   }
   if (err != MP_OKAY) {
 801aef8:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801aefc:	2b00      	cmp	r3, #0
 801aefe:	f040 82a0 	bne.w	801b442 <_ecc_projective_add_point+0x8a6>
   x = R->x;
   y = R->y;
   z = R->z;
#endif

   if (err == MP_OKAY)
 801af02:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801af06:	2b00      	cmp	r3, #0
 801af08:	d107      	bne.n	801af1a <_ecc_projective_add_point+0x37e>
       err = mp_copy(P->x, x);
 801af0a:	68fb      	ldr	r3, [r7, #12]
 801af0c:	681b      	ldr	r3, [r3, #0]
 801af0e:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801af10:	4618      	mov	r0, r3
 801af12:	f00b fe0a 	bl	8026b2a <mp_copy>
 801af16:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801af1a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801af1e:	2b00      	cmp	r3, #0
 801af20:	d107      	bne.n	801af32 <_ecc_projective_add_point+0x396>
       err = mp_copy(P->y, y);
 801af22:	68fb      	ldr	r3, [r7, #12]
 801af24:	685b      	ldr	r3, [r3, #4]
 801af26:	6db9      	ldr	r1, [r7, #88]	@ 0x58
 801af28:	4618      	mov	r0, r3
 801af2a:	f00b fdfe 	bl	8026b2a <mp_copy>
 801af2e:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801af32:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801af36:	2b00      	cmp	r3, #0
 801af38:	d107      	bne.n	801af4a <_ecc_projective_add_point+0x3ae>
       err = mp_copy(P->z, z);
 801af3a:	68fb      	ldr	r3, [r7, #12]
 801af3c:	689b      	ldr	r3, [r3, #8]
 801af3e:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 801af40:	4618      	mov	r0, r3
 801af42:	f00b fdf2 	bl	8026b2a <mp_copy>
 801af46:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* if Z is one then these are no-operations */
   if (err == MP_OKAY) {
 801af4a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801af4e:	2b00      	cmp	r3, #0
 801af50:	d16d      	bne.n	801b02e <_ecc_projective_add_point+0x492>
       if (!mp_iszero(Q->z)) {
 801af52:	68bb      	ldr	r3, [r7, #8]
 801af54:	689b      	ldr	r3, [r3, #8]
 801af56:	4618      	mov	r0, r3
 801af58:	f00b fdf5 	bl	8026b46 <mp_iszero>
 801af5c:	4603      	mov	r3, r0
 801af5e:	2b00      	cmp	r3, #0
 801af60:	d165      	bne.n	801b02e <_ecc_projective_add_point+0x492>
           /* T1 = Z' * Z' */
           err = mp_sqr(Q->z, t1);
 801af62:	68bb      	ldr	r3, [r7, #8]
 801af64:	689b      	ldr	r3, [r3, #8]
 801af66:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801af6a:	4618      	mov	r0, r3
 801af6c:	f00c f87c 	bl	8027068 <mp_sqr>
 801af70:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
           if (err == MP_OKAY)
 801af74:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801af78:	2b00      	cmp	r3, #0
 801af7a:	d109      	bne.n	801af90 <_ecc_projective_add_point+0x3f4>
               err = mp_montgomery_reduce(t1, modulus, mp);
 801af7c:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801af80:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801af84:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801af88:	f00c f83e 	bl	8027008 <mp_montgomery_reduce>
 801af8c:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

           /* X = X * T1 */
           if (err == MP_OKAY)
 801af90:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801af94:	2b00      	cmp	r3, #0
 801af96:	d107      	bne.n	801afa8 <_ecc_projective_add_point+0x40c>
               err = mp_mul(t1, x, x);
 801af98:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801af9a:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801af9c:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801afa0:	f00b fc6b 	bl	802687a <mp_mul>
 801afa4:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
           if (err == MP_OKAY)
 801afa8:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801afac:	2b00      	cmp	r3, #0
 801afae:	d108      	bne.n	801afc2 <_ecc_projective_add_point+0x426>
               err = mp_montgomery_reduce(x, modulus, mp);
 801afb0:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801afb4:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801afb8:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801afba:	f00c f825 	bl	8027008 <mp_montgomery_reduce>
 801afbe:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

           /* T1 = Z' * T1 */
           if (err == MP_OKAY)
 801afc2:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801afc6:	2b00      	cmp	r3, #0
 801afc8:	d10a      	bne.n	801afe0 <_ecc_projective_add_point+0x444>
               err = mp_mul(Q->z, t1, t1);
 801afca:	68bb      	ldr	r3, [r7, #8]
 801afcc:	689b      	ldr	r3, [r3, #8]
 801afce:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 801afd2:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801afd6:	4618      	mov	r0, r3
 801afd8:	f00b fc4f 	bl	802687a <mp_mul>
 801afdc:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
           if (err == MP_OKAY)
 801afe0:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801afe4:	2b00      	cmp	r3, #0
 801afe6:	d109      	bne.n	801affc <_ecc_projective_add_point+0x460>
               err = mp_montgomery_reduce(t1, modulus, mp);
 801afe8:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801afec:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801aff0:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801aff4:	f00c f808 	bl	8027008 <mp_montgomery_reduce>
 801aff8:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

           /* Y = Y * T1 */
           if (err == MP_OKAY)
 801affc:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b000:	2b00      	cmp	r3, #0
 801b002:	d107      	bne.n	801b014 <_ecc_projective_add_point+0x478>
               err = mp_mul(t1, y, y);
 801b004:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 801b006:	6db9      	ldr	r1, [r7, #88]	@ 0x58
 801b008:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b00c:	f00b fc35 	bl	802687a <mp_mul>
 801b010:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
           if (err == MP_OKAY)
 801b014:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b018:	2b00      	cmp	r3, #0
 801b01a:	d108      	bne.n	801b02e <_ecc_projective_add_point+0x492>
               err = mp_montgomery_reduce(y, modulus, mp);
 801b01c:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b020:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b024:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801b026:	f00b ffef 	bl	8027008 <mp_montgomery_reduce>
 801b02a:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
       }
   }

   /* T1 = Z*Z */
   if (err == MP_OKAY)
 801b02e:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b032:	2b00      	cmp	r3, #0
 801b034:	d106      	bne.n	801b044 <_ecc_projective_add_point+0x4a8>
       err = mp_sqr(z, t1);
 801b036:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801b03a:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801b03c:	f00c f814 	bl	8027068 <mp_sqr>
 801b040:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b044:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b048:	2b00      	cmp	r3, #0
 801b04a:	d109      	bne.n	801b060 <_ecc_projective_add_point+0x4c4>
       err = mp_montgomery_reduce(t1, modulus, mp);
 801b04c:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b050:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b054:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b058:	f00b ffd6 	bl	8027008 <mp_montgomery_reduce>
 801b05c:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* T2 = X' * T1 */
   if (err == MP_OKAY)
 801b060:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b064:	2b00      	cmp	r3, #0
 801b066:	d10a      	bne.n	801b07e <_ecc_projective_add_point+0x4e2>
       err = mp_mul(Q->x, t1, t2);
 801b068:	68bb      	ldr	r3, [r7, #8]
 801b06a:	681b      	ldr	r3, [r3, #0]
 801b06c:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 801b070:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801b074:	4618      	mov	r0, r3
 801b076:	f00b fc00 	bl	802687a <mp_mul>
 801b07a:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b07e:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b082:	2b00      	cmp	r3, #0
 801b084:	d109      	bne.n	801b09a <_ecc_projective_add_point+0x4fe>
       err = mp_montgomery_reduce(t2, modulus, mp);
 801b086:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b08a:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b08e:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b092:	f00b ffb9 	bl	8027008 <mp_montgomery_reduce>
 801b096:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* T1 = Z * T1 */
   if (err == MP_OKAY)
 801b09a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b09e:	2b00      	cmp	r3, #0
 801b0a0:	d108      	bne.n	801b0b4 <_ecc_projective_add_point+0x518>
       err = mp_mul(z, t1, t1);
 801b0a2:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 801b0a6:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801b0aa:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801b0ac:	f00b fbe5 	bl	802687a <mp_mul>
 801b0b0:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b0b4:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b0b8:	2b00      	cmp	r3, #0
 801b0ba:	d109      	bne.n	801b0d0 <_ecc_projective_add_point+0x534>
       err = mp_montgomery_reduce(t1, modulus, mp);
 801b0bc:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b0c0:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b0c4:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b0c8:	f00b ff9e 	bl	8027008 <mp_montgomery_reduce>
 801b0cc:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* T1 = Y' * T1 */
   if (err == MP_OKAY)
 801b0d0:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b0d4:	2b00      	cmp	r3, #0
 801b0d6:	d10a      	bne.n	801b0ee <_ecc_projective_add_point+0x552>
       err = mp_mul(Q->y, t1, t1);
 801b0d8:	68bb      	ldr	r3, [r7, #8]
 801b0da:	685b      	ldr	r3, [r3, #4]
 801b0dc:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 801b0e0:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801b0e4:	4618      	mov	r0, r3
 801b0e6:	f00b fbc8 	bl	802687a <mp_mul>
 801b0ea:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b0ee:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b0f2:	2b00      	cmp	r3, #0
 801b0f4:	d109      	bne.n	801b10a <_ecc_projective_add_point+0x56e>
       err = mp_montgomery_reduce(t1, modulus, mp);
 801b0f6:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b0fa:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b0fe:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b102:	f00b ff81 	bl	8027008 <mp_montgomery_reduce>
 801b106:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* Y = Y - T1 */
   if (err == MP_OKAY)
 801b10a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b10e:	2b00      	cmp	r3, #0
 801b110:	d109      	bne.n	801b126 <_ecc_projective_add_point+0x58a>
       err = mp_submod_ct(y, t1, modulus, y);
 801b112:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801b114:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b118:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801b11c:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801b11e:	f00b fbd1 	bl	80268c4 <mp_submod_ct>
 801b122:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   /* T1 = 2T1 */
   if (err == MP_OKAY)
 801b126:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b12a:	2b00      	cmp	r3, #0
 801b12c:	d10b      	bne.n	801b146 <_ecc_projective_add_point+0x5aa>
       err = mp_addmod_ct(t1, t1, modulus, t1);
 801b12e:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801b132:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b136:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801b13a:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b13e:	f00b fbd3 	bl	80268e8 <mp_addmod_ct>
 801b142:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   /* T1 = Y + T1 */
   if (err == MP_OKAY)
 801b146:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b14a:	2b00      	cmp	r3, #0
 801b14c:	d10a      	bne.n	801b164 <_ecc_projective_add_point+0x5c8>
       err = mp_addmod_ct(t1, y, modulus, t1);
 801b14e:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801b152:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b156:	6db9      	ldr	r1, [r7, #88]	@ 0x58
 801b158:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b15c:	f00b fbc4 	bl	80268e8 <mp_addmod_ct>
 801b160:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   /* X = X - T2 */
   if (err == MP_OKAY)
 801b164:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b168:	2b00      	cmp	r3, #0
 801b16a:	d109      	bne.n	801b180 <_ecc_projective_add_point+0x5e4>
       err = mp_submod_ct(x, t2, modulus, x);
 801b16c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801b16e:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b172:	f8d7 1084 	ldr.w	r1, [r7, #132]	@ 0x84
 801b176:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801b178:	f00b fba4 	bl	80268c4 <mp_submod_ct>
 801b17c:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   /* T2 = 2T2 */
   if (err == MP_OKAY)
 801b180:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b184:	2b00      	cmp	r3, #0
 801b186:	d10b      	bne.n	801b1a0 <_ecc_projective_add_point+0x604>
       err = mp_addmod_ct(t2, t2, modulus, t2);
 801b188:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801b18c:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b190:	f8d7 1084 	ldr.w	r1, [r7, #132]	@ 0x84
 801b194:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b198:	f00b fba6 	bl	80268e8 <mp_addmod_ct>
 801b19c:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   /* T2 = X + T2 */
   if (err == MP_OKAY)
 801b1a0:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b1a4:	2b00      	cmp	r3, #0
 801b1a6:	d10a      	bne.n	801b1be <_ecc_projective_add_point+0x622>
       err = mp_addmod_ct(t2, x, modulus, t2);
 801b1a8:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801b1ac:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b1b0:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801b1b2:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b1b6:	f00b fb97 	bl	80268e8 <mp_addmod_ct>
 801b1ba:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   if (err == MP_OKAY) {
 801b1be:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b1c2:	2b00      	cmp	r3, #0
 801b1c4:	d11d      	bne.n	801b202 <_ecc_projective_add_point+0x666>
       if (!mp_iszero(Q->z)) {
 801b1c6:	68bb      	ldr	r3, [r7, #8]
 801b1c8:	689b      	ldr	r3, [r3, #8]
 801b1ca:	4618      	mov	r0, r3
 801b1cc:	f00b fcbb 	bl	8026b46 <mp_iszero>
 801b1d0:	4603      	mov	r3, r0
 801b1d2:	2b00      	cmp	r3, #0
 801b1d4:	d115      	bne.n	801b202 <_ecc_projective_add_point+0x666>
           /* Z = Z * Z' */
           err = mp_mul(z, Q->z, z);
 801b1d6:	68bb      	ldr	r3, [r7, #8]
 801b1d8:	689b      	ldr	r3, [r3, #8]
 801b1da:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801b1dc:	4619      	mov	r1, r3
 801b1de:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801b1e0:	f00b fb4b 	bl	802687a <mp_mul>
 801b1e4:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
           if (err == MP_OKAY)
 801b1e8:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b1ec:	2b00      	cmp	r3, #0
 801b1ee:	d108      	bne.n	801b202 <_ecc_projective_add_point+0x666>
               err = mp_montgomery_reduce(z, modulus, mp);
 801b1f0:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b1f4:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b1f8:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801b1fa:	f00b ff05 	bl	8027008 <mp_montgomery_reduce>
 801b1fe:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
       }
   }

   /* Z = Z * X */
   if (err == MP_OKAY)
 801b202:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b206:	2b00      	cmp	r3, #0
 801b208:	d106      	bne.n	801b218 <_ecc_projective_add_point+0x67c>
       err = mp_mul(z, x, z);
 801b20a:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801b20c:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801b20e:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801b210:	f00b fb33 	bl	802687a <mp_mul>
 801b214:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b218:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b21c:	2b00      	cmp	r3, #0
 801b21e:	d108      	bne.n	801b232 <_ecc_projective_add_point+0x696>
       err = mp_montgomery_reduce(z, modulus, mp);
 801b220:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b224:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b228:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801b22a:	f00b feed 	bl	8027008 <mp_montgomery_reduce>
 801b22e:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* T1 = T1 * X  */
   if (err == MP_OKAY)
 801b232:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b236:	2b00      	cmp	r3, #0
 801b238:	d108      	bne.n	801b24c <_ecc_projective_add_point+0x6b0>
       err = mp_mul(t1, x, t1);
 801b23a:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 801b23e:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801b240:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b244:	f00b fb19 	bl	802687a <mp_mul>
 801b248:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b24c:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b250:	2b00      	cmp	r3, #0
 801b252:	d109      	bne.n	801b268 <_ecc_projective_add_point+0x6cc>
       err = mp_montgomery_reduce(t1, modulus, mp);
 801b254:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b258:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b25c:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b260:	f00b fed2 	bl	8027008 <mp_montgomery_reduce>
 801b264:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* X = X * X */
   if (err == MP_OKAY)
 801b268:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b26c:	2b00      	cmp	r3, #0
 801b26e:	d105      	bne.n	801b27c <_ecc_projective_add_point+0x6e0>
       err = mp_sqr(x, x);
 801b270:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801b272:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801b274:	f00b fef8 	bl	8027068 <mp_sqr>
 801b278:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b27c:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b280:	2b00      	cmp	r3, #0
 801b282:	d108      	bne.n	801b296 <_ecc_projective_add_point+0x6fa>
       err = mp_montgomery_reduce(x, modulus, mp);
 801b284:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b288:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b28c:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801b28e:	f00b febb 	bl	8027008 <mp_montgomery_reduce>
 801b292:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* T2 = T2 * x */
   if (err == MP_OKAY)
 801b296:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b29a:	2b00      	cmp	r3, #0
 801b29c:	d108      	bne.n	801b2b0 <_ecc_projective_add_point+0x714>
       err = mp_mul(t2, x, t2);
 801b29e:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 801b2a2:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801b2a4:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b2a8:	f00b fae7 	bl	802687a <mp_mul>
 801b2ac:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b2b0:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b2b4:	2b00      	cmp	r3, #0
 801b2b6:	d109      	bne.n	801b2cc <_ecc_projective_add_point+0x730>
       err = mp_montgomery_reduce(t2, modulus, mp);
 801b2b8:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b2bc:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b2c0:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b2c4:	f00b fea0 	bl	8027008 <mp_montgomery_reduce>
 801b2c8:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* T1 = T1 * X  */
   if (err == MP_OKAY)
 801b2cc:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b2d0:	2b00      	cmp	r3, #0
 801b2d2:	d108      	bne.n	801b2e6 <_ecc_projective_add_point+0x74a>
       err = mp_mul(t1, x, t1);
 801b2d4:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 801b2d8:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801b2da:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b2de:	f00b facc 	bl	802687a <mp_mul>
 801b2e2:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b2e6:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b2ea:	2b00      	cmp	r3, #0
 801b2ec:	d109      	bne.n	801b302 <_ecc_projective_add_point+0x766>
       err = mp_montgomery_reduce(t1, modulus, mp);
 801b2ee:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b2f2:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b2f6:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b2fa:	f00b fe85 	bl	8027008 <mp_montgomery_reduce>
 801b2fe:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* X = Y*Y */
   if (err == MP_OKAY)
 801b302:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b306:	2b00      	cmp	r3, #0
 801b308:	d105      	bne.n	801b316 <_ecc_projective_add_point+0x77a>
       err = mp_sqr(y, x);
 801b30a:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801b30c:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801b30e:	f00b feab 	bl	8027068 <mp_sqr>
 801b312:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b316:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b31a:	2b00      	cmp	r3, #0
 801b31c:	d108      	bne.n	801b330 <_ecc_projective_add_point+0x794>
       err = mp_montgomery_reduce(x, modulus, mp);
 801b31e:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b322:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b326:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801b328:	f00b fe6e 	bl	8027008 <mp_montgomery_reduce>
 801b32c:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* X = X - T2 */
   if (err == MP_OKAY)
 801b330:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b334:	2b00      	cmp	r3, #0
 801b336:	d109      	bne.n	801b34c <_ecc_projective_add_point+0x7b0>
       err = mp_submod_ct(x, t2, modulus, x);
 801b338:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801b33a:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b33e:	f8d7 1084 	ldr.w	r1, [r7, #132]	@ 0x84
 801b342:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801b344:	f00b fabe 	bl	80268c4 <mp_submod_ct>
 801b348:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   /* T2 = T2 - X */
   if (err == MP_OKAY)
 801b34c:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b350:	2b00      	cmp	r3, #0
 801b352:	d10a      	bne.n	801b36a <_ecc_projective_add_point+0x7ce>
       err = mp_submod_ct(t2, x, modulus, t2);
 801b354:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801b358:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b35c:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801b35e:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b362:	f00b faaf 	bl	80268c4 <mp_submod_ct>
 801b366:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   /* T2 = T2 - X */
   if (err == MP_OKAY)
 801b36a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b36e:	2b00      	cmp	r3, #0
 801b370:	d10a      	bne.n	801b388 <_ecc_projective_add_point+0x7ec>
       err = mp_submod_ct(t2, x, modulus, t2);
 801b372:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801b376:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b37a:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801b37c:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b380:	f00b faa0 	bl	80268c4 <mp_submod_ct>
 801b384:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   /* T2 = T2 * Y */
   if (err == MP_OKAY)
 801b388:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b38c:	2b00      	cmp	r3, #0
 801b38e:	d108      	bne.n	801b3a2 <_ecc_projective_add_point+0x806>
       err = mp_mul(t2, y, t2);
 801b390:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 801b394:	6db9      	ldr	r1, [r7, #88]	@ 0x58
 801b396:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b39a:	f00b fa6e 	bl	802687a <mp_mul>
 801b39e:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b3a2:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b3a6:	2b00      	cmp	r3, #0
 801b3a8:	d109      	bne.n	801b3be <_ecc_projective_add_point+0x822>
       err = mp_montgomery_reduce(t2, modulus, mp);
 801b3aa:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b3ae:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b3b2:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b3b6:	f00b fe27 	bl	8027008 <mp_montgomery_reduce>
 801b3ba:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* Y = T2 - T1 */
   if (err == MP_OKAY)
 801b3be:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b3c2:	2b00      	cmp	r3, #0
 801b3c4:	d10a      	bne.n	801b3dc <_ecc_projective_add_point+0x840>
       err = mp_submod_ct(t2, t1, modulus, y);
 801b3c6:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801b3c8:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b3cc:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801b3d0:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b3d4:	f00b fa76 	bl	80268c4 <mp_submod_ct>
 801b3d8:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   /* Y = Y/2 */
   if (err == MP_OKAY)
 801b3dc:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b3e0:	2b00      	cmp	r3, #0
 801b3e2:	d107      	bne.n	801b3f4 <_ecc_projective_add_point+0x858>
       err = mp_div_2_mod_ct(y, modulus, y);
 801b3e4:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 801b3e6:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b3ea:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801b3ec:	f00b fe4a 	bl	8027084 <mp_div_2_mod_ct>
 801b3f0:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

#ifdef ALT_ECC_SIZE
   if (err == MP_OKAY)
 801b3f4:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b3f8:	2b00      	cmp	r3, #0
 801b3fa:	d107      	bne.n	801b40c <_ecc_projective_add_point+0x870>
       err = mp_copy(x, R->x);
 801b3fc:	687b      	ldr	r3, [r7, #4]
 801b3fe:	681b      	ldr	r3, [r3, #0]
 801b400:	4619      	mov	r1, r3
 801b402:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801b404:	f00b fb91 	bl	8026b2a <mp_copy>
 801b408:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b40c:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b410:	2b00      	cmp	r3, #0
 801b412:	d107      	bne.n	801b424 <_ecc_projective_add_point+0x888>
       err = mp_copy(y, R->y);
 801b414:	687b      	ldr	r3, [r7, #4]
 801b416:	685b      	ldr	r3, [r3, #4]
 801b418:	4619      	mov	r1, r3
 801b41a:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801b41c:	f00b fb85 	bl	8026b2a <mp_copy>
 801b420:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b424:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b428:	2b00      	cmp	r3, #0
 801b42a:	d10c      	bne.n	801b446 <_ecc_projective_add_point+0x8aa>
       err = mp_copy(z, R->z);
 801b42c:	687b      	ldr	r3, [r7, #4]
 801b42e:	689b      	ldr	r3, [r3, #8]
 801b430:	4619      	mov	r1, r3
 801b432:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801b434:	f00b fb79 	bl	8026b2a <mp_copy>
 801b438:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
 801b43c:	e004      	b.n	801b448 <_ecc_projective_add_point+0x8ac>
      goto done;
 801b43e:	bf00      	nop
 801b440:	e002      	b.n	801b448 <_ecc_projective_add_point+0x8ac>
      goto done;
 801b442:	bf00      	nop
 801b444:	e000      	b.n	801b448 <_ecc_projective_add_point+0x8ac>
#endif

done:
 801b446:	bf00      	nop

   /* clean up */
   mp_clear(t1);
 801b448:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b44c:	f00b f9ab 	bl	80267a6 <mp_clear>
   mp_clear(t2);
 801b450:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b454:	f00b f9a7 	bl	80267a6 <mp_clear>
   if (R->key == NULL)
#endif
#endif
   {
   #ifdef ALT_ECC_SIZE
      FREE_MP_INT_SIZE(rz, NULL, DYNAMIC_TYPE_ECC);
 801b458:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801b45a:	653b      	str	r3, [r7, #80]	@ 0x50
 801b45c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801b45e:	2b00      	cmp	r3, #0
 801b460:	d002      	beq.n	801b468 <_ecc_projective_add_point+0x8cc>
 801b462:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 801b464:	f003 fb2c 	bl	801eac0 <wolfSSL_Free>
      FREE_MP_INT_SIZE(ry, NULL, DYNAMIC_TYPE_ECC);
 801b468:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801b46a:	64fb      	str	r3, [r7, #76]	@ 0x4c
 801b46c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801b46e:	2b00      	cmp	r3, #0
 801b470:	d002      	beq.n	801b478 <_ecc_projective_add_point+0x8dc>
 801b472:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 801b474:	f003 fb24 	bl	801eac0 <wolfSSL_Free>
      FREE_MP_INT_SIZE(rx, NULL, DYNAMIC_TYPE_ECC);
 801b478:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801b47c:	64bb      	str	r3, [r7, #72]	@ 0x48
 801b47e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801b480:	2b00      	cmp	r3, #0
 801b482:	d002      	beq.n	801b48a <_ecc_projective_add_point+0x8ee>
 801b484:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 801b486:	f003 fb1b 	bl	801eac0 <wolfSSL_Free>
   #endif
      FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801b48a:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801b48e:	647b      	str	r3, [r7, #68]	@ 0x44
 801b490:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801b492:	2b00      	cmp	r3, #0
 801b494:	d002      	beq.n	801b49c <_ecc_projective_add_point+0x900>
 801b496:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 801b498:	f003 fb12 	bl	801eac0 <wolfSSL_Free>
      FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801b49c:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801b4a0:	643b      	str	r3, [r7, #64]	@ 0x40
 801b4a2:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801b4a4:	2b00      	cmp	r3, #0
 801b4a6:	d002      	beq.n	801b4ae <_ecc_projective_add_point+0x912>
 801b4a8:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 801b4aa:	f003 fb09 	bl	801eac0 <wolfSSL_Free>
   }

   return err;
 801b4ae:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
                                         R->x, R->y, R->z);
    }
#endif
    return ECC_BAD_ARG_E;
#endif
}
 801b4b2:	4618      	mov	r0, r3
 801b4b4:	3790      	adds	r7, #144	@ 0x90
 801b4b6:	46bd      	mov	sp, r7
 801b4b8:	bd80      	pop	{r7, pc}

0801b4ba <_ecc_projective_dbl_point>:
   mp       The "b" value from montgomery_setup()
   return   MP_OKAY on success
*/
static int _ecc_projective_dbl_point(ecc_point *P, ecc_point *R, mp_int* a,
                                     mp_int* modulus, mp_digit mp)
{
 801b4ba:	b580      	push	{r7, lr}
 801b4bc:	b0a4      	sub	sp, #144	@ 0x90
 801b4be:	af00      	add	r7, sp, #0
 801b4c0:	60f8      	str	r0, [r7, #12]
 801b4c2:	60b9      	str	r1, [r7, #8]
 801b4c4:	607a      	str	r2, [r7, #4]
 801b4c6:	603b      	str	r3, [r7, #0]
#if !defined(WOLFSSL_SP_MATH)
   DECL_MP_INT_SIZE_DYN(t1, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801b4c8:	2300      	movs	r3, #0
 801b4ca:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
   DECL_MP_INT_SIZE_DYN(t2, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801b4ce:	2300      	movs	r3, #0
 801b4d0:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
#ifdef ALT_ECC_SIZE
   DECL_MP_INT_SIZE_DYN(rx, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801b4d4:	2300      	movs	r3, #0
 801b4d6:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
   DECL_MP_INT_SIZE_DYN(ry, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801b4da:	2300      	movs	r3, #0
 801b4dc:	67fb      	str	r3, [r7, #124]	@ 0x7c
   DECL_MP_INT_SIZE_DYN(rz, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801b4de:	2300      	movs	r3, #0
 801b4e0:	67bb      	str	r3, [r7, #120]	@ 0x78
   }
   else
#endif /* WOLFSSL_SMALL_STACK_CACHE */
#endif
   {
      NEW_MP_INT_SIZE(t1, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801b4e2:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801b4e6:	f003 facf 	bl	801ea88 <wolfSSL_Malloc>
 801b4ea:	f8c7 0088 	str.w	r0, [r7, #136]	@ 0x88
 801b4ee:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801b4f2:	2b00      	cmp	r3, #0
 801b4f4:	d006      	beq.n	801b504 <_ecc_projective_dbl_point+0x4a>
 801b4f6:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801b4fa:	2100      	movs	r1, #0
 801b4fc:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b500:	f00c ffe2 	bl	80284c8 <memset>
      NEW_MP_INT_SIZE(t2, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801b504:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801b508:	f003 fabe 	bl	801ea88 <wolfSSL_Malloc>
 801b50c:	f8c7 0084 	str.w	r0, [r7, #132]	@ 0x84
 801b510:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801b514:	2b00      	cmp	r3, #0
 801b516:	d006      	beq.n	801b526 <_ecc_projective_dbl_point+0x6c>
 801b518:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801b51c:	2100      	movs	r1, #0
 801b51e:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b522:	f00c ffd1 	bl	80284c8 <memset>
   #ifdef MP_INT_SIZE_CHECK_NULL
      if (t1 == NULL || t2 == NULL) {
 801b526:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801b52a:	2b00      	cmp	r3, #0
 801b52c:	d003      	beq.n	801b536 <_ecc_projective_dbl_point+0x7c>
 801b52e:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801b532:	2b00      	cmp	r3, #0
 801b534:	d114      	bne.n	801b560 <_ecc_projective_dbl_point+0xa6>
         FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801b536:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801b53a:	61bb      	str	r3, [r7, #24]
 801b53c:	69bb      	ldr	r3, [r7, #24]
 801b53e:	2b00      	cmp	r3, #0
 801b540:	d002      	beq.n	801b548 <_ecc_projective_dbl_point+0x8e>
 801b542:	69b8      	ldr	r0, [r7, #24]
 801b544:	f003 fabc 	bl	801eac0 <wolfSSL_Free>
         FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801b548:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801b54c:	617b      	str	r3, [r7, #20]
 801b54e:	697b      	ldr	r3, [r7, #20]
 801b550:	2b00      	cmp	r3, #0
 801b552:	d002      	beq.n	801b55a <_ecc_projective_dbl_point+0xa0>
 801b554:	6978      	ldr	r0, [r7, #20]
 801b556:	f003 fab3 	bl	801eac0 <wolfSSL_Free>
         return MEMORY_E;
 801b55a:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801b55e:	e2c1      	b.n	801bae4 <_ecc_projective_dbl_point+0x62a>
      }
   #endif
   #ifdef ALT_ECC_SIZE
      NEW_MP_INT_SIZE(rx, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801b560:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801b564:	f003 fa90 	bl	801ea88 <wolfSSL_Malloc>
 801b568:	f8c7 0080 	str.w	r0, [r7, #128]	@ 0x80
 801b56c:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801b570:	2b00      	cmp	r3, #0
 801b572:	d006      	beq.n	801b582 <_ecc_projective_dbl_point+0xc8>
 801b574:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801b578:	2100      	movs	r1, #0
 801b57a:	f8d7 0080 	ldr.w	r0, [r7, #128]	@ 0x80
 801b57e:	f00c ffa3 	bl	80284c8 <memset>
      NEW_MP_INT_SIZE(ry, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801b582:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801b586:	f003 fa7f 	bl	801ea88 <wolfSSL_Malloc>
 801b58a:	67f8      	str	r0, [r7, #124]	@ 0x7c
 801b58c:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801b58e:	2b00      	cmp	r3, #0
 801b590:	d005      	beq.n	801b59e <_ecc_projective_dbl_point+0xe4>
 801b592:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801b596:	2100      	movs	r1, #0
 801b598:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
 801b59a:	f00c ff95 	bl	80284c8 <memset>
      NEW_MP_INT_SIZE(rz, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801b59e:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801b5a2:	f003 fa71 	bl	801ea88 <wolfSSL_Malloc>
 801b5a6:	67b8      	str	r0, [r7, #120]	@ 0x78
 801b5a8:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801b5aa:	2b00      	cmp	r3, #0
 801b5ac:	d005      	beq.n	801b5ba <_ecc_projective_dbl_point+0x100>
 801b5ae:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801b5b2:	2100      	movs	r1, #0
 801b5b4:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 801b5b6:	f00c ff87 	bl	80284c8 <memset>
   #ifdef MP_INT_SIZE_CHECK_NULL
      if (rx == NULL || ry == NULL || rz == NULL) {
 801b5ba:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801b5be:	2b00      	cmp	r3, #0
 801b5c0:	d005      	beq.n	801b5ce <_ecc_projective_dbl_point+0x114>
 801b5c2:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801b5c4:	2b00      	cmp	r3, #0
 801b5c6:	d002      	beq.n	801b5ce <_ecc_projective_dbl_point+0x114>
 801b5c8:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801b5ca:	2b00      	cmp	r3, #0
 801b5cc:	d12d      	bne.n	801b62a <_ecc_projective_dbl_point+0x170>
          FREE_MP_INT_SIZE(rz, NULL, DYNAMIC_TYPE_ECC);
 801b5ce:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801b5d0:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801b5d2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801b5d4:	2b00      	cmp	r3, #0
 801b5d6:	d002      	beq.n	801b5de <_ecc_projective_dbl_point+0x124>
 801b5d8:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 801b5da:	f003 fa71 	bl	801eac0 <wolfSSL_Free>
          FREE_MP_INT_SIZE(ry, NULL, DYNAMIC_TYPE_ECC);
 801b5de:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801b5e0:	62bb      	str	r3, [r7, #40]	@ 0x28
 801b5e2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801b5e4:	2b00      	cmp	r3, #0
 801b5e6:	d002      	beq.n	801b5ee <_ecc_projective_dbl_point+0x134>
 801b5e8:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801b5ea:	f003 fa69 	bl	801eac0 <wolfSSL_Free>
          FREE_MP_INT_SIZE(rx, NULL, DYNAMIC_TYPE_ECC);
 801b5ee:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801b5f2:	627b      	str	r3, [r7, #36]	@ 0x24
 801b5f4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801b5f6:	2b00      	cmp	r3, #0
 801b5f8:	d002      	beq.n	801b600 <_ecc_projective_dbl_point+0x146>
 801b5fa:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 801b5fc:	f003 fa60 	bl	801eac0 <wolfSSL_Free>
          FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801b600:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801b604:	623b      	str	r3, [r7, #32]
 801b606:	6a3b      	ldr	r3, [r7, #32]
 801b608:	2b00      	cmp	r3, #0
 801b60a:	d002      	beq.n	801b612 <_ecc_projective_dbl_point+0x158>
 801b60c:	6a38      	ldr	r0, [r7, #32]
 801b60e:	f003 fa57 	bl	801eac0 <wolfSSL_Free>
          FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801b612:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801b616:	61fb      	str	r3, [r7, #28]
 801b618:	69fb      	ldr	r3, [r7, #28]
 801b61a:	2b00      	cmp	r3, #0
 801b61c:	d002      	beq.n	801b624 <_ecc_projective_dbl_point+0x16a>
 801b61e:	69f8      	ldr	r0, [r7, #28]
 801b620:	f003 fa4e 	bl	801eac0 <wolfSSL_Free>
          return MEMORY_E;
 801b624:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801b628:	e25c      	b.n	801bae4 <_ecc_projective_dbl_point+0x62a>
      }
   #endif
   #endif
   }

   err = INIT_MP_INT_SIZE(t1, mp_bitsused(modulus));
 801b62a:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b62e:	f00b f830 	bl	8026692 <mp_init>
 801b632:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY) {
 801b636:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b63a:	2b00      	cmp	r3, #0
 801b63c:	d105      	bne.n	801b64a <_ecc_projective_dbl_point+0x190>
      err = INIT_MP_INT_SIZE(t2, mp_bitsused(modulus));
 801b63e:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b642:	f00b f826 	bl	8026692 <mp_init>
 801b646:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   }
   if (err != MP_OKAY) {
 801b64a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b64e:	2b00      	cmp	r3, #0
 801b650:	d02d      	beq.n	801b6ae <_ecc_projective_dbl_point+0x1f4>
      if (R->key == NULL)
   #endif
#endif
      {
      #ifdef ALT_ECC_SIZE
         FREE_MP_INT_SIZE(rz, NULL, DYNAMIC_TYPE_ECC);
 801b652:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801b654:	643b      	str	r3, [r7, #64]	@ 0x40
 801b656:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801b658:	2b00      	cmp	r3, #0
 801b65a:	d002      	beq.n	801b662 <_ecc_projective_dbl_point+0x1a8>
 801b65c:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 801b65e:	f003 fa2f 	bl	801eac0 <wolfSSL_Free>
         FREE_MP_INT_SIZE(ry, NULL, DYNAMIC_TYPE_ECC);
 801b662:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801b664:	63fb      	str	r3, [r7, #60]	@ 0x3c
 801b666:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801b668:	2b00      	cmp	r3, #0
 801b66a:	d002      	beq.n	801b672 <_ecc_projective_dbl_point+0x1b8>
 801b66c:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 801b66e:	f003 fa27 	bl	801eac0 <wolfSSL_Free>
         FREE_MP_INT_SIZE(rx, NULL, DYNAMIC_TYPE_ECC);
 801b672:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801b676:	63bb      	str	r3, [r7, #56]	@ 0x38
 801b678:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801b67a:	2b00      	cmp	r3, #0
 801b67c:	d002      	beq.n	801b684 <_ecc_projective_dbl_point+0x1ca>
 801b67e:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 801b680:	f003 fa1e 	bl	801eac0 <wolfSSL_Free>
      #endif
         FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801b684:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801b688:	637b      	str	r3, [r7, #52]	@ 0x34
 801b68a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801b68c:	2b00      	cmp	r3, #0
 801b68e:	d002      	beq.n	801b696 <_ecc_projective_dbl_point+0x1dc>
 801b690:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801b692:	f003 fa15 	bl	801eac0 <wolfSSL_Free>
         FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801b696:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801b69a:	633b      	str	r3, [r7, #48]	@ 0x30
 801b69c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801b69e:	2b00      	cmp	r3, #0
 801b6a0:	d002      	beq.n	801b6a8 <_ecc_projective_dbl_point+0x1ee>
 801b6a2:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 801b6a4:	f003 fa0c 	bl	801eac0 <wolfSSL_Free>
      }
      return err;
 801b6a8:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b6ac:	e21a      	b.n	801bae4 <_ecc_projective_dbl_point+0x62a>

/* If use ALT_ECC_SIZE we need to use local stack variable since
   ecc_point x,y,z is reduced size */
#ifdef ALT_ECC_SIZE
   /* Use local stack variable */
   x = rx;
 801b6ae:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801b6b2:	677b      	str	r3, [r7, #116]	@ 0x74
   y = ry;
 801b6b4:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801b6b6:	673b      	str	r3, [r7, #112]	@ 0x70
   z = rz;
 801b6b8:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801b6ba:	66fb      	str	r3, [r7, #108]	@ 0x6c

   err = INIT_MP_INT_SIZE(x, mp_bitsused(modulus));
 801b6bc:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 801b6be:	f00a ffe8 	bl	8026692 <mp_init>
 801b6c2:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY) {
 801b6c6:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b6ca:	2b00      	cmp	r3, #0
 801b6cc:	d104      	bne.n	801b6d8 <_ecc_projective_dbl_point+0x21e>
      err = INIT_MP_INT_SIZE(y, mp_bitsused(modulus));
 801b6ce:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801b6d0:	f00a ffdf 	bl	8026692 <mp_init>
 801b6d4:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   }
   if (err == MP_OKAY) {
 801b6d8:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b6dc:	2b00      	cmp	r3, #0
 801b6de:	d104      	bne.n	801b6ea <_ecc_projective_dbl_point+0x230>
      err = INIT_MP_INT_SIZE(z, mp_bitsused(modulus));
 801b6e0:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 801b6e2:	f00a ffd6 	bl	8026692 <mp_init>
 801b6e6:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   }
   if (err != MP_OKAY) {
 801b6ea:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b6ee:	2b00      	cmp	r3, #0
 801b6f0:	d02d      	beq.n	801b74e <_ecc_projective_dbl_point+0x294>
      if (R->key == NULL)
   #endif
#endif
      {
      #ifdef ALT_ECC_SIZE
         FREE_MP_INT_SIZE(rz, NULL, DYNAMIC_TYPE_ECC);
 801b6f2:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801b6f4:	657b      	str	r3, [r7, #84]	@ 0x54
 801b6f6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801b6f8:	2b00      	cmp	r3, #0
 801b6fa:	d002      	beq.n	801b702 <_ecc_projective_dbl_point+0x248>
 801b6fc:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801b6fe:	f003 f9df 	bl	801eac0 <wolfSSL_Free>
         FREE_MP_INT_SIZE(ry, NULL, DYNAMIC_TYPE_ECC);
 801b702:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801b704:	653b      	str	r3, [r7, #80]	@ 0x50
 801b706:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801b708:	2b00      	cmp	r3, #0
 801b70a:	d002      	beq.n	801b712 <_ecc_projective_dbl_point+0x258>
 801b70c:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 801b70e:	f003 f9d7 	bl	801eac0 <wolfSSL_Free>
         FREE_MP_INT_SIZE(rx, NULL, DYNAMIC_TYPE_ECC);
 801b712:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801b716:	64fb      	str	r3, [r7, #76]	@ 0x4c
 801b718:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801b71a:	2b00      	cmp	r3, #0
 801b71c:	d002      	beq.n	801b724 <_ecc_projective_dbl_point+0x26a>
 801b71e:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 801b720:	f003 f9ce 	bl	801eac0 <wolfSSL_Free>
      #endif
         FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801b724:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801b728:	64bb      	str	r3, [r7, #72]	@ 0x48
 801b72a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801b72c:	2b00      	cmp	r3, #0
 801b72e:	d002      	beq.n	801b736 <_ecc_projective_dbl_point+0x27c>
 801b730:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 801b732:	f003 f9c5 	bl	801eac0 <wolfSSL_Free>
         FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801b736:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801b73a:	647b      	str	r3, [r7, #68]	@ 0x44
 801b73c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801b73e:	2b00      	cmp	r3, #0
 801b740:	d002      	beq.n	801b748 <_ecc_projective_dbl_point+0x28e>
 801b742:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 801b744:	f003 f9bc 	bl	801eac0 <wolfSSL_Free>
      }
      return err;
 801b748:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b74c:	e1ca      	b.n	801bae4 <_ecc_projective_dbl_point+0x62a>
   x = R->x;
   y = R->y;
   z = R->z;
#endif

   if (err == MP_OKAY)
 801b74e:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b752:	2b00      	cmp	r3, #0
 801b754:	d107      	bne.n	801b766 <_ecc_projective_dbl_point+0x2ac>
       err = mp_copy(P->x, x);
 801b756:	68fb      	ldr	r3, [r7, #12]
 801b758:	681b      	ldr	r3, [r3, #0]
 801b75a:	6f79      	ldr	r1, [r7, #116]	@ 0x74
 801b75c:	4618      	mov	r0, r3
 801b75e:	f00b f9e4 	bl	8026b2a <mp_copy>
 801b762:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b766:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b76a:	2b00      	cmp	r3, #0
 801b76c:	d107      	bne.n	801b77e <_ecc_projective_dbl_point+0x2c4>
       err = mp_copy(P->y, y);
 801b76e:	68fb      	ldr	r3, [r7, #12]
 801b770:	685b      	ldr	r3, [r3, #4]
 801b772:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 801b774:	4618      	mov	r0, r3
 801b776:	f00b f9d8 	bl	8026b2a <mp_copy>
 801b77a:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b77e:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b782:	2b00      	cmp	r3, #0
 801b784:	d107      	bne.n	801b796 <_ecc_projective_dbl_point+0x2dc>
       err = mp_copy(P->z, z);
 801b786:	68fb      	ldr	r3, [r7, #12]
 801b788:	689b      	ldr	r3, [r3, #8]
 801b78a:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 801b78c:	4618      	mov	r0, r3
 801b78e:	f00b f9cc 	bl	8026b2a <mp_copy>
 801b792:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* T1 = Z * Z */
   if (err == MP_OKAY)
 801b796:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b79a:	2b00      	cmp	r3, #0
 801b79c:	d106      	bne.n	801b7ac <_ecc_projective_dbl_point+0x2f2>
       err = mp_sqr(z, t1);
 801b79e:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801b7a2:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 801b7a4:	f00b fc60 	bl	8027068 <mp_sqr>
 801b7a8:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b7ac:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b7b0:	2b00      	cmp	r3, #0
 801b7b2:	d108      	bne.n	801b7c6 <_ecc_projective_dbl_point+0x30c>
       err = mp_montgomery_reduce(t1, modulus, mp);
 801b7b4:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b7b8:	6839      	ldr	r1, [r7, #0]
 801b7ba:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b7be:	f00b fc23 	bl	8027008 <mp_montgomery_reduce>
 801b7c2:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* Z = Y * Z */
   if (err == MP_OKAY)
 801b7c6:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b7ca:	2b00      	cmp	r3, #0
 801b7cc:	d106      	bne.n	801b7dc <_ecc_projective_dbl_point+0x322>
       err = mp_mul(z, y, z);
 801b7ce:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 801b7d0:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 801b7d2:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 801b7d4:	f00b f851 	bl	802687a <mp_mul>
 801b7d8:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b7dc:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b7e0:	2b00      	cmp	r3, #0
 801b7e2:	d107      	bne.n	801b7f4 <_ecc_projective_dbl_point+0x33a>
       err = mp_montgomery_reduce(z, modulus, mp);
 801b7e4:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b7e8:	6839      	ldr	r1, [r7, #0]
 801b7ea:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 801b7ec:	f00b fc0c 	bl	8027008 <mp_montgomery_reduce>
 801b7f0:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* Z = 2Z */
   if (err == MP_OKAY)
 801b7f4:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b7f8:	2b00      	cmp	r3, #0
 801b7fa:	d107      	bne.n	801b80c <_ecc_projective_dbl_point+0x352>
       err = mp_addmod_ct(z, z, modulus, z);
 801b7fc:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801b7fe:	683a      	ldr	r2, [r7, #0]
 801b800:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 801b802:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 801b804:	f00b f870 	bl	80268e8 <mp_addmod_ct>
 801b808:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   {
      /* assumes "a" == 3 */
      (void)a;

      /* T2 = X - T1 */
      if (err == MP_OKAY)
 801b80c:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b810:	2b00      	cmp	r3, #0
 801b812:	d109      	bne.n	801b828 <_ecc_projective_dbl_point+0x36e>
          err = mp_submod_ct(x, t1, modulus, t2);
 801b814:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801b818:	683a      	ldr	r2, [r7, #0]
 801b81a:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801b81e:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 801b820:	f00b f850 	bl	80268c4 <mp_submod_ct>
 801b824:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
      /* T1 = X + T1 */
      if (err == MP_OKAY)
 801b828:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b82c:	2b00      	cmp	r3, #0
 801b82e:	d109      	bne.n	801b844 <_ecc_projective_dbl_point+0x38a>
          err = mp_addmod_ct(t1, x, modulus, t1);
 801b830:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801b834:	683a      	ldr	r2, [r7, #0]
 801b836:	6f79      	ldr	r1, [r7, #116]	@ 0x74
 801b838:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b83c:	f00b f854 	bl	80268e8 <mp_addmod_ct>
 801b840:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
      /* T2 = T1 * T2 */
      if (err == MP_OKAY)
 801b844:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b848:	2b00      	cmp	r3, #0
 801b84a:	d109      	bne.n	801b860 <_ecc_projective_dbl_point+0x3a6>
          err = mp_mul(t1, t2, t2);
 801b84c:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 801b850:	f8d7 1084 	ldr.w	r1, [r7, #132]	@ 0x84
 801b854:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b858:	f00b f80f 	bl	802687a <mp_mul>
 801b85c:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
      if (err == MP_OKAY)
 801b860:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b864:	2b00      	cmp	r3, #0
 801b866:	d108      	bne.n	801b87a <_ecc_projective_dbl_point+0x3c0>
          err = mp_montgomery_reduce(t2, modulus, mp);
 801b868:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b86c:	6839      	ldr	r1, [r7, #0]
 801b86e:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b872:	f00b fbc9 	bl	8027008 <mp_montgomery_reduce>
 801b876:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

      /* T1 = 2T2 */
      if (err == MP_OKAY)
 801b87a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b87e:	2b00      	cmp	r3, #0
 801b880:	d10a      	bne.n	801b898 <_ecc_projective_dbl_point+0x3de>
          err = mp_addmod_ct(t2, t2, modulus, t1);
 801b882:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801b886:	683a      	ldr	r2, [r7, #0]
 801b888:	f8d7 1084 	ldr.w	r1, [r7, #132]	@ 0x84
 801b88c:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b890:	f00b f82a 	bl	80268e8 <mp_addmod_ct>
 801b894:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
      /* T1 = T1 + T2 */
      if (err == MP_OKAY)
 801b898:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b89c:	2b00      	cmp	r3, #0
 801b89e:	d10a      	bne.n	801b8b6 <_ecc_projective_dbl_point+0x3fc>
          err = mp_addmod_ct(t1, t2, modulus, t1);
 801b8a0:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801b8a4:	683a      	ldr	r2, [r7, #0]
 801b8a6:	f8d7 1084 	ldr.w	r1, [r7, #132]	@ 0x84
 801b8aa:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b8ae:	f00b f81b 	bl	80268e8 <mp_addmod_ct>
 801b8b2:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   }

   /* Y = 2Y */
   if (err == MP_OKAY)
 801b8b6:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b8ba:	2b00      	cmp	r3, #0
 801b8bc:	d107      	bne.n	801b8ce <_ecc_projective_dbl_point+0x414>
       err = mp_addmod_ct(y, y, modulus, y);
 801b8be:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801b8c0:	683a      	ldr	r2, [r7, #0]
 801b8c2:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 801b8c4:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801b8c6:	f00b f80f 	bl	80268e8 <mp_addmod_ct>
 801b8ca:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   /* Y = Y * Y */
   if (err == MP_OKAY)
 801b8ce:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b8d2:	2b00      	cmp	r3, #0
 801b8d4:	d105      	bne.n	801b8e2 <_ecc_projective_dbl_point+0x428>
       err = mp_sqr(y, y);
 801b8d6:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 801b8d8:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801b8da:	f00b fbc5 	bl	8027068 <mp_sqr>
 801b8de:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b8e2:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b8e6:	2b00      	cmp	r3, #0
 801b8e8:	d107      	bne.n	801b8fa <_ecc_projective_dbl_point+0x440>
       err = mp_montgomery_reduce(y, modulus, mp);
 801b8ea:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b8ee:	6839      	ldr	r1, [r7, #0]
 801b8f0:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801b8f2:	f00b fb89 	bl	8027008 <mp_montgomery_reduce>
 801b8f6:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* T2 = Y * Y */
   if (err == MP_OKAY)
 801b8fa:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b8fe:	2b00      	cmp	r3, #0
 801b900:	d106      	bne.n	801b910 <_ecc_projective_dbl_point+0x456>
       err = mp_sqr(y, t2);
 801b902:	f8d7 1084 	ldr.w	r1, [r7, #132]	@ 0x84
 801b906:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801b908:	f00b fbae 	bl	8027068 <mp_sqr>
 801b90c:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b910:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b914:	2b00      	cmp	r3, #0
 801b916:	d108      	bne.n	801b92a <_ecc_projective_dbl_point+0x470>
       err = mp_montgomery_reduce(t2, modulus, mp);
 801b918:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b91c:	6839      	ldr	r1, [r7, #0]
 801b91e:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b922:	f00b fb71 	bl	8027008 <mp_montgomery_reduce>
 801b926:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* T2 = T2/2 */
   if (err == MP_OKAY)
 801b92a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b92e:	2b00      	cmp	r3, #0
 801b930:	d108      	bne.n	801b944 <_ecc_projective_dbl_point+0x48a>
       err = mp_div_2_mod_ct(t2, modulus, t2);
 801b932:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 801b936:	6839      	ldr	r1, [r7, #0]
 801b938:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b93c:	f00b fba2 	bl	8027084 <mp_div_2_mod_ct>
 801b940:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* Y = Y * X */
   if (err == MP_OKAY)
 801b944:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b948:	2b00      	cmp	r3, #0
 801b94a:	d106      	bne.n	801b95a <_ecc_projective_dbl_point+0x4a0>
       err = mp_mul(y, x, y);
 801b94c:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 801b94e:	6f79      	ldr	r1, [r7, #116]	@ 0x74
 801b950:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801b952:	f00a ff92 	bl	802687a <mp_mul>
 801b956:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b95a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b95e:	2b00      	cmp	r3, #0
 801b960:	d107      	bne.n	801b972 <_ecc_projective_dbl_point+0x4b8>
       err = mp_montgomery_reduce(y, modulus, mp);
 801b962:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b966:	6839      	ldr	r1, [r7, #0]
 801b968:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801b96a:	f00b fb4d 	bl	8027008 <mp_montgomery_reduce>
 801b96e:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* X = T1 * T1 */
   if (err == MP_OKAY)
 801b972:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b976:	2b00      	cmp	r3, #0
 801b978:	d106      	bne.n	801b988 <_ecc_projective_dbl_point+0x4ce>
       err = mp_sqr(t1, x);
 801b97a:	6f79      	ldr	r1, [r7, #116]	@ 0x74
 801b97c:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b980:	f00b fb72 	bl	8027068 <mp_sqr>
 801b984:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b988:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b98c:	2b00      	cmp	r3, #0
 801b98e:	d107      	bne.n	801b9a0 <_ecc_projective_dbl_point+0x4e6>
       err = mp_montgomery_reduce(x, modulus, mp);
 801b990:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b994:	6839      	ldr	r1, [r7, #0]
 801b996:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 801b998:	f00b fb36 	bl	8027008 <mp_montgomery_reduce>
 801b99c:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* X = X - Y */
   if (err == MP_OKAY)
 801b9a0:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b9a4:	2b00      	cmp	r3, #0
 801b9a6:	d107      	bne.n	801b9b8 <_ecc_projective_dbl_point+0x4fe>
       err = mp_submod_ct(x, y, modulus, x);
 801b9a8:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801b9aa:	683a      	ldr	r2, [r7, #0]
 801b9ac:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 801b9ae:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 801b9b0:	f00a ff88 	bl	80268c4 <mp_submod_ct>
 801b9b4:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   /* X = X - Y */
   if (err == MP_OKAY)
 801b9b8:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b9bc:	2b00      	cmp	r3, #0
 801b9be:	d107      	bne.n	801b9d0 <_ecc_projective_dbl_point+0x516>
       err = mp_submod_ct(x, y, modulus, x);
 801b9c0:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801b9c2:	683a      	ldr	r2, [r7, #0]
 801b9c4:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 801b9c6:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 801b9c8:	f00a ff7c 	bl	80268c4 <mp_submod_ct>
 801b9cc:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* Y = Y - X */
   if (err == MP_OKAY)
 801b9d0:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b9d4:	2b00      	cmp	r3, #0
 801b9d6:	d107      	bne.n	801b9e8 <_ecc_projective_dbl_point+0x52e>
       err = mp_submod_ct(y, x, modulus, y);
 801b9d8:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801b9da:	683a      	ldr	r2, [r7, #0]
 801b9dc:	6f79      	ldr	r1, [r7, #116]	@ 0x74
 801b9de:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801b9e0:	f00a ff70 	bl	80268c4 <mp_submod_ct>
 801b9e4:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   /* Y = Y * T1 */
   if (err == MP_OKAY)
 801b9e8:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b9ec:	2b00      	cmp	r3, #0
 801b9ee:	d107      	bne.n	801ba00 <_ecc_projective_dbl_point+0x546>
       err = mp_mul(y, t1, y);
 801b9f0:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 801b9f2:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801b9f6:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801b9f8:	f00a ff3f 	bl	802687a <mp_mul>
 801b9fc:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801ba00:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801ba04:	2b00      	cmp	r3, #0
 801ba06:	d107      	bne.n	801ba18 <_ecc_projective_dbl_point+0x55e>
       err = mp_montgomery_reduce(y, modulus, mp);
 801ba08:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801ba0c:	6839      	ldr	r1, [r7, #0]
 801ba0e:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801ba10:	f00b fafa 	bl	8027008 <mp_montgomery_reduce>
 801ba14:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* Y = Y - T2 */
   if (err == MP_OKAY)
 801ba18:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801ba1c:	2b00      	cmp	r3, #0
 801ba1e:	d108      	bne.n	801ba32 <_ecc_projective_dbl_point+0x578>
       err = mp_submod_ct(y, t2, modulus, y);
 801ba20:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801ba22:	683a      	ldr	r2, [r7, #0]
 801ba24:	f8d7 1084 	ldr.w	r1, [r7, #132]	@ 0x84
 801ba28:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801ba2a:	f00a ff4b 	bl	80268c4 <mp_submod_ct>
 801ba2e:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

#ifdef ALT_ECC_SIZE
   if (err == MP_OKAY)
 801ba32:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801ba36:	2b00      	cmp	r3, #0
 801ba38:	d107      	bne.n	801ba4a <_ecc_projective_dbl_point+0x590>
       err = mp_copy(x, R->x);
 801ba3a:	68bb      	ldr	r3, [r7, #8]
 801ba3c:	681b      	ldr	r3, [r3, #0]
 801ba3e:	4619      	mov	r1, r3
 801ba40:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 801ba42:	f00b f872 	bl	8026b2a <mp_copy>
 801ba46:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801ba4a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801ba4e:	2b00      	cmp	r3, #0
 801ba50:	d107      	bne.n	801ba62 <_ecc_projective_dbl_point+0x5a8>
       err = mp_copy(y, R->y);
 801ba52:	68bb      	ldr	r3, [r7, #8]
 801ba54:	685b      	ldr	r3, [r3, #4]
 801ba56:	4619      	mov	r1, r3
 801ba58:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801ba5a:	f00b f866 	bl	8026b2a <mp_copy>
 801ba5e:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801ba62:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801ba66:	2b00      	cmp	r3, #0
 801ba68:	d107      	bne.n	801ba7a <_ecc_projective_dbl_point+0x5c0>
       err = mp_copy(z, R->z);
 801ba6a:	68bb      	ldr	r3, [r7, #8]
 801ba6c:	689b      	ldr	r3, [r3, #8]
 801ba6e:	4619      	mov	r1, r3
 801ba70:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 801ba72:	f00b f85a 	bl	8026b2a <mp_copy>
 801ba76:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
#endif

   /* clean up */
   mp_clear(t1);
 801ba7a:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801ba7e:	f00a fe92 	bl	80267a6 <mp_clear>
   mp_clear(t2);
 801ba82:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801ba86:	f00a fe8e 	bl	80267a6 <mp_clear>
   if (R->key == NULL)
#endif
#endif
   {
    #ifdef ALT_ECC_SIZE
       FREE_MP_INT_SIZE(rz, NULL, DYNAMIC_TYPE_ECC);
 801ba8a:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801ba8c:	66bb      	str	r3, [r7, #104]	@ 0x68
 801ba8e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801ba90:	2b00      	cmp	r3, #0
 801ba92:	d002      	beq.n	801ba9a <_ecc_projective_dbl_point+0x5e0>
 801ba94:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 801ba96:	f003 f813 	bl	801eac0 <wolfSSL_Free>
       FREE_MP_INT_SIZE(ry, NULL, DYNAMIC_TYPE_ECC);
 801ba9a:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801ba9c:	667b      	str	r3, [r7, #100]	@ 0x64
 801ba9e:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801baa0:	2b00      	cmp	r3, #0
 801baa2:	d002      	beq.n	801baaa <_ecc_projective_dbl_point+0x5f0>
 801baa4:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 801baa6:	f003 f80b 	bl	801eac0 <wolfSSL_Free>
       FREE_MP_INT_SIZE(rx, NULL, DYNAMIC_TYPE_ECC);
 801baaa:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801baae:	663b      	str	r3, [r7, #96]	@ 0x60
 801bab0:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801bab2:	2b00      	cmp	r3, #0
 801bab4:	d002      	beq.n	801babc <_ecc_projective_dbl_point+0x602>
 801bab6:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 801bab8:	f003 f802 	bl	801eac0 <wolfSSL_Free>
    #endif
       FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801babc:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801bac0:	65fb      	str	r3, [r7, #92]	@ 0x5c
 801bac2:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801bac4:	2b00      	cmp	r3, #0
 801bac6:	d002      	beq.n	801bace <_ecc_projective_dbl_point+0x614>
 801bac8:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801baca:	f002 fff9 	bl	801eac0 <wolfSSL_Free>
       FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801bace:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801bad2:	65bb      	str	r3, [r7, #88]	@ 0x58
 801bad4:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801bad6:	2b00      	cmp	r3, #0
 801bad8:	d002      	beq.n	801bae0 <_ecc_projective_dbl_point+0x626>
 801bada:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801badc:	f002 fff0 	bl	801eac0 <wolfSSL_Free>
    }

   return err;
 801bae0:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
        return sp_ecc_proj_dbl_point_521(P->x, P->y, P->z, R->x, R->y, R->z);
    }
#endif
    return ECC_BAD_ARG_E;
#endif
}
 801bae4:	4618      	mov	r0, r3
 801bae6:	3790      	adds	r7, #144	@ 0x90
 801bae8:	46bd      	mov	sp, r7
 801baea:	bd80      	pop	{r7, pc}

0801baec <ecc_map_ex>:
  mp       The "b" value from montgomery_setup()
  ct       Operation should be constant time.
  return   MP_OKAY on success
*/
int ecc_map_ex(ecc_point* P, mp_int* modulus, mp_digit mp, int ct)
{
 801baec:	b580      	push	{r7, lr}
 801baee:	b09e      	sub	sp, #120	@ 0x78
 801baf0:	af00      	add	r7, sp, #0
 801baf2:	60f8      	str	r0, [r7, #12]
 801baf4:	60b9      	str	r1, [r7, #8]
 801baf6:	607a      	str	r2, [r7, #4]
 801baf8:	603b      	str	r3, [r7, #0]
   int err = MP_OKAY;
 801bafa:	2300      	movs	r3, #0
 801bafc:	677b      	str	r3, [r7, #116]	@ 0x74
#if !defined(WOLFSSL_SP_MATH)
   DECL_MP_INT_SIZE_DYN(t1, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801bafe:	2300      	movs	r3, #0
 801bb00:	673b      	str	r3, [r7, #112]	@ 0x70
   DECL_MP_INT_SIZE_DYN(t2, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801bb02:	2300      	movs	r3, #0
 801bb04:	66fb      	str	r3, [r7, #108]	@ 0x6c
#ifdef ALT_ECC_SIZE
   DECL_MP_INT_SIZE_DYN(rx, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801bb06:	2300      	movs	r3, #0
 801bb08:	66bb      	str	r3, [r7, #104]	@ 0x68
   DECL_MP_INT_SIZE_DYN(ry, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801bb0a:	2300      	movs	r3, #0
 801bb0c:	667b      	str	r3, [r7, #100]	@ 0x64
   DECL_MP_INT_SIZE_DYN(rz, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801bb0e:	2300      	movs	r3, #0
 801bb10:	663b      	str	r3, [r7, #96]	@ 0x60
#endif
   mp_int *x, *y, *z;

   (void)ct;

   if (P == NULL || modulus == NULL)
 801bb12:	68fb      	ldr	r3, [r7, #12]
 801bb14:	2b00      	cmp	r3, #0
 801bb16:	d002      	beq.n	801bb1e <ecc_map_ex+0x32>
 801bb18:	68bb      	ldr	r3, [r7, #8]
 801bb1a:	2b00      	cmp	r3, #0
 801bb1c:	d102      	bne.n	801bb24 <ecc_map_ex+0x38>
       return ECC_BAD_ARG_E;
 801bb1e:	f06f 03a9 	mvn.w	r3, #169	@ 0xa9
 801bb22:	e1f7      	b.n	801bf14 <ecc_map_ex+0x428>

   /* special case for point at infinity */
   if (mp_cmp_d(P->z, 0) == MP_EQ) {
 801bb24:	68fb      	ldr	r3, [r7, #12]
 801bb26:	689b      	ldr	r3, [r3, #8]
 801bb28:	2100      	movs	r1, #0
 801bb2a:	4618      	mov	r0, r3
 801bb2c:	f00a ff52 	bl	80269d4 <mp_cmp_d>
 801bb30:	4603      	mov	r3, r0
 801bb32:	2b00      	cmp	r3, #0
 801bb34:	d11c      	bne.n	801bb70 <ecc_map_ex+0x84>
       err = mp_set(P->x, 0);
 801bb36:	68fb      	ldr	r3, [r7, #12]
 801bb38:	681b      	ldr	r3, [r3, #0]
 801bb3a:	2100      	movs	r1, #0
 801bb3c:	4618      	mov	r0, r3
 801bb3e:	f00b fab1 	bl	80270a4 <mp_set>
 801bb42:	6778      	str	r0, [r7, #116]	@ 0x74
       if (err == MP_OKAY)
 801bb44:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bb46:	2b00      	cmp	r3, #0
 801bb48:	d106      	bne.n	801bb58 <ecc_map_ex+0x6c>
           err = mp_set(P->y, 0);
 801bb4a:	68fb      	ldr	r3, [r7, #12]
 801bb4c:	685b      	ldr	r3, [r3, #4]
 801bb4e:	2100      	movs	r1, #0
 801bb50:	4618      	mov	r0, r3
 801bb52:	f00b faa7 	bl	80270a4 <mp_set>
 801bb56:	6778      	str	r0, [r7, #116]	@ 0x74
       if (err == MP_OKAY)
 801bb58:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bb5a:	2b00      	cmp	r3, #0
 801bb5c:	d106      	bne.n	801bb6c <ecc_map_ex+0x80>
           err = mp_set(P->z, 1);
 801bb5e:	68fb      	ldr	r3, [r7, #12]
 801bb60:	689b      	ldr	r3, [r3, #8]
 801bb62:	2101      	movs	r1, #1
 801bb64:	4618      	mov	r0, r3
 801bb66:	f00b fa9d 	bl	80270a4 <mp_set>
 801bb6a:	6778      	str	r0, [r7, #116]	@ 0x74
       return err;
 801bb6c:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bb6e:	e1d1      	b.n	801bf14 <ecc_map_ex+0x428>
   }
   else
#endif /* WOLFSSL_SMALL_STACK_CACHE */
#endif
   {
      NEW_MP_INT_SIZE(t1, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801bb70:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801bb74:	f002 ff88 	bl	801ea88 <wolfSSL_Malloc>
 801bb78:	6738      	str	r0, [r7, #112]	@ 0x70
 801bb7a:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801bb7c:	2b00      	cmp	r3, #0
 801bb7e:	d005      	beq.n	801bb8c <ecc_map_ex+0xa0>
 801bb80:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801bb84:	2100      	movs	r1, #0
 801bb86:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801bb88:	f00c fc9e 	bl	80284c8 <memset>
      NEW_MP_INT_SIZE(t2, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801bb8c:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801bb90:	f002 ff7a 	bl	801ea88 <wolfSSL_Malloc>
 801bb94:	66f8      	str	r0, [r7, #108]	@ 0x6c
 801bb96:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801bb98:	2b00      	cmp	r3, #0
 801bb9a:	d005      	beq.n	801bba8 <ecc_map_ex+0xbc>
 801bb9c:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801bba0:	2100      	movs	r1, #0
 801bba2:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 801bba4:	f00c fc90 	bl	80284c8 <memset>
   #ifdef MP_INT_SIZE_CHECK_NULL
      if (t1 == NULL || t2 == NULL) {
 801bba8:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801bbaa:	2b00      	cmp	r3, #0
 801bbac:	d002      	beq.n	801bbb4 <ecc_map_ex+0xc8>
 801bbae:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801bbb0:	2b00      	cmp	r3, #0
 801bbb2:	d112      	bne.n	801bbda <ecc_map_ex+0xee>
         FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801bbb4:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801bbb6:	617b      	str	r3, [r7, #20]
 801bbb8:	697b      	ldr	r3, [r7, #20]
 801bbba:	2b00      	cmp	r3, #0
 801bbbc:	d002      	beq.n	801bbc4 <ecc_map_ex+0xd8>
 801bbbe:	6978      	ldr	r0, [r7, #20]
 801bbc0:	f002 ff7e 	bl	801eac0 <wolfSSL_Free>
         FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801bbc4:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801bbc6:	613b      	str	r3, [r7, #16]
 801bbc8:	693b      	ldr	r3, [r7, #16]
 801bbca:	2b00      	cmp	r3, #0
 801bbcc:	d002      	beq.n	801bbd4 <ecc_map_ex+0xe8>
 801bbce:	6938      	ldr	r0, [r7, #16]
 801bbd0:	f002 ff76 	bl	801eac0 <wolfSSL_Free>
         return MEMORY_E;
 801bbd4:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801bbd8:	e19c      	b.n	801bf14 <ecc_map_ex+0x428>
      }
   #endif
   #ifdef ALT_ECC_SIZE
      NEW_MP_INT_SIZE(rx, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801bbda:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801bbde:	f002 ff53 	bl	801ea88 <wolfSSL_Malloc>
 801bbe2:	66b8      	str	r0, [r7, #104]	@ 0x68
 801bbe4:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801bbe6:	2b00      	cmp	r3, #0
 801bbe8:	d005      	beq.n	801bbf6 <ecc_map_ex+0x10a>
 801bbea:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801bbee:	2100      	movs	r1, #0
 801bbf0:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 801bbf2:	f00c fc69 	bl	80284c8 <memset>
      NEW_MP_INT_SIZE(ry, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801bbf6:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801bbfa:	f002 ff45 	bl	801ea88 <wolfSSL_Malloc>
 801bbfe:	6678      	str	r0, [r7, #100]	@ 0x64
 801bc00:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801bc02:	2b00      	cmp	r3, #0
 801bc04:	d005      	beq.n	801bc12 <ecc_map_ex+0x126>
 801bc06:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801bc0a:	2100      	movs	r1, #0
 801bc0c:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 801bc0e:	f00c fc5b 	bl	80284c8 <memset>
      NEW_MP_INT_SIZE(rz, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801bc12:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801bc16:	f002 ff37 	bl	801ea88 <wolfSSL_Malloc>
 801bc1a:	6638      	str	r0, [r7, #96]	@ 0x60
 801bc1c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801bc1e:	2b00      	cmp	r3, #0
 801bc20:	d005      	beq.n	801bc2e <ecc_map_ex+0x142>
 801bc22:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801bc26:	2100      	movs	r1, #0
 801bc28:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 801bc2a:	f00c fc4d 	bl	80284c8 <memset>
   #ifdef MP_INT_SIZE_CHECK_NULL
      if (rx == NULL || ry == NULL || rz == NULL) {
 801bc2e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801bc30:	2b00      	cmp	r3, #0
 801bc32:	d005      	beq.n	801bc40 <ecc_map_ex+0x154>
 801bc34:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801bc36:	2b00      	cmp	r3, #0
 801bc38:	d002      	beq.n	801bc40 <ecc_map_ex+0x154>
 801bc3a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801bc3c:	2b00      	cmp	r3, #0
 801bc3e:	d12a      	bne.n	801bc96 <ecc_map_ex+0x1aa>
          FREE_MP_INT_SIZE(rz, NULL, DYNAMIC_TYPE_ECC);
 801bc40:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801bc42:	62bb      	str	r3, [r7, #40]	@ 0x28
 801bc44:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801bc46:	2b00      	cmp	r3, #0
 801bc48:	d002      	beq.n	801bc50 <ecc_map_ex+0x164>
 801bc4a:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801bc4c:	f002 ff38 	bl	801eac0 <wolfSSL_Free>
          FREE_MP_INT_SIZE(ry, NULL, DYNAMIC_TYPE_ECC);
 801bc50:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801bc52:	627b      	str	r3, [r7, #36]	@ 0x24
 801bc54:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801bc56:	2b00      	cmp	r3, #0
 801bc58:	d002      	beq.n	801bc60 <ecc_map_ex+0x174>
 801bc5a:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 801bc5c:	f002 ff30 	bl	801eac0 <wolfSSL_Free>
          FREE_MP_INT_SIZE(rx, NULL, DYNAMIC_TYPE_ECC);
 801bc60:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801bc62:	623b      	str	r3, [r7, #32]
 801bc64:	6a3b      	ldr	r3, [r7, #32]
 801bc66:	2b00      	cmp	r3, #0
 801bc68:	d002      	beq.n	801bc70 <ecc_map_ex+0x184>
 801bc6a:	6a38      	ldr	r0, [r7, #32]
 801bc6c:	f002 ff28 	bl	801eac0 <wolfSSL_Free>
          FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801bc70:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801bc72:	61fb      	str	r3, [r7, #28]
 801bc74:	69fb      	ldr	r3, [r7, #28]
 801bc76:	2b00      	cmp	r3, #0
 801bc78:	d002      	beq.n	801bc80 <ecc_map_ex+0x194>
 801bc7a:	69f8      	ldr	r0, [r7, #28]
 801bc7c:	f002 ff20 	bl	801eac0 <wolfSSL_Free>
          FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801bc80:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801bc82:	61bb      	str	r3, [r7, #24]
 801bc84:	69bb      	ldr	r3, [r7, #24]
 801bc86:	2b00      	cmp	r3, #0
 801bc88:	d002      	beq.n	801bc90 <ecc_map_ex+0x1a4>
 801bc8a:	69b8      	ldr	r0, [r7, #24]
 801bc8c:	f002 ff18 	bl	801eac0 <wolfSSL_Free>
          return MEMORY_E;
 801bc90:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801bc94:	e13e      	b.n	801bf14 <ecc_map_ex+0x428>
      }
   #endif
   #endif
   }

   err = INIT_MP_INT_SIZE(t1, mp_bitsused(modulus));
 801bc96:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801bc98:	f00a fcfb 	bl	8026692 <mp_init>
 801bc9c:	6778      	str	r0, [r7, #116]	@ 0x74
   if (err == MP_OKAY) {
 801bc9e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bca0:	2b00      	cmp	r3, #0
 801bca2:	d103      	bne.n	801bcac <ecc_map_ex+0x1c0>
      err = INIT_MP_INT_SIZE(t2, mp_bitsused(modulus));
 801bca4:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 801bca6:	f00a fcf4 	bl	8026692 <mp_init>
 801bcaa:	6778      	str	r0, [r7, #116]	@ 0x74
   }
   if (err != MP_OKAY) {
 801bcac:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bcae:	2b00      	cmp	r3, #0
 801bcb0:	d02a      	beq.n	801bd08 <ecc_map_ex+0x21c>
      if (P->key == NULL)
   #endif
#endif
      {
      #ifdef ALT_ECC_SIZE
         FREE_MP_INT_SIZE(rz, NULL, DYNAMIC_TYPE_ECC);
 801bcb2:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801bcb4:	63fb      	str	r3, [r7, #60]	@ 0x3c
 801bcb6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801bcb8:	2b00      	cmp	r3, #0
 801bcba:	d002      	beq.n	801bcc2 <ecc_map_ex+0x1d6>
 801bcbc:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 801bcbe:	f002 feff 	bl	801eac0 <wolfSSL_Free>
         FREE_MP_INT_SIZE(ry, NULL, DYNAMIC_TYPE_ECC);
 801bcc2:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801bcc4:	63bb      	str	r3, [r7, #56]	@ 0x38
 801bcc6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801bcc8:	2b00      	cmp	r3, #0
 801bcca:	d002      	beq.n	801bcd2 <ecc_map_ex+0x1e6>
 801bccc:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 801bcce:	f002 fef7 	bl	801eac0 <wolfSSL_Free>
         FREE_MP_INT_SIZE(rx, NULL, DYNAMIC_TYPE_ECC);
 801bcd2:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801bcd4:	637b      	str	r3, [r7, #52]	@ 0x34
 801bcd6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801bcd8:	2b00      	cmp	r3, #0
 801bcda:	d002      	beq.n	801bce2 <ecc_map_ex+0x1f6>
 801bcdc:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801bcde:	f002 feef 	bl	801eac0 <wolfSSL_Free>
      #endif
         FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801bce2:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801bce4:	633b      	str	r3, [r7, #48]	@ 0x30
 801bce6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801bce8:	2b00      	cmp	r3, #0
 801bcea:	d002      	beq.n	801bcf2 <ecc_map_ex+0x206>
 801bcec:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 801bcee:	f002 fee7 	bl	801eac0 <wolfSSL_Free>
         FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801bcf2:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801bcf4:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801bcf6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801bcf8:	2b00      	cmp	r3, #0
 801bcfa:	d002      	beq.n	801bd02 <ecc_map_ex+0x216>
 801bcfc:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 801bcfe:	f002 fedf 	bl	801eac0 <wolfSSL_Free>
      }
      return MEMORY_E;
 801bd02:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801bd06:	e105      	b.n	801bf14 <ecc_map_ex+0x428>
   }

#ifdef ALT_ECC_SIZE
   /* Use local stack variable */
   x = rx;
 801bd08:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801bd0a:	65fb      	str	r3, [r7, #92]	@ 0x5c
   y = ry;
 801bd0c:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801bd0e:	65bb      	str	r3, [r7, #88]	@ 0x58
   z = rz;
 801bd10:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801bd12:	657b      	str	r3, [r7, #84]	@ 0x54

   err = INIT_MP_INT_SIZE(x, mp_bitsused(modulus));
 801bd14:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801bd16:	f00a fcbc 	bl	8026692 <mp_init>
 801bd1a:	6778      	str	r0, [r7, #116]	@ 0x74
   if (err == MP_OKAY) {
 801bd1c:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bd1e:	2b00      	cmp	r3, #0
 801bd20:	d103      	bne.n	801bd2a <ecc_map_ex+0x23e>
      err = INIT_MP_INT_SIZE(y, mp_bitsused(modulus));
 801bd22:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801bd24:	f00a fcb5 	bl	8026692 <mp_init>
 801bd28:	6778      	str	r0, [r7, #116]	@ 0x74
   }
   if (err == MP_OKAY) {
 801bd2a:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bd2c:	2b00      	cmp	r3, #0
 801bd2e:	d103      	bne.n	801bd38 <ecc_map_ex+0x24c>
      err = INIT_MP_INT_SIZE(z, mp_bitsused(modulus));
 801bd30:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801bd32:	f00a fcae 	bl	8026692 <mp_init>
 801bd36:	6778      	str	r0, [r7, #116]	@ 0x74
   }
   if (err != MP_OKAY) {
 801bd38:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bd3a:	2b00      	cmp	r3, #0
 801bd3c:	f040 80b6 	bne.w	801beac <ecc_map_ex+0x3c0>
      goto done;
   }

   if (err == MP_OKAY)
 801bd40:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bd42:	2b00      	cmp	r3, #0
 801bd44:	d106      	bne.n	801bd54 <ecc_map_ex+0x268>
      err = mp_copy(P->x, x);
 801bd46:	68fb      	ldr	r3, [r7, #12]
 801bd48:	681b      	ldr	r3, [r3, #0]
 801bd4a:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801bd4c:	4618      	mov	r0, r3
 801bd4e:	f00a feec 	bl	8026b2a <mp_copy>
 801bd52:	6778      	str	r0, [r7, #116]	@ 0x74
   if (err == MP_OKAY)
 801bd54:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bd56:	2b00      	cmp	r3, #0
 801bd58:	d106      	bne.n	801bd68 <ecc_map_ex+0x27c>
      err = mp_copy(P->y, y);
 801bd5a:	68fb      	ldr	r3, [r7, #12]
 801bd5c:	685b      	ldr	r3, [r3, #4]
 801bd5e:	6db9      	ldr	r1, [r7, #88]	@ 0x58
 801bd60:	4618      	mov	r0, r3
 801bd62:	f00a fee2 	bl	8026b2a <mp_copy>
 801bd66:	6778      	str	r0, [r7, #116]	@ 0x74
   if (err == MP_OKAY)
 801bd68:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bd6a:	2b00      	cmp	r3, #0
 801bd6c:	d106      	bne.n	801bd7c <ecc_map_ex+0x290>
      err = mp_copy(P->z, z);
 801bd6e:	68fb      	ldr	r3, [r7, #12]
 801bd70:	689b      	ldr	r3, [r3, #8]
 801bd72:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 801bd74:	4618      	mov	r0, r3
 801bd76:	f00a fed8 	bl	8026b2a <mp_copy>
 801bd7a:	6778      	str	r0, [r7, #116]	@ 0x74

   if (err != MP_OKAY) {
 801bd7c:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bd7e:	2b00      	cmp	r3, #0
 801bd80:	f040 8096 	bne.w	801beb0 <ecc_map_ex+0x3c4>
   y = P->y;
   z = P->z;
#endif

   /* get 1/z */
   if (err == MP_OKAY) {
 801bd84:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bd86:	2b00      	cmp	r3, #0
 801bd88:	d122      	bne.n	801bdd0 <ecc_map_ex+0x2e4>
#if defined(ECC_TIMING_RESISTANT) && (defined(USE_FAST_MATH) || \
                       defined(WOLFSSL_SP_MATH) || defined(WOLFSSL_SP_MATH_ALL))
       if (ct) {
 801bd8a:	683b      	ldr	r3, [r7, #0]
 801bd8c:	2b00      	cmp	r3, #0
 801bd8e:	d010      	beq.n	801bdb2 <ecc_map_ex+0x2c6>
           err = mp_invmod_mont_ct(z, modulus, t1, mp);
 801bd90:	687b      	ldr	r3, [r7, #4]
 801bd92:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 801bd94:	68b9      	ldr	r1, [r7, #8]
 801bd96:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801bd98:	f00a fdd8 	bl	802694c <mp_invmod_mont_ct>
 801bd9c:	6778      	str	r0, [r7, #116]	@ 0x74
           if (err == MP_OKAY)
 801bd9e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bda0:	2b00      	cmp	r3, #0
 801bda2:	d115      	bne.n	801bdd0 <ecc_map_ex+0x2e4>
               err = mp_montgomery_reduce(t1, modulus, mp);
 801bda4:	687a      	ldr	r2, [r7, #4]
 801bda6:	68b9      	ldr	r1, [r7, #8]
 801bda8:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801bdaa:	f00b f92d 	bl	8027008 <mp_montgomery_reduce>
 801bdae:	6778      	str	r0, [r7, #116]	@ 0x74
 801bdb0:	e00e      	b.n	801bdd0 <ecc_map_ex+0x2e4>
       }
       else
#endif
       {
           /* first map z back to normal */
           err = mp_montgomery_reduce(z, modulus, mp);
 801bdb2:	687a      	ldr	r2, [r7, #4]
 801bdb4:	68b9      	ldr	r1, [r7, #8]
 801bdb6:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801bdb8:	f00b f926 	bl	8027008 <mp_montgomery_reduce>
 801bdbc:	6778      	str	r0, [r7, #116]	@ 0x74
           if (err == MP_OKAY)
 801bdbe:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bdc0:	2b00      	cmp	r3, #0
 801bdc2:	d105      	bne.n	801bdd0 <ecc_map_ex+0x2e4>
               err = mp_invmod(z, modulus, t1);
 801bdc4:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 801bdc6:	68b9      	ldr	r1, [r7, #8]
 801bdc8:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801bdca:	f00a fdaf 	bl	802692c <mp_invmod>
 801bdce:	6778      	str	r0, [r7, #116]	@ 0x74
       }
   }

   /* get 1/z^2 and 1/z^3 */
   if (err == MP_OKAY)
 801bdd0:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bdd2:	2b00      	cmp	r3, #0
 801bdd4:	d104      	bne.n	801bde0 <ecc_map_ex+0x2f4>
       err = mp_sqr(t1, t2);
 801bdd6:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 801bdd8:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801bdda:	f00b f945 	bl	8027068 <mp_sqr>
 801bdde:	6778      	str	r0, [r7, #116]	@ 0x74
   if (err == MP_OKAY)
 801bde0:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bde2:	2b00      	cmp	r3, #0
 801bde4:	d105      	bne.n	801bdf2 <ecc_map_ex+0x306>
       err = mp_mod(t2, modulus, t2);
 801bde6:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 801bde8:	68b9      	ldr	r1, [r7, #8]
 801bdea:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 801bdec:	f00a fd8e 	bl	802690c <mp_mod>
 801bdf0:	6778      	str	r0, [r7, #116]	@ 0x74
   if (err == MP_OKAY)
 801bdf2:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bdf4:	2b00      	cmp	r3, #0
 801bdf6:	d105      	bne.n	801be04 <ecc_map_ex+0x318>
       err = mp_mul(t1, t2, t1);
 801bdf8:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 801bdfa:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 801bdfc:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801bdfe:	f00a fd3c 	bl	802687a <mp_mul>
 801be02:	6778      	str	r0, [r7, #116]	@ 0x74
   if (err == MP_OKAY)
 801be04:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801be06:	2b00      	cmp	r3, #0
 801be08:	d105      	bne.n	801be16 <ecc_map_ex+0x32a>
       err = mp_mod(t1, modulus, t1);
 801be0a:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 801be0c:	68b9      	ldr	r1, [r7, #8]
 801be0e:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801be10:	f00a fd7c 	bl	802690c <mp_mod>
 801be14:	6778      	str	r0, [r7, #116]	@ 0x74

   /* multiply against x/y */
   if (err == MP_OKAY)
 801be16:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801be18:	2b00      	cmp	r3, #0
 801be1a:	d105      	bne.n	801be28 <ecc_map_ex+0x33c>
       err = mp_mul(x, t2, x);
 801be1c:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801be1e:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 801be20:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801be22:	f00a fd2a 	bl	802687a <mp_mul>
 801be26:	6778      	str	r0, [r7, #116]	@ 0x74
   if (err == MP_OKAY)
 801be28:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801be2a:	2b00      	cmp	r3, #0
 801be2c:	d105      	bne.n	801be3a <ecc_map_ex+0x34e>
       err = mp_montgomery_reduce(x, modulus, mp);
 801be2e:	687a      	ldr	r2, [r7, #4]
 801be30:	68b9      	ldr	r1, [r7, #8]
 801be32:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801be34:	f00b f8e8 	bl	8027008 <mp_montgomery_reduce>
 801be38:	6778      	str	r0, [r7, #116]	@ 0x74
   if (err == MP_OKAY)
 801be3a:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801be3c:	2b00      	cmp	r3, #0
 801be3e:	d105      	bne.n	801be4c <ecc_map_ex+0x360>
       err = mp_mul(y, t1, y);
 801be40:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 801be42:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 801be44:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801be46:	f00a fd18 	bl	802687a <mp_mul>
 801be4a:	6778      	str	r0, [r7, #116]	@ 0x74
   if (err == MP_OKAY)
 801be4c:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801be4e:	2b00      	cmp	r3, #0
 801be50:	d105      	bne.n	801be5e <ecc_map_ex+0x372>
       err = mp_montgomery_reduce(y, modulus, mp);
 801be52:	687a      	ldr	r2, [r7, #4]
 801be54:	68b9      	ldr	r1, [r7, #8]
 801be56:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801be58:	f00b f8d6 	bl	8027008 <mp_montgomery_reduce>
 801be5c:	6778      	str	r0, [r7, #116]	@ 0x74

   if (err == MP_OKAY)
 801be5e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801be60:	2b00      	cmp	r3, #0
 801be62:	d104      	bne.n	801be6e <ecc_map_ex+0x382>
       err = mp_set(z, 1);
 801be64:	2101      	movs	r1, #1
 801be66:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801be68:	f00b f91c 	bl	80270a4 <mp_set>
 801be6c:	6778      	str	r0, [r7, #116]	@ 0x74

#ifdef ALT_ECC_SIZE
   /* return result */
   if (err == MP_OKAY)
 801be6e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801be70:	2b00      	cmp	r3, #0
 801be72:	d106      	bne.n	801be82 <ecc_map_ex+0x396>
      err = mp_copy(x, P->x);
 801be74:	68fb      	ldr	r3, [r7, #12]
 801be76:	681b      	ldr	r3, [r3, #0]
 801be78:	4619      	mov	r1, r3
 801be7a:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801be7c:	f00a fe55 	bl	8026b2a <mp_copy>
 801be80:	6778      	str	r0, [r7, #116]	@ 0x74
   if (err == MP_OKAY)
 801be82:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801be84:	2b00      	cmp	r3, #0
 801be86:	d106      	bne.n	801be96 <ecc_map_ex+0x3aa>
      err = mp_copy(y, P->y);
 801be88:	68fb      	ldr	r3, [r7, #12]
 801be8a:	685b      	ldr	r3, [r3, #4]
 801be8c:	4619      	mov	r1, r3
 801be8e:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801be90:	f00a fe4b 	bl	8026b2a <mp_copy>
 801be94:	6778      	str	r0, [r7, #116]	@ 0x74
   if (err == MP_OKAY)
 801be96:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801be98:	2b00      	cmp	r3, #0
 801be9a:	d10b      	bne.n	801beb4 <ecc_map_ex+0x3c8>
      err = mp_copy(z, P->z);
 801be9c:	68fb      	ldr	r3, [r7, #12]
 801be9e:	689b      	ldr	r3, [r3, #8]
 801bea0:	4619      	mov	r1, r3
 801bea2:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801bea4:	f00a fe41 	bl	8026b2a <mp_copy>
 801bea8:	6778      	str	r0, [r7, #116]	@ 0x74
 801beaa:	e004      	b.n	801beb6 <ecc_map_ex+0x3ca>
      goto done;
 801beac:	bf00      	nop
 801beae:	e002      	b.n	801beb6 <ecc_map_ex+0x3ca>
      goto done;
 801beb0:	bf00      	nop
 801beb2:	e000      	b.n	801beb6 <ecc_map_ex+0x3ca>

done:
 801beb4:	bf00      	nop
#endif

   /* clean up */
   mp_clear(t1);
 801beb6:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801beb8:	f00a fc75 	bl	80267a6 <mp_clear>
   mp_clear(t2);
 801bebc:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 801bebe:	f00a fc72 	bl	80267a6 <mp_clear>
   if (P->key == NULL)
#endif
#endif
   {
   #ifdef ALT_ECC_SIZE
      FREE_MP_INT_SIZE(rz, NULL, DYNAMIC_TYPE_ECC);
 801bec2:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801bec4:	653b      	str	r3, [r7, #80]	@ 0x50
 801bec6:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801bec8:	2b00      	cmp	r3, #0
 801beca:	d002      	beq.n	801bed2 <ecc_map_ex+0x3e6>
 801becc:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 801bece:	f002 fdf7 	bl	801eac0 <wolfSSL_Free>
      FREE_MP_INT_SIZE(ry, NULL, DYNAMIC_TYPE_ECC);
 801bed2:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801bed4:	64fb      	str	r3, [r7, #76]	@ 0x4c
 801bed6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801bed8:	2b00      	cmp	r3, #0
 801beda:	d002      	beq.n	801bee2 <ecc_map_ex+0x3f6>
 801bedc:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 801bede:	f002 fdef 	bl	801eac0 <wolfSSL_Free>
      FREE_MP_INT_SIZE(rx, NULL, DYNAMIC_TYPE_ECC);
 801bee2:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801bee4:	64bb      	str	r3, [r7, #72]	@ 0x48
 801bee6:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801bee8:	2b00      	cmp	r3, #0
 801beea:	d002      	beq.n	801bef2 <ecc_map_ex+0x406>
 801beec:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 801beee:	f002 fde7 	bl	801eac0 <wolfSSL_Free>
   #endif
      FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801bef2:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801bef4:	647b      	str	r3, [r7, #68]	@ 0x44
 801bef6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801bef8:	2b00      	cmp	r3, #0
 801befa:	d002      	beq.n	801bf02 <ecc_map_ex+0x416>
 801befc:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 801befe:	f002 fddf 	bl	801eac0 <wolfSSL_Free>
      FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801bf02:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801bf04:	643b      	str	r3, [r7, #64]	@ 0x40
 801bf06:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801bf08:	2b00      	cmp	r3, #0
 801bf0a:	d002      	beq.n	801bf12 <ecc_map_ex+0x426>
 801bf0c:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 801bf0e:	f002 fdd7 	bl	801eac0 <wolfSSL_Free>
   }

   return err;
 801bf12:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
#endif

   WOLFSSL_LEAVE("ecc_map_ex (SP Math)", err);
   return err;
#endif /* WOLFSSL_SP_MATH */
}
 801bf14:	4618      	mov	r0, r3
 801bf16:	3778      	adds	r7, #120	@ 0x78
 801bf18:	46bd      	mov	sp, r7
 801bf1a:	bd80      	pop	{r7, pc}

0801bf1c <ecc_map>:
#endif /* !FREESCALE_LTC_ECC && !WOLFSSL_STM32_PKA */

int ecc_map(ecc_point* P, mp_int* modulus, mp_digit mp)
{
 801bf1c:	b580      	push	{r7, lr}
 801bf1e:	b084      	sub	sp, #16
 801bf20:	af00      	add	r7, sp, #0
 801bf22:	60f8      	str	r0, [r7, #12]
 801bf24:	60b9      	str	r1, [r7, #8]
 801bf26:	607a      	str	r2, [r7, #4]
    return ecc_map_ex(P, modulus, mp, 0);
 801bf28:	2300      	movs	r3, #0
 801bf2a:	687a      	ldr	r2, [r7, #4]
 801bf2c:	68b9      	ldr	r1, [r7, #8]
 801bf2e:	68f8      	ldr	r0, [r7, #12]
 801bf30:	f7ff fddc 	bl	801baec <ecc_map_ex>
 801bf34:	4603      	mov	r3, r0
}
 801bf36:	4618      	mov	r0, r3
 801bf38:	3710      	adds	r7, #16
 801bf3a:	46bd      	mov	sp, r7
 801bf3c:	bd80      	pop	{r7, pc}

0801bf3e <wc_ecc_gen_z>:

#else

static int wc_ecc_gen_z(WC_RNG* rng, int size, ecc_point* p, mp_int* modulus,
    mp_digit mp, mp_int* tx, mp_int* ty, mp_int* mu)
{
 801bf3e:	b580      	push	{r7, lr}
 801bf40:	b086      	sub	sp, #24
 801bf42:	af00      	add	r7, sp, #0
 801bf44:	60f8      	str	r0, [r7, #12]
 801bf46:	60b9      	str	r1, [r7, #8]
 801bf48:	607a      	str	r2, [r7, #4]
 801bf4a:	603b      	str	r3, [r7, #0]
    int err = MP_OKAY;
 801bf4c:	2300      	movs	r3, #0
 801bf4e:	617b      	str	r3, [r7, #20]

    err = mp_montgomery_calc_normalization(mu, modulus);
 801bf50:	6839      	ldr	r1, [r7, #0]
 801bf52:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 801bf54:	f00a fe2d 	bl	8026bb2 <mp_montgomery_calc_normalization>
 801bf58:	6178      	str	r0, [r7, #20]
    /* Generate random value to multiply into p->z. */
    if (err == MP_OKAY)
 801bf5a:	697b      	ldr	r3, [r7, #20]
 801bf5c:	2b00      	cmp	r3, #0
 801bf5e:	d106      	bne.n	801bf6e <wc_ecc_gen_z+0x30>
        err = wc_ecc_gen_k(rng, size, ty, modulus);
 801bf60:	683b      	ldr	r3, [r7, #0]
 801bf62:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801bf64:	68b9      	ldr	r1, [r7, #8]
 801bf66:	68f8      	ldr	r0, [r7, #12]
 801bf68:	f000 fdf8 	bl	801cb5c <wc_ecc_gen_k>
 801bf6c:	6178      	str	r0, [r7, #20]
    /* Convert to montogmery form. */
    if (err == MP_OKAY)
 801bf6e:	697b      	ldr	r3, [r7, #20]
 801bf70:	2b00      	cmp	r3, #0
 801bf72:	d106      	bne.n	801bf82 <wc_ecc_gen_z+0x44>
        err = mp_mulmod(ty, mu, modulus, ty);
 801bf74:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801bf76:	683a      	ldr	r2, [r7, #0]
 801bf78:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 801bf7a:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801bf7c:	f00a fc8d 	bl	802689a <mp_mulmod>
 801bf80:	6178      	str	r0, [r7, #20]
    /* Multiply random value into p->z. */
    if (err == MP_OKAY)
 801bf82:	697b      	ldr	r3, [r7, #20]
 801bf84:	2b00      	cmp	r3, #0
 801bf86:	d108      	bne.n	801bf9a <wc_ecc_gen_z+0x5c>
        err = mp_mul(p->z, ty, p->z);
 801bf88:	687b      	ldr	r3, [r7, #4]
 801bf8a:	6898      	ldr	r0, [r3, #8]
 801bf8c:	687b      	ldr	r3, [r7, #4]
 801bf8e:	689b      	ldr	r3, [r3, #8]
 801bf90:	461a      	mov	r2, r3
 801bf92:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 801bf94:	f00a fc71 	bl	802687a <mp_mul>
 801bf98:	6178      	str	r0, [r7, #20]
    if (err == MP_OKAY)
 801bf9a:	697b      	ldr	r3, [r7, #20]
 801bf9c:	2b00      	cmp	r3, #0
 801bf9e:	d107      	bne.n	801bfb0 <wc_ecc_gen_z+0x72>
        err = mp_montgomery_reduce(p->z, modulus, mp);
 801bfa0:	687b      	ldr	r3, [r7, #4]
 801bfa2:	689b      	ldr	r3, [r3, #8]
 801bfa4:	6a3a      	ldr	r2, [r7, #32]
 801bfa6:	6839      	ldr	r1, [r7, #0]
 801bfa8:	4618      	mov	r0, r3
 801bfaa:	f00b f82d 	bl	8027008 <mp_montgomery_reduce>
 801bfae:	6178      	str	r0, [r7, #20]
    /* Square random value for X (X' = X / Z^2). */
    if (err == MP_OKAY)
 801bfb0:	697b      	ldr	r3, [r7, #20]
 801bfb2:	2b00      	cmp	r3, #0
 801bfb4:	d104      	bne.n	801bfc0 <wc_ecc_gen_z+0x82>
        err = mp_sqr(ty, tx);
 801bfb6:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801bfb8:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801bfba:	f00b f855 	bl	8027068 <mp_sqr>
 801bfbe:	6178      	str	r0, [r7, #20]
    if (err == MP_OKAY)
 801bfc0:	697b      	ldr	r3, [r7, #20]
 801bfc2:	2b00      	cmp	r3, #0
 801bfc4:	d105      	bne.n	801bfd2 <wc_ecc_gen_z+0x94>
        err = mp_montgomery_reduce(tx, modulus, mp);
 801bfc6:	6a3a      	ldr	r2, [r7, #32]
 801bfc8:	6839      	ldr	r1, [r7, #0]
 801bfca:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 801bfcc:	f00b f81c 	bl	8027008 <mp_montgomery_reduce>
 801bfd0:	6178      	str	r0, [r7, #20]
    /* Multiply square of random by random value for Y. */
    if (err == MP_OKAY)
 801bfd2:	697b      	ldr	r3, [r7, #20]
 801bfd4:	2b00      	cmp	r3, #0
 801bfd6:	d105      	bne.n	801bfe4 <wc_ecc_gen_z+0xa6>
        err = mp_mul(ty, tx, ty);
 801bfd8:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801bfda:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801bfdc:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801bfde:	f00a fc4c 	bl	802687a <mp_mul>
 801bfe2:	6178      	str	r0, [r7, #20]
    if (err == MP_OKAY)
 801bfe4:	697b      	ldr	r3, [r7, #20]
 801bfe6:	2b00      	cmp	r3, #0
 801bfe8:	d105      	bne.n	801bff6 <wc_ecc_gen_z+0xb8>
        err = mp_montgomery_reduce(ty, modulus, mp);
 801bfea:	6a3a      	ldr	r2, [r7, #32]
 801bfec:	6839      	ldr	r1, [r7, #0]
 801bfee:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801bff0:	f00b f80a 	bl	8027008 <mp_montgomery_reduce>
 801bff4:	6178      	str	r0, [r7, #20]
    /* Multiply square into X. */
    if (err == MP_OKAY)
 801bff6:	697b      	ldr	r3, [r7, #20]
 801bff8:	2b00      	cmp	r3, #0
 801bffa:	d108      	bne.n	801c00e <wc_ecc_gen_z+0xd0>
        err = mp_mul(p->x, tx, p->x);
 801bffc:	687b      	ldr	r3, [r7, #4]
 801bffe:	6818      	ldr	r0, [r3, #0]
 801c000:	687b      	ldr	r3, [r7, #4]
 801c002:	681b      	ldr	r3, [r3, #0]
 801c004:	461a      	mov	r2, r3
 801c006:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801c008:	f00a fc37 	bl	802687a <mp_mul>
 801c00c:	6178      	str	r0, [r7, #20]
    if (err == MP_OKAY)
 801c00e:	697b      	ldr	r3, [r7, #20]
 801c010:	2b00      	cmp	r3, #0
 801c012:	d107      	bne.n	801c024 <wc_ecc_gen_z+0xe6>
        err = mp_montgomery_reduce(p->x, modulus, mp);
 801c014:	687b      	ldr	r3, [r7, #4]
 801c016:	681b      	ldr	r3, [r3, #0]
 801c018:	6a3a      	ldr	r2, [r7, #32]
 801c01a:	6839      	ldr	r1, [r7, #0]
 801c01c:	4618      	mov	r0, r3
 801c01e:	f00a fff3 	bl	8027008 <mp_montgomery_reduce>
 801c022:	6178      	str	r0, [r7, #20]
    /* Multiply cube into Y (Y' = Y / Z^3). */
    if (err == MP_OKAY)
 801c024:	697b      	ldr	r3, [r7, #20]
 801c026:	2b00      	cmp	r3, #0
 801c028:	d108      	bne.n	801c03c <wc_ecc_gen_z+0xfe>
        err = mp_mul(p->y, ty, p->y);
 801c02a:	687b      	ldr	r3, [r7, #4]
 801c02c:	6858      	ldr	r0, [r3, #4]
 801c02e:	687b      	ldr	r3, [r7, #4]
 801c030:	685b      	ldr	r3, [r3, #4]
 801c032:	461a      	mov	r2, r3
 801c034:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 801c036:	f00a fc20 	bl	802687a <mp_mul>
 801c03a:	6178      	str	r0, [r7, #20]
    if (err == MP_OKAY)
 801c03c:	697b      	ldr	r3, [r7, #20]
 801c03e:	2b00      	cmp	r3, #0
 801c040:	d107      	bne.n	801c052 <wc_ecc_gen_z+0x114>
        err = mp_montgomery_reduce(p->y, modulus, mp);
 801c042:	687b      	ldr	r3, [r7, #4]
 801c044:	685b      	ldr	r3, [r3, #4]
 801c046:	6a3a      	ldr	r2, [r7, #32]
 801c048:	6839      	ldr	r1, [r7, #0]
 801c04a:	4618      	mov	r0, r3
 801c04c:	f00a ffdc 	bl	8027008 <mp_montgomery_reduce>
 801c050:	6178      	str	r0, [r7, #20]

    return err;
 801c052:	697b      	ldr	r3, [r7, #20]
}
 801c054:	4618      	mov	r0, r3
 801c056:	3718      	adds	r7, #24
 801c058:	46bd      	mov	sp, r7
 801c05a:	bd80      	pop	{r7, pc}

0801c05c <ecc_mulmod>:
 *
 * Assumes: k < order.
 */
static int ecc_mulmod(const mp_int* k, ecc_point* P, ecc_point* Q,
    ecc_point** R, mp_int* a, mp_int* modulus, mp_digit mp, WC_RNG* rng)
{
 801c05c:	b590      	push	{r4, r7, lr}
 801c05e:	b097      	sub	sp, #92	@ 0x5c
 801c060:	af04      	add	r7, sp, #16
 801c062:	60f8      	str	r0, [r7, #12]
 801c064:	60b9      	str	r1, [r7, #8]
 801c066:	607a      	str	r2, [r7, #4]
 801c068:	603b      	str	r3, [r7, #0]
    int      err = MP_OKAY;
 801c06a:	2300      	movs	r3, #0
 801c06c:	647b      	str	r3, [r7, #68]	@ 0x44
    int      bytes = (mp_count_bits(modulus) + 7) / 8;
 801c06e:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801c070:	f00a fd7a 	bl	8026b68 <mp_count_bits>
 801c074:	4603      	mov	r3, r0
 801c076:	3307      	adds	r3, #7
 801c078:	2b00      	cmp	r3, #0
 801c07a:	da00      	bge.n	801c07e <ecc_mulmod+0x22>
 801c07c:	3307      	adds	r3, #7
 801c07e:	10db      	asrs	r3, r3, #3
 801c080:	62bb      	str	r3, [r7, #40]	@ 0x28
    int      i;
    int      j = 1;
 801c082:	2301      	movs	r3, #1
 801c084:	63fb      	str	r3, [r7, #60]	@ 0x3c
    int      cnt = DIGIT_BIT;
 801c086:	2320      	movs	r3, #32
 801c088:	63bb      	str	r3, [r7, #56]	@ 0x38
    int      t = 0;
 801c08a:	2300      	movs	r3, #0
 801c08c:	637b      	str	r3, [r7, #52]	@ 0x34
    mp_digit b;
    mp_digit v = 0;
 801c08e:	2300      	movs	r3, #0
 801c090:	633b      	str	r3, [r7, #48]	@ 0x30
    mp_int*  kt = R[2]->x;
 801c092:	683b      	ldr	r3, [r7, #0]
 801c094:	3308      	adds	r3, #8
 801c096:	681b      	ldr	r3, [r3, #0]
 801c098:	681b      	ldr	r3, [r3, #0]
 801c09a:	627b      	str	r3, [r7, #36]	@ 0x24
#ifndef WC_NO_CACHE_RESISTANT
    /* First bit always 1 (fix at end) and swap equals first bit */
    int      swap = 1;
 801c09c:	2301      	movs	r3, #1
 801c09e:	62fb      	str	r3, [r7, #44]	@ 0x2c
#ifdef WOLFSSL_SMALL_STACK
    mp_int*  tmp = NULL;
 801c0a0:	2300      	movs	r3, #0
 801c0a2:	623b      	str	r3, [r7, #32]
#endif
    int      infinity;

#ifndef WC_NO_CACHE_RESISTANT
#ifdef WOLFSSL_SMALL_STACK
    tmp = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);
 801c0a4:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801c0a8:	f002 fcee 	bl	801ea88 <wolfSSL_Malloc>
 801c0ac:	6238      	str	r0, [r7, #32]
    if (tmp == NULL) {
 801c0ae:	6a3b      	ldr	r3, [r7, #32]
 801c0b0:	2b00      	cmp	r3, #0
 801c0b2:	d102      	bne.n	801c0ba <ecc_mulmod+0x5e>
        err = MEMORY_E;
 801c0b4:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801c0b8:	647b      	str	r3, [r7, #68]	@ 0x44
    }
#endif
    if (err == MP_OKAY)
 801c0ba:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c0bc:	2b00      	cmp	r3, #0
 801c0be:	d103      	bne.n	801c0c8 <ecc_mulmod+0x6c>
        err = mp_init(tmp);
 801c0c0:	6a38      	ldr	r0, [r7, #32]
 801c0c2:	f00a fae6 	bl	8026692 <mp_init>
 801c0c6:	6478      	str	r0, [r7, #68]	@ 0x44
#endif

    /* Step 1: R[0] = P; R[1] = P */
    /* R[0] = P */
    if (err == MP_OKAY)
 801c0c8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c0ca:	2b00      	cmp	r3, #0
 801c0cc:	d109      	bne.n	801c0e2 <ecc_mulmod+0x86>
        err = mp_copy(P->x, R[0]->x);
 801c0ce:	68bb      	ldr	r3, [r7, #8]
 801c0d0:	681a      	ldr	r2, [r3, #0]
 801c0d2:	683b      	ldr	r3, [r7, #0]
 801c0d4:	681b      	ldr	r3, [r3, #0]
 801c0d6:	681b      	ldr	r3, [r3, #0]
 801c0d8:	4619      	mov	r1, r3
 801c0da:	4610      	mov	r0, r2
 801c0dc:	f00a fd25 	bl	8026b2a <mp_copy>
 801c0e0:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err == MP_OKAY)
 801c0e2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c0e4:	2b00      	cmp	r3, #0
 801c0e6:	d109      	bne.n	801c0fc <ecc_mulmod+0xa0>
        err = mp_copy(P->y, R[0]->y);
 801c0e8:	68bb      	ldr	r3, [r7, #8]
 801c0ea:	685a      	ldr	r2, [r3, #4]
 801c0ec:	683b      	ldr	r3, [r7, #0]
 801c0ee:	681b      	ldr	r3, [r3, #0]
 801c0f0:	685b      	ldr	r3, [r3, #4]
 801c0f2:	4619      	mov	r1, r3
 801c0f4:	4610      	mov	r0, r2
 801c0f6:	f00a fd18 	bl	8026b2a <mp_copy>
 801c0fa:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err == MP_OKAY)
 801c0fc:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c0fe:	2b00      	cmp	r3, #0
 801c100:	d109      	bne.n	801c116 <ecc_mulmod+0xba>
        err = mp_copy(P->z, R[0]->z);
 801c102:	68bb      	ldr	r3, [r7, #8]
 801c104:	689a      	ldr	r2, [r3, #8]
 801c106:	683b      	ldr	r3, [r7, #0]
 801c108:	681b      	ldr	r3, [r3, #0]
 801c10a:	689b      	ldr	r3, [r3, #8]
 801c10c:	4619      	mov	r1, r3
 801c10e:	4610      	mov	r0, r2
 801c110:	f00a fd0b 	bl	8026b2a <mp_copy>
 801c114:	6478      	str	r0, [r7, #68]	@ 0x44

    /* R[1] = P */
    if (err == MP_OKAY)
 801c116:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c118:	2b00      	cmp	r3, #0
 801c11a:	d10a      	bne.n	801c132 <ecc_mulmod+0xd6>
        err = mp_copy(P->x, R[1]->x);
 801c11c:	68bb      	ldr	r3, [r7, #8]
 801c11e:	681a      	ldr	r2, [r3, #0]
 801c120:	683b      	ldr	r3, [r7, #0]
 801c122:	3304      	adds	r3, #4
 801c124:	681b      	ldr	r3, [r3, #0]
 801c126:	681b      	ldr	r3, [r3, #0]
 801c128:	4619      	mov	r1, r3
 801c12a:	4610      	mov	r0, r2
 801c12c:	f00a fcfd 	bl	8026b2a <mp_copy>
 801c130:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err == MP_OKAY)
 801c132:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c134:	2b00      	cmp	r3, #0
 801c136:	d10a      	bne.n	801c14e <ecc_mulmod+0xf2>
        err = mp_copy(P->y, R[1]->y);
 801c138:	68bb      	ldr	r3, [r7, #8]
 801c13a:	685a      	ldr	r2, [r3, #4]
 801c13c:	683b      	ldr	r3, [r7, #0]
 801c13e:	3304      	adds	r3, #4
 801c140:	681b      	ldr	r3, [r3, #0]
 801c142:	685b      	ldr	r3, [r3, #4]
 801c144:	4619      	mov	r1, r3
 801c146:	4610      	mov	r0, r2
 801c148:	f00a fcef 	bl	8026b2a <mp_copy>
 801c14c:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err == MP_OKAY)
 801c14e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c150:	2b00      	cmp	r3, #0
 801c152:	d10a      	bne.n	801c16a <ecc_mulmod+0x10e>
        err = mp_copy(P->z, R[1]->z);
 801c154:	68bb      	ldr	r3, [r7, #8]
 801c156:	689a      	ldr	r2, [r3, #8]
 801c158:	683b      	ldr	r3, [r7, #0]
 801c15a:	3304      	adds	r3, #4
 801c15c:	681b      	ldr	r3, [r3, #0]
 801c15e:	689b      	ldr	r3, [r3, #8]
 801c160:	4619      	mov	r1, r3
 801c162:	4610      	mov	r0, r2
 801c164:	f00a fce1 	bl	8026b2a <mp_copy>
 801c168:	6478      	str	r0, [r7, #68]	@ 0x44

    /* Randomize z ordinates to obfuscate timing. */
    if ((err == MP_OKAY) && (rng != NULL))
 801c16a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c16c:	2b00      	cmp	r3, #0
 801c16e:	d119      	bne.n	801c1a4 <ecc_mulmod+0x148>
 801c170:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801c172:	2b00      	cmp	r3, #0
 801c174:	d016      	beq.n	801c1a4 <ecc_mulmod+0x148>
        err = wc_ecc_gen_z(rng, bytes, R[0], modulus, mp, R[2]->x, R[2]->y, kt);
 801c176:	683b      	ldr	r3, [r7, #0]
 801c178:	6818      	ldr	r0, [r3, #0]
 801c17a:	683b      	ldr	r3, [r7, #0]
 801c17c:	3308      	adds	r3, #8
 801c17e:	681b      	ldr	r3, [r3, #0]
 801c180:	681b      	ldr	r3, [r3, #0]
 801c182:	683a      	ldr	r2, [r7, #0]
 801c184:	3208      	adds	r2, #8
 801c186:	6812      	ldr	r2, [r2, #0]
 801c188:	6852      	ldr	r2, [r2, #4]
 801c18a:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801c18c:	9103      	str	r1, [sp, #12]
 801c18e:	9202      	str	r2, [sp, #8]
 801c190:	9301      	str	r3, [sp, #4]
 801c192:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801c194:	9300      	str	r3, [sp, #0]
 801c196:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c198:	4602      	mov	r2, r0
 801c19a:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 801c19c:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 801c19e:	f7ff fece 	bl	801bf3e <wc_ecc_gen_z>
 801c1a2:	6478      	str	r0, [r7, #68]	@ 0x44
    if ((err == MP_OKAY) && (rng != NULL))
 801c1a4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c1a6:	2b00      	cmp	r3, #0
 801c1a8:	d11a      	bne.n	801c1e0 <ecc_mulmod+0x184>
 801c1aa:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801c1ac:	2b00      	cmp	r3, #0
 801c1ae:	d017      	beq.n	801c1e0 <ecc_mulmod+0x184>
        err = wc_ecc_gen_z(rng, bytes, R[1], modulus, mp, R[2]->x, R[2]->y, kt);
 801c1b0:	683b      	ldr	r3, [r7, #0]
 801c1b2:	3304      	adds	r3, #4
 801c1b4:	6818      	ldr	r0, [r3, #0]
 801c1b6:	683b      	ldr	r3, [r7, #0]
 801c1b8:	3308      	adds	r3, #8
 801c1ba:	681b      	ldr	r3, [r3, #0]
 801c1bc:	681b      	ldr	r3, [r3, #0]
 801c1be:	683a      	ldr	r2, [r7, #0]
 801c1c0:	3208      	adds	r2, #8
 801c1c2:	6812      	ldr	r2, [r2, #0]
 801c1c4:	6852      	ldr	r2, [r2, #4]
 801c1c6:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801c1c8:	9103      	str	r1, [sp, #12]
 801c1ca:	9202      	str	r2, [sp, #8]
 801c1cc:	9301      	str	r3, [sp, #4]
 801c1ce:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801c1d0:	9300      	str	r3, [sp, #0]
 801c1d2:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c1d4:	4602      	mov	r2, r0
 801c1d6:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 801c1d8:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 801c1da:	f7ff feb0 	bl	801bf3e <wc_ecc_gen_z>
 801c1de:	6478      	str	r0, [r7, #68]	@ 0x44

    if (err == MP_OKAY) {
 801c1e0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c1e2:	2b00      	cmp	r3, #0
 801c1e4:	d114      	bne.n	801c210 <ecc_mulmod+0x1b4>
        /* Order could be one greater than the size of the modulus. */
        t = mp_count_bits(modulus) + 1;
 801c1e6:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801c1e8:	f00a fcbe 	bl	8026b68 <mp_count_bits>
 801c1ec:	4603      	mov	r3, r0
 801c1ee:	3301      	adds	r3, #1
 801c1f0:	637b      	str	r3, [r7, #52]	@ 0x34
        v = k->dp[0] >> 1;
 801c1f2:	68fb      	ldr	r3, [r7, #12]
 801c1f4:	68db      	ldr	r3, [r3, #12]
 801c1f6:	085b      	lsrs	r3, r3, #1
 801c1f8:	633b      	str	r3, [r7, #48]	@ 0x30
        if (cnt > t) {
 801c1fa:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801c1fc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801c1fe:	429a      	cmp	r2, r3
 801c200:	dd01      	ble.n	801c206 <ecc_mulmod+0x1aa>
            cnt = t;
 801c202:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801c204:	63bb      	str	r3, [r7, #56]	@ 0x38
        }
        err = mp_copy(k, kt);
 801c206:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801c208:	68f8      	ldr	r0, [r7, #12]
 801c20a:	f00a fc8e 	bl	8026b2a <mp_copy>
 801c20e:	6478      	str	r0, [r7, #68]	@ 0x44
    }
    if (err == MP_OKAY) {
 801c210:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c212:	2b00      	cmp	r3, #0
 801c214:	d101      	bne.n	801c21a <ecc_mulmod+0x1be>
        err = mp_grow(kt, (int)modulus->used + 1);
 801c216:	2300      	movs	r3, #0
 801c218:	647b      	str	r3, [r7, #68]	@ 0x44
    }
    /* Step 2: for j = 1 to t-1 do */
    for (i = 1; (err == MP_OKAY) && (i < t); i++) {
 801c21a:	2301      	movs	r3, #1
 801c21c:	643b      	str	r3, [r7, #64]	@ 0x40
 801c21e:	e079      	b.n	801c314 <ecc_mulmod+0x2b8>
        if (--cnt == 0) {
 801c220:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801c222:	3b01      	subs	r3, #1
 801c224:	63bb      	str	r3, [r7, #56]	@ 0x38
 801c226:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801c228:	2b00      	cmp	r3, #0
 801c22a:	d10a      	bne.n	801c242 <ecc_mulmod+0x1e6>
            v = kt->dp[j++];
 801c22c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801c22e:	1c5a      	adds	r2, r3, #1
 801c230:	63fa      	str	r2, [r7, #60]	@ 0x3c
 801c232:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801c234:	3302      	adds	r3, #2
 801c236:	009b      	lsls	r3, r3, #2
 801c238:	4413      	add	r3, r2
 801c23a:	685b      	ldr	r3, [r3, #4]
 801c23c:	633b      	str	r3, [r7, #48]	@ 0x30
            cnt = DIGIT_BIT;
 801c23e:	2320      	movs	r3, #32
 801c240:	63bb      	str	r3, [r7, #56]	@ 0x38
        }

        /* Step 3: b = 1 - k[j]; R[b] = 2*R[b] + R[k[j]] */
        b = v & 1;
 801c242:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801c244:	f003 0301 	and.w	r3, r3, #1
 801c248:	61fb      	str	r3, [r7, #28]
        v >>= 1;
 801c24a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801c24c:	085b      	lsrs	r3, r3, #1
 801c24e:	633b      	str	r3, [r7, #48]	@ 0x30
            err = ecc_projective_add_point_safe(R[b^1], R[b], R[b^1], a,
                                                        modulus, mp, &infinity);
        }
#else
        /* Swap R[0] and R[1] if other index is needed. */
        swap ^= (int)b;
 801c250:	69fb      	ldr	r3, [r7, #28]
 801c252:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801c254:	4053      	eors	r3, r2
 801c256:	62fb      	str	r3, [r7, #44]	@ 0x2c
        if (err == MP_OKAY) {
 801c258:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c25a:	2b00      	cmp	r3, #0
 801c25c:	d10e      	bne.n	801c27c <ecc_mulmod+0x220>
            err = mp_cond_swap_ct_ex(R[0]->x, R[1]->x, (int)modulus->used, swap,
 801c25e:	683b      	ldr	r3, [r7, #0]
 801c260:	681b      	ldr	r3, [r3, #0]
 801c262:	6818      	ldr	r0, [r3, #0]
 801c264:	683b      	ldr	r3, [r7, #0]
 801c266:	3304      	adds	r3, #4
 801c268:	681b      	ldr	r3, [r3, #0]
 801c26a:	6819      	ldr	r1, [r3, #0]
 801c26c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c26e:	681a      	ldr	r2, [r3, #0]
 801c270:	6a3b      	ldr	r3, [r7, #32]
 801c272:	9300      	str	r3, [sp, #0]
 801c274:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c276:	f00a fd2d 	bl	8026cd4 <mp_cond_swap_ct_ex>
 801c27a:	6478      	str	r0, [r7, #68]	@ 0x44
                tmp);
        }
        if (err == MP_OKAY) {
 801c27c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c27e:	2b00      	cmp	r3, #0
 801c280:	d10e      	bne.n	801c2a0 <ecc_mulmod+0x244>
            err = mp_cond_swap_ct_ex(R[0]->y, R[1]->y, (int)modulus->used, swap,
 801c282:	683b      	ldr	r3, [r7, #0]
 801c284:	681b      	ldr	r3, [r3, #0]
 801c286:	6858      	ldr	r0, [r3, #4]
 801c288:	683b      	ldr	r3, [r7, #0]
 801c28a:	3304      	adds	r3, #4
 801c28c:	681b      	ldr	r3, [r3, #0]
 801c28e:	6859      	ldr	r1, [r3, #4]
 801c290:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c292:	681a      	ldr	r2, [r3, #0]
 801c294:	6a3b      	ldr	r3, [r7, #32]
 801c296:	9300      	str	r3, [sp, #0]
 801c298:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c29a:	f00a fd1b 	bl	8026cd4 <mp_cond_swap_ct_ex>
 801c29e:	6478      	str	r0, [r7, #68]	@ 0x44
                tmp);
        }
        if (err == MP_OKAY) {
 801c2a0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c2a2:	2b00      	cmp	r3, #0
 801c2a4:	d10e      	bne.n	801c2c4 <ecc_mulmod+0x268>
            err = mp_cond_swap_ct_ex(R[0]->z, R[1]->z, (int)modulus->used, swap,
 801c2a6:	683b      	ldr	r3, [r7, #0]
 801c2a8:	681b      	ldr	r3, [r3, #0]
 801c2aa:	6898      	ldr	r0, [r3, #8]
 801c2ac:	683b      	ldr	r3, [r7, #0]
 801c2ae:	3304      	adds	r3, #4
 801c2b0:	681b      	ldr	r3, [r3, #0]
 801c2b2:	6899      	ldr	r1, [r3, #8]
 801c2b4:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c2b6:	681a      	ldr	r2, [r3, #0]
 801c2b8:	6a3b      	ldr	r3, [r7, #32]
 801c2ba:	9300      	str	r3, [sp, #0]
 801c2bc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c2be:	f00a fd09 	bl	8026cd4 <mp_cond_swap_ct_ex>
 801c2c2:	6478      	str	r0, [r7, #68]	@ 0x44
                tmp);
        }
        swap = (int)b;
 801c2c4:	69fb      	ldr	r3, [r7, #28]
 801c2c6:	62fb      	str	r3, [r7, #44]	@ 0x2c

        if (err == MP_OKAY)
 801c2c8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c2ca:	2b00      	cmp	r3, #0
 801c2cc:	d10a      	bne.n	801c2e4 <ecc_mulmod+0x288>
            err = ecc_projective_dbl_point_safe(R[0], R[0], a, modulus, mp);
 801c2ce:	683b      	ldr	r3, [r7, #0]
 801c2d0:	6818      	ldr	r0, [r3, #0]
 801c2d2:	683b      	ldr	r3, [r7, #0]
 801c2d4:	6819      	ldr	r1, [r3, #0]
 801c2d6:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801c2d8:	9300      	str	r3, [sp, #0]
 801c2da:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c2dc:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 801c2de:	f000 ff48 	bl	801d172 <ecc_projective_dbl_point_safe>
 801c2e2:	6478      	str	r0, [r7, #68]	@ 0x44
        if (err == MP_OKAY) {
 801c2e4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c2e6:	2b00      	cmp	r3, #0
 801c2e8:	d111      	bne.n	801c30e <ecc_mulmod+0x2b2>
            err = ecc_projective_add_point_safe(R[0], R[1], R[0], a, modulus,
 801c2ea:	683b      	ldr	r3, [r7, #0]
 801c2ec:	6818      	ldr	r0, [r3, #0]
 801c2ee:	683b      	ldr	r3, [r7, #0]
 801c2f0:	3304      	adds	r3, #4
 801c2f2:	6819      	ldr	r1, [r3, #0]
 801c2f4:	683b      	ldr	r3, [r7, #0]
 801c2f6:	681a      	ldr	r2, [r3, #0]
 801c2f8:	f107 0314 	add.w	r3, r7, #20
 801c2fc:	9302      	str	r3, [sp, #8]
 801c2fe:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801c300:	9301      	str	r3, [sp, #4]
 801c302:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c304:	9300      	str	r3, [sp, #0]
 801c306:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801c308:	f000 fe2f 	bl	801cf6a <ecc_projective_add_point_safe>
 801c30c:	6478      	str	r0, [r7, #68]	@ 0x44
    for (i = 1; (err == MP_OKAY) && (i < t); i++) {
 801c30e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801c310:	3301      	adds	r3, #1
 801c312:	643b      	str	r3, [r7, #64]	@ 0x40
 801c314:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c316:	2b00      	cmp	r3, #0
 801c318:	d104      	bne.n	801c324 <ecc_mulmod+0x2c8>
 801c31a:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 801c31c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801c31e:	429a      	cmp	r2, r3
 801c320:	f6ff af7e 	blt.w	801c220 <ecc_mulmod+0x1c4>
#endif /* WC_NO_CACHE_RESISTANT */
    }
    /* Step 4: end for */
#ifndef WC_NO_CACHE_RESISTANT
    /* Swap back if last bit is 0. */
    swap ^= 1;
 801c324:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c326:	f083 0301 	eor.w	r3, r3, #1
 801c32a:	62fb      	str	r3, [r7, #44]	@ 0x2c
    if (err == MP_OKAY) {
 801c32c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c32e:	2b00      	cmp	r3, #0
 801c330:	d10e      	bne.n	801c350 <ecc_mulmod+0x2f4>
        err = mp_cond_swap_ct_ex(R[0]->x, R[1]->x, (int)modulus->used, swap,
 801c332:	683b      	ldr	r3, [r7, #0]
 801c334:	681b      	ldr	r3, [r3, #0]
 801c336:	6818      	ldr	r0, [r3, #0]
 801c338:	683b      	ldr	r3, [r7, #0]
 801c33a:	3304      	adds	r3, #4
 801c33c:	681b      	ldr	r3, [r3, #0]
 801c33e:	6819      	ldr	r1, [r3, #0]
 801c340:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c342:	681a      	ldr	r2, [r3, #0]
 801c344:	6a3b      	ldr	r3, [r7, #32]
 801c346:	9300      	str	r3, [sp, #0]
 801c348:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c34a:	f00a fcc3 	bl	8026cd4 <mp_cond_swap_ct_ex>
 801c34e:	6478      	str	r0, [r7, #68]	@ 0x44
            tmp);
    }
    if (err == MP_OKAY) {
 801c350:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c352:	2b00      	cmp	r3, #0
 801c354:	d10e      	bne.n	801c374 <ecc_mulmod+0x318>
        err = mp_cond_swap_ct_ex(R[0]->y, R[1]->y, (int)modulus->used, swap,
 801c356:	683b      	ldr	r3, [r7, #0]
 801c358:	681b      	ldr	r3, [r3, #0]
 801c35a:	6858      	ldr	r0, [r3, #4]
 801c35c:	683b      	ldr	r3, [r7, #0]
 801c35e:	3304      	adds	r3, #4
 801c360:	681b      	ldr	r3, [r3, #0]
 801c362:	6859      	ldr	r1, [r3, #4]
 801c364:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c366:	681a      	ldr	r2, [r3, #0]
 801c368:	6a3b      	ldr	r3, [r7, #32]
 801c36a:	9300      	str	r3, [sp, #0]
 801c36c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c36e:	f00a fcb1 	bl	8026cd4 <mp_cond_swap_ct_ex>
 801c372:	6478      	str	r0, [r7, #68]	@ 0x44
            tmp);
    }
    if (err == MP_OKAY) {
 801c374:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c376:	2b00      	cmp	r3, #0
 801c378:	d10e      	bne.n	801c398 <ecc_mulmod+0x33c>
        err = mp_cond_swap_ct_ex(R[0]->z, R[1]->z, (int)modulus->used, swap,
 801c37a:	683b      	ldr	r3, [r7, #0]
 801c37c:	681b      	ldr	r3, [r3, #0]
 801c37e:	6898      	ldr	r0, [r3, #8]
 801c380:	683b      	ldr	r3, [r7, #0]
 801c382:	3304      	adds	r3, #4
 801c384:	681b      	ldr	r3, [r3, #0]
 801c386:	6899      	ldr	r1, [r3, #8]
 801c388:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c38a:	681a      	ldr	r2, [r3, #0]
 801c38c:	6a3b      	ldr	r3, [r7, #32]
 801c38e:	9300      	str	r3, [sp, #0]
 801c390:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c392:	f00a fc9f 	bl	8026cd4 <mp_cond_swap_ct_ex>
 801c396:	6478      	str	r0, [r7, #68]	@ 0x44
    }
#endif

    /* Step 5: b = k[0]; R[b] = R[b] - P */
    /* R[2] = -P */
    if (err == MP_OKAY)
 801c398:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c39a:	2b00      	cmp	r3, #0
 801c39c:	d10a      	bne.n	801c3b4 <ecc_mulmod+0x358>
        err = mp_copy(P->x, R[2]->x);
 801c39e:	68bb      	ldr	r3, [r7, #8]
 801c3a0:	681a      	ldr	r2, [r3, #0]
 801c3a2:	683b      	ldr	r3, [r7, #0]
 801c3a4:	3308      	adds	r3, #8
 801c3a6:	681b      	ldr	r3, [r3, #0]
 801c3a8:	681b      	ldr	r3, [r3, #0]
 801c3aa:	4619      	mov	r1, r3
 801c3ac:	4610      	mov	r0, r2
 801c3ae:	f00a fbbc 	bl	8026b2a <mp_copy>
 801c3b2:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err == MP_OKAY)
 801c3b4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c3b6:	2b00      	cmp	r3, #0
 801c3b8:	d10a      	bne.n	801c3d0 <ecc_mulmod+0x374>
        err = mp_sub(modulus, P->y, R[2]->y);
 801c3ba:	68bb      	ldr	r3, [r7, #8]
 801c3bc:	6859      	ldr	r1, [r3, #4]
 801c3be:	683b      	ldr	r3, [r7, #0]
 801c3c0:	3308      	adds	r3, #8
 801c3c2:	681b      	ldr	r3, [r3, #0]
 801c3c4:	685b      	ldr	r3, [r3, #4]
 801c3c6:	461a      	mov	r2, r3
 801c3c8:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801c3ca:	f00a fa46 	bl	802685a <mp_sub>
 801c3ce:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err == MP_OKAY)
 801c3d0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c3d2:	2b00      	cmp	r3, #0
 801c3d4:	d10a      	bne.n	801c3ec <ecc_mulmod+0x390>
        err = mp_copy(P->z, R[2]->z);
 801c3d6:	68bb      	ldr	r3, [r7, #8]
 801c3d8:	689a      	ldr	r2, [r3, #8]
 801c3da:	683b      	ldr	r3, [r7, #0]
 801c3dc:	3308      	adds	r3, #8
 801c3de:	681b      	ldr	r3, [r3, #0]
 801c3e0:	689b      	ldr	r3, [r3, #8]
 801c3e2:	4619      	mov	r1, r3
 801c3e4:	4610      	mov	r0, r2
 801c3e6:	f00a fba0 	bl	8026b2a <mp_copy>
 801c3ea:	6478      	str	r0, [r7, #68]	@ 0x44
    /* Subtract point by adding negative. */
    if (err == MP_OKAY) {
 801c3ec:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c3ee:	2b00      	cmp	r3, #0
 801c3f0:	f040 8089 	bne.w	801c506 <ecc_mulmod+0x4aa>
        b = k->dp[0] & 1;
 801c3f4:	68fb      	ldr	r3, [r7, #12]
 801c3f6:	68db      	ldr	r3, [r3, #12]
 801c3f8:	f003 0301 	and.w	r3, r3, #1
 801c3fc:	61fb      	str	r3, [r7, #28]
#ifdef WC_NO_CACHE_RESISTANT
        err = ecc_projective_add_point_safe(R[b], R[2], R[b], a, modulus, mp,
                                                                     &infinity);
#else
        /* Swap R[0] and R[1], if necessary, to operate on the one we want. */
        err = mp_cond_swap_ct_ex(R[0]->x, R[1]->x, (int)modulus->used, (int)b,
 801c3fe:	683b      	ldr	r3, [r7, #0]
 801c400:	681b      	ldr	r3, [r3, #0]
 801c402:	6818      	ldr	r0, [r3, #0]
 801c404:	683b      	ldr	r3, [r7, #0]
 801c406:	3304      	adds	r3, #4
 801c408:	681b      	ldr	r3, [r3, #0]
 801c40a:	6819      	ldr	r1, [r3, #0]
 801c40c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c40e:	681a      	ldr	r2, [r3, #0]
 801c410:	69fc      	ldr	r4, [r7, #28]
 801c412:	6a3b      	ldr	r3, [r7, #32]
 801c414:	9300      	str	r3, [sp, #0]
 801c416:	4623      	mov	r3, r4
 801c418:	f00a fc5c 	bl	8026cd4 <mp_cond_swap_ct_ex>
 801c41c:	6478      	str	r0, [r7, #68]	@ 0x44
            tmp);
        if (err == MP_OKAY) {
 801c41e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c420:	2b00      	cmp	r3, #0
 801c422:	d10f      	bne.n	801c444 <ecc_mulmod+0x3e8>
            err = mp_cond_swap_ct_ex(R[0]->y, R[1]->y, (int)modulus->used,
 801c424:	683b      	ldr	r3, [r7, #0]
 801c426:	681b      	ldr	r3, [r3, #0]
 801c428:	6858      	ldr	r0, [r3, #4]
 801c42a:	683b      	ldr	r3, [r7, #0]
 801c42c:	3304      	adds	r3, #4
 801c42e:	681b      	ldr	r3, [r3, #0]
 801c430:	6859      	ldr	r1, [r3, #4]
 801c432:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c434:	681a      	ldr	r2, [r3, #0]
 801c436:	69fc      	ldr	r4, [r7, #28]
 801c438:	6a3b      	ldr	r3, [r7, #32]
 801c43a:	9300      	str	r3, [sp, #0]
 801c43c:	4623      	mov	r3, r4
 801c43e:	f00a fc49 	bl	8026cd4 <mp_cond_swap_ct_ex>
 801c442:	6478      	str	r0, [r7, #68]	@ 0x44
                (int)b, tmp);
        }
        if (err == MP_OKAY) {
 801c444:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c446:	2b00      	cmp	r3, #0
 801c448:	d10f      	bne.n	801c46a <ecc_mulmod+0x40e>
            err = mp_cond_swap_ct_ex(R[0]->z, R[1]->z, (int)modulus->used,
 801c44a:	683b      	ldr	r3, [r7, #0]
 801c44c:	681b      	ldr	r3, [r3, #0]
 801c44e:	6898      	ldr	r0, [r3, #8]
 801c450:	683b      	ldr	r3, [r7, #0]
 801c452:	3304      	adds	r3, #4
 801c454:	681b      	ldr	r3, [r3, #0]
 801c456:	6899      	ldr	r1, [r3, #8]
 801c458:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c45a:	681a      	ldr	r2, [r3, #0]
 801c45c:	69fc      	ldr	r4, [r7, #28]
 801c45e:	6a3b      	ldr	r3, [r7, #32]
 801c460:	9300      	str	r3, [sp, #0]
 801c462:	4623      	mov	r3, r4
 801c464:	f00a fc36 	bl	8026cd4 <mp_cond_swap_ct_ex>
 801c468:	6478      	str	r0, [r7, #68]	@ 0x44
                (int)b, tmp);
        }
        if (err == MP_OKAY)
 801c46a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c46c:	2b00      	cmp	r3, #0
 801c46e:	d111      	bne.n	801c494 <ecc_mulmod+0x438>
            err = ecc_projective_add_point_safe(R[0], R[2], R[0], a, modulus,
 801c470:	683b      	ldr	r3, [r7, #0]
 801c472:	6818      	ldr	r0, [r3, #0]
 801c474:	683b      	ldr	r3, [r7, #0]
 801c476:	3308      	adds	r3, #8
 801c478:	6819      	ldr	r1, [r3, #0]
 801c47a:	683b      	ldr	r3, [r7, #0]
 801c47c:	681a      	ldr	r2, [r3, #0]
 801c47e:	f107 0314 	add.w	r3, r7, #20
 801c482:	9302      	str	r3, [sp, #8]
 801c484:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801c486:	9301      	str	r3, [sp, #4]
 801c488:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c48a:	9300      	str	r3, [sp, #0]
 801c48c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801c48e:	f000 fd6c 	bl	801cf6a <ecc_projective_add_point_safe>
 801c492:	6478      	str	r0, [r7, #68]	@ 0x44
                                                                 mp, &infinity);
        /* Swap back if necessary. */
        if (err == MP_OKAY) {
 801c494:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c496:	2b00      	cmp	r3, #0
 801c498:	d10f      	bne.n	801c4ba <ecc_mulmod+0x45e>
            err = mp_cond_swap_ct_ex(R[0]->x, R[1]->x, (int)modulus->used,
 801c49a:	683b      	ldr	r3, [r7, #0]
 801c49c:	681b      	ldr	r3, [r3, #0]
 801c49e:	6818      	ldr	r0, [r3, #0]
 801c4a0:	683b      	ldr	r3, [r7, #0]
 801c4a2:	3304      	adds	r3, #4
 801c4a4:	681b      	ldr	r3, [r3, #0]
 801c4a6:	6819      	ldr	r1, [r3, #0]
 801c4a8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c4aa:	681a      	ldr	r2, [r3, #0]
 801c4ac:	69fc      	ldr	r4, [r7, #28]
 801c4ae:	6a3b      	ldr	r3, [r7, #32]
 801c4b0:	9300      	str	r3, [sp, #0]
 801c4b2:	4623      	mov	r3, r4
 801c4b4:	f00a fc0e 	bl	8026cd4 <mp_cond_swap_ct_ex>
 801c4b8:	6478      	str	r0, [r7, #68]	@ 0x44
                (int)b, tmp);
        }
        if (err == MP_OKAY) {
 801c4ba:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c4bc:	2b00      	cmp	r3, #0
 801c4be:	d10f      	bne.n	801c4e0 <ecc_mulmod+0x484>
            err = mp_cond_swap_ct_ex(R[0]->y, R[1]->y, (int)modulus->used,
 801c4c0:	683b      	ldr	r3, [r7, #0]
 801c4c2:	681b      	ldr	r3, [r3, #0]
 801c4c4:	6858      	ldr	r0, [r3, #4]
 801c4c6:	683b      	ldr	r3, [r7, #0]
 801c4c8:	3304      	adds	r3, #4
 801c4ca:	681b      	ldr	r3, [r3, #0]
 801c4cc:	6859      	ldr	r1, [r3, #4]
 801c4ce:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c4d0:	681a      	ldr	r2, [r3, #0]
 801c4d2:	69fc      	ldr	r4, [r7, #28]
 801c4d4:	6a3b      	ldr	r3, [r7, #32]
 801c4d6:	9300      	str	r3, [sp, #0]
 801c4d8:	4623      	mov	r3, r4
 801c4da:	f00a fbfb 	bl	8026cd4 <mp_cond_swap_ct_ex>
 801c4de:	6478      	str	r0, [r7, #68]	@ 0x44
                (int)b, tmp);
        }
        if (err == MP_OKAY) {
 801c4e0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c4e2:	2b00      	cmp	r3, #0
 801c4e4:	d10f      	bne.n	801c506 <ecc_mulmod+0x4aa>
            err = mp_cond_swap_ct_ex(R[0]->z, R[1]->z, (int)modulus->used,
 801c4e6:	683b      	ldr	r3, [r7, #0]
 801c4e8:	681b      	ldr	r3, [r3, #0]
 801c4ea:	6898      	ldr	r0, [r3, #8]
 801c4ec:	683b      	ldr	r3, [r7, #0]
 801c4ee:	3304      	adds	r3, #4
 801c4f0:	681b      	ldr	r3, [r3, #0]
 801c4f2:	6899      	ldr	r1, [r3, #8]
 801c4f4:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c4f6:	681a      	ldr	r2, [r3, #0]
 801c4f8:	69fc      	ldr	r4, [r7, #28]
 801c4fa:	6a3b      	ldr	r3, [r7, #32]
 801c4fc:	9300      	str	r3, [sp, #0]
 801c4fe:	4623      	mov	r3, r4
 801c500:	f00a fbe8 	bl	8026cd4 <mp_cond_swap_ct_ex>
 801c504:	6478      	str	r0, [r7, #68]	@ 0x44
        }
#endif
    }

    /* Step 6: return R[0] */
    if (err == MP_OKAY)
 801c506:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c508:	2b00      	cmp	r3, #0
 801c50a:	d109      	bne.n	801c520 <ecc_mulmod+0x4c4>
        err = mp_copy(R[0]->x, Q->x);
 801c50c:	683b      	ldr	r3, [r7, #0]
 801c50e:	681b      	ldr	r3, [r3, #0]
 801c510:	681a      	ldr	r2, [r3, #0]
 801c512:	687b      	ldr	r3, [r7, #4]
 801c514:	681b      	ldr	r3, [r3, #0]
 801c516:	4619      	mov	r1, r3
 801c518:	4610      	mov	r0, r2
 801c51a:	f00a fb06 	bl	8026b2a <mp_copy>
 801c51e:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err == MP_OKAY)
 801c520:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c522:	2b00      	cmp	r3, #0
 801c524:	d109      	bne.n	801c53a <ecc_mulmod+0x4de>
        err = mp_copy(R[0]->y, Q->y);
 801c526:	683b      	ldr	r3, [r7, #0]
 801c528:	681b      	ldr	r3, [r3, #0]
 801c52a:	685a      	ldr	r2, [r3, #4]
 801c52c:	687b      	ldr	r3, [r7, #4]
 801c52e:	685b      	ldr	r3, [r3, #4]
 801c530:	4619      	mov	r1, r3
 801c532:	4610      	mov	r0, r2
 801c534:	f00a faf9 	bl	8026b2a <mp_copy>
 801c538:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err == MP_OKAY)
 801c53a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c53c:	2b00      	cmp	r3, #0
 801c53e:	d109      	bne.n	801c554 <ecc_mulmod+0x4f8>
        err = mp_copy(R[0]->z, Q->z);
 801c540:	683b      	ldr	r3, [r7, #0]
 801c542:	681b      	ldr	r3, [r3, #0]
 801c544:	689a      	ldr	r2, [r3, #8]
 801c546:	687b      	ldr	r3, [r7, #4]
 801c548:	689b      	ldr	r3, [r3, #8]
 801c54a:	4619      	mov	r1, r3
 801c54c:	4610      	mov	r0, r2
 801c54e:	f00a faec 	bl	8026b2a <mp_copy>
 801c552:	6478      	str	r0, [r7, #68]	@ 0x44

#if defined(WOLFSSL_SMALL_STACK) && !defined(WC_NO_CACHE_RESISTANT)
    XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
 801c554:	6a3b      	ldr	r3, [r7, #32]
 801c556:	61bb      	str	r3, [r7, #24]
 801c558:	69bb      	ldr	r3, [r7, #24]
 801c55a:	2b00      	cmp	r3, #0
 801c55c:	d002      	beq.n	801c564 <ecc_mulmod+0x508>
 801c55e:	69b8      	ldr	r0, [r7, #24]
 801c560:	f002 faae 	bl	801eac0 <wolfSSL_Free>
#endif

    return err;
 801c564:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
}
 801c566:	4618      	mov	r0, r3
 801c568:	374c      	adds	r7, #76	@ 0x4c
 801c56a:	46bd      	mov	sp, r7
 801c56c:	bd90      	pop	{r4, r7, pc}

0801c56e <ecc_point_to_mont>:
 * @return  0 on success.
 * @return  -ve on failure.
 */
static int ecc_point_to_mont(ecc_point* p, ecc_point* r, mp_int* modulus,
                             void* heap)
{
 801c56e:	b580      	push	{r7, lr}
 801c570:	b088      	sub	sp, #32
 801c572:	af00      	add	r7, sp, #0
 801c574:	60f8      	str	r0, [r7, #12]
 801c576:	60b9      	str	r1, [r7, #8]
 801c578:	607a      	str	r2, [r7, #4]
 801c57a:	603b      	str	r3, [r7, #0]
   int err = MP_OKAY;
 801c57c:	2300      	movs	r3, #0
 801c57e:	61fb      	str	r3, [r7, #28]
   DECL_MP_INT_SIZE_DYN(mu, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801c580:	2300      	movs	r3, #0
 801c582:	61bb      	str	r3, [r7, #24]

   (void)heap;

   NEW_MP_INT_SIZE(mu, mp_bitsused(modulus), heap, DYNAMIC_TYPE_ECC);
 801c584:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801c588:	f002 fa7e 	bl	801ea88 <wolfSSL_Malloc>
 801c58c:	61b8      	str	r0, [r7, #24]
 801c58e:	69bb      	ldr	r3, [r7, #24]
 801c590:	2b00      	cmp	r3, #0
 801c592:	d005      	beq.n	801c5a0 <ecc_point_to_mont+0x32>
 801c594:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801c598:	2100      	movs	r1, #0
 801c59a:	69b8      	ldr	r0, [r7, #24]
 801c59c:	f00b ff94 	bl	80284c8 <memset>
#ifdef MP_INT_SIZE_CHECK_NULL
   if (mu == NULL)
 801c5a0:	69bb      	ldr	r3, [r7, #24]
 801c5a2:	2b00      	cmp	r3, #0
 801c5a4:	d102      	bne.n	801c5ac <ecc_point_to_mont+0x3e>
       err = MEMORY_E;
 801c5a6:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801c5aa:	61fb      	str	r3, [r7, #28]
#endif
   if (err == MP_OKAY)
 801c5ac:	69fb      	ldr	r3, [r7, #28]
 801c5ae:	2b00      	cmp	r3, #0
 801c5b0:	d103      	bne.n	801c5ba <ecc_point_to_mont+0x4c>
       err = INIT_MP_INT_SIZE(mu, mp_bitsused(modulus));
 801c5b2:	69b8      	ldr	r0, [r7, #24]
 801c5b4:	f00a f86d 	bl	8026692 <mp_init>
 801c5b8:	61f8      	str	r0, [r7, #28]
   if (err == MP_OKAY) {
 801c5ba:	69fb      	ldr	r3, [r7, #28]
 801c5bc:	2b00      	cmp	r3, #0
 801c5be:	d154      	bne.n	801c66a <ecc_point_to_mont+0xfc>
       err = mp_montgomery_calc_normalization(mu, modulus);
 801c5c0:	6879      	ldr	r1, [r7, #4]
 801c5c2:	69b8      	ldr	r0, [r7, #24]
 801c5c4:	f00a faf5 	bl	8026bb2 <mp_montgomery_calc_normalization>
 801c5c8:	61f8      	str	r0, [r7, #28]

       if (err == MP_OKAY) {
 801c5ca:	69fb      	ldr	r3, [r7, #28]
 801c5cc:	2b00      	cmp	r3, #0
 801c5ce:	d149      	bne.n	801c664 <ecc_point_to_mont+0xf6>
           if (mp_cmp_d(mu, 1) == MP_EQ) {
 801c5d0:	2101      	movs	r1, #1
 801c5d2:	69b8      	ldr	r0, [r7, #24]
 801c5d4:	f00a f9fe 	bl	80269d4 <mp_cmp_d>
 801c5d8:	4603      	mov	r3, r0
 801c5da:	2b00      	cmp	r3, #0
 801c5dc:	d121      	bne.n	801c622 <ecc_point_to_mont+0xb4>
               err = mp_copy(p->x, r->x);
 801c5de:	68fb      	ldr	r3, [r7, #12]
 801c5e0:	681a      	ldr	r2, [r3, #0]
 801c5e2:	68bb      	ldr	r3, [r7, #8]
 801c5e4:	681b      	ldr	r3, [r3, #0]
 801c5e6:	4619      	mov	r1, r3
 801c5e8:	4610      	mov	r0, r2
 801c5ea:	f00a fa9e 	bl	8026b2a <mp_copy>
 801c5ee:	61f8      	str	r0, [r7, #28]
               if (err == MP_OKAY)
 801c5f0:	69fb      	ldr	r3, [r7, #28]
 801c5f2:	2b00      	cmp	r3, #0
 801c5f4:	d108      	bne.n	801c608 <ecc_point_to_mont+0x9a>
                   err = mp_copy(p->y, r->y);
 801c5f6:	68fb      	ldr	r3, [r7, #12]
 801c5f8:	685a      	ldr	r2, [r3, #4]
 801c5fa:	68bb      	ldr	r3, [r7, #8]
 801c5fc:	685b      	ldr	r3, [r3, #4]
 801c5fe:	4619      	mov	r1, r3
 801c600:	4610      	mov	r0, r2
 801c602:	f00a fa92 	bl	8026b2a <mp_copy>
 801c606:	61f8      	str	r0, [r7, #28]
               if (err == MP_OKAY)
 801c608:	69fb      	ldr	r3, [r7, #28]
 801c60a:	2b00      	cmp	r3, #0
 801c60c:	d12a      	bne.n	801c664 <ecc_point_to_mont+0xf6>
                   err = mp_copy(p->z, r->z);
 801c60e:	68fb      	ldr	r3, [r7, #12]
 801c610:	689a      	ldr	r2, [r3, #8]
 801c612:	68bb      	ldr	r3, [r7, #8]
 801c614:	689b      	ldr	r3, [r3, #8]
 801c616:	4619      	mov	r1, r3
 801c618:	4610      	mov	r0, r2
 801c61a:	f00a fa86 	bl	8026b2a <mp_copy>
 801c61e:	61f8      	str	r0, [r7, #28]
 801c620:	e020      	b.n	801c664 <ecc_point_to_mont+0xf6>
           }
           else {
               err = mp_mulmod(p->x, mu, modulus, r->x);
 801c622:	68fb      	ldr	r3, [r7, #12]
 801c624:	6818      	ldr	r0, [r3, #0]
 801c626:	68bb      	ldr	r3, [r7, #8]
 801c628:	681b      	ldr	r3, [r3, #0]
 801c62a:	687a      	ldr	r2, [r7, #4]
 801c62c:	69b9      	ldr	r1, [r7, #24]
 801c62e:	f00a f934 	bl	802689a <mp_mulmod>
 801c632:	61f8      	str	r0, [r7, #28]
               if (err == MP_OKAY)
 801c634:	69fb      	ldr	r3, [r7, #28]
 801c636:	2b00      	cmp	r3, #0
 801c638:	d108      	bne.n	801c64c <ecc_point_to_mont+0xde>
                   err = mp_mulmod(p->y, mu, modulus, r->y);
 801c63a:	68fb      	ldr	r3, [r7, #12]
 801c63c:	6858      	ldr	r0, [r3, #4]
 801c63e:	68bb      	ldr	r3, [r7, #8]
 801c640:	685b      	ldr	r3, [r3, #4]
 801c642:	687a      	ldr	r2, [r7, #4]
 801c644:	69b9      	ldr	r1, [r7, #24]
 801c646:	f00a f928 	bl	802689a <mp_mulmod>
 801c64a:	61f8      	str	r0, [r7, #28]
               if (err == MP_OKAY)
 801c64c:	69fb      	ldr	r3, [r7, #28]
 801c64e:	2b00      	cmp	r3, #0
 801c650:	d108      	bne.n	801c664 <ecc_point_to_mont+0xf6>
                   err = mp_mulmod(p->z, mu, modulus, r->z);
 801c652:	68fb      	ldr	r3, [r7, #12]
 801c654:	6898      	ldr	r0, [r3, #8]
 801c656:	68bb      	ldr	r3, [r7, #8]
 801c658:	689b      	ldr	r3, [r3, #8]
 801c65a:	687a      	ldr	r2, [r7, #4]
 801c65c:	69b9      	ldr	r1, [r7, #24]
 801c65e:	f00a f91c 	bl	802689a <mp_mulmod>
 801c662:	61f8      	str	r0, [r7, #28]
           }
       }

       mp_clear(mu);
 801c664:	69b8      	ldr	r0, [r7, #24]
 801c666:	f00a f89e 	bl	80267a6 <mp_clear>
   }

   FREE_MP_INT_SIZE(mu, heap, DYNAMIC_TYPE_ECC);
 801c66a:	69bb      	ldr	r3, [r7, #24]
 801c66c:	617b      	str	r3, [r7, #20]
 801c66e:	697b      	ldr	r3, [r7, #20]
 801c670:	2b00      	cmp	r3, #0
 801c672:	d002      	beq.n	801c67a <ecc_point_to_mont+0x10c>
 801c674:	6978      	ldr	r0, [r7, #20]
 801c676:	f002 fa23 	bl	801eac0 <wolfSSL_Free>
   return err;
 801c67a:	69fb      	ldr	r3, [r7, #28]
}
 801c67c:	4618      	mov	r0, r3
 801c67e:	3720      	adds	r7, #32
 801c680:	46bd      	mov	sp, r7
 801c682:	bd80      	pop	{r7, pc}

0801c684 <ecc_check_order_minus_1>:
#ifndef FP_ECC
#if !defined(WOLFSSL_SP_MATH)
#ifdef ECC_TIMING_RESISTANT
static int ecc_check_order_minus_1(const mp_int* k, ecc_point* tG, ecc_point* R,
   mp_int* modulus, mp_int* order)
{
 801c684:	b580      	push	{r7, lr}
 801c686:	b088      	sub	sp, #32
 801c688:	af00      	add	r7, sp, #0
 801c68a:	60f8      	str	r0, [r7, #12]
 801c68c:	60b9      	str	r1, [r7, #8]
 801c68e:	607a      	str	r2, [r7, #4]
 801c690:	603b      	str	r3, [r7, #0]
    int err;
    DECL_MP_INT_SIZE_DYN(t, mp_bitsused(order), MAX_ECC_BITS_USE);
 801c692:	2300      	movs	r3, #0
 801c694:	61bb      	str	r3, [r7, #24]

    NEW_MP_INT_SIZE(t, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801c696:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801c69a:	f002 f9f5 	bl	801ea88 <wolfSSL_Malloc>
 801c69e:	61b8      	str	r0, [r7, #24]
 801c6a0:	69bb      	ldr	r3, [r7, #24]
 801c6a2:	2b00      	cmp	r3, #0
 801c6a4:	d005      	beq.n	801c6b2 <ecc_check_order_minus_1+0x2e>
 801c6a6:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801c6aa:	2100      	movs	r1, #0
 801c6ac:	69b8      	ldr	r0, [r7, #24]
 801c6ae:	f00b ff0b 	bl	80284c8 <memset>
#ifdef MP_INT_SIZE_CHECK_NULL
    if (t == NULL) {
 801c6b2:	69bb      	ldr	r3, [r7, #24]
 801c6b4:	2b00      	cmp	r3, #0
 801c6b6:	d103      	bne.n	801c6c0 <ecc_check_order_minus_1+0x3c>
        err = MEMORY_E;
 801c6b8:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801c6bc:	61fb      	str	r3, [r7, #28]
 801c6be:	e003      	b.n	801c6c8 <ecc_check_order_minus_1+0x44>
    }
    else
#endif
    {
        err = INIT_MP_INT_SIZE(t, mp_bitsused(modulus));
 801c6c0:	69b8      	ldr	r0, [r7, #24]
 801c6c2:	f009 ffe6 	bl	8026692 <mp_init>
 801c6c6:	61f8      	str	r0, [r7, #28]
    }
    if (err == MP_OKAY) {
 801c6c8:	69fb      	ldr	r3, [r7, #28]
 801c6ca:	2b00      	cmp	r3, #0
 801c6cc:	d141      	bne.n	801c752 <ecc_check_order_minus_1+0xce>
        /* Check for k == order - 1. Result will be 0 point which is not correct
         * Calculates order / 2 and adds order / 2 + 1 and gets infinity.
         * (with constant time implementation)
         */
        err = mp_sub_d(order, 1, t);
 801c6ce:	69ba      	ldr	r2, [r7, #24]
 801c6d0:	2101      	movs	r1, #1
 801c6d2:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801c6d4:	f00a f9c6 	bl	8026a64 <mp_sub_d>
 801c6d8:	61f8      	str	r0, [r7, #28]
        if (err == MP_OKAY) {
 801c6da:	69fb      	ldr	r3, [r7, #28]
 801c6dc:	2b00      	cmp	r3, #0
 801c6de:	d135      	bne.n	801c74c <ecc_check_order_minus_1+0xc8>
            int kIsMinusOne = (mp_cmp((mp_int*)k, t) == MP_EQ);
 801c6e0:	69b9      	ldr	r1, [r7, #24]
 801c6e2:	68f8      	ldr	r0, [r7, #12]
 801c6e4:	f00a f968 	bl	80269b8 <mp_cmp>
 801c6e8:	4603      	mov	r3, r0
 801c6ea:	2b00      	cmp	r3, #0
 801c6ec:	bf0c      	ite	eq
 801c6ee:	2301      	moveq	r3, #1
 801c6f0:	2300      	movne	r3, #0
 801c6f2:	b2db      	uxtb	r3, r3
 801c6f4:	617b      	str	r3, [r7, #20]
            err = mp_cond_copy(tG->x, kIsMinusOne, R->x);
 801c6f6:	68bb      	ldr	r3, [r7, #8]
 801c6f8:	6818      	ldr	r0, [r3, #0]
 801c6fa:	687b      	ldr	r3, [r7, #4]
 801c6fc:	681b      	ldr	r3, [r3, #0]
 801c6fe:	461a      	mov	r2, r3
 801c700:	6979      	ldr	r1, [r7, #20]
 801c702:	f00a fefc 	bl	80274fe <mp_cond_copy>
 801c706:	61f8      	str	r0, [r7, #28]
            if (err == MP_OKAY) {
 801c708:	69fb      	ldr	r3, [r7, #28]
 801c70a:	2b00      	cmp	r3, #0
 801c70c:	d107      	bne.n	801c71e <ecc_check_order_minus_1+0x9a>
                err = mp_sub(modulus, tG->y, t);
 801c70e:	68bb      	ldr	r3, [r7, #8]
 801c710:	685b      	ldr	r3, [r3, #4]
 801c712:	69ba      	ldr	r2, [r7, #24]
 801c714:	4619      	mov	r1, r3
 801c716:	6838      	ldr	r0, [r7, #0]
 801c718:	f00a f89f 	bl	802685a <mp_sub>
 801c71c:	61f8      	str	r0, [r7, #28]
            }
            if (err == MP_OKAY) {
 801c71e:	69fb      	ldr	r3, [r7, #28]
 801c720:	2b00      	cmp	r3, #0
 801c722:	d107      	bne.n	801c734 <ecc_check_order_minus_1+0xb0>
                err = mp_cond_copy(t, kIsMinusOne, R->y);
 801c724:	687b      	ldr	r3, [r7, #4]
 801c726:	685b      	ldr	r3, [r3, #4]
 801c728:	461a      	mov	r2, r3
 801c72a:	6979      	ldr	r1, [r7, #20]
 801c72c:	69b8      	ldr	r0, [r7, #24]
 801c72e:	f00a fee6 	bl	80274fe <mp_cond_copy>
 801c732:	61f8      	str	r0, [r7, #28]
            }
            if (err == MP_OKAY) {
 801c734:	69fb      	ldr	r3, [r7, #28]
 801c736:	2b00      	cmp	r3, #0
 801c738:	d108      	bne.n	801c74c <ecc_check_order_minus_1+0xc8>
                err = mp_cond_copy(tG->z, kIsMinusOne, R->z);
 801c73a:	68bb      	ldr	r3, [r7, #8]
 801c73c:	6898      	ldr	r0, [r3, #8]
 801c73e:	687b      	ldr	r3, [r7, #4]
 801c740:	689b      	ldr	r3, [r3, #8]
 801c742:	461a      	mov	r2, r3
 801c744:	6979      	ldr	r1, [r7, #20]
 801c746:	f00a feda 	bl	80274fe <mp_cond_copy>
 801c74a:	61f8      	str	r0, [r7, #28]
            }
        }

        mp_free(t);
 801c74c:	69b8      	ldr	r0, [r7, #24]
 801c74e:	f00a f839 	bl	80267c4 <mp_free>
    }

    FREE_MP_INT_SIZE(t, NULL, DYNAMIC_TYPE_ECC);
 801c752:	69bb      	ldr	r3, [r7, #24]
 801c754:	613b      	str	r3, [r7, #16]
 801c756:	693b      	ldr	r3, [r7, #16]
 801c758:	2b00      	cmp	r3, #0
 801c75a:	d002      	beq.n	801c762 <ecc_check_order_minus_1+0xde>
 801c75c:	6938      	ldr	r0, [r7, #16]
 801c75e:	f002 f9af 	bl	801eac0 <wolfSSL_Free>
    return err;
 801c762:	69fb      	ldr	r3, [r7, #28]
}
 801c764:	4618      	mov	r0, r3
 801c766:	3720      	adds	r7, #32
 801c768:	46bd      	mov	sp, r7
 801c76a:	bd80      	pop	{r7, pc}

0801c76c <wc_ecc_mulmod_ex2>:
*/
int wc_ecc_mulmod_ex2(const mp_int* k, ecc_point* G, ecc_point* R, mp_int* a,
                      mp_int* modulus, mp_int* order, WC_RNG* rng, int map,
                      void* heap)
#if !defined(WOLFSSL_SP_MATH)
{
 801c76c:	b590      	push	{r4, r7, lr}
 801c76e:	b091      	sub	sp, #68	@ 0x44
 801c770:	af04      	add	r7, sp, #16
 801c772:	60f8      	str	r0, [r7, #12]
 801c774:	60b9      	str	r1, [r7, #8]
 801c776:	607a      	str	r2, [r7, #4]
 801c778:	603b      	str	r3, [r7, #0]
#ifdef WOLFSSL_SMALL_STACK_CACHE
   ecc_key       key;
#endif
   mp_digit      mp;

   if (k == NULL || G == NULL || R == NULL || modulus == NULL) {
 801c77a:	68fb      	ldr	r3, [r7, #12]
 801c77c:	2b00      	cmp	r3, #0
 801c77e:	d008      	beq.n	801c792 <wc_ecc_mulmod_ex2+0x26>
 801c780:	68bb      	ldr	r3, [r7, #8]
 801c782:	2b00      	cmp	r3, #0
 801c784:	d005      	beq.n	801c792 <wc_ecc_mulmod_ex2+0x26>
 801c786:	687b      	ldr	r3, [r7, #4]
 801c788:	2b00      	cmp	r3, #0
 801c78a:	d002      	beq.n	801c792 <wc_ecc_mulmod_ex2+0x26>
 801c78c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801c78e:	2b00      	cmp	r3, #0
 801c790:	d102      	bne.n	801c798 <wc_ecc_mulmod_ex2+0x2c>
      return ECC_BAD_ARG_E;
 801c792:	f06f 03a9 	mvn.w	r3, #169	@ 0xa9
 801c796:	e096      	b.n	801c8c6 <wc_ecc_mulmod_ex2+0x15a>
      }
   }
   else
#endif
   /* k can't have more bits than order */
   if (mp_count_bits(k) > mp_count_bits(order)) {
 801c798:	68f8      	ldr	r0, [r7, #12]
 801c79a:	f00a f9e5 	bl	8026b68 <mp_count_bits>
 801c79e:	4604      	mov	r4, r0
 801c7a0:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 801c7a2:	f00a f9e1 	bl	8026b68 <mp_count_bits>
 801c7a6:	4603      	mov	r3, r0
 801c7a8:	429c      	cmp	r4, r3
 801c7aa:	dd02      	ble.n	801c7b2 <wc_ecc_mulmod_ex2+0x46>
      WOLFSSL_MSG("Private key length is greater than order in bits.");
      return ECC_OUT_OF_RANGE_E;
 801c7ac:	f06f 03d8 	mvn.w	r3, #216	@ 0xd8
 801c7b0:	e089      	b.n	801c8c6 <wc_ecc_mulmod_ex2+0x15a>
   }

   /* init variables */
   tG = NULL;
 801c7b2:	2300      	movs	r3, #0
 801c7b4:	627b      	str	r3, [r7, #36]	@ 0x24
   XMEMSET(M, 0, sizeof(M));
 801c7b6:	f107 0318 	add.w	r3, r7, #24
 801c7ba:	220c      	movs	r2, #12
 801c7bc:	2100      	movs	r1, #0
 801c7be:	4618      	mov	r0, r3
 801c7c0:	f00b fe82 	bl	80284c8 <memset>
      goto exit;
   R->key = &key;
#endif /* WOLFSSL_SMALL_STACK_CACHE */

   /* alloc ram for window temps */
   for (i = 0; i < M_POINTS; i++) {
 801c7c4:	2300      	movs	r3, #0
 801c7c6:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801c7c8:	e00f      	b.n	801c7ea <wc_ecc_mulmod_ex2+0x7e>
   #ifdef WOLFSSL_NO_MALLOC
      M[i] = &lcl_M[i];
   #endif
      err = wc_ecc_new_point_ex(&M[i], heap);
 801c7ca:	f107 0218 	add.w	r2, r7, #24
 801c7ce:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c7d0:	009b      	lsls	r3, r3, #2
 801c7d2:	4413      	add	r3, r2
 801c7d4:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 801c7d6:	4618      	mov	r0, r3
 801c7d8:	f000 f879 	bl	801c8ce <wc_ecc_new_point_ex>
 801c7dc:	62b8      	str	r0, [r7, #40]	@ 0x28
      if (err != MP_OKAY) {
 801c7de:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801c7e0:	2b00      	cmp	r3, #0
 801c7e2:	d14e      	bne.n	801c882 <wc_ecc_mulmod_ex2+0x116>
   for (i = 0; i < M_POINTS; i++) {
 801c7e4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c7e6:	3301      	adds	r3, #1
 801c7e8:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801c7ea:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c7ec:	2b02      	cmp	r3, #2
 801c7ee:	ddec      	ble.n	801c7ca <wc_ecc_mulmod_ex2+0x5e>

   /* make a copy of G in case R==G */
#ifdef WOLFSSL_NO_MALLOC
   tG = &lcl_tG;
#endif
   err = wc_ecc_new_point_ex(&tG, heap);
 801c7f0:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 801c7f4:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 801c7f6:	4618      	mov	r0, r3
 801c7f8:	f000 f869 	bl	801c8ce <wc_ecc_new_point_ex>
 801c7fc:	62b8      	str	r0, [r7, #40]	@ 0x28
   if (err != MP_OKAY) {
 801c7fe:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801c800:	2b00      	cmp	r3, #0
 801c802:	d140      	bne.n	801c886 <wc_ecc_mulmod_ex2+0x11a>
       goto exit;
   }
   if ((err = ecc_point_to_mont(G, tG, modulus, heap)) != MP_OKAY) {
 801c804:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801c806:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801c808:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 801c80a:	68b8      	ldr	r0, [r7, #8]
 801c80c:	f7ff feaf 	bl	801c56e <ecc_point_to_mont>
 801c810:	62b8      	str	r0, [r7, #40]	@ 0x28
 801c812:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801c814:	2b00      	cmp	r3, #0
 801c816:	d138      	bne.n	801c88a <wc_ecc_mulmod_ex2+0x11e>
       goto exit;
   }

   /* init montgomery reduction */
   if ((err = mp_montgomery_setup(modulus, &mp)) != MP_OKAY) {
 801c818:	f107 0314 	add.w	r3, r7, #20
 801c81c:	4619      	mov	r1, r3
 801c81e:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 801c820:	f00a fc14 	bl	802704c <mp_montgomery_setup>
 801c824:	62b8      	str	r0, [r7, #40]	@ 0x28
 801c826:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801c828:	2b00      	cmp	r3, #0
 801c82a:	d130      	bne.n	801c88e <wc_ecc_mulmod_ex2+0x122>
      goto exit;
   }

   err = ecc_mulmod(k, tG, R, M, a, modulus, mp, rng);
 801c82c:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801c82e:	697b      	ldr	r3, [r7, #20]
 801c830:	f107 0018 	add.w	r0, r7, #24
 801c834:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 801c836:	9203      	str	r2, [sp, #12]
 801c838:	9302      	str	r3, [sp, #8]
 801c83a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801c83c:	9301      	str	r3, [sp, #4]
 801c83e:	683b      	ldr	r3, [r7, #0]
 801c840:	9300      	str	r3, [sp, #0]
 801c842:	4603      	mov	r3, r0
 801c844:	687a      	ldr	r2, [r7, #4]
 801c846:	68f8      	ldr	r0, [r7, #12]
 801c848:	f7ff fc08 	bl	801c05c <ecc_mulmod>
 801c84c:	62b8      	str	r0, [r7, #40]	@ 0x28
#ifdef ECC_TIMING_RESISTANT
   if (err == MP_OKAY) {
 801c84e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801c850:	2b00      	cmp	r3, #0
 801c852:	d108      	bne.n	801c866 <wc_ecc_mulmod_ex2+0xfa>
       err = ecc_check_order_minus_1(k, tG, R, modulus, order);
 801c854:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801c856:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c858:	9300      	str	r3, [sp, #0]
 801c85a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801c85c:	687a      	ldr	r2, [r7, #4]
 801c85e:	68f8      	ldr	r0, [r7, #12]
 801c860:	f7ff ff10 	bl	801c684 <ecc_check_order_minus_1>
 801c864:	62b8      	str	r0, [r7, #40]	@ 0x28
   }
#else
   (void)order;
#endif
   /* map R back from projective space */
   if (err == MP_OKAY && map)
 801c866:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801c868:	2b00      	cmp	r3, #0
 801c86a:	d112      	bne.n	801c892 <wc_ecc_mulmod_ex2+0x126>
 801c86c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801c86e:	2b00      	cmp	r3, #0
 801c870:	d00f      	beq.n	801c892 <wc_ecc_mulmod_ex2+0x126>
      err = ecc_map(R, modulus, mp);
 801c872:	697b      	ldr	r3, [r7, #20]
 801c874:	461a      	mov	r2, r3
 801c876:	6c39      	ldr	r1, [r7, #64]	@ 0x40
 801c878:	6878      	ldr	r0, [r7, #4]
 801c87a:	f7ff fb4f 	bl	801bf1c <ecc_map>
 801c87e:	62b8      	str	r0, [r7, #40]	@ 0x28
 801c880:	e008      	b.n	801c894 <wc_ecc_mulmod_ex2+0x128>
         goto exit;
 801c882:	bf00      	nop
 801c884:	e006      	b.n	801c894 <wc_ecc_mulmod_ex2+0x128>
       goto exit;
 801c886:	bf00      	nop
 801c888:	e004      	b.n	801c894 <wc_ecc_mulmod_ex2+0x128>
       goto exit;
 801c88a:	bf00      	nop
 801c88c:	e002      	b.n	801c894 <wc_ecc_mulmod_ex2+0x128>
      goto exit;
 801c88e:	bf00      	nop
 801c890:	e000      	b.n	801c894 <wc_ecc_mulmod_ex2+0x128>

exit:
 801c892:	bf00      	nop

   /* done */
   wc_ecc_del_point_ex(tG, heap);
 801c894:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801c896:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 801c898:	4618      	mov	r0, r3
 801c89a:	f000 f86d 	bl	801c978 <wc_ecc_del_point_ex>
   for (i = 0; i < M_POINTS; i++) {
 801c89e:	2300      	movs	r3, #0
 801c8a0:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801c8a2:	e00c      	b.n	801c8be <wc_ecc_mulmod_ex2+0x152>
      wc_ecc_del_point_ex(M[i], heap);
 801c8a4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c8a6:	009b      	lsls	r3, r3, #2
 801c8a8:	3330      	adds	r3, #48	@ 0x30
 801c8aa:	443b      	add	r3, r7
 801c8ac:	f853 3c18 	ldr.w	r3, [r3, #-24]
 801c8b0:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 801c8b2:	4618      	mov	r0, r3
 801c8b4:	f000 f860 	bl	801c978 <wc_ecc_del_point_ex>
   for (i = 0; i < M_POINTS; i++) {
 801c8b8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c8ba:	3301      	adds	r3, #1
 801c8bc:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801c8be:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c8c0:	2b02      	cmp	r3, #2
 801c8c2:	ddef      	ble.n	801c8a4 <wc_ecc_mulmod_ex2+0x138>
#ifdef WOLFSSL_SMALL_STACK_CACHE
   R->key = NULL;
   ecc_key_tmp_final(&key, heap);
#endif /* WOLFSSL_SMALL_STACK_CACHE */

   return err;
 801c8c4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
}
 801c8c6:	4618      	mov	r0, r3
 801c8c8:	3734      	adds	r7, #52	@ 0x34
 801c8ca:	46bd      	mov	sp, r7
 801c8cc:	bd90      	pop	{r4, r7, pc}

0801c8ce <wc_ecc_new_point_ex>:
 * Allocate a new ECC point (if one not provided)
 * use a heap hint when creating new ecc_point
 * return an allocated point on success or NULL on failure
*/
static int wc_ecc_new_point_ex(ecc_point** point, void* heap)
{
 801c8ce:	b580      	push	{r7, lr}
 801c8d0:	b084      	sub	sp, #16
 801c8d2:	af00      	add	r7, sp, #0
 801c8d4:	6078      	str	r0, [r7, #4]
 801c8d6:	6039      	str	r1, [r7, #0]
   int err = MP_OKAY;
 801c8d8:	2300      	movs	r3, #0
 801c8da:	60bb      	str	r3, [r7, #8]
   ecc_point* p;

   if (point == NULL) {
 801c8dc:	687b      	ldr	r3, [r7, #4]
 801c8de:	2b00      	cmp	r3, #0
 801c8e0:	d102      	bne.n	801c8e8 <wc_ecc_new_point_ex+0x1a>
       return BAD_FUNC_ARG;
 801c8e2:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801c8e6:	e043      	b.n	801c970 <wc_ecc_new_point_ex+0xa2>
   }

   p = *point;
 801c8e8:	687b      	ldr	r3, [r7, #4]
 801c8ea:	681b      	ldr	r3, [r3, #0]
 801c8ec:	60fb      	str	r3, [r7, #12]
   if (p == NULL) {
 801c8ee:	68fb      	ldr	r3, [r7, #12]
 801c8f0:	2b00      	cmp	r3, #0
 801c8f2:	d104      	bne.n	801c8fe <wc_ecc_new_point_ex+0x30>
      p = (ecc_point*)XMALLOC(sizeof(ecc_point), heap, DYNAMIC_TYPE_ECC);
 801c8f4:	f44f 7080 	mov.w	r0, #256	@ 0x100
 801c8f8:	f002 f8c6 	bl	801ea88 <wolfSSL_Malloc>
 801c8fc:	60f8      	str	r0, [r7, #12]
   }
   if (p == NULL) {
 801c8fe:	68fb      	ldr	r3, [r7, #12]
 801c900:	2b00      	cmp	r3, #0
 801c902:	d102      	bne.n	801c90a <wc_ecc_new_point_ex+0x3c>
      return MEMORY_E;
 801c904:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801c908:	e032      	b.n	801c970 <wc_ecc_new_point_ex+0xa2>
   }
   XMEMSET(p, 0, sizeof(ecc_point));
 801c90a:	f44f 7280 	mov.w	r2, #256	@ 0x100
 801c90e:	2100      	movs	r1, #0
 801c910:	68f8      	ldr	r0, [r7, #12]
 801c912:	f00b fdd9 	bl	80284c8 <memset>

   if (*point == NULL)
 801c916:	687b      	ldr	r3, [r7, #4]
 801c918:	681b      	ldr	r3, [r3, #0]
 801c91a:	2b00      	cmp	r3, #0
 801c91c:	d106      	bne.n	801c92c <wc_ecc_new_point_ex+0x5e>
       p->isAllocated = 1;
 801c91e:	68fa      	ldr	r2, [r7, #12]
 801c920:	f892 30fc 	ldrb.w	r3, [r2, #252]	@ 0xfc
 801c924:	f043 0301 	orr.w	r3, r3, #1
 801c928:	f882 30fc 	strb.w	r3, [r2, #252]	@ 0xfc
      if (p->isAllocated)
          XFREE(p, heap, DYNAMIC_TYPE_ECC);
      p = NULL;
   }
#else
   p->x = (mp_int*)&p->xyz[0];
 801c92c:	68fb      	ldr	r3, [r7, #12]
 801c92e:	f103 020c 	add.w	r2, r3, #12
 801c932:	68fb      	ldr	r3, [r7, #12]
 801c934:	601a      	str	r2, [r3, #0]
   p->y = (mp_int*)&p->xyz[1];
 801c936:	68fb      	ldr	r3, [r7, #12]
 801c938:	f103 025c 	add.w	r2, r3, #92	@ 0x5c
 801c93c:	68fb      	ldr	r3, [r7, #12]
 801c93e:	605a      	str	r2, [r3, #4]
   p->z = (mp_int*)&p->xyz[2];
 801c940:	68fb      	ldr	r3, [r7, #12]
 801c942:	f103 02ac 	add.w	r2, r3, #172	@ 0xac
 801c946:	68fb      	ldr	r3, [r7, #12]
 801c948:	609a      	str	r2, [r3, #8]
   alt_fp_init(p->x);
 801c94a:	68fb      	ldr	r3, [r7, #12]
 801c94c:	681b      	ldr	r3, [r3, #0]
 801c94e:	4618      	mov	r0, r3
 801c950:	f7fe f916 	bl	801ab80 <alt_fp_init>
   alt_fp_init(p->y);
 801c954:	68fb      	ldr	r3, [r7, #12]
 801c956:	685b      	ldr	r3, [r3, #4]
 801c958:	4618      	mov	r0, r3
 801c95a:	f7fe f911 	bl	801ab80 <alt_fp_init>
   alt_fp_init(p->z);
 801c95e:	68fb      	ldr	r3, [r7, #12]
 801c960:	689b      	ldr	r3, [r3, #8]
 801c962:	4618      	mov	r0, r3
 801c964:	f7fe f90c 	bl	801ab80 <alt_fp_init>
#endif

   *point = p;
 801c968:	687b      	ldr	r3, [r7, #4]
 801c96a:	68fa      	ldr	r2, [r7, #12]
 801c96c:	601a      	str	r2, [r3, #0]
   (void)heap;
   return err;
 801c96e:	68bb      	ldr	r3, [r7, #8]
} /* wc_ecc_new_point_ex */
 801c970:	4618      	mov	r0, r3
 801c972:	3710      	adds	r7, #16
 801c974:	46bd      	mov	sp, r7
 801c976:	bd80      	pop	{r7, pc}

0801c978 <wc_ecc_del_point_ex>:

/** Free an ECC point from memory
  p   The point to free
*/
static void wc_ecc_del_point_ex(ecc_point* p, void* heap)
{
 801c978:	b580      	push	{r7, lr}
 801c97a:	b084      	sub	sp, #16
 801c97c:	af00      	add	r7, sp, #0
 801c97e:	6078      	str	r0, [r7, #4]
 801c980:	6039      	str	r1, [r7, #0]
   if (p != NULL) {
 801c982:	687b      	ldr	r3, [r7, #4]
 801c984:	2b00      	cmp	r3, #0
 801c986:	d01e      	beq.n	801c9c6 <wc_ecc_del_point_ex+0x4e>
      mp_clear(p->x);
 801c988:	687b      	ldr	r3, [r7, #4]
 801c98a:	681b      	ldr	r3, [r3, #0]
 801c98c:	4618      	mov	r0, r3
 801c98e:	f009 ff0a 	bl	80267a6 <mp_clear>
      mp_clear(p->y);
 801c992:	687b      	ldr	r3, [r7, #4]
 801c994:	685b      	ldr	r3, [r3, #4]
 801c996:	4618      	mov	r0, r3
 801c998:	f009 ff05 	bl	80267a6 <mp_clear>
      mp_clear(p->z);
 801c99c:	687b      	ldr	r3, [r7, #4]
 801c99e:	689b      	ldr	r3, [r3, #8]
 801c9a0:	4618      	mov	r0, r3
 801c9a2:	f009 ff00 	bl	80267a6 <mp_clear>
      if (p->isAllocated)
 801c9a6:	687b      	ldr	r3, [r7, #4]
 801c9a8:	f893 30fc 	ldrb.w	r3, [r3, #252]	@ 0xfc
 801c9ac:	f003 0301 	and.w	r3, r3, #1
 801c9b0:	b2db      	uxtb	r3, r3
 801c9b2:	2b00      	cmp	r3, #0
 801c9b4:	d007      	beq.n	801c9c6 <wc_ecc_del_point_ex+0x4e>
          XFREE(p, heap, DYNAMIC_TYPE_ECC);
 801c9b6:	687b      	ldr	r3, [r7, #4]
 801c9b8:	60fb      	str	r3, [r7, #12]
 801c9ba:	68fb      	ldr	r3, [r7, #12]
 801c9bc:	2b00      	cmp	r3, #0
 801c9be:	d002      	beq.n	801c9c6 <wc_ecc_del_point_ex+0x4e>
 801c9c0:	68f8      	ldr	r0, [r7, #12]
 801c9c2:	f002 f87d 	bl	801eac0 <wolfSSL_Free>
   }
   (void)heap;
}
 801c9c6:	bf00      	nop
 801c9c8:	3710      	adds	r7, #16
 801c9ca:	46bd      	mov	sp, r7
 801c9cc:	bd80      	pop	{r7, pc}

0801c9ce <wc_ecc_del_point>:
void wc_ecc_del_point_h(ecc_point* p, void* heap)
{
   wc_ecc_del_point_ex(p, heap);
}
void wc_ecc_del_point(ecc_point* p)
{
 801c9ce:	b580      	push	{r7, lr}
 801c9d0:	b082      	sub	sp, #8
 801c9d2:	af00      	add	r7, sp, #0
 801c9d4:	6078      	str	r0, [r7, #4]
    wc_ecc_del_point_ex(p, NULL);
 801c9d6:	2100      	movs	r1, #0
 801c9d8:	6878      	ldr	r0, [r7, #4]
 801c9da:	f7ff ffcd 	bl	801c978 <wc_ecc_del_point_ex>
}
 801c9de:	bf00      	nop
 801c9e0:	3708      	adds	r7, #8
 801c9e2:	46bd      	mov	sp, r7
 801c9e4:	bd80      	pop	{r7, pc}

0801c9e6 <wc_ecc_copy_point>:
/** Copy the value of a point to an other one
  p    The point to copy
  r    The created point
*/
int wc_ecc_copy_point(const ecc_point* p, ecc_point *r)
{
 801c9e6:	b580      	push	{r7, lr}
 801c9e8:	b084      	sub	sp, #16
 801c9ea:	af00      	add	r7, sp, #0
 801c9ec:	6078      	str	r0, [r7, #4]
 801c9ee:	6039      	str	r1, [r7, #0]
    int ret;

    /* prevents null arguments */
    if (p == NULL || r == NULL)
 801c9f0:	687b      	ldr	r3, [r7, #4]
 801c9f2:	2b00      	cmp	r3, #0
 801c9f4:	d002      	beq.n	801c9fc <wc_ecc_copy_point+0x16>
 801c9f6:	683b      	ldr	r3, [r7, #0]
 801c9f8:	2b00      	cmp	r3, #0
 801c9fa:	d102      	bne.n	801ca02 <wc_ecc_copy_point+0x1c>
        return ECC_BAD_ARG_E;
 801c9fc:	f06f 03a9 	mvn.w	r3, #169	@ 0xa9
 801ca00:	e02a      	b.n	801ca58 <wc_ecc_copy_point+0x72>

    ret = mp_copy(p->x, r->x);
 801ca02:	687b      	ldr	r3, [r7, #4]
 801ca04:	681a      	ldr	r2, [r3, #0]
 801ca06:	683b      	ldr	r3, [r7, #0]
 801ca08:	681b      	ldr	r3, [r3, #0]
 801ca0a:	4619      	mov	r1, r3
 801ca0c:	4610      	mov	r0, r2
 801ca0e:	f00a f88c 	bl	8026b2a <mp_copy>
 801ca12:	60f8      	str	r0, [r7, #12]
    if (ret != MP_OKAY)
 801ca14:	68fb      	ldr	r3, [r7, #12]
 801ca16:	2b00      	cmp	r3, #0
 801ca18:	d001      	beq.n	801ca1e <wc_ecc_copy_point+0x38>
        return ret;
 801ca1a:	68fb      	ldr	r3, [r7, #12]
 801ca1c:	e01c      	b.n	801ca58 <wc_ecc_copy_point+0x72>
    ret = mp_copy(p->y, r->y);
 801ca1e:	687b      	ldr	r3, [r7, #4]
 801ca20:	685a      	ldr	r2, [r3, #4]
 801ca22:	683b      	ldr	r3, [r7, #0]
 801ca24:	685b      	ldr	r3, [r3, #4]
 801ca26:	4619      	mov	r1, r3
 801ca28:	4610      	mov	r0, r2
 801ca2a:	f00a f87e 	bl	8026b2a <mp_copy>
 801ca2e:	60f8      	str	r0, [r7, #12]
    if (ret != MP_OKAY)
 801ca30:	68fb      	ldr	r3, [r7, #12]
 801ca32:	2b00      	cmp	r3, #0
 801ca34:	d001      	beq.n	801ca3a <wc_ecc_copy_point+0x54>
        return ret;
 801ca36:	68fb      	ldr	r3, [r7, #12]
 801ca38:	e00e      	b.n	801ca58 <wc_ecc_copy_point+0x72>
    ret = mp_copy(p->z, r->z);
 801ca3a:	687b      	ldr	r3, [r7, #4]
 801ca3c:	689a      	ldr	r2, [r3, #8]
 801ca3e:	683b      	ldr	r3, [r7, #0]
 801ca40:	689b      	ldr	r3, [r3, #8]
 801ca42:	4619      	mov	r1, r3
 801ca44:	4610      	mov	r0, r2
 801ca46:	f00a f870 	bl	8026b2a <mp_copy>
 801ca4a:	60f8      	str	r0, [r7, #12]
    if (ret != MP_OKAY)
 801ca4c:	68fb      	ldr	r3, [r7, #12]
 801ca4e:	2b00      	cmp	r3, #0
 801ca50:	d001      	beq.n	801ca56 <wc_ecc_copy_point+0x70>
        return ret;
 801ca52:	68fb      	ldr	r3, [r7, #12]
 801ca54:	e000      	b.n	801ca58 <wc_ecc_copy_point+0x72>

    return MP_OKAY;
 801ca56:	2300      	movs	r3, #0
}
 801ca58:	4618      	mov	r0, r3
 801ca5a:	3710      	adds	r7, #16
 801ca5c:	46bd      	mov	sp, r7
 801ca5e:	bd80      	pop	{r7, pc}

0801ca60 <wc_ecc_is_valid_idx>:
/** Returns whether an ECC idx is valid or not
  n      The idx number to check
  return 1 if valid, 0 if not
*/
int wc_ecc_is_valid_idx(int n)
{
 801ca60:	b480      	push	{r7}
 801ca62:	b085      	sub	sp, #20
 801ca64:	af00      	add	r7, sp, #0
 801ca66:	6078      	str	r0, [r7, #4]
   int x;

   if (n >= (int)ECC_SET_COUNT)
 801ca68:	687b      	ldr	r3, [r7, #4]
 801ca6a:	2b01      	cmp	r3, #1
 801ca6c:	dd01      	ble.n	801ca72 <wc_ecc_is_valid_idx+0x12>
       return 0;
 801ca6e:	2300      	movs	r3, #0
 801ca70:	e019      	b.n	801caa6 <wc_ecc_is_valid_idx+0x46>

   for (x = 0; ecc_sets[x].size != 0; x++)
 801ca72:	2300      	movs	r3, #0
 801ca74:	60fb      	str	r3, [r7, #12]
 801ca76:	e002      	b.n	801ca7e <wc_ecc_is_valid_idx+0x1e>
 801ca78:	68fb      	ldr	r3, [r7, #12]
 801ca7a:	3301      	adds	r3, #1
 801ca7c:	60fb      	str	r3, [r7, #12]
 801ca7e:	4a0d      	ldr	r2, [pc, #52]	@ (801cab4 <wc_ecc_is_valid_idx+0x54>)
 801ca80:	68fb      	ldr	r3, [r7, #12]
 801ca82:	2134      	movs	r1, #52	@ 0x34
 801ca84:	fb01 f303 	mul.w	r3, r1, r3
 801ca88:	4413      	add	r3, r2
 801ca8a:	681b      	ldr	r3, [r3, #0]
 801ca8c:	2b00      	cmp	r3, #0
 801ca8e:	d1f3      	bne.n	801ca78 <wc_ecc_is_valid_idx+0x18>
       ;
   /* -1 is a valid index --- indicating that the domain params
      were supplied by the user */
   if ((n >= ECC_CUSTOM_IDX) && (n < x)) {
 801ca90:	687b      	ldr	r3, [r7, #4]
 801ca92:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 801ca96:	db05      	blt.n	801caa4 <wc_ecc_is_valid_idx+0x44>
 801ca98:	687a      	ldr	r2, [r7, #4]
 801ca9a:	68fb      	ldr	r3, [r7, #12]
 801ca9c:	429a      	cmp	r2, r3
 801ca9e:	da01      	bge.n	801caa4 <wc_ecc_is_valid_idx+0x44>
      return 1;
 801caa0:	2301      	movs	r3, #1
 801caa2:	e000      	b.n	801caa6 <wc_ecc_is_valid_idx+0x46>
   }

   return 0;
 801caa4:	2300      	movs	r3, #0
}
 801caa6:	4618      	mov	r0, r3
 801caa8:	3714      	adds	r7, #20
 801caaa:	46bd      	mov	sp, r7
 801caac:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cab0:	4770      	bx	lr
 801cab2:	bf00      	nop
 801cab4:	08033b18 	.word	0x08033b18

0801cab8 <wc_ecc_get_curve_idx>:

int wc_ecc_get_curve_idx(int curve_id)
{
 801cab8:	b480      	push	{r7}
 801caba:	b085      	sub	sp, #20
 801cabc:	af00      	add	r7, sp, #0
 801cabe:	6078      	str	r0, [r7, #4]
    int curve_idx;
    for (curve_idx = 0; ecc_sets[curve_idx].size != 0; curve_idx++) {
 801cac0:	2300      	movs	r3, #0
 801cac2:	60fb      	str	r3, [r7, #12]
 801cac4:	e00d      	b.n	801cae2 <wc_ecc_get_curve_idx+0x2a>
        if (curve_id == ecc_sets[curve_idx].id)
 801cac6:	4a16      	ldr	r2, [pc, #88]	@ (801cb20 <wc_ecc_get_curve_idx+0x68>)
 801cac8:	68fb      	ldr	r3, [r7, #12]
 801caca:	2134      	movs	r1, #52	@ 0x34
 801cacc:	fb01 f303 	mul.w	r3, r1, r3
 801cad0:	4413      	add	r3, r2
 801cad2:	3304      	adds	r3, #4
 801cad4:	681b      	ldr	r3, [r3, #0]
 801cad6:	687a      	ldr	r2, [r7, #4]
 801cad8:	429a      	cmp	r2, r3
 801cada:	d00c      	beq.n	801caf6 <wc_ecc_get_curve_idx+0x3e>
    for (curve_idx = 0; ecc_sets[curve_idx].size != 0; curve_idx++) {
 801cadc:	68fb      	ldr	r3, [r7, #12]
 801cade:	3301      	adds	r3, #1
 801cae0:	60fb      	str	r3, [r7, #12]
 801cae2:	4a0f      	ldr	r2, [pc, #60]	@ (801cb20 <wc_ecc_get_curve_idx+0x68>)
 801cae4:	68fb      	ldr	r3, [r7, #12]
 801cae6:	2134      	movs	r1, #52	@ 0x34
 801cae8:	fb01 f303 	mul.w	r3, r1, r3
 801caec:	4413      	add	r3, r2
 801caee:	681b      	ldr	r3, [r3, #0]
 801caf0:	2b00      	cmp	r3, #0
 801caf2:	d1e8      	bne.n	801cac6 <wc_ecc_get_curve_idx+0xe>
 801caf4:	e000      	b.n	801caf8 <wc_ecc_get_curve_idx+0x40>
            break;
 801caf6:	bf00      	nop
    }
    if (ecc_sets[curve_idx].size == 0) {
 801caf8:	4a09      	ldr	r2, [pc, #36]	@ (801cb20 <wc_ecc_get_curve_idx+0x68>)
 801cafa:	68fb      	ldr	r3, [r7, #12]
 801cafc:	2134      	movs	r1, #52	@ 0x34
 801cafe:	fb01 f303 	mul.w	r3, r1, r3
 801cb02:	4413      	add	r3, r2
 801cb04:	681b      	ldr	r3, [r3, #0]
 801cb06:	2b00      	cmp	r3, #0
 801cb08:	d102      	bne.n	801cb10 <wc_ecc_get_curve_idx+0x58>
        return ECC_CURVE_INVALID;
 801cb0a:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 801cb0e:	e000      	b.n	801cb12 <wc_ecc_get_curve_idx+0x5a>
    }
    return curve_idx;
 801cb10:	68fb      	ldr	r3, [r7, #12]
}
 801cb12:	4618      	mov	r0, r3
 801cb14:	3714      	adds	r7, #20
 801cb16:	46bd      	mov	sp, r7
 801cb18:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cb1c:	4770      	bx	lr
 801cb1e:	bf00      	nop
 801cb20:	08033b18 	.word	0x08033b18

0801cb24 <wc_ecc_get_curve_size_from_id>:
 *
 * id      curve id, from ecc_curve_id enum in ecc.h
 * return  curve size, from ecc_sets[] on success, negative on error
 */
int wc_ecc_get_curve_size_from_id(int curve_id)
{
 801cb24:	b580      	push	{r7, lr}
 801cb26:	b084      	sub	sp, #16
 801cb28:	af00      	add	r7, sp, #0
 801cb2a:	6078      	str	r0, [r7, #4]
    int curve_idx = wc_ecc_get_curve_idx(curve_id);
 801cb2c:	6878      	ldr	r0, [r7, #4]
 801cb2e:	f7ff ffc3 	bl	801cab8 <wc_ecc_get_curve_idx>
 801cb32:	60f8      	str	r0, [r7, #12]
    if (curve_idx == ECC_CURVE_INVALID)
 801cb34:	68fb      	ldr	r3, [r7, #12]
 801cb36:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 801cb3a:	d102      	bne.n	801cb42 <wc_ecc_get_curve_size_from_id+0x1e>
        return ECC_BAD_ARG_E;
 801cb3c:	f06f 03a9 	mvn.w	r3, #169	@ 0xa9
 801cb40:	e006      	b.n	801cb50 <wc_ecc_get_curve_size_from_id+0x2c>
    return ecc_sets[curve_idx].size;
 801cb42:	4a05      	ldr	r2, [pc, #20]	@ (801cb58 <wc_ecc_get_curve_size_from_id+0x34>)
 801cb44:	68fb      	ldr	r3, [r7, #12]
 801cb46:	2134      	movs	r1, #52	@ 0x34
 801cb48:	fb01 f303 	mul.w	r3, r1, r3
 801cb4c:	4413      	add	r3, r2
 801cb4e:	681b      	ldr	r3, [r3, #0]
}
 801cb50:	4618      	mov	r0, r3
 801cb52:	3710      	adds	r7, #16
 801cb54:	46bd      	mov	sp, r7
 801cb56:	bd80      	pop	{r7, pc}
 801cb58:	08033b18 	.word	0x08033b18

0801cb5c <wc_ecc_gen_k>:
}
#endif

/* generate random and ensure its greater than 0 and less than order */
int wc_ecc_gen_k(WC_RNG* rng, int size, mp_int* k, mp_int* order)
{
 801cb5c:	b580      	push	{r7, lr}
 801cb5e:	b098      	sub	sp, #96	@ 0x60
 801cb60:	af00      	add	r7, sp, #0
 801cb62:	60f8      	str	r0, [r7, #12]
 801cb64:	60b9      	str	r1, [r7, #8]
 801cb66:	607a      	str	r2, [r7, #4]
 801cb68:	603b      	str	r3, [r7, #0]
#ifndef WC_NO_RNG
#ifndef WOLFSSL_ECC_GEN_REJECT_SAMPLING
    int err;
    byte buf[ECC_MAXSIZE_GEN];

    if (rng == NULL || size < 0 || size + 8 > ECC_MAXSIZE_GEN || k == NULL ||
 801cb6a:	68fb      	ldr	r3, [r7, #12]
 801cb6c:	2b00      	cmp	r3, #0
 801cb6e:	d00b      	beq.n	801cb88 <wc_ecc_gen_k+0x2c>
 801cb70:	68bb      	ldr	r3, [r7, #8]
 801cb72:	2b00      	cmp	r3, #0
 801cb74:	db08      	blt.n	801cb88 <wc_ecc_gen_k+0x2c>
 801cb76:	68bb      	ldr	r3, [r7, #8]
 801cb78:	2b42      	cmp	r3, #66	@ 0x42
 801cb7a:	dc05      	bgt.n	801cb88 <wc_ecc_gen_k+0x2c>
 801cb7c:	687b      	ldr	r3, [r7, #4]
 801cb7e:	2b00      	cmp	r3, #0
 801cb80:	d002      	beq.n	801cb88 <wc_ecc_gen_k+0x2c>
 801cb82:	683b      	ldr	r3, [r7, #0]
 801cb84:	2b00      	cmp	r3, #0
 801cb86:	d102      	bne.n	801cb8e <wc_ecc_gen_k+0x32>
                                                                order == NULL) {
        return BAD_FUNC_ARG;
 801cb88:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801cb8c:	e039      	b.n	801cc02 <wc_ecc_gen_k+0xa6>
    }

    /* generate 8 extra bytes to mitigate bias from the modulo operation below */
    /* see section A.1.2 in 'Suite B Implementor's Guide to FIPS 186-3 (ECDSA)' */
    size += 8;
 801cb8e:	68bb      	ldr	r3, [r7, #8]
 801cb90:	3308      	adds	r3, #8
 801cb92:	60bb      	str	r3, [r7, #8]

    /* make up random string */
    err = wc_RNG_GenerateBlock(rng, buf, (word32)size);
 801cb94:	68ba      	ldr	r2, [r7, #8]
 801cb96:	f107 0310 	add.w	r3, r7, #16
 801cb9a:	4619      	mov	r1, r3
 801cb9c:	68f8      	ldr	r0, [r7, #12]
 801cb9e:	f002 fcfa 	bl	801f596 <wc_RNG_GenerateBlock>
 801cba2:	65f8      	str	r0, [r7, #92]	@ 0x5c
#ifdef WOLFSSL_CHECK_MEM_ZERO
    wc_MemZero_Add("wc_ecc_gen_k buf", buf, size);
#endif

    /* load random buffer data into k */
    if (err == 0)
 801cba4:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801cba6:	2b00      	cmp	r3, #0
 801cba8:	d107      	bne.n	801cbba <wc_ecc_gen_k+0x5e>
        err = mp_read_unsigned_bin(k, buf, (word32)size);
 801cbaa:	f107 0310 	add.w	r3, r7, #16
 801cbae:	68ba      	ldr	r2, [r7, #8]
 801cbb0:	4619      	mov	r1, r3
 801cbb2:	6878      	ldr	r0, [r7, #4]
 801cbb4:	f009 ff46 	bl	8026a44 <mp_read_unsigned_bin>
 801cbb8:	65f8      	str	r0, [r7, #92]	@ 0x5c

    /* the key should be smaller than the order of base point */
    if (err == MP_OKAY) {
 801cbba:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801cbbc:	2b00      	cmp	r3, #0
 801cbbe:	d10d      	bne.n	801cbdc <wc_ecc_gen_k+0x80>
        if (mp_cmp(k, order) != MP_LT) {
 801cbc0:	6839      	ldr	r1, [r7, #0]
 801cbc2:	6878      	ldr	r0, [r7, #4]
 801cbc4:	f009 fef8 	bl	80269b8 <mp_cmp>
 801cbc8:	4603      	mov	r3, r0
 801cbca:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 801cbce:	d005      	beq.n	801cbdc <wc_ecc_gen_k+0x80>
            err = mp_mod(k, order, k);
 801cbd0:	687a      	ldr	r2, [r7, #4]
 801cbd2:	6839      	ldr	r1, [r7, #0]
 801cbd4:	6878      	ldr	r0, [r7, #4]
 801cbd6:	f009 fe99 	bl	802690c <mp_mod>
 801cbda:	65f8      	str	r0, [r7, #92]	@ 0x5c
        }
    }

    /* quick sanity check to make sure we're not dealing with a 0 key */
    if (err == MP_OKAY) {
 801cbdc:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801cbde:	2b00      	cmp	r3, #0
 801cbe0:	d108      	bne.n	801cbf4 <wc_ecc_gen_k+0x98>
        if (mp_iszero(k) == MP_YES)
 801cbe2:	6878      	ldr	r0, [r7, #4]
 801cbe4:	f009 ffaf 	bl	8026b46 <mp_iszero>
 801cbe8:	4603      	mov	r3, r0
 801cbea:	2b01      	cmp	r3, #1
 801cbec:	d102      	bne.n	801cbf4 <wc_ecc_gen_k+0x98>
          err = MP_ZERO_E;
 801cbee:	f06f 0378 	mvn.w	r3, #120	@ 0x78
 801cbf2:	65fb      	str	r3, [r7, #92]	@ 0x5c
    }

    ForceZero(buf, ECC_MAXSIZE_GEN);
 801cbf4:	f107 0310 	add.w	r3, r7, #16
 801cbf8:	214a      	movs	r1, #74	@ 0x4a
 801cbfa:	4618      	mov	r0, r3
 801cbfc:	f7fd fdbe 	bl	801a77c <ForceZero>
#ifdef WOLFSSL_CHECK_MEM_ZERO
    wc_MemZero_Check(buf, ECC_MAXSIZE_GEN);
#endif

    return err;
 801cc00:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
    (void)size;
    (void)k;
    (void)order;
    return NOT_COMPILED_IN;
#endif /* !WC_NO_RNG */
}
 801cc02:	4618      	mov	r0, r3
 801cc04:	3760      	adds	r7, #96	@ 0x60
 801cc06:	46bd      	mov	sp, r7
 801cc08:	bd80      	pop	{r7, pc}

0801cc0a <wc_ecc_reset>:

static WC_INLINE void wc_ecc_reset(ecc_key* key)
{
 801cc0a:	b480      	push	{r7}
 801cc0c:	b083      	sub	sp, #12
 801cc0e:	af00      	add	r7, sp, #0
 801cc10:	6078      	str	r0, [r7, #4]
    /* make sure required key variables are reset */
    key->state = ECC_STATE_NONE;
 801cc12:	687b      	ldr	r3, [r7, #4]
 801cc14:	2200      	movs	r2, #0
 801cc16:	609a      	str	r2, [r3, #8]
}
 801cc18:	bf00      	nop
 801cc1a:	370c      	adds	r7, #12
 801cc1c:	46bd      	mov	sp, r7
 801cc1e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cc22:	4770      	bx	lr

0801cc24 <ecc_make_pub_ex>:
 *
 * returns MP_OKAY on success
 */
static int ecc_make_pub_ex(ecc_key* key, ecc_curve_spec* curve,
        ecc_point* pubOut, WC_RNG* rng)
{
 801cc24:	b5b0      	push	{r4, r5, r7, lr}
 801cc26:	b08e      	sub	sp, #56	@ 0x38
 801cc28:	af06      	add	r7, sp, #24
 801cc2a:	60f8      	str	r0, [r7, #12]
 801cc2c:	60b9      	str	r1, [r7, #8]
 801cc2e:	607a      	str	r2, [r7, #4]
 801cc30:	603b      	str	r3, [r7, #0]
    int err = MP_OKAY;
 801cc32:	2300      	movs	r3, #0
 801cc34:	61fb      	str	r3, [r7, #28]
    ecc_point* pub;
#endif /* HAVE_ECC_MAKE_PUB */

    (void)rng;

    if (key == NULL) {
 801cc36:	68fb      	ldr	r3, [r7, #12]
 801cc38:	2b00      	cmp	r3, #0
 801cc3a:	d102      	bne.n	801cc42 <ecc_make_pub_ex+0x1e>
        return BAD_FUNC_ARG;
 801cc3c:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801cc40:	e0cc      	b.n	801cddc <ecc_make_pub_ex+0x1b8>

    SAVE_VECTOR_REGISTERS(return _svr_ret;);

#ifdef HAVE_ECC_MAKE_PUB
    /* if ecc_point passed in then use it as output for public key point */
    if (pubOut != NULL) {
 801cc42:	687b      	ldr	r3, [r7, #4]
 801cc44:	2b00      	cmp	r3, #0
 801cc46:	d002      	beq.n	801cc4e <ecc_make_pub_ex+0x2a>
        pub = pubOut;
 801cc48:	687b      	ldr	r3, [r7, #4]
 801cc4a:	61bb      	str	r3, [r7, #24]
 801cc4c:	e005      	b.n	801cc5a <ecc_make_pub_ex+0x36>
    }
    else {
        /* caching public key making it a ECC_PRIVATEKEY instead of
           ECC_PRIVATEKEY_ONLY */
        pub = &key->pubkey;
 801cc4e:	68fb      	ldr	r3, [r7, #12]
 801cc50:	3318      	adds	r3, #24
 801cc52:	61bb      	str	r3, [r7, #24]
        key->type = ECC_PRIVATEKEY_ONLY;
 801cc54:	68fb      	ldr	r3, [r7, #12]
 801cc56:	2203      	movs	r2, #3
 801cc58:	601a      	str	r2, [r3, #0]
    }

    if ((err == MP_OKAY) && (mp_iszero(ecc_get_k(key)) ||
 801cc5a:	69fb      	ldr	r3, [r7, #28]
 801cc5c:	2b00      	cmp	r3, #0
 801cc5e:	d11e      	bne.n	801cc9e <ecc_make_pub_ex+0x7a>
 801cc60:	68fb      	ldr	r3, [r7, #12]
 801cc62:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 801cc66:	4618      	mov	r0, r3
 801cc68:	f009 ff6d 	bl	8026b46 <mp_iszero>
 801cc6c:	4603      	mov	r3, r0
 801cc6e:	2b00      	cmp	r3, #0
 801cc70:	d112      	bne.n	801cc98 <ecc_make_pub_ex+0x74>
            mp_isneg(ecc_get_k(key)) ||
 801cc72:	68fb      	ldr	r3, [r7, #12]
 801cc74:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 801cc78:	685b      	ldr	r3, [r3, #4]
    if ((err == MP_OKAY) && (mp_iszero(ecc_get_k(key)) ||
 801cc7a:	2b00      	cmp	r3, #0
 801cc7c:	d10c      	bne.n	801cc98 <ecc_make_pub_ex+0x74>
            (mp_cmp(ecc_get_k(key), curve->order) != MP_LT))) {
 801cc7e:	68fb      	ldr	r3, [r7, #12]
 801cc80:	f8d3 2118 	ldr.w	r2, [r3, #280]	@ 0x118
 801cc84:	68bb      	ldr	r3, [r7, #8]
 801cc86:	691b      	ldr	r3, [r3, #16]
 801cc88:	4619      	mov	r1, r3
 801cc8a:	4610      	mov	r0, r2
 801cc8c:	f009 fe94 	bl	80269b8 <mp_cmp>
 801cc90:	4603      	mov	r3, r0
            mp_isneg(ecc_get_k(key)) ||
 801cc92:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 801cc96:	d002      	beq.n	801cc9e <ecc_make_pub_ex+0x7a>
        err = ECC_PRIV_KEY_E;
 801cc98:	f06f 03d7 	mvn.w	r3, #215	@ 0xd7
 801cc9c:	61fb      	str	r3, [r7, #28]
    }

    if (err == MP_OKAY) {
 801cc9e:	69fb      	ldr	r3, [r7, #28]
 801cca0:	2b00      	cmp	r3, #0
 801cca2:	d11d      	bne.n	801cce0 <ecc_make_pub_ex+0xbc>
    #ifndef ALT_ECC_SIZE
        err = mp_init_multi(pub->x, pub->y, pub->z, NULL, NULL, NULL);
    #else
        pub->x = (mp_int*)&pub->xyz[0];
 801cca4:	69bb      	ldr	r3, [r7, #24]
 801cca6:	f103 020c 	add.w	r2, r3, #12
 801ccaa:	69bb      	ldr	r3, [r7, #24]
 801ccac:	601a      	str	r2, [r3, #0]
        pub->y = (mp_int*)&pub->xyz[1];
 801ccae:	69bb      	ldr	r3, [r7, #24]
 801ccb0:	f103 025c 	add.w	r2, r3, #92	@ 0x5c
 801ccb4:	69bb      	ldr	r3, [r7, #24]
 801ccb6:	605a      	str	r2, [r3, #4]
        pub->z = (mp_int*)&pub->xyz[2];
 801ccb8:	69bb      	ldr	r3, [r7, #24]
 801ccba:	f103 02ac 	add.w	r2, r3, #172	@ 0xac
 801ccbe:	69bb      	ldr	r3, [r7, #24]
 801ccc0:	609a      	str	r2, [r3, #8]
        alt_fp_init(pub->x);
 801ccc2:	69bb      	ldr	r3, [r7, #24]
 801ccc4:	681b      	ldr	r3, [r3, #0]
 801ccc6:	4618      	mov	r0, r3
 801ccc8:	f7fd ff5a 	bl	801ab80 <alt_fp_init>
        alt_fp_init(pub->y);
 801cccc:	69bb      	ldr	r3, [r7, #24]
 801ccce:	685b      	ldr	r3, [r3, #4]
 801ccd0:	4618      	mov	r0, r3
 801ccd2:	f7fd ff55 	bl	801ab80 <alt_fp_init>
        alt_fp_init(pub->z);
 801ccd6:	69bb      	ldr	r3, [r7, #24]
 801ccd8:	689b      	ldr	r3, [r3, #8]
 801ccda:	4618      	mov	r0, r3
 801ccdc:	f7fd ff50 	bl	801ab80 <alt_fp_init>
#endif /* WOLFSSL_HAVE_SP_ECC */

#if defined(WOLFSSL_SP_MATH)
        err = WC_KEY_SIZE_E;
#else
    if (err == MP_OKAY) {
 801cce0:	69fb      	ldr	r3, [r7, #28]
 801cce2:	2b00      	cmp	r3, #0
 801cce4:	d16f      	bne.n	801cdc6 <ecc_make_pub_ex+0x1a2>
        /* Multi-Precision Math: compute public curve */
        mp_digit mp = 0;
 801cce6:	2300      	movs	r3, #0
 801cce8:	617b      	str	r3, [r7, #20]
        ecc_point* base = NULL;
 801ccea:	2300      	movs	r3, #0
 801ccec:	613b      	str	r3, [r7, #16]
    #ifdef WOLFSSL_NO_MALLOC
        ecc_point  lcl_base;
        base = &lcl_base;
    #endif
        err = wc_ecc_new_point_ex(&base, key->heap);
 801ccee:	68fb      	ldr	r3, [r7, #12]
 801ccf0:	695a      	ldr	r2, [r3, #20]
 801ccf2:	f107 0310 	add.w	r3, r7, #16
 801ccf6:	4611      	mov	r1, r2
 801ccf8:	4618      	mov	r0, r3
 801ccfa:	f7ff fde8 	bl	801c8ce <wc_ecc_new_point_ex>
 801ccfe:	61f8      	str	r0, [r7, #28]

        /* read in the x/y for this key */
        if (err == MP_OKAY)
 801cd00:	69fb      	ldr	r3, [r7, #28]
 801cd02:	2b00      	cmp	r3, #0
 801cd04:	d108      	bne.n	801cd18 <ecc_make_pub_ex+0xf4>
            err = mp_copy(curve->Gx, base->x);
 801cd06:	68bb      	ldr	r3, [r7, #8]
 801cd08:	695a      	ldr	r2, [r3, #20]
 801cd0a:	693b      	ldr	r3, [r7, #16]
 801cd0c:	681b      	ldr	r3, [r3, #0]
 801cd0e:	4619      	mov	r1, r3
 801cd10:	4610      	mov	r0, r2
 801cd12:	f009 ff0a 	bl	8026b2a <mp_copy>
 801cd16:	61f8      	str	r0, [r7, #28]
        if (err == MP_OKAY)
 801cd18:	69fb      	ldr	r3, [r7, #28]
 801cd1a:	2b00      	cmp	r3, #0
 801cd1c:	d108      	bne.n	801cd30 <ecc_make_pub_ex+0x10c>
            err = mp_copy(curve->Gy, base->y);
 801cd1e:	68bb      	ldr	r3, [r7, #8]
 801cd20:	699a      	ldr	r2, [r3, #24]
 801cd22:	693b      	ldr	r3, [r7, #16]
 801cd24:	685b      	ldr	r3, [r3, #4]
 801cd26:	4619      	mov	r1, r3
 801cd28:	4610      	mov	r0, r2
 801cd2a:	f009 fefe 	bl	8026b2a <mp_copy>
 801cd2e:	61f8      	str	r0, [r7, #28]
        if (err == MP_OKAY)
 801cd30:	69fb      	ldr	r3, [r7, #28]
 801cd32:	2b00      	cmp	r3, #0
 801cd34:	d108      	bne.n	801cd48 <ecc_make_pub_ex+0x124>
            err = mp_montgomery_setup(curve->prime, &mp);
 801cd36:	68bb      	ldr	r3, [r7, #8]
 801cd38:	685b      	ldr	r3, [r3, #4]
 801cd3a:	f107 0214 	add.w	r2, r7, #20
 801cd3e:	4611      	mov	r1, r2
 801cd40:	4618      	mov	r0, r3
 801cd42:	f00a f983 	bl	802704c <mp_montgomery_setup>
 801cd46:	61f8      	str	r0, [r7, #28]
        if (err == MP_OKAY)
 801cd48:	69fb      	ldr	r3, [r7, #28]
 801cd4a:	2b00      	cmp	r3, #0
 801cd4c:	d106      	bne.n	801cd5c <ecc_make_pub_ex+0x138>
            err = mp_set(base->z, 1);
 801cd4e:	693b      	ldr	r3, [r7, #16]
 801cd50:	689b      	ldr	r3, [r3, #8]
 801cd52:	2101      	movs	r1, #1
 801cd54:	4618      	mov	r0, r3
 801cd56:	f00a f9a5 	bl	80270a4 <mp_set>
 801cd5a:	61f8      	str	r0, [r7, #28]

        /* make the public key */
        if (err == MP_OKAY) {
 801cd5c:	69fb      	ldr	r3, [r7, #28]
 801cd5e:	2b00      	cmp	r3, #0
 801cd60:	d11f      	bne.n	801cda2 <ecc_make_pub_ex+0x17e>
            /* Map in a separate call as this should be constant time */
            err = wc_ecc_mulmod_ex2(ecc_get_k(key), base, pub, curve->Af,
 801cd62:	68fb      	ldr	r3, [r7, #12]
 801cd64:	f8d3 0118 	ldr.w	r0, [r3, #280]	@ 0x118
 801cd68:	693c      	ldr	r4, [r7, #16]
 801cd6a:	68bb      	ldr	r3, [r7, #8]
 801cd6c:	689d      	ldr	r5, [r3, #8]
 801cd6e:	68bb      	ldr	r3, [r7, #8]
 801cd70:	685b      	ldr	r3, [r3, #4]
 801cd72:	68ba      	ldr	r2, [r7, #8]
 801cd74:	6912      	ldr	r2, [r2, #16]
 801cd76:	68f9      	ldr	r1, [r7, #12]
 801cd78:	6949      	ldr	r1, [r1, #20]
 801cd7a:	9104      	str	r1, [sp, #16]
 801cd7c:	2100      	movs	r1, #0
 801cd7e:	9103      	str	r1, [sp, #12]
 801cd80:	6839      	ldr	r1, [r7, #0]
 801cd82:	9102      	str	r1, [sp, #8]
 801cd84:	9201      	str	r2, [sp, #4]
 801cd86:	9300      	str	r3, [sp, #0]
 801cd88:	462b      	mov	r3, r5
 801cd8a:	69ba      	ldr	r2, [r7, #24]
 801cd8c:	4621      	mov	r1, r4
 801cd8e:	f7ff fced 	bl	801c76c <wc_ecc_mulmod_ex2>
 801cd92:	61f8      	str	r0, [r7, #28]
                                 curve->prime, curve->order, rng, 0, key->heap);
            if (err == WC_NO_ERR_TRACE(MP_MEM)) {
 801cd94:	69fb      	ldr	r3, [r7, #28]
 801cd96:	f113 0f61 	cmn.w	r3, #97	@ 0x61
 801cd9a:	d102      	bne.n	801cda2 <ecc_make_pub_ex+0x17e>
               err = MEMORY_E;
 801cd9c:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801cda0:	61fb      	str	r3, [r7, #28]
            }
        }
        if (err == MP_OKAY) {
 801cda2:	69fb      	ldr	r3, [r7, #28]
 801cda4:	2b00      	cmp	r3, #0
 801cda6:	d107      	bne.n	801cdb8 <ecc_make_pub_ex+0x194>
            /* Use constant time map if compiled in */
            err = ecc_map_ex(pub, curve->prime, mp, 1);
 801cda8:	68bb      	ldr	r3, [r7, #8]
 801cdaa:	6859      	ldr	r1, [r3, #4]
 801cdac:	697a      	ldr	r2, [r7, #20]
 801cdae:	2301      	movs	r3, #1
 801cdb0:	69b8      	ldr	r0, [r7, #24]
 801cdb2:	f7fe fe9b 	bl	801baec <ecc_map_ex>
 801cdb6:	61f8      	str	r0, [r7, #28]
        }

        wc_ecc_del_point_ex(base, key->heap);
 801cdb8:	693a      	ldr	r2, [r7, #16]
 801cdba:	68fb      	ldr	r3, [r7, #12]
 801cdbc:	695b      	ldr	r3, [r3, #20]
 801cdbe:	4619      	mov	r1, r3
 801cdc0:	4610      	mov	r0, r2
 801cdc2:	f7ff fdd9 	bl	801c978 <wc_ecc_del_point_ex>
    (void)curve;
    err = NOT_COMPILED_IN;
#endif /* HAVE_ECC_MAKE_PUB */

    /* change key state if public part is cached */
    if (key->type == ECC_PRIVATEKEY_ONLY && pubOut == NULL) {
 801cdc6:	68fb      	ldr	r3, [r7, #12]
 801cdc8:	681b      	ldr	r3, [r3, #0]
 801cdca:	2b03      	cmp	r3, #3
 801cdcc:	d105      	bne.n	801cdda <ecc_make_pub_ex+0x1b6>
 801cdce:	687b      	ldr	r3, [r7, #4]
 801cdd0:	2b00      	cmp	r3, #0
 801cdd2:	d102      	bne.n	801cdda <ecc_make_pub_ex+0x1b6>
        key->type = ECC_PRIVATEKEY;
 801cdd4:	68fb      	ldr	r3, [r7, #12]
 801cdd6:	2202      	movs	r2, #2
 801cdd8:	601a      	str	r2, [r3, #0]
    }

    RESTORE_VECTOR_REGISTERS();

    return err;
 801cdda:	69fb      	ldr	r3, [r7, #28]
}
 801cddc:	4618      	mov	r0, r3
 801cdde:	3720      	adds	r7, #32
 801cde0:	46bd      	mov	sp, r7
 801cde2:	bdb0      	pop	{r4, r5, r7, pc}

0801cde4 <wc_ecc_init_ex>:
}

/* Setup dynamic pointers if using normal math for proper freeing */
WOLFSSL_ABI
int wc_ecc_init_ex(ecc_key* key, void* heap, int devId)
{
 801cde4:	b580      	push	{r7, lr}
 801cde6:	b086      	sub	sp, #24
 801cde8:	af00      	add	r7, sp, #0
 801cdea:	60f8      	str	r0, [r7, #12]
 801cdec:	60b9      	str	r1, [r7, #8]
 801cdee:	607a      	str	r2, [r7, #4]
    int ret      = 0;
 801cdf0:	2300      	movs	r3, #0
 801cdf2:	617b      	str	r3, [r7, #20]

    if (key == NULL) {
 801cdf4:	68fb      	ldr	r3, [r7, #12]
 801cdf6:	2b00      	cmp	r3, #0
 801cdf8:	d102      	bne.n	801ce00 <wc_ecc_init_ex+0x1c>
        return BAD_FUNC_ARG;
 801cdfa:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801cdfe:	e036      	b.n	801ce6e <wc_ecc_init_ex+0x8a>

#ifdef ECC_DUMP_OID
    wc_ecc_dump_oids();
#endif

    XMEMSET(key, 0, sizeof(ecc_key));
 801ce00:	f44f 72b8 	mov.w	r2, #368	@ 0x170
 801ce04:	2100      	movs	r1, #0
 801ce06:	68f8      	ldr	r0, [r7, #12]
 801ce08:	f00b fb5e 	bl	80284c8 <memset>
    key->state = ECC_STATE_NONE;
 801ce0c:	68fb      	ldr	r3, [r7, #12]
 801ce0e:	2200      	movs	r2, #0
 801ce10:	609a      	str	r2, [r3, #8]
    key->slot = ATECC_INVALID_SLOT;
#elif defined(WOLFSSL_KCAPI_ECC)
    key->handle = NULL;
#else
#ifdef ALT_ECC_SIZE
    key->pubkey.x = (mp_int*)&key->pubkey.xyz[0];
 801ce12:	68fb      	ldr	r3, [r7, #12]
 801ce14:	f103 0224 	add.w	r2, r3, #36	@ 0x24
 801ce18:	68fb      	ldr	r3, [r7, #12]
 801ce1a:	619a      	str	r2, [r3, #24]
    key->pubkey.y = (mp_int*)&key->pubkey.xyz[1];
 801ce1c:	68fb      	ldr	r3, [r7, #12]
 801ce1e:	f103 0274 	add.w	r2, r3, #116	@ 0x74
 801ce22:	68fb      	ldr	r3, [r7, #12]
 801ce24:	61da      	str	r2, [r3, #28]
    key->pubkey.z = (mp_int*)&key->pubkey.xyz[2];
 801ce26:	68fb      	ldr	r3, [r7, #12]
 801ce28:	f103 02c4 	add.w	r2, r3, #196	@ 0xc4
 801ce2c:	68fb      	ldr	r3, [r7, #12]
 801ce2e:	621a      	str	r2, [r3, #32]
    alt_fp_init(key->pubkey.x);
 801ce30:	68fb      	ldr	r3, [r7, #12]
 801ce32:	699b      	ldr	r3, [r3, #24]
 801ce34:	4618      	mov	r0, r3
 801ce36:	f7fd fea3 	bl	801ab80 <alt_fp_init>
    alt_fp_init(key->pubkey.y);
 801ce3a:	68fb      	ldr	r3, [r7, #12]
 801ce3c:	69db      	ldr	r3, [r3, #28]
 801ce3e:	4618      	mov	r0, r3
 801ce40:	f7fd fe9e 	bl	801ab80 <alt_fp_init>
    alt_fp_init(key->pubkey.z);
 801ce44:	68fb      	ldr	r3, [r7, #12]
 801ce46:	6a1b      	ldr	r3, [r3, #32]
 801ce48:	4618      	mov	r0, r3
 801ce4a:	f7fd fe99 	bl	801ab80 <alt_fp_init>
    key->k = (mp_int*)key->ka;
 801ce4e:	68fb      	ldr	r3, [r7, #12]
 801ce50:	f503 728e 	add.w	r2, r3, #284	@ 0x11c
 801ce54:	68fb      	ldr	r3, [r7, #12]
 801ce56:	f8c3 2118 	str.w	r2, [r3, #280]	@ 0x118
    alt_fp_init(key->k);
 801ce5a:	68fb      	ldr	r3, [r7, #12]
 801ce5c:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 801ce60:	4618      	mov	r0, r3
 801ce62:	f7fd fe8d 	bl	801ab80 <alt_fp_init>

#ifdef WOLFSSL_HEAP_TEST
    (void)heap;
    key->heap = (void*)WOLFSSL_HEAP_TEST;
#else
    key->heap = heap;
 801ce66:	68fb      	ldr	r3, [r7, #12]
 801ce68:	68ba      	ldr	r2, [r7, #8]
 801ce6a:	615a      	str	r2, [r3, #20]
        WOLFSSL_MSG("Can't initialize Xsecure");
        return WC_HW_E;
    }
#endif

    return ret;
 801ce6c:	697b      	ldr	r3, [r7, #20]
}
 801ce6e:	4618      	mov	r0, r3
 801ce70:	3718      	adds	r7, #24
 801ce72:	46bd      	mov	sp, r7
 801ce74:	bd80      	pop	{r7, pc}

0801ce76 <wc_ecc_get_curve_order_bit_count>:
    return 0;
}


static int wc_ecc_get_curve_order_bit_count(const ecc_set_type* dp)
{
 801ce76:	b580      	push	{r7, lr}
 801ce78:	b094      	sub	sp, #80	@ 0x50
 801ce7a:	af00      	add	r7, sp, #0
 801ce7c:	6078      	str	r0, [r7, #4]
    int err = MP_OKAY;
 801ce7e:	2300      	movs	r3, #0
 801ce80:	64fb      	str	r3, [r7, #76]	@ 0x4c
    int orderBits;
    DECLARE_CURVE_SPECS(1);
 801ce82:	2300      	movs	r3, #0
 801ce84:	64bb      	str	r3, [r7, #72]	@ 0x48
 801ce86:	f107 0310 	add.w	r3, r7, #16
 801ce8a:	60fb      	str	r3, [r7, #12]
 801ce8c:	68fb      	ldr	r3, [r7, #12]
 801ce8e:	222c      	movs	r2, #44	@ 0x2c
 801ce90:	2100      	movs	r1, #0
 801ce92:	4618      	mov	r0, r3
 801ce94:	f00b fb18 	bl	80284c8 <memset>
 801ce98:	68fb      	ldr	r3, [r7, #12]
 801ce9a:	2201      	movs	r2, #1
 801ce9c:	621a      	str	r2, [r3, #32]

    ALLOC_CURVE_SPECS(1, err);
 801ce9e:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801cea2:	f001 fdf1 	bl	801ea88 <wolfSSL_Malloc>
 801cea6:	64b8      	str	r0, [r7, #72]	@ 0x48
 801cea8:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801ceaa:	2b00      	cmp	r3, #0
 801ceac:	d103      	bne.n	801ceb6 <wc_ecc_get_curve_order_bit_count+0x40>
 801ceae:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801ceb2:	64fb      	str	r3, [r7, #76]	@ 0x4c
 801ceb4:	e002      	b.n	801cebc <wc_ecc_get_curve_order_bit_count+0x46>
 801ceb6:	68fb      	ldr	r3, [r7, #12]
 801ceb8:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 801ceba:	61da      	str	r2, [r3, #28]
    if (err == MP_OKAY) {
 801cebc:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801cebe:	2b00      	cmp	r3, #0
 801cec0:	d107      	bne.n	801ced2 <wc_ecc_get_curve_order_bit_count+0x5c>
        err = wc_ecc_curve_load(dp, &curve, ECC_CURVE_FIELD_ORDER);
 801cec2:	f107 030c 	add.w	r3, r7, #12
 801cec6:	2208      	movs	r2, #8
 801cec8:	4619      	mov	r1, r3
 801ceca:	6878      	ldr	r0, [r7, #4]
 801cecc:	f7fd fd3d 	bl	801a94a <wc_ecc_curve_load>
 801ced0:	64f8      	str	r0, [r7, #76]	@ 0x4c
    }

    if (err != 0) {
 801ced2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801ced4:	2b00      	cmp	r3, #0
 801ced6:	d009      	beq.n	801ceec <wc_ecc_get_curve_order_bit_count+0x76>
       FREE_CURVE_SPECS();
 801ced8:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801ceda:	63fb      	str	r3, [r7, #60]	@ 0x3c
 801cedc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801cede:	2b00      	cmp	r3, #0
 801cee0:	d002      	beq.n	801cee8 <wc_ecc_get_curve_order_bit_count+0x72>
 801cee2:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 801cee4:	f001 fdec 	bl	801eac0 <wolfSSL_Free>
       return err;
 801cee8:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801ceea:	e012      	b.n	801cf12 <wc_ecc_get_curve_order_bit_count+0x9c>
    }
    orderBits = mp_count_bits(curve->order);
 801ceec:	68fb      	ldr	r3, [r7, #12]
 801ceee:	691b      	ldr	r3, [r3, #16]
 801cef0:	4618      	mov	r0, r3
 801cef2:	f009 fe39 	bl	8026b68 <mp_count_bits>
 801cef6:	6478      	str	r0, [r7, #68]	@ 0x44

    wc_ecc_curve_free(curve);
 801cef8:	68fb      	ldr	r3, [r7, #12]
 801cefa:	4618      	mov	r0, r3
 801cefc:	f7fd fcda 	bl	801a8b4 <wc_ecc_curve_free>
    FREE_CURVE_SPECS();
 801cf00:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801cf02:	643b      	str	r3, [r7, #64]	@ 0x40
 801cf04:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801cf06:	2b00      	cmp	r3, #0
 801cf08:	d002      	beq.n	801cf10 <wc_ecc_get_curve_order_bit_count+0x9a>
 801cf0a:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 801cf0c:	f001 fdd8 	bl	801eac0 <wolfSSL_Free>
    return orderBits;
 801cf10:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
}
 801cf12:	4618      	mov	r0, r3
 801cf14:	3750      	adds	r7, #80	@ 0x50
 801cf16:	46bd      	mov	sp, r7
 801cf18:	bd80      	pop	{r7, pc}

0801cf1a <wc_ecc_free>:
  Free an ECC key from memory
  key   The key you wish to free
*/
WOLFSSL_ABI
int wc_ecc_free(ecc_key* key)
{
 801cf1a:	b580      	push	{r7, lr}
 801cf1c:	b082      	sub	sp, #8
 801cf1e:	af00      	add	r7, sp, #0
 801cf20:	6078      	str	r0, [r7, #4]
    if (key == NULL) {
 801cf22:	687b      	ldr	r3, [r7, #4]
 801cf24:	2b00      	cmp	r3, #0
 801cf26:	d101      	bne.n	801cf2c <wc_ecc_free+0x12>
        return 0;
 801cf28:	2300      	movs	r3, #0
 801cf2a:	e01a      	b.n	801cf62 <wc_ecc_free+0x48>

#ifdef WOLFSSL_MAXQ10XX_CRYPTO
    wc_MAXQ10XX_EccFree(key);
#endif

    mp_clear(key->pubkey.x);
 801cf2c:	687b      	ldr	r3, [r7, #4]
 801cf2e:	699b      	ldr	r3, [r3, #24]
 801cf30:	4618      	mov	r0, r3
 801cf32:	f009 fc38 	bl	80267a6 <mp_clear>
    mp_clear(key->pubkey.y);
 801cf36:	687b      	ldr	r3, [r7, #4]
 801cf38:	69db      	ldr	r3, [r3, #28]
 801cf3a:	4618      	mov	r0, r3
 801cf3c:	f009 fc33 	bl	80267a6 <mp_clear>
    mp_clear(key->pubkey.z);
 801cf40:	687b      	ldr	r3, [r7, #4]
 801cf42:	6a1b      	ldr	r3, [r3, #32]
 801cf44:	4618      	mov	r0, r3
 801cf46:	f009 fc2e 	bl	80267a6 <mp_clear>

#ifdef ALT_ECC_SIZE
    if (key->k)
 801cf4a:	687b      	ldr	r3, [r7, #4]
 801cf4c:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 801cf50:	2b00      	cmp	r3, #0
 801cf52:	d005      	beq.n	801cf60 <wc_ecc_free+0x46>
#endif
        mp_forcezero(key->k);
 801cf54:	687b      	ldr	r3, [r7, #4]
 801cf56:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 801cf5a:	4618      	mov	r0, r3
 801cf5c:	f009 fc0e 	bl	802677c <mp_forcezero>

#ifdef WOLFSSL_CHECK_MEM_ZERO
    wc_MemZero_Check(key, sizeof(ecc_key));
#endif

    return 0;
 801cf60:	2300      	movs	r3, #0
}
 801cf62:	4618      	mov	r0, r3
 801cf64:	3708      	adds	r7, #8
 801cf66:	46bd      	mov	sp, r7
 801cf68:	bd80      	pop	{r7, pc}

0801cf6a <ecc_projective_add_point_safe>:
 *           (Result was: z == 0, x and/or y not 0)
 *        -> Need to set result to infinity.
 */
int ecc_projective_add_point_safe(ecc_point* A, ecc_point* B, ecc_point* R,
    mp_int* a, mp_int* modulus, mp_digit mp, int* infinity)
{
 801cf6a:	b580      	push	{r7, lr}
 801cf6c:	b088      	sub	sp, #32
 801cf6e:	af02      	add	r7, sp, #8
 801cf70:	60f8      	str	r0, [r7, #12]
 801cf72:	60b9      	str	r1, [r7, #8]
 801cf74:	607a      	str	r2, [r7, #4]
 801cf76:	603b      	str	r3, [r7, #0]
    int err;

    if (mp_iszero(A->x) && mp_iszero(A->y)) {
 801cf78:	68fb      	ldr	r3, [r7, #12]
 801cf7a:	681b      	ldr	r3, [r3, #0]
 801cf7c:	4618      	mov	r0, r3
 801cf7e:	f009 fde2 	bl	8026b46 <mp_iszero>
 801cf82:	4603      	mov	r3, r0
 801cf84:	2b00      	cmp	r3, #0
 801cf86:	d00d      	beq.n	801cfa4 <ecc_projective_add_point_safe+0x3a>
 801cf88:	68fb      	ldr	r3, [r7, #12]
 801cf8a:	685b      	ldr	r3, [r3, #4]
 801cf8c:	4618      	mov	r0, r3
 801cf8e:	f009 fdda 	bl	8026b46 <mp_iszero>
 801cf92:	4603      	mov	r3, r0
 801cf94:	2b00      	cmp	r3, #0
 801cf96:	d005      	beq.n	801cfa4 <ecc_projective_add_point_safe+0x3a>
        /* A is infinity. */
        err = wc_ecc_copy_point(B, R);
 801cf98:	6879      	ldr	r1, [r7, #4]
 801cf9a:	68b8      	ldr	r0, [r7, #8]
 801cf9c:	f7ff fd23 	bl	801c9e6 <wc_ecc_copy_point>
 801cfa0:	6178      	str	r0, [r7, #20]
 801cfa2:	e0e1      	b.n	801d168 <ecc_projective_add_point_safe+0x1fe>
    }
    else if (mp_iszero(B->x) && mp_iszero(B->y)) {
 801cfa4:	68bb      	ldr	r3, [r7, #8]
 801cfa6:	681b      	ldr	r3, [r3, #0]
 801cfa8:	4618      	mov	r0, r3
 801cfaa:	f009 fdcc 	bl	8026b46 <mp_iszero>
 801cfae:	4603      	mov	r3, r0
 801cfb0:	2b00      	cmp	r3, #0
 801cfb2:	d00d      	beq.n	801cfd0 <ecc_projective_add_point_safe+0x66>
 801cfb4:	68bb      	ldr	r3, [r7, #8]
 801cfb6:	685b      	ldr	r3, [r3, #4]
 801cfb8:	4618      	mov	r0, r3
 801cfba:	f009 fdc4 	bl	8026b46 <mp_iszero>
 801cfbe:	4603      	mov	r3, r0
 801cfc0:	2b00      	cmp	r3, #0
 801cfc2:	d005      	beq.n	801cfd0 <ecc_projective_add_point_safe+0x66>
        /* B is infinity. */
        err = wc_ecc_copy_point(A, R);
 801cfc4:	6879      	ldr	r1, [r7, #4]
 801cfc6:	68f8      	ldr	r0, [r7, #12]
 801cfc8:	f7ff fd0d 	bl	801c9e6 <wc_ecc_copy_point>
 801cfcc:	6178      	str	r0, [r7, #20]
 801cfce:	e0cb      	b.n	801d168 <ecc_projective_add_point_safe+0x1fe>
    }
    else if ((mp_cmp(A->x, B->x) == MP_EQ) && (mp_cmp(A->z, B->z) == MP_EQ)) {
 801cfd0:	68fb      	ldr	r3, [r7, #12]
 801cfd2:	681a      	ldr	r2, [r3, #0]
 801cfd4:	68bb      	ldr	r3, [r7, #8]
 801cfd6:	681b      	ldr	r3, [r3, #0]
 801cfd8:	4619      	mov	r1, r3
 801cfda:	4610      	mov	r0, r2
 801cfdc:	f009 fcec 	bl	80269b8 <mp_cmp>
 801cfe0:	4603      	mov	r3, r0
 801cfe2:	2b00      	cmp	r3, #0
 801cfe4:	d144      	bne.n	801d070 <ecc_projective_add_point_safe+0x106>
 801cfe6:	68fb      	ldr	r3, [r7, #12]
 801cfe8:	689a      	ldr	r2, [r3, #8]
 801cfea:	68bb      	ldr	r3, [r7, #8]
 801cfec:	689b      	ldr	r3, [r3, #8]
 801cfee:	4619      	mov	r1, r3
 801cff0:	4610      	mov	r0, r2
 801cff2:	f009 fce1 	bl	80269b8 <mp_cmp>
 801cff6:	4603      	mov	r3, r0
 801cff8:	2b00      	cmp	r3, #0
 801cffa:	d139      	bne.n	801d070 <ecc_projective_add_point_safe+0x106>
        /* x ordinattes the same. */
        if (mp_cmp(A->y, B->y) == MP_EQ) {
 801cffc:	68fb      	ldr	r3, [r7, #12]
 801cffe:	685a      	ldr	r2, [r3, #4]
 801d000:	68bb      	ldr	r3, [r7, #8]
 801d002:	685b      	ldr	r3, [r3, #4]
 801d004:	4619      	mov	r1, r3
 801d006:	4610      	mov	r0, r2
 801d008:	f009 fcd6 	bl	80269b8 <mp_cmp>
 801d00c:	4603      	mov	r3, r0
 801d00e:	2b00      	cmp	r3, #0
 801d010:	d109      	bne.n	801d026 <ecc_projective_add_point_safe+0xbc>
            /* A = B */
            err = _ecc_projective_dbl_point(B, R, a, modulus, mp);
 801d012:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801d014:	9300      	str	r3, [sp, #0]
 801d016:	6a3b      	ldr	r3, [r7, #32]
 801d018:	683a      	ldr	r2, [r7, #0]
 801d01a:	6879      	ldr	r1, [r7, #4]
 801d01c:	68b8      	ldr	r0, [r7, #8]
 801d01e:	f7fe fa4c 	bl	801b4ba <_ecc_projective_dbl_point>
 801d022:	6178      	str	r0, [r7, #20]
        if (mp_cmp(A->y, B->y) == MP_EQ) {
 801d024:	e09d      	b.n	801d162 <ecc_projective_add_point_safe+0x1f8>
        }
        else {
            /* A = -B */
            err = mp_set(R->x, 0);
 801d026:	687b      	ldr	r3, [r7, #4]
 801d028:	681b      	ldr	r3, [r3, #0]
 801d02a:	2100      	movs	r1, #0
 801d02c:	4618      	mov	r0, r3
 801d02e:	f00a f839 	bl	80270a4 <mp_set>
 801d032:	6178      	str	r0, [r7, #20]
            if (err == MP_OKAY)
 801d034:	697b      	ldr	r3, [r7, #20]
 801d036:	2b00      	cmp	r3, #0
 801d038:	d106      	bne.n	801d048 <ecc_projective_add_point_safe+0xde>
                err = mp_set(R->y, 0);
 801d03a:	687b      	ldr	r3, [r7, #4]
 801d03c:	685b      	ldr	r3, [r3, #4]
 801d03e:	2100      	movs	r1, #0
 801d040:	4618      	mov	r0, r3
 801d042:	f00a f82f 	bl	80270a4 <mp_set>
 801d046:	6178      	str	r0, [r7, #20]
            if (err == MP_OKAY)
 801d048:	697b      	ldr	r3, [r7, #20]
 801d04a:	2b00      	cmp	r3, #0
 801d04c:	d106      	bne.n	801d05c <ecc_projective_add_point_safe+0xf2>
                err = mp_set(R->z, 1);
 801d04e:	687b      	ldr	r3, [r7, #4]
 801d050:	689b      	ldr	r3, [r3, #8]
 801d052:	2101      	movs	r1, #1
 801d054:	4618      	mov	r0, r3
 801d056:	f00a f825 	bl	80270a4 <mp_set>
 801d05a:	6178      	str	r0, [r7, #20]
            if ((err == MP_OKAY) && (infinity != NULL))
 801d05c:	697b      	ldr	r3, [r7, #20]
 801d05e:	2b00      	cmp	r3, #0
 801d060:	d17f      	bne.n	801d162 <ecc_projective_add_point_safe+0x1f8>
 801d062:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801d064:	2b00      	cmp	r3, #0
 801d066:	d07c      	beq.n	801d162 <ecc_projective_add_point_safe+0x1f8>
                *infinity = 1;
 801d068:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801d06a:	2201      	movs	r2, #1
 801d06c:	601a      	str	r2, [r3, #0]
        if (mp_cmp(A->y, B->y) == MP_EQ) {
 801d06e:	e078      	b.n	801d162 <ecc_projective_add_point_safe+0x1f8>
        }
    }
    else {
        err = _ecc_projective_add_point(A, B, R, a, modulus, mp);
 801d070:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801d072:	9301      	str	r3, [sp, #4]
 801d074:	6a3b      	ldr	r3, [r7, #32]
 801d076:	9300      	str	r3, [sp, #0]
 801d078:	683b      	ldr	r3, [r7, #0]
 801d07a:	687a      	ldr	r2, [r7, #4]
 801d07c:	68b9      	ldr	r1, [r7, #8]
 801d07e:	68f8      	ldr	r0, [r7, #12]
 801d080:	f7fd fd8c 	bl	801ab9c <_ecc_projective_add_point>
 801d084:	6178      	str	r0, [r7, #20]
        if ((err == MP_OKAY) && mp_iszero(R->z)) {
 801d086:	697b      	ldr	r3, [r7, #20]
 801d088:	2b00      	cmp	r3, #0
 801d08a:	d16d      	bne.n	801d168 <ecc_projective_add_point_safe+0x1fe>
 801d08c:	687b      	ldr	r3, [r7, #4]
 801d08e:	689b      	ldr	r3, [r3, #8]
 801d090:	4618      	mov	r0, r3
 801d092:	f009 fd58 	bl	8026b46 <mp_iszero>
 801d096:	4603      	mov	r3, r0
 801d098:	2b00      	cmp	r3, #0
 801d09a:	d065      	beq.n	801d168 <ecc_projective_add_point_safe+0x1fe>
            /* When all zero then should have done a double */
            if (mp_iszero(R->x) && mp_iszero(R->y)) {
 801d09c:	687b      	ldr	r3, [r7, #4]
 801d09e:	681b      	ldr	r3, [r3, #0]
 801d0a0:	4618      	mov	r0, r3
 801d0a2:	f009 fd50 	bl	8026b46 <mp_iszero>
 801d0a6:	4603      	mov	r3, r0
 801d0a8:	2b00      	cmp	r3, #0
 801d0aa:	d035      	beq.n	801d118 <ecc_projective_add_point_safe+0x1ae>
 801d0ac:	687b      	ldr	r3, [r7, #4]
 801d0ae:	685b      	ldr	r3, [r3, #4]
 801d0b0:	4618      	mov	r0, r3
 801d0b2:	f009 fd48 	bl	8026b46 <mp_iszero>
 801d0b6:	4603      	mov	r3, r0
 801d0b8:	2b00      	cmp	r3, #0
 801d0ba:	d02d      	beq.n	801d118 <ecc_projective_add_point_safe+0x1ae>
                if (mp_iszero(B->z)) {
 801d0bc:	68bb      	ldr	r3, [r7, #8]
 801d0be:	689b      	ldr	r3, [r3, #8]
 801d0c0:	4618      	mov	r0, r3
 801d0c2:	f009 fd40 	bl	8026b46 <mp_iszero>
 801d0c6:	4603      	mov	r3, r0
 801d0c8:	2b00      	cmp	r3, #0
 801d0ca:	d01b      	beq.n	801d104 <ecc_projective_add_point_safe+0x19a>
                    err = wc_ecc_copy_point(B, R);
 801d0cc:	6879      	ldr	r1, [r7, #4]
 801d0ce:	68b8      	ldr	r0, [r7, #8]
 801d0d0:	f7ff fc89 	bl	801c9e6 <wc_ecc_copy_point>
 801d0d4:	6178      	str	r0, [r7, #20]
                    if (err == MP_OKAY) {
 801d0d6:	697b      	ldr	r3, [r7, #20]
 801d0d8:	2b00      	cmp	r3, #0
 801d0da:	d106      	bne.n	801d0ea <ecc_projective_add_point_safe+0x180>
                        err = mp_montgomery_calc_normalization(R->z, modulus);
 801d0dc:	687b      	ldr	r3, [r7, #4]
 801d0de:	689b      	ldr	r3, [r3, #8]
 801d0e0:	6a39      	ldr	r1, [r7, #32]
 801d0e2:	4618      	mov	r0, r3
 801d0e4:	f009 fd65 	bl	8026bb2 <mp_montgomery_calc_normalization>
 801d0e8:	6178      	str	r0, [r7, #20]
                    }
                    if (err == MP_OKAY) {
 801d0ea:	697b      	ldr	r3, [r7, #20]
 801d0ec:	2b00      	cmp	r3, #0
 801d0ee:	d13a      	bne.n	801d166 <ecc_projective_add_point_safe+0x1fc>
                        err = _ecc_projective_dbl_point(R, R, a, modulus, mp);
 801d0f0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801d0f2:	9300      	str	r3, [sp, #0]
 801d0f4:	6a3b      	ldr	r3, [r7, #32]
 801d0f6:	683a      	ldr	r2, [r7, #0]
 801d0f8:	6879      	ldr	r1, [r7, #4]
 801d0fa:	6878      	ldr	r0, [r7, #4]
 801d0fc:	f7fe f9dd 	bl	801b4ba <_ecc_projective_dbl_point>
 801d100:	6178      	str	r0, [r7, #20]
                if (mp_iszero(B->z)) {
 801d102:	e030      	b.n	801d166 <ecc_projective_add_point_safe+0x1fc>
                    }
                }
                else {
                    err = _ecc_projective_dbl_point(B, R, a, modulus, mp);
 801d104:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801d106:	9300      	str	r3, [sp, #0]
 801d108:	6a3b      	ldr	r3, [r7, #32]
 801d10a:	683a      	ldr	r2, [r7, #0]
 801d10c:	6879      	ldr	r1, [r7, #4]
 801d10e:	68b8      	ldr	r0, [r7, #8]
 801d110:	f7fe f9d3 	bl	801b4ba <_ecc_projective_dbl_point>
 801d114:	6178      	str	r0, [r7, #20]
                if (mp_iszero(B->z)) {
 801d116:	e026      	b.n	801d166 <ecc_projective_add_point_safe+0x1fc>
                }
            }
            /* When only Z zero then result is infinity */
            else {
                err = mp_set(R->x, 0);
 801d118:	687b      	ldr	r3, [r7, #4]
 801d11a:	681b      	ldr	r3, [r3, #0]
 801d11c:	2100      	movs	r1, #0
 801d11e:	4618      	mov	r0, r3
 801d120:	f009 ffc0 	bl	80270a4 <mp_set>
 801d124:	6178      	str	r0, [r7, #20]
                if (err == MP_OKAY)
 801d126:	697b      	ldr	r3, [r7, #20]
 801d128:	2b00      	cmp	r3, #0
 801d12a:	d106      	bne.n	801d13a <ecc_projective_add_point_safe+0x1d0>
                    err = mp_set(R->y, 0);
 801d12c:	687b      	ldr	r3, [r7, #4]
 801d12e:	685b      	ldr	r3, [r3, #4]
 801d130:	2100      	movs	r1, #0
 801d132:	4618      	mov	r0, r3
 801d134:	f009 ffb6 	bl	80270a4 <mp_set>
 801d138:	6178      	str	r0, [r7, #20]
                if (err == MP_OKAY)
 801d13a:	697b      	ldr	r3, [r7, #20]
 801d13c:	2b00      	cmp	r3, #0
 801d13e:	d106      	bne.n	801d14e <ecc_projective_add_point_safe+0x1e4>
                    err = mp_set(R->z, 1);
 801d140:	687b      	ldr	r3, [r7, #4]
 801d142:	689b      	ldr	r3, [r3, #8]
 801d144:	2101      	movs	r1, #1
 801d146:	4618      	mov	r0, r3
 801d148:	f009 ffac 	bl	80270a4 <mp_set>
 801d14c:	6178      	str	r0, [r7, #20]
                if ((err == MP_OKAY) && (infinity != NULL))
 801d14e:	697b      	ldr	r3, [r7, #20]
 801d150:	2b00      	cmp	r3, #0
 801d152:	d109      	bne.n	801d168 <ecc_projective_add_point_safe+0x1fe>
 801d154:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801d156:	2b00      	cmp	r3, #0
 801d158:	d006      	beq.n	801d168 <ecc_projective_add_point_safe+0x1fe>
                    *infinity = 1;
 801d15a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801d15c:	2201      	movs	r2, #1
 801d15e:	601a      	str	r2, [r3, #0]
 801d160:	e002      	b.n	801d168 <ecc_projective_add_point_safe+0x1fe>
        if (mp_cmp(A->y, B->y) == MP_EQ) {
 801d162:	bf00      	nop
 801d164:	e000      	b.n	801d168 <ecc_projective_add_point_safe+0x1fe>
                if (mp_iszero(B->z)) {
 801d166:	bf00      	nop
            }
        }
    }

    return err;
 801d168:	697b      	ldr	r3, [r7, #20]
}
 801d16a:	4618      	mov	r0, r3
 801d16c:	3718      	adds	r7, #24
 801d16e:	46bd      	mov	sp, r7
 801d170:	bd80      	pop	{r7, pc}

0801d172 <ecc_projective_dbl_point_safe>:
 * Double infinity -> infinity.
 * Otherwise do normal double - which can't lead to infinity as odd order.
 */
int ecc_projective_dbl_point_safe(ecc_point *P, ecc_point *R, mp_int* a,
                                  mp_int* modulus, mp_digit mp)
{
 801d172:	b580      	push	{r7, lr}
 801d174:	b088      	sub	sp, #32
 801d176:	af02      	add	r7, sp, #8
 801d178:	60f8      	str	r0, [r7, #12]
 801d17a:	60b9      	str	r1, [r7, #8]
 801d17c:	607a      	str	r2, [r7, #4]
 801d17e:	603b      	str	r3, [r7, #0]
    int err;

    if (mp_iszero(P->x) && mp_iszero(P->y)) {
 801d180:	68fb      	ldr	r3, [r7, #12]
 801d182:	681b      	ldr	r3, [r3, #0]
 801d184:	4618      	mov	r0, r3
 801d186:	f009 fcde 	bl	8026b46 <mp_iszero>
 801d18a:	4603      	mov	r3, r0
 801d18c:	2b00      	cmp	r3, #0
 801d18e:	d00d      	beq.n	801d1ac <ecc_projective_dbl_point_safe+0x3a>
 801d190:	68fb      	ldr	r3, [r7, #12]
 801d192:	685b      	ldr	r3, [r3, #4]
 801d194:	4618      	mov	r0, r3
 801d196:	f009 fcd6 	bl	8026b46 <mp_iszero>
 801d19a:	4603      	mov	r3, r0
 801d19c:	2b00      	cmp	r3, #0
 801d19e:	d005      	beq.n	801d1ac <ecc_projective_dbl_point_safe+0x3a>
        /* P is infinity. */
        err = wc_ecc_copy_point(P, R);
 801d1a0:	68b9      	ldr	r1, [r7, #8]
 801d1a2:	68f8      	ldr	r0, [r7, #12]
 801d1a4:	f7ff fc1f 	bl	801c9e6 <wc_ecc_copy_point>
 801d1a8:	6178      	str	r0, [r7, #20]
 801d1aa:	e02e      	b.n	801d20a <ecc_projective_dbl_point_safe+0x98>
    }
    else {
        err = _ecc_projective_dbl_point(P, R, a, modulus, mp);
 801d1ac:	6a3b      	ldr	r3, [r7, #32]
 801d1ae:	9300      	str	r3, [sp, #0]
 801d1b0:	683b      	ldr	r3, [r7, #0]
 801d1b2:	687a      	ldr	r2, [r7, #4]
 801d1b4:	68b9      	ldr	r1, [r7, #8]
 801d1b6:	68f8      	ldr	r0, [r7, #12]
 801d1b8:	f7fe f97f 	bl	801b4ba <_ecc_projective_dbl_point>
 801d1bc:	6178      	str	r0, [r7, #20]
        if ((err == MP_OKAY) && mp_iszero(R->z)) {
 801d1be:	697b      	ldr	r3, [r7, #20]
 801d1c0:	2b00      	cmp	r3, #0
 801d1c2:	d122      	bne.n	801d20a <ecc_projective_dbl_point_safe+0x98>
 801d1c4:	68bb      	ldr	r3, [r7, #8]
 801d1c6:	689b      	ldr	r3, [r3, #8]
 801d1c8:	4618      	mov	r0, r3
 801d1ca:	f009 fcbc 	bl	8026b46 <mp_iszero>
 801d1ce:	4603      	mov	r3, r0
 801d1d0:	2b00      	cmp	r3, #0
 801d1d2:	d01a      	beq.n	801d20a <ecc_projective_dbl_point_safe+0x98>
           err = mp_set(R->x, 0);
 801d1d4:	68bb      	ldr	r3, [r7, #8]
 801d1d6:	681b      	ldr	r3, [r3, #0]
 801d1d8:	2100      	movs	r1, #0
 801d1da:	4618      	mov	r0, r3
 801d1dc:	f009 ff62 	bl	80270a4 <mp_set>
 801d1e0:	6178      	str	r0, [r7, #20]
           if (err == MP_OKAY)
 801d1e2:	697b      	ldr	r3, [r7, #20]
 801d1e4:	2b00      	cmp	r3, #0
 801d1e6:	d106      	bne.n	801d1f6 <ecc_projective_dbl_point_safe+0x84>
               err = mp_set(R->y, 0);
 801d1e8:	68bb      	ldr	r3, [r7, #8]
 801d1ea:	685b      	ldr	r3, [r3, #4]
 801d1ec:	2100      	movs	r1, #0
 801d1ee:	4618      	mov	r0, r3
 801d1f0:	f009 ff58 	bl	80270a4 <mp_set>
 801d1f4:	6178      	str	r0, [r7, #20]
           if (err == MP_OKAY)
 801d1f6:	697b      	ldr	r3, [r7, #20]
 801d1f8:	2b00      	cmp	r3, #0
 801d1fa:	d106      	bne.n	801d20a <ecc_projective_dbl_point_safe+0x98>
               err = mp_set(R->z, 1);
 801d1fc:	68bb      	ldr	r3, [r7, #8]
 801d1fe:	689b      	ldr	r3, [r3, #8]
 801d200:	2101      	movs	r1, #1
 801d202:	4618      	mov	r0, r3
 801d204:	f009 ff4e 	bl	80270a4 <mp_set>
 801d208:	6178      	str	r0, [r7, #20]
        }
    }

    return err;
 801d20a:	697b      	ldr	r3, [r7, #20]
}
 801d20c:	4618      	mov	r0, r3
 801d20e:	3718      	adds	r7, #24
 801d210:	46bd      	mov	sp, r7
 801d212:	bd80      	pop	{r7, pc}

0801d214 <ecc_mont_norm_points>:
    !defined(WOLFSSL_KCAPI_ECC) && !defined(WOLF_CRYPTO_CB_ONLY_ECC)
#ifdef ECC_SHAMIR

static int ecc_mont_norm_points(ecc_point* A, ecc_point* Am, ecc_point* B,
    ecc_point* Bm, mp_int* modulus, void* heap)
{
 801d214:	b580      	push	{r7, lr}
 801d216:	b088      	sub	sp, #32
 801d218:	af00      	add	r7, sp, #0
 801d21a:	60f8      	str	r0, [r7, #12]
 801d21c:	60b9      	str	r1, [r7, #8]
 801d21e:	607a      	str	r2, [r7, #4]
 801d220:	603b      	str	r3, [r7, #0]
    int err = MP_OKAY;
 801d222:	2300      	movs	r3, #0
 801d224:	61fb      	str	r3, [r7, #28]
    DECL_MP_INT_SIZE_DYN(mu, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801d226:	2300      	movs	r3, #0
 801d228:	61bb      	str	r3, [r7, #24]

    (void)heap;

    NEW_MP_INT_SIZE(mu, mp_bitsused(modulus), heap, DYNAMIC_TYPE_ECC);
 801d22a:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801d22e:	f001 fc2b 	bl	801ea88 <wolfSSL_Malloc>
 801d232:	61b8      	str	r0, [r7, #24]
 801d234:	69bb      	ldr	r3, [r7, #24]
 801d236:	2b00      	cmp	r3, #0
 801d238:	d005      	beq.n	801d246 <ecc_mont_norm_points+0x32>
 801d23a:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801d23e:	2100      	movs	r1, #0
 801d240:	69b8      	ldr	r0, [r7, #24]
 801d242:	f00b f941 	bl	80284c8 <memset>
#ifdef MP_INT_SIZE_CHECK_NULL
    if (mu == NULL)
 801d246:	69bb      	ldr	r3, [r7, #24]
 801d248:	2b00      	cmp	r3, #0
 801d24a:	d102      	bne.n	801d252 <ecc_mont_norm_points+0x3e>
       err = MEMORY_E;
 801d24c:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801d250:	61fb      	str	r3, [r7, #28]
#endif
    if (err == MP_OKAY) {
 801d252:	69fb      	ldr	r3, [r7, #28]
 801d254:	2b00      	cmp	r3, #0
 801d256:	d103      	bne.n	801d260 <ecc_mont_norm_points+0x4c>
        err = INIT_MP_INT_SIZE(mu, mp_bitsused(modulus));
 801d258:	69b8      	ldr	r0, [r7, #24]
 801d25a:	f009 fa1a 	bl	8026692 <mp_init>
 801d25e:	61f8      	str	r0, [r7, #28]
    }
    if (err == MP_OKAY) {
 801d260:	69fb      	ldr	r3, [r7, #28]
 801d262:	2b00      	cmp	r3, #0
 801d264:	d14f      	bne.n	801d306 <ecc_mont_norm_points+0xf2>
        err = mp_montgomery_calc_normalization(mu, modulus);
 801d266:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 801d268:	69b8      	ldr	r0, [r7, #24]
 801d26a:	f009 fca2 	bl	8026bb2 <mp_montgomery_calc_normalization>
 801d26e:	61f8      	str	r0, [r7, #28]

        if (err == MP_OKAY) {
 801d270:	69fb      	ldr	r3, [r7, #28]
 801d272:	2b00      	cmp	r3, #0
 801d274:	d108      	bne.n	801d288 <ecc_mont_norm_points+0x74>
            /* copy ones ... */
            err = mp_mulmod(A->x, mu, modulus, Am->x);
 801d276:	68fb      	ldr	r3, [r7, #12]
 801d278:	6818      	ldr	r0, [r3, #0]
 801d27a:	68bb      	ldr	r3, [r7, #8]
 801d27c:	681b      	ldr	r3, [r3, #0]
 801d27e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801d280:	69b9      	ldr	r1, [r7, #24]
 801d282:	f009 fb0a 	bl	802689a <mp_mulmod>
 801d286:	61f8      	str	r0, [r7, #28]
        }

        if (err == MP_OKAY)
 801d288:	69fb      	ldr	r3, [r7, #28]
 801d28a:	2b00      	cmp	r3, #0
 801d28c:	d108      	bne.n	801d2a0 <ecc_mont_norm_points+0x8c>
            err = mp_mulmod(A->y, mu, modulus, Am->y);
 801d28e:	68fb      	ldr	r3, [r7, #12]
 801d290:	6858      	ldr	r0, [r3, #4]
 801d292:	68bb      	ldr	r3, [r7, #8]
 801d294:	685b      	ldr	r3, [r3, #4]
 801d296:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801d298:	69b9      	ldr	r1, [r7, #24]
 801d29a:	f009 fafe 	bl	802689a <mp_mulmod>
 801d29e:	61f8      	str	r0, [r7, #28]
        if (err == MP_OKAY)
 801d2a0:	69fb      	ldr	r3, [r7, #28]
 801d2a2:	2b00      	cmp	r3, #0
 801d2a4:	d108      	bne.n	801d2b8 <ecc_mont_norm_points+0xa4>
            err = mp_mulmod(A->z, mu, modulus, Am->z);
 801d2a6:	68fb      	ldr	r3, [r7, #12]
 801d2a8:	6898      	ldr	r0, [r3, #8]
 801d2aa:	68bb      	ldr	r3, [r7, #8]
 801d2ac:	689b      	ldr	r3, [r3, #8]
 801d2ae:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801d2b0:	69b9      	ldr	r1, [r7, #24]
 801d2b2:	f009 faf2 	bl	802689a <mp_mulmod>
 801d2b6:	61f8      	str	r0, [r7, #28]

        if (err == MP_OKAY)
 801d2b8:	69fb      	ldr	r3, [r7, #28]
 801d2ba:	2b00      	cmp	r3, #0
 801d2bc:	d108      	bne.n	801d2d0 <ecc_mont_norm_points+0xbc>
            err = mp_mulmod(B->x, mu, modulus, Bm->x);
 801d2be:	687b      	ldr	r3, [r7, #4]
 801d2c0:	6818      	ldr	r0, [r3, #0]
 801d2c2:	683b      	ldr	r3, [r7, #0]
 801d2c4:	681b      	ldr	r3, [r3, #0]
 801d2c6:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801d2c8:	69b9      	ldr	r1, [r7, #24]
 801d2ca:	f009 fae6 	bl	802689a <mp_mulmod>
 801d2ce:	61f8      	str	r0, [r7, #28]
        if (err == MP_OKAY)
 801d2d0:	69fb      	ldr	r3, [r7, #28]
 801d2d2:	2b00      	cmp	r3, #0
 801d2d4:	d108      	bne.n	801d2e8 <ecc_mont_norm_points+0xd4>
            err = mp_mulmod(B->y, mu, modulus, Bm->y);
 801d2d6:	687b      	ldr	r3, [r7, #4]
 801d2d8:	6858      	ldr	r0, [r3, #4]
 801d2da:	683b      	ldr	r3, [r7, #0]
 801d2dc:	685b      	ldr	r3, [r3, #4]
 801d2de:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801d2e0:	69b9      	ldr	r1, [r7, #24]
 801d2e2:	f009 fada 	bl	802689a <mp_mulmod>
 801d2e6:	61f8      	str	r0, [r7, #28]
        if (err == MP_OKAY)
 801d2e8:	69fb      	ldr	r3, [r7, #28]
 801d2ea:	2b00      	cmp	r3, #0
 801d2ec:	d108      	bne.n	801d300 <ecc_mont_norm_points+0xec>
            err = mp_mulmod(B->z, mu, modulus, Bm->z);
 801d2ee:	687b      	ldr	r3, [r7, #4]
 801d2f0:	6898      	ldr	r0, [r3, #8]
 801d2f2:	683b      	ldr	r3, [r7, #0]
 801d2f4:	689b      	ldr	r3, [r3, #8]
 801d2f6:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801d2f8:	69b9      	ldr	r1, [r7, #24]
 801d2fa:	f009 face 	bl	802689a <mp_mulmod>
 801d2fe:	61f8      	str	r0, [r7, #28]

        /* done with mu */
        mp_clear(mu);
 801d300:	69b8      	ldr	r0, [r7, #24]
 801d302:	f009 fa50 	bl	80267a6 <mp_clear>
    }

    FREE_MP_INT_SIZE(mu, heap, DYNAMIC_TYPE_ECC);
 801d306:	69bb      	ldr	r3, [r7, #24]
 801d308:	617b      	str	r3, [r7, #20]
 801d30a:	697b      	ldr	r3, [r7, #20]
 801d30c:	2b00      	cmp	r3, #0
 801d30e:	d002      	beq.n	801d316 <ecc_mont_norm_points+0x102>
 801d310:	6978      	ldr	r0, [r7, #20]
 801d312:	f001 fbd5 	bl	801eac0 <wolfSSL_Free>

    return err;
 801d316:	69fb      	ldr	r3, [r7, #28]
}
 801d318:	4618      	mov	r0, r3
 801d31a:	3720      	adds	r7, #32
 801d31c:	46bd      	mov	sp, r7
 801d31e:	bd80      	pop	{r7, pc}

0801d320 <ecc_mul2add>:
int ecc_mul2add(ecc_point* A, mp_int* kA,
                    ecc_point* B, mp_int* kB,
                    ecc_point* C, mp_int* a, mp_int* modulus,
                    void* heap)
#endif
{
 801d320:	b590      	push	{r4, r7, lr}
 801d322:	b0a1      	sub	sp, #132	@ 0x84
 801d324:	af04      	add	r7, sp, #16
 801d326:	60f8      	str	r0, [r7, #12]
 801d328:	60b9      	str	r1, [r7, #8]
 801d32a:	607a      	str	r2, [r7, #4]
 801d32c:	603b      	str	r3, [r7, #0]
#ifdef WOLFSSL_SMALL_STACK_CACHE
  ecc_key        *key = NULL;
#endif
#ifdef WOLFSSL_SMALL_STACK
  ecc_point**    precomp = NULL;
 801d32e:	2300      	movs	r3, #0
 801d330:	657b      	str	r3, [r7, #84]	@ 0x54
  unsigned int  bitbufA, bitbufB, lenA, lenB, len, nA, nB, nibble;
#ifdef WOLFSSL_NO_MALLOC
  unsigned char tA[ECC_BUFSIZE];
  unsigned char tB[ECC_BUFSIZE];
#else
  unsigned char* tA = NULL;
 801d332:	2300      	movs	r3, #0
 801d334:	653b      	str	r3, [r7, #80]	@ 0x50
  unsigned char* tB = NULL;
 801d336:	2300      	movs	r3, #0
 801d338:	64fb      	str	r3, [r7, #76]	@ 0x4c
#endif
  int            err = MP_OKAY, first, x, y;
 801d33a:	2300      	movs	r3, #0
 801d33c:	663b      	str	r3, [r7, #96]	@ 0x60
  mp_digit       mp = 0;
 801d33e:	2300      	movs	r3, #0
 801d340:	617b      	str	r3, [r7, #20]

  /* argchks */
  if (A == NULL || kA == NULL || B == NULL || kB == NULL || C == NULL ||
 801d342:	68fb      	ldr	r3, [r7, #12]
 801d344:	2b00      	cmp	r3, #0
 801d346:	d010      	beq.n	801d36a <ecc_mul2add+0x4a>
 801d348:	68bb      	ldr	r3, [r7, #8]
 801d34a:	2b00      	cmp	r3, #0
 801d34c:	d00d      	beq.n	801d36a <ecc_mul2add+0x4a>
 801d34e:	687b      	ldr	r3, [r7, #4]
 801d350:	2b00      	cmp	r3, #0
 801d352:	d00a      	beq.n	801d36a <ecc_mul2add+0x4a>
 801d354:	683b      	ldr	r3, [r7, #0]
 801d356:	2b00      	cmp	r3, #0
 801d358:	d007      	beq.n	801d36a <ecc_mul2add+0x4a>
 801d35a:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801d35e:	2b00      	cmp	r3, #0
 801d360:	d003      	beq.n	801d36a <ecc_mul2add+0x4a>
 801d362:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801d366:	2b00      	cmp	r3, #0
 801d368:	d102      	bne.n	801d370 <ecc_mul2add+0x50>
                                                         modulus == NULL) {
     return ECC_BAD_ARG_E;
 801d36a:	f06f 03a9 	mvn.w	r3, #169	@ 0xa9
 801d36e:	e261      	b.n	801d834 <ecc_mul2add+0x514>
  }

#ifndef WOLFSSL_NO_MALLOC
  /* allocate memory */
  tA = (unsigned char*)XMALLOC(ECC_BUFSIZE, heap, DYNAMIC_TYPE_ECC_BUFFER);
 801d370:	f240 1001 	movw	r0, #257	@ 0x101
 801d374:	f001 fb88 	bl	801ea88 <wolfSSL_Malloc>
 801d378:	6538      	str	r0, [r7, #80]	@ 0x50
  if (tA == NULL) {
 801d37a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801d37c:	2b00      	cmp	r3, #0
 801d37e:	d102      	bne.n	801d386 <ecc_mul2add+0x66>
     return MP_MEM;
 801d380:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 801d384:	e256      	b.n	801d834 <ecc_mul2add+0x514>
  }
  tB = (unsigned char*)XMALLOC(ECC_BUFSIZE, heap, DYNAMIC_TYPE_ECC_BUFFER);
 801d386:	f240 1001 	movw	r0, #257	@ 0x101
 801d38a:	f001 fb7d 	bl	801ea88 <wolfSSL_Malloc>
 801d38e:	64f8      	str	r0, [r7, #76]	@ 0x4c
  if (tB == NULL) {
 801d390:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801d392:	2b00      	cmp	r3, #0
 801d394:	d10a      	bne.n	801d3ac <ecc_mul2add+0x8c>
     XFREE(tA, heap, DYNAMIC_TYPE_ECC_BUFFER);
 801d396:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801d398:	61fb      	str	r3, [r7, #28]
 801d39a:	69fb      	ldr	r3, [r7, #28]
 801d39c:	2b00      	cmp	r3, #0
 801d39e:	d002      	beq.n	801d3a6 <ecc_mul2add+0x86>
 801d3a0:	69f8      	ldr	r0, [r7, #28]
 801d3a2:	f001 fb8d 	bl	801eac0 <wolfSSL_Free>
     return MP_MEM;
 801d3a6:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 801d3aa:	e243      	b.n	801d834 <ecc_mul2add+0x514>
     XFREE(tA, heap, DYNAMIC_TYPE_ECC_BUFFER);
     return MP_MEM;
  }
#endif
#ifdef WOLFSSL_SMALL_STACK
  precomp = (ecc_point**)XMALLOC(sizeof(ecc_point*) * SHAMIR_PRECOMP_SZ, heap,
 801d3ac:	2040      	movs	r0, #64	@ 0x40
 801d3ae:	f001 fb6b 	bl	801ea88 <wolfSSL_Malloc>
 801d3b2:	6578      	str	r0, [r7, #84]	@ 0x54
                                                       DYNAMIC_TYPE_ECC_BUFFER);
  if (precomp == NULL) {
 801d3b4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d3b6:	2b00      	cmp	r3, #0
 801d3b8:	d112      	bne.n	801d3e0 <ecc_mul2add+0xc0>
     XFREE(tB, heap, DYNAMIC_TYPE_ECC_BUFFER);
 801d3ba:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801d3bc:	627b      	str	r3, [r7, #36]	@ 0x24
 801d3be:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801d3c0:	2b00      	cmp	r3, #0
 801d3c2:	d002      	beq.n	801d3ca <ecc_mul2add+0xaa>
 801d3c4:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 801d3c6:	f001 fb7b 	bl	801eac0 <wolfSSL_Free>
     XFREE(tA, heap, DYNAMIC_TYPE_ECC_BUFFER);
 801d3ca:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801d3cc:	623b      	str	r3, [r7, #32]
 801d3ce:	6a3b      	ldr	r3, [r7, #32]
 801d3d0:	2b00      	cmp	r3, #0
 801d3d2:	d002      	beq.n	801d3da <ecc_mul2add+0xba>
 801d3d4:	6a38      	ldr	r0, [r7, #32]
 801d3d6:	f001 fb73 	bl	801eac0 <wolfSSL_Free>
  #ifdef WOLFSSL_SMALL_STACK_CACHE
     XFREE(key, heap, DYNAMIC_TYPE_ECC_BUFFER);
  #endif
     return MP_MEM;
 801d3da:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 801d3de:	e229      	b.n	801d834 <ecc_mul2add+0x514>
  }
  C->key = key;
#endif /* WOLFSSL_SMALL_STACK_CACHE */

  /* init variables */
  XMEMSET(tA, 0, ECC_BUFSIZE);
 801d3e0:	f240 1201 	movw	r2, #257	@ 0x101
 801d3e4:	2100      	movs	r1, #0
 801d3e6:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 801d3e8:	f00b f86e 	bl	80284c8 <memset>
  XMEMSET(tB, 0, ECC_BUFSIZE);
 801d3ec:	f240 1201 	movw	r2, #257	@ 0x101
 801d3f0:	2100      	movs	r1, #0
 801d3f2:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 801d3f4:	f00b f868 	bl	80284c8 <memset>
#ifndef WOLFSSL_SMALL_STACK
  XMEMSET(precomp, 0, sizeof(precomp));
#else
  XMEMSET(precomp, 0, sizeof(ecc_point*) * SHAMIR_PRECOMP_SZ);
 801d3f8:	2240      	movs	r2, #64	@ 0x40
 801d3fa:	2100      	movs	r1, #0
 801d3fc:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801d3fe:	f00b f863 	bl	80284c8 <memset>
  wc_MemZero_Add("ecc_mul2add tA", tA, ECC_BUFSIZE);
  wc_MemZero_Add("ecc_mul2add tB", tB, ECC_BUFSIZE);
#endif

  /* get sizes */
  lenA = (unsigned int)mp_unsigned_bin_size(kA);
 801d402:	68b8      	ldr	r0, [r7, #8]
 801d404:	f009 faf4 	bl	80269f0 <mp_unsigned_bin_size>
 801d408:	4603      	mov	r3, r0
 801d40a:	64bb      	str	r3, [r7, #72]	@ 0x48
  lenB = (unsigned int)mp_unsigned_bin_size(kB);
 801d40c:	6838      	ldr	r0, [r7, #0]
 801d40e:	f009 faef 	bl	80269f0 <mp_unsigned_bin_size>
 801d412:	4603      	mov	r3, r0
 801d414:	647b      	str	r3, [r7, #68]	@ 0x44
  len  = MAX(lenA, lenB);
 801d416:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 801d418:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801d41a:	4293      	cmp	r3, r2
 801d41c:	bf38      	it	cc
 801d41e:	4613      	movcc	r3, r2
 801d420:	643b      	str	r3, [r7, #64]	@ 0x40

  /* sanity check */
  if ((lenA > ECC_BUFSIZE) || (lenB > ECC_BUFSIZE)) {
 801d422:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801d424:	f5b3 7f81 	cmp.w	r3, #258	@ 0x102
 801d428:	d203      	bcs.n	801d432 <ecc_mul2add+0x112>
 801d42a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801d42c:	f5b3 7f81 	cmp.w	r3, #258	@ 0x102
 801d430:	d302      	bcc.n	801d438 <ecc_mul2add+0x118>
    err = BAD_FUNC_ARG;
 801d432:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801d436:	663b      	str	r3, [r7, #96]	@ 0x60
  }

  if (err == MP_OKAY) {
 801d438:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d43a:	2b00      	cmp	r3, #0
 801d43c:	d131      	bne.n	801d4a2 <ecc_mul2add+0x182>
    /* extract and justify kA */
    err = mp_to_unsigned_bin(kA, (len - lenA) + tA);
 801d43e:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 801d440:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801d442:	1ad3      	subs	r3, r2, r3
 801d444:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 801d446:	4413      	add	r3, r2
 801d448:	4619      	mov	r1, r3
 801d44a:	68b8      	ldr	r0, [r7, #8]
 801d44c:	f009 fadc 	bl	8026a08 <mp_to_unsigned_bin>
 801d450:	6638      	str	r0, [r7, #96]	@ 0x60

    /* extract and justify kB */
    if (err == MP_OKAY)
 801d452:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d454:	2b00      	cmp	r3, #0
 801d456:	d109      	bne.n	801d46c <ecc_mul2add+0x14c>
        err = mp_to_unsigned_bin(kB, (len - lenB) + tB);
 801d458:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 801d45a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801d45c:	1ad3      	subs	r3, r2, r3
 801d45e:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 801d460:	4413      	add	r3, r2
 801d462:	4619      	mov	r1, r3
 801d464:	6838      	ldr	r0, [r7, #0]
 801d466:	f009 facf 	bl	8026a08 <mp_to_unsigned_bin>
 801d46a:	6638      	str	r0, [r7, #96]	@ 0x60

    /* allocate the table */
    if (err == MP_OKAY) {
 801d46c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d46e:	2b00      	cmp	r3, #0
 801d470:	d117      	bne.n	801d4a2 <ecc_mul2add+0x182>
        for (x = 0; x < SHAMIR_PRECOMP_SZ; x++) {
 801d472:	2300      	movs	r3, #0
 801d474:	65fb      	str	r3, [r7, #92]	@ 0x5c
 801d476:	e00f      	b.n	801d498 <ecc_mul2add+0x178>
        #ifdef WOLFSSL_NO_MALLOC
            precomp[x] = &lcl_precomp[x];
        #endif
            err = wc_ecc_new_point_ex(&precomp[x], heap);
 801d478:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d47a:	009b      	lsls	r3, r3, #2
 801d47c:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801d47e:	4413      	add	r3, r2
 801d480:	f8d7 108c 	ldr.w	r1, [r7, #140]	@ 0x8c
 801d484:	4618      	mov	r0, r3
 801d486:	f7ff fa22 	bl	801c8ce <wc_ecc_new_point_ex>
 801d48a:	6638      	str	r0, [r7, #96]	@ 0x60
            if (err != MP_OKAY)
 801d48c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d48e:	2b00      	cmp	r3, #0
 801d490:	d106      	bne.n	801d4a0 <ecc_mul2add+0x180>
        for (x = 0; x < SHAMIR_PRECOMP_SZ; x++) {
 801d492:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d494:	3301      	adds	r3, #1
 801d496:	65fb      	str	r3, [r7, #92]	@ 0x5c
 801d498:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d49a:	2b0f      	cmp	r3, #15
 801d49c:	ddec      	ble.n	801d478 <ecc_mul2add+0x158>
 801d49e:	e000      	b.n	801d4a2 <ecc_mul2add+0x182>
                break;
 801d4a0:	bf00      	nop
        #endif
        }
    }
  }

  if (err == MP_OKAY)
 801d4a2:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d4a4:	2b00      	cmp	r3, #0
 801d4a6:	d107      	bne.n	801d4b8 <ecc_mul2add+0x198>
    /* init montgomery reduction */
    err = mp_montgomery_setup(modulus, &mp);
 801d4a8:	f107 0314 	add.w	r3, r7, #20
 801d4ac:	4619      	mov	r1, r3
 801d4ae:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801d4b2:	f009 fdcb 	bl	802704c <mp_montgomery_setup>
 801d4b6:	6638      	str	r0, [r7, #96]	@ 0x60

  if (err == MP_OKAY) {
 801d4b8:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d4ba:	2b00      	cmp	r3, #0
 801d4bc:	d111      	bne.n	801d4e2 <ecc_mul2add+0x1c2>
    err = ecc_mont_norm_points(A, precomp[1], B, precomp[1<<2], modulus, heap);
 801d4be:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d4c0:	3304      	adds	r3, #4
 801d4c2:	6819      	ldr	r1, [r3, #0]
 801d4c4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d4c6:	3310      	adds	r3, #16
 801d4c8:	681a      	ldr	r2, [r3, #0]
 801d4ca:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801d4ce:	9301      	str	r3, [sp, #4]
 801d4d0:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801d4d4:	9300      	str	r3, [sp, #0]
 801d4d6:	4613      	mov	r3, r2
 801d4d8:	687a      	ldr	r2, [r7, #4]
 801d4da:	68f8      	ldr	r0, [r7, #12]
 801d4dc:	f7ff fe9a 	bl	801d214 <ecc_mont_norm_points>
 801d4e0:	6638      	str	r0, [r7, #96]	@ 0x60
  }

  if (err == MP_OKAY) {
 801d4e2:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d4e4:	2b00      	cmp	r3, #0
 801d4e6:	d10e      	bne.n	801d506 <ecc_mul2add+0x1e6>
    /* precomp [i,0](A + B) table */
    err = ecc_projective_dbl_point_safe(precomp[1], precomp[2], a, modulus, mp);
 801d4e8:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d4ea:	3304      	adds	r3, #4
 801d4ec:	6818      	ldr	r0, [r3, #0]
 801d4ee:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d4f0:	3308      	adds	r3, #8
 801d4f2:	6819      	ldr	r1, [r3, #0]
 801d4f4:	697b      	ldr	r3, [r7, #20]
 801d4f6:	9300      	str	r3, [sp, #0]
 801d4f8:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801d4fc:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 801d500:	f7ff fe37 	bl	801d172 <ecc_projective_dbl_point_safe>
 801d504:	6638      	str	r0, [r7, #96]	@ 0x60
  }
  if (err == MP_OKAY) {
 801d506:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d508:	2b00      	cmp	r3, #0
 801d50a:	d114      	bne.n	801d536 <ecc_mul2add+0x216>
    err = ecc_projective_add_point_safe(precomp[1], precomp[2], precomp[3],
 801d50c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d50e:	3304      	adds	r3, #4
 801d510:	6818      	ldr	r0, [r3, #0]
 801d512:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d514:	3308      	adds	r3, #8
 801d516:	6819      	ldr	r1, [r3, #0]
 801d518:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d51a:	330c      	adds	r3, #12
 801d51c:	681a      	ldr	r2, [r3, #0]
 801d51e:	697b      	ldr	r3, [r7, #20]
 801d520:	2400      	movs	r4, #0
 801d522:	9402      	str	r4, [sp, #8]
 801d524:	9301      	str	r3, [sp, #4]
 801d526:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801d52a:	9300      	str	r3, [sp, #0]
 801d52c:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801d530:	f7ff fd1b 	bl	801cf6a <ecc_projective_add_point_safe>
 801d534:	6638      	str	r0, [r7, #96]	@ 0x60
                                                          a, modulus, mp, NULL);
  }

  if (err == MP_OKAY) {
 801d536:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d538:	2b00      	cmp	r3, #0
 801d53a:	d10e      	bne.n	801d55a <ecc_mul2add+0x23a>
    /* precomp [0,i](A + B) table */
    err = ecc_projective_dbl_point_safe(precomp[4], precomp[8], a, modulus, mp);
 801d53c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d53e:	3310      	adds	r3, #16
 801d540:	6818      	ldr	r0, [r3, #0]
 801d542:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d544:	3320      	adds	r3, #32
 801d546:	6819      	ldr	r1, [r3, #0]
 801d548:	697b      	ldr	r3, [r7, #20]
 801d54a:	9300      	str	r3, [sp, #0]
 801d54c:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801d550:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 801d554:	f7ff fe0d 	bl	801d172 <ecc_projective_dbl_point_safe>
 801d558:	6638      	str	r0, [r7, #96]	@ 0x60
  }
  if (err == MP_OKAY) {
 801d55a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d55c:	2b00      	cmp	r3, #0
 801d55e:	d114      	bne.n	801d58a <ecc_mul2add+0x26a>
    err = ecc_projective_add_point_safe(precomp[4], precomp[8], precomp[12], a,
 801d560:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d562:	3310      	adds	r3, #16
 801d564:	6818      	ldr	r0, [r3, #0]
 801d566:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d568:	3320      	adds	r3, #32
 801d56a:	6819      	ldr	r1, [r3, #0]
 801d56c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d56e:	3330      	adds	r3, #48	@ 0x30
 801d570:	681a      	ldr	r2, [r3, #0]
 801d572:	697b      	ldr	r3, [r7, #20]
 801d574:	2400      	movs	r4, #0
 801d576:	9402      	str	r4, [sp, #8]
 801d578:	9301      	str	r3, [sp, #4]
 801d57a:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801d57e:	9300      	str	r3, [sp, #0]
 801d580:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801d584:	f7ff fcf1 	bl	801cf6a <ecc_projective_add_point_safe>
 801d588:	6638      	str	r0, [r7, #96]	@ 0x60
                                                             modulus, mp, NULL);
  }

  if (err == MP_OKAY) {
 801d58a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d58c:	2b00      	cmp	r3, #0
 801d58e:	d132      	bne.n	801d5f6 <ecc_mul2add+0x2d6>
    /* precomp [i,j](A + B) table (i != 0, j != 0) */
    for (x = 1; x < 4; x++) {
 801d590:	2301      	movs	r3, #1
 801d592:	65fb      	str	r3, [r7, #92]	@ 0x5c
 801d594:	e02c      	b.n	801d5f0 <ecc_mul2add+0x2d0>
      for (y = 1; y < 4; y++) {
 801d596:	2301      	movs	r3, #1
 801d598:	65bb      	str	r3, [r7, #88]	@ 0x58
 801d59a:	e023      	b.n	801d5e4 <ecc_mul2add+0x2c4>
        if (err == MP_OKAY) {
 801d59c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d59e:	2b00      	cmp	r3, #0
 801d5a0:	d11d      	bne.n	801d5de <ecc_mul2add+0x2be>
          err = ecc_projective_add_point_safe(precomp[x], precomp[(y<<2)],
 801d5a2:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d5a4:	009b      	lsls	r3, r3, #2
 801d5a6:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801d5a8:	4413      	add	r3, r2
 801d5aa:	6818      	ldr	r0, [r3, #0]
 801d5ac:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801d5ae:	011b      	lsls	r3, r3, #4
 801d5b0:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801d5b2:	4413      	add	r3, r2
 801d5b4:	6819      	ldr	r1, [r3, #0]
                                                  precomp[x+(y<<2)], a, modulus,
 801d5b6:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801d5b8:	009a      	lsls	r2, r3, #2
 801d5ba:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d5bc:	4413      	add	r3, r2
 801d5be:	009b      	lsls	r3, r3, #2
 801d5c0:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801d5c2:	4413      	add	r3, r2
          err = ecc_projective_add_point_safe(precomp[x], precomp[(y<<2)],
 801d5c4:	681a      	ldr	r2, [r3, #0]
 801d5c6:	697b      	ldr	r3, [r7, #20]
 801d5c8:	2400      	movs	r4, #0
 801d5ca:	9402      	str	r4, [sp, #8]
 801d5cc:	9301      	str	r3, [sp, #4]
 801d5ce:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801d5d2:	9300      	str	r3, [sp, #0]
 801d5d4:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801d5d8:	f7ff fcc7 	bl	801cf6a <ecc_projective_add_point_safe>
 801d5dc:	6638      	str	r0, [r7, #96]	@ 0x60
      for (y = 1; y < 4; y++) {
 801d5de:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801d5e0:	3301      	adds	r3, #1
 801d5e2:	65bb      	str	r3, [r7, #88]	@ 0x58
 801d5e4:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801d5e6:	2b03      	cmp	r3, #3
 801d5e8:	ddd8      	ble.n	801d59c <ecc_mul2add+0x27c>
    for (x = 1; x < 4; x++) {
 801d5ea:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d5ec:	3301      	adds	r3, #1
 801d5ee:	65fb      	str	r3, [r7, #92]	@ 0x5c
 801d5f0:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d5f2:	2b03      	cmp	r3, #3
 801d5f4:	ddcf      	ble.n	801d596 <ecc_mul2add+0x276>
        }
      }
    }
  }

  if (err == MP_OKAY) {
 801d5f6:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d5f8:	2b00      	cmp	r3, #0
 801d5fa:	f040 80d9 	bne.w	801d7b0 <ecc_mul2add+0x490>
    nibble  = 3;
 801d5fe:	2303      	movs	r3, #3
 801d600:	667b      	str	r3, [r7, #100]	@ 0x64
    first   = 1;
 801d602:	2301      	movs	r3, #1
 801d604:	61bb      	str	r3, [r7, #24]
    bitbufA = tA[0];
 801d606:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801d608:	781b      	ldrb	r3, [r3, #0]
 801d60a:	66fb      	str	r3, [r7, #108]	@ 0x6c
    bitbufB = tB[0];
 801d60c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801d60e:	781b      	ldrb	r3, [r3, #0]
 801d610:	66bb      	str	r3, [r7, #104]	@ 0x68

    /* for every byte of the multiplicands */
    for (x = 0; x < (int)len || nibble != 3; ) {
 801d612:	2300      	movs	r3, #0
 801d614:	65fb      	str	r3, [r7, #92]	@ 0x5c
 801d616:	e0ba      	b.n	801d78e <ecc_mul2add+0x46e>
        /* grab a nibble */
        if (++nibble == 4) {
 801d618:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801d61a:	3301      	adds	r3, #1
 801d61c:	667b      	str	r3, [r7, #100]	@ 0x64
 801d61e:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801d620:	2b04      	cmp	r3, #4
 801d622:	d113      	bne.n	801d64c <ecc_mul2add+0x32c>
            if (x == (int)len) break;
 801d624:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801d626:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801d628:	429a      	cmp	r2, r3
 801d62a:	f000 80ba 	beq.w	801d7a2 <ecc_mul2add+0x482>
            bitbufA = tA[x];
 801d62e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d630:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 801d632:	4413      	add	r3, r2
 801d634:	781b      	ldrb	r3, [r3, #0]
 801d636:	66fb      	str	r3, [r7, #108]	@ 0x6c
            bitbufB = tB[x];
 801d638:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d63a:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 801d63c:	4413      	add	r3, r2
 801d63e:	781b      	ldrb	r3, [r3, #0]
 801d640:	66bb      	str	r3, [r7, #104]	@ 0x68
            nibble  = 0;
 801d642:	2300      	movs	r3, #0
 801d644:	667b      	str	r3, [r7, #100]	@ 0x64
            x++;
 801d646:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d648:	3301      	adds	r3, #1
 801d64a:	65fb      	str	r3, [r7, #92]	@ 0x5c
        }

        /* extract two bits from both, shift/update */
        nA = (bitbufA >> 6) & 0x03;
 801d64c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801d64e:	099b      	lsrs	r3, r3, #6
 801d650:	f003 0303 	and.w	r3, r3, #3
 801d654:	63fb      	str	r3, [r7, #60]	@ 0x3c
        nB = (bitbufB >> 6) & 0x03;
 801d656:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801d658:	099b      	lsrs	r3, r3, #6
 801d65a:	f003 0303 	and.w	r3, r3, #3
 801d65e:	63bb      	str	r3, [r7, #56]	@ 0x38
        bitbufA = (bitbufA << 2) & 0xFF;
 801d660:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801d662:	009b      	lsls	r3, r3, #2
 801d664:	b2db      	uxtb	r3, r3
 801d666:	66fb      	str	r3, [r7, #108]	@ 0x6c
        bitbufB = (bitbufB << 2) & 0xFF;
 801d668:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801d66a:	009b      	lsls	r3, r3, #2
 801d66c:	b2db      	uxtb	r3, r3
 801d66e:	66bb      	str	r3, [r7, #104]	@ 0x68

        /* if both zero, if first, continue */
        if ((nA == 0) && (nB == 0) && (first == 1)) {
 801d670:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801d672:	2b00      	cmp	r3, #0
 801d674:	d106      	bne.n	801d684 <ecc_mul2add+0x364>
 801d676:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801d678:	2b00      	cmp	r3, #0
 801d67a:	d103      	bne.n	801d684 <ecc_mul2add+0x364>
 801d67c:	69bb      	ldr	r3, [r7, #24]
 801d67e:	2b01      	cmp	r3, #1
 801d680:	f000 8084 	beq.w	801d78c <ecc_mul2add+0x46c>
            continue;
        }

        /* double twice, only if this isn't the first */
        if (first == 0) {
 801d684:	69bb      	ldr	r3, [r7, #24]
 801d686:	2b00      	cmp	r3, #0
 801d688:	d11f      	bne.n	801d6ca <ecc_mul2add+0x3aa>
            /* double twice */
            if (err == MP_OKAY)
 801d68a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d68c:	2b00      	cmp	r3, #0
 801d68e:	d10c      	bne.n	801d6aa <ecc_mul2add+0x38a>
                err = ecc_projective_dbl_point_safe(C, C, a, modulus, mp);
 801d690:	697b      	ldr	r3, [r7, #20]
 801d692:	9300      	str	r3, [sp, #0]
 801d694:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801d698:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 801d69c:	f8d7 1080 	ldr.w	r1, [r7, #128]	@ 0x80
 801d6a0:	f8d7 0080 	ldr.w	r0, [r7, #128]	@ 0x80
 801d6a4:	f7ff fd65 	bl	801d172 <ecc_projective_dbl_point_safe>
 801d6a8:	6638      	str	r0, [r7, #96]	@ 0x60
            if (err == MP_OKAY)
 801d6aa:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d6ac:	2b00      	cmp	r3, #0
 801d6ae:	d17a      	bne.n	801d7a6 <ecc_mul2add+0x486>
                err = ecc_projective_dbl_point_safe(C, C, a, modulus, mp);
 801d6b0:	697b      	ldr	r3, [r7, #20]
 801d6b2:	9300      	str	r3, [sp, #0]
 801d6b4:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801d6b8:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 801d6bc:	f8d7 1080 	ldr.w	r1, [r7, #128]	@ 0x80
 801d6c0:	f8d7 0080 	ldr.w	r0, [r7, #128]	@ 0x80
 801d6c4:	f7ff fd55 	bl	801d172 <ecc_projective_dbl_point_safe>
 801d6c8:	6638      	str	r0, [r7, #96]	@ 0x60
            else
                break;
        }

        /* if not both zero */
        if ((nA != 0) || (nB != 0)) {
 801d6ca:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801d6cc:	2b00      	cmp	r3, #0
 801d6ce:	d102      	bne.n	801d6d6 <ecc_mul2add+0x3b6>
 801d6d0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801d6d2:	2b00      	cmp	r3, #0
 801d6d4:	d05b      	beq.n	801d78e <ecc_mul2add+0x46e>
            unsigned int i = nA + (nB<<2);
 801d6d6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801d6d8:	009b      	lsls	r3, r3, #2
 801d6da:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 801d6dc:	4413      	add	r3, r2
 801d6de:	637b      	str	r3, [r7, #52]	@ 0x34
            if (first == 1) {
 801d6e0:	69bb      	ldr	r3, [r7, #24]
 801d6e2:	2b01      	cmp	r3, #1
 801d6e4:	d135      	bne.n	801d752 <ecc_mul2add+0x432>
                /* if first, copy from table */
                first = 0;
 801d6e6:	2300      	movs	r3, #0
 801d6e8:	61bb      	str	r3, [r7, #24]
                if (err == MP_OKAY)
 801d6ea:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d6ec:	2b00      	cmp	r3, #0
 801d6ee:	d10d      	bne.n	801d70c <ecc_mul2add+0x3ec>
                    err = mp_copy(precomp[i]->x, C->x);
 801d6f0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801d6f2:	009b      	lsls	r3, r3, #2
 801d6f4:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801d6f6:	4413      	add	r3, r2
 801d6f8:	681b      	ldr	r3, [r3, #0]
 801d6fa:	681a      	ldr	r2, [r3, #0]
 801d6fc:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801d700:	681b      	ldr	r3, [r3, #0]
 801d702:	4619      	mov	r1, r3
 801d704:	4610      	mov	r0, r2
 801d706:	f009 fa10 	bl	8026b2a <mp_copy>
 801d70a:	6638      	str	r0, [r7, #96]	@ 0x60

                if (err == MP_OKAY)
 801d70c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d70e:	2b00      	cmp	r3, #0
 801d710:	d10d      	bne.n	801d72e <ecc_mul2add+0x40e>
                    err = mp_copy(precomp[i]->y, C->y);
 801d712:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801d714:	009b      	lsls	r3, r3, #2
 801d716:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801d718:	4413      	add	r3, r2
 801d71a:	681b      	ldr	r3, [r3, #0]
 801d71c:	685a      	ldr	r2, [r3, #4]
 801d71e:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801d722:	685b      	ldr	r3, [r3, #4]
 801d724:	4619      	mov	r1, r3
 801d726:	4610      	mov	r0, r2
 801d728:	f009 f9ff 	bl	8026b2a <mp_copy>
 801d72c:	6638      	str	r0, [r7, #96]	@ 0x60

                if (err == MP_OKAY)
 801d72e:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d730:	2b00      	cmp	r3, #0
 801d732:	d13a      	bne.n	801d7aa <ecc_mul2add+0x48a>
                    err = mp_copy(precomp[i]->z, C->z);
 801d734:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801d736:	009b      	lsls	r3, r3, #2
 801d738:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801d73a:	4413      	add	r3, r2
 801d73c:	681b      	ldr	r3, [r3, #0]
 801d73e:	689a      	ldr	r2, [r3, #8]
 801d740:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801d744:	689b      	ldr	r3, [r3, #8]
 801d746:	4619      	mov	r1, r3
 801d748:	4610      	mov	r0, r2
 801d74a:	f009 f9ee 	bl	8026b2a <mp_copy>
 801d74e:	6638      	str	r0, [r7, #96]	@ 0x60
 801d750:	e01d      	b.n	801d78e <ecc_mul2add+0x46e>
                else
                    break;
            } else {
                /* if not first, add from table */
                if (err == MP_OKAY)
 801d752:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d754:	2b00      	cmp	r3, #0
 801d756:	d115      	bne.n	801d784 <ecc_mul2add+0x464>
                    err = ecc_projective_add_point_safe(C, precomp[i],
 801d758:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801d75a:	009b      	lsls	r3, r3, #2
 801d75c:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801d75e:	4413      	add	r3, r2
 801d760:	6819      	ldr	r1, [r3, #0]
 801d762:	697b      	ldr	r3, [r7, #20]
 801d764:	f107 0218 	add.w	r2, r7, #24
 801d768:	9202      	str	r2, [sp, #8]
 801d76a:	9301      	str	r3, [sp, #4]
 801d76c:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801d770:	9300      	str	r3, [sp, #0]
 801d772:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801d776:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 801d77a:	f8d7 0080 	ldr.w	r0, [r7, #128]	@ 0x80
 801d77e:	f7ff fbf4 	bl	801cf6a <ecc_projective_add_point_safe>
 801d782:	6638      	str	r0, [r7, #96]	@ 0x60
                                                        C, a, modulus, mp,
                                                        &first);
                if (err != MP_OKAY)
 801d784:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d786:	2b00      	cmp	r3, #0
 801d788:	d111      	bne.n	801d7ae <ecc_mul2add+0x48e>
 801d78a:	e000      	b.n	801d78e <ecc_mul2add+0x46e>
            continue;
 801d78c:	bf00      	nop
    for (x = 0; x < (int)len || nibble != 3; ) {
 801d78e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801d790:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801d792:	429a      	cmp	r2, r3
 801d794:	f6ff af40 	blt.w	801d618 <ecc_mul2add+0x2f8>
 801d798:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801d79a:	2b03      	cmp	r3, #3
 801d79c:	f47f af3c 	bne.w	801d618 <ecc_mul2add+0x2f8>
 801d7a0:	e006      	b.n	801d7b0 <ecc_mul2add+0x490>
            if (x == (int)len) break;
 801d7a2:	bf00      	nop
 801d7a4:	e004      	b.n	801d7b0 <ecc_mul2add+0x490>
                break;
 801d7a6:	bf00      	nop
 801d7a8:	e002      	b.n	801d7b0 <ecc_mul2add+0x490>
                    break;
 801d7aa:	bf00      	nop
 801d7ac:	e000      	b.n	801d7b0 <ecc_mul2add+0x490>
                    break;
 801d7ae:	bf00      	nop
        }
    }
  }

  /* reduce to affine */
  if (err == MP_OKAY)
 801d7b0:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d7b2:	2b00      	cmp	r3, #0
 801d7b4:	d108      	bne.n	801d7c8 <ecc_mul2add+0x4a8>
    err = ecc_map(C, modulus, mp);
 801d7b6:	697b      	ldr	r3, [r7, #20]
 801d7b8:	461a      	mov	r2, r3
 801d7ba:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801d7be:	f8d7 0080 	ldr.w	r0, [r7, #128]	@ 0x80
 801d7c2:	f7fe fbab 	bl	801bf1c <ecc_map>
 801d7c6:	6638      	str	r0, [r7, #96]	@ 0x60

  /* clean up */
  for (x = 0; x < SHAMIR_PRECOMP_SZ; x++) {
 801d7c8:	2300      	movs	r3, #0
 801d7ca:	65fb      	str	r3, [r7, #92]	@ 0x5c
 801d7cc:	e00c      	b.n	801d7e8 <ecc_mul2add+0x4c8>
     wc_ecc_del_point_ex(precomp[x], heap);
 801d7ce:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d7d0:	009b      	lsls	r3, r3, #2
 801d7d2:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801d7d4:	4413      	add	r3, r2
 801d7d6:	681b      	ldr	r3, [r3, #0]
 801d7d8:	f8d7 108c 	ldr.w	r1, [r7, #140]	@ 0x8c
 801d7dc:	4618      	mov	r0, r3
 801d7de:	f7ff f8cb 	bl	801c978 <wc_ecc_del_point_ex>
  for (x = 0; x < SHAMIR_PRECOMP_SZ; x++) {
 801d7e2:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d7e4:	3301      	adds	r3, #1
 801d7e6:	65fb      	str	r3, [r7, #92]	@ 0x5c
 801d7e8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d7ea:	2b0f      	cmp	r3, #15
 801d7ec:	ddef      	ble.n	801d7ce <ecc_mul2add+0x4ae>
  }

  ForceZero(tA, ECC_BUFSIZE);
 801d7ee:	f240 1101 	movw	r1, #257	@ 0x101
 801d7f2:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 801d7f4:	f7fc ffc2 	bl	801a77c <ForceZero>
  ForceZero(tB, ECC_BUFSIZE);
 801d7f8:	f240 1101 	movw	r1, #257	@ 0x101
 801d7fc:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 801d7fe:	f7fc ffbd 	bl	801a77c <ForceZero>
  XFREE(key->t1, heap, DYNAMIC_TYPE_ECC);
  XFREE(key, heap, DYNAMIC_TYPE_ECC_BUFFER);
  C->key = NULL;
#endif
#ifdef WOLFSSL_SMALL_STACK
  XFREE(precomp, heap, DYNAMIC_TYPE_ECC_BUFFER);
 801d802:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d804:	633b      	str	r3, [r7, #48]	@ 0x30
 801d806:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801d808:	2b00      	cmp	r3, #0
 801d80a:	d002      	beq.n	801d812 <ecc_mul2add+0x4f2>
 801d80c:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 801d80e:	f001 f957 	bl	801eac0 <wolfSSL_Free>
#endif
#ifndef WOLFSSL_NO_MALLOC
  XFREE(tB, heap, DYNAMIC_TYPE_ECC_BUFFER);
 801d812:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801d814:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801d816:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801d818:	2b00      	cmp	r3, #0
 801d81a:	d002      	beq.n	801d822 <ecc_mul2add+0x502>
 801d81c:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 801d81e:	f001 f94f 	bl	801eac0 <wolfSSL_Free>
  XFREE(tA, heap, DYNAMIC_TYPE_ECC_BUFFER);
 801d822:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801d824:	62bb      	str	r3, [r7, #40]	@ 0x28
 801d826:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801d828:	2b00      	cmp	r3, #0
 801d82a:	d002      	beq.n	801d832 <ecc_mul2add+0x512>
 801d82c:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801d82e:	f001 f947 	bl	801eac0 <wolfSSL_Free>
#elif defined(WOLFSSL_CHECK_MEM_ZERO)
  wc_MemZero_Check(tB, ECC_BUFSIZE);
  wc_MemZero_Check(tA, ECC_BUFSIZE);
#endif
  return err;
 801d832:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
}
 801d834:	4618      	mov	r0, r3
 801d836:	3774      	adds	r7, #116	@ 0x74
 801d838:	46bd      	mov	sp, r7
 801d83a:	bd90      	pop	{r4, r7, pc}

0801d83c <wc_ecc_verify_hash>:
             is valid or invalid. Other negative values are returned on error.
 */
WOLFSSL_ABI
int wc_ecc_verify_hash(const byte* sig, word32 siglen, const byte* hash,
                       word32 hashlen, int* res, ecc_key* key)
{
 801d83c:	b580      	push	{r7, lr}
 801d83e:	b092      	sub	sp, #72	@ 0x48
 801d840:	af02      	add	r7, sp, #8
 801d842:	60f8      	str	r0, [r7, #12]
 801d844:	60b9      	str	r1, [r7, #8]
 801d846:	607a      	str	r2, [r7, #4]
 801d848:	603b      	str	r3, [r7, #0]
    int err;

#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)
    mp_int *r = NULL, *s = NULL;
#else
    DECL_MP_INT_SIZE_DYN(r, ECC_KEY_MAX_BITS(key), MAX_ECC_BITS_USE);
 801d84a:	2300      	movs	r3, #0
 801d84c:	63bb      	str	r3, [r7, #56]	@ 0x38
    DECL_MP_INT_SIZE_DYN(s, ECC_KEY_MAX_BITS(key), MAX_ECC_BITS_USE);
 801d84e:	2300      	movs	r3, #0
 801d850:	637b      	str	r3, [r7, #52]	@ 0x34
#endif
#ifdef NO_ASN
    word32 keySz;
#endif

    if (sig == NULL || hash == NULL || res == NULL || key == NULL) {
 801d852:	68fb      	ldr	r3, [r7, #12]
 801d854:	2b00      	cmp	r3, #0
 801d856:	d008      	beq.n	801d86a <wc_ecc_verify_hash+0x2e>
 801d858:	687b      	ldr	r3, [r7, #4]
 801d85a:	2b00      	cmp	r3, #0
 801d85c:	d005      	beq.n	801d86a <wc_ecc_verify_hash+0x2e>
 801d85e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801d860:	2b00      	cmp	r3, #0
 801d862:	d002      	beq.n	801d86a <wc_ecc_verify_hash+0x2e>
 801d864:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801d866:	2b00      	cmp	r3, #0
 801d868:	d102      	bne.n	801d870 <wc_ecc_verify_hash+0x34>
        return ECC_BAD_ARG_E;
 801d86a:	f06f 03a9 	mvn.w	r3, #169	@ 0xa9
 801d86e:	e0d7      	b.n	801da20 <wc_ecc_verify_hash+0x1e4>
    if (err != 0)
        return err;
    r = key->r;
    s = key->s;
#else
    NEW_MP_INT_SIZE(r, ECC_KEY_MAX_BITS_NONULLCHECK(key), key->heap,
 801d870:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801d874:	f001 f908 	bl	801ea88 <wolfSSL_Malloc>
 801d878:	63b8      	str	r0, [r7, #56]	@ 0x38
 801d87a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801d87c:	2b00      	cmp	r3, #0
 801d87e:	d005      	beq.n	801d88c <wc_ecc_verify_hash+0x50>
 801d880:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801d884:	2100      	movs	r1, #0
 801d886:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 801d888:	f00a fe1e 	bl	80284c8 <memset>
        DYNAMIC_TYPE_ECC);
    #ifdef MP_INT_SIZE_CHECK_NULL
    if (r == NULL)
 801d88c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801d88e:	2b00      	cmp	r3, #0
 801d890:	d102      	bne.n	801d898 <wc_ecc_verify_hash+0x5c>
        return MEMORY_E;
 801d892:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801d896:	e0c3      	b.n	801da20 <wc_ecc_verify_hash+0x1e4>
    #endif
    NEW_MP_INT_SIZE(s, ECC_KEY_MAX_BITS_NONULLCHECK(key), key->heap,
 801d898:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801d89c:	f001 f8f4 	bl	801ea88 <wolfSSL_Malloc>
 801d8a0:	6378      	str	r0, [r7, #52]	@ 0x34
 801d8a2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801d8a4:	2b00      	cmp	r3, #0
 801d8a6:	d005      	beq.n	801d8b4 <wc_ecc_verify_hash+0x78>
 801d8a8:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801d8ac:	2100      	movs	r1, #0
 801d8ae:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801d8b0:	f00a fe0a 	bl	80284c8 <memset>
        DYNAMIC_TYPE_ECC);
    #ifdef MP_INT_SIZE_CHECK_NULL
    if (s == NULL) {
 801d8b4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801d8b6:	2b00      	cmp	r3, #0
 801d8b8:	d10a      	bne.n	801d8d0 <wc_ecc_verify_hash+0x94>
        FREE_MP_INT_SIZE(r, key->heap, DYNAMIC_TYPE_ECC);
 801d8ba:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801d8bc:	613b      	str	r3, [r7, #16]
 801d8be:	693b      	ldr	r3, [r7, #16]
 801d8c0:	2b00      	cmp	r3, #0
 801d8c2:	d002      	beq.n	801d8ca <wc_ecc_verify_hash+0x8e>
 801d8c4:	6938      	ldr	r0, [r7, #16]
 801d8c6:	f001 f8fb 	bl	801eac0 <wolfSSL_Free>
        return MEMORY_E;
 801d8ca:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801d8ce:	e0a7      	b.n	801da20 <wc_ecc_verify_hash+0x1e4>
    }
    #endif
    err = INIT_MP_INT_SIZE(r, ECC_KEY_MAX_BITS_NONULLCHECK(key));
 801d8d0:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 801d8d2:	f008 fede 	bl	8026692 <mp_init>
 801d8d6:	63f8      	str	r0, [r7, #60]	@ 0x3c
    if (err != 0) {
 801d8d8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801d8da:	2b00      	cmp	r3, #0
 801d8dc:	d011      	beq.n	801d902 <wc_ecc_verify_hash+0xc6>
        FREE_MP_INT_SIZE(s, key->heap, DYNAMIC_TYPE_ECC);
 801d8de:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801d8e0:	61bb      	str	r3, [r7, #24]
 801d8e2:	69bb      	ldr	r3, [r7, #24]
 801d8e4:	2b00      	cmp	r3, #0
 801d8e6:	d002      	beq.n	801d8ee <wc_ecc_verify_hash+0xb2>
 801d8e8:	69b8      	ldr	r0, [r7, #24]
 801d8ea:	f001 f8e9 	bl	801eac0 <wolfSSL_Free>
        FREE_MP_INT_SIZE(r, key->heap, DYNAMIC_TYPE_ECC);
 801d8ee:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801d8f0:	617b      	str	r3, [r7, #20]
 801d8f2:	697b      	ldr	r3, [r7, #20]
 801d8f4:	2b00      	cmp	r3, #0
 801d8f6:	d002      	beq.n	801d8fe <wc_ecc_verify_hash+0xc2>
 801d8f8:	6978      	ldr	r0, [r7, #20]
 801d8fa:	f001 f8e1 	bl	801eac0 <wolfSSL_Free>
        return err;
 801d8fe:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801d900:	e08e      	b.n	801da20 <wc_ecc_verify_hash+0x1e4>
    }
    err = INIT_MP_INT_SIZE(s, ECC_KEY_MAX_BITS_NONULLCHECK(key));
 801d902:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801d904:	f008 fec5 	bl	8026692 <mp_init>
 801d908:	63f8      	str	r0, [r7, #60]	@ 0x3c
    if (err != 0) {
 801d90a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801d90c:	2b00      	cmp	r3, #0
 801d90e:	d011      	beq.n	801d934 <wc_ecc_verify_hash+0xf8>
        FREE_MP_INT_SIZE(s, key->heap, DYNAMIC_TYPE_ECC);
 801d910:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801d912:	623b      	str	r3, [r7, #32]
 801d914:	6a3b      	ldr	r3, [r7, #32]
 801d916:	2b00      	cmp	r3, #0
 801d918:	d002      	beq.n	801d920 <wc_ecc_verify_hash+0xe4>
 801d91a:	6a38      	ldr	r0, [r7, #32]
 801d91c:	f001 f8d0 	bl	801eac0 <wolfSSL_Free>
        FREE_MP_INT_SIZE(r, key->heap, DYNAMIC_TYPE_ECC);
 801d920:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801d922:	61fb      	str	r3, [r7, #28]
 801d924:	69fb      	ldr	r3, [r7, #28]
 801d926:	2b00      	cmp	r3, #0
 801d928:	d002      	beq.n	801d930 <wc_ecc_verify_hash+0xf4>
 801d92a:	69f8      	ldr	r0, [r7, #28]
 801d92c:	f001 f8c8 	bl	801eac0 <wolfSSL_Free>
        return err;
 801d930:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801d932:	e075      	b.n	801da20 <wc_ecc_verify_hash+0x1e4>
    }
#endif /* WOLFSSL_ASYNC_CRYPT */

    switch (key->state) {
 801d934:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801d936:	689b      	ldr	r3, [r3, #8]
 801d938:	2b07      	cmp	r3, #7
 801d93a:	d856      	bhi.n	801d9ea <wc_ecc_verify_hash+0x1ae>
 801d93c:	a201      	add	r2, pc, #4	@ (adr r2, 801d944 <wc_ecc_verify_hash+0x108>)
 801d93e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801d942:	bf00      	nop
 801d944:	0801d965 	.word	0x0801d965
 801d948:	0801d9eb 	.word	0x0801d9eb
 801d94c:	0801d9eb 	.word	0x0801d9eb
 801d950:	0801d9eb 	.word	0x0801d9eb
 801d954:	0801d9eb 	.word	0x0801d9eb
 801d958:	0801d965 	.word	0x0801d965
 801d95c:	0801d989 	.word	0x0801d989
 801d960:	0801d9df 	.word	0x0801d9df
        case ECC_STATE_NONE:
        case ECC_STATE_VERIFY_DECODE:
            key->state = ECC_STATE_VERIFY_DECODE;
 801d964:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801d966:	2205      	movs	r2, #5
 801d968:	609a      	str	r2, [r3, #8]

            /* default to invalid signature */
            *res = 0;
 801d96a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801d96c:	2200      	movs	r2, #0
 801d96e:	601a      	str	r2, [r3, #0]
             * the rest of this function will execute, and everything
             * gets cleaned up at the end. */
            err = DecodeECC_DSA_Sig(sig, siglen, r, s);
        #else
            /* r and s are initialized. */
            err = DecodeECC_DSA_Sig_Ex(sig, siglen, r, s, 0);
 801d970:	2300      	movs	r3, #0
 801d972:	9300      	str	r3, [sp, #0]
 801d974:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801d976:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801d978:	68b9      	ldr	r1, [r7, #8]
 801d97a:	68f8      	ldr	r0, [r7, #12]
 801d97c:	f7fc f9d0 	bl	8019d20 <DecodeECC_DSA_Sig_Ex>
 801d980:	63f8      	str	r0, [r7, #60]	@ 0x3c
        #endif
            if (err < 0) {
 801d982:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801d984:	2b00      	cmp	r3, #0
 801d986:	db34      	blt.n	801d9f2 <wc_ecc_verify_hash+0x1b6>
            mp_read_unsigned_bin(s, sig + keySz, keySz);
    #endif /* !NO_ASN */
            FALL_THROUGH;

        case ECC_STATE_VERIFY_DO:
            key->state = ECC_STATE_VERIFY_DO;
 801d988:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801d98a:	2206      	movs	r2, #6
 801d98c:	609a      	str	r2, [r3, #8]
        #ifdef WOLFSSL_ASYNC_CRYPT
            if (key->type == ECC_PRIVATEKEY_ONLY) {
                isPrivateKeyOnly = 1;
            }
        #endif
            err = wc_ecc_verify_hash_ex(r, s, hash, hashlen, res, key);
 801d98e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801d990:	9301      	str	r3, [sp, #4]
 801d992:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801d994:	9300      	str	r3, [sp, #0]
 801d996:	683b      	ldr	r3, [r7, #0]
 801d998:	687a      	ldr	r2, [r7, #4]
 801d99a:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 801d99c:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 801d99e:	f000 fa34 	bl	801de0a <wc_ecc_verify_hash_ex>
 801d9a2:	63f8      	str	r0, [r7, #60]	@ 0x3c

        #ifndef WOLFSSL_ASYNC_CRYPT
            /* done with R/S */
            mp_clear(r);
 801d9a4:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 801d9a6:	f008 fefe 	bl	80267a6 <mp_clear>
            mp_clear(s);
 801d9aa:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801d9ac:	f008 fefb 	bl	80267a6 <mp_clear>
            FREE_MP_INT_SIZE(s, key->heap, DYNAMIC_TYPE_ECC);
 801d9b0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801d9b2:	633b      	str	r3, [r7, #48]	@ 0x30
 801d9b4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801d9b6:	2b00      	cmp	r3, #0
 801d9b8:	d002      	beq.n	801d9c0 <wc_ecc_verify_hash+0x184>
 801d9ba:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 801d9bc:	f001 f880 	bl	801eac0 <wolfSSL_Free>
            FREE_MP_INT_SIZE(r, key->heap, DYNAMIC_TYPE_ECC);
 801d9c0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801d9c2:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801d9c4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801d9c6:	2b00      	cmp	r3, #0
 801d9c8:	d002      	beq.n	801d9d0 <wc_ecc_verify_hash+0x194>
 801d9ca:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 801d9cc:	f001 f878 	bl	801eac0 <wolfSSL_Free>
        #ifdef MP_INT_SIZE_CHECK_NULL
            r = NULL;
 801d9d0:	2300      	movs	r3, #0
 801d9d2:	63bb      	str	r3, [r7, #56]	@ 0x38
            s = NULL;
 801d9d4:	2300      	movs	r3, #0
 801d9d6:	637b      	str	r3, [r7, #52]	@ 0x34
        #endif
        #endif

            if (err < 0) {
 801d9d8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801d9da:	2b00      	cmp	r3, #0
 801d9dc:	db0b      	blt.n	801d9f6 <wc_ecc_verify_hash+0x1ba>
                break;
            }
            FALL_THROUGH;

        case ECC_STATE_VERIFY_RES:
            key->state = ECC_STATE_VERIFY_RES;
 801d9de:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801d9e0:	2207      	movs	r2, #7
 801d9e2:	609a      	str	r2, [r3, #8]
            err = 0;
 801d9e4:	2300      	movs	r3, #0
 801d9e6:	63fb      	str	r3, [r7, #60]	@ 0x3c
            break;
 801d9e8:	e006      	b.n	801d9f8 <wc_ecc_verify_hash+0x1bc>

        default:
            err = BAD_STATE_E;
 801d9ea:	f06f 03bf 	mvn.w	r3, #191	@ 0xbf
 801d9ee:	63fb      	str	r3, [r7, #60]	@ 0x3c
 801d9f0:	e002      	b.n	801d9f8 <wc_ecc_verify_hash+0x1bc>
                break;
 801d9f2:	bf00      	nop
 801d9f4:	e000      	b.n	801d9f8 <wc_ecc_verify_hash+0x1bc>
                break;
 801d9f6:	bf00      	nop

    /* cleanup */
#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)
    wc_ecc_free_async(key);
#else
    FREE_MP_INT_SIZE(s, key->heap, DYNAMIC_TYPE_ECC);
 801d9f8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801d9fa:	62bb      	str	r3, [r7, #40]	@ 0x28
 801d9fc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801d9fe:	2b00      	cmp	r3, #0
 801da00:	d002      	beq.n	801da08 <wc_ecc_verify_hash+0x1cc>
 801da02:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801da04:	f001 f85c 	bl	801eac0 <wolfSSL_Free>
    FREE_MP_INT_SIZE(r, key->heap, DYNAMIC_TYPE_ECC);
 801da08:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801da0a:	627b      	str	r3, [r7, #36]	@ 0x24
 801da0c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801da0e:	2b00      	cmp	r3, #0
 801da10:	d002      	beq.n	801da18 <wc_ecc_verify_hash+0x1dc>
 801da12:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 801da14:	f001 f854 	bl	801eac0 <wolfSSL_Free>
#endif

    /* make sure required variables are reset */
    wc_ecc_reset(key);
 801da18:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 801da1a:	f7ff f8f6 	bl	801cc0a <wc_ecc_reset>
    return err;
 801da1e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
#endif /* !WOLF_CRYPTO_CB_ONLY_ECC */
}
 801da20:	4618      	mov	r0, r3
 801da22:	3740      	adds	r7, #64	@ 0x40
 801da24:	46bd      	mov	sp, r7
 801da26:	bd80      	pop	{r7, pc}

0801da28 <wc_ecc_check_r_s_range>:
#ifndef WOLF_CRYPTO_CB_ONLY_ECC

#if !defined(WOLFSSL_STM32_PKA) && !defined(WOLFSSL_PSOC6_CRYPTO) && \
    !defined(WOLF_CRYPTO_CB_ONLY_ECC)
static int wc_ecc_check_r_s_range(ecc_key* key, mp_int* r, mp_int* s)
{
 801da28:	b580      	push	{r7, lr}
 801da2a:	b094      	sub	sp, #80	@ 0x50
 801da2c:	af00      	add	r7, sp, #0
 801da2e:	60f8      	str	r0, [r7, #12]
 801da30:	60b9      	str	r1, [r7, #8]
 801da32:	607a      	str	r2, [r7, #4]
    int err = MP_OKAY;
 801da34:	2300      	movs	r3, #0
 801da36:	64fb      	str	r3, [r7, #76]	@ 0x4c
    DECLARE_CURVE_SPECS(1);
 801da38:	2300      	movs	r3, #0
 801da3a:	64bb      	str	r3, [r7, #72]	@ 0x48
 801da3c:	f107 0314 	add.w	r3, r7, #20
 801da40:	613b      	str	r3, [r7, #16]
 801da42:	693b      	ldr	r3, [r7, #16]
 801da44:	222c      	movs	r2, #44	@ 0x2c
 801da46:	2100      	movs	r1, #0
 801da48:	4618      	mov	r0, r3
 801da4a:	f00a fd3d 	bl	80284c8 <memset>
 801da4e:	693b      	ldr	r3, [r7, #16]
 801da50:	2201      	movs	r2, #1
 801da52:	621a      	str	r2, [r3, #32]

    ALLOC_CURVE_SPECS(1, err);
 801da54:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801da58:	f001 f816 	bl	801ea88 <wolfSSL_Malloc>
 801da5c:	64b8      	str	r0, [r7, #72]	@ 0x48
 801da5e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801da60:	2b00      	cmp	r3, #0
 801da62:	d103      	bne.n	801da6c <wc_ecc_check_r_s_range+0x44>
 801da64:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801da68:	64fb      	str	r3, [r7, #76]	@ 0x4c
 801da6a:	e002      	b.n	801da72 <wc_ecc_check_r_s_range+0x4a>
 801da6c:	693b      	ldr	r3, [r7, #16]
 801da6e:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 801da70:	61da      	str	r2, [r3, #28]
    if (err == MP_OKAY) {
 801da72:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801da74:	2b00      	cmp	r3, #0
 801da76:	d108      	bne.n	801da8a <wc_ecc_check_r_s_range+0x62>
        err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ORDER);
 801da78:	68fb      	ldr	r3, [r7, #12]
 801da7a:	691b      	ldr	r3, [r3, #16]
 801da7c:	f107 0110 	add.w	r1, r7, #16
 801da80:	2208      	movs	r2, #8
 801da82:	4618      	mov	r0, r3
 801da84:	f7fc ff61 	bl	801a94a <wc_ecc_curve_load>
 801da88:	64f8      	str	r0, [r7, #76]	@ 0x4c
    }
    if (err != 0) {
 801da8a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801da8c:	2b00      	cmp	r3, #0
 801da8e:	d009      	beq.n	801daa4 <wc_ecc_check_r_s_range+0x7c>
        FREE_CURVE_SPECS();
 801da90:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801da92:	643b      	str	r3, [r7, #64]	@ 0x40
 801da94:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801da96:	2b00      	cmp	r3, #0
 801da98:	d002      	beq.n	801daa0 <wc_ecc_check_r_s_range+0x78>
 801da9a:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 801da9c:	f001 f810 	bl	801eac0 <wolfSSL_Free>
        return err;
 801daa0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801daa2:	e03b      	b.n	801db1c <wc_ecc_check_r_s_range+0xf4>
    }

    if (mp_iszero(r) || mp_iszero(s)) {
 801daa4:	68b8      	ldr	r0, [r7, #8]
 801daa6:	f009 f84e 	bl	8026b46 <mp_iszero>
 801daaa:	4603      	mov	r3, r0
 801daac:	2b00      	cmp	r3, #0
 801daae:	d105      	bne.n	801dabc <wc_ecc_check_r_s_range+0x94>
 801dab0:	6878      	ldr	r0, [r7, #4]
 801dab2:	f009 f848 	bl	8026b46 <mp_iszero>
 801dab6:	4603      	mov	r3, r0
 801dab8:	2b00      	cmp	r3, #0
 801daba:	d002      	beq.n	801dac2 <wc_ecc_check_r_s_range+0x9a>
        err = MP_ZERO_E;
 801dabc:	f06f 0378 	mvn.w	r3, #120	@ 0x78
 801dac0:	64fb      	str	r3, [r7, #76]	@ 0x4c
    }
    if ((err == 0) && (mp_cmp(r, curve->order) != MP_LT)) {
 801dac2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801dac4:	2b00      	cmp	r3, #0
 801dac6:	d10c      	bne.n	801dae2 <wc_ecc_check_r_s_range+0xba>
 801dac8:	693b      	ldr	r3, [r7, #16]
 801daca:	691b      	ldr	r3, [r3, #16]
 801dacc:	4619      	mov	r1, r3
 801dace:	68b8      	ldr	r0, [r7, #8]
 801dad0:	f008 ff72 	bl	80269b8 <mp_cmp>
 801dad4:	4603      	mov	r3, r0
 801dad6:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 801dada:	d002      	beq.n	801dae2 <wc_ecc_check_r_s_range+0xba>
        err = MP_VAL;
 801dadc:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 801dae0:	64fb      	str	r3, [r7, #76]	@ 0x4c
    }
    if ((err == 0) && (mp_cmp(s, curve->order) != MP_LT)) {
 801dae2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801dae4:	2b00      	cmp	r3, #0
 801dae6:	d10c      	bne.n	801db02 <wc_ecc_check_r_s_range+0xda>
 801dae8:	693b      	ldr	r3, [r7, #16]
 801daea:	691b      	ldr	r3, [r3, #16]
 801daec:	4619      	mov	r1, r3
 801daee:	6878      	ldr	r0, [r7, #4]
 801daf0:	f008 ff62 	bl	80269b8 <mp_cmp>
 801daf4:	4603      	mov	r3, r0
 801daf6:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 801dafa:	d002      	beq.n	801db02 <wc_ecc_check_r_s_range+0xda>
        err = MP_VAL;
 801dafc:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 801db00:	64fb      	str	r3, [r7, #76]	@ 0x4c
    }

    wc_ecc_curve_free(curve);
 801db02:	693b      	ldr	r3, [r7, #16]
 801db04:	4618      	mov	r0, r3
 801db06:	f7fc fed5 	bl	801a8b4 <wc_ecc_curve_free>
    FREE_CURVE_SPECS();
 801db0a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801db0c:	647b      	str	r3, [r7, #68]	@ 0x44
 801db0e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801db10:	2b00      	cmp	r3, #0
 801db12:	d002      	beq.n	801db1a <wc_ecc_check_r_s_range+0xf2>
 801db14:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 801db16:	f000 ffd3 	bl	801eac0 <wolfSSL_Free>
    return err;
 801db1a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
}
 801db1c:	4618      	mov	r0, r3
 801db1e:	3750      	adds	r7, #80	@ 0x50
 801db20:	46bd      	mov	sp, r7
 801db22:	bd80      	pop	{r7, pc}

0801db24 <ecc_verify_hash_sp>:
#endif /* !WOLFSSL_STM32_PKA && !WOLFSSL_PSOC6_CRYPTO */

#ifdef HAVE_ECC_VERIFY_HELPER
static int ecc_verify_hash_sp(mp_int *r, mp_int *s, const byte* hash,
    word32 hashlen, int* res, ecc_key* key)
{
 801db24:	b480      	push	{r7}
 801db26:	b085      	sub	sp, #20
 801db28:	af00      	add	r7, sp, #0
 801db2a:	60f8      	str	r0, [r7, #12]
 801db2c:	60b9      	str	r1, [r7, #8]
 801db2e:	607a      	str	r2, [r7, #4]
 801db30:	603b      	str	r3, [r7, #0]
        }
    #endif
    }
#endif

    return NOT_COMPILED_IN;
 801db32:	f06f 03ad 	mvn.w	r3, #173	@ 0xad
}
 801db36:	4618      	mov	r0, r3
 801db38:	3714      	adds	r7, #20
 801db3a:	46bd      	mov	sp, r7
 801db3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801db40:	4770      	bx	lr

0801db42 <ecc_verify_hash>:

#if !defined(WOLFSSL_SP_MATH) || defined(FREESCALE_LTC_ECC)
static int ecc_verify_hash(mp_int *r, mp_int *s, const byte* hash,
    word32 hashlen, int* res, ecc_key* key, ecc_curve_spec* curve)
{
 801db42:	b5b0      	push	{r4, r5, r7, lr}
 801db44:	b096      	sub	sp, #88	@ 0x58
 801db46:	af04      	add	r7, sp, #16
 801db48:	60f8      	str	r0, [r7, #12]
 801db4a:	60b9      	str	r1, [r7, #8]
 801db4c:	607a      	str	r2, [r7, #4]
 801db4e:	603b      	str	r3, [r7, #0]
   int        err;
   ecc_point* mG = NULL;
 801db50:	2300      	movs	r3, #0
 801db52:	61bb      	str	r3, [r7, #24]
   ecc_point* mQ = NULL;
 801db54:	2300      	movs	r3, #0
 801db56:	617b      	str	r3, [r7, #20]
#ifdef WOLFSSL_NO_MALLOC
   ecc_point  lcl_mG;
   ecc_point  lcl_mQ;
#endif
   DECL_MP_INT_SIZE_DYN(w, ECC_KEY_MAX_BITS_NONULLCHECK(key), MAX_ECC_BITS_USE);
 801db58:	2300      	movs	r3, #0
 801db5a:	637b      	str	r3, [r7, #52]	@ 0x34
#if !defined(WOLFSSL_ASYNC_CRYPT) || !defined(HAVE_CAVIUM_V)
   DECL_MP_INT_SIZE_DYN(e_lcl, ECC_KEY_MAX_BITS_NONULLCHECK(key), MAX_ECC_BITS_USE);
 801db5c:	2300      	movs	r3, #0
 801db5e:	633b      	str	r3, [r7, #48]	@ 0x30
#endif
   mp_int*    e;
   mp_int*    v = NULL;      /* Will be w. */
 801db60:	2300      	movs	r3, #0
 801db62:	643b      	str	r3, [r7, #64]	@ 0x40
#if defined(WOLFSSL_CHECK_VER_FAULTS) && defined(WOLFSSL_NO_MALLOC)
   mp_int     u1tmp[1];
   mp_int     u2tmp[1];
#endif
   mp_int*    u1 = NULL;     /* Will be e. */
 801db64:	2300      	movs	r3, #0
 801db66:	63fb      	str	r3, [r7, #60]	@ 0x3c
   mp_int*    u2 = NULL;     /* Will be w. */
 801db68:	2300      	movs	r3, #0
 801db6a:	63bb      	str	r3, [r7, #56]	@ 0x38
   }
   e = key->e;

   err = mp_init(e);
#else
   NEW_MP_INT_SIZE(e_lcl, ECC_KEY_MAX_BITS_NONULLCHECK(key), key->heap, DYNAMIC_TYPE_ECC);
 801db6c:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801db70:	f000 ff8a 	bl	801ea88 <wolfSSL_Malloc>
 801db74:	6338      	str	r0, [r7, #48]	@ 0x30
 801db76:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801db78:	2b00      	cmp	r3, #0
 801db7a:	d005      	beq.n	801db88 <ecc_verify_hash+0x46>
 801db7c:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801db80:	2100      	movs	r1, #0
 801db82:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 801db84:	f00a fca0 	bl	80284c8 <memset>
#ifdef MP_INT_SIZE_CHECK_NULL
   if (e_lcl == NULL) {
 801db88:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801db8a:	2b00      	cmp	r3, #0
 801db8c:	d102      	bne.n	801db94 <ecc_verify_hash+0x52>
       return MEMORY_E;
 801db8e:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801db92:	e136      	b.n	801de02 <ecc_verify_hash+0x2c0>
   }
#endif
   e = e_lcl;
 801db94:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801db96:	62fb      	str	r3, [r7, #44]	@ 0x2c

   err = INIT_MP_INT_SIZE(e, ECC_KEY_MAX_BITS_NONULLCHECK(key));
 801db98:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 801db9a:	f008 fd7a 	bl	8026692 <mp_init>
 801db9e:	6478      	str	r0, [r7, #68]	@ 0x44
#endif /* WOLFSSL_ASYNC_CRYPT && HAVE_CAVIUM_V */
   if (err != MP_OKAY) {
 801dba0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dba2:	2b00      	cmp	r3, #0
 801dba4:	d00a      	beq.n	801dbbc <ecc_verify_hash+0x7a>
#ifdef WOLFSSL_SMALL_STACK
   #if !defined(WOLFSSL_ASYNC_CRYPT) || !defined(HAVE_CAVIUM_V)
      XFREE(e_lcl, key->heap, DYNAMIC_TYPE_ECC);
 801dba6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801dba8:	61fb      	str	r3, [r7, #28]
 801dbaa:	69fb      	ldr	r3, [r7, #28]
 801dbac:	2b00      	cmp	r3, #0
 801dbae:	d002      	beq.n	801dbb6 <ecc_verify_hash+0x74>
 801dbb0:	69f8      	ldr	r0, [r7, #28]
 801dbb2:	f000 ff85 	bl	801eac0 <wolfSSL_Free>
   #endif
#endif
      return MEMORY_E;
 801dbb6:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801dbba:	e122      	b.n	801de02 <ecc_verify_hash+0x2c0>
   }

   /* read hash */
   if (err == MP_OKAY) {
 801dbbc:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dbbe:	2b00      	cmp	r3, #0
 801dbc0:	d127      	bne.n	801dc12 <ecc_verify_hash+0xd0>
       /* we may need to truncate if hash is longer than key size */
       unsigned int orderBits = (unsigned int)mp_count_bits(curve->order);
 801dbc2:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801dbc4:	691b      	ldr	r3, [r3, #16]
 801dbc6:	4618      	mov	r0, r3
 801dbc8:	f008 ffce 	bl	8026b68 <mp_count_bits>
 801dbcc:	4603      	mov	r3, r0
 801dbce:	62bb      	str	r3, [r7, #40]	@ 0x28

       /* truncate down to byte size, may be all that's needed */
       if ( (WOLFSSL_BIT_SIZE * hashlen) > orderBits)
 801dbd0:	683b      	ldr	r3, [r7, #0]
 801dbd2:	00db      	lsls	r3, r3, #3
 801dbd4:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801dbd6:	429a      	cmp	r2, r3
 801dbd8:	d203      	bcs.n	801dbe2 <ecc_verify_hash+0xa0>
           hashlen = (orderBits + WOLFSSL_BIT_SIZE - 1) / WOLFSSL_BIT_SIZE;
 801dbda:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801dbdc:	3307      	adds	r3, #7
 801dbde:	08db      	lsrs	r3, r3, #3
 801dbe0:	603b      	str	r3, [r7, #0]
       err = mp_read_unsigned_bin(e, hash, hashlen);
 801dbe2:	683b      	ldr	r3, [r7, #0]
 801dbe4:	461a      	mov	r2, r3
 801dbe6:	6879      	ldr	r1, [r7, #4]
 801dbe8:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 801dbea:	f008 ff2b 	bl	8026a44 <mp_read_unsigned_bin>
 801dbee:	6478      	str	r0, [r7, #68]	@ 0x44

       /* may still need bit truncation too */
       if (err == MP_OKAY && (WOLFSSL_BIT_SIZE * hashlen) > orderBits)
 801dbf0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dbf2:	2b00      	cmp	r3, #0
 801dbf4:	d10d      	bne.n	801dc12 <ecc_verify_hash+0xd0>
 801dbf6:	683b      	ldr	r3, [r7, #0]
 801dbf8:	00db      	lsls	r3, r3, #3
 801dbfa:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801dbfc:	429a      	cmp	r2, r3
 801dbfe:	d208      	bcs.n	801dc12 <ecc_verify_hash+0xd0>
           mp_rshb(e, (int)(WOLFSSL_BIT_SIZE - (orderBits & 0x7)));
 801dc00:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801dc02:	f003 0307 	and.w	r3, r3, #7
 801dc06:	f1c3 0308 	rsb	r3, r3, #8
 801dc0a:	4619      	mov	r1, r3
 801dc0c:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 801dc0e:	f008 ffc3 	bl	8026b98 <mp_rshb>
      }
   #endif /* HAVE_CAVIUM_V || HAVE_INTEL_QA */
   }
#endif /* WOLFSSL_ASYNC_CRYPT && WC_ASYNC_ENABLE_ECC */

   NEW_MP_INT_SIZE(w, ECC_KEY_MAX_BITS_NONULLCHECK(key), key->heap, DYNAMIC_TYPE_ECC);
 801dc12:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801dc16:	f000 ff37 	bl	801ea88 <wolfSSL_Malloc>
 801dc1a:	6378      	str	r0, [r7, #52]	@ 0x34
 801dc1c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801dc1e:	2b00      	cmp	r3, #0
 801dc20:	d005      	beq.n	801dc2e <ecc_verify_hash+0xec>
 801dc22:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801dc26:	2100      	movs	r1, #0
 801dc28:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801dc2a:	f00a fc4d 	bl	80284c8 <memset>
#ifdef MP_INT_SIZE_CHECK_NULL
   if (w == NULL) {
 801dc2e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801dc30:	2b00      	cmp	r3, #0
 801dc32:	d102      	bne.n	801dc3a <ecc_verify_hash+0xf8>
       err = MEMORY_E;
 801dc34:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801dc38:	647b      	str	r3, [r7, #68]	@ 0x44
   }
#endif

   if (err == MP_OKAY) {
 801dc3a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dc3c:	2b00      	cmp	r3, #0
 801dc3e:	d105      	bne.n	801dc4c <ecc_verify_hash+0x10a>
    #else
        u1 = u1tmp;
        u2 = u2tmp;
    #endif
#else
       u1 = e;
 801dc40:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801dc42:	63fb      	str	r3, [r7, #60]	@ 0x3c
       u2 = w;
 801dc44:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801dc46:	63bb      	str	r3, [r7, #56]	@ 0x38
#endif
       v = w;
 801dc48:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801dc4a:	643b      	str	r3, [r7, #64]	@ 0x40
   }
   if (err == MP_OKAY) {
 801dc4c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dc4e:	2b00      	cmp	r3, #0
 801dc50:	d103      	bne.n	801dc5a <ecc_verify_hash+0x118>
       err = INIT_MP_INT_SIZE(w, ECC_KEY_MAX_BITS_NONULLCHECK(key));
 801dc52:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801dc54:	f008 fd1d 	bl	8026692 <mp_init>
 801dc58:	6478      	str	r0, [r7, #68]	@ 0x44
       err = INIT_MP_INT_SIZE(u2, ECC_KEY_MAX_BITS_NONULLCHECK(key));
   }
#endif

   /* allocate points */
   if (err == MP_OKAY) {
 801dc5a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dc5c:	2b00      	cmp	r3, #0
 801dc5e:	d108      	bne.n	801dc72 <ecc_verify_hash+0x130>
   #ifdef WOLFSSL_NO_MALLOC
       mG = &lcl_mG;
   #endif
       err = wc_ecc_new_point_ex(&mG, key->heap);
 801dc60:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801dc62:	695a      	ldr	r2, [r3, #20]
 801dc64:	f107 0318 	add.w	r3, r7, #24
 801dc68:	4611      	mov	r1, r2
 801dc6a:	4618      	mov	r0, r3
 801dc6c:	f7fe fe2f 	bl	801c8ce <wc_ecc_new_point_ex>
 801dc70:	6478      	str	r0, [r7, #68]	@ 0x44
   }
   if (err == MP_OKAY) {
 801dc72:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dc74:	2b00      	cmp	r3, #0
 801dc76:	d108      	bne.n	801dc8a <ecc_verify_hash+0x148>
   #ifdef WOLFSSL_NO_MALLOC
       mQ = &lcl_mQ;
   #endif
       err = wc_ecc_new_point_ex(&mQ, key->heap);
 801dc78:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801dc7a:	695a      	ldr	r2, [r3, #20]
 801dc7c:	f107 0314 	add.w	r3, r7, #20
 801dc80:	4611      	mov	r1, r2
 801dc82:	4618      	mov	r0, r3
 801dc84:	f7fe fe23 	bl	801c8ce <wc_ecc_new_point_ex>
 801dc88:	6478      	str	r0, [r7, #68]	@ 0x44
   }

   /*  w  = s^-1 mod n */
   if (err == MP_OKAY)
 801dc8a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dc8c:	2b00      	cmp	r3, #0
 801dc8e:	d107      	bne.n	801dca0 <ecc_verify_hash+0x15e>
       err = mp_invmod(s, curve->order, w);
 801dc90:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801dc92:	691b      	ldr	r3, [r3, #16]
 801dc94:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 801dc96:	4619      	mov	r1, r3
 801dc98:	68b8      	ldr	r0, [r7, #8]
 801dc9a:	f008 fe47 	bl	802692c <mp_invmod>
 801dc9e:	6478      	str	r0, [r7, #68]	@ 0x44

   /* u1 = ew */
   if (err == MP_OKAY)
 801dca0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dca2:	2b00      	cmp	r3, #0
 801dca4:	d107      	bne.n	801dcb6 <ecc_verify_hash+0x174>
       err = mp_mulmod(e, w, curve->order, u1);
 801dca6:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801dca8:	691a      	ldr	r2, [r3, #16]
 801dcaa:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801dcac:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 801dcae:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 801dcb0:	f008 fdf3 	bl	802689a <mp_mulmod>
 801dcb4:	6478      	str	r0, [r7, #68]	@ 0x44
        err = BAD_STATE_E;
    }
#endif

   /* u2 = rw */
   if (err == MP_OKAY)
 801dcb6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dcb8:	2b00      	cmp	r3, #0
 801dcba:	d107      	bne.n	801dccc <ecc_verify_hash+0x18a>
       err = mp_mulmod(r, w, curve->order, u2);
 801dcbc:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801dcbe:	691a      	ldr	r2, [r3, #16]
 801dcc0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801dcc2:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 801dcc4:	68f8      	ldr	r0, [r7, #12]
 801dcc6:	f008 fde8 	bl	802689a <mp_mulmod>
 801dcca:	6478      	str	r0, [r7, #68]	@ 0x44
        err = BAD_STATE_E;
    }
#endif

   /* find mG and mQ */
   if (err == MP_OKAY)
 801dccc:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dcce:	2b00      	cmp	r3, #0
 801dcd0:	d108      	bne.n	801dce4 <ecc_verify_hash+0x1a2>
       err = mp_copy(curve->Gx, mG->x);
 801dcd2:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801dcd4:	695a      	ldr	r2, [r3, #20]
 801dcd6:	69bb      	ldr	r3, [r7, #24]
 801dcd8:	681b      	ldr	r3, [r3, #0]
 801dcda:	4619      	mov	r1, r3
 801dcdc:	4610      	mov	r0, r2
 801dcde:	f008 ff24 	bl	8026b2a <mp_copy>
 801dce2:	6478      	str	r0, [r7, #68]	@ 0x44
   if (err == MP_OKAY)
 801dce4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dce6:	2b00      	cmp	r3, #0
 801dce8:	d108      	bne.n	801dcfc <ecc_verify_hash+0x1ba>
       err = mp_copy(curve->Gy, mG->y);
 801dcea:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801dcec:	699a      	ldr	r2, [r3, #24]
 801dcee:	69bb      	ldr	r3, [r7, #24]
 801dcf0:	685b      	ldr	r3, [r3, #4]
 801dcf2:	4619      	mov	r1, r3
 801dcf4:	4610      	mov	r0, r2
 801dcf6:	f008 ff18 	bl	8026b2a <mp_copy>
 801dcfa:	6478      	str	r0, [r7, #68]	@ 0x44
   if (err == MP_OKAY)
 801dcfc:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dcfe:	2b00      	cmp	r3, #0
 801dd00:	d106      	bne.n	801dd10 <ecc_verify_hash+0x1ce>
       err = mp_set(mG->z, 1);
 801dd02:	69bb      	ldr	r3, [r7, #24]
 801dd04:	689b      	ldr	r3, [r3, #8]
 801dd06:	2101      	movs	r1, #1
 801dd08:	4618      	mov	r0, r3
 801dd0a:	f009 f9cb 	bl	80270a4 <mp_set>
 801dd0e:	6478      	str	r0, [r7, #68]	@ 0x44

   if (err == MP_OKAY)
 801dd10:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dd12:	2b00      	cmp	r3, #0
 801dd14:	d108      	bne.n	801dd28 <ecc_verify_hash+0x1e6>
       err = mp_copy(key->pubkey.x, mQ->x);
 801dd16:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801dd18:	699a      	ldr	r2, [r3, #24]
 801dd1a:	697b      	ldr	r3, [r7, #20]
 801dd1c:	681b      	ldr	r3, [r3, #0]
 801dd1e:	4619      	mov	r1, r3
 801dd20:	4610      	mov	r0, r2
 801dd22:	f008 ff02 	bl	8026b2a <mp_copy>
 801dd26:	6478      	str	r0, [r7, #68]	@ 0x44
   if (err == MP_OKAY)
 801dd28:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dd2a:	2b00      	cmp	r3, #0
 801dd2c:	d108      	bne.n	801dd40 <ecc_verify_hash+0x1fe>
       err = mp_copy(key->pubkey.y, mQ->y);
 801dd2e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801dd30:	69da      	ldr	r2, [r3, #28]
 801dd32:	697b      	ldr	r3, [r7, #20]
 801dd34:	685b      	ldr	r3, [r3, #4]
 801dd36:	4619      	mov	r1, r3
 801dd38:	4610      	mov	r0, r2
 801dd3a:	f008 fef6 	bl	8026b2a <mp_copy>
 801dd3e:	6478      	str	r0, [r7, #68]	@ 0x44
   if (err == MP_OKAY)
 801dd40:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dd42:	2b00      	cmp	r3, #0
 801dd44:	d108      	bne.n	801dd58 <ecc_verify_hash+0x216>
       err = mp_copy(key->pubkey.z, mQ->z);
 801dd46:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801dd48:	6a1a      	ldr	r2, [r3, #32]
 801dd4a:	697b      	ldr	r3, [r7, #20]
 801dd4c:	689b      	ldr	r3, [r3, #8]
 801dd4e:	4619      	mov	r1, r3
 801dd50:	4610      	mov	r0, r2
 801dd52:	f008 feea 	bl	8026b2a <mp_copy>
 801dd56:	6478      	str	r0, [r7, #68]	@ 0x44
        if (err == MP_OKAY)
            err = ecc_map(mG, curve->prime, mp);
    }
#else
    /* use Shamir's trick to compute u1*mG + u2*mQ using half the doubles */
    if (err == MP_OKAY) {
 801dd58:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dd5a:	2b00      	cmp	r3, #0
 801dd5c:	d113      	bne.n	801dd86 <ecc_verify_hash+0x244>
        err = ecc_mul2add(mG, u1, mQ, u2, mG, curve->Af, curve->prime,
 801dd5e:	69bc      	ldr	r4, [r7, #24]
 801dd60:	697d      	ldr	r5, [r7, #20]
 801dd62:	69bb      	ldr	r3, [r7, #24]
 801dd64:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 801dd66:	6892      	ldr	r2, [r2, #8]
 801dd68:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 801dd6a:	6849      	ldr	r1, [r1, #4]
 801dd6c:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801dd6e:	6940      	ldr	r0, [r0, #20]
 801dd70:	9003      	str	r0, [sp, #12]
 801dd72:	9102      	str	r1, [sp, #8]
 801dd74:	9201      	str	r2, [sp, #4]
 801dd76:	9300      	str	r3, [sp, #0]
 801dd78:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801dd7a:	462a      	mov	r2, r5
 801dd7c:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 801dd7e:	4620      	mov	r0, r4
 801dd80:	f7ff face 	bl	801d320 <ecc_mul2add>
 801dd84:	6478      	str	r0, [r7, #68]	@ 0x44
    }
#endif /* ECC_SHAMIR */
#endif /* FREESCALE_LTC_ECC */

   /* v = X_x1 mod n */
   if (err == MP_OKAY)
 801dd86:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dd88:	2b00      	cmp	r3, #0
 801dd8a:	d108      	bne.n	801dd9e <ecc_verify_hash+0x25c>
       err = mp_mod(mG->x, curve->order, v);
 801dd8c:	69bb      	ldr	r3, [r7, #24]
 801dd8e:	6818      	ldr	r0, [r3, #0]
 801dd90:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801dd92:	691b      	ldr	r3, [r3, #16]
 801dd94:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 801dd96:	4619      	mov	r1, r3
 801dd98:	f008 fdb8 	bl	802690c <mp_mod>
 801dd9c:	6478      	str	r0, [r7, #68]	@ 0x44

   /* does v == r */
   if (err == MP_OKAY) {
 801dd9e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dda0:	2b00      	cmp	r3, #0
 801dda2:	d109      	bne.n	801ddb8 <ecc_verify_hash+0x276>
       if (mp_cmp(v, r) == MP_EQ)
 801dda4:	68f9      	ldr	r1, [r7, #12]
 801dda6:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 801dda8:	f008 fe06 	bl	80269b8 <mp_cmp>
 801ddac:	4603      	mov	r3, r0
 801ddae:	2b00      	cmp	r3, #0
 801ddb0:	d102      	bne.n	801ddb8 <ecc_verify_hash+0x276>
           *res = 1;
 801ddb2:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801ddb4:	2201      	movs	r2, #1
 801ddb6:	601a      	str	r2, [r3, #0]
           *res = 0;
#endif
   }

   /* cleanup */
   wc_ecc_del_point_ex(mG, key->heap);
 801ddb8:	69ba      	ldr	r2, [r7, #24]
 801ddba:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801ddbc:	695b      	ldr	r3, [r3, #20]
 801ddbe:	4619      	mov	r1, r3
 801ddc0:	4610      	mov	r0, r2
 801ddc2:	f7fe fdd9 	bl	801c978 <wc_ecc_del_point_ex>
   wc_ecc_del_point_ex(mQ, key->heap);
 801ddc6:	697a      	ldr	r2, [r7, #20]
 801ddc8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801ddca:	695b      	ldr	r3, [r3, #20]
 801ddcc:	4619      	mov	r1, r3
 801ddce:	4610      	mov	r0, r2
 801ddd0:	f7fe fdd2 	bl	801c978 <wc_ecc_del_point_ex>

   mp_clear(e);
 801ddd4:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 801ddd6:	f008 fce6 	bl	80267a6 <mp_clear>
   mp_clear(w);
 801ddda:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801dddc:	f008 fce3 	bl	80267a6 <mp_clear>
   FREE_MP_INT_SIZE(w, key->heap, DYNAMIC_TYPE_ECC);
 801dde0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801dde2:	627b      	str	r3, [r7, #36]	@ 0x24
 801dde4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801dde6:	2b00      	cmp	r3, #0
 801dde8:	d002      	beq.n	801ddf0 <ecc_verify_hash+0x2ae>
 801ddea:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 801ddec:	f000 fe68 	bl	801eac0 <wolfSSL_Free>
   XFREE(u1, key->heap, DYNAMIC_TYPE_ECC);
   XFREE(u2, key->heap, DYNAMIC_TYPE_ECC);
#endif
#endif
#if !defined(WOLFSSL_ASYNC_CRYPT) || !defined(HAVE_CAVIUM_V)
   FREE_MP_INT_SIZE(e_lcl, key->heap, DYNAMIC_TYPE_ECC);
 801ddf0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801ddf2:	623b      	str	r3, [r7, #32]
 801ddf4:	6a3b      	ldr	r3, [r7, #32]
 801ddf6:	2b00      	cmp	r3, #0
 801ddf8:	d002      	beq.n	801de00 <ecc_verify_hash+0x2be>
 801ddfa:	6a38      	ldr	r0, [r7, #32]
 801ddfc:	f000 fe60 	bl	801eac0 <wolfSSL_Free>
#endif

   return err;
 801de00:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
}
 801de02:	4618      	mov	r0, r3
 801de04:	3748      	adds	r7, #72	@ 0x48
 801de06:	46bd      	mov	sp, r7
 801de08:	bdb0      	pop	{r4, r5, r7, pc}

0801de0a <wc_ecc_verify_hash_ex>:
               Caller should check the *res value to determine if the signature
               is valid or invalid. Other negative values are returned on error.
*/
int wc_ecc_verify_hash_ex(mp_int *r, mp_int *s, const byte* hash,
                    word32 hashlen, int* res, ecc_key* key)
{
 801de0a:	b580      	push	{r7, lr}
 801de0c:	b09e      	sub	sp, #120	@ 0x78
 801de0e:	af04      	add	r7, sp, #16
 801de10:	60f8      	str	r0, [r7, #12]
 801de12:	60b9      	str	r1, [r7, #8]
 801de14:	607a      	str	r2, [r7, #4]
 801de16:	603b      	str	r3, [r7, #0]
    return stm32_ecc_verify_hash_ex(r, s, hash, hashlen, res, key);
#elif defined(WOLFSSL_PSOC6_CRYPTO)
    return psoc6_ecc_verify_hash_ex(r, s, hash, hashlen, res, key);
#else
   int           err;
   word32        keySz = 0;
 801de18:	2300      	movs	r3, #0
 801de1a:	65bb      	str	r3, [r7, #88]	@ 0x58
   byte sigRS[MAX_ECC_BYTES*2];
#elif defined(WOLFSSL_XILINX_CRYPT_VERSAL)
   byte sigRS[ECC_MAX_CRYPTO_HW_SIZE * 2];
   byte hashcopy[ECC_MAX_CRYPTO_HW_SIZE] = {0};
#else
   int curveLoaded = 0;
 801de1c:	2300      	movs	r3, #0
 801de1e:	663b      	str	r3, [r7, #96]	@ 0x60
   DECLARE_CURVE_SPECS(ECC_CURVE_FIELD_COUNT);
 801de20:	2300      	movs	r3, #0
 801de22:	65fb      	str	r3, [r7, #92]	@ 0x5c
 801de24:	f107 0318 	add.w	r3, r7, #24
 801de28:	617b      	str	r3, [r7, #20]
 801de2a:	697b      	ldr	r3, [r7, #20]
 801de2c:	222c      	movs	r2, #44	@ 0x2c
 801de2e:	2100      	movs	r1, #0
 801de30:	4618      	mov	r0, r3
 801de32:	f00a fb49 	bl	80284c8 <memset>
 801de36:	697b      	ldr	r3, [r7, #20]
 801de38:	2206      	movs	r2, #6
 801de3a:	621a      	str	r2, [r3, #32]
#endif

   if (r == NULL || s == NULL || hash == NULL || res == NULL || key == NULL)
 801de3c:	68fb      	ldr	r3, [r7, #12]
 801de3e:	2b00      	cmp	r3, #0
 801de40:	d00b      	beq.n	801de5a <wc_ecc_verify_hash_ex+0x50>
 801de42:	68bb      	ldr	r3, [r7, #8]
 801de44:	2b00      	cmp	r3, #0
 801de46:	d008      	beq.n	801de5a <wc_ecc_verify_hash_ex+0x50>
 801de48:	687b      	ldr	r3, [r7, #4]
 801de4a:	2b00      	cmp	r3, #0
 801de4c:	d005      	beq.n	801de5a <wc_ecc_verify_hash_ex+0x50>
 801de4e:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801de50:	2b00      	cmp	r3, #0
 801de52:	d002      	beq.n	801de5a <wc_ecc_verify_hash_ex+0x50>
 801de54:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801de56:	2b00      	cmp	r3, #0
 801de58:	d102      	bne.n	801de60 <wc_ecc_verify_hash_ex+0x56>
       return ECC_BAD_ARG_E;
 801de5a:	f06f 03a9 	mvn.w	r3, #169	@ 0xa9
 801de5e:	e0d1      	b.n	801e004 <wc_ecc_verify_hash_ex+0x1fa>

   /* default to invalid signature */
   *res = 0;
 801de60:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801de62:	2200      	movs	r2, #0
 801de64:	601a      	str	r2, [r3, #0]

   /* is the IDX valid ?  */
   if (wc_ecc_is_valid_idx(key->idx) == 0 || key->dp == NULL) {
 801de66:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801de68:	685b      	ldr	r3, [r3, #4]
 801de6a:	4618      	mov	r0, r3
 801de6c:	f7fe fdf8 	bl	801ca60 <wc_ecc_is_valid_idx>
 801de70:	4603      	mov	r3, r0
 801de72:	2b00      	cmp	r3, #0
 801de74:	d003      	beq.n	801de7e <wc_ecc_verify_hash_ex+0x74>
 801de76:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801de78:	691b      	ldr	r3, [r3, #16]
 801de7a:	2b00      	cmp	r3, #0
 801de7c:	d102      	bne.n	801de84 <wc_ecc_verify_hash_ex+0x7a>
      return ECC_BAD_ARG_E;
 801de7e:	f06f 03a9 	mvn.w	r3, #169	@ 0xa9
 801de82:	e0bf      	b.n	801e004 <wc_ecc_verify_hash_ex+0x1fa>
   }

   err = wc_ecc_check_r_s_range(key, r, s);
 801de84:	68ba      	ldr	r2, [r7, #8]
 801de86:	68f9      	ldr	r1, [r7, #12]
 801de88:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 801de8a:	f7ff fdcd 	bl	801da28 <wc_ecc_check_r_s_range>
 801de8e:	6678      	str	r0, [r7, #100]	@ 0x64
   if (err != MP_OKAY) {
 801de90:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801de92:	2b00      	cmp	r3, #0
 801de94:	d001      	beq.n	801de9a <wc_ecc_verify_hash_ex+0x90>
      return err;
 801de96:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801de98:	e0b4      	b.n	801e004 <wc_ecc_verify_hash_ex+0x1fa>
   }

   keySz = (word32)key->dp->size;
 801de9a:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801de9c:	691b      	ldr	r3, [r3, #16]
 801de9e:	681b      	ldr	r3, [r3, #0]
 801dea0:	65bb      	str	r3, [r7, #88]	@ 0x58
    }
#endif

#else
  /* checking if private key with no public part */
  if (key->type == ECC_PRIVATEKEY_ONLY) {
 801dea2:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801dea4:	681b      	ldr	r3, [r3, #0]
 801dea6:	2b03      	cmp	r3, #3
 801dea8:	d143      	bne.n	801df32 <wc_ecc_verify_hash_ex+0x128>
      WOLFSSL_MSG("Verify called with private key, generating public part");
      ALLOC_CURVE_SPECS(ECC_CURVE_FIELD_COUNT, err);
 801deaa:	f640 5008 	movw	r0, #3336	@ 0xd08
 801deae:	f000 fdeb 	bl	801ea88 <wolfSSL_Malloc>
 801deb2:	65f8      	str	r0, [r7, #92]	@ 0x5c
 801deb4:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801deb6:	2b00      	cmp	r3, #0
 801deb8:	d103      	bne.n	801dec2 <wc_ecc_verify_hash_ex+0xb8>
 801deba:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801debe:	667b      	str	r3, [r7, #100]	@ 0x64
 801dec0:	e002      	b.n	801dec8 <wc_ecc_verify_hash_ex+0xbe>
 801dec2:	697b      	ldr	r3, [r7, #20]
 801dec4:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801dec6:	61da      	str	r2, [r3, #28]
      if (err != MP_OKAY) {
 801dec8:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801deca:	2b00      	cmp	r3, #0
 801decc:	d001      	beq.n	801ded2 <wc_ecc_verify_hash_ex+0xc8>
          return err;
 801dece:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801ded0:	e098      	b.n	801e004 <wc_ecc_verify_hash_ex+0x1fa>
      }
      err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ALL);
 801ded2:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801ded4:	691b      	ldr	r3, [r3, #16]
 801ded6:	f107 0114 	add.w	r1, r7, #20
 801deda:	223f      	movs	r2, #63	@ 0x3f
 801dedc:	4618      	mov	r0, r3
 801dede:	f7fc fd34 	bl	801a94a <wc_ecc_curve_load>
 801dee2:	6678      	str	r0, [r7, #100]	@ 0x64
      if (err != MP_OKAY) {
 801dee4:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801dee6:	2b00      	cmp	r3, #0
 801dee8:	d009      	beq.n	801defe <wc_ecc_verify_hash_ex+0xf4>
          FREE_CURVE_SPECS();
 801deea:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801deec:	653b      	str	r3, [r7, #80]	@ 0x50
 801deee:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801def0:	2b00      	cmp	r3, #0
 801def2:	d002      	beq.n	801defa <wc_ecc_verify_hash_ex+0xf0>
 801def4:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 801def6:	f000 fde3 	bl	801eac0 <wolfSSL_Free>
          return err;
 801defa:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801defc:	e082      	b.n	801e004 <wc_ecc_verify_hash_ex+0x1fa>
      }
      err = ecc_make_pub_ex(key, curve, NULL, NULL);
 801defe:	6979      	ldr	r1, [r7, #20]
 801df00:	2300      	movs	r3, #0
 801df02:	2200      	movs	r2, #0
 801df04:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 801df06:	f7fe fe8d 	bl	801cc24 <ecc_make_pub_ex>
 801df0a:	6678      	str	r0, [r7, #100]	@ 0x64
      if (err != MP_OKAY) {
 801df0c:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801df0e:	2b00      	cmp	r3, #0
 801df10:	d00d      	beq.n	801df2e <wc_ecc_verify_hash_ex+0x124>
           WOLFSSL_MSG("Unable to extract public key");
           wc_ecc_curve_free(curve);
 801df12:	697b      	ldr	r3, [r7, #20]
 801df14:	4618      	mov	r0, r3
 801df16:	f7fc fccd 	bl	801a8b4 <wc_ecc_curve_free>
           FREE_CURVE_SPECS();
 801df1a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801df1c:	657b      	str	r3, [r7, #84]	@ 0x54
 801df1e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801df20:	2b00      	cmp	r3, #0
 801df22:	d002      	beq.n	801df2a <wc_ecc_verify_hash_ex+0x120>
 801df24:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801df26:	f000 fdcb 	bl	801eac0 <wolfSSL_Free>
           return err;
 801df2a:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801df2c:	e06a      	b.n	801e004 <wc_ecc_verify_hash_ex+0x1fa>
      }
      curveLoaded = 1;
 801df2e:	2301      	movs	r3, #1
 801df30:	663b      	str	r3, [r7, #96]	@ 0x60
  }

  err = ecc_verify_hash_sp(r, s, hash, hashlen, res, key);
 801df32:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801df34:	9301      	str	r3, [sp, #4]
 801df36:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801df38:	9300      	str	r3, [sp, #0]
 801df3a:	683b      	ldr	r3, [r7, #0]
 801df3c:	687a      	ldr	r2, [r7, #4]
 801df3e:	68b9      	ldr	r1, [r7, #8]
 801df40:	68f8      	ldr	r0, [r7, #12]
 801df42:	f7ff fdef 	bl	801db24 <ecc_verify_hash_sp>
 801df46:	6678      	str	r0, [r7, #100]	@ 0x64
  if (err != WC_NO_ERR_TRACE(NOT_COMPILED_IN)) {
 801df48:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801df4a:	f113 0fae 	cmn.w	r3, #174	@ 0xae
 801df4e:	d010      	beq.n	801df72 <wc_ecc_verify_hash_ex+0x168>
      if (curveLoaded) {
 801df50:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801df52:	2b00      	cmp	r3, #0
 801df54:	d00b      	beq.n	801df6e <wc_ecc_verify_hash_ex+0x164>
           wc_ecc_curve_free(curve);
 801df56:	697b      	ldr	r3, [r7, #20]
 801df58:	4618      	mov	r0, r3
 801df5a:	f7fc fcab 	bl	801a8b4 <wc_ecc_curve_free>
           FREE_CURVE_SPECS();
 801df5e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801df60:	647b      	str	r3, [r7, #68]	@ 0x44
 801df62:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801df64:	2b00      	cmp	r3, #0
 801df66:	d002      	beq.n	801df6e <wc_ecc_verify_hash_ex+0x164>
 801df68:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 801df6a:	f000 fda9 	bl	801eac0 <wolfSSL_Free>
      }
      return err;
 801df6e:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801df70:	e048      	b.n	801e004 <wc_ecc_verify_hash_ex+0x1fa>
  }

#if !defined(WOLFSSL_SP_MATH) || defined(FREESCALE_LTC_ECC)
   if (!curveLoaded) {
 801df72:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801df74:	2b00      	cmp	r3, #0
 801df76:	d12b      	bne.n	801dfd0 <wc_ecc_verify_hash_ex+0x1c6>
       err = 0; /* potential for NOT_COMPILED_IN error from SP attempt */
 801df78:	2300      	movs	r3, #0
 801df7a:	667b      	str	r3, [r7, #100]	@ 0x64
       ALLOC_CURVE_SPECS(ECC_CURVE_FIELD_COUNT, err);
 801df7c:	f640 5008 	movw	r0, #3336	@ 0xd08
 801df80:	f000 fd82 	bl	801ea88 <wolfSSL_Malloc>
 801df84:	65f8      	str	r0, [r7, #92]	@ 0x5c
 801df86:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801df88:	2b00      	cmp	r3, #0
 801df8a:	d103      	bne.n	801df94 <wc_ecc_verify_hash_ex+0x18a>
 801df8c:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801df90:	667b      	str	r3, [r7, #100]	@ 0x64
 801df92:	e002      	b.n	801df9a <wc_ecc_verify_hash_ex+0x190>
 801df94:	697b      	ldr	r3, [r7, #20]
 801df96:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801df98:	61da      	str	r2, [r3, #28]
       if (err != 0) {
 801df9a:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801df9c:	2b00      	cmp	r3, #0
 801df9e:	d001      	beq.n	801dfa4 <wc_ecc_verify_hash_ex+0x19a>
          return err;
 801dfa0:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801dfa2:	e02f      	b.n	801e004 <wc_ecc_verify_hash_ex+0x1fa>
       }
       /* read in the specs for this curve */
       err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ALL);
 801dfa4:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801dfa6:	691b      	ldr	r3, [r3, #16]
 801dfa8:	f107 0114 	add.w	r1, r7, #20
 801dfac:	223f      	movs	r2, #63	@ 0x3f
 801dfae:	4618      	mov	r0, r3
 801dfb0:	f7fc fccb 	bl	801a94a <wc_ecc_curve_load>
 801dfb4:	6678      	str	r0, [r7, #100]	@ 0x64
       if (err != 0) {
 801dfb6:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801dfb8:	2b00      	cmp	r3, #0
 801dfba:	d009      	beq.n	801dfd0 <wc_ecc_verify_hash_ex+0x1c6>
          FREE_CURVE_SPECS();
 801dfbc:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801dfbe:	64fb      	str	r3, [r7, #76]	@ 0x4c
 801dfc0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801dfc2:	2b00      	cmp	r3, #0
 801dfc4:	d002      	beq.n	801dfcc <wc_ecc_verify_hash_ex+0x1c2>
 801dfc6:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 801dfc8:	f000 fd7a 	bl	801eac0 <wolfSSL_Free>
          return err;
 801dfcc:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801dfce:	e019      	b.n	801e004 <wc_ecc_verify_hash_ex+0x1fa>
       }
   }

   err = ecc_verify_hash(r, s, hash, hashlen, res, key, curve);
 801dfd0:	697b      	ldr	r3, [r7, #20]
 801dfd2:	9302      	str	r3, [sp, #8]
 801dfd4:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801dfd6:	9301      	str	r3, [sp, #4]
 801dfd8:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801dfda:	9300      	str	r3, [sp, #0]
 801dfdc:	683b      	ldr	r3, [r7, #0]
 801dfde:	687a      	ldr	r2, [r7, #4]
 801dfe0:	68b9      	ldr	r1, [r7, #8]
 801dfe2:	68f8      	ldr	r0, [r7, #12]
 801dfe4:	f7ff fdad 	bl	801db42 <ecc_verify_hash>
 801dfe8:	6678      	str	r0, [r7, #100]	@ 0x64
#endif /* !WOLFSSL_SP_MATH || FREESCALE_LTC_ECC */

   (void)curveLoaded;
   wc_ecc_curve_free(curve);
 801dfea:	697b      	ldr	r3, [r7, #20]
 801dfec:	4618      	mov	r0, r3
 801dfee:	f7fc fc61 	bl	801a8b4 <wc_ecc_curve_free>
   FREE_CURVE_SPECS();
 801dff2:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801dff4:	64bb      	str	r3, [r7, #72]	@ 0x48
 801dff6:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801dff8:	2b00      	cmp	r3, #0
 801dffa:	d002      	beq.n	801e002 <wc_ecc_verify_hash_ex+0x1f8>
 801dffc:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 801dffe:	f000 fd5f 	bl	801eac0 <wolfSSL_Free>
#endif /* HAVE_ECC_VERIFY_HELPER */

   (void)keySz;
   (void)hashlen;

   return err;
 801e002:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
#endif /* WOLFSSL_STM32_PKA */
}
 801e004:	4618      	mov	r0, r3
 801e006:	3768      	adds	r7, #104	@ 0x68
 801e008:	46bd      	mov	sp, r7
 801e00a:	bd80      	pop	{r7, pc}

0801e00c <wc_ecc_import_x963_ex>:

#ifdef HAVE_ECC_KEY_IMPORT
/* import public ECC key in ANSI X9.63 format */
int wc_ecc_import_x963_ex(const byte* in, word32 inLen, ecc_key* key,
                          int curve_id)
{
 801e00c:	b580      	push	{r7, lr}
 801e00e:	b088      	sub	sp, #32
 801e010:	af00      	add	r7, sp, #0
 801e012:	60f8      	str	r0, [r7, #12]
 801e014:	60b9      	str	r1, [r7, #8]
 801e016:	607a      	str	r2, [r7, #4]
 801e018:	603b      	str	r3, [r7, #0]
    int err = MP_OKAY;
 801e01a:	2300      	movs	r3, #0
 801e01c:	61fb      	str	r3, [r7, #28]
#ifdef HAVE_COMP_KEY
    int compressed = 0;
#endif
    int keysize = 0;
 801e01e:	2300      	movs	r3, #0
 801e020:	61bb      	str	r3, [r7, #24]
    byte pointType;
#ifdef WOLFSSL_CRYPTOCELL
    const CRYS_ECPKI_Domain_t* pDomain;
    CRYS_ECPKI_BUILD_TempData_t tempBuff;
#endif
    if (in == NULL || key == NULL)
 801e022:	68fb      	ldr	r3, [r7, #12]
 801e024:	2b00      	cmp	r3, #0
 801e026:	d002      	beq.n	801e02e <wc_ecc_import_x963_ex+0x22>
 801e028:	687b      	ldr	r3, [r7, #4]
 801e02a:	2b00      	cmp	r3, #0
 801e02c:	d102      	bne.n	801e034 <wc_ecc_import_x963_ex+0x28>
        return BAD_FUNC_ARG;
 801e02e:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801e032:	e0a2      	b.n	801e17a <wc_ecc_import_x963_ex+0x16e>

    /* must be odd */
    if ((inLen & 1) == 0) {
 801e034:	68bb      	ldr	r3, [r7, #8]
 801e036:	f003 0301 	and.w	r3, r3, #1
 801e03a:	2b00      	cmp	r3, #0
 801e03c:	d102      	bne.n	801e044 <wc_ecc_import_x963_ex+0x38>
        return ECC_BAD_ARG_E;
 801e03e:	f06f 03a9 	mvn.w	r3, #169	@ 0xa9
 801e042:	e09a      	b.n	801e17a <wc_ecc_import_x963_ex+0x16e>
    }

    /* make sure required variables are reset */
    wc_ecc_reset(key);
 801e044:	6878      	ldr	r0, [r7, #4]
 801e046:	f7fe fde0 	bl	801cc0a <wc_ecc_reset>

    /* init key */
    #ifdef ALT_ECC_SIZE
        key->pubkey.x = (mp_int*)&key->pubkey.xyz[0];
 801e04a:	687b      	ldr	r3, [r7, #4]
 801e04c:	f103 0224 	add.w	r2, r3, #36	@ 0x24
 801e050:	687b      	ldr	r3, [r7, #4]
 801e052:	619a      	str	r2, [r3, #24]
        key->pubkey.y = (mp_int*)&key->pubkey.xyz[1];
 801e054:	687b      	ldr	r3, [r7, #4]
 801e056:	f103 0274 	add.w	r2, r3, #116	@ 0x74
 801e05a:	687b      	ldr	r3, [r7, #4]
 801e05c:	61da      	str	r2, [r3, #28]
        key->pubkey.z = (mp_int*)&key->pubkey.xyz[2];
 801e05e:	687b      	ldr	r3, [r7, #4]
 801e060:	f103 02c4 	add.w	r2, r3, #196	@ 0xc4
 801e064:	687b      	ldr	r3, [r7, #4]
 801e066:	621a      	str	r2, [r3, #32]
        alt_fp_init(key->pubkey.x);
 801e068:	687b      	ldr	r3, [r7, #4]
 801e06a:	699b      	ldr	r3, [r3, #24]
 801e06c:	4618      	mov	r0, r3
 801e06e:	f7fc fd87 	bl	801ab80 <alt_fp_init>
        alt_fp_init(key->pubkey.y);
 801e072:	687b      	ldr	r3, [r7, #4]
 801e074:	69db      	ldr	r3, [r3, #28]
 801e076:	4618      	mov	r0, r3
 801e078:	f7fc fd82 	bl	801ab80 <alt_fp_init>
        alt_fp_init(key->pubkey.z);
 801e07c:	687b      	ldr	r3, [r7, #4]
 801e07e:	6a1b      	ldr	r3, [r3, #32]
 801e080:	4618      	mov	r0, r3
 801e082:	f7fc fd7d 	bl	801ab80 <alt_fp_init>
        key->k = (mp_int*)key->ka;
 801e086:	687b      	ldr	r3, [r7, #4]
 801e088:	f503 728e 	add.w	r2, r3, #284	@ 0x11c
 801e08c:	687b      	ldr	r3, [r7, #4]
 801e08e:	f8c3 2118 	str.w	r2, [r3, #280]	@ 0x118
        alt_fp_init(key->k);
 801e092:	687b      	ldr	r3, [r7, #4]
 801e094:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 801e098:	4618      	mov	r0, r3
 801e09a:	f7fc fd71 	bl	801ab80 <alt_fp_init>
    #else
                                                                key->kb, key->ku
    #endif
                            );
    #endif
    if (err != MP_OKAY)
 801e09e:	69fb      	ldr	r3, [r7, #28]
 801e0a0:	2b00      	cmp	r3, #0
 801e0a2:	d002      	beq.n	801e0aa <wc_ecc_import_x963_ex+0x9e>
        return MEMORY_E;
 801e0a4:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801e0a8:	e067      	b.n	801e17a <wc_ecc_import_x963_ex+0x16e>
#endif

    SAVE_VECTOR_REGISTERS(return _svr_ret;);

    /* check for point type (4, 2, or 3) */
    pointType = in[0];
 801e0aa:	68fb      	ldr	r3, [r7, #12]
 801e0ac:	781b      	ldrb	r3, [r3, #0]
 801e0ae:	75fb      	strb	r3, [r7, #23]
    if (pointType != ECC_POINT_UNCOMP && pointType != ECC_POINT_COMP_EVEN &&
 801e0b0:	7dfb      	ldrb	r3, [r7, #23]
 801e0b2:	2b04      	cmp	r3, #4
 801e0b4:	d008      	beq.n	801e0c8 <wc_ecc_import_x963_ex+0xbc>
 801e0b6:	7dfb      	ldrb	r3, [r7, #23]
 801e0b8:	2b02      	cmp	r3, #2
 801e0ba:	d005      	beq.n	801e0c8 <wc_ecc_import_x963_ex+0xbc>
 801e0bc:	7dfb      	ldrb	r3, [r7, #23]
 801e0be:	2b03      	cmp	r3, #3
 801e0c0:	d002      	beq.n	801e0c8 <wc_ecc_import_x963_ex+0xbc>
                                         pointType != ECC_POINT_COMP_ODD) {
        err = ASN_PARSE_E;
 801e0c2:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801e0c6:	61fb      	str	r3, [r7, #28]
    }

    if (pointType == ECC_POINT_COMP_EVEN || pointType == ECC_POINT_COMP_ODD) {
 801e0c8:	7dfb      	ldrb	r3, [r7, #23]
 801e0ca:	2b02      	cmp	r3, #2
 801e0cc:	d002      	beq.n	801e0d4 <wc_ecc_import_x963_ex+0xc8>
 801e0ce:	7dfb      	ldrb	r3, [r7, #23]
 801e0d0:	2b03      	cmp	r3, #3
 801e0d2:	d102      	bne.n	801e0da <wc_ecc_import_x963_ex+0xce>
    #ifdef HAVE_COMP_KEY
        compressed = 1;
    #else
        err = NOT_COMPILED_IN;
 801e0d4:	f06f 03ad 	mvn.w	r3, #173	@ 0xad
 801e0d8:	61fb      	str	r3, [r7, #28]
    #endif
    }

    /* adjust to skip first byte */
    inLen -= 1;
 801e0da:	68bb      	ldr	r3, [r7, #8]
 801e0dc:	3b01      	subs	r3, #1
 801e0de:	60bb      	str	r3, [r7, #8]
    in += 1;
 801e0e0:	68fb      	ldr	r3, [r7, #12]
 801e0e2:	3301      	adds	r3, #1
 801e0e4:	60fb      	str	r3, [r7, #12]
    }
#elif defined(WOLFSSL_KCAPI_ECC)
    XMEMCPY(key->pubkey_raw, (byte*)in, inLen);
#endif

    if (err == MP_OKAY) {
 801e0e6:	69fb      	ldr	r3, [r7, #28]
 801e0e8:	2b00      	cmp	r3, #0
 801e0ea:	d10b      	bne.n	801e104 <wc_ecc_import_x963_ex+0xf8>
        if (compressed)
            inLen = inLen*2 + 1;  /* used uncompressed len */
    #endif

        /* determine key size */
        keysize = (int)(inLen>>1);
 801e0ec:	68bb      	ldr	r3, [r7, #8]
 801e0ee:	085b      	lsrs	r3, r3, #1
 801e0f0:	61bb      	str	r3, [r7, #24]
        /* NOTE: FIPS v6.0.0 or greater, no restriction on imported keys, only
         *       on created keys or signatures */
        err = wc_ecc_set_curve(key, keysize, curve_id);
 801e0f2:	683a      	ldr	r2, [r7, #0]
 801e0f4:	69b9      	ldr	r1, [r7, #24]
 801e0f6:	6878      	ldr	r0, [r7, #4]
 801e0f8:	f7fc fcd4 	bl	801aaa4 <wc_ecc_set_curve>
 801e0fc:	61f8      	str	r0, [r7, #28]
        key->type = ECC_PUBLICKEY;
 801e0fe:	687b      	ldr	r3, [r7, #4]
 801e100:	2201      	movs	r2, #1
 801e102:	601a      	str	r2, [r3, #0]
    }

    /* read data */
    if (err == MP_OKAY)
 801e104:	69fb      	ldr	r3, [r7, #28]
 801e106:	2b00      	cmp	r3, #0
 801e108:	d107      	bne.n	801e11a <wc_ecc_import_x963_ex+0x10e>
        err = mp_read_unsigned_bin(key->pubkey.x, in, (word32)keysize);
 801e10a:	687b      	ldr	r3, [r7, #4]
 801e10c:	699b      	ldr	r3, [r3, #24]
 801e10e:	69ba      	ldr	r2, [r7, #24]
 801e110:	68f9      	ldr	r1, [r7, #12]
 801e112:	4618      	mov	r0, r3
 801e114:	f008 fc96 	bl	8026a44 <mp_read_unsigned_bin>
 801e118:	61f8      	str	r0, [r7, #28]
        }
#endif
    }
#endif /* HAVE_COMP_KEY */

    if (err == MP_OKAY) {
 801e11a:	69fb      	ldr	r3, [r7, #28]
 801e11c:	2b00      	cmp	r3, #0
 801e11e:	d109      	bne.n	801e134 <wc_ecc_import_x963_ex+0x128>
    #ifdef HAVE_COMP_KEY
        if (compressed == 0)
    #endif
        {
            err = mp_read_unsigned_bin(key->pubkey.y, in + keysize,
 801e120:	687b      	ldr	r3, [r7, #4]
 801e122:	69d8      	ldr	r0, [r3, #28]
 801e124:	69bb      	ldr	r3, [r7, #24]
 801e126:	68fa      	ldr	r2, [r7, #12]
 801e128:	4413      	add	r3, r2
 801e12a:	69ba      	ldr	r2, [r7, #24]
 801e12c:	4619      	mov	r1, r3
 801e12e:	f008 fc89 	bl	8026a44 <mp_read_unsigned_bin>
 801e132:	61f8      	str	r0, [r7, #28]
                (word32)keysize);
        }
    }
    if (err == MP_OKAY)
 801e134:	69fb      	ldr	r3, [r7, #28]
 801e136:	2b00      	cmp	r3, #0
 801e138:	d106      	bne.n	801e148 <wc_ecc_import_x963_ex+0x13c>
        err = mp_set(key->pubkey.z, 1);
 801e13a:	687b      	ldr	r3, [r7, #4]
 801e13c:	6a1b      	ldr	r3, [r3, #32]
 801e13e:	2101      	movs	r1, #1
 801e140:	4618      	mov	r0, r3
 801e142:	f008 ffaf 	bl	80270a4 <mp_set>
 801e146:	61f8      	str	r0, [r7, #28]
    if (err == MP_OKAY) {
        err = wc_MAXQ10XX_EccSetKey(key, keysize);
    }
#endif

    if (err != MP_OKAY) {
 801e148:	69fb      	ldr	r3, [r7, #28]
 801e14a:	2b00      	cmp	r3, #0
 801e14c:	d014      	beq.n	801e178 <wc_ecc_import_x963_ex+0x16c>
        mp_clear(key->pubkey.x);
 801e14e:	687b      	ldr	r3, [r7, #4]
 801e150:	699b      	ldr	r3, [r3, #24]
 801e152:	4618      	mov	r0, r3
 801e154:	f008 fb27 	bl	80267a6 <mp_clear>
        mp_clear(key->pubkey.y);
 801e158:	687b      	ldr	r3, [r7, #4]
 801e15a:	69db      	ldr	r3, [r3, #28]
 801e15c:	4618      	mov	r0, r3
 801e15e:	f008 fb22 	bl	80267a6 <mp_clear>
        mp_clear(key->pubkey.z);
 801e162:	687b      	ldr	r3, [r7, #4]
 801e164:	6a1b      	ldr	r3, [r3, #32]
 801e166:	4618      	mov	r0, r3
 801e168:	f008 fb1d 	bl	80267a6 <mp_clear>
        mp_clear(key->k);
 801e16c:	687b      	ldr	r3, [r7, #4]
 801e16e:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 801e172:	4618      	mov	r0, r3
 801e174:	f008 fb17 	bl	80267a6 <mp_clear>
    }

    RESTORE_VECTOR_REGISTERS();

    return err;
 801e178:	69fb      	ldr	r3, [r7, #28]
}
 801e17a:	4618      	mov	r0, r3
 801e17c:	3720      	adds	r7, #32
 801e17e:	46bd      	mov	sp, r7
 801e180:	bd80      	pop	{r7, pc}

0801e182 <wc_ecc_import_private_key_ex>:
#ifdef HAVE_ECC_KEY_IMPORT
/* import private key, public part optional if (pub) passed as NULL */
int wc_ecc_import_private_key_ex(const byte* priv, word32 privSz,
                                 const byte* pub, word32 pubSz, ecc_key* key,
                                 int curve_id)
{
 801e182:	b580      	push	{r7, lr}
 801e184:	b086      	sub	sp, #24
 801e186:	af00      	add	r7, sp, #0
 801e188:	60f8      	str	r0, [r7, #12]
 801e18a:	60b9      	str	r1, [r7, #8]
 801e18c:	607a      	str	r2, [r7, #4]
 801e18e:	603b      	str	r3, [r7, #0]
    int ret;
#ifdef WOLFSSL_CRYPTOCELL
    const CRYS_ECPKI_Domain_t* pDomain;
#endif
    if (key == NULL || priv == NULL)
 801e190:	6a3b      	ldr	r3, [r7, #32]
 801e192:	2b00      	cmp	r3, #0
 801e194:	d002      	beq.n	801e19c <wc_ecc_import_private_key_ex+0x1a>
 801e196:	68fb      	ldr	r3, [r7, #12]
 801e198:	2b00      	cmp	r3, #0
 801e19a:	d102      	bne.n	801e1a2 <wc_ecc_import_private_key_ex+0x20>
        return BAD_FUNC_ARG;
 801e19c:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801e1a0:	e036      	b.n	801e210 <wc_ecc_import_private_key_ex+0x8e>

    /* public optional, NULL if only importing private */
    if (pub != NULL) {
 801e1a2:	687b      	ldr	r3, [r7, #4]
 801e1a4:	2b00      	cmp	r3, #0
 801e1a6:	d017      	beq.n	801e1d8 <wc_ecc_import_private_key_ex+0x56>
    #ifndef NO_ASN
        word32 idx = 0;
 801e1a8:	2300      	movs	r3, #0
 801e1aa:	613b      	str	r3, [r7, #16]
        ret = wc_ecc_import_x963_ex(pub, pubSz, key, curve_id);
 801e1ac:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801e1ae:	6a3a      	ldr	r2, [r7, #32]
 801e1b0:	6839      	ldr	r1, [r7, #0]
 801e1b2:	6878      	ldr	r0, [r7, #4]
 801e1b4:	f7ff ff2a 	bl	801e00c <wc_ecc_import_x963_ex>
 801e1b8:	6178      	str	r0, [r7, #20]
        if (ret < 0)
 801e1ba:	697b      	ldr	r3, [r7, #20]
 801e1bc:	2b00      	cmp	r3, #0
 801e1be:	da07      	bge.n	801e1d0 <wc_ecc_import_private_key_ex+0x4e>
            ret = wc_EccPublicKeyDecode(pub, &idx, key, pubSz);
 801e1c0:	f107 0110 	add.w	r1, r7, #16
 801e1c4:	683b      	ldr	r3, [r7, #0]
 801e1c6:	6a3a      	ldr	r2, [r7, #32]
 801e1c8:	6878      	ldr	r0, [r7, #4]
 801e1ca:	f7fb febb 	bl	8019f44 <wc_EccPublicKeyDecode>
 801e1ce:	6178      	str	r0, [r7, #20]
        key->type = ECC_PRIVATEKEY;
 801e1d0:	6a3b      	ldr	r3, [r7, #32]
 801e1d2:	2202      	movs	r2, #2
 801e1d4:	601a      	str	r2, [r3, #0]
 801e1d6:	e00c      	b.n	801e1f2 <wc_ecc_import_private_key_ex+0x70>
        ret = NOT_COMPILED_IN;
    #endif
    }
    else {
        /* make sure required variables are reset */
        wc_ecc_reset(key);
 801e1d8:	6a38      	ldr	r0, [r7, #32]
 801e1da:	f7fe fd16 	bl	801cc0a <wc_ecc_reset>

        /* set key size */
        /* NOTE: FIPS v6.0.0 or greater, no restriction on imported keys, only
         *       on created keys or signatures */
        ret = wc_ecc_set_curve(key, (int)privSz, curve_id);
 801e1de:	68bb      	ldr	r3, [r7, #8]
 801e1e0:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801e1e2:	4619      	mov	r1, r3
 801e1e4:	6a38      	ldr	r0, [r7, #32]
 801e1e6:	f7fc fc5d 	bl	801aaa4 <wc_ecc_set_curve>
 801e1ea:	6178      	str	r0, [r7, #20]
        key->type = ECC_PRIVATEKEY_ONLY;
 801e1ec:	6a3b      	ldr	r3, [r7, #32]
 801e1ee:	2203      	movs	r2, #3
 801e1f0:	601a      	str	r2, [r3, #0]
    }

    if (ret != 0)
 801e1f2:	697b      	ldr	r3, [r7, #20]
 801e1f4:	2b00      	cmp	r3, #0
 801e1f6:	d001      	beq.n	801e1fc <wc_ecc_import_private_key_ex+0x7a>
        return ret;
 801e1f8:	697b      	ldr	r3, [r7, #20]
 801e1fa:	e009      	b.n	801e210 <wc_ecc_import_private_key_ex+0x8e>

#ifdef WOLFSSL_VALIDATE_ECC_IMPORT
    SAVE_VECTOR_REGISTERS(return _svr_ret;);
#endif

    ret = mp_read_unsigned_bin(key->k, priv, privSz);
 801e1fc:	6a3b      	ldr	r3, [r7, #32]
 801e1fe:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 801e202:	68ba      	ldr	r2, [r7, #8]
 801e204:	68f9      	ldr	r1, [r7, #12]
 801e206:	4618      	mov	r0, r3
 801e208:	f008 fc1c 	bl	8026a44 <mp_read_unsigned_bin>
 801e20c:	6178      	str	r0, [r7, #20]
    if (ret == 0) {
        ret = silabs_ecc_import(key, key->dp->size, (pub != NULL), 1);
    }
#endif

    return ret;
 801e20e:	697b      	ldr	r3, [r7, #20]
}
 801e210:	4618      	mov	r0, r3
 801e212:	3718      	adds	r7, #24
 801e214:	46bd      	mov	sp, r7
 801e216:	bd80      	pop	{r7, pc}

0801e218 <wc_ecc_size>:
#endif

/* key size in octets */
WOLFSSL_ABI
int wc_ecc_size(ecc_key* key)
{
 801e218:	b480      	push	{r7}
 801e21a:	b083      	sub	sp, #12
 801e21c:	af00      	add	r7, sp, #0
 801e21e:	6078      	str	r0, [r7, #4]
    if (key == NULL || key->dp == NULL)
 801e220:	687b      	ldr	r3, [r7, #4]
 801e222:	2b00      	cmp	r3, #0
 801e224:	d003      	beq.n	801e22e <wc_ecc_size+0x16>
 801e226:	687b      	ldr	r3, [r7, #4]
 801e228:	691b      	ldr	r3, [r3, #16]
 801e22a:	2b00      	cmp	r3, #0
 801e22c:	d101      	bne.n	801e232 <wc_ecc_size+0x1a>
        return 0;
 801e22e:	2300      	movs	r3, #0
 801e230:	e002      	b.n	801e238 <wc_ecc_size+0x20>

    return key->dp->size;
 801e232:	687b      	ldr	r3, [r7, #4]
 801e234:	691b      	ldr	r3, [r3, #16]
 801e236:	681b      	ldr	r3, [r3, #0]
}
 801e238:	4618      	mov	r0, r3
 801e23a:	370c      	adds	r7, #12
 801e23c:	46bd      	mov	sp, r7
 801e23e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e242:	4770      	bx	lr

0801e244 <wc_ecc_sig_size>:
}

/* maximum signature size based on actual key curve */
WOLFSSL_ABI
int wc_ecc_sig_size(const ecc_key* key)
{
 801e244:	b580      	push	{r7, lr}
 801e246:	b086      	sub	sp, #24
 801e248:	af00      	add	r7, sp, #0
 801e24a:	6078      	str	r0, [r7, #4]
    int maxSigSz;
    int orderBits, keySz;

    if (key == NULL || key->dp == NULL)
 801e24c:	687b      	ldr	r3, [r7, #4]
 801e24e:	2b00      	cmp	r3, #0
 801e250:	d003      	beq.n	801e25a <wc_ecc_sig_size+0x16>
 801e252:	687b      	ldr	r3, [r7, #4]
 801e254:	691b      	ldr	r3, [r3, #16]
 801e256:	2b00      	cmp	r3, #0
 801e258:	d101      	bne.n	801e25e <wc_ecc_sig_size+0x1a>
        return 0;
 801e25a:	2300      	movs	r3, #0
 801e25c:	e028      	b.n	801e2b0 <wc_ecc_sig_size+0x6c>

    /* the signature r and s will always be less than order */
    /* if the order MSB (top bit of byte) is set then ASN encoding needs
        extra byte for r and s, so add 2 */
    keySz = key->dp->size;
 801e25e:	687b      	ldr	r3, [r7, #4]
 801e260:	691b      	ldr	r3, [r3, #16]
 801e262:	681b      	ldr	r3, [r3, #0]
 801e264:	613b      	str	r3, [r7, #16]
    orderBits = wc_ecc_get_curve_order_bit_count(key->dp);
 801e266:	687b      	ldr	r3, [r7, #4]
 801e268:	691b      	ldr	r3, [r3, #16]
 801e26a:	4618      	mov	r0, r3
 801e26c:	f7fe fe03 	bl	801ce76 <wc_ecc_get_curve_order_bit_count>
 801e270:	60f8      	str	r0, [r7, #12]
    if (orderBits > keySz * 8) {
 801e272:	693b      	ldr	r3, [r7, #16]
 801e274:	00db      	lsls	r3, r3, #3
 801e276:	68fa      	ldr	r2, [r7, #12]
 801e278:	429a      	cmp	r2, r3
 801e27a:	dd06      	ble.n	801e28a <wc_ecc_sig_size+0x46>
        keySz = (orderBits + 7) / 8;
 801e27c:	68fb      	ldr	r3, [r7, #12]
 801e27e:	3307      	adds	r3, #7
 801e280:	2b00      	cmp	r3, #0
 801e282:	da00      	bge.n	801e286 <wc_ecc_sig_size+0x42>
 801e284:	3307      	adds	r3, #7
 801e286:	10db      	asrs	r3, r3, #3
 801e288:	613b      	str	r3, [r7, #16]
    }
    /* maximum possible signature header size is 7 bytes */
    maxSigSz = (keySz * 2) + SIG_HEADER_SZ;
 801e28a:	693b      	ldr	r3, [r7, #16]
 801e28c:	005b      	lsls	r3, r3, #1
 801e28e:	3307      	adds	r3, #7
 801e290:	617b      	str	r3, [r7, #20]
    if ((orderBits % 8) == 0) {
 801e292:	68fb      	ldr	r3, [r7, #12]
 801e294:	f003 0307 	and.w	r3, r3, #7
 801e298:	2b00      	cmp	r3, #0
 801e29a:	d102      	bne.n	801e2a2 <wc_ecc_sig_size+0x5e>
        /* MSB can be set, so add 2 */
        maxSigSz += ECC_MAX_PAD_SZ;
 801e29c:	697b      	ldr	r3, [r7, #20]
 801e29e:	3302      	adds	r3, #2
 801e2a0:	617b      	str	r3, [r7, #20]
    }
    /* if total length is less than 128 + SEQ(1)+LEN(1) then subtract 1 */
    if (maxSigSz < (128 + 2)) {
 801e2a2:	697b      	ldr	r3, [r7, #20]
 801e2a4:	2b81      	cmp	r3, #129	@ 0x81
 801e2a6:	dc02      	bgt.n	801e2ae <wc_ecc_sig_size+0x6a>
        maxSigSz -= 1;
 801e2a8:	697b      	ldr	r3, [r7, #20]
 801e2aa:	3b01      	subs	r3, #1
 801e2ac:	617b      	str	r3, [r7, #20]
    }

    return maxSigSz;
 801e2ae:	697b      	ldr	r3, [r7, #20]
}
 801e2b0:	4618      	mov	r0, r3
 801e2b2:	3718      	adds	r7, #24
 801e2b4:	46bd      	mov	sp, r7
 801e2b6:	bd80      	pop	{r7, pc}

0801e2b8 <wc_ecc_get_oid>:
#endif
}
#endif /* HAVE_OID_ENCODING */

int wc_ecc_get_oid(word32 oidSum, const byte** oid, word32* oidSz)
{
 801e2b8:	b480      	push	{r7}
 801e2ba:	b087      	sub	sp, #28
 801e2bc:	af00      	add	r7, sp, #0
 801e2be:	60f8      	str	r0, [r7, #12]
 801e2c0:	60b9      	str	r1, [r7, #8]
 801e2c2:	607a      	str	r2, [r7, #4]
    int x;
    int ret = WC_NO_ERR_TRACE(NOT_COMPILED_IN);
 801e2c4:	f06f 03ad 	mvn.w	r3, #173	@ 0xad
 801e2c8:	613b      	str	r3, [r7, #16]
#ifdef HAVE_OID_ENCODING
    oid_cache_t* o = NULL;
#endif

    if (oidSum == 0) {
 801e2ca:	68fb      	ldr	r3, [r7, #12]
 801e2cc:	2b00      	cmp	r3, #0
 801e2ce:	d102      	bne.n	801e2d6 <wc_ecc_get_oid+0x1e>
        return BAD_FUNC_ARG;
 801e2d0:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801e2d4:	e03e      	b.n	801e354 <wc_ecc_get_oid+0x9c>
        return BAD_MUTEX_E;
    }
#endif

    /* find matching OID sum (based on encoded value) */
    for (x = 0; ecc_sets[x].size != 0; x++) {
 801e2d6:	2300      	movs	r3, #0
 801e2d8:	617b      	str	r3, [r7, #20]
 801e2da:	e031      	b.n	801e340 <wc_ecc_get_oid+0x88>
        if (ecc_sets[x].oidSum == oidSum) {
 801e2dc:	4a20      	ldr	r2, [pc, #128]	@ (801e360 <wc_ecc_get_oid+0xa8>)
 801e2de:	697b      	ldr	r3, [r7, #20]
 801e2e0:	2134      	movs	r1, #52	@ 0x34
 801e2e2:	fb01 f303 	mul.w	r3, r1, r3
 801e2e6:	4413      	add	r3, r2
 801e2e8:	332c      	adds	r3, #44	@ 0x2c
 801e2ea:	681b      	ldr	r3, [r3, #0]
 801e2ec:	68fa      	ldr	r2, [r7, #12]
 801e2ee:	429a      	cmp	r2, r3
 801e2f0:	d123      	bne.n	801e33a <wc_ecc_get_oid+0x82>
            if (ret == 0) {
                ret = ecc_sets[x].id;
            }
            break;
        #else
            if (oidSz) {
 801e2f2:	687b      	ldr	r3, [r7, #4]
 801e2f4:	2b00      	cmp	r3, #0
 801e2f6:	d009      	beq.n	801e30c <wc_ecc_get_oid+0x54>
                *oidSz = ecc_sets[x].oidSz;
 801e2f8:	4a19      	ldr	r2, [pc, #100]	@ (801e360 <wc_ecc_get_oid+0xa8>)
 801e2fa:	697b      	ldr	r3, [r7, #20]
 801e2fc:	2134      	movs	r1, #52	@ 0x34
 801e2fe:	fb01 f303 	mul.w	r3, r1, r3
 801e302:	4413      	add	r3, r2
 801e304:	3328      	adds	r3, #40	@ 0x28
 801e306:	681a      	ldr	r2, [r3, #0]
 801e308:	687b      	ldr	r3, [r7, #4]
 801e30a:	601a      	str	r2, [r3, #0]
            }
            if (oid) {
 801e30c:	68bb      	ldr	r3, [r7, #8]
 801e30e:	2b00      	cmp	r3, #0
 801e310:	d009      	beq.n	801e326 <wc_ecc_get_oid+0x6e>
                *oid = ecc_sets[x].oid;
 801e312:	4a13      	ldr	r2, [pc, #76]	@ (801e360 <wc_ecc_get_oid+0xa8>)
 801e314:	697b      	ldr	r3, [r7, #20]
 801e316:	2134      	movs	r1, #52	@ 0x34
 801e318:	fb01 f303 	mul.w	r3, r1, r3
 801e31c:	4413      	add	r3, r2
 801e31e:	3324      	adds	r3, #36	@ 0x24
 801e320:	681a      	ldr	r2, [r3, #0]
 801e322:	68bb      	ldr	r3, [r7, #8]
 801e324:	601a      	str	r2, [r3, #0]
            }
            ret = ecc_sets[x].id;
 801e326:	4a0e      	ldr	r2, [pc, #56]	@ (801e360 <wc_ecc_get_oid+0xa8>)
 801e328:	697b      	ldr	r3, [r7, #20]
 801e32a:	2134      	movs	r1, #52	@ 0x34
 801e32c:	fb01 f303 	mul.w	r3, r1, r3
 801e330:	4413      	add	r3, r2
 801e332:	3304      	adds	r3, #4
 801e334:	681b      	ldr	r3, [r3, #0]
 801e336:	613b      	str	r3, [r7, #16]
            break;
 801e338:	e00b      	b.n	801e352 <wc_ecc_get_oid+0x9a>
    for (x = 0; ecc_sets[x].size != 0; x++) {
 801e33a:	697b      	ldr	r3, [r7, #20]
 801e33c:	3301      	adds	r3, #1
 801e33e:	617b      	str	r3, [r7, #20]
 801e340:	4a07      	ldr	r2, [pc, #28]	@ (801e360 <wc_ecc_get_oid+0xa8>)
 801e342:	697b      	ldr	r3, [r7, #20]
 801e344:	2134      	movs	r1, #52	@ 0x34
 801e346:	fb01 f303 	mul.w	r3, r1, r3
 801e34a:	4413      	add	r3, r2
 801e34c:	681b      	ldr	r3, [r3, #0]
 801e34e:	2b00      	cmp	r3, #0
 801e350:	d1c4      	bne.n	801e2dc <wc_ecc_get_oid+0x24>

#ifdef HAVE_OID_ENCODING
    wc_UnLockMutex(&ecc_oid_cache_lock);
#endif

    return ret;
 801e352:	693b      	ldr	r3, [r7, #16]
}
 801e354:	4618      	mov	r0, r3
 801e356:	371c      	adds	r7, #28
 801e358:	46bd      	mov	sp, r7
 801e35a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e35e:	4770      	bx	lr
 801e360:	08033b18 	.word	0x08033b18

0801e364 <wc_HashGetDigestSize>:

#ifndef NO_HASH_WRAPPER

/* Get Hash digest size */
int wc_HashGetDigestSize(enum wc_HashType hash_type)
{
 801e364:	b480      	push	{r7}
 801e366:	b085      	sub	sp, #20
 801e368:	af00      	add	r7, sp, #0
 801e36a:	4603      	mov	r3, r0
 801e36c:	71fb      	strb	r3, [r7, #7]
    int dig_size = WC_NO_ERR_TRACE(HASH_TYPE_E);
 801e36e:	f06f 03e7 	mvn.w	r3, #231	@ 0xe7
 801e372:	60fb      	str	r3, [r7, #12]
    switch(hash_type)
 801e374:	79fb      	ldrb	r3, [r7, #7]
 801e376:	3b01      	subs	r3, #1
 801e378:	2b10      	cmp	r3, #16
 801e37a:	d828      	bhi.n	801e3ce <wc_HashGetDigestSize+0x6a>
 801e37c:	a201      	add	r2, pc, #4	@ (adr r2, 801e384 <wc_HashGetDigestSize+0x20>)
 801e37e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801e382:	bf00      	nop
 801e384:	0801e3d7 	.word	0x0801e3d7
 801e388:	0801e3d7 	.word	0x0801e3d7
 801e38c:	0801e3d7 	.word	0x0801e3d7
 801e390:	0801e3d7 	.word	0x0801e3d7
 801e394:	0801e3d7 	.word	0x0801e3d7
 801e398:	0801e3c9 	.word	0x0801e3c9
 801e39c:	0801e3d7 	.word	0x0801e3d7
 801e3a0:	0801e3d7 	.word	0x0801e3d7
 801e3a4:	0801e3d7 	.word	0x0801e3d7
 801e3a8:	0801e3d7 	.word	0x0801e3d7
 801e3ac:	0801e3d7 	.word	0x0801e3d7
 801e3b0:	0801e3d7 	.word	0x0801e3d7
 801e3b4:	0801e3d7 	.word	0x0801e3d7
 801e3b8:	0801e3d7 	.word	0x0801e3d7
 801e3bc:	0801e3d7 	.word	0x0801e3d7
 801e3c0:	0801e3d7 	.word	0x0801e3d7
 801e3c4:	0801e3d7 	.word	0x0801e3d7
            dig_size = WC_SHA224_DIGEST_SIZE;
        #endif
            break;
        case WC_HASH_TYPE_SHA256:
        #ifndef NO_SHA256
            dig_size = WC_SHA256_DIGEST_SIZE;
 801e3c8:	2320      	movs	r3, #32
 801e3ca:	60fb      	str	r3, [r7, #12]
        #endif
            break;
 801e3cc:	e004      	b.n	801e3d8 <wc_HashGetDigestSize+0x74>
    #if defined(WOLFSSL_SHA3) && defined(WOLFSSL_SHAKE256)
        case WC_HASH_TYPE_SHAKE256:
    #endif
        case WC_HASH_TYPE_NONE:
        default:
            dig_size = BAD_FUNC_ARG;
 801e3ce:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801e3d2:	60fb      	str	r3, [r7, #12]
            break;
 801e3d4:	e000      	b.n	801e3d8 <wc_HashGetDigestSize+0x74>
            break;
 801e3d6:	bf00      	nop
    }
    return dig_size;
 801e3d8:	68fb      	ldr	r3, [r7, #12]
}
 801e3da:	4618      	mov	r0, r3
 801e3dc:	3714      	adds	r7, #20
 801e3de:	46bd      	mov	sp, r7
 801e3e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e3e4:	4770      	bx	lr
 801e3e6:	bf00      	nop

0801e3e8 <wc_Hash_ex>:
}

/* Generic Hashing Wrapper */
int wc_Hash_ex(enum wc_HashType hash_type, const byte* data,
    word32 data_len, byte* hash, word32 hash_len, void* heap, int devId)
{
 801e3e8:	b580      	push	{r7, lr}
 801e3ea:	b088      	sub	sp, #32
 801e3ec:	af02      	add	r7, sp, #8
 801e3ee:	60b9      	str	r1, [r7, #8]
 801e3f0:	607a      	str	r2, [r7, #4]
 801e3f2:	603b      	str	r3, [r7, #0]
 801e3f4:	4603      	mov	r3, r0
 801e3f6:	73fb      	strb	r3, [r7, #15]
    int ret = WC_NO_ERR_TRACE(HASH_TYPE_E); /* Default to hash type error */
 801e3f8:	f06f 03e7 	mvn.w	r3, #231	@ 0xe7
 801e3fc:	617b      	str	r3, [r7, #20]
    int dig_size;

    /* Validate hash buffer size */
    dig_size = wc_HashGetDigestSize(hash_type);
 801e3fe:	7bfb      	ldrb	r3, [r7, #15]
 801e400:	4618      	mov	r0, r3
 801e402:	f7ff ffaf 	bl	801e364 <wc_HashGetDigestSize>
 801e406:	6138      	str	r0, [r7, #16]
    if (dig_size < 0) {
 801e408:	693b      	ldr	r3, [r7, #16]
 801e40a:	2b00      	cmp	r3, #0
 801e40c:	da01      	bge.n	801e412 <wc_Hash_ex+0x2a>
        return dig_size;
 801e40e:	693b      	ldr	r3, [r7, #16]
 801e410:	e03c      	b.n	801e48c <wc_Hash_ex+0xa4>
    }

    if (hash_len < (word32)dig_size) {
 801e412:	693b      	ldr	r3, [r7, #16]
 801e414:	6a3a      	ldr	r2, [r7, #32]
 801e416:	429a      	cmp	r2, r3
 801e418:	d202      	bcs.n	801e420 <wc_Hash_ex+0x38>
        return BUFFER_E;
 801e41a:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 801e41e:	e035      	b.n	801e48c <wc_Hash_ex+0xa4>
    (void)data;
    (void)data_len;
    (void)hash;
    (void)hash_len;

    switch(hash_type)
 801e420:	7bfb      	ldrb	r3, [r7, #15]
 801e422:	3b03      	subs	r3, #3
 801e424:	2b0e      	cmp	r3, #14
 801e426:	d82b      	bhi.n	801e480 <wc_Hash_ex+0x98>
 801e428:	a201      	add	r2, pc, #4	@ (adr r2, 801e430 <wc_Hash_ex+0x48>)
 801e42a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801e42e:	bf00      	nop
 801e430:	0801e489 	.word	0x0801e489
 801e434:	0801e489 	.word	0x0801e489
 801e438:	0801e489 	.word	0x0801e489
 801e43c:	0801e46d 	.word	0x0801e46d
 801e440:	0801e489 	.word	0x0801e489
 801e444:	0801e489 	.word	0x0801e489
 801e448:	0801e489 	.word	0x0801e489
 801e44c:	0801e489 	.word	0x0801e489
 801e450:	0801e489 	.word	0x0801e489
 801e454:	0801e489 	.word	0x0801e489
 801e458:	0801e489 	.word	0x0801e489
 801e45c:	0801e481 	.word	0x0801e481
 801e460:	0801e481 	.word	0x0801e481
 801e464:	0801e489 	.word	0x0801e489
 801e468:	0801e489 	.word	0x0801e489
            ret = wc_Sha224Hash_ex(data, data_len, hash, heap, devId);
#endif
            break;
        case WC_HASH_TYPE_SHA256:
#ifndef NO_SHA256
            ret = wc_Sha256Hash_ex(data, data_len, hash, heap, devId);
 801e46c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801e46e:	9300      	str	r3, [sp, #0]
 801e470:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801e472:	683a      	ldr	r2, [r7, #0]
 801e474:	6879      	ldr	r1, [r7, #4]
 801e476:	68b8      	ldr	r0, [r7, #8]
 801e478:	f000 f826 	bl	801e4c8 <wc_Sha256Hash_ex>
 801e47c:	6178      	str	r0, [r7, #20]
#endif
            break;
 801e47e:	e004      	b.n	801e48a <wc_Hash_ex+0xa2>
    #if defined(WOLFSSL_SHA3) && defined(WOLFSSL_SHAKE256)
        case WC_HASH_TYPE_SHAKE256:
    #endif
        case WC_HASH_TYPE_NONE:
        default:
            ret = BAD_FUNC_ARG;
 801e480:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801e484:	617b      	str	r3, [r7, #20]
            break;
 801e486:	e000      	b.n	801e48a <wc_Hash_ex+0xa2>
            break;
 801e488:	bf00      	nop
    }
    return ret;
 801e48a:	697b      	ldr	r3, [r7, #20]
}
 801e48c:	4618      	mov	r0, r3
 801e48e:	3718      	adds	r7, #24
 801e490:	46bd      	mov	sp, r7
 801e492:	bd80      	pop	{r7, pc}

0801e494 <wc_Hash>:
int wc_Hash(enum wc_HashType hash_type, const byte* data,
    word32 data_len, byte* hash, word32 hash_len)
{
 801e494:	b580      	push	{r7, lr}
 801e496:	b088      	sub	sp, #32
 801e498:	af04      	add	r7, sp, #16
 801e49a:	60b9      	str	r1, [r7, #8]
 801e49c:	607a      	str	r2, [r7, #4]
 801e49e:	603b      	str	r3, [r7, #0]
 801e4a0:	4603      	mov	r3, r0
 801e4a2:	73fb      	strb	r3, [r7, #15]
    return wc_Hash_ex(hash_type, data, data_len, hash, hash_len,
 801e4a4:	7bf8      	ldrb	r0, [r7, #15]
 801e4a6:	f06f 0301 	mvn.w	r3, #1
 801e4aa:	9302      	str	r3, [sp, #8]
 801e4ac:	2300      	movs	r3, #0
 801e4ae:	9301      	str	r3, [sp, #4]
 801e4b0:	69bb      	ldr	r3, [r7, #24]
 801e4b2:	9300      	str	r3, [sp, #0]
 801e4b4:	683b      	ldr	r3, [r7, #0]
 801e4b6:	687a      	ldr	r2, [r7, #4]
 801e4b8:	68b9      	ldr	r1, [r7, #8]
 801e4ba:	f7ff ff95 	bl	801e3e8 <wc_Hash_ex>
 801e4be:	4603      	mov	r3, r0
        NULL, INVALID_DEVID);
}
 801e4c0:	4618      	mov	r0, r3
 801e4c2:	3710      	adds	r7, #16
 801e4c4:	46bd      	mov	sp, r7
 801e4c6:	bd80      	pop	{r7, pc}

0801e4c8 <wc_Sha256Hash_ex>:
#endif /* WOLFSSL_SHA224 */

#if !defined(NO_SHA256)
    int wc_Sha256Hash_ex(const byte* data, word32 len, byte* hash,
        void* heap, int devId)
    {
 801e4c8:	b580      	push	{r7, lr}
 801e4ca:	b088      	sub	sp, #32
 801e4cc:	af00      	add	r7, sp, #0
 801e4ce:	60f8      	str	r0, [r7, #12]
 801e4d0:	60b9      	str	r1, [r7, #8]
 801e4d2:	607a      	str	r2, [r7, #4]
 801e4d4:	603b      	str	r3, [r7, #0]
        int ret = 0;
 801e4d6:	2300      	movs	r3, #0
 801e4d8:	61fb      	str	r3, [r7, #28]
    #else
        wc_Sha256 sha256[1];
    #endif

    #ifdef WOLFSSL_SMALL_STACK
        sha256 = (wc_Sha256*)XMALLOC(sizeof(wc_Sha256), NULL,
 801e4da:	2070      	movs	r0, #112	@ 0x70
 801e4dc:	f000 fad4 	bl	801ea88 <wolfSSL_Malloc>
 801e4e0:	61b8      	str	r0, [r7, #24]
            DYNAMIC_TYPE_TMP_BUFFER);
        if (sha256 == NULL)
 801e4e2:	69bb      	ldr	r3, [r7, #24]
 801e4e4:	2b00      	cmp	r3, #0
 801e4e6:	d102      	bne.n	801e4ee <wc_Sha256Hash_ex+0x26>
            return MEMORY_E;
 801e4e8:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801e4ec:	e022      	b.n	801e534 <wc_Sha256Hash_ex+0x6c>
    #endif

        if ((ret = wc_InitSha256_ex(sha256, heap, devId)) != 0) {
 801e4ee:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801e4f0:	6839      	ldr	r1, [r7, #0]
 801e4f2:	69b8      	ldr	r0, [r7, #24]
 801e4f4:	f003 f86c 	bl	80215d0 <wc_InitSha256_ex>
 801e4f8:	61f8      	str	r0, [r7, #28]
 801e4fa:	69fb      	ldr	r3, [r7, #28]
 801e4fc:	2b00      	cmp	r3, #0
 801e4fe:	d110      	bne.n	801e522 <wc_Sha256Hash_ex+0x5a>
            WOLFSSL_MSG("InitSha256 failed");
        }
        else {
            if ((ret = wc_Sha256Update(sha256, data, len)) != 0) {
 801e500:	68ba      	ldr	r2, [r7, #8]
 801e502:	68f9      	ldr	r1, [r7, #12]
 801e504:	69b8      	ldr	r0, [r7, #24]
 801e506:	f003 fca6 	bl	8021e56 <wc_Sha256Update>
 801e50a:	61f8      	str	r0, [r7, #28]
 801e50c:	69fb      	ldr	r3, [r7, #28]
 801e50e:	2b00      	cmp	r3, #0
 801e510:	d104      	bne.n	801e51c <wc_Sha256Hash_ex+0x54>
                WOLFSSL_MSG("Sha256Update failed");
            }
            else if ((ret = wc_Sha256Final(sha256, hash)) != 0) {
 801e512:	6879      	ldr	r1, [r7, #4]
 801e514:	69b8      	ldr	r0, [r7, #24]
 801e516:	f003 fd3c 	bl	8021f92 <wc_Sha256Final>
 801e51a:	61f8      	str	r0, [r7, #28]
                WOLFSSL_MSG("Sha256Final failed");
            }
            wc_Sha256Free(sha256);
 801e51c:	69b8      	ldr	r0, [r7, #24]
 801e51e:	f003 fd74 	bl	802200a <wc_Sha256Free>
        }


    #ifdef WOLFSSL_SMALL_STACK
        XFREE(sha256, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 801e522:	69bb      	ldr	r3, [r7, #24]
 801e524:	617b      	str	r3, [r7, #20]
 801e526:	697b      	ldr	r3, [r7, #20]
 801e528:	2b00      	cmp	r3, #0
 801e52a:	d002      	beq.n	801e532 <wc_Sha256Hash_ex+0x6a>
 801e52c:	6978      	ldr	r0, [r7, #20]
 801e52e:	f000 fac7 	bl	801eac0 <wolfSSL_Free>
    #endif

        return ret;
 801e532:	69fb      	ldr	r3, [r7, #28]
    }
 801e534:	4618      	mov	r0, r3
 801e536:	3720      	adds	r7, #32
 801e538:	46bd      	mov	sp, r7
 801e53a:	bd80      	pop	{r7, pc}

0801e53c <wc_Sha256Hash>:
    int wc_Sha256Hash(const byte* data, word32 len, byte* hash)
    {
 801e53c:	b580      	push	{r7, lr}
 801e53e:	b088      	sub	sp, #32
 801e540:	af02      	add	r7, sp, #8
 801e542:	60f8      	str	r0, [r7, #12]
 801e544:	60b9      	str	r1, [r7, #8]
 801e546:	607a      	str	r2, [r7, #4]
        int devId = INVALID_DEVID;
 801e548:	f06f 0301 	mvn.w	r3, #1
 801e54c:	617b      	str	r3, [r7, #20]
        /* find devId if its not an empty hash */
        if (data != NULL && len > 0) {
            devId = wc_CryptoCb_DefaultDevID();
        }
    #endif
        return wc_Sha256Hash_ex(data, len, hash, NULL, devId);
 801e54e:	697b      	ldr	r3, [r7, #20]
 801e550:	9300      	str	r3, [sp, #0]
 801e552:	2300      	movs	r3, #0
 801e554:	687a      	ldr	r2, [r7, #4]
 801e556:	68b9      	ldr	r1, [r7, #8]
 801e558:	68f8      	ldr	r0, [r7, #12]
 801e55a:	f7ff ffb5 	bl	801e4c8 <wc_Sha256Hash_ex>
 801e55e:	4603      	mov	r3, r0
    }
 801e560:	4618      	mov	r0, r3
 801e562:	3718      	adds	r7, #24
 801e564:	46bd      	mov	sp, r7
 801e566:	bd80      	pop	{r7, pc}

0801e568 <ForceZero>:
{
 801e568:	b480      	push	{r7}
 801e56a:	b085      	sub	sp, #20
 801e56c:	af00      	add	r7, sp, #0
 801e56e:	6078      	str	r0, [r7, #4]
 801e570:	6039      	str	r1, [r7, #0]
    volatile byte* z = (volatile byte*)mem;
 801e572:	687b      	ldr	r3, [r7, #4]
 801e574:	60fb      	str	r3, [r7, #12]
    while (len--) *z++ = 0;
 801e576:	e004      	b.n	801e582 <ForceZero+0x1a>
 801e578:	68fb      	ldr	r3, [r7, #12]
 801e57a:	1c5a      	adds	r2, r3, #1
 801e57c:	60fa      	str	r2, [r7, #12]
 801e57e:	2200      	movs	r2, #0
 801e580:	701a      	strb	r2, [r3, #0]
 801e582:	683b      	ldr	r3, [r7, #0]
 801e584:	1e5a      	subs	r2, r3, #1
 801e586:	603a      	str	r2, [r7, #0]
 801e588:	2b00      	cmp	r3, #0
 801e58a:	d1f5      	bne.n	801e578 <ForceZero+0x10>
}
 801e58c:	bf00      	nop
 801e58e:	bf00      	nop
 801e590:	3714      	adds	r7, #20
 801e592:	46bd      	mov	sp, r7
 801e594:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e598:	4770      	bx	lr

0801e59a <wc_HmacFree>:
}
#endif /* WOLF_PRIVATE_KEY_ID */

/* Free Hmac from use with async device */
void wc_HmacFree(Hmac* hmac)
{
 801e59a:	b580      	push	{r7, lr}
 801e59c:	b082      	sub	sp, #8
 801e59e:	af00      	add	r7, sp, #0
 801e5a0:	6078      	str	r0, [r7, #4]
    if (hmac == NULL)
 801e5a2:	687b      	ldr	r3, [r7, #4]
 801e5a4:	2b00      	cmp	r3, #0
 801e5a6:	d010      	beq.n	801e5ca <wc_HmacFree+0x30>

#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_HMAC)
    wolfAsync_DevCtxFree(&hmac->asyncDev, WOLFSSL_ASYNC_MARKER_HMAC);
#endif /* WOLFSSL_ASYNC_CRYPT */

    switch (hmac->macType) {
 801e5a8:	687b      	ldr	r3, [r7, #4]
 801e5aa:	f893 3114 	ldrb.w	r3, [r3, #276]	@ 0x114
 801e5ae:	2b06      	cmp	r3, #6
 801e5b0:	d104      	bne.n	801e5bc <wc_HmacFree+0x22>
            wc_Sha224Free(&hmac->hash.sha224);
            break;
    #endif /* WOLFSSL_SHA224 */
    #ifndef NO_SHA256
        case WC_SHA256:
            wc_Sha256Free(&hmac->hash.sha256);
 801e5b2:	687b      	ldr	r3, [r7, #4]
 801e5b4:	4618      	mov	r0, r3
 801e5b6:	f003 fd28 	bl	802200a <wc_Sha256Free>
            break;
 801e5ba:	e000      	b.n	801e5be <wc_HmacFree+0x24>
            wc_Sm3Free(&hmac->hash.sm3);
            break;
    #endif

        default:
            break;
 801e5bc:	bf00      	nop
    }

    ForceZero(hmac, sizeof(*hmac));
 801e5be:	f44f 718c 	mov.w	r1, #280	@ 0x118
 801e5c2:	6878      	ldr	r0, [r7, #4]
 801e5c4:	f7ff ffd0 	bl	801e568 <ForceZero>
 801e5c8:	e000      	b.n	801e5cc <wc_HmacFree+0x32>
        return;
 801e5ca:	bf00      	nop
}
 801e5cc:	3708      	adds	r7, #8
 801e5ce:	46bd      	mov	sp, r7
 801e5d0:	bd80      	pop	{r7, pc}
	...

0801e5d4 <wc_LoggingInit>:
#define ERRQ_LOCK()            wc_LockMutex(&wc_error_mutex)
#define ERRQ_UNLOCK()          wc_UnLockMutex(&wc_error_mutex)

/* Internal function that is called by wolfCrypt_Init() */
int wc_LoggingInit(void)
{
 801e5d4:	b580      	push	{r7, lr}
 801e5d6:	af00      	add	r7, sp, #0
#ifndef WOLFSSL_MUTEX_INITIALIZER
    if (ERRQ_MUTEX_INIT() != 0) {
 801e5d8:	480b      	ldr	r0, [pc, #44]	@ (801e608 <wc_LoggingInit+0x34>)
 801e5da:	f008 fecf 	bl	802737c <wc_InitMutex>
 801e5de:	4603      	mov	r3, r0
 801e5e0:	2b00      	cmp	r3, #0
 801e5e2:	d002      	beq.n	801e5ea <wc_LoggingInit+0x16>
        WOLFSSL_MSG("Bad Init Mutex");
        return BAD_MUTEX_E;
 801e5e4:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 801e5e8:	e00c      	b.n	801e604 <wc_LoggingInit+0x30>
    }
#endif
    wc_errors_count = 0;
 801e5ea:	4b08      	ldr	r3, [pc, #32]	@ (801e60c <wc_LoggingInit+0x38>)
 801e5ec:	2200      	movs	r2, #0
 801e5ee:	601a      	str	r2, [r3, #0]
    wc_errors          = NULL;
 801e5f0:	4b07      	ldr	r3, [pc, #28]	@ (801e610 <wc_LoggingInit+0x3c>)
 801e5f2:	2200      	movs	r2, #0
 801e5f4:	601a      	str	r2, [r3, #0]
    wc_current_node    = NULL;
 801e5f6:	4b07      	ldr	r3, [pc, #28]	@ (801e614 <wc_LoggingInit+0x40>)
 801e5f8:	2200      	movs	r2, #0
 801e5fa:	601a      	str	r2, [r3, #0]
    wc_last_node       = NULL;
 801e5fc:	4b06      	ldr	r3, [pc, #24]	@ (801e618 <wc_LoggingInit+0x44>)
 801e5fe:	2200      	movs	r2, #0
 801e600:	601a      	str	r2, [r3, #0]
    return 0;
 801e602:	2300      	movs	r3, #0
}
 801e604:	4618      	mov	r0, r3
 801e606:	bd80      	pop	{r7, pc}
 801e608:	200028f8 	.word	0x200028f8
 801e60c:	200028e8 	.word	0x200028e8
 801e610:	200028e4 	.word	0x200028e4
 801e614:	200028f0 	.word	0x200028f0
 801e618:	200028ec 	.word	0x200028ec

0801e61c <wc_LoggingCleanup>:


/* internal function that is called by wolfCrypt_Cleanup */
int wc_LoggingCleanup(void)
{
 801e61c:	b580      	push	{r7, lr}
 801e61e:	af00      	add	r7, sp, #0
    /* clear logging entries */
    wc_ClearErrorNodes();
 801e620:	f000 f9d4 	bl	801e9cc <wc_ClearErrorNodes>
    /* free mutex */
#ifndef WOLFSSL_MUTEX_INITIALIZER
    if (ERRQ_MUTEX_FREE() != 0) {
 801e624:	4805      	ldr	r0, [pc, #20]	@ (801e63c <wc_LoggingCleanup+0x20>)
 801e626:	f008 feb4 	bl	8027392 <wc_FreeMutex>
 801e62a:	4603      	mov	r3, r0
 801e62c:	2b00      	cmp	r3, #0
 801e62e:	d002      	beq.n	801e636 <wc_LoggingCleanup+0x1a>
        WOLFSSL_MSG("Bad Mutex free");
        return BAD_MUTEX_E;
 801e630:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 801e634:	e000      	b.n	801e638 <wc_LoggingCleanup+0x1c>
    }
#endif
    return 0;
 801e636:	2300      	movs	r3, #0
}
 801e638:	4618      	mov	r0, r3
 801e63a:	bd80      	pop	{r7, pc}
 801e63c:	200028f8 	.word	0x200028f8

0801e640 <peekErrorNode>:

static int peekErrorNode(int idx, const char **file, const char **reason,
        int *line)
{
 801e640:	b480      	push	{r7}
 801e642:	b087      	sub	sp, #28
 801e644:	af00      	add	r7, sp, #0
 801e646:	60f8      	str	r0, [r7, #12]
 801e648:	60b9      	str	r1, [r7, #8]
 801e64a:	607a      	str	r2, [r7, #4]
 801e64c:	603b      	str	r3, [r7, #0]
    struct wc_error_queue* err;

    if (idx < 0) {
 801e64e:	68fb      	ldr	r3, [r7, #12]
 801e650:	2b00      	cmp	r3, #0
 801e652:	da03      	bge.n	801e65c <peekErrorNode+0x1c>
        err = wc_last_node;
 801e654:	4b20      	ldr	r3, [pc, #128]	@ (801e6d8 <peekErrorNode+0x98>)
 801e656:	681b      	ldr	r3, [r3, #0]
 801e658:	617b      	str	r3, [r7, #20]
 801e65a:	e015      	b.n	801e688 <peekErrorNode+0x48>
    }
    else {
        int i;

        err = (struct wc_error_queue*)wc_errors;
 801e65c:	4b1f      	ldr	r3, [pc, #124]	@ (801e6dc <peekErrorNode+0x9c>)
 801e65e:	681b      	ldr	r3, [r3, #0]
 801e660:	617b      	str	r3, [r7, #20]
        for (i = 0; i < idx; i++) {
 801e662:	2300      	movs	r3, #0
 801e664:	613b      	str	r3, [r7, #16]
 801e666:	e00b      	b.n	801e680 <peekErrorNode+0x40>
            if (err == NULL) {
 801e668:	697b      	ldr	r3, [r7, #20]
 801e66a:	2b00      	cmp	r3, #0
 801e66c:	d102      	bne.n	801e674 <peekErrorNode+0x34>
                WOLFSSL_MSG("Error node not found. Bad index?");
                return BAD_FUNC_ARG;
 801e66e:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801e672:	e02a      	b.n	801e6ca <peekErrorNode+0x8a>
            }
            err = err->next;
 801e674:	697b      	ldr	r3, [r7, #20]
 801e676:	685b      	ldr	r3, [r3, #4]
 801e678:	617b      	str	r3, [r7, #20]
        for (i = 0; i < idx; i++) {
 801e67a:	693b      	ldr	r3, [r7, #16]
 801e67c:	3301      	adds	r3, #1
 801e67e:	613b      	str	r3, [r7, #16]
 801e680:	693a      	ldr	r2, [r7, #16]
 801e682:	68fb      	ldr	r3, [r7, #12]
 801e684:	429a      	cmp	r2, r3
 801e686:	dbef      	blt.n	801e668 <peekErrorNode+0x28>
        }
    }

    if (err == NULL) {
 801e688:	697b      	ldr	r3, [r7, #20]
 801e68a:	2b00      	cmp	r3, #0
 801e68c:	d102      	bne.n	801e694 <peekErrorNode+0x54>
        WOLFSSL_MSG("No Errors in queue");
        return BAD_STATE_E;
 801e68e:	f06f 03bf 	mvn.w	r3, #191	@ 0xbf
 801e692:	e01a      	b.n	801e6ca <peekErrorNode+0x8a>
    }

    if (file != NULL) {
 801e694:	68bb      	ldr	r3, [r7, #8]
 801e696:	2b00      	cmp	r3, #0
 801e698:	d004      	beq.n	801e6a4 <peekErrorNode+0x64>
        *file = err->file;
 801e69a:	697b      	ldr	r3, [r7, #20]
 801e69c:	f103 025c 	add.w	r2, r3, #92	@ 0x5c
 801e6a0:	68bb      	ldr	r3, [r7, #8]
 801e6a2:	601a      	str	r2, [r3, #0]
    }
    if (reason != NULL) {
 801e6a4:	687b      	ldr	r3, [r7, #4]
 801e6a6:	2b00      	cmp	r3, #0
 801e6a8:	d004      	beq.n	801e6b4 <peekErrorNode+0x74>
        *reason = err->error;
 801e6aa:	697b      	ldr	r3, [r7, #20]
 801e6ac:	f103 020c 	add.w	r2, r3, #12
 801e6b0:	687b      	ldr	r3, [r7, #4]
 801e6b2:	601a      	str	r2, [r3, #0]
    }
    if (line != NULL) {
 801e6b4:	683b      	ldr	r3, [r7, #0]
 801e6b6:	2b00      	cmp	r3, #0
 801e6b8:	d004      	beq.n	801e6c4 <peekErrorNode+0x84>
        *line = err->line;
 801e6ba:	697b      	ldr	r3, [r7, #20]
 801e6bc:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
 801e6c0:	683b      	ldr	r3, [r7, #0]
 801e6c2:	601a      	str	r2, [r3, #0]
    }

    return err->value;
 801e6c4:	697b      	ldr	r3, [r7, #20]
 801e6c6:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
}
 801e6ca:	4618      	mov	r0, r3
 801e6cc:	371c      	adds	r7, #28
 801e6ce:	46bd      	mov	sp, r7
 801e6d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e6d4:	4770      	bx	lr
 801e6d6:	bf00      	nop
 801e6d8:	200028ec 	.word	0x200028ec
 801e6dc:	200028e4 	.word	0x200028e4

0801e6e0 <wc_PeekErrorNode>:
 * Returns a negative value in error case, on success returns the nodes error
 * value which is positive (absolute value)
 */
int wc_PeekErrorNode(int idx, const char **file, const char **reason,
        int *line)
{
 801e6e0:	b580      	push	{r7, lr}
 801e6e2:	b086      	sub	sp, #24
 801e6e4:	af00      	add	r7, sp, #0
 801e6e6:	60f8      	str	r0, [r7, #12]
 801e6e8:	60b9      	str	r1, [r7, #8]
 801e6ea:	607a      	str	r2, [r7, #4]
 801e6ec:	603b      	str	r3, [r7, #0]
    int ret;

    if (ERRQ_LOCK() != 0) {
 801e6ee:	480c      	ldr	r0, [pc, #48]	@ (801e720 <wc_PeekErrorNode+0x40>)
 801e6f0:	f008 fe5a 	bl	80273a8 <wc_LockMutex>
 801e6f4:	4603      	mov	r3, r0
 801e6f6:	2b00      	cmp	r3, #0
 801e6f8:	d002      	beq.n	801e700 <wc_PeekErrorNode+0x20>
        WOLFSSL_MSG("Lock debug mutex failed");
        return BAD_MUTEX_E;
 801e6fa:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 801e6fe:	e00a      	b.n	801e716 <wc_PeekErrorNode+0x36>
    }
    ret = peekErrorNode(idx, file, reason, line);
 801e700:	683b      	ldr	r3, [r7, #0]
 801e702:	687a      	ldr	r2, [r7, #4]
 801e704:	68b9      	ldr	r1, [r7, #8]
 801e706:	68f8      	ldr	r0, [r7, #12]
 801e708:	f7ff ff9a 	bl	801e640 <peekErrorNode>
 801e70c:	6178      	str	r0, [r7, #20]
    ERRQ_UNLOCK();
 801e70e:	4804      	ldr	r0, [pc, #16]	@ (801e720 <wc_PeekErrorNode+0x40>)
 801e710:	f008 fe55 	bl	80273be <wc_UnLockMutex>
    return ret;
 801e714:	697b      	ldr	r3, [r7, #20]
}
 801e716:	4618      	mov	r0, r3
 801e718:	3718      	adds	r7, #24
 801e71a:	46bd      	mov	sp, r7
 801e71c:	bd80      	pop	{r7, pc}
 801e71e:	bf00      	nop
 801e720:	200028f8 	.word	0x200028f8

0801e724 <wc_AddErrorNode>:

/* create new error node and add it to the queue
 * buffers are assumed to be of size WOLFSSL_MAX_ERROR_SZ for this internal
 * function. */
int wc_AddErrorNode(int error, int line, char* buf, char* file)
{
 801e724:	b580      	push	{r7, lr}
 801e726:	b088      	sub	sp, #32
 801e728:	af00      	add	r7, sp, #0
 801e72a:	60f8      	str	r0, [r7, #12]
 801e72c:	60b9      	str	r1, [r7, #8]
 801e72e:	607a      	str	r2, [r7, #4]
 801e730:	603b      	str	r3, [r7, #0]
    struct wc_error_queue* err;

    if (wc_errors_count >= ERROR_QUEUE_MAX) {
 801e732:	4b44      	ldr	r3, [pc, #272]	@ (801e844 <wc_AddErrorNode+0x120>)
 801e734:	681b      	ldr	r3, [r3, #0]
 801e736:	2b63      	cmp	r3, #99	@ 0x63
 801e738:	dd02      	ble.n	801e740 <wc_AddErrorNode+0x1c>
        WOLFSSL_MSG("Error queue is full, at ERROR_QUEUE_MAX");
        return MEMORY_E;
 801e73a:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801e73e:	e07d      	b.n	801e83c <wc_AddErrorNode+0x118>
    }

    err = (struct wc_error_queue*)XMALLOC(
 801e740:	20b4      	movs	r0, #180	@ 0xb4
 801e742:	f000 f9a1 	bl	801ea88 <wolfSSL_Malloc>
 801e746:	61b8      	str	r0, [r7, #24]
            sizeof(struct wc_error_queue), wc_error_heap, DYNAMIC_TYPE_LOG);
    if (err == NULL) {
 801e748:	69bb      	ldr	r3, [r7, #24]
 801e74a:	2b00      	cmp	r3, #0
 801e74c:	d102      	bne.n	801e754 <wc_AddErrorNode+0x30>
        WOLFSSL_MSG("Unable to create error node for log");
        return MEMORY_E;
 801e74e:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801e752:	e073      	b.n	801e83c <wc_AddErrorNode+0x118>
    }
    else {
        int sz;

        XMEMSET(err, 0, sizeof(struct wc_error_queue));
 801e754:	22b4      	movs	r2, #180	@ 0xb4
 801e756:	2100      	movs	r1, #0
 801e758:	69b8      	ldr	r0, [r7, #24]
 801e75a:	f009 feb5 	bl	80284c8 <memset>
        err->heap = wc_error_heap;
 801e75e:	4b3a      	ldr	r3, [pc, #232]	@ (801e848 <wc_AddErrorNode+0x124>)
 801e760:	681a      	ldr	r2, [r3, #0]
 801e762:	69bb      	ldr	r3, [r7, #24]
 801e764:	601a      	str	r2, [r3, #0]
        sz = (int)XSTRLEN(buf);
 801e766:	6878      	ldr	r0, [r7, #4]
 801e768:	f7e1 fd3c 	bl	80001e4 <strlen>
 801e76c:	4603      	mov	r3, r0
 801e76e:	61fb      	str	r3, [r7, #28]
        if (sz > WOLFSSL_MAX_ERROR_SZ - 1) {
 801e770:	69fb      	ldr	r3, [r7, #28]
 801e772:	2b4f      	cmp	r3, #79	@ 0x4f
 801e774:	dd01      	ble.n	801e77a <wc_AddErrorNode+0x56>
            sz = WOLFSSL_MAX_ERROR_SZ - 1;
 801e776:	234f      	movs	r3, #79	@ 0x4f
 801e778:	61fb      	str	r3, [r7, #28]
        }
        if (sz > 0) {
 801e77a:	69fb      	ldr	r3, [r7, #28]
 801e77c:	2b00      	cmp	r3, #0
 801e77e:	dd06      	ble.n	801e78e <wc_AddErrorNode+0x6a>
            XMEMCPY(err->error, buf, sz);
 801e780:	69bb      	ldr	r3, [r7, #24]
 801e782:	330c      	adds	r3, #12
 801e784:	69fa      	ldr	r2, [r7, #28]
 801e786:	6879      	ldr	r1, [r7, #4]
 801e788:	4618      	mov	r0, r3
 801e78a:	f009 ff07 	bl	802859c <memcpy>
        }

        sz = (int)XSTRLEN(file);
 801e78e:	6838      	ldr	r0, [r7, #0]
 801e790:	f7e1 fd28 	bl	80001e4 <strlen>
 801e794:	4603      	mov	r3, r0
 801e796:	61fb      	str	r3, [r7, #28]
        if (sz > WOLFSSL_MAX_ERROR_SZ - 1) {
 801e798:	69fb      	ldr	r3, [r7, #28]
 801e79a:	2b4f      	cmp	r3, #79	@ 0x4f
 801e79c:	dd01      	ble.n	801e7a2 <wc_AddErrorNode+0x7e>
            sz = WOLFSSL_MAX_ERROR_SZ - 1;
 801e79e:	234f      	movs	r3, #79	@ 0x4f
 801e7a0:	61fb      	str	r3, [r7, #28]
        }
        if (sz > 0) {
 801e7a2:	69fb      	ldr	r3, [r7, #28]
 801e7a4:	2b00      	cmp	r3, #0
 801e7a6:	dd06      	ble.n	801e7b6 <wc_AddErrorNode+0x92>
            XMEMCPY(err->file, file, sz);
 801e7a8:	69bb      	ldr	r3, [r7, #24]
 801e7aa:	335c      	adds	r3, #92	@ 0x5c
 801e7ac:	69fa      	ldr	r2, [r7, #28]
 801e7ae:	6839      	ldr	r1, [r7, #0]
 801e7b0:	4618      	mov	r0, r3
 801e7b2:	f009 fef3 	bl	802859c <memcpy>
        }

        err->value = error;
 801e7b6:	69bb      	ldr	r3, [r7, #24]
 801e7b8:	68fa      	ldr	r2, [r7, #12]
 801e7ba:	f8c3 20ac 	str.w	r2, [r3, #172]	@ 0xac
        err->line  = line;
 801e7be:	69bb      	ldr	r3, [r7, #24]
 801e7c0:	68ba      	ldr	r2, [r7, #8]
 801e7c2:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0

        /* make sure is terminated */
        err->error[WOLFSSL_MAX_ERROR_SZ - 1] = '\0';
 801e7c6:	69bb      	ldr	r3, [r7, #24]
 801e7c8:	2200      	movs	r2, #0
 801e7ca:	f883 205b 	strb.w	r2, [r3, #91]	@ 0x5b
        err->file[WOLFSSL_MAX_ERROR_SZ - 1]  = '\0';
 801e7ce:	69bb      	ldr	r3, [r7, #24]
 801e7d0:	2200      	movs	r2, #0
 801e7d2:	f883 20ab 	strb.w	r2, [r3, #171]	@ 0xab


        /* since is queue place new node at last of the list */
        if (wc_last_node == NULL) {
 801e7d6:	4b1d      	ldr	r3, [pc, #116]	@ (801e84c <wc_AddErrorNode+0x128>)
 801e7d8:	681b      	ldr	r3, [r3, #0]
 801e7da:	2b00      	cmp	r3, #0
 801e7dc:	d116      	bne.n	801e80c <wc_AddErrorNode+0xe8>
            /* case of first node added to queue */
            if (wc_errors != NULL) {
 801e7de:	4b1c      	ldr	r3, [pc, #112]	@ (801e850 <wc_AddErrorNode+0x12c>)
 801e7e0:	681b      	ldr	r3, [r3, #0]
 801e7e2:	2b00      	cmp	r3, #0
 801e7e4:	d008      	beq.n	801e7f8 <wc_AddErrorNode+0xd4>
                WOLFSSL_MSG("ERROR in adding new node to logging queue!!");
                /* In the event both wc_last_node and wc_errors are NULL, err
                 * goes unassigned to external wc_errors, wc_last_node. Free
                 * err in this instance since wc_ClearErrorNodes will not
                 */
                XFREE(err, wc_error_heap, DYNAMIC_TYPE_LOG);
 801e7e6:	69bb      	ldr	r3, [r7, #24]
 801e7e8:	617b      	str	r3, [r7, #20]
 801e7ea:	697b      	ldr	r3, [r7, #20]
 801e7ec:	2b00      	cmp	r3, #0
 801e7ee:	d01f      	beq.n	801e830 <wc_AddErrorNode+0x10c>
 801e7f0:	6978      	ldr	r0, [r7, #20]
 801e7f2:	f000 f965 	bl	801eac0 <wolfSSL_Free>
 801e7f6:	e01b      	b.n	801e830 <wc_AddErrorNode+0x10c>
            }
            else {
                wc_errors    = err;
 801e7f8:	4a15      	ldr	r2, [pc, #84]	@ (801e850 <wc_AddErrorNode+0x12c>)
 801e7fa:	69bb      	ldr	r3, [r7, #24]
 801e7fc:	6013      	str	r3, [r2, #0]
                wc_last_node = err;
 801e7fe:	4a13      	ldr	r2, [pc, #76]	@ (801e84c <wc_AddErrorNode+0x128>)
 801e800:	69bb      	ldr	r3, [r7, #24]
 801e802:	6013      	str	r3, [r2, #0]
                wc_current_node = err;
 801e804:	4a13      	ldr	r2, [pc, #76]	@ (801e854 <wc_AddErrorNode+0x130>)
 801e806:	69bb      	ldr	r3, [r7, #24]
 801e808:	6013      	str	r3, [r2, #0]
 801e80a:	e011      	b.n	801e830 <wc_AddErrorNode+0x10c>
            }
        }
        else {
            wc_last_node->next = err;
 801e80c:	4b0f      	ldr	r3, [pc, #60]	@ (801e84c <wc_AddErrorNode+0x128>)
 801e80e:	681b      	ldr	r3, [r3, #0]
 801e810:	69ba      	ldr	r2, [r7, #24]
 801e812:	605a      	str	r2, [r3, #4]
            err->prev = wc_last_node;
 801e814:	4b0d      	ldr	r3, [pc, #52]	@ (801e84c <wc_AddErrorNode+0x128>)
 801e816:	681a      	ldr	r2, [r3, #0]
 801e818:	69bb      	ldr	r3, [r7, #24]
 801e81a:	609a      	str	r2, [r3, #8]
            wc_last_node = err;
 801e81c:	4a0b      	ldr	r2, [pc, #44]	@ (801e84c <wc_AddErrorNode+0x128>)
 801e81e:	69bb      	ldr	r3, [r7, #24]
 801e820:	6013      	str	r3, [r2, #0]

            /* check the case where have read to the end of the queue and the
             * current node to read needs updated */
            if (wc_current_node == NULL) {
 801e822:	4b0c      	ldr	r3, [pc, #48]	@ (801e854 <wc_AddErrorNode+0x130>)
 801e824:	681b      	ldr	r3, [r3, #0]
 801e826:	2b00      	cmp	r3, #0
 801e828:	d102      	bne.n	801e830 <wc_AddErrorNode+0x10c>
                wc_current_node = err;
 801e82a:	4a0a      	ldr	r2, [pc, #40]	@ (801e854 <wc_AddErrorNode+0x130>)
 801e82c:	69bb      	ldr	r3, [r7, #24]
 801e82e:	6013      	str	r3, [r2, #0]
            }
        }
        wc_errors_count++;
 801e830:	4b04      	ldr	r3, [pc, #16]	@ (801e844 <wc_AddErrorNode+0x120>)
 801e832:	681b      	ldr	r3, [r3, #0]
 801e834:	3301      	adds	r3, #1
 801e836:	4a03      	ldr	r2, [pc, #12]	@ (801e844 <wc_AddErrorNode+0x120>)
 801e838:	6013      	str	r3, [r2, #0]
    }
    return 0;
 801e83a:	2300      	movs	r3, #0
}
 801e83c:	4618      	mov	r0, r3
 801e83e:	3720      	adds	r7, #32
 801e840:	46bd      	mov	sp, r7
 801e842:	bd80      	pop	{r7, pc}
 801e844:	200028e8 	.word	0x200028e8
 801e848:	200028f4 	.word	0x200028f4
 801e84c:	200028ec 	.word	0x200028ec
 801e850:	200028e4 	.word	0x200028e4
 801e854:	200028f0 	.word	0x200028f0

0801e858 <removeErrorNode>:
    }
    return ret;
}

static void removeErrorNode(int idx)
{
 801e858:	b580      	push	{r7, lr}
 801e85a:	b084      	sub	sp, #16
 801e85c:	af00      	add	r7, sp, #0
 801e85e:	6078      	str	r0, [r7, #4]
    struct wc_error_queue* current;

    if (idx == -1) {
 801e860:	687b      	ldr	r3, [r7, #4]
 801e862:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 801e866:	d103      	bne.n	801e870 <removeErrorNode+0x18>
        current = wc_last_node;
 801e868:	4b30      	ldr	r3, [pc, #192]	@ (801e92c <removeErrorNode+0xd4>)
 801e86a:	681b      	ldr	r3, [r3, #0]
 801e86c:	60fb      	str	r3, [r7, #12]
 801e86e:	e00f      	b.n	801e890 <removeErrorNode+0x38>
    }
    else {
        current = (struct wc_error_queue*)wc_errors;
 801e870:	4b2f      	ldr	r3, [pc, #188]	@ (801e930 <removeErrorNode+0xd8>)
 801e872:	681b      	ldr	r3, [r3, #0]
 801e874:	60fb      	str	r3, [r7, #12]
        for (; current != NULL && idx > 0; idx--)
 801e876:	e005      	b.n	801e884 <removeErrorNode+0x2c>
             current = current->next;
 801e878:	68fb      	ldr	r3, [r7, #12]
 801e87a:	685b      	ldr	r3, [r3, #4]
 801e87c:	60fb      	str	r3, [r7, #12]
        for (; current != NULL && idx > 0; idx--)
 801e87e:	687b      	ldr	r3, [r7, #4]
 801e880:	3b01      	subs	r3, #1
 801e882:	607b      	str	r3, [r7, #4]
 801e884:	68fb      	ldr	r3, [r7, #12]
 801e886:	2b00      	cmp	r3, #0
 801e888:	d002      	beq.n	801e890 <removeErrorNode+0x38>
 801e88a:	687b      	ldr	r3, [r7, #4]
 801e88c:	2b00      	cmp	r3, #0
 801e88e:	dcf3      	bgt.n	801e878 <removeErrorNode+0x20>
    }
    if (current != NULL) {
 801e890:	68fb      	ldr	r3, [r7, #12]
 801e892:	2b00      	cmp	r3, #0
 801e894:	d046      	beq.n	801e924 <removeErrorNode+0xcc>
        if (current->prev != NULL)
 801e896:	68fb      	ldr	r3, [r7, #12]
 801e898:	689b      	ldr	r3, [r3, #8]
 801e89a:	2b00      	cmp	r3, #0
 801e89c:	d004      	beq.n	801e8a8 <removeErrorNode+0x50>
            current->prev->next = current->next;
 801e89e:	68fb      	ldr	r3, [r7, #12]
 801e8a0:	689b      	ldr	r3, [r3, #8]
 801e8a2:	68fa      	ldr	r2, [r7, #12]
 801e8a4:	6852      	ldr	r2, [r2, #4]
 801e8a6:	605a      	str	r2, [r3, #4]
        if (current->next != NULL)
 801e8a8:	68fb      	ldr	r3, [r7, #12]
 801e8aa:	685b      	ldr	r3, [r3, #4]
 801e8ac:	2b00      	cmp	r3, #0
 801e8ae:	d004      	beq.n	801e8ba <removeErrorNode+0x62>
            current->next->prev = current->prev;
 801e8b0:	68fb      	ldr	r3, [r7, #12]
 801e8b2:	685b      	ldr	r3, [r3, #4]
 801e8b4:	68fa      	ldr	r2, [r7, #12]
 801e8b6:	6892      	ldr	r2, [r2, #8]
 801e8b8:	609a      	str	r2, [r3, #8]
        if (wc_last_node == current)
 801e8ba:	4b1c      	ldr	r3, [pc, #112]	@ (801e92c <removeErrorNode+0xd4>)
 801e8bc:	681b      	ldr	r3, [r3, #0]
 801e8be:	68fa      	ldr	r2, [r7, #12]
 801e8c0:	429a      	cmp	r2, r3
 801e8c2:	d103      	bne.n	801e8cc <removeErrorNode+0x74>
            wc_last_node = current->prev;
 801e8c4:	68fb      	ldr	r3, [r7, #12]
 801e8c6:	689b      	ldr	r3, [r3, #8]
 801e8c8:	4a18      	ldr	r2, [pc, #96]	@ (801e92c <removeErrorNode+0xd4>)
 801e8ca:	6013      	str	r3, [r2, #0]
        if (wc_errors == current)
 801e8cc:	4b18      	ldr	r3, [pc, #96]	@ (801e930 <removeErrorNode+0xd8>)
 801e8ce:	681b      	ldr	r3, [r3, #0]
 801e8d0:	68fa      	ldr	r2, [r7, #12]
 801e8d2:	429a      	cmp	r2, r3
 801e8d4:	d103      	bne.n	801e8de <removeErrorNode+0x86>
            wc_errors = current->next;
 801e8d6:	68fb      	ldr	r3, [r7, #12]
 801e8d8:	685b      	ldr	r3, [r3, #4]
 801e8da:	4a15      	ldr	r2, [pc, #84]	@ (801e930 <removeErrorNode+0xd8>)
 801e8dc:	6013      	str	r3, [r2, #0]
        if (wc_current_node == current)
 801e8de:	4b15      	ldr	r3, [pc, #84]	@ (801e934 <removeErrorNode+0xdc>)
 801e8e0:	681b      	ldr	r3, [r3, #0]
 801e8e2:	68fa      	ldr	r2, [r7, #12]
 801e8e4:	429a      	cmp	r2, r3
 801e8e6:	d103      	bne.n	801e8f0 <removeErrorNode+0x98>
            wc_current_node = current->next;
 801e8e8:	68fb      	ldr	r3, [r7, #12]
 801e8ea:	685b      	ldr	r3, [r3, #4]
 801e8ec:	4a11      	ldr	r2, [pc, #68]	@ (801e934 <removeErrorNode+0xdc>)
 801e8ee:	6013      	str	r3, [r2, #0]
        XFREE(current, current->heap, DYNAMIC_TYPE_LOG);
 801e8f0:	68fb      	ldr	r3, [r7, #12]
 801e8f2:	60bb      	str	r3, [r7, #8]
 801e8f4:	68bb      	ldr	r3, [r7, #8]
 801e8f6:	2b00      	cmp	r3, #0
 801e8f8:	d002      	beq.n	801e900 <removeErrorNode+0xa8>
 801e8fa:	68b8      	ldr	r0, [r7, #8]
 801e8fc:	f000 f8e0 	bl	801eac0 <wolfSSL_Free>
        wc_errors_count--;
 801e900:	4b0d      	ldr	r3, [pc, #52]	@ (801e938 <removeErrorNode+0xe0>)
 801e902:	681b      	ldr	r3, [r3, #0]
 801e904:	3b01      	subs	r3, #1
 801e906:	4a0c      	ldr	r2, [pc, #48]	@ (801e938 <removeErrorNode+0xe0>)
 801e908:	6013      	str	r3, [r2, #0]

        /* last node left in list was free'd, reset list head */
        if (wc_errors_count == 0) {
 801e90a:	4b0b      	ldr	r3, [pc, #44]	@ (801e938 <removeErrorNode+0xe0>)
 801e90c:	681b      	ldr	r3, [r3, #0]
 801e90e:	2b00      	cmp	r3, #0
 801e910:	d108      	bne.n	801e924 <removeErrorNode+0xcc>
            wc_errors       = NULL;
 801e912:	4b07      	ldr	r3, [pc, #28]	@ (801e930 <removeErrorNode+0xd8>)
 801e914:	2200      	movs	r2, #0
 801e916:	601a      	str	r2, [r3, #0]
            wc_last_node    = NULL;
 801e918:	4b04      	ldr	r3, [pc, #16]	@ (801e92c <removeErrorNode+0xd4>)
 801e91a:	2200      	movs	r2, #0
 801e91c:	601a      	str	r2, [r3, #0]
            wc_current_node = NULL;
 801e91e:	4b05      	ldr	r3, [pc, #20]	@ (801e934 <removeErrorNode+0xdc>)
 801e920:	2200      	movs	r2, #0
 801e922:	601a      	str	r2, [r3, #0]
        }
    }
}
 801e924:	bf00      	nop
 801e926:	3710      	adds	r7, #16
 801e928:	46bd      	mov	sp, r7
 801e92a:	bd80      	pop	{r7, pc}
 801e92c:	200028ec 	.word	0x200028ec
 801e930:	200028e4 	.word	0x200028e4
 801e934:	200028f0 	.word	0x200028f0
 801e938:	200028e8 	.word	0x200028e8

0801e93c <wc_RemoveErrorNode>:
 * idx : if -1 then the most recent node is looked at,
 *       otherwise search through queue for node at the given index starting
 *          from the absolute head wc_errors
 */
void wc_RemoveErrorNode(int idx)
{
 801e93c:	b580      	push	{r7, lr}
 801e93e:	b082      	sub	sp, #8
 801e940:	af00      	add	r7, sp, #0
 801e942:	6078      	str	r0, [r7, #4]
    if (ERRQ_LOCK() != 0) {
 801e944:	4808      	ldr	r0, [pc, #32]	@ (801e968 <wc_RemoveErrorNode+0x2c>)
 801e946:	f008 fd2f 	bl	80273a8 <wc_LockMutex>
 801e94a:	4603      	mov	r3, r0
 801e94c:	2b00      	cmp	r3, #0
 801e94e:	d106      	bne.n	801e95e <wc_RemoveErrorNode+0x22>
        WOLFSSL_MSG("Lock debug mutex failed");
        return;
    }

    removeErrorNode(idx);
 801e950:	6878      	ldr	r0, [r7, #4]
 801e952:	f7ff ff81 	bl	801e858 <removeErrorNode>

    ERRQ_UNLOCK();
 801e956:	4804      	ldr	r0, [pc, #16]	@ (801e968 <wc_RemoveErrorNode+0x2c>)
 801e958:	f008 fd31 	bl	80273be <wc_UnLockMutex>
 801e95c:	e000      	b.n	801e960 <wc_RemoveErrorNode+0x24>
        return;
 801e95e:	bf00      	nop
}
 801e960:	3708      	adds	r7, #8
 801e962:	46bd      	mov	sp, r7
 801e964:	bd80      	pop	{r7, pc}
 801e966:	bf00      	nop
 801e968:	200028f8 	.word	0x200028f8

0801e96c <clearErrorNodes>:

static void clearErrorNodes(void)
{
 801e96c:	b580      	push	{r7, lr}
 801e96e:	b084      	sub	sp, #16
 801e970:	af00      	add	r7, sp, #0
    struct wc_error_queue* current;
    struct wc_error_queue* next;
    /* free all nodes from error queue (even previously 'pulled' ones) starting
     * at the lists absolute head of wc_errors */

    current = (struct wc_error_queue*)wc_errors;
 801e972:	4b12      	ldr	r3, [pc, #72]	@ (801e9bc <clearErrorNodes+0x50>)
 801e974:	681b      	ldr	r3, [r3, #0]
 801e976:	60fb      	str	r3, [r7, #12]
    while (current != NULL) {
 801e978:	e00c      	b.n	801e994 <clearErrorNodes+0x28>
        next = current->next;
 801e97a:	68fb      	ldr	r3, [r7, #12]
 801e97c:	685b      	ldr	r3, [r3, #4]
 801e97e:	60bb      	str	r3, [r7, #8]
        XFREE(current, current->heap, DYNAMIC_TYPE_LOG);
 801e980:	68fb      	ldr	r3, [r7, #12]
 801e982:	607b      	str	r3, [r7, #4]
 801e984:	687b      	ldr	r3, [r7, #4]
 801e986:	2b00      	cmp	r3, #0
 801e988:	d002      	beq.n	801e990 <clearErrorNodes+0x24>
 801e98a:	6878      	ldr	r0, [r7, #4]
 801e98c:	f000 f898 	bl	801eac0 <wolfSSL_Free>
        current = next;
 801e990:	68bb      	ldr	r3, [r7, #8]
 801e992:	60fb      	str	r3, [r7, #12]
    while (current != NULL) {
 801e994:	68fb      	ldr	r3, [r7, #12]
 801e996:	2b00      	cmp	r3, #0
 801e998:	d1ef      	bne.n	801e97a <clearErrorNodes+0xe>
    }

    wc_errors_count = 0;
 801e99a:	4b09      	ldr	r3, [pc, #36]	@ (801e9c0 <clearErrorNodes+0x54>)
 801e99c:	2200      	movs	r2, #0
 801e99e:	601a      	str	r2, [r3, #0]
    wc_errors       = NULL;
 801e9a0:	4b06      	ldr	r3, [pc, #24]	@ (801e9bc <clearErrorNodes+0x50>)
 801e9a2:	2200      	movs	r2, #0
 801e9a4:	601a      	str	r2, [r3, #0]
    wc_last_node    = NULL;
 801e9a6:	4b07      	ldr	r3, [pc, #28]	@ (801e9c4 <clearErrorNodes+0x58>)
 801e9a8:	2200      	movs	r2, #0
 801e9aa:	601a      	str	r2, [r3, #0]
    wc_current_node = NULL;
 801e9ac:	4b06      	ldr	r3, [pc, #24]	@ (801e9c8 <clearErrorNodes+0x5c>)
 801e9ae:	2200      	movs	r2, #0
 801e9b0:	601a      	str	r2, [r3, #0]
}
 801e9b2:	bf00      	nop
 801e9b4:	3710      	adds	r7, #16
 801e9b6:	46bd      	mov	sp, r7
 801e9b8:	bd80      	pop	{r7, pc}
 801e9ba:	bf00      	nop
 801e9bc:	200028e4 	.word	0x200028e4
 801e9c0:	200028e8 	.word	0x200028e8
 801e9c4:	200028ec 	.word	0x200028ec
 801e9c8:	200028f0 	.word	0x200028f0

0801e9cc <wc_ClearErrorNodes>:

/* Clears out the list of error nodes.
 */
void wc_ClearErrorNodes(void)
{
 801e9cc:	b580      	push	{r7, lr}
 801e9ce:	af00      	add	r7, sp, #0
    if (ERRQ_LOCK() != 0) {
 801e9d0:	4806      	ldr	r0, [pc, #24]	@ (801e9ec <wc_ClearErrorNodes+0x20>)
 801e9d2:	f008 fce9 	bl	80273a8 <wc_LockMutex>
 801e9d6:	4603      	mov	r3, r0
 801e9d8:	2b00      	cmp	r3, #0
 801e9da:	d105      	bne.n	801e9e8 <wc_ClearErrorNodes+0x1c>
        WOLFSSL_MSG("Lock debug mutex failed");
        return;
    }

    clearErrorNodes();
 801e9dc:	f7ff ffc6 	bl	801e96c <clearErrorNodes>

    ERRQ_UNLOCK();
 801e9e0:	4802      	ldr	r0, [pc, #8]	@ (801e9ec <wc_ClearErrorNodes+0x20>)
 801e9e2:	f008 fcec 	bl	80273be <wc_UnLockMutex>
 801e9e6:	e000      	b.n	801e9ea <wc_ClearErrorNodes+0x1e>
        return;
 801e9e8:	bf00      	nop
}
 801e9ea:	bd80      	pop	{r7, pc}
 801e9ec:	200028f8 	.word	0x200028f8

0801e9f0 <WOLFSSL_ERROR_LINE>:
void WOLFSSL_ERROR_LINE(int error, const char* func, unsigned int line,
        const char* file, void* usrCtx)
#else
void WOLFSSL_ERROR(int error)
#endif
{
 801e9f0:	b580      	push	{r7, lr}
 801e9f2:	b09a      	sub	sp, #104	@ 0x68
 801e9f4:	af02      	add	r7, sp, #8
 801e9f6:	60f8      	str	r0, [r7, #12]
 801e9f8:	60b9      	str	r1, [r7, #8]
 801e9fa:	607a      	str	r2, [r7, #4]
 801e9fc:	603b      	str	r3, [r7, #0]

    #ifdef WOLFSSL_HAVE_ERROR_QUEUE
        (void)usrCtx; /* a user ctx for future flexibility */
        (void)func;

        if (ERRQ_LOCK() != 0) {
 801e9fe:	481f      	ldr	r0, [pc, #124]	@ (801ea7c <WOLFSSL_ERROR_LINE+0x8c>)
 801ea00:	f008 fcd2 	bl	80273a8 <wc_LockMutex>
 801ea04:	4603      	mov	r3, r0
 801ea06:	2b00      	cmp	r3, #0
 801ea08:	d007      	beq.n	801ea1a <WOLFSSL_ERROR_LINE+0x2a>
            WOLFSSL_MSG("Lock debug mutex failed");
            (void)XSNPRINTF(buffer, sizeof(buffer),
 801ea0a:	f107 0010 	add.w	r0, r7, #16
 801ea0e:	68fb      	ldr	r3, [r7, #12]
 801ea10:	4a1b      	ldr	r2, [pc, #108]	@ (801ea80 <WOLFSSL_ERROR_LINE+0x90>)
 801ea12:	2150      	movs	r1, #80	@ 0x50
 801ea14:	f009 fcf8 	bl	8028408 <sniprintf>
    #ifdef DEBUG_WOLFSSL
        if (loggingEnabled)
            wolfssl_log(ERROR_LOG, NULL, 0, buffer);
    #endif
    }
}
 801ea18:	e02c      	b.n	801ea74 <WOLFSSL_ERROR_LINE+0x84>
            if (error != WC_NO_ERR_TRACE(WANT_READ) &&
 801ea1a:	68fb      	ldr	r3, [r7, #12]
 801ea1c:	f46f 72a1 	mvn.w	r2, #322	@ 0x142
 801ea20:	4293      	cmp	r3, r2
 801ea22:	d01d      	beq.n	801ea60 <WOLFSSL_ERROR_LINE+0x70>
 801ea24:	68fb      	ldr	r3, [r7, #12]
 801ea26:	f46f 72a3 	mvn.w	r2, #326	@ 0x146
 801ea2a:	4293      	cmp	r3, r2
 801ea2c:	d018      	beq.n	801ea60 <WOLFSSL_ERROR_LINE+0x70>
            if (error < 0)
 801ea2e:	68fb      	ldr	r3, [r7, #12]
 801ea30:	2b00      	cmp	r3, #0
 801ea32:	da02      	bge.n	801ea3a <WOLFSSL_ERROR_LINE+0x4a>
                error = error - (2 * error); /* get absolute value */
 801ea34:	68fb      	ldr	r3, [r7, #12]
 801ea36:	425b      	negs	r3, r3
 801ea38:	60fb      	str	r3, [r7, #12]
            (void)XSNPRINTF(buffer, sizeof(buffer),
 801ea3a:	f107 0010 	add.w	r0, r7, #16
 801ea3e:	683b      	ldr	r3, [r7, #0]
 801ea40:	9301      	str	r3, [sp, #4]
 801ea42:	687b      	ldr	r3, [r7, #4]
 801ea44:	9300      	str	r3, [sp, #0]
 801ea46:	68fb      	ldr	r3, [r7, #12]
 801ea48:	4a0e      	ldr	r2, [pc, #56]	@ (801ea84 <WOLFSSL_ERROR_LINE+0x94>)
 801ea4a:	2150      	movs	r1, #80	@ 0x50
 801ea4c:	f009 fcdc 	bl	8028408 <sniprintf>
            if (wc_AddErrorNode(error, (int)line, buffer, (char*)file) != 0) {
 801ea50:	6879      	ldr	r1, [r7, #4]
 801ea52:	f107 0210 	add.w	r2, r7, #16
 801ea56:	683b      	ldr	r3, [r7, #0]
 801ea58:	68f8      	ldr	r0, [r7, #12]
 801ea5a:	f7ff fe63 	bl	801e724 <wc_AddErrorNode>
 801ea5e:	e006      	b.n	801ea6e <WOLFSSL_ERROR_LINE+0x7e>
                (void)XSNPRINTF(buffer, sizeof(buffer),
 801ea60:	f107 0010 	add.w	r0, r7, #16
 801ea64:	68fb      	ldr	r3, [r7, #12]
 801ea66:	4a06      	ldr	r2, [pc, #24]	@ (801ea80 <WOLFSSL_ERROR_LINE+0x90>)
 801ea68:	2150      	movs	r1, #80	@ 0x50
 801ea6a:	f009 fccd 	bl	8028408 <sniprintf>
            ERRQ_UNLOCK();
 801ea6e:	4803      	ldr	r0, [pc, #12]	@ (801ea7c <WOLFSSL_ERROR_LINE+0x8c>)
 801ea70:	f008 fca5 	bl	80273be <wc_UnLockMutex>
}
 801ea74:	bf00      	nop
 801ea76:	3760      	adds	r7, #96	@ 0x60
 801ea78:	46bd      	mov	sp, r7
 801ea7a:	bd80      	pop	{r7, pc}
 801ea7c:	200028f8 	.word	0x200028f8
 801ea80:	0802feb4 	.word	0x0802feb4
 801ea84:	0802fed8 	.word	0x0802fed8

0801ea88 <wolfSSL_Malloc>:
#ifdef WOLFSSL_DEBUG_MEMORY
void* wolfSSL_Malloc(size_t size, const char* func, unsigned int line)
#else
void* wolfSSL_Malloc(size_t size)
#endif
{
 801ea88:	b580      	push	{r7, lr}
 801ea8a:	b084      	sub	sp, #16
 801ea8c:	af00      	add	r7, sp, #0
 801ea8e:	6078      	str	r0, [r7, #4]
    void* res = 0;
 801ea90:	2300      	movs	r3, #0
 801ea92:	60fb      	str	r3, [r7, #12]
#ifdef WOLFSSL_CHECK_MEM_ZERO
    /* Space for requested size. */
    size += MEM_ALIGN;
#endif

    if (malloc_function) {
 801ea94:	4b09      	ldr	r3, [pc, #36]	@ (801eabc <wolfSSL_Malloc+0x34>)
 801ea96:	681b      	ldr	r3, [r3, #0]
 801ea98:	2b00      	cmp	r3, #0
 801ea9a:	d005      	beq.n	801eaa8 <wolfSSL_Malloc+0x20>
    #ifdef WOLFSSL_DEBUG_MEMORY
        res = malloc_function(size, func, line);
    #else
        res = malloc_function(size);
 801ea9c:	4b07      	ldr	r3, [pc, #28]	@ (801eabc <wolfSSL_Malloc+0x34>)
 801ea9e:	681b      	ldr	r3, [r3, #0]
 801eaa0:	6878      	ldr	r0, [r7, #4]
 801eaa2:	4798      	blx	r3
 801eaa4:	60f8      	str	r0, [r7, #12]
 801eaa6:	e004      	b.n	801eab2 <wolfSSL_Malloc+0x2a>
            WOLFSSL_MSG("Malloc too big!");
            return NULL;
        }
        #endif

        res = malloc(size); /* native heap */
 801eaa8:	6878      	ldr	r0, [r7, #4]
 801eaaa:	f009 fbc1 	bl	8028230 <malloc>
 801eaae:	4603      	mov	r3, r0
 801eab0:	60fb      	str	r3, [r7, #12]
        gMemFailCount = gMemFailCountSeed; /* reset */
        return NULL;
    }
#endif

    return res;
 801eab2:	68fb      	ldr	r3, [r7, #12]
}
 801eab4:	4618      	mov	r0, r3
 801eab6:	3710      	adds	r7, #16
 801eab8:	46bd      	mov	sp, r7
 801eaba:	bd80      	pop	{r7, pc}
 801eabc:	200028fc 	.word	0x200028fc

0801eac0 <wolfSSL_Free>:
#ifdef WOLFSSL_DEBUG_MEMORY
void wolfSSL_Free(void *ptr, const char* func, unsigned int line)
#else
void wolfSSL_Free(void *ptr)
#endif
{
 801eac0:	b580      	push	{r7, lr}
 801eac2:	b082      	sub	sp, #8
 801eac4:	af00      	add	r7, sp, #0
 801eac6:	6078      	str	r0, [r7, #4]
#endif
#ifdef WOLFSSL_MEM_FAIL_COUNT
    wc_MemFailCount_FreeMem();
#endif

    if (free_function) {
 801eac8:	4b07      	ldr	r3, [pc, #28]	@ (801eae8 <wolfSSL_Free+0x28>)
 801eaca:	681b      	ldr	r3, [r3, #0]
 801eacc:	2b00      	cmp	r3, #0
 801eace:	d004      	beq.n	801eada <wolfSSL_Free+0x1a>
    #ifdef WOLFSSL_DEBUG_MEMORY
        free_function(ptr, func, line);
    #else
        free_function(ptr);
 801ead0:	4b05      	ldr	r3, [pc, #20]	@ (801eae8 <wolfSSL_Free+0x28>)
 801ead2:	681b      	ldr	r3, [r3, #0]
 801ead4:	6878      	ldr	r0, [r7, #4]
 801ead6:	4798      	blx	r3
        free(ptr); /* native heap */
    #else
        WOLFSSL_MSG("No free available");
    #endif
    }
}
 801ead8:	e002      	b.n	801eae0 <wolfSSL_Free+0x20>
        free(ptr); /* native heap */
 801eada:	6878      	ldr	r0, [r7, #4]
 801eadc:	f009 fbb0 	bl	8028240 <free>
}
 801eae0:	bf00      	nop
 801eae2:	3708      	adds	r7, #8
 801eae4:	46bd      	mov	sp, r7
 801eae6:	bd80      	pop	{r7, pc}
 801eae8:	20002900 	.word	0x20002900

0801eaec <rotlFixed>:
    {
 801eaec:	b480      	push	{r7}
 801eaee:	b083      	sub	sp, #12
 801eaf0:	af00      	add	r7, sp, #0
 801eaf2:	6078      	str	r0, [r7, #4]
 801eaf4:	6039      	str	r1, [r7, #0]
        return (x << y) | (x >> (sizeof(x) * 8 - y));
 801eaf6:	687a      	ldr	r2, [r7, #4]
 801eaf8:	683b      	ldr	r3, [r7, #0]
 801eafa:	f1c3 0320 	rsb	r3, r3, #32
 801eafe:	fa62 f303 	ror.w	r3, r2, r3
    }
 801eb02:	4618      	mov	r0, r3
 801eb04:	370c      	adds	r7, #12
 801eb06:	46bd      	mov	sp, r7
 801eb08:	f85d 7b04 	ldr.w	r7, [sp], #4
 801eb0c:	4770      	bx	lr

0801eb0e <ByteReverseWord32>:
{
 801eb0e:	b580      	push	{r7, lr}
 801eb10:	b082      	sub	sp, #8
 801eb12:	af00      	add	r7, sp, #0
 801eb14:	6078      	str	r0, [r7, #4]
    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
 801eb16:	687b      	ldr	r3, [r7, #4]
 801eb18:	0a1b      	lsrs	r3, r3, #8
 801eb1a:	f003 12ff 	and.w	r2, r3, #16711935	@ 0xff00ff
 801eb1e:	687b      	ldr	r3, [r7, #4]
 801eb20:	021b      	lsls	r3, r3, #8
 801eb22:	f003 23ff 	and.w	r3, r3, #4278255360	@ 0xff00ff00
 801eb26:	4313      	orrs	r3, r2
 801eb28:	607b      	str	r3, [r7, #4]
    return rotlFixed(value, 16U);
 801eb2a:	2110      	movs	r1, #16
 801eb2c:	6878      	ldr	r0, [r7, #4]
 801eb2e:	f7ff ffdd 	bl	801eaec <rotlFixed>
 801eb32:	4603      	mov	r3, r0
}
 801eb34:	4618      	mov	r0, r3
 801eb36:	3708      	adds	r7, #8
 801eb38:	46bd      	mov	sp, r7
 801eb3a:	bd80      	pop	{r7, pc}

0801eb3c <ForceZero>:
{
 801eb3c:	b480      	push	{r7}
 801eb3e:	b085      	sub	sp, #20
 801eb40:	af00      	add	r7, sp, #0
 801eb42:	6078      	str	r0, [r7, #4]
 801eb44:	6039      	str	r1, [r7, #0]
    volatile byte* z = (volatile byte*)mem;
 801eb46:	687b      	ldr	r3, [r7, #4]
 801eb48:	60fb      	str	r3, [r7, #12]
    while (len--) *z++ = 0;
 801eb4a:	e004      	b.n	801eb56 <ForceZero+0x1a>
 801eb4c:	68fb      	ldr	r3, [r7, #12]
 801eb4e:	1c5a      	adds	r2, r3, #1
 801eb50:	60fa      	str	r2, [r7, #12]
 801eb52:	2200      	movs	r2, #0
 801eb54:	701a      	strb	r2, [r3, #0]
 801eb56:	683b      	ldr	r3, [r7, #0]
 801eb58:	1e5a      	subs	r2, r3, #1
 801eb5a:	603a      	str	r2, [r7, #0]
 801eb5c:	2b00      	cmp	r3, #0
 801eb5e:	d1f5      	bne.n	801eb4c <ForceZero+0x10>
}
 801eb60:	bf00      	nop
 801eb62:	bf00      	nop
 801eb64:	3714      	adds	r7, #20
 801eb66:	46bd      	mov	sp, r7
 801eb68:	f85d 7b04 	ldr.w	r7, [sp], #4
 801eb6c:	4770      	bx	lr

0801eb6e <ConstantCompare>:
{
 801eb6e:	b480      	push	{r7}
 801eb70:	b087      	sub	sp, #28
 801eb72:	af00      	add	r7, sp, #0
 801eb74:	60f8      	str	r0, [r7, #12]
 801eb76:	60b9      	str	r1, [r7, #8]
 801eb78:	607a      	str	r2, [r7, #4]
    int compareSum = 0;
 801eb7a:	2300      	movs	r3, #0
 801eb7c:	613b      	str	r3, [r7, #16]
    for (i = 0; i < length; i++) {
 801eb7e:	2300      	movs	r3, #0
 801eb80:	617b      	str	r3, [r7, #20]
 801eb82:	e010      	b.n	801eba6 <ConstantCompare+0x38>
        compareSum |= a[i] ^ b[i];
 801eb84:	697b      	ldr	r3, [r7, #20]
 801eb86:	68fa      	ldr	r2, [r7, #12]
 801eb88:	4413      	add	r3, r2
 801eb8a:	781a      	ldrb	r2, [r3, #0]
 801eb8c:	697b      	ldr	r3, [r7, #20]
 801eb8e:	68b9      	ldr	r1, [r7, #8]
 801eb90:	440b      	add	r3, r1
 801eb92:	781b      	ldrb	r3, [r3, #0]
 801eb94:	4053      	eors	r3, r2
 801eb96:	b2db      	uxtb	r3, r3
 801eb98:	461a      	mov	r2, r3
 801eb9a:	693b      	ldr	r3, [r7, #16]
 801eb9c:	4313      	orrs	r3, r2
 801eb9e:	613b      	str	r3, [r7, #16]
    for (i = 0; i < length; i++) {
 801eba0:	697b      	ldr	r3, [r7, #20]
 801eba2:	3301      	adds	r3, #1
 801eba4:	617b      	str	r3, [r7, #20]
 801eba6:	697a      	ldr	r2, [r7, #20]
 801eba8:	687b      	ldr	r3, [r7, #4]
 801ebaa:	429a      	cmp	r2, r3
 801ebac:	dbea      	blt.n	801eb84 <ConstantCompare+0x16>
    return compareSum;
 801ebae:	693b      	ldr	r3, [r7, #16]
}
 801ebb0:	4618      	mov	r0, r3
 801ebb2:	371c      	adds	r7, #28
 801ebb4:	46bd      	mov	sp, r7
 801ebb6:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ebba:	4770      	bx	lr

0801ebbc <min>:
    {
 801ebbc:	b480      	push	{r7}
 801ebbe:	b083      	sub	sp, #12
 801ebc0:	af00      	add	r7, sp, #0
 801ebc2:	6078      	str	r0, [r7, #4]
 801ebc4:	6039      	str	r1, [r7, #0]
        return a > b ? b : a;
 801ebc6:	687a      	ldr	r2, [r7, #4]
 801ebc8:	683b      	ldr	r3, [r7, #0]
 801ebca:	4293      	cmp	r3, r2
 801ebcc:	bf28      	it	cs
 801ebce:	4613      	movcs	r3, r2
    }
 801ebd0:	4618      	mov	r0, r3
 801ebd2:	370c      	adds	r7, #12
 801ebd4:	46bd      	mov	sp, r7
 801ebd6:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ebda:	4770      	bx	lr

0801ebdc <Hash_df>:
/* Hash Derivation Function */
/* Returns: DRBG_SUCCESS or DRBG_FAILURE */
static int Hash_df(DRBG_internal* drbg, byte* out, word32 outSz, byte type,
                                                  const byte* inA, word32 inASz,
                                                  const byte* inB, word32 inBSz)
{
 801ebdc:	b580      	push	{r7, lr}
 801ebde:	b0a8      	sub	sp, #160	@ 0xa0
 801ebe0:	af00      	add	r7, sp, #0
 801ebe2:	60f8      	str	r0, [r7, #12]
 801ebe4:	60b9      	str	r1, [r7, #8]
 801ebe6:	607a      	str	r2, [r7, #4]
 801ebe8:	70fb      	strb	r3, [r7, #3]
    int ret = DRBG_FAILURE;
 801ebea:	2301      	movs	r3, #1
 801ebec:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
    byte ctr;
    word32 i;
    word32 len;
    word32 bits = (outSz * 8); /* reverse byte order */
 801ebf0:	687b      	ldr	r3, [r7, #4]
 801ebf2:	00db      	lsls	r3, r3, #3
 801ebf4:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
    byte* digest;
#else
    byte digest[WC_SHA256_DIGEST_SIZE];
#endif

    if (drbg == NULL) {
 801ebf8:	68fb      	ldr	r3, [r7, #12]
 801ebfa:	2b00      	cmp	r3, #0
 801ebfc:	d101      	bne.n	801ec02 <Hash_df+0x26>
        return DRBG_FAILURE;
 801ebfe:	2301      	movs	r3, #1
 801ec00:	e0d8      	b.n	801edb4 <Hash_df+0x1d8>
    }

#ifdef WOLFSSL_SMALL_STACK
    digest = (byte*)XMALLOC(WC_SHA256_DIGEST_SIZE, drbg->heap,
 801ec02:	2020      	movs	r0, #32
 801ec04:	f7ff ff40 	bl	801ea88 <wolfSSL_Malloc>
 801ec08:	f8c7 0094 	str.w	r0, [r7, #148]	@ 0x94
        DYNAMIC_TYPE_DIGEST);
    if (digest == NULL)
 801ec0c:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 801ec10:	2b00      	cmp	r3, #0
 801ec12:	d101      	bne.n	801ec18 <Hash_df+0x3c>
        return DRBG_FAILURE;
 801ec14:	2301      	movs	r3, #1
 801ec16:	e0cd      	b.n	801edb4 <Hash_df+0x1d8>
#endif

#ifdef LITTLE_ENDIAN_ORDER
    bits = ByteReverseWord32(bits);
 801ec18:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801ec1c:	4618      	mov	r0, r3
 801ec1e:	f7ff ff76 	bl	801eb0e <ByteReverseWord32>
 801ec22:	4603      	mov	r3, r0
 801ec24:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
#endif
    len = (outSz / OUTPUT_BLOCK_LEN)
 801ec28:	687b      	ldr	r3, [r7, #4]
 801ec2a:	095b      	lsrs	r3, r3, #5
        + ((outSz % OUTPUT_BLOCK_LEN) ? 1 : 0);
 801ec2c:	687a      	ldr	r2, [r7, #4]
 801ec2e:	f002 021f 	and.w	r2, r2, #31
 801ec32:	2a00      	cmp	r2, #0
 801ec34:	d001      	beq.n	801ec3a <Hash_df+0x5e>
 801ec36:	2201      	movs	r2, #1
 801ec38:	e000      	b.n	801ec3c <Hash_df+0x60>
 801ec3a:	2200      	movs	r2, #0
    len = (outSz / OUTPUT_BLOCK_LEN)
 801ec3c:	4413      	add	r3, r2
 801ec3e:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90

    ctr = 1;
 801ec42:	2301      	movs	r3, #1
 801ec44:	f887 308b 	strb.w	r3, [r7, #139]	@ 0x8b
    for (i = 0; i < len; i++) {
 801ec48:	2300      	movs	r3, #0
 801ec4a:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
 801ec4e:	e090      	b.n	801ed72 <Hash_df+0x196>
#ifndef WOLFSSL_SMALL_STACK_CACHE
    #if defined(WOLFSSL_ASYNC_CRYPT) || defined(WOLF_CRYPTO_CB)
        ret = wc_InitSha256_ex(sha, drbg->heap, drbg->devId);
    #else
        ret = wc_InitSha256(sha);
 801ec50:	f107 0314 	add.w	r3, r7, #20
 801ec54:	4618      	mov	r0, r3
 801ec56:	f003 f9c7 	bl	8021fe8 <wc_InitSha256>
 801ec5a:	f8c7 009c 	str.w	r0, [r7, #156]	@ 0x9c
    #endif
        if (ret != 0)
 801ec5e:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801ec62:	2b00      	cmp	r3, #0
 801ec64:	f040 808d 	bne.w	801ed82 <Hash_df+0x1a6>
            break;
#endif
        ret = wc_Sha256Update(sha, &ctr, sizeof(ctr));
 801ec68:	f107 018b 	add.w	r1, r7, #139	@ 0x8b
 801ec6c:	f107 0314 	add.w	r3, r7, #20
 801ec70:	2201      	movs	r2, #1
 801ec72:	4618      	mov	r0, r3
 801ec74:	f003 f8ef 	bl	8021e56 <wc_Sha256Update>
 801ec78:	f8c7 009c 	str.w	r0, [r7, #156]	@ 0x9c
        if (ret == 0) {
 801ec7c:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801ec80:	2b00      	cmp	r3, #0
 801ec82:	d10f      	bne.n	801eca4 <Hash_df+0xc8>
            ctr++;
 801ec84:	f897 308b 	ldrb.w	r3, [r7, #139]	@ 0x8b
 801ec88:	3301      	adds	r3, #1
 801ec8a:	b2db      	uxtb	r3, r3
 801ec8c:	f887 308b 	strb.w	r3, [r7, #139]	@ 0x8b
            ret = wc_Sha256Update(sha, (byte*)&bits, sizeof(bits));
 801ec90:	f107 0184 	add.w	r1, r7, #132	@ 0x84
 801ec94:	f107 0314 	add.w	r3, r7, #20
 801ec98:	2204      	movs	r2, #4
 801ec9a:	4618      	mov	r0, r3
 801ec9c:	f003 f8db 	bl	8021e56 <wc_Sha256Update>
 801eca0:	f8c7 009c 	str.w	r0, [r7, #156]	@ 0x9c
        }

        if (ret == 0) {
 801eca4:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801eca8:	2b00      	cmp	r3, #0
 801ecaa:	d10b      	bne.n	801ecc4 <Hash_df+0xe8>
            /* churning V is the only string that doesn't have the type added */
            if (type != drbgInitV)
 801ecac:	78fb      	ldrb	r3, [r7, #3]
 801ecae:	2b04      	cmp	r3, #4
 801ecb0:	d008      	beq.n	801ecc4 <Hash_df+0xe8>
                ret = wc_Sha256Update(sha, &type, sizeof(type));
 801ecb2:	1cf9      	adds	r1, r7, #3
 801ecb4:	f107 0314 	add.w	r3, r7, #20
 801ecb8:	2201      	movs	r2, #1
 801ecba:	4618      	mov	r0, r3
 801ecbc:	f003 f8cb 	bl	8021e56 <wc_Sha256Update>
 801ecc0:	f8c7 009c 	str.w	r0, [r7, #156]	@ 0x9c
        }
        if (ret == 0)
 801ecc4:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801ecc8:	2b00      	cmp	r3, #0
 801ecca:	d10a      	bne.n	801ece2 <Hash_df+0x106>
            ret = wc_Sha256Update(sha, inA, inASz);
 801eccc:	f107 0314 	add.w	r3, r7, #20
 801ecd0:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 801ecd4:	f8d7 10a8 	ldr.w	r1, [r7, #168]	@ 0xa8
 801ecd8:	4618      	mov	r0, r3
 801ecda:	f003 f8bc 	bl	8021e56 <wc_Sha256Update>
 801ecde:	f8c7 009c 	str.w	r0, [r7, #156]	@ 0x9c
        if (ret == 0) {
 801ece2:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801ece6:	2b00      	cmp	r3, #0
 801ece8:	d112      	bne.n	801ed10 <Hash_df+0x134>
            if (inB != NULL && inBSz > 0)
 801ecea:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 801ecee:	2b00      	cmp	r3, #0
 801ecf0:	d00e      	beq.n	801ed10 <Hash_df+0x134>
 801ecf2:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 801ecf6:	2b00      	cmp	r3, #0
 801ecf8:	d00a      	beq.n	801ed10 <Hash_df+0x134>
                ret = wc_Sha256Update(sha, inB, inBSz);
 801ecfa:	f107 0314 	add.w	r3, r7, #20
 801ecfe:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 801ed02:	f8d7 10b0 	ldr.w	r1, [r7, #176]	@ 0xb0
 801ed06:	4618      	mov	r0, r3
 801ed08:	f003 f8a5 	bl	8021e56 <wc_Sha256Update>
 801ed0c:	f8c7 009c 	str.w	r0, [r7, #156]	@ 0x9c
        }
        if (ret == 0)
 801ed10:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801ed14:	2b00      	cmp	r3, #0
 801ed16:	d108      	bne.n	801ed2a <Hash_df+0x14e>
            ret = wc_Sha256Final(sha, digest);
 801ed18:	f107 0314 	add.w	r3, r7, #20
 801ed1c:	f8d7 1094 	ldr.w	r1, [r7, #148]	@ 0x94
 801ed20:	4618      	mov	r0, r3
 801ed22:	f003 f936 	bl	8021f92 <wc_Sha256Final>
 801ed26:	f8c7 009c 	str.w	r0, [r7, #156]	@ 0x9c

#ifndef WOLFSSL_SMALL_STACK_CACHE
        wc_Sha256Free(sha);
 801ed2a:	f107 0314 	add.w	r3, r7, #20
 801ed2e:	4618      	mov	r0, r3
 801ed30:	f003 f96b 	bl	802200a <wc_Sha256Free>
#endif
        if (ret == 0) {
 801ed34:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801ed38:	2b00      	cmp	r3, #0
 801ed3a:	d115      	bne.n	801ed68 <Hash_df+0x18c>
            if (outSz > OUTPUT_BLOCK_LEN) {
 801ed3c:	687b      	ldr	r3, [r7, #4]
 801ed3e:	2b20      	cmp	r3, #32
 801ed40:	d90c      	bls.n	801ed5c <Hash_df+0x180>
                XMEMCPY(out, digest, OUTPUT_BLOCK_LEN);
 801ed42:	2220      	movs	r2, #32
 801ed44:	f8d7 1094 	ldr.w	r1, [r7, #148]	@ 0x94
 801ed48:	68b8      	ldr	r0, [r7, #8]
 801ed4a:	f009 fc27 	bl	802859c <memcpy>
                outSz -= OUTPUT_BLOCK_LEN;
 801ed4e:	687b      	ldr	r3, [r7, #4]
 801ed50:	3b20      	subs	r3, #32
 801ed52:	607b      	str	r3, [r7, #4]
                out += OUTPUT_BLOCK_LEN;
 801ed54:	68bb      	ldr	r3, [r7, #8]
 801ed56:	3320      	adds	r3, #32
 801ed58:	60bb      	str	r3, [r7, #8]
 801ed5a:	e005      	b.n	801ed68 <Hash_df+0x18c>
            }
            else {
                XMEMCPY(out, digest, outSz);
 801ed5c:	687a      	ldr	r2, [r7, #4]
 801ed5e:	f8d7 1094 	ldr.w	r1, [r7, #148]	@ 0x94
 801ed62:	68b8      	ldr	r0, [r7, #8]
 801ed64:	f009 fc1a 	bl	802859c <memcpy>
    for (i = 0; i < len; i++) {
 801ed68:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 801ed6c:	3301      	adds	r3, #1
 801ed6e:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
 801ed72:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801ed76:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 801ed7a:	429a      	cmp	r2, r3
 801ed7c:	f4ff af68 	bcc.w	801ec50 <Hash_df+0x74>
 801ed80:	e000      	b.n	801ed84 <Hash_df+0x1a8>
            break;
 801ed82:	bf00      	nop
            }
        }
    }

    ForceZero(digest, WC_SHA256_DIGEST_SIZE);
 801ed84:	2120      	movs	r1, #32
 801ed86:	f8d7 0094 	ldr.w	r0, [r7, #148]	@ 0x94
 801ed8a:	f7ff fed7 	bl	801eb3c <ForceZero>

#ifdef WOLFSSL_SMALL_STACK
    XFREE(digest, drbg->heap, DYNAMIC_TYPE_DIGEST);
 801ed8e:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 801ed92:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
 801ed96:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801ed9a:	2b00      	cmp	r3, #0
 801ed9c:	d003      	beq.n	801eda6 <Hash_df+0x1ca>
 801ed9e:	f8d7 008c 	ldr.w	r0, [r7, #140]	@ 0x8c
 801eda2:	f7ff fe8d 	bl	801eac0 <wolfSSL_Free>
#endif

    return (ret == 0) ? DRBG_SUCCESS : DRBG_FAILURE;
 801eda6:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801edaa:	2b00      	cmp	r3, #0
 801edac:	bf14      	ite	ne
 801edae:	2301      	movne	r3, #1
 801edb0:	2300      	moveq	r3, #0
 801edb2:	b2db      	uxtb	r3, r3
}
 801edb4:	4618      	mov	r0, r3
 801edb6:	37a0      	adds	r7, #160	@ 0xa0
 801edb8:	46bd      	mov	sp, r7
 801edba:	bd80      	pop	{r7, pc}

0801edbc <Hash_DRBG_Reseed>:

/* Returns: DRBG_SUCCESS or DRBG_FAILURE */
static int Hash_DRBG_Reseed(DRBG_internal* drbg, const byte* seed, word32 seedSz)
{
 801edbc:	b580      	push	{r7, lr}
 801edbe:	b08c      	sub	sp, #48	@ 0x30
 801edc0:	af04      	add	r7, sp, #16
 801edc2:	60f8      	str	r0, [r7, #12]
 801edc4:	60b9      	str	r1, [r7, #8]
 801edc6:	607a      	str	r2, [r7, #4]
    byte* newV;
#else
    byte newV[DRBG_SEED_LEN];
#endif

    if (drbg == NULL) {
 801edc8:	68fb      	ldr	r3, [r7, #12]
 801edca:	2b00      	cmp	r3, #0
 801edcc:	d101      	bne.n	801edd2 <Hash_DRBG_Reseed+0x16>
        return DRBG_FAILURE;
 801edce:	2301      	movs	r3, #1
 801edd0:	e04d      	b.n	801ee6e <Hash_DRBG_Reseed+0xb2>
    }

#ifdef WOLFSSL_SMALL_STACK
    newV = (byte*)XMALLOC(DRBG_SEED_LEN, drbg->heap, DYNAMIC_TYPE_TMP_BUFFER);
 801edd2:	2037      	movs	r0, #55	@ 0x37
 801edd4:	f7ff fe58 	bl	801ea88 <wolfSSL_Malloc>
 801edd8:	61b8      	str	r0, [r7, #24]
    if (newV == NULL) {
 801edda:	69bb      	ldr	r3, [r7, #24]
 801eddc:	2b00      	cmp	r3, #0
 801edde:	d102      	bne.n	801ede6 <Hash_DRBG_Reseed+0x2a>
        return MEMORY_E;
 801ede0:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801ede4:	e043      	b.n	801ee6e <Hash_DRBG_Reseed+0xb2>
    }
#endif
    XMEMSET(newV, 0, DRBG_SEED_LEN);
 801ede6:	2237      	movs	r2, #55	@ 0x37
 801ede8:	2100      	movs	r1, #0
 801edea:	69b8      	ldr	r0, [r7, #24]
 801edec:	f009 fb6c 	bl	80284c8 <memset>

    ret = Hash_df(drbg, newV, DRBG_SEED_LEN, drbgReseed,
                drbg->V, sizeof(drbg->V), seed, seedSz);
 801edf0:	68fb      	ldr	r3, [r7, #12]
 801edf2:	3304      	adds	r3, #4
    ret = Hash_df(drbg, newV, DRBG_SEED_LEN, drbgReseed,
 801edf4:	687a      	ldr	r2, [r7, #4]
 801edf6:	9203      	str	r2, [sp, #12]
 801edf8:	68ba      	ldr	r2, [r7, #8]
 801edfa:	9202      	str	r2, [sp, #8]
 801edfc:	2237      	movs	r2, #55	@ 0x37
 801edfe:	9201      	str	r2, [sp, #4]
 801ee00:	9300      	str	r3, [sp, #0]
 801ee02:	2301      	movs	r3, #1
 801ee04:	2237      	movs	r2, #55	@ 0x37
 801ee06:	69b9      	ldr	r1, [r7, #24]
 801ee08:	68f8      	ldr	r0, [r7, #12]
 801ee0a:	f7ff fee7 	bl	801ebdc <Hash_df>
 801ee0e:	61f8      	str	r0, [r7, #28]
    if (ret == DRBG_SUCCESS) {
 801ee10:	69fb      	ldr	r3, [r7, #28]
 801ee12:	2b00      	cmp	r3, #0
 801ee14:	d11c      	bne.n	801ee50 <Hash_DRBG_Reseed+0x94>
        XMEMCPY(drbg->V, newV, sizeof(drbg->V));
 801ee16:	68fb      	ldr	r3, [r7, #12]
 801ee18:	3304      	adds	r3, #4
 801ee1a:	2237      	movs	r2, #55	@ 0x37
 801ee1c:	69b9      	ldr	r1, [r7, #24]
 801ee1e:	4618      	mov	r0, r3
 801ee20:	f009 fbbc 	bl	802859c <memcpy>
        ForceZero(newV, DRBG_SEED_LEN);
 801ee24:	2137      	movs	r1, #55	@ 0x37
 801ee26:	69b8      	ldr	r0, [r7, #24]
 801ee28:	f7ff fe88 	bl	801eb3c <ForceZero>

        ret = Hash_df(drbg, drbg->C, sizeof(drbg->C), drbgInitC, drbg->V,
 801ee2c:	68fb      	ldr	r3, [r7, #12]
 801ee2e:	f103 013b 	add.w	r1, r3, #59	@ 0x3b
 801ee32:	68fb      	ldr	r3, [r7, #12]
 801ee34:	3304      	adds	r3, #4
 801ee36:	2200      	movs	r2, #0
 801ee38:	9203      	str	r2, [sp, #12]
 801ee3a:	2200      	movs	r2, #0
 801ee3c:	9202      	str	r2, [sp, #8]
 801ee3e:	2237      	movs	r2, #55	@ 0x37
 801ee40:	9201      	str	r2, [sp, #4]
 801ee42:	9300      	str	r3, [sp, #0]
 801ee44:	2300      	movs	r3, #0
 801ee46:	2237      	movs	r2, #55	@ 0x37
 801ee48:	68f8      	ldr	r0, [r7, #12]
 801ee4a:	f7ff fec7 	bl	801ebdc <Hash_df>
 801ee4e:	61f8      	str	r0, [r7, #28]
                                    sizeof(drbg->V), NULL, 0);
    }
    if (ret == DRBG_SUCCESS) {
 801ee50:	69fb      	ldr	r3, [r7, #28]
 801ee52:	2b00      	cmp	r3, #0
 801ee54:	d102      	bne.n	801ee5c <Hash_DRBG_Reseed+0xa0>
        drbg->reseedCtr = 1;
 801ee56:	68fb      	ldr	r3, [r7, #12]
 801ee58:	2201      	movs	r2, #1
 801ee5a:	601a      	str	r2, [r3, #0]
    }

#ifdef WOLFSSL_SMALL_STACK
    XFREE(newV, drbg->heap, DYNAMIC_TYPE_TMP_BUFFER);
 801ee5c:	69bb      	ldr	r3, [r7, #24]
 801ee5e:	617b      	str	r3, [r7, #20]
 801ee60:	697b      	ldr	r3, [r7, #20]
 801ee62:	2b00      	cmp	r3, #0
 801ee64:	d002      	beq.n	801ee6c <Hash_DRBG_Reseed+0xb0>
 801ee66:	6978      	ldr	r0, [r7, #20]
 801ee68:	f7ff fe2a 	bl	801eac0 <wolfSSL_Free>
#endif
    return ret;
 801ee6c:	69fb      	ldr	r3, [r7, #28]
}
 801ee6e:	4618      	mov	r0, r3
 801ee70:	3720      	adds	r7, #32
 801ee72:	46bd      	mov	sp, r7
 801ee74:	bd80      	pop	{r7, pc}

0801ee76 <array_add_one>:

    return Hash_DRBG_Reseed((DRBG_internal *)rng->drbg, seed, seedSz);
}

static WC_INLINE void array_add_one(byte* data, word32 dataSz)
{
 801ee76:	b480      	push	{r7}
 801ee78:	b085      	sub	sp, #20
 801ee7a:	af00      	add	r7, sp, #0
 801ee7c:	6078      	str	r0, [r7, #4]
 801ee7e:	6039      	str	r1, [r7, #0]
    int i;
    for (i = (int)dataSz - 1; i >= 0; i--) {
 801ee80:	683b      	ldr	r3, [r7, #0]
 801ee82:	3b01      	subs	r3, #1
 801ee84:	60fb      	str	r3, [r7, #12]
 801ee86:	e00f      	b.n	801eea8 <array_add_one+0x32>
        data[i]++;
 801ee88:	68fb      	ldr	r3, [r7, #12]
 801ee8a:	687a      	ldr	r2, [r7, #4]
 801ee8c:	4413      	add	r3, r2
 801ee8e:	781a      	ldrb	r2, [r3, #0]
 801ee90:	3201      	adds	r2, #1
 801ee92:	b2d2      	uxtb	r2, r2
 801ee94:	701a      	strb	r2, [r3, #0]
        if (data[i] != 0) break;
 801ee96:	68fb      	ldr	r3, [r7, #12]
 801ee98:	687a      	ldr	r2, [r7, #4]
 801ee9a:	4413      	add	r3, r2
 801ee9c:	781b      	ldrb	r3, [r3, #0]
 801ee9e:	2b00      	cmp	r3, #0
 801eea0:	d106      	bne.n	801eeb0 <array_add_one+0x3a>
    for (i = (int)dataSz - 1; i >= 0; i--) {
 801eea2:	68fb      	ldr	r3, [r7, #12]
 801eea4:	3b01      	subs	r3, #1
 801eea6:	60fb      	str	r3, [r7, #12]
 801eea8:	68fb      	ldr	r3, [r7, #12]
 801eeaa:	2b00      	cmp	r3, #0
 801eeac:	daec      	bge.n	801ee88 <array_add_one+0x12>
    }
}
 801eeae:	e000      	b.n	801eeb2 <array_add_one+0x3c>
        if (data[i] != 0) break;
 801eeb0:	bf00      	nop
}
 801eeb2:	bf00      	nop
 801eeb4:	3714      	adds	r7, #20
 801eeb6:	46bd      	mov	sp, r7
 801eeb8:	f85d 7b04 	ldr.w	r7, [sp], #4
 801eebc:	4770      	bx	lr

0801eebe <Hash_gen>:

/* Returns: DRBG_SUCCESS or DRBG_FAILURE */
static int Hash_gen(DRBG_internal* drbg, byte* out, word32 outSz, const byte* V)
{
 801eebe:	b580      	push	{r7, lr}
 801eec0:	b0aa      	sub	sp, #168	@ 0xa8
 801eec2:	af00      	add	r7, sp, #0
 801eec4:	60f8      	str	r0, [r7, #12]
 801eec6:	60b9      	str	r1, [r7, #8]
 801eec8:	607a      	str	r2, [r7, #4]
 801eeca:	603b      	str	r3, [r7, #0]
    int ret = DRBG_FAILURE;
 801eecc:	2301      	movs	r3, #1
 801eece:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
    wc_Sha256* sha = &drbg->sha256;
#else
    wc_Sha256 sha[1];
#endif

    if (drbg == NULL) {
 801eed2:	68fb      	ldr	r3, [r7, #12]
 801eed4:	2b00      	cmp	r3, #0
 801eed6:	d101      	bne.n	801eedc <Hash_gen+0x1e>
        return DRBG_FAILURE;
 801eed8:	2301      	movs	r3, #1
 801eeda:	e0c6      	b.n	801f06a <Hash_gen+0x1ac>
    }

#ifdef WOLFSSL_SMALL_STACK
    data = (byte*)XMALLOC(DRBG_SEED_LEN, drbg->heap, DYNAMIC_TYPE_TMP_BUFFER);
 801eedc:	2037      	movs	r0, #55	@ 0x37
 801eede:	f7ff fdd3 	bl	801ea88 <wolfSSL_Malloc>
 801eee2:	f8c7 009c 	str.w	r0, [r7, #156]	@ 0x9c
    digest = (byte*)XMALLOC(WC_SHA256_DIGEST_SIZE, drbg->heap,
 801eee6:	2020      	movs	r0, #32
 801eee8:	f7ff fdce 	bl	801ea88 <wolfSSL_Malloc>
 801eeec:	f8c7 0098 	str.w	r0, [r7, #152]	@ 0x98
        DYNAMIC_TYPE_DIGEST);
    if (data == NULL || digest == NULL) {
 801eef0:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801eef4:	2b00      	cmp	r3, #0
 801eef6:	d003      	beq.n	801ef00 <Hash_gen+0x42>
 801eef8:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 801eefc:	2b00      	cmp	r3, #0
 801eefe:	d119      	bne.n	801ef34 <Hash_gen+0x76>
        XFREE(digest, drbg->heap, DYNAMIC_TYPE_DIGEST);
 801ef00:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 801ef04:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
 801ef08:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801ef0c:	2b00      	cmp	r3, #0
 801ef0e:	d003      	beq.n	801ef18 <Hash_gen+0x5a>
 801ef10:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801ef14:	f7ff fdd4 	bl	801eac0 <wolfSSL_Free>
        XFREE(data, drbg->heap, DYNAMIC_TYPE_TMP_BUFFER);
 801ef18:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801ef1c:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
 801ef20:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801ef24:	2b00      	cmp	r3, #0
 801ef26:	d003      	beq.n	801ef30 <Hash_gen+0x72>
 801ef28:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801ef2c:	f7ff fdc8 	bl	801eac0 <wolfSSL_Free>
        return DRBG_FAILURE;
 801ef30:	2301      	movs	r3, #1
 801ef32:	e09a      	b.n	801f06a <Hash_gen+0x1ac>
#endif

    /* Special case: outSz is 0 and out is NULL. wc_Generate a block to save for
     * the continuous test. */

    if (outSz == 0) {
 801ef34:	687b      	ldr	r3, [r7, #4]
 801ef36:	2b00      	cmp	r3, #0
 801ef38:	d101      	bne.n	801ef3e <Hash_gen+0x80>
        outSz = 1;
 801ef3a:	2301      	movs	r3, #1
 801ef3c:	607b      	str	r3, [r7, #4]
    }

    len = (outSz / OUTPUT_BLOCK_LEN) + ((outSz % OUTPUT_BLOCK_LEN) ? 1 : 0);
 801ef3e:	687b      	ldr	r3, [r7, #4]
 801ef40:	095b      	lsrs	r3, r3, #5
 801ef42:	687a      	ldr	r2, [r7, #4]
 801ef44:	f002 021f 	and.w	r2, r2, #31
 801ef48:	2a00      	cmp	r2, #0
 801ef4a:	d001      	beq.n	801ef50 <Hash_gen+0x92>
 801ef4c:	2201      	movs	r2, #1
 801ef4e:	e000      	b.n	801ef52 <Hash_gen+0x94>
 801ef50:	2200      	movs	r2, #0
 801ef52:	4413      	add	r3, r2
 801ef54:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94

    XMEMCPY(data, V, DRBG_SEED_LEN);
 801ef58:	2237      	movs	r2, #55	@ 0x37
 801ef5a:	6839      	ldr	r1, [r7, #0]
 801ef5c:	f8d7 009c 	ldr.w	r0, [r7, #156]	@ 0x9c
 801ef60:	f009 fb1c 	bl	802859c <memcpy>
    for (i = 0; i < len; i++) {
 801ef64:	2300      	movs	r3, #0
 801ef66:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
 801ef6a:	e052      	b.n	801f012 <Hash_gen+0x154>
#ifndef WOLFSSL_SMALL_STACK_CACHE
    #if defined(WOLFSSL_ASYNC_CRYPT) || defined(WOLF_CRYPTO_CB)
        ret = wc_InitSha256_ex(sha, drbg->heap, drbg->devId);
    #else
        ret = wc_InitSha256(sha);
 801ef6c:	f107 0314 	add.w	r3, r7, #20
 801ef70:	4618      	mov	r0, r3
 801ef72:	f003 f839 	bl	8021fe8 <wc_InitSha256>
 801ef76:	f8c7 00a4 	str.w	r0, [r7, #164]	@ 0xa4
    #endif
        if (ret == 0)
 801ef7a:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801ef7e:	2b00      	cmp	r3, #0
 801ef80:	d109      	bne.n	801ef96 <Hash_gen+0xd8>
#endif
            ret = wc_Sha256Update(sha, data, DRBG_SEED_LEN);
 801ef82:	f107 0314 	add.w	r3, r7, #20
 801ef86:	2237      	movs	r2, #55	@ 0x37
 801ef88:	f8d7 109c 	ldr.w	r1, [r7, #156]	@ 0x9c
 801ef8c:	4618      	mov	r0, r3
 801ef8e:	f002 ff62 	bl	8021e56 <wc_Sha256Update>
 801ef92:	f8c7 00a4 	str.w	r0, [r7, #164]	@ 0xa4
        if (ret == 0)
 801ef96:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801ef9a:	2b00      	cmp	r3, #0
 801ef9c:	d108      	bne.n	801efb0 <Hash_gen+0xf2>
            ret = wc_Sha256Final(sha, digest);
 801ef9e:	f107 0314 	add.w	r3, r7, #20
 801efa2:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801efa6:	4618      	mov	r0, r3
 801efa8:	f002 fff3 	bl	8021f92 <wc_Sha256Final>
 801efac:	f8c7 00a4 	str.w	r0, [r7, #164]	@ 0xa4
#ifndef WOLFSSL_SMALL_STACK_CACHE
        wc_Sha256Free(sha);
 801efb0:	f107 0314 	add.w	r3, r7, #20
 801efb4:	4618      	mov	r0, r3
 801efb6:	f003 f828 	bl	802200a <wc_Sha256Free>
#endif

        if (ret == 0) {
 801efba:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801efbe:	2b00      	cmp	r3, #0
 801efc0:	d12e      	bne.n	801f020 <Hash_gen+0x162>
            if (out != NULL && outSz != 0) {
 801efc2:	68bb      	ldr	r3, [r7, #8]
 801efc4:	2b00      	cmp	r3, #0
 801efc6:	d01f      	beq.n	801f008 <Hash_gen+0x14a>
 801efc8:	687b      	ldr	r3, [r7, #4]
 801efca:	2b00      	cmp	r3, #0
 801efcc:	d01c      	beq.n	801f008 <Hash_gen+0x14a>
                if (outSz >= OUTPUT_BLOCK_LEN) {
 801efce:	687b      	ldr	r3, [r7, #4]
 801efd0:	2b1f      	cmp	r3, #31
 801efd2:	d911      	bls.n	801eff8 <Hash_gen+0x13a>
                    XMEMCPY(out, digest, OUTPUT_BLOCK_LEN);
 801efd4:	2220      	movs	r2, #32
 801efd6:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801efda:	68b8      	ldr	r0, [r7, #8]
 801efdc:	f009 fade 	bl	802859c <memcpy>
                    outSz -= OUTPUT_BLOCK_LEN;
 801efe0:	687b      	ldr	r3, [r7, #4]
 801efe2:	3b20      	subs	r3, #32
 801efe4:	607b      	str	r3, [r7, #4]
                    out += OUTPUT_BLOCK_LEN;
 801efe6:	68bb      	ldr	r3, [r7, #8]
 801efe8:	3320      	adds	r3, #32
 801efea:	60bb      	str	r3, [r7, #8]
                    array_add_one(data, DRBG_SEED_LEN);
 801efec:	2137      	movs	r1, #55	@ 0x37
 801efee:	f8d7 009c 	ldr.w	r0, [r7, #156]	@ 0x9c
 801eff2:	f7ff ff40 	bl	801ee76 <array_add_one>
 801eff6:	e007      	b.n	801f008 <Hash_gen+0x14a>
                }
                else {
                    XMEMCPY(out, digest, outSz);
 801eff8:	687a      	ldr	r2, [r7, #4]
 801effa:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801effe:	68b8      	ldr	r0, [r7, #8]
 801f000:	f009 facc 	bl	802859c <memcpy>
                    outSz = 0;
 801f004:	2300      	movs	r3, #0
 801f006:	607b      	str	r3, [r7, #4]
    for (i = 0; i < len; i++) {
 801f008:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 801f00c:	3301      	adds	r3, #1
 801f00e:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
 801f012:	f8d7 20a0 	ldr.w	r2, [r7, #160]	@ 0xa0
 801f016:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 801f01a:	429a      	cmp	r2, r3
 801f01c:	d3a6      	bcc.n	801ef6c <Hash_gen+0xae>
 801f01e:	e000      	b.n	801f022 <Hash_gen+0x164>
                }
            }
        }
        else {
            /* wc_Sha256Update or wc_Sha256Final returned error */
            break;
 801f020:	bf00      	nop
        }
    }
    ForceZero(data, DRBG_SEED_LEN);
 801f022:	2137      	movs	r1, #55	@ 0x37
 801f024:	f8d7 009c 	ldr.w	r0, [r7, #156]	@ 0x9c
 801f028:	f7ff fd88 	bl	801eb3c <ForceZero>

#ifdef WOLFSSL_SMALL_STACK
    XFREE(digest, drbg->heap, DYNAMIC_TYPE_DIGEST);
 801f02c:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 801f030:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
 801f034:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 801f038:	2b00      	cmp	r3, #0
 801f03a:	d003      	beq.n	801f044 <Hash_gen+0x186>
 801f03c:	f8d7 0090 	ldr.w	r0, [r7, #144]	@ 0x90
 801f040:	f7ff fd3e 	bl	801eac0 <wolfSSL_Free>
    XFREE(data, drbg->heap, DYNAMIC_TYPE_TMP_BUFFER);
 801f044:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801f048:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
 801f04c:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801f050:	2b00      	cmp	r3, #0
 801f052:	d003      	beq.n	801f05c <Hash_gen+0x19e>
 801f054:	f8d7 008c 	ldr.w	r0, [r7, #140]	@ 0x8c
 801f058:	f7ff fd32 	bl	801eac0 <wolfSSL_Free>
#endif

    return (ret == 0) ? DRBG_SUCCESS : DRBG_FAILURE;
 801f05c:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801f060:	2b00      	cmp	r3, #0
 801f062:	bf14      	ite	ne
 801f064:	2301      	movne	r3, #1
 801f066:	2300      	moveq	r3, #0
 801f068:	b2db      	uxtb	r3, r3
}
 801f06a:	4618      	mov	r0, r3
 801f06c:	37a8      	adds	r7, #168	@ 0xa8
 801f06e:	46bd      	mov	sp, r7
 801f070:	bd80      	pop	{r7, pc}

0801f072 <array_add>:

static WC_INLINE void array_add(byte* d, word32 dLen, const byte* s, word32 sLen)
{
 801f072:	b480      	push	{r7}
 801f074:	b089      	sub	sp, #36	@ 0x24
 801f076:	af00      	add	r7, sp, #0
 801f078:	60f8      	str	r0, [r7, #12]
 801f07a:	60b9      	str	r1, [r7, #8]
 801f07c:	607a      	str	r2, [r7, #4]
 801f07e:	603b      	str	r3, [r7, #0]
    if (dLen > 0 && sLen > 0 && dLen >= sLen) {
 801f080:	68bb      	ldr	r3, [r7, #8]
 801f082:	2b00      	cmp	r3, #0
 801f084:	d047      	beq.n	801f116 <array_add+0xa4>
 801f086:	683b      	ldr	r3, [r7, #0]
 801f088:	2b00      	cmp	r3, #0
 801f08a:	d044      	beq.n	801f116 <array_add+0xa4>
 801f08c:	68ba      	ldr	r2, [r7, #8]
 801f08e:	683b      	ldr	r3, [r7, #0]
 801f090:	429a      	cmp	r2, r3
 801f092:	d340      	bcc.n	801f116 <array_add+0xa4>
        int sIdx, dIdx;
        word16 carry = 0;
 801f094:	2300      	movs	r3, #0
 801f096:	82fb      	strh	r3, [r7, #22]

        dIdx = (int)dLen - 1;
 801f098:	68bb      	ldr	r3, [r7, #8]
 801f09a:	3b01      	subs	r3, #1
 801f09c:	61bb      	str	r3, [r7, #24]
        for (sIdx = (int)sLen - 1; sIdx >= 0; sIdx--) {
 801f09e:	683b      	ldr	r3, [r7, #0]
 801f0a0:	3b01      	subs	r3, #1
 801f0a2:	61fb      	str	r3, [r7, #28]
 801f0a4:	e01c      	b.n	801f0e0 <array_add+0x6e>
            carry = (word16)(carry + d[dIdx] + s[sIdx]);
 801f0a6:	69bb      	ldr	r3, [r7, #24]
 801f0a8:	68fa      	ldr	r2, [r7, #12]
 801f0aa:	4413      	add	r3, r2
 801f0ac:	781b      	ldrb	r3, [r3, #0]
 801f0ae:	461a      	mov	r2, r3
 801f0b0:	8afb      	ldrh	r3, [r7, #22]
 801f0b2:	4413      	add	r3, r2
 801f0b4:	b29b      	uxth	r3, r3
 801f0b6:	69fa      	ldr	r2, [r7, #28]
 801f0b8:	6879      	ldr	r1, [r7, #4]
 801f0ba:	440a      	add	r2, r1
 801f0bc:	7812      	ldrb	r2, [r2, #0]
 801f0be:	4413      	add	r3, r2
 801f0c0:	82fb      	strh	r3, [r7, #22]
            d[dIdx] = (byte)carry;
 801f0c2:	69bb      	ldr	r3, [r7, #24]
 801f0c4:	68fa      	ldr	r2, [r7, #12]
 801f0c6:	4413      	add	r3, r2
 801f0c8:	8afa      	ldrh	r2, [r7, #22]
 801f0ca:	b2d2      	uxtb	r2, r2
 801f0cc:	701a      	strb	r2, [r3, #0]
            carry >>= 8;
 801f0ce:	8afb      	ldrh	r3, [r7, #22]
 801f0d0:	0a1b      	lsrs	r3, r3, #8
 801f0d2:	82fb      	strh	r3, [r7, #22]
            dIdx--;
 801f0d4:	69bb      	ldr	r3, [r7, #24]
 801f0d6:	3b01      	subs	r3, #1
 801f0d8:	61bb      	str	r3, [r7, #24]
        for (sIdx = (int)sLen - 1; sIdx >= 0; sIdx--) {
 801f0da:	69fb      	ldr	r3, [r7, #28]
 801f0dc:	3b01      	subs	r3, #1
 801f0de:	61fb      	str	r3, [r7, #28]
 801f0e0:	69fb      	ldr	r3, [r7, #28]
 801f0e2:	2b00      	cmp	r3, #0
 801f0e4:	dadf      	bge.n	801f0a6 <array_add+0x34>
        }

        for (; dIdx >= 0; dIdx--) {
 801f0e6:	e013      	b.n	801f110 <array_add+0x9e>
            carry = (word16)(carry + d[dIdx]);
 801f0e8:	69bb      	ldr	r3, [r7, #24]
 801f0ea:	68fa      	ldr	r2, [r7, #12]
 801f0ec:	4413      	add	r3, r2
 801f0ee:	781b      	ldrb	r3, [r3, #0]
 801f0f0:	461a      	mov	r2, r3
 801f0f2:	8afb      	ldrh	r3, [r7, #22]
 801f0f4:	4413      	add	r3, r2
 801f0f6:	82fb      	strh	r3, [r7, #22]
            d[dIdx] = (byte)carry;
 801f0f8:	69bb      	ldr	r3, [r7, #24]
 801f0fa:	68fa      	ldr	r2, [r7, #12]
 801f0fc:	4413      	add	r3, r2
 801f0fe:	8afa      	ldrh	r2, [r7, #22]
 801f100:	b2d2      	uxtb	r2, r2
 801f102:	701a      	strb	r2, [r3, #0]
            carry >>= 8;
 801f104:	8afb      	ldrh	r3, [r7, #22]
 801f106:	0a1b      	lsrs	r3, r3, #8
 801f108:	82fb      	strh	r3, [r7, #22]
        for (; dIdx >= 0; dIdx--) {
 801f10a:	69bb      	ldr	r3, [r7, #24]
 801f10c:	3b01      	subs	r3, #1
 801f10e:	61bb      	str	r3, [r7, #24]
 801f110:	69bb      	ldr	r3, [r7, #24]
 801f112:	2b00      	cmp	r3, #0
 801f114:	dae8      	bge.n	801f0e8 <array_add+0x76>
        }
    }
}
 801f116:	bf00      	nop
 801f118:	3724      	adds	r7, #36	@ 0x24
 801f11a:	46bd      	mov	sp, r7
 801f11c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f120:	4770      	bx	lr
	...

0801f124 <Hash_DRBG_Generate>:

/* Returns: DRBG_SUCCESS, DRBG_NEED_RESEED, or DRBG_FAILURE */
static int Hash_DRBG_Generate(DRBG_internal* drbg, byte* out, word32 outSz)
{
 801f124:	b580      	push	{r7, lr}
 801f126:	b0a6      	sub	sp, #152	@ 0x98
 801f128:	af00      	add	r7, sp, #0
 801f12a:	60f8      	str	r0, [r7, #12]
 801f12c:	60b9      	str	r1, [r7, #8]
 801f12e:	607a      	str	r2, [r7, #4]
    wc_Sha256 sha[1];
#endif
    byte type;
    word32 reseedCtr;

    if (drbg == NULL) {
 801f130:	68fb      	ldr	r3, [r7, #12]
 801f132:	2b00      	cmp	r3, #0
 801f134:	d101      	bne.n	801f13a <Hash_DRBG_Generate+0x16>
        return DRBG_FAILURE;
 801f136:	2301      	movs	r3, #1
 801f138:	e09b      	b.n	801f272 <Hash_DRBG_Generate+0x14e>
    }

    if (drbg->reseedCtr == RESEED_INTERVAL) {
 801f13a:	68fb      	ldr	r3, [r7, #12]
 801f13c:	681b      	ldr	r3, [r3, #0]
 801f13e:	4a4f      	ldr	r2, [pc, #316]	@ (801f27c <Hash_DRBG_Generate+0x158>)
 801f140:	4293      	cmp	r3, r2
 801f142:	d101      	bne.n	801f148 <Hash_DRBG_Generate+0x24>
#if FIPS_VERSION3_GE(6,0,0)
        printf("Reseed triggered\n");
#endif
        return DRBG_NEED_RESEED;
 801f144:	2302      	movs	r3, #2
 801f146:	e094      	b.n	801f272 <Hash_DRBG_Generate+0x14e>
    }
    else {
    #ifndef WOLFSSL_SMALL_STACK
        byte digest[WC_SHA256_DIGEST_SIZE];
    #else
        byte* digest = (byte*)XMALLOC(WC_SHA256_DIGEST_SIZE, drbg->heap,
 801f148:	2020      	movs	r0, #32
 801f14a:	f7ff fc9d 	bl	801ea88 <wolfSSL_Malloc>
 801f14e:	f8c7 0090 	str.w	r0, [r7, #144]	@ 0x90
            DYNAMIC_TYPE_DIGEST);
        if (digest == NULL)
 801f152:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 801f156:	2b00      	cmp	r3, #0
 801f158:	d101      	bne.n	801f15e <Hash_DRBG_Generate+0x3a>
            return DRBG_FAILURE;
 801f15a:	2301      	movs	r3, #1
 801f15c:	e089      	b.n	801f272 <Hash_DRBG_Generate+0x14e>
    #endif

        type = drbgGenerateH;
 801f15e:	2303      	movs	r3, #3
 801f160:	76fb      	strb	r3, [r7, #27]
        reseedCtr = drbg->reseedCtr;
 801f162:	68fb      	ldr	r3, [r7, #12]
 801f164:	681b      	ldr	r3, [r3, #0]
 801f166:	617b      	str	r3, [r7, #20]

        ret = Hash_gen(drbg, out, outSz, drbg->V);
 801f168:	68fb      	ldr	r3, [r7, #12]
 801f16a:	3304      	adds	r3, #4
 801f16c:	687a      	ldr	r2, [r7, #4]
 801f16e:	68b9      	ldr	r1, [r7, #8]
 801f170:	68f8      	ldr	r0, [r7, #12]
 801f172:	f7ff fea4 	bl	801eebe <Hash_gen>
 801f176:	f8c7 0094 	str.w	r0, [r7, #148]	@ 0x94
        if (ret == DRBG_SUCCESS) {
 801f17a:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 801f17e:	2b00      	cmp	r3, #0
 801f180:	d15f      	bne.n	801f242 <Hash_DRBG_Generate+0x11e>
#ifndef WOLFSSL_SMALL_STACK_CACHE
        #if defined(WOLFSSL_ASYNC_CRYPT) || defined(WOLF_CRYPTO_CB)
            ret = wc_InitSha256_ex(sha, drbg->heap, drbg->devId);
        #else
            ret = wc_InitSha256(sha);
 801f182:	f107 031c 	add.w	r3, r7, #28
 801f186:	4618      	mov	r0, r3
 801f188:	f002 ff2e 	bl	8021fe8 <wc_InitSha256>
 801f18c:	f8c7 0094 	str.w	r0, [r7, #148]	@ 0x94
        #endif
            if (ret == 0)
 801f190:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 801f194:	2b00      	cmp	r3, #0
 801f196:	d109      	bne.n	801f1ac <Hash_DRBG_Generate+0x88>
#endif
                ret = wc_Sha256Update(sha, &type, sizeof(type));
 801f198:	f107 011b 	add.w	r1, r7, #27
 801f19c:	f107 031c 	add.w	r3, r7, #28
 801f1a0:	2201      	movs	r2, #1
 801f1a2:	4618      	mov	r0, r3
 801f1a4:	f002 fe57 	bl	8021e56 <wc_Sha256Update>
 801f1a8:	f8c7 0094 	str.w	r0, [r7, #148]	@ 0x94
            if (ret == 0)
 801f1ac:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 801f1b0:	2b00      	cmp	r3, #0
 801f1b2:	d109      	bne.n	801f1c8 <Hash_DRBG_Generate+0xa4>
                ret = wc_Sha256Update(sha, drbg->V, sizeof(drbg->V));
 801f1b4:	68fb      	ldr	r3, [r7, #12]
 801f1b6:	1d19      	adds	r1, r3, #4
 801f1b8:	f107 031c 	add.w	r3, r7, #28
 801f1bc:	2237      	movs	r2, #55	@ 0x37
 801f1be:	4618      	mov	r0, r3
 801f1c0:	f002 fe49 	bl	8021e56 <wc_Sha256Update>
 801f1c4:	f8c7 0094 	str.w	r0, [r7, #148]	@ 0x94
            if (ret == 0)
 801f1c8:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 801f1cc:	2b00      	cmp	r3, #0
 801f1ce:	d108      	bne.n	801f1e2 <Hash_DRBG_Generate+0xbe>
                ret = wc_Sha256Final(sha, digest);
 801f1d0:	f107 031c 	add.w	r3, r7, #28
 801f1d4:	f8d7 1090 	ldr.w	r1, [r7, #144]	@ 0x90
 801f1d8:	4618      	mov	r0, r3
 801f1da:	f002 feda 	bl	8021f92 <wc_Sha256Final>
 801f1de:	f8c7 0094 	str.w	r0, [r7, #148]	@ 0x94

#ifndef WOLFSSL_SMALL_STACK_CACHE
            wc_Sha256Free(sha);
 801f1e2:	f107 031c 	add.w	r3, r7, #28
 801f1e6:	4618      	mov	r0, r3
 801f1e8:	f002 ff0f 	bl	802200a <wc_Sha256Free>
#endif

            if (ret == 0) {
 801f1ec:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 801f1f0:	2b00      	cmp	r3, #0
 801f1f2:	d121      	bne.n	801f238 <Hash_DRBG_Generate+0x114>
                array_add(drbg->V, sizeof(drbg->V), digest, WC_SHA256_DIGEST_SIZE);
 801f1f4:	68fb      	ldr	r3, [r7, #12]
 801f1f6:	1d18      	adds	r0, r3, #4
 801f1f8:	2320      	movs	r3, #32
 801f1fa:	f8d7 2090 	ldr.w	r2, [r7, #144]	@ 0x90
 801f1fe:	2137      	movs	r1, #55	@ 0x37
 801f200:	f7ff ff37 	bl	801f072 <array_add>
                array_add(drbg->V, sizeof(drbg->V), drbg->C, sizeof(drbg->C));
 801f204:	68fb      	ldr	r3, [r7, #12]
 801f206:	1d18      	adds	r0, r3, #4
 801f208:	68fb      	ldr	r3, [r7, #12]
 801f20a:	f103 023b 	add.w	r2, r3, #59	@ 0x3b
 801f20e:	2337      	movs	r3, #55	@ 0x37
 801f210:	2137      	movs	r1, #55	@ 0x37
 801f212:	f7ff ff2e 	bl	801f072 <array_add>
            #ifdef LITTLE_ENDIAN_ORDER
                reseedCtr = ByteReverseWord32(reseedCtr);
 801f216:	697b      	ldr	r3, [r7, #20]
 801f218:	4618      	mov	r0, r3
 801f21a:	f7ff fc78 	bl	801eb0e <ByteReverseWord32>
 801f21e:	4603      	mov	r3, r0
 801f220:	617b      	str	r3, [r7, #20]
            #endif
                array_add(drbg->V, sizeof(drbg->V),
 801f222:	68fb      	ldr	r3, [r7, #12]
 801f224:	1d18      	adds	r0, r3, #4
 801f226:	f107 0214 	add.w	r2, r7, #20
 801f22a:	2304      	movs	r3, #4
 801f22c:	2137      	movs	r1, #55	@ 0x37
 801f22e:	f7ff ff20 	bl	801f072 <array_add>
                                          (byte*)&reseedCtr, sizeof(reseedCtr));
                ret = DRBG_SUCCESS;
 801f232:	2300      	movs	r3, #0
 801f234:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
            }
            drbg->reseedCtr++;
 801f238:	68fb      	ldr	r3, [r7, #12]
 801f23a:	681b      	ldr	r3, [r3, #0]
 801f23c:	1c5a      	adds	r2, r3, #1
 801f23e:	68fb      	ldr	r3, [r7, #12]
 801f240:	601a      	str	r2, [r3, #0]
        }
        ForceZero(digest, WC_SHA256_DIGEST_SIZE);
 801f242:	2120      	movs	r1, #32
 801f244:	f8d7 0090 	ldr.w	r0, [r7, #144]	@ 0x90
 801f248:	f7ff fc78 	bl	801eb3c <ForceZero>
    #ifdef WOLFSSL_SMALL_STACK
        XFREE(digest, drbg->heap, DYNAMIC_TYPE_DIGEST);
 801f24c:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 801f250:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
 801f254:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801f258:	2b00      	cmp	r3, #0
 801f25a:	d003      	beq.n	801f264 <Hash_DRBG_Generate+0x140>
 801f25c:	f8d7 008c 	ldr.w	r0, [r7, #140]	@ 0x8c
 801f260:	f7ff fc2e 	bl	801eac0 <wolfSSL_Free>
    #endif
    }

    return (ret == 0) ? DRBG_SUCCESS : DRBG_FAILURE;
 801f264:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 801f268:	2b00      	cmp	r3, #0
 801f26a:	bf14      	ite	ne
 801f26c:	2301      	movne	r3, #1
 801f26e:	2300      	moveq	r3, #0
 801f270:	b2db      	uxtb	r3, r3
}
 801f272:	4618      	mov	r0, r3
 801f274:	3798      	adds	r7, #152	@ 0x98
 801f276:	46bd      	mov	sp, r7
 801f278:	bd80      	pop	{r7, pc}
 801f27a:	bf00      	nop
 801f27c:	000f4240 	.word	0x000f4240

0801f280 <Hash_DRBG_Instantiate>:

/* Returns: DRBG_SUCCESS or DRBG_FAILURE */
static int Hash_DRBG_Instantiate(DRBG_internal* drbg, const byte* seed, word32 seedSz,
                                             const byte* nonce, word32 nonceSz,
                                             void* heap, int devId)
{
 801f280:	b580      	push	{r7, lr}
 801f282:	b08a      	sub	sp, #40	@ 0x28
 801f284:	af04      	add	r7, sp, #16
 801f286:	60f8      	str	r0, [r7, #12]
 801f288:	60b9      	str	r1, [r7, #8]
 801f28a:	607a      	str	r2, [r7, #4]
 801f28c:	603b      	str	r3, [r7, #0]
    int ret = DRBG_FAILURE;
 801f28e:	2301      	movs	r3, #1
 801f290:	617b      	str	r3, [r7, #20]

    XMEMSET(drbg, 0, sizeof(DRBG_internal));
 801f292:	2278      	movs	r2, #120	@ 0x78
 801f294:	2100      	movs	r1, #0
 801f296:	68f8      	ldr	r0, [r7, #12]
 801f298:	f009 f916 	bl	80284c8 <memset>
    drbg->heap = heap;
 801f29c:	68fb      	ldr	r3, [r7, #12]
 801f29e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801f2a0:	675a      	str	r2, [r3, #116]	@ 0x74
    #endif
    if (ret != 0)
        return ret;
#endif

    if (Hash_df(drbg, drbg->V, sizeof(drbg->V), drbgInitV, seed, seedSz,
 801f2a2:	68fb      	ldr	r3, [r7, #12]
 801f2a4:	1d19      	adds	r1, r3, #4
 801f2a6:	6a3b      	ldr	r3, [r7, #32]
 801f2a8:	9303      	str	r3, [sp, #12]
 801f2aa:	683b      	ldr	r3, [r7, #0]
 801f2ac:	9302      	str	r3, [sp, #8]
 801f2ae:	687b      	ldr	r3, [r7, #4]
 801f2b0:	9301      	str	r3, [sp, #4]
 801f2b2:	68bb      	ldr	r3, [r7, #8]
 801f2b4:	9300      	str	r3, [sp, #0]
 801f2b6:	2304      	movs	r3, #4
 801f2b8:	2237      	movs	r2, #55	@ 0x37
 801f2ba:	68f8      	ldr	r0, [r7, #12]
 801f2bc:	f7ff fc8e 	bl	801ebdc <Hash_df>
 801f2c0:	4603      	mov	r3, r0
 801f2c2:	2b00      	cmp	r3, #0
 801f2c4:	d118      	bne.n	801f2f8 <Hash_DRBG_Instantiate+0x78>
                                              nonce, nonceSz) == DRBG_SUCCESS &&
        Hash_df(drbg, drbg->C, sizeof(drbg->C), drbgInitC, drbg->V,
 801f2c6:	68fb      	ldr	r3, [r7, #12]
 801f2c8:	f103 013b 	add.w	r1, r3, #59	@ 0x3b
 801f2cc:	68fb      	ldr	r3, [r7, #12]
 801f2ce:	3304      	adds	r3, #4
 801f2d0:	2200      	movs	r2, #0
 801f2d2:	9203      	str	r2, [sp, #12]
 801f2d4:	2200      	movs	r2, #0
 801f2d6:	9202      	str	r2, [sp, #8]
 801f2d8:	2237      	movs	r2, #55	@ 0x37
 801f2da:	9201      	str	r2, [sp, #4]
 801f2dc:	9300      	str	r3, [sp, #0]
 801f2de:	2300      	movs	r3, #0
 801f2e0:	2237      	movs	r2, #55	@ 0x37
 801f2e2:	68f8      	ldr	r0, [r7, #12]
 801f2e4:	f7ff fc7a 	bl	801ebdc <Hash_df>
 801f2e8:	4603      	mov	r3, r0
                                              nonce, nonceSz) == DRBG_SUCCESS &&
 801f2ea:	2b00      	cmp	r3, #0
 801f2ec:	d104      	bne.n	801f2f8 <Hash_DRBG_Instantiate+0x78>
                                    sizeof(drbg->V), NULL, 0) == DRBG_SUCCESS) {

        drbg->reseedCtr = 1;
 801f2ee:	68fb      	ldr	r3, [r7, #12]
 801f2f0:	2201      	movs	r2, #1
 801f2f2:	601a      	str	r2, [r3, #0]
        ret = DRBG_SUCCESS;
 801f2f4:	2300      	movs	r3, #0
 801f2f6:	617b      	str	r3, [r7, #20]
    }

    return ret;
 801f2f8:	697b      	ldr	r3, [r7, #20]
}
 801f2fa:	4618      	mov	r0, r3
 801f2fc:	3718      	adds	r7, #24
 801f2fe:	46bd      	mov	sp, r7
 801f300:	bd80      	pop	{r7, pc}

0801f302 <Hash_DRBG_Uninstantiate>:

/* Returns: DRBG_SUCCESS or DRBG_FAILURE */
static int Hash_DRBG_Uninstantiate(DRBG_internal* drbg)
{
 801f302:	b580      	push	{r7, lr}
 801f304:	b086      	sub	sp, #24
 801f306:	af00      	add	r7, sp, #0
 801f308:	6078      	str	r0, [r7, #4]
    word32 i;
    int    compareSum = 0;
 801f30a:	2300      	movs	r3, #0
 801f30c:	613b      	str	r3, [r7, #16]
    byte*  compareDrbg = (byte*)drbg;
 801f30e:	687b      	ldr	r3, [r7, #4]
 801f310:	60fb      	str	r3, [r7, #12]

#ifdef WOLFSSL_SMALL_STACK_CACHE
    wc_Sha256Free(&drbg->sha256);
#endif

    ForceZero(drbg, sizeof(DRBG_internal));
 801f312:	2178      	movs	r1, #120	@ 0x78
 801f314:	6878      	ldr	r0, [r7, #4]
 801f316:	f7ff fc11 	bl	801eb3c <ForceZero>

    for (i = 0; i < sizeof(DRBG_internal); i++) {
 801f31a:	2300      	movs	r3, #0
 801f31c:	617b      	str	r3, [r7, #20]
 801f31e:	e00a      	b.n	801f336 <Hash_DRBG_Uninstantiate+0x34>
        compareSum |= compareDrbg[i] ^ 0;
 801f320:	68fa      	ldr	r2, [r7, #12]
 801f322:	697b      	ldr	r3, [r7, #20]
 801f324:	4413      	add	r3, r2
 801f326:	781b      	ldrb	r3, [r3, #0]
 801f328:	461a      	mov	r2, r3
 801f32a:	693b      	ldr	r3, [r7, #16]
 801f32c:	4313      	orrs	r3, r2
 801f32e:	613b      	str	r3, [r7, #16]
    for (i = 0; i < sizeof(DRBG_internal); i++) {
 801f330:	697b      	ldr	r3, [r7, #20]
 801f332:	3301      	adds	r3, #1
 801f334:	617b      	str	r3, [r7, #20]
 801f336:	697b      	ldr	r3, [r7, #20]
 801f338:	2b77      	cmp	r3, #119	@ 0x77
 801f33a:	d9f1      	bls.n	801f320 <Hash_DRBG_Uninstantiate+0x1e>
    }

    return (compareSum == 0) ? DRBG_SUCCESS : DRBG_FAILURE;
 801f33c:	693b      	ldr	r3, [r7, #16]
 801f33e:	2b00      	cmp	r3, #0
 801f340:	bf14      	ite	ne
 801f342:	2301      	movne	r3, #1
 801f344:	2300      	moveq	r3, #0
 801f346:	b2db      	uxtb	r3, r3
}
 801f348:	4618      	mov	r0, r3
 801f34a:	3718      	adds	r7, #24
 801f34c:	46bd      	mov	sp, r7
 801f34e:	bd80      	pop	{r7, pc}

0801f350 <wc_RNG_TestSeed>:


int wc_RNG_TestSeed(const byte* seed, word32 seedSz)
{
 801f350:	b580      	push	{r7, lr}
 801f352:	b086      	sub	sp, #24
 801f354:	af00      	add	r7, sp, #0
 801f356:	6078      	str	r0, [r7, #4]
 801f358:	6039      	str	r1, [r7, #0]
    int ret = 0;
 801f35a:	2300      	movs	r3, #0
 801f35c:	617b      	str	r3, [r7, #20]

    /* Check the seed for duplicate words. */
    word32 seedIdx = 0;
 801f35e:	2300      	movs	r3, #0
 801f360:	613b      	str	r3, [r7, #16]
    word32 scratchSz = min(SEED_BLOCK_SZ, seedSz - SEED_BLOCK_SZ);
 801f362:	683b      	ldr	r3, [r7, #0]
 801f364:	3b04      	subs	r3, #4
 801f366:	4619      	mov	r1, r3
 801f368:	2004      	movs	r0, #4
 801f36a:	f7ff fc27 	bl	801ebbc <min>
 801f36e:	60f8      	str	r0, [r7, #12]

    while (seedIdx < seedSz - SEED_BLOCK_SZ) {
 801f370:	e01b      	b.n	801f3aa <wc_RNG_TestSeed+0x5a>
        if (ConstantCompare(seed + seedIdx,
 801f372:	687a      	ldr	r2, [r7, #4]
 801f374:	693b      	ldr	r3, [r7, #16]
 801f376:	18d0      	adds	r0, r2, r3
                            seed + seedIdx + scratchSz,
 801f378:	693a      	ldr	r2, [r7, #16]
 801f37a:	68fb      	ldr	r3, [r7, #12]
 801f37c:	4413      	add	r3, r2
        if (ConstantCompare(seed + seedIdx,
 801f37e:	687a      	ldr	r2, [r7, #4]
 801f380:	4413      	add	r3, r2
 801f382:	68fa      	ldr	r2, [r7, #12]
 801f384:	4619      	mov	r1, r3
 801f386:	f7ff fbf2 	bl	801eb6e <ConstantCompare>
 801f38a:	4603      	mov	r3, r0
 801f38c:	2b00      	cmp	r3, #0
 801f38e:	d101      	bne.n	801f394 <wc_RNG_TestSeed+0x44>
                            (int)scratchSz) == 0) {

            ret = DRBG_CONT_FAILURE;
 801f390:	2303      	movs	r3, #3
 801f392:	617b      	str	r3, [r7, #20]
        }
        seedIdx += SEED_BLOCK_SZ;
 801f394:	693b      	ldr	r3, [r7, #16]
 801f396:	3304      	adds	r3, #4
 801f398:	613b      	str	r3, [r7, #16]
        scratchSz = min(SEED_BLOCK_SZ, (seedSz - seedIdx));
 801f39a:	683a      	ldr	r2, [r7, #0]
 801f39c:	693b      	ldr	r3, [r7, #16]
 801f39e:	1ad3      	subs	r3, r2, r3
 801f3a0:	4619      	mov	r1, r3
 801f3a2:	2004      	movs	r0, #4
 801f3a4:	f7ff fc0a 	bl	801ebbc <min>
 801f3a8:	60f8      	str	r0, [r7, #12]
    while (seedIdx < seedSz - SEED_BLOCK_SZ) {
 801f3aa:	683b      	ldr	r3, [r7, #0]
 801f3ac:	3b04      	subs	r3, #4
 801f3ae:	693a      	ldr	r2, [r7, #16]
 801f3b0:	429a      	cmp	r2, r3
 801f3b2:	d3de      	bcc.n	801f372 <wc_RNG_TestSeed+0x22>
    }

    return ret;
 801f3b4:	697b      	ldr	r3, [r7, #20]
}
 801f3b6:	4618      	mov	r0, r3
 801f3b8:	3718      	adds	r7, #24
 801f3ba:	46bd      	mov	sp, r7
 801f3bc:	bd80      	pop	{r7, pc}

0801f3be <_InitRng>:

#endif /* HAVE_ENTROPY_MEMUSE */

static int _InitRng(WC_RNG* rng, byte* nonce, word32 nonceSz,
                    void* heap, int devId)
{
 801f3be:	b590      	push	{r4, r7, lr}
 801f3c0:	b08f      	sub	sp, #60	@ 0x3c
 801f3c2:	af04      	add	r7, sp, #16
 801f3c4:	60f8      	str	r0, [r7, #12]
 801f3c6:	60b9      	str	r1, [r7, #8]
 801f3c8:	607a      	str	r2, [r7, #4]
 801f3ca:	603b      	str	r3, [r7, #0]
    int ret = 0;
 801f3cc:	2300      	movs	r3, #0
 801f3ce:	627b      	str	r3, [r7, #36]	@ 0x24
#ifdef HAVE_HASHDRBG
    word32 seedSz = SEED_SZ + SEED_BLOCK_SZ;
 801f3d0:	2324      	movs	r3, #36	@ 0x24
 801f3d2:	623b      	str	r3, [r7, #32]
#endif

    (void)nonce;
    (void)nonceSz;

    if (rng == NULL)
 801f3d4:	68fb      	ldr	r3, [r7, #12]
 801f3d6:	2b00      	cmp	r3, #0
 801f3d8:	d102      	bne.n	801f3e0 <_InitRng+0x22>
        return BAD_FUNC_ARG;
 801f3da:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801f3de:	e0a7      	b.n	801f530 <_InitRng+0x172>
    if (nonce == NULL && nonceSz != 0)
 801f3e0:	68bb      	ldr	r3, [r7, #8]
 801f3e2:	2b00      	cmp	r3, #0
 801f3e4:	d105      	bne.n	801f3f2 <_InitRng+0x34>
 801f3e6:	687b      	ldr	r3, [r7, #4]
 801f3e8:	2b00      	cmp	r3, #0
 801f3ea:	d002      	beq.n	801f3f2 <_InitRng+0x34>
        return BAD_FUNC_ARG;
 801f3ec:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801f3f0:	e09e      	b.n	801f530 <_InitRng+0x172>

#ifdef WOLFSSL_HEAP_TEST
    rng->heap = (void*)WOLFSSL_HEAP_TEST;
    (void)heap;
#else
    rng->heap = heap;
 801f3f2:	68fb      	ldr	r3, [r7, #12]
 801f3f4:	683a      	ldr	r2, [r7, #0]
 801f3f6:	605a      	str	r2, [r3, #4]
    (void)devId;
#endif

#ifdef HAVE_HASHDRBG
    /* init the DBRG to known values */
    rng->drbg = NULL;
 801f3f8:	68fb      	ldr	r3, [r7, #12]
 801f3fa:	2200      	movs	r2, #0
 801f3fc:	609a      	str	r2, [r3, #8]
    rng->status = DRBG_NOT_INIT;
 801f3fe:	68fb      	ldr	r3, [r7, #12]
 801f400:	2200      	movs	r2, #0
 801f402:	731a      	strb	r2, [r3, #12]
    ret = 0; /* success */
#else

 /* not CUSTOM_RAND_GENERATE_BLOCK follows */
#ifdef HAVE_HASHDRBG
    if (nonceSz == 0) {
 801f404:	687b      	ldr	r3, [r7, #4]
 801f406:	2b00      	cmp	r3, #0
 801f408:	d101      	bne.n	801f40e <_InitRng+0x50>
        seedSz = MAX_SEED_SZ;
 801f40a:	2334      	movs	r3, #52	@ 0x34
 801f40c:	623b      	str	r3, [r7, #32]
    }

    ret = wc_RNG_HealthTestLocal(0, rng->heap, devId);
 801f40e:	68fb      	ldr	r3, [r7, #12]
 801f410:	685b      	ldr	r3, [r3, #4]
 801f412:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801f414:	4619      	mov	r1, r3
 801f416:	2000      	movs	r0, #0
 801f418:	f000 fa02 	bl	801f820 <wc_RNG_HealthTestLocal>
 801f41c:	6278      	str	r0, [r7, #36]	@ 0x24
    if (ret != 0) {
 801f41e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801f420:	2b00      	cmp	r3, #0
 801f422:	d002      	beq.n	801f42a <_InitRng+0x6c>
        #if defined(DEBUG_WOLFSSL)
        WOLFSSL_MSG_EX("wc_RNG_HealthTestLocal failed err = %d", ret);
        #endif
        ret = DRBG_CONT_FAILURE;
 801f424:	2303      	movs	r3, #3
 801f426:	627b      	str	r3, [r7, #36]	@ 0x24
 801f428:	e061      	b.n	801f4ee <_InitRng+0x130>
    }
    else {
    #ifndef WOLFSSL_SMALL_STACK
        byte seed[MAX_SEED_SZ];
    #else
        byte* seed = (byte*)XMALLOC(MAX_SEED_SZ, rng->heap,
 801f42a:	2034      	movs	r0, #52	@ 0x34
 801f42c:	f7ff fb2c 	bl	801ea88 <wolfSSL_Malloc>
 801f430:	61f8      	str	r0, [r7, #28]
            DYNAMIC_TYPE_SEED);
        if (seed == NULL)
 801f432:	69fb      	ldr	r3, [r7, #28]
 801f434:	2b00      	cmp	r3, #0
 801f436:	d102      	bne.n	801f43e <_InitRng+0x80>
            return MEMORY_E;
 801f438:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801f43c:	e078      	b.n	801f530 <_InitRng+0x172>
    #endif

#if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)
        rng->drbg =
                (struct DRBG*)XMALLOC(sizeof(DRBG_internal), rng->heap,
 801f43e:	2078      	movs	r0, #120	@ 0x78
 801f440:	f7ff fb22 	bl	801ea88 <wolfSSL_Malloc>
 801f444:	4602      	mov	r2, r0
        rng->drbg =
 801f446:	68fb      	ldr	r3, [r7, #12]
 801f448:	609a      	str	r2, [r3, #8]
                                                          DYNAMIC_TYPE_RNG);
        if (rng->drbg == NULL) {
 801f44a:	68fb      	ldr	r3, [r7, #12]
 801f44c:	689b      	ldr	r3, [r3, #8]
 801f44e:	2b00      	cmp	r3, #0
 801f450:	d105      	bne.n	801f45e <_InitRng+0xa0>
    #if defined(DEBUG_WOLFSSL)
            WOLFSSL_MSG_EX("_InitRng XMALLOC failed to allocate %d bytes",
                           sizeof(DRBG_internal));
    #endif
            ret = MEMORY_E;
 801f452:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801f456:	627b      	str	r3, [r7, #36]	@ 0x24
            rng->status = DRBG_FAILED;
 801f458:	68fb      	ldr	r3, [r7, #12]
 801f45a:	2202      	movs	r2, #2
 801f45c:	731a      	strb	r2, [r3, #12]
        }
#else
        rng->drbg = (struct DRBG*)&rng->drbg_data;
#endif /* WOLFSSL_NO_MALLOC or WOLFSSL_STATIC_MEMORY */

        if (ret != 0) {
 801f45e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801f460:	2b00      	cmp	r3, #0
 801f462:	d138      	bne.n	801f4d6 <_InitRng+0x118>
                if (ret != 0) {
                    ret = DRBG_FAILURE;
                }
            }
#else
            ret = wc_GenerateSeed(&rng->seed, seed, seedSz);
 801f464:	68fb      	ldr	r3, [r7, #12]
 801f466:	6a3a      	ldr	r2, [r7, #32]
 801f468:	69f9      	ldr	r1, [r7, #28]
 801f46a:	4618      	mov	r0, r3
 801f46c:	f000 fa7e 	bl	801f96c <wc_GenerateSeed>
 801f470:	6278      	str	r0, [r7, #36]	@ 0x24
#endif /* WC_RNG_SEED_CB */
            if (ret == 0)
 801f472:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801f474:	2b00      	cmp	r3, #0
 801f476:	d105      	bne.n	801f484 <_InitRng+0xc6>
                ret = wc_RNG_TestSeed(seed, seedSz);
 801f478:	6a39      	ldr	r1, [r7, #32]
 801f47a:	69f8      	ldr	r0, [r7, #28]
 801f47c:	f7ff ff68 	bl	801f350 <wc_RNG_TestSeed>
 801f480:	6278      	str	r0, [r7, #36]	@ 0x24
 801f482:	e004      	b.n	801f48e <_InitRng+0xd0>
            else {
    #if defined(DEBUG_WOLFSSL)
                WOLFSSL_MSG_EX("wc_RNG_TestSeed failed... %d", ret);
    #endif
                ret = DRBG_FAILURE;
 801f484:	2301      	movs	r3, #1
 801f486:	627b      	str	r3, [r7, #36]	@ 0x24
                rng->status = DRBG_FAILED;
 801f488:	68fb      	ldr	r3, [r7, #12]
 801f48a:	2202      	movs	r2, #2
 801f48c:	731a      	strb	r2, [r3, #12]
            }

            if (ret == DRBG_SUCCESS)
 801f48e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801f490:	2b00      	cmp	r3, #0
 801f492:	d111      	bne.n	801f4b8 <_InitRng+0xfa>
                ret = Hash_DRBG_Instantiate((DRBG_internal *)rng->drbg,
 801f494:	68fb      	ldr	r3, [r7, #12]
 801f496:	6898      	ldr	r0, [r3, #8]
                            seed + SEED_BLOCK_SZ, seedSz - SEED_BLOCK_SZ,
 801f498:	69fb      	ldr	r3, [r7, #28]
 801f49a:	1d19      	adds	r1, r3, #4
                ret = Hash_DRBG_Instantiate((DRBG_internal *)rng->drbg,
 801f49c:	6a3b      	ldr	r3, [r7, #32]
 801f49e:	1f1c      	subs	r4, r3, #4
 801f4a0:	68fb      	ldr	r3, [r7, #12]
 801f4a2:	685b      	ldr	r3, [r3, #4]
 801f4a4:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801f4a6:	9202      	str	r2, [sp, #8]
 801f4a8:	9301      	str	r3, [sp, #4]
 801f4aa:	687b      	ldr	r3, [r7, #4]
 801f4ac:	9300      	str	r3, [sp, #0]
 801f4ae:	68bb      	ldr	r3, [r7, #8]
 801f4b0:	4622      	mov	r2, r4
 801f4b2:	f7ff fee5 	bl	801f280 <Hash_DRBG_Instantiate>
 801f4b6:	6278      	str	r0, [r7, #36]	@ 0x24
                            nonce, nonceSz, rng->heap, devId);

            if (ret != DRBG_SUCCESS) {
 801f4b8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801f4ba:	2b00      	cmp	r3, #0
 801f4bc:	d00b      	beq.n	801f4d6 <_InitRng+0x118>
            #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)
                XFREE(rng->drbg, rng->heap, DYNAMIC_TYPE_RNG);
 801f4be:	68fb      	ldr	r3, [r7, #12]
 801f4c0:	689b      	ldr	r3, [r3, #8]
 801f4c2:	61bb      	str	r3, [r7, #24]
 801f4c4:	69bb      	ldr	r3, [r7, #24]
 801f4c6:	2b00      	cmp	r3, #0
 801f4c8:	d002      	beq.n	801f4d0 <_InitRng+0x112>
 801f4ca:	69b8      	ldr	r0, [r7, #24]
 801f4cc:	f7ff faf8 	bl	801eac0 <wolfSSL_Free>
            #endif
                rng->drbg = NULL;
 801f4d0:	68fb      	ldr	r3, [r7, #12]
 801f4d2:	2200      	movs	r2, #0
 801f4d4:	609a      	str	r2, [r3, #8]
            }
        } /* ret == 0 */

        ForceZero(seed, seedSz);
 801f4d6:	6a39      	ldr	r1, [r7, #32]
 801f4d8:	69f8      	ldr	r0, [r7, #28]
 801f4da:	f7ff fb2f 	bl	801eb3c <ForceZero>
    #ifdef WOLFSSL_SMALL_STACK
        XFREE(seed, rng->heap, DYNAMIC_TYPE_SEED);
 801f4de:	69fb      	ldr	r3, [r7, #28]
 801f4e0:	617b      	str	r3, [r7, #20]
 801f4e2:	697b      	ldr	r3, [r7, #20]
 801f4e4:	2b00      	cmp	r3, #0
 801f4e6:	d002      	beq.n	801f4ee <_InitRng+0x130>
 801f4e8:	6978      	ldr	r0, [r7, #20]
 801f4ea:	f7ff fae9 	bl	801eac0 <wolfSSL_Free>
    #endif
    } /* else swc_RNG_HealthTestLocal was successful */

    if (ret == DRBG_SUCCESS) {
 801f4ee:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801f4f0:	2b00      	cmp	r3, #0
 801f4f2:	d105      	bne.n	801f500 <_InitRng+0x142>
        wc_MemZero_Add("DRBG V", &drbg->V, sizeof(drbg->V));
        wc_MemZero_Add("DRBG C", &drbg->C, sizeof(drbg->C));
    #endif
#endif

        rng->status = DRBG_OK;
 801f4f4:	68fb      	ldr	r3, [r7, #12]
 801f4f6:	2201      	movs	r2, #1
 801f4f8:	731a      	strb	r2, [r3, #12]
        ret = 0;
 801f4fa:	2300      	movs	r3, #0
 801f4fc:	627b      	str	r3, [r7, #36]	@ 0x24
 801f4fe:	e016      	b.n	801f52e <_InitRng+0x170>
    }
    else if (ret == DRBG_CONT_FAILURE) {
 801f500:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801f502:	2b03      	cmp	r3, #3
 801f504:	d106      	bne.n	801f514 <_InitRng+0x156>
        rng->status = DRBG_CONT_FAILED;
 801f506:	68fb      	ldr	r3, [r7, #12]
 801f508:	2203      	movs	r2, #3
 801f50a:	731a      	strb	r2, [r3, #12]
        ret = DRBG_CONT_FIPS_E;
 801f50c:	f06f 03d0 	mvn.w	r3, #208	@ 0xd0
 801f510:	627b      	str	r3, [r7, #36]	@ 0x24
 801f512:	e00c      	b.n	801f52e <_InitRng+0x170>
    }
    else if (ret == DRBG_FAILURE) {
 801f514:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801f516:	2b01      	cmp	r3, #1
 801f518:	d106      	bne.n	801f528 <_InitRng+0x16a>
        rng->status = DRBG_FAILED;
 801f51a:	68fb      	ldr	r3, [r7, #12]
 801f51c:	2202      	movs	r2, #2
 801f51e:	731a      	strb	r2, [r3, #12]
        ret = RNG_FAILURE_E;
 801f520:	f06f 03c6 	mvn.w	r3, #198	@ 0xc6
 801f524:	627b      	str	r3, [r7, #36]	@ 0x24
 801f526:	e002      	b.n	801f52e <_InitRng+0x170>
    }
    else {
        rng->status = DRBG_FAILED;
 801f528:	68fb      	ldr	r3, [r7, #12]
 801f52a:	2202      	movs	r2, #2
 801f52c:	731a      	strb	r2, [r3, #12]
    }
#endif /* HAVE_HASHDRBG */
#endif /* CUSTOM_RAND_GENERATE_BLOCK */

    return ret;
 801f52e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 801f530:	4618      	mov	r0, r3
 801f532:	372c      	adds	r7, #44	@ 0x2c
 801f534:	46bd      	mov	sp, r7
 801f536:	bd90      	pop	{r4, r7, pc}

0801f538 <wc_rng_free>:
}


WOLFSSL_ABI
void wc_rng_free(WC_RNG* rng)
{
 801f538:	b580      	push	{r7, lr}
 801f53a:	b084      	sub	sp, #16
 801f53c:	af00      	add	r7, sp, #0
 801f53e:	6078      	str	r0, [r7, #4]
    if (rng) {
 801f540:	687b      	ldr	r3, [r7, #4]
 801f542:	2b00      	cmp	r3, #0
 801f544:	d011      	beq.n	801f56a <wc_rng_free+0x32>
        void* heap = rng->heap;
 801f546:	687b      	ldr	r3, [r7, #4]
 801f548:	685b      	ldr	r3, [r3, #4]
 801f54a:	60fb      	str	r3, [r7, #12]

        wc_FreeRng(rng);
 801f54c:	6878      	ldr	r0, [r7, #4]
 801f54e:	f000 f8c3 	bl	801f6d8 <wc_FreeRng>
        ForceZero(rng, sizeof(WC_RNG));
 801f552:	2110      	movs	r1, #16
 801f554:	6878      	ldr	r0, [r7, #4]
 801f556:	f7ff faf1 	bl	801eb3c <ForceZero>
        XFREE(rng, heap, DYNAMIC_TYPE_RNG);
 801f55a:	687b      	ldr	r3, [r7, #4]
 801f55c:	60bb      	str	r3, [r7, #8]
 801f55e:	68bb      	ldr	r3, [r7, #8]
 801f560:	2b00      	cmp	r3, #0
 801f562:	d002      	beq.n	801f56a <wc_rng_free+0x32>
 801f564:	68b8      	ldr	r0, [r7, #8]
 801f566:	f7ff faab 	bl	801eac0 <wolfSSL_Free>
        (void)heap;
    }
}
 801f56a:	bf00      	nop
 801f56c:	3710      	adds	r7, #16
 801f56e:	46bd      	mov	sp, r7
 801f570:	bd80      	pop	{r7, pc}

0801f572 <wc_InitRng>:

WOLFSSL_ABI
int wc_InitRng(WC_RNG* rng)
{
 801f572:	b580      	push	{r7, lr}
 801f574:	b084      	sub	sp, #16
 801f576:	af02      	add	r7, sp, #8
 801f578:	6078      	str	r0, [r7, #4]
    return _InitRng(rng, NULL, 0, NULL, INVALID_DEVID);
 801f57a:	f06f 0301 	mvn.w	r3, #1
 801f57e:	9300      	str	r3, [sp, #0]
 801f580:	2300      	movs	r3, #0
 801f582:	2200      	movs	r2, #0
 801f584:	2100      	movs	r1, #0
 801f586:	6878      	ldr	r0, [r7, #4]
 801f588:	f7ff ff19 	bl	801f3be <_InitRng>
 801f58c:	4603      	mov	r3, r0
}
 801f58e:	4618      	mov	r0, r3
 801f590:	3708      	adds	r7, #8
 801f592:	46bd      	mov	sp, r7
 801f594:	bd80      	pop	{r7, pc}

0801f596 <wc_RNG_GenerateBlock>:


/* place a generated block in output */
WOLFSSL_ABI
int wc_RNG_GenerateBlock(WC_RNG* rng, byte* output, word32 sz)
{
 801f596:	b580      	push	{r7, lr}
 801f598:	b088      	sub	sp, #32
 801f59a:	af00      	add	r7, sp, #0
 801f59c:	60f8      	str	r0, [r7, #12]
 801f59e:	60b9      	str	r1, [r7, #8]
 801f5a0:	607a      	str	r2, [r7, #4]
    int ret;

    if (rng == NULL || output == NULL)
 801f5a2:	68fb      	ldr	r3, [r7, #12]
 801f5a4:	2b00      	cmp	r3, #0
 801f5a6:	d002      	beq.n	801f5ae <wc_RNG_GenerateBlock+0x18>
 801f5a8:	68bb      	ldr	r3, [r7, #8]
 801f5aa:	2b00      	cmp	r3, #0
 801f5ac:	d102      	bne.n	801f5b4 <wc_RNG_GenerateBlock+0x1e>
        return BAD_FUNC_ARG;
 801f5ae:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801f5b2:	e08d      	b.n	801f6d0 <wc_RNG_GenerateBlock+0x13a>

    if (sz == 0)
 801f5b4:	687b      	ldr	r3, [r7, #4]
 801f5b6:	2b00      	cmp	r3, #0
 801f5b8:	d101      	bne.n	801f5be <wc_RNG_GenerateBlock+0x28>
        return 0;
 801f5ba:	2300      	movs	r3, #0
 801f5bc:	e088      	b.n	801f6d0 <wc_RNG_GenerateBlock+0x13a>
    XMEMSET(output, 0, sz);
    ret = (int)CUSTOM_RAND_GENERATE_BLOCK(output, sz);
#else

#ifdef HAVE_HASHDRBG
    if (sz > RNG_MAX_BLOCK_LEN)
 801f5be:	687b      	ldr	r3, [r7, #4]
 801f5c0:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 801f5c4:	d902      	bls.n	801f5cc <wc_RNG_GenerateBlock+0x36>
        return BAD_FUNC_ARG;
 801f5c6:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801f5ca:	e081      	b.n	801f6d0 <wc_RNG_GenerateBlock+0x13a>

    if (rng->status != DRBG_OK)
 801f5cc:	68fb      	ldr	r3, [r7, #12]
 801f5ce:	7b1b      	ldrb	r3, [r3, #12]
 801f5d0:	2b01      	cmp	r3, #1
 801f5d2:	d002      	beq.n	801f5da <wc_RNG_GenerateBlock+0x44>
        return RNG_FAILURE_E;
 801f5d4:	f06f 03c6 	mvn.w	r3, #198	@ 0xc6
 801f5d8:	e07a      	b.n	801f6d0 <wc_RNG_GenerateBlock+0x13a>

    ret = Hash_DRBG_Generate((DRBG_internal *)rng->drbg, output, sz);
 801f5da:	68fb      	ldr	r3, [r7, #12]
 801f5dc:	689b      	ldr	r3, [r3, #8]
 801f5de:	687a      	ldr	r2, [r7, #4]
 801f5e0:	68b9      	ldr	r1, [r7, #8]
 801f5e2:	4618      	mov	r0, r3
 801f5e4:	f7ff fd9e 	bl	801f124 <Hash_DRBG_Generate>
 801f5e8:	61f8      	str	r0, [r7, #28]
    if (ret == DRBG_NEED_RESEED) {
 801f5ea:	69fb      	ldr	r3, [r7, #28]
 801f5ec:	2b02      	cmp	r3, #2
 801f5ee:	d158      	bne.n	801f6a2 <wc_RNG_GenerateBlock+0x10c>
        int devId = INVALID_DEVID;
 801f5f0:	f06f 0301 	mvn.w	r3, #1
 801f5f4:	61bb      	str	r3, [r7, #24]
    #if defined(WOLFSSL_ASYNC_CRYPT) || defined(WOLF_CRYPTO_CB)
        devId = rng->devId;
    #endif
        if (wc_RNG_HealthTestLocal(1, rng->heap, devId) == 0) {
 801f5f6:	68fb      	ldr	r3, [r7, #12]
 801f5f8:	685b      	ldr	r3, [r3, #4]
 801f5fa:	69ba      	ldr	r2, [r7, #24]
 801f5fc:	4619      	mov	r1, r3
 801f5fe:	2001      	movs	r0, #1
 801f600:	f000 f90e 	bl	801f820 <wc_RNG_HealthTestLocal>
 801f604:	4603      	mov	r3, r0
 801f606:	2b00      	cmp	r3, #0
 801f608:	d149      	bne.n	801f69e <wc_RNG_GenerateBlock+0x108>
        #ifndef WOLFSSL_SMALL_STACK
            byte newSeed[SEED_SZ + SEED_BLOCK_SZ];
            ret = DRBG_SUCCESS;
        #else
            byte* newSeed = (byte*)XMALLOC(SEED_SZ + SEED_BLOCK_SZ, rng->heap,
 801f60a:	2024      	movs	r0, #36	@ 0x24
 801f60c:	f7ff fa3c 	bl	801ea88 <wolfSSL_Malloc>
 801f610:	6178      	str	r0, [r7, #20]
                DYNAMIC_TYPE_SEED);
            ret = (newSeed == NULL) ? MEMORY_E : DRBG_SUCCESS;
 801f612:	697b      	ldr	r3, [r7, #20]
 801f614:	2b00      	cmp	r3, #0
 801f616:	d102      	bne.n	801f61e <wc_RNG_GenerateBlock+0x88>
 801f618:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801f61c:	e000      	b.n	801f620 <wc_RNG_GenerateBlock+0x8a>
 801f61e:	2300      	movs	r3, #0
 801f620:	61fb      	str	r3, [r7, #28]
        #endif
            if (ret == DRBG_SUCCESS) {
 801f622:	69fb      	ldr	r3, [r7, #28]
 801f624:	2b00      	cmp	r3, #0
 801f626:	d10b      	bne.n	801f640 <wc_RNG_GenerateBlock+0xaa>
                    if (ret != 0) {
                        ret = DRBG_FAILURE;
                    }
                }
            #else
                ret = wc_GenerateSeed(&rng->seed, newSeed,
 801f628:	68fb      	ldr	r3, [r7, #12]
 801f62a:	2224      	movs	r2, #36	@ 0x24
 801f62c:	6979      	ldr	r1, [r7, #20]
 801f62e:	4618      	mov	r0, r3
 801f630:	f000 f99c 	bl	801f96c <wc_GenerateSeed>
 801f634:	61f8      	str	r0, [r7, #28]
                                  SEED_SZ + SEED_BLOCK_SZ);
            #endif
                if (ret != 0)
 801f636:	69fb      	ldr	r3, [r7, #28]
 801f638:	2b00      	cmp	r3, #0
 801f63a:	d001      	beq.n	801f640 <wc_RNG_GenerateBlock+0xaa>
                    ret = DRBG_FAILURE;
 801f63c:	2301      	movs	r3, #1
 801f63e:	61fb      	str	r3, [r7, #28]
            }
            if (ret == DRBG_SUCCESS)
 801f640:	69fb      	ldr	r3, [r7, #28]
 801f642:	2b00      	cmp	r3, #0
 801f644:	d104      	bne.n	801f650 <wc_RNG_GenerateBlock+0xba>
                ret = wc_RNG_TestSeed(newSeed, SEED_SZ + SEED_BLOCK_SZ);
 801f646:	2124      	movs	r1, #36	@ 0x24
 801f648:	6978      	ldr	r0, [r7, #20]
 801f64a:	f7ff fe81 	bl	801f350 <wc_RNG_TestSeed>
 801f64e:	61f8      	str	r0, [r7, #28]

            if (ret == DRBG_SUCCESS)
 801f650:	69fb      	ldr	r3, [r7, #28]
 801f652:	2b00      	cmp	r3, #0
 801f654:	d108      	bne.n	801f668 <wc_RNG_GenerateBlock+0xd2>
                ret = Hash_DRBG_Reseed((DRBG_internal *)rng->drbg,
 801f656:	68fb      	ldr	r3, [r7, #12]
 801f658:	6898      	ldr	r0, [r3, #8]
                                       newSeed + SEED_BLOCK_SZ, SEED_SZ);
 801f65a:	697b      	ldr	r3, [r7, #20]
 801f65c:	3304      	adds	r3, #4
                ret = Hash_DRBG_Reseed((DRBG_internal *)rng->drbg,
 801f65e:	2220      	movs	r2, #32
 801f660:	4619      	mov	r1, r3
 801f662:	f7ff fbab 	bl	801edbc <Hash_DRBG_Reseed>
 801f666:	61f8      	str	r0, [r7, #28]
            if (ret == DRBG_SUCCESS)
 801f668:	69fb      	ldr	r3, [r7, #28]
 801f66a:	2b00      	cmp	r3, #0
 801f66c:	d107      	bne.n	801f67e <wc_RNG_GenerateBlock+0xe8>
                ret = Hash_DRBG_Generate((DRBG_internal *)rng->drbg, output, sz);
 801f66e:	68fb      	ldr	r3, [r7, #12]
 801f670:	689b      	ldr	r3, [r3, #8]
 801f672:	687a      	ldr	r2, [r7, #4]
 801f674:	68b9      	ldr	r1, [r7, #8]
 801f676:	4618      	mov	r0, r3
 801f678:	f7ff fd54 	bl	801f124 <Hash_DRBG_Generate>
 801f67c:	61f8      	str	r0, [r7, #28]

        #ifdef WOLFSSL_SMALL_STACK
            if (newSeed != NULL) {
 801f67e:	697b      	ldr	r3, [r7, #20]
 801f680:	2b00      	cmp	r3, #0
 801f682:	d003      	beq.n	801f68c <wc_RNG_GenerateBlock+0xf6>
                ForceZero(newSeed, SEED_SZ + SEED_BLOCK_SZ);
 801f684:	2124      	movs	r1, #36	@ 0x24
 801f686:	6978      	ldr	r0, [r7, #20]
 801f688:	f7ff fa58 	bl	801eb3c <ForceZero>
            }
            XFREE(newSeed, rng->heap, DYNAMIC_TYPE_SEED);
 801f68c:	697b      	ldr	r3, [r7, #20]
 801f68e:	613b      	str	r3, [r7, #16]
 801f690:	693b      	ldr	r3, [r7, #16]
 801f692:	2b00      	cmp	r3, #0
 801f694:	d005      	beq.n	801f6a2 <wc_RNG_GenerateBlock+0x10c>
 801f696:	6938      	ldr	r0, [r7, #16]
 801f698:	f7ff fa12 	bl	801eac0 <wolfSSL_Free>
 801f69c:	e001      	b.n	801f6a2 <wc_RNG_GenerateBlock+0x10c>
        #else
            ForceZero(newSeed, sizeof(newSeed));
        #endif
        }
        else {
            ret = DRBG_CONT_FAILURE;
 801f69e:	2303      	movs	r3, #3
 801f6a0:	61fb      	str	r3, [r7, #28]
        }
    }

    if (ret == DRBG_SUCCESS) {
 801f6a2:	69fb      	ldr	r3, [r7, #28]
 801f6a4:	2b00      	cmp	r3, #0
 801f6a6:	d102      	bne.n	801f6ae <wc_RNG_GenerateBlock+0x118>
        ret = 0;
 801f6a8:	2300      	movs	r3, #0
 801f6aa:	61fb      	str	r3, [r7, #28]
 801f6ac:	e00f      	b.n	801f6ce <wc_RNG_GenerateBlock+0x138>
    }
    else if (ret == DRBG_CONT_FAILURE) {
 801f6ae:	69fb      	ldr	r3, [r7, #28]
 801f6b0:	2b03      	cmp	r3, #3
 801f6b2:	d106      	bne.n	801f6c2 <wc_RNG_GenerateBlock+0x12c>
        ret = DRBG_CONT_FIPS_E;
 801f6b4:	f06f 03d0 	mvn.w	r3, #208	@ 0xd0
 801f6b8:	61fb      	str	r3, [r7, #28]
        rng->status = DRBG_CONT_FAILED;
 801f6ba:	68fb      	ldr	r3, [r7, #12]
 801f6bc:	2203      	movs	r2, #3
 801f6be:	731a      	strb	r2, [r3, #12]
 801f6c0:	e005      	b.n	801f6ce <wc_RNG_GenerateBlock+0x138>
    }
    else {
        ret = RNG_FAILURE_E;
 801f6c2:	f06f 03c6 	mvn.w	r3, #198	@ 0xc6
 801f6c6:	61fb      	str	r3, [r7, #28]
        rng->status = DRBG_FAILED;
 801f6c8:	68fb      	ldr	r3, [r7, #12]
 801f6ca:	2202      	movs	r2, #2
 801f6cc:	731a      	strb	r2, [r3, #12]
    ret = RNG_FAILURE_E;

#endif /* HAVE_HASHDRBG */
#endif /* CUSTOM_RAND_GENERATE_BLOCK */

    return ret;
 801f6ce:	69fb      	ldr	r3, [r7, #28]
}
 801f6d0:	4618      	mov	r0, r3
 801f6d2:	3720      	adds	r7, #32
 801f6d4:	46bd      	mov	sp, r7
 801f6d6:	bd80      	pop	{r7, pc}

0801f6d8 <wc_FreeRng>:
    return wc_RNG_GenerateBlock(rng, b, 1);
}


int wc_FreeRng(WC_RNG* rng)
{
 801f6d8:	b580      	push	{r7, lr}
 801f6da:	b084      	sub	sp, #16
 801f6dc:	af00      	add	r7, sp, #0
 801f6de:	6078      	str	r0, [r7, #4]
    int ret = 0;
 801f6e0:	2300      	movs	r3, #0
 801f6e2:	60fb      	str	r3, [r7, #12]

    if (rng == NULL)
 801f6e4:	687b      	ldr	r3, [r7, #4]
 801f6e6:	2b00      	cmp	r3, #0
 801f6e8:	d102      	bne.n	801f6f0 <wc_FreeRng+0x18>
        return BAD_FUNC_ARG;
 801f6ea:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801f6ee:	e01e      	b.n	801f72e <wc_FreeRng+0x56>
#if defined(WOLFSSL_ASYNC_CRYPT)
    wolfAsync_DevCtxFree(&rng->asyncDev, WOLFSSL_ASYNC_MARKER_RNG);
#endif

#ifdef HAVE_HASHDRBG
    if (rng->drbg != NULL) {
 801f6f0:	687b      	ldr	r3, [r7, #4]
 801f6f2:	689b      	ldr	r3, [r3, #8]
 801f6f4:	2b00      	cmp	r3, #0
 801f6f6:	d016      	beq.n	801f726 <wc_FreeRng+0x4e>
      if (Hash_DRBG_Uninstantiate((DRBG_internal *)rng->drbg) != DRBG_SUCCESS)
 801f6f8:	687b      	ldr	r3, [r7, #4]
 801f6fa:	689b      	ldr	r3, [r3, #8]
 801f6fc:	4618      	mov	r0, r3
 801f6fe:	f7ff fe00 	bl	801f302 <Hash_DRBG_Uninstantiate>
 801f702:	4603      	mov	r3, r0
 801f704:	2b00      	cmp	r3, #0
 801f706:	d002      	beq.n	801f70e <wc_FreeRng+0x36>
            ret = RNG_FAILURE_E;
 801f708:	f06f 03c6 	mvn.w	r3, #198	@ 0xc6
 801f70c:	60fb      	str	r3, [r7, #12]

    #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)
        XFREE(rng->drbg, rng->heap, DYNAMIC_TYPE_RNG);
 801f70e:	687b      	ldr	r3, [r7, #4]
 801f710:	689b      	ldr	r3, [r3, #8]
 801f712:	60bb      	str	r3, [r7, #8]
 801f714:	68bb      	ldr	r3, [r7, #8]
 801f716:	2b00      	cmp	r3, #0
 801f718:	d002      	beq.n	801f720 <wc_FreeRng+0x48>
 801f71a:	68b8      	ldr	r0, [r7, #8]
 801f71c:	f7ff f9d0 	bl	801eac0 <wolfSSL_Free>
    #elif defined(WOLFSSL_CHECK_MEM_ZERO)
        wc_MemZero_Check(rng->drbg, sizeof(DRBG_internal));
    #endif
        rng->drbg = NULL;
 801f720:	687b      	ldr	r3, [r7, #4]
 801f722:	2200      	movs	r2, #0
 801f724:	609a      	str	r2, [r3, #8]
    }

    rng->status = DRBG_NOT_INIT;
 801f726:	687b      	ldr	r3, [r7, #4]
 801f728:	2200      	movs	r2, #0
 801f72a:	731a      	strb	r2, [r3, #12]
    /* don't overwrite previously set error */
    if (wc_VersalTrngReset() && !ret)
        ret = WC_HW_E;
#endif

    return ret;
 801f72c:	68fb      	ldr	r3, [r7, #12]
}
 801f72e:	4618      	mov	r0, r3
 801f730:	3710      	adds	r7, #16
 801f732:	46bd      	mov	sp, r7
 801f734:	bd80      	pop	{r7, pc}

0801f736 <wc_RNG_HealthTest_ex>:
int wc_RNG_HealthTest_ex(int reseed, const byte* nonce, word32 nonceSz,
                                  const byte* seedA, word32 seedASz,
                                  const byte* seedB, word32 seedBSz,
                                  byte* output, word32 outputSz,
                                  void* heap, int devId)
{
 801f736:	b580      	push	{r7, lr}
 801f738:	b08c      	sub	sp, #48	@ 0x30
 801f73a:	af04      	add	r7, sp, #16
 801f73c:	60f8      	str	r0, [r7, #12]
 801f73e:	60b9      	str	r1, [r7, #8]
 801f740:	607a      	str	r2, [r7, #4]
 801f742:	603b      	str	r3, [r7, #0]
    int ret = -1;
 801f744:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 801f748:	61fb      	str	r3, [r7, #28]
    DRBG_internal* drbg;
#ifndef WOLFSSL_SMALL_STACK
    DRBG_internal  drbg_var;
#endif

    if (seedA == NULL || output == NULL) {
 801f74a:	683b      	ldr	r3, [r7, #0]
 801f74c:	2b00      	cmp	r3, #0
 801f74e:	d002      	beq.n	801f756 <wc_RNG_HealthTest_ex+0x20>
 801f750:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801f752:	2b00      	cmp	r3, #0
 801f754:	d102      	bne.n	801f75c <wc_RNG_HealthTest_ex+0x26>
        return BAD_FUNC_ARG;
 801f756:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801f75a:	e05d      	b.n	801f818 <wc_RNG_HealthTest_ex+0xe2>
    }

    if (reseed != 0 && seedB == NULL) {
 801f75c:	68fb      	ldr	r3, [r7, #12]
 801f75e:	2b00      	cmp	r3, #0
 801f760:	d005      	beq.n	801f76e <wc_RNG_HealthTest_ex+0x38>
 801f762:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801f764:	2b00      	cmp	r3, #0
 801f766:	d102      	bne.n	801f76e <wc_RNG_HealthTest_ex+0x38>
        return BAD_FUNC_ARG;
 801f768:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801f76c:	e054      	b.n	801f818 <wc_RNG_HealthTest_ex+0xe2>
    }

    if (outputSz != RNG_HEALTH_TEST_CHECK_SIZE) {
 801f76e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801f770:	2b80      	cmp	r3, #128	@ 0x80
 801f772:	d001      	beq.n	801f778 <wc_RNG_HealthTest_ex+0x42>
        return ret;
 801f774:	69fb      	ldr	r3, [r7, #28]
 801f776:	e04f      	b.n	801f818 <wc_RNG_HealthTest_ex+0xe2>
    }

#ifdef WOLFSSL_SMALL_STACK
    drbg = (DRBG_internal*)XMALLOC(sizeof(DRBG_internal), heap,
 801f778:	2078      	movs	r0, #120	@ 0x78
 801f77a:	f7ff f985 	bl	801ea88 <wolfSSL_Malloc>
 801f77e:	61b8      	str	r0, [r7, #24]
        DYNAMIC_TYPE_RNG);
    if (drbg == NULL) {
 801f780:	69bb      	ldr	r3, [r7, #24]
 801f782:	2b00      	cmp	r3, #0
 801f784:	d102      	bne.n	801f78c <wc_RNG_HealthTest_ex+0x56>
        return MEMORY_E;
 801f786:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801f78a:	e045      	b.n	801f818 <wc_RNG_HealthTest_ex+0xe2>
    }
#else
    drbg = &drbg_var;
#endif

    if (Hash_DRBG_Instantiate(drbg, seedA, seedASz, nonce, nonceSz,
 801f78c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801f78e:	9302      	str	r3, [sp, #8]
 801f790:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801f792:	9301      	str	r3, [sp, #4]
 801f794:	687b      	ldr	r3, [r7, #4]
 801f796:	9300      	str	r3, [sp, #0]
 801f798:	68bb      	ldr	r3, [r7, #8]
 801f79a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801f79c:	6839      	ldr	r1, [r7, #0]
 801f79e:	69b8      	ldr	r0, [r7, #24]
 801f7a0:	f7ff fd6e 	bl	801f280 <Hash_DRBG_Instantiate>
 801f7a4:	4603      	mov	r3, r0
 801f7a6:	2b00      	cmp	r3, #0
 801f7a8:	d11d      	bne.n	801f7e6 <wc_RNG_HealthTest_ex+0xb0>
                              heap, devId) != 0) {
        goto exit_rng_ht;
    }

    if (reseed) {
 801f7aa:	68fb      	ldr	r3, [r7, #12]
 801f7ac:	2b00      	cmp	r3, #0
 801f7ae:	d007      	beq.n	801f7c0 <wc_RNG_HealthTest_ex+0x8a>
        if (Hash_DRBG_Reseed(drbg, seedB, seedBSz) != 0) {
 801f7b0:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801f7b2:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 801f7b4:	69b8      	ldr	r0, [r7, #24]
 801f7b6:	f7ff fb01 	bl	801edbc <Hash_DRBG_Reseed>
 801f7ba:	4603      	mov	r3, r0
 801f7bc:	2b00      	cmp	r3, #0
 801f7be:	d114      	bne.n	801f7ea <wc_RNG_HealthTest_ex+0xb4>
    /* This call to generate is prescribed by the NIST DRBGVS
     * procedure. The results are thrown away. The known
     * answer test checks the second block of DRBG out of
     * the generator to ensure the internal state is updated
     * as expected. */
    if (Hash_DRBG_Generate(drbg, output, outputSz) != 0) {
 801f7c0:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801f7c2:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 801f7c4:	69b8      	ldr	r0, [r7, #24]
 801f7c6:	f7ff fcad 	bl	801f124 <Hash_DRBG_Generate>
 801f7ca:	4603      	mov	r3, r0
 801f7cc:	2b00      	cmp	r3, #0
 801f7ce:	d10e      	bne.n	801f7ee <wc_RNG_HealthTest_ex+0xb8>
        goto exit_rng_ht;
    }

    if (Hash_DRBG_Generate(drbg, output, outputSz) != 0) {
 801f7d0:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801f7d2:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 801f7d4:	69b8      	ldr	r0, [r7, #24]
 801f7d6:	f7ff fca5 	bl	801f124 <Hash_DRBG_Generate>
 801f7da:	4603      	mov	r3, r0
 801f7dc:	2b00      	cmp	r3, #0
 801f7de:	d108      	bne.n	801f7f2 <wc_RNG_HealthTest_ex+0xbc>
        goto exit_rng_ht;
    }

    /* Mark success */
    ret = 0;
 801f7e0:	2300      	movs	r3, #0
 801f7e2:	61fb      	str	r3, [r7, #28]
 801f7e4:	e006      	b.n	801f7f4 <wc_RNG_HealthTest_ex+0xbe>
        goto exit_rng_ht;
 801f7e6:	bf00      	nop
 801f7e8:	e004      	b.n	801f7f4 <wc_RNG_HealthTest_ex+0xbe>
            goto exit_rng_ht;
 801f7ea:	bf00      	nop
 801f7ec:	e002      	b.n	801f7f4 <wc_RNG_HealthTest_ex+0xbe>
        goto exit_rng_ht;
 801f7ee:	bf00      	nop
 801f7f0:	e000      	b.n	801f7f4 <wc_RNG_HealthTest_ex+0xbe>
        goto exit_rng_ht;
 801f7f2:	bf00      	nop

exit_rng_ht:

    /* This is safe to call even if Hash_DRBG_Instantiate fails */
    if (Hash_DRBG_Uninstantiate(drbg) != 0) {
 801f7f4:	69b8      	ldr	r0, [r7, #24]
 801f7f6:	f7ff fd84 	bl	801f302 <Hash_DRBG_Uninstantiate>
 801f7fa:	4603      	mov	r3, r0
 801f7fc:	2b00      	cmp	r3, #0
 801f7fe:	d002      	beq.n	801f806 <wc_RNG_HealthTest_ex+0xd0>
        ret = -1;
 801f800:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 801f804:	61fb      	str	r3, [r7, #28]
    }

#ifdef WOLFSSL_SMALL_STACK
    XFREE(drbg, heap, DYNAMIC_TYPE_RNG);
 801f806:	69bb      	ldr	r3, [r7, #24]
 801f808:	617b      	str	r3, [r7, #20]
 801f80a:	697b      	ldr	r3, [r7, #20]
 801f80c:	2b00      	cmp	r3, #0
 801f80e:	d002      	beq.n	801f816 <wc_RNG_HealthTest_ex+0xe0>
 801f810:	6978      	ldr	r0, [r7, #20]
 801f812:	f7ff f955 	bl	801eac0 <wolfSSL_Free>
#endif

    return ret;
 801f816:	69fb      	ldr	r3, [r7, #28]
}
 801f818:	4618      	mov	r0, r3
 801f81a:	3720      	adds	r7, #32
 801f81c:	46bd      	mov	sp, r7
 801f81e:	bd80      	pop	{r7, pc}

0801f820 <wc_RNG_HealthTestLocal>:
    0xd4, 0x31, 0xf4, 0xc9, 0xf7, 0x04, 0x27, 0xdf
};


static int wc_RNG_HealthTestLocal(int reseed, void* heap, int devId)
{
 801f820:	b580      	push	{r7, lr}
 801f822:	b094      	sub	sp, #80	@ 0x50
 801f824:	af08      	add	r7, sp, #32
 801f826:	60f8      	str	r0, [r7, #12]
 801f828:	60b9      	str	r1, [r7, #8]
 801f82a:	607a      	str	r2, [r7, #4]
    int ret = 0;
 801f82c:	2300      	movs	r3, #0
 801f82e:	62fb      	str	r3, [r7, #44]	@ 0x2c
#else
    byte  check[RNG_HEALTH_TEST_CHECK_SIZE];
#endif

#ifdef WOLFSSL_SMALL_STACK
    check = (byte*)XMALLOC(RNG_HEALTH_TEST_CHECK_SIZE, NULL,
 801f830:	2080      	movs	r0, #128	@ 0x80
 801f832:	f7ff f929 	bl	801ea88 <wolfSSL_Malloc>
 801f836:	62b8      	str	r0, [r7, #40]	@ 0x28
                           DYNAMIC_TYPE_TMP_BUFFER);
    if (check == NULL) {
 801f838:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801f83a:	2b00      	cmp	r3, #0
 801f83c:	d102      	bne.n	801f844 <wc_RNG_HealthTestLocal+0x24>
        return MEMORY_E;
 801f83e:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801f842:	e085      	b.n	801f950 <wc_RNG_HealthTestLocal+0x130>
    }
#endif

    if (reseed) {
 801f844:	68fb      	ldr	r3, [r7, #12]
 801f846:	2b00      	cmp	r3, #0
 801f848:	d029      	beq.n	801f89e <wc_RNG_HealthTestLocal+0x7e>
        else {
            XMEMCPY_P(seedA, seedA_data, sizeof(seedA_data));
            XMEMCPY_P(reseedSeedA, reseedSeedA_data, sizeof(reseedSeedA_data));
            XMEMCPY_P(outputA, outputA_data, sizeof(outputA_data));
#else
        const byte* seedA = seedA_data;
 801f84a:	4b43      	ldr	r3, [pc, #268]	@ (801f958 <wc_RNG_HealthTestLocal+0x138>)
 801f84c:	61fb      	str	r3, [r7, #28]
        const byte* reseedSeedA = reseedSeedA_data;
 801f84e:	4b43      	ldr	r3, [pc, #268]	@ (801f95c <wc_RNG_HealthTestLocal+0x13c>)
 801f850:	61bb      	str	r3, [r7, #24]
        const byte* outputA = outputA_data;
 801f852:	4b43      	ldr	r3, [pc, #268]	@ (801f960 <wc_RNG_HealthTestLocal+0x140>)
 801f854:	617b      	str	r3, [r7, #20]
#endif
        ret = wc_RNG_HealthTest_ex(1, NULL, 0,
 801f856:	687b      	ldr	r3, [r7, #4]
 801f858:	9306      	str	r3, [sp, #24]
 801f85a:	68bb      	ldr	r3, [r7, #8]
 801f85c:	9305      	str	r3, [sp, #20]
 801f85e:	2380      	movs	r3, #128	@ 0x80
 801f860:	9304      	str	r3, [sp, #16]
 801f862:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801f864:	9303      	str	r3, [sp, #12]
 801f866:	2320      	movs	r3, #32
 801f868:	9302      	str	r3, [sp, #8]
 801f86a:	69bb      	ldr	r3, [r7, #24]
 801f86c:	9301      	str	r3, [sp, #4]
 801f86e:	2330      	movs	r3, #48	@ 0x30
 801f870:	9300      	str	r3, [sp, #0]
 801f872:	69fb      	ldr	r3, [r7, #28]
 801f874:	2200      	movs	r2, #0
 801f876:	2100      	movs	r1, #0
 801f878:	2001      	movs	r0, #1
 801f87a:	f7ff ff5c 	bl	801f736 <wc_RNG_HealthTest_ex>
 801f87e:	62f8      	str	r0, [r7, #44]	@ 0x2c
                                   seedA, sizeof(seedA_data),
                                   reseedSeedA, sizeof(reseedSeedA_data),
                                   check, RNG_HEALTH_TEST_CHECK_SIZE,
                                   heap, devId);
        if (ret == 0) {
 801f880:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801f882:	2b00      	cmp	r3, #0
 801f884:	d15b      	bne.n	801f93e <wc_RNG_HealthTestLocal+0x11e>
            if (ConstantCompare(check, outputA,
 801f886:	2280      	movs	r2, #128	@ 0x80
 801f888:	6979      	ldr	r1, [r7, #20]
 801f88a:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801f88c:	f7ff f96f 	bl	801eb6e <ConstantCompare>
 801f890:	4603      	mov	r3, r0
 801f892:	2b00      	cmp	r3, #0
 801f894:	d053      	beq.n	801f93e <wc_RNG_HealthTestLocal+0x11e>
                                RNG_HEALTH_TEST_CHECK_SIZE) != 0)
                ret = -1;
 801f896:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 801f89a:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801f89c:	e04f      	b.n	801f93e <wc_RNG_HealthTestLocal+0x11e>
        }
        else {
            XMEMCPY_P(seedB, seedB_data, sizeof(seedB_data));
            XMEMCPY_P(outputB, outputB_data, sizeof(outputB_data));
#else
        const byte* seedB = seedB_data;
 801f89e:	4b31      	ldr	r3, [pc, #196]	@ (801f964 <wc_RNG_HealthTestLocal+0x144>)
 801f8a0:	627b      	str	r3, [r7, #36]	@ 0x24
        const byte* outputB = outputB_data;
 801f8a2:	4b31      	ldr	r3, [pc, #196]	@ (801f968 <wc_RNG_HealthTestLocal+0x148>)
 801f8a4:	623b      	str	r3, [r7, #32]
        WOLFSSL_MSG_EX("RNG_HEALTH_TEST_CHECK_SIZE = %d",
                        RNG_HEALTH_TEST_CHECK_SIZE);
        WOLFSSL_MSG_EX("sizeof(seedB_data)         = %d",
                        (int)sizeof(outputB_data));
#endif
        ret = wc_RNG_HealthTest_ex(0, NULL, 0,
 801f8a6:	687b      	ldr	r3, [r7, #4]
 801f8a8:	9306      	str	r3, [sp, #24]
 801f8aa:	68bb      	ldr	r3, [r7, #8]
 801f8ac:	9305      	str	r3, [sp, #20]
 801f8ae:	2380      	movs	r3, #128	@ 0x80
 801f8b0:	9304      	str	r3, [sp, #16]
 801f8b2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801f8b4:	9303      	str	r3, [sp, #12]
 801f8b6:	2300      	movs	r3, #0
 801f8b8:	9302      	str	r3, [sp, #8]
 801f8ba:	2300      	movs	r3, #0
 801f8bc:	9301      	str	r3, [sp, #4]
 801f8be:	2330      	movs	r3, #48	@ 0x30
 801f8c0:	9300      	str	r3, [sp, #0]
 801f8c2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801f8c4:	2200      	movs	r2, #0
 801f8c6:	2100      	movs	r1, #0
 801f8c8:	2000      	movs	r0, #0
 801f8ca:	f7ff ff34 	bl	801f736 <wc_RNG_HealthTest_ex>
 801f8ce:	62f8      	str	r0, [r7, #44]	@ 0x2c
                                   seedB, sizeof(seedB_data),
                                   NULL, 0,
                                   check, RNG_HEALTH_TEST_CHECK_SIZE,
                                   heap, devId);
        if (ret != 0) {
 801f8d0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801f8d2:	2b00      	cmp	r3, #0
 801f8d4:	d10b      	bne.n	801f8ee <wc_RNG_HealthTestLocal+0xce>
            #if defined(DEBUG_WOLFSSL)
            WOLFSSL_MSG_EX("RNG_HealthTest failed: err = %d", ret);
            #endif
        }
        else {
            ret = ConstantCompare(check, outputB,
 801f8d6:	2280      	movs	r2, #128	@ 0x80
 801f8d8:	6a39      	ldr	r1, [r7, #32]
 801f8da:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801f8dc:	f7ff f947 	bl	801eb6e <ConstantCompare>
 801f8e0:	62f8      	str	r0, [r7, #44]	@ 0x2c
                                RNG_HEALTH_TEST_CHECK_SIZE);
            if (ret != 0) {
 801f8e2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801f8e4:	2b00      	cmp	r3, #0
 801f8e6:	d002      	beq.n	801f8ee <wc_RNG_HealthTestLocal+0xce>
                #if defined(DEBUG_WOLFSSL)
                WOLFSSL_MSG_EX("Random ConstantCompare failed: err = %d", ret);
                #endif
                ret = -1;
 801f8e8:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 801f8ec:	62fb      	str	r3, [r7, #44]	@ 0x2c

        /* The previous test cases use a large seed instead of a seed and nonce.
         * seedB is actually from a test case with a seed and nonce, and
         * just concatenates them. The pivot point between seed and nonce is
         * byte 32, feed them into the health test separately. */
        if (ret == 0) {
 801f8ee:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801f8f0:	2b00      	cmp	r3, #0
 801f8f2:	d124      	bne.n	801f93e <wc_RNG_HealthTestLocal+0x11e>
            ret = wc_RNG_HealthTest_ex(0,
 801f8f4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801f8f6:	f103 0120 	add.w	r1, r3, #32
 801f8fa:	687b      	ldr	r3, [r7, #4]
 801f8fc:	9306      	str	r3, [sp, #24]
 801f8fe:	68bb      	ldr	r3, [r7, #8]
 801f900:	9305      	str	r3, [sp, #20]
 801f902:	2380      	movs	r3, #128	@ 0x80
 801f904:	9304      	str	r3, [sp, #16]
 801f906:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801f908:	9303      	str	r3, [sp, #12]
 801f90a:	2300      	movs	r3, #0
 801f90c:	9302      	str	r3, [sp, #8]
 801f90e:	2300      	movs	r3, #0
 801f910:	9301      	str	r3, [sp, #4]
 801f912:	2320      	movs	r3, #32
 801f914:	9300      	str	r3, [sp, #0]
 801f916:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801f918:	2210      	movs	r2, #16
 801f91a:	2000      	movs	r0, #0
 801f91c:	f7ff ff0b 	bl	801f736 <wc_RNG_HealthTest_ex>
 801f920:	62f8      	str	r0, [r7, #44]	@ 0x2c
                                       seedB + 32, sizeof(seedB_data) - 32,
                                       seedB, 32,
                                       NULL, 0,
                                       check, RNG_HEALTH_TEST_CHECK_SIZE,
                                       heap, devId);
            if (ret == 0) {
 801f922:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801f924:	2b00      	cmp	r3, #0
 801f926:	d10a      	bne.n	801f93e <wc_RNG_HealthTestLocal+0x11e>
                if (ConstantCompare(check, outputB, sizeof(outputB_data)) != 0)
 801f928:	2280      	movs	r2, #128	@ 0x80
 801f92a:	6a39      	ldr	r1, [r7, #32]
 801f92c:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801f92e:	f7ff f91e 	bl	801eb6e <ConstantCompare>
 801f932:	4603      	mov	r3, r0
 801f934:	2b00      	cmp	r3, #0
 801f936:	d002      	beq.n	801f93e <wc_RNG_HealthTestLocal+0x11e>
                    ret = -1;
 801f938:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 801f93c:	62fb      	str	r3, [r7, #44]	@ 0x2c
        }
#endif
    }

#ifdef WOLFSSL_SMALL_STACK
    XFREE(check, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 801f93e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801f940:	613b      	str	r3, [r7, #16]
 801f942:	693b      	ldr	r3, [r7, #16]
 801f944:	2b00      	cmp	r3, #0
 801f946:	d002      	beq.n	801f94e <wc_RNG_HealthTestLocal+0x12e>
 801f948:	6938      	ldr	r0, [r7, #16]
 801f94a:	f7ff f8b9 	bl	801eac0 <wolfSSL_Free>
#endif

    return ret;
 801f94e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
}
 801f950:	4618      	mov	r0, r3
 801f952:	3730      	adds	r7, #48	@ 0x30
 801f954:	46bd      	mov	sp, r7
 801f956:	bd80      	pop	{r7, pc}
 801f958:	08033b80 	.word	0x08033b80
 801f95c:	08033bb0 	.word	0x08033bb0
 801f960:	08033bd0 	.word	0x08033bd0
 801f964:	08033c50 	.word	0x08033c50
 801f968:	08033c80 	.word	0x08033c80

0801f96c <wc_GenerateSeed>:
     /* Generate a RNG seed using the hardware random number generator
      * on the STM32F2/F4/F7/L4. */

    #ifdef WOLFSSL_STM32_CUBEMX
    int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
    {
 801f96c:	b580      	push	{r7, lr}
 801f96e:	b08c      	sub	sp, #48	@ 0x30
 801f970:	af00      	add	r7, sp, #0
 801f972:	60f8      	str	r0, [r7, #12]
 801f974:	60b9      	str	r1, [r7, #8]
 801f976:	607a      	str	r2, [r7, #4]
        int ret;
        RNG_HandleTypeDef hrng;
        word32 i = 0;
 801f978:	2300      	movs	r3, #0
 801f97a:	62fb      	str	r3, [r7, #44]	@ 0x2c
        (void)os;

        ret = wolfSSL_CryptHwMutexLock();
 801f97c:	f007 fcd6 	bl	802732c <wolfSSL_CryptHwMutexLock>
 801f980:	62b8      	str	r0, [r7, #40]	@ 0x28
        if (ret != 0) {
 801f982:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801f984:	2b00      	cmp	r3, #0
 801f986:	d001      	beq.n	801f98c <wc_GenerateSeed+0x20>
            return ret;
 801f988:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801f98a:	e063      	b.n	801fa54 <wc_GenerateSeed+0xe8>
        }

        /* enable RNG clock source */
        __HAL_RCC_RNG_CLK_ENABLE();
 801f98c:	2300      	movs	r3, #0
 801f98e:	617b      	str	r3, [r7, #20]
 801f990:	4b32      	ldr	r3, [pc, #200]	@ (801fa5c <wc_GenerateSeed+0xf0>)
 801f992:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 801f994:	4a31      	ldr	r2, [pc, #196]	@ (801fa5c <wc_GenerateSeed+0xf0>)
 801f996:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 801f99a:	6353      	str	r3, [r2, #52]	@ 0x34
 801f99c:	4b2f      	ldr	r3, [pc, #188]	@ (801fa5c <wc_GenerateSeed+0xf0>)
 801f99e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 801f9a0:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 801f9a4:	617b      	str	r3, [r7, #20]
 801f9a6:	697b      	ldr	r3, [r7, #20]

        /* enable RNG peripheral */
        XMEMSET(&hrng, 0, sizeof(hrng));
 801f9a8:	f107 0318 	add.w	r3, r7, #24
 801f9ac:	2210      	movs	r2, #16
 801f9ae:	2100      	movs	r1, #0
 801f9b0:	4618      	mov	r0, r3
 801f9b2:	f008 fd89 	bl	80284c8 <memset>
        hrng.Instance = RNG;
 801f9b6:	4b2a      	ldr	r3, [pc, #168]	@ (801fa60 <wc_GenerateSeed+0xf4>)
 801f9b8:	61bb      	str	r3, [r7, #24]
        HAL_RNG_Init(&hrng);
 801f9ba:	f107 0318 	add.w	r3, r7, #24
 801f9be:	4618      	mov	r0, r3
 801f9c0:	f7e5 fb18 	bl	8004ff4 <HAL_RNG_Init>

        while (i < sz) {
 801f9c4:	e03a      	b.n	801fa3c <wc_GenerateSeed+0xd0>
            /* If not aligned or there is odd/remainder */
            if( (i + sizeof(word32)) > sz ||
 801f9c6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801f9c8:	3304      	adds	r3, #4
 801f9ca:	687a      	ldr	r2, [r7, #4]
 801f9cc:	429a      	cmp	r2, r3
 801f9ce:	d306      	bcc.n	801f9de <wc_GenerateSeed+0x72>
                ((wc_ptr_t)&output[i] % sizeof(word32)) != 0
 801f9d0:	68ba      	ldr	r2, [r7, #8]
 801f9d2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801f9d4:	4413      	add	r3, r2
 801f9d6:	f003 0303 	and.w	r3, r3, #3
            if( (i + sizeof(word32)) > sz ||
 801f9da:	2b00      	cmp	r3, #0
 801f9dc:	d01a      	beq.n	801fa14 <wc_GenerateSeed+0xa8>
            ) {
                /* Single byte at a time */
                uint32_t tmpRng = 0;
 801f9de:	2300      	movs	r3, #0
 801f9e0:	613b      	str	r3, [r7, #16]
                if (HAL_RNG_GenerateRandomNumber(&hrng, &tmpRng) != HAL_OK) {
 801f9e2:	f107 0210 	add.w	r2, r7, #16
 801f9e6:	f107 0318 	add.w	r3, r7, #24
 801f9ea:	4611      	mov	r1, r2
 801f9ec:	4618      	mov	r0, r3
 801f9ee:	f7e5 fb55 	bl	800509c <HAL_RNG_GenerateRandomNumber>
 801f9f2:	4603      	mov	r3, r0
 801f9f4:	2b00      	cmp	r3, #0
 801f9f6:	d004      	beq.n	801fa02 <wc_GenerateSeed+0x96>
                    wolfSSL_CryptHwMutexUnLock();
 801f9f8:	f007 fcac 	bl	8027354 <wolfSSL_CryptHwMutexUnLock>
                    return RAN_BLOCK_E;
 801f9fc:	f06f 0368 	mvn.w	r3, #104	@ 0x68
 801fa00:	e028      	b.n	801fa54 <wc_GenerateSeed+0xe8>
                }
                output[i++] = (byte)tmpRng;
 801fa02:	6939      	ldr	r1, [r7, #16]
 801fa04:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801fa06:	1c5a      	adds	r2, r3, #1
 801fa08:	62fa      	str	r2, [r7, #44]	@ 0x2c
 801fa0a:	68ba      	ldr	r2, [r7, #8]
 801fa0c:	4413      	add	r3, r2
 801fa0e:	b2ca      	uxtb	r2, r1
 801fa10:	701a      	strb	r2, [r3, #0]
            ) {
 801fa12:	e013      	b.n	801fa3c <wc_GenerateSeed+0xd0>
            }
            else {
                /* Use native 32 instruction */
                if (HAL_RNG_GenerateRandomNumber(&hrng, (uint32_t*)&output[i]) != HAL_OK) {
 801fa14:	68ba      	ldr	r2, [r7, #8]
 801fa16:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801fa18:	441a      	add	r2, r3
 801fa1a:	f107 0318 	add.w	r3, r7, #24
 801fa1e:	4611      	mov	r1, r2
 801fa20:	4618      	mov	r0, r3
 801fa22:	f7e5 fb3b 	bl	800509c <HAL_RNG_GenerateRandomNumber>
 801fa26:	4603      	mov	r3, r0
 801fa28:	2b00      	cmp	r3, #0
 801fa2a:	d004      	beq.n	801fa36 <wc_GenerateSeed+0xca>
                    wolfSSL_CryptHwMutexUnLock();
 801fa2c:	f007 fc92 	bl	8027354 <wolfSSL_CryptHwMutexUnLock>
                    return RAN_BLOCK_E;
 801fa30:	f06f 0368 	mvn.w	r3, #104	@ 0x68
 801fa34:	e00e      	b.n	801fa54 <wc_GenerateSeed+0xe8>
                }
                i += sizeof(word32);
 801fa36:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801fa38:	3304      	adds	r3, #4
 801fa3a:	62fb      	str	r3, [r7, #44]	@ 0x2c
        while (i < sz) {
 801fa3c:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801fa3e:	687b      	ldr	r3, [r7, #4]
 801fa40:	429a      	cmp	r2, r3
 801fa42:	d3c0      	bcc.n	801f9c6 <wc_GenerateSeed+0x5a>
            }
        }

        HAL_RNG_DeInit(&hrng);
 801fa44:	f107 0318 	add.w	r3, r7, #24
 801fa48:	4618      	mov	r0, r3
 801fa4a:	f7e5 fafd 	bl	8005048 <HAL_RNG_DeInit>

        wolfSSL_CryptHwMutexUnLock();
 801fa4e:	f007 fc81 	bl	8027354 <wolfSSL_CryptHwMutexUnLock>

        return 0;
 801fa52:	2300      	movs	r3, #0
    }
 801fa54:	4618      	mov	r0, r3
 801fa56:	3730      	adds	r7, #48	@ 0x30
 801fa58:	46bd      	mov	sp, r7
 801fa5a:	bd80      	pop	{r7, pc}
 801fa5c:	40023800 	.word	0x40023800
 801fa60:	50060800 	.word	0x50060800

0801fa64 <XorWords>:
{
 801fa64:	b480      	push	{r7}
 801fa66:	b087      	sub	sp, #28
 801fa68:	af00      	add	r7, sp, #0
 801fa6a:	60f8      	str	r0, [r7, #12]
 801fa6c:	60b9      	str	r1, [r7, #8]
 801fa6e:	607a      	str	r2, [r7, #4]
    for (i = 0; i < n; i++)
 801fa70:	2300      	movs	r3, #0
 801fa72:	617b      	str	r3, [r7, #20]
 801fa74:	e010      	b.n	801fa98 <XorWords+0x34>
        *((*r)++) ^= *((*a)++);
 801fa76:	68bb      	ldr	r3, [r7, #8]
 801fa78:	681b      	ldr	r3, [r3, #0]
 801fa7a:	1d19      	adds	r1, r3, #4
 801fa7c:	68ba      	ldr	r2, [r7, #8]
 801fa7e:	6011      	str	r1, [r2, #0]
 801fa80:	6819      	ldr	r1, [r3, #0]
 801fa82:	68fb      	ldr	r3, [r7, #12]
 801fa84:	681b      	ldr	r3, [r3, #0]
 801fa86:	1d18      	adds	r0, r3, #4
 801fa88:	68fa      	ldr	r2, [r7, #12]
 801fa8a:	6010      	str	r0, [r2, #0]
 801fa8c:	681a      	ldr	r2, [r3, #0]
 801fa8e:	404a      	eors	r2, r1
 801fa90:	601a      	str	r2, [r3, #0]
    for (i = 0; i < n; i++)
 801fa92:	697b      	ldr	r3, [r7, #20]
 801fa94:	3301      	adds	r3, #1
 801fa96:	617b      	str	r3, [r7, #20]
 801fa98:	697a      	ldr	r2, [r7, #20]
 801fa9a:	687b      	ldr	r3, [r7, #4]
 801fa9c:	429a      	cmp	r2, r3
 801fa9e:	d3ea      	bcc.n	801fa76 <XorWords+0x12>
}
 801faa0:	bf00      	nop
 801faa2:	bf00      	nop
 801faa4:	371c      	adds	r7, #28
 801faa6:	46bd      	mov	sp, r7
 801faa8:	f85d 7b04 	ldr.w	r7, [sp], #4
 801faac:	4770      	bx	lr

0801faae <xorbuf>:
{
 801faae:	b580      	push	{r7, lr}
 801fab0:	b08a      	sub	sp, #40	@ 0x28
 801fab2:	af00      	add	r7, sp, #0
 801fab4:	60f8      	str	r0, [r7, #12]
 801fab6:	60b9      	str	r1, [r7, #8]
 801fab8:	607a      	str	r2, [r7, #4]
    b = (byte*)buf;
 801faba:	68fb      	ldr	r3, [r7, #12]
 801fabc:	623b      	str	r3, [r7, #32]
    m = (const byte*)mask;
 801fabe:	68bb      	ldr	r3, [r7, #8]
 801fac0:	61fb      	str	r3, [r7, #28]
    if (((wc_ptr_t)b) % WOLFSSL_WORD_SIZE ==
 801fac2:	6a3a      	ldr	r2, [r7, #32]
            ((wc_ptr_t)m) % WOLFSSL_WORD_SIZE) {
 801fac4:	69fb      	ldr	r3, [r7, #28]
    if (((wc_ptr_t)b) % WOLFSSL_WORD_SIZE ==
 801fac6:	4053      	eors	r3, r2
 801fac8:	f003 0303 	and.w	r3, r3, #3
 801facc:	2b00      	cmp	r3, #0
 801face:	d12b      	bne.n	801fb28 <xorbuf+0x7a>
        while (((wc_ptr_t)buf) % WOLFSSL_WORD_SIZE != 0 && count > 0) {
 801fad0:	e00d      	b.n	801faee <xorbuf+0x40>
            *(b++) ^= *(m++);
 801fad2:	69fb      	ldr	r3, [r7, #28]
 801fad4:	1c5a      	adds	r2, r3, #1
 801fad6:	61fa      	str	r2, [r7, #28]
 801fad8:	7819      	ldrb	r1, [r3, #0]
 801fada:	6a3b      	ldr	r3, [r7, #32]
 801fadc:	1c5a      	adds	r2, r3, #1
 801fade:	623a      	str	r2, [r7, #32]
 801fae0:	781a      	ldrb	r2, [r3, #0]
 801fae2:	404a      	eors	r2, r1
 801fae4:	b2d2      	uxtb	r2, r2
 801fae6:	701a      	strb	r2, [r3, #0]
            count--;
 801fae8:	687b      	ldr	r3, [r7, #4]
 801faea:	3b01      	subs	r3, #1
 801faec:	607b      	str	r3, [r7, #4]
        while (((wc_ptr_t)buf) % WOLFSSL_WORD_SIZE != 0 && count > 0) {
 801faee:	68fb      	ldr	r3, [r7, #12]
 801faf0:	f003 0303 	and.w	r3, r3, #3
 801faf4:	2b00      	cmp	r3, #0
 801faf6:	d002      	beq.n	801fafe <xorbuf+0x50>
 801faf8:	687b      	ldr	r3, [r7, #4]
 801fafa:	2b00      	cmp	r3, #0
 801fafc:	d1e9      	bne.n	801fad2 <xorbuf+0x24>
        tpb.bp = b;
 801fafe:	6a3b      	ldr	r3, [r7, #32]
 801fb00:	61bb      	str	r3, [r7, #24]
        tpm.bp = m;
 801fb02:	69fb      	ldr	r3, [r7, #28]
 801fb04:	617b      	str	r3, [r7, #20]
        XorWords( &tpb.wp, &tpm.wp, count / WOLFSSL_WORD_SIZE);
 801fb06:	687b      	ldr	r3, [r7, #4]
 801fb08:	089a      	lsrs	r2, r3, #2
 801fb0a:	f107 0114 	add.w	r1, r7, #20
 801fb0e:	f107 0318 	add.w	r3, r7, #24
 801fb12:	4618      	mov	r0, r3
 801fb14:	f7ff ffa6 	bl	801fa64 <XorWords>
        b = tpb.bp;
 801fb18:	69bb      	ldr	r3, [r7, #24]
 801fb1a:	623b      	str	r3, [r7, #32]
        m = tpm.bp;
 801fb1c:	697b      	ldr	r3, [r7, #20]
 801fb1e:	61fb      	str	r3, [r7, #28]
        count %= WOLFSSL_WORD_SIZE;
 801fb20:	687b      	ldr	r3, [r7, #4]
 801fb22:	f003 0303 	and.w	r3, r3, #3
 801fb26:	607b      	str	r3, [r7, #4]
    for (i = 0; i < count; i++)
 801fb28:	2300      	movs	r3, #0
 801fb2a:	627b      	str	r3, [r7, #36]	@ 0x24
 801fb2c:	e010      	b.n	801fb50 <xorbuf+0xa2>
        b[i] ^= m[i];
 801fb2e:	6a3a      	ldr	r2, [r7, #32]
 801fb30:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801fb32:	4413      	add	r3, r2
 801fb34:	7819      	ldrb	r1, [r3, #0]
 801fb36:	69fa      	ldr	r2, [r7, #28]
 801fb38:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801fb3a:	4413      	add	r3, r2
 801fb3c:	781a      	ldrb	r2, [r3, #0]
 801fb3e:	6a38      	ldr	r0, [r7, #32]
 801fb40:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801fb42:	4403      	add	r3, r0
 801fb44:	404a      	eors	r2, r1
 801fb46:	b2d2      	uxtb	r2, r2
 801fb48:	701a      	strb	r2, [r3, #0]
    for (i = 0; i < count; i++)
 801fb4a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801fb4c:	3301      	adds	r3, #1
 801fb4e:	627b      	str	r3, [r7, #36]	@ 0x24
 801fb50:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801fb52:	687b      	ldr	r3, [r7, #4]
 801fb54:	429a      	cmp	r2, r3
 801fb56:	d3ea      	bcc.n	801fb2e <xorbuf+0x80>
}
 801fb58:	bf00      	nop
 801fb5a:	bf00      	nop
 801fb5c:	3728      	adds	r7, #40	@ 0x28
 801fb5e:	46bd      	mov	sp, r7
 801fb60:	bd80      	pop	{r7, pc}

0801fb62 <ForceZero>:
{
 801fb62:	b480      	push	{r7}
 801fb64:	b085      	sub	sp, #20
 801fb66:	af00      	add	r7, sp, #0
 801fb68:	6078      	str	r0, [r7, #4]
 801fb6a:	6039      	str	r1, [r7, #0]
    volatile byte* z = (volatile byte*)mem;
 801fb6c:	687b      	ldr	r3, [r7, #4]
 801fb6e:	60fb      	str	r3, [r7, #12]
    while (len--) *z++ = 0;
 801fb70:	e004      	b.n	801fb7c <ForceZero+0x1a>
 801fb72:	68fb      	ldr	r3, [r7, #12]
 801fb74:	1c5a      	adds	r2, r3, #1
 801fb76:	60fa      	str	r2, [r7, #12]
 801fb78:	2200      	movs	r2, #0
 801fb7a:	701a      	strb	r2, [r3, #0]
 801fb7c:	683b      	ldr	r3, [r7, #0]
 801fb7e:	1e5a      	subs	r2, r3, #1
 801fb80:	603a      	str	r2, [r7, #0]
 801fb82:	2b00      	cmp	r3, #0
 801fb84:	d1f5      	bne.n	801fb72 <ForceZero+0x10>
}
 801fb86:	bf00      	nop
 801fb88:	bf00      	nop
 801fb8a:	3714      	adds	r7, #20
 801fb8c:	46bd      	mov	sp, r7
 801fb8e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fb92:	4770      	bx	lr

0801fb94 <ConstantCompare>:
{
 801fb94:	b480      	push	{r7}
 801fb96:	b087      	sub	sp, #28
 801fb98:	af00      	add	r7, sp, #0
 801fb9a:	60f8      	str	r0, [r7, #12]
 801fb9c:	60b9      	str	r1, [r7, #8]
 801fb9e:	607a      	str	r2, [r7, #4]
    int compareSum = 0;
 801fba0:	2300      	movs	r3, #0
 801fba2:	613b      	str	r3, [r7, #16]
    for (i = 0; i < length; i++) {
 801fba4:	2300      	movs	r3, #0
 801fba6:	617b      	str	r3, [r7, #20]
 801fba8:	e010      	b.n	801fbcc <ConstantCompare+0x38>
        compareSum |= a[i] ^ b[i];
 801fbaa:	697b      	ldr	r3, [r7, #20]
 801fbac:	68fa      	ldr	r2, [r7, #12]
 801fbae:	4413      	add	r3, r2
 801fbb0:	781a      	ldrb	r2, [r3, #0]
 801fbb2:	697b      	ldr	r3, [r7, #20]
 801fbb4:	68b9      	ldr	r1, [r7, #8]
 801fbb6:	440b      	add	r3, r1
 801fbb8:	781b      	ldrb	r3, [r3, #0]
 801fbba:	4053      	eors	r3, r2
 801fbbc:	b2db      	uxtb	r3, r3
 801fbbe:	461a      	mov	r2, r3
 801fbc0:	693b      	ldr	r3, [r7, #16]
 801fbc2:	4313      	orrs	r3, r2
 801fbc4:	613b      	str	r3, [r7, #16]
    for (i = 0; i < length; i++) {
 801fbc6:	697b      	ldr	r3, [r7, #20]
 801fbc8:	3301      	adds	r3, #1
 801fbca:	617b      	str	r3, [r7, #20]
 801fbcc:	697a      	ldr	r2, [r7, #20]
 801fbce:	687b      	ldr	r3, [r7, #4]
 801fbd0:	429a      	cmp	r2, r3
 801fbd2:	dbea      	blt.n	801fbaa <ConstantCompare+0x16>
    return compareSum;
 801fbd4:	693b      	ldr	r3, [r7, #16]
}
 801fbd6:	4618      	mov	r0, r3
 801fbd8:	371c      	adds	r7, #28
 801fbda:	46bd      	mov	sp, r7
 801fbdc:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fbe0:	4770      	bx	lr

0801fbe2 <ctMaskGT>:
{
 801fbe2:	b480      	push	{r7}
 801fbe4:	b083      	sub	sp, #12
 801fbe6:	af00      	add	r7, sp, #0
 801fbe8:	6078      	str	r0, [r7, #4]
 801fbea:	6039      	str	r1, [r7, #0]
    return (byte)((((word32)a - (word32)b - 1) >> 31) - 1);
 801fbec:	687a      	ldr	r2, [r7, #4]
 801fbee:	683b      	ldr	r3, [r7, #0]
 801fbf0:	1ad3      	subs	r3, r2, r3
 801fbf2:	3b01      	subs	r3, #1
 801fbf4:	0fdb      	lsrs	r3, r3, #31
 801fbf6:	b2db      	uxtb	r3, r3
 801fbf8:	3b01      	subs	r3, #1
 801fbfa:	b2db      	uxtb	r3, r3
}
 801fbfc:	4618      	mov	r0, r3
 801fbfe:	370c      	adds	r7, #12
 801fc00:	46bd      	mov	sp, r7
 801fc02:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fc06:	4770      	bx	lr

0801fc08 <ctMaskGTE>:
{
 801fc08:	b480      	push	{r7}
 801fc0a:	b083      	sub	sp, #12
 801fc0c:	af00      	add	r7, sp, #0
 801fc0e:	6078      	str	r0, [r7, #4]
 801fc10:	6039      	str	r1, [r7, #0]
    return (byte)((((word32)a - (word32)b) >> 31) - 1);
 801fc12:	687a      	ldr	r2, [r7, #4]
 801fc14:	683b      	ldr	r3, [r7, #0]
 801fc16:	1ad3      	subs	r3, r2, r3
 801fc18:	0fdb      	lsrs	r3, r3, #31
 801fc1a:	b2db      	uxtb	r3, r3
 801fc1c:	3b01      	subs	r3, #1
 801fc1e:	b2db      	uxtb	r3, r3
}
 801fc20:	4618      	mov	r0, r3
 801fc22:	370c      	adds	r7, #12
 801fc24:	46bd      	mov	sp, r7
 801fc26:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fc2a:	4770      	bx	lr

0801fc2c <ctMaskLT>:
{
 801fc2c:	b480      	push	{r7}
 801fc2e:	b083      	sub	sp, #12
 801fc30:	af00      	add	r7, sp, #0
 801fc32:	6078      	str	r0, [r7, #4]
 801fc34:	6039      	str	r1, [r7, #0]
    return (byte)((((word32)b - (word32)a - 1) >> 31) - 1);
 801fc36:	683a      	ldr	r2, [r7, #0]
 801fc38:	687b      	ldr	r3, [r7, #4]
 801fc3a:	1ad3      	subs	r3, r2, r3
 801fc3c:	3b01      	subs	r3, #1
 801fc3e:	0fdb      	lsrs	r3, r3, #31
 801fc40:	b2db      	uxtb	r3, r3
 801fc42:	3b01      	subs	r3, #1
 801fc44:	b2db      	uxtb	r3, r3
}
 801fc46:	4618      	mov	r0, r3
 801fc48:	370c      	adds	r7, #12
 801fc4a:	46bd      	mov	sp, r7
 801fc4c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fc50:	4770      	bx	lr

0801fc52 <ctMaskLTE>:
{
 801fc52:	b480      	push	{r7}
 801fc54:	b083      	sub	sp, #12
 801fc56:	af00      	add	r7, sp, #0
 801fc58:	6078      	str	r0, [r7, #4]
 801fc5a:	6039      	str	r1, [r7, #0]
    return (byte)((((word32)b - (word32)a) >> 31) - 1);
 801fc5c:	683a      	ldr	r2, [r7, #0]
 801fc5e:	687b      	ldr	r3, [r7, #4]
 801fc60:	1ad3      	subs	r3, r2, r3
 801fc62:	0fdb      	lsrs	r3, r3, #31
 801fc64:	b2db      	uxtb	r3, r3
 801fc66:	3b01      	subs	r3, #1
 801fc68:	b2db      	uxtb	r3, r3
}
 801fc6a:	4618      	mov	r0, r3
 801fc6c:	370c      	adds	r7, #12
 801fc6e:	46bd      	mov	sp, r7
 801fc70:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fc74:	4770      	bx	lr

0801fc76 <ctMaskEq>:
{
 801fc76:	b590      	push	{r4, r7, lr}
 801fc78:	b083      	sub	sp, #12
 801fc7a:	af00      	add	r7, sp, #0
 801fc7c:	6078      	str	r0, [r7, #4]
 801fc7e:	6039      	str	r1, [r7, #0]
    return (byte)((byte)(~ctMaskGT(a, b)) & (byte)(~ctMaskLT(a, b)));
 801fc80:	6839      	ldr	r1, [r7, #0]
 801fc82:	6878      	ldr	r0, [r7, #4]
 801fc84:	f7ff ffad 	bl	801fbe2 <ctMaskGT>
 801fc88:	4603      	mov	r3, r0
 801fc8a:	461c      	mov	r4, r3
 801fc8c:	6839      	ldr	r1, [r7, #0]
 801fc8e:	6878      	ldr	r0, [r7, #4]
 801fc90:	f7ff ffcc 	bl	801fc2c <ctMaskLT>
 801fc94:	4603      	mov	r3, r0
 801fc96:	4323      	orrs	r3, r4
 801fc98:	b2db      	uxtb	r3, r3
 801fc9a:	43db      	mvns	r3, r3
 801fc9c:	b2db      	uxtb	r3, r3
}
 801fc9e:	4618      	mov	r0, r3
 801fca0:	370c      	adds	r7, #12
 801fca2:	46bd      	mov	sp, r7
 801fca4:	bd90      	pop	{r4, r7, pc}

0801fca6 <ctMask16GT>:
{
 801fca6:	b480      	push	{r7}
 801fca8:	b083      	sub	sp, #12
 801fcaa:	af00      	add	r7, sp, #0
 801fcac:	6078      	str	r0, [r7, #4]
 801fcae:	6039      	str	r1, [r7, #0]
    return (word16)((((word32)a - (word32)b - 1) >> 31) - 1);
 801fcb0:	687a      	ldr	r2, [r7, #4]
 801fcb2:	683b      	ldr	r3, [r7, #0]
 801fcb4:	1ad3      	subs	r3, r2, r3
 801fcb6:	3b01      	subs	r3, #1
 801fcb8:	0fdb      	lsrs	r3, r3, #31
 801fcba:	b29b      	uxth	r3, r3
 801fcbc:	3b01      	subs	r3, #1
 801fcbe:	b29b      	uxth	r3, r3
}
 801fcc0:	4618      	mov	r0, r3
 801fcc2:	370c      	adds	r7, #12
 801fcc4:	46bd      	mov	sp, r7
 801fcc6:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fcca:	4770      	bx	lr

0801fccc <ctMask16LT>:
{
 801fccc:	b480      	push	{r7}
 801fcce:	b083      	sub	sp, #12
 801fcd0:	af00      	add	r7, sp, #0
 801fcd2:	6078      	str	r0, [r7, #4]
 801fcd4:	6039      	str	r1, [r7, #0]
    return (word16)((((word32)b - (word32)a - 1) >> 31) - 1);
 801fcd6:	683a      	ldr	r2, [r7, #0]
 801fcd8:	687b      	ldr	r3, [r7, #4]
 801fcda:	1ad3      	subs	r3, r2, r3
 801fcdc:	3b01      	subs	r3, #1
 801fcde:	0fdb      	lsrs	r3, r3, #31
 801fce0:	b29b      	uxth	r3, r3
 801fce2:	3b01      	subs	r3, #1
 801fce4:	b29b      	uxth	r3, r3
}
 801fce6:	4618      	mov	r0, r3
 801fce8:	370c      	adds	r7, #12
 801fcea:	46bd      	mov	sp, r7
 801fcec:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fcf0:	4770      	bx	lr

0801fcf2 <ctMask16Eq>:
{
 801fcf2:	b590      	push	{r4, r7, lr}
 801fcf4:	b083      	sub	sp, #12
 801fcf6:	af00      	add	r7, sp, #0
 801fcf8:	6078      	str	r0, [r7, #4]
 801fcfa:	6039      	str	r1, [r7, #0]
    return (word16)((word16)(~ctMask16GT(a, b)) & (word16)(~ctMask16LT(a, b)));
 801fcfc:	6839      	ldr	r1, [r7, #0]
 801fcfe:	6878      	ldr	r0, [r7, #4]
 801fd00:	f7ff ffd1 	bl	801fca6 <ctMask16GT>
 801fd04:	4603      	mov	r3, r0
 801fd06:	461c      	mov	r4, r3
 801fd08:	6839      	ldr	r1, [r7, #0]
 801fd0a:	6878      	ldr	r0, [r7, #4]
 801fd0c:	f7ff ffde 	bl	801fccc <ctMask16LT>
 801fd10:	4603      	mov	r3, r0
 801fd12:	4323      	orrs	r3, r4
 801fd14:	b29b      	uxth	r3, r3
 801fd16:	43db      	mvns	r3, r3
 801fd18:	b29b      	uxth	r3, r3
}
 801fd1a:	4618      	mov	r0, r3
 801fd1c:	370c      	adds	r7, #12
 801fd1e:	46bd      	mov	sp, r7
 801fd20:	bd90      	pop	{r4, r7, pc}

0801fd22 <ctMaskNotEq>:
{
 801fd22:	b590      	push	{r4, r7, lr}
 801fd24:	b083      	sub	sp, #12
 801fd26:	af00      	add	r7, sp, #0
 801fd28:	6078      	str	r0, [r7, #4]
 801fd2a:	6039      	str	r1, [r7, #0]
    return (byte)((byte)ctMaskGT(a, b) | (byte)ctMaskLT(a, b));
 801fd2c:	6839      	ldr	r1, [r7, #0]
 801fd2e:	6878      	ldr	r0, [r7, #4]
 801fd30:	f7ff ff57 	bl	801fbe2 <ctMaskGT>
 801fd34:	4603      	mov	r3, r0
 801fd36:	461c      	mov	r4, r3
 801fd38:	6839      	ldr	r1, [r7, #0]
 801fd3a:	6878      	ldr	r0, [r7, #4]
 801fd3c:	f7ff ff76 	bl	801fc2c <ctMaskLT>
 801fd40:	4603      	mov	r3, r0
 801fd42:	4323      	orrs	r3, r4
 801fd44:	b2db      	uxtb	r3, r3
}
 801fd46:	4618      	mov	r0, r3
 801fd48:	370c      	adds	r7, #12
 801fd4a:	46bd      	mov	sp, r7
 801fd4c:	bd90      	pop	{r4, r7, pc}

0801fd4e <ctMaskSelInt>:
{
 801fd4e:	b480      	push	{r7}
 801fd50:	b085      	sub	sp, #20
 801fd52:	af00      	add	r7, sp, #0
 801fd54:	4603      	mov	r3, r0
 801fd56:	60b9      	str	r1, [r7, #8]
 801fd58:	607a      	str	r2, [r7, #4]
 801fd5a:	73fb      	strb	r3, [r7, #15]
    return (b & (~(signed int)(signed char)m)) |
 801fd5c:	f997 300f 	ldrsb.w	r3, [r7, #15]
 801fd60:	43da      	mvns	r2, r3
 801fd62:	687b      	ldr	r3, [r7, #4]
 801fd64:	401a      	ands	r2, r3
           (a & ( (signed int)(signed char)m));
 801fd66:	f997 300f 	ldrsb.w	r3, [r7, #15]
 801fd6a:	4619      	mov	r1, r3
 801fd6c:	68bb      	ldr	r3, [r7, #8]
 801fd6e:	400b      	ands	r3, r1
    return (b & (~(signed int)(signed char)m)) |
 801fd70:	4313      	orrs	r3, r2
}
 801fd72:	4618      	mov	r0, r3
 801fd74:	3714      	adds	r7, #20
 801fd76:	46bd      	mov	sp, r7
 801fd78:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fd7c:	4770      	bx	lr

0801fd7e <ctMaskSelWord32>:
{
 801fd7e:	b480      	push	{r7}
 801fd80:	b085      	sub	sp, #20
 801fd82:	af00      	add	r7, sp, #0
 801fd84:	4603      	mov	r3, r0
 801fd86:	60b9      	str	r1, [r7, #8]
 801fd88:	607a      	str	r2, [r7, #4]
 801fd8a:	73fb      	strb	r3, [r7, #15]
    return (((word32)b & (word32)(~(signed int)(signed char)m)) |
 801fd8c:	f997 300f 	ldrsb.w	r3, [r7, #15]
 801fd90:	43db      	mvns	r3, r3
 801fd92:	461a      	mov	r2, r3
 801fd94:	687b      	ldr	r3, [r7, #4]
 801fd96:	401a      	ands	r2, r3
            ((word32)a & (word32)( (signed int)(signed char)m)));
 801fd98:	f997 300f 	ldrsb.w	r3, [r7, #15]
 801fd9c:	4619      	mov	r1, r3
 801fd9e:	68bb      	ldr	r3, [r7, #8]
 801fda0:	400b      	ands	r3, r1
    return (((word32)b & (word32)(~(signed int)(signed char)m)) |
 801fda2:	4313      	orrs	r3, r2
}
 801fda4:	4618      	mov	r0, r3
 801fda6:	3714      	adds	r7, #20
 801fda8:	46bd      	mov	sp, r7
 801fdaa:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fdae:	4770      	bx	lr

0801fdb0 <wc_RsaCleanup>:
    RSA_STATE_DECRYPT_UNPAD,
    RSA_STATE_DECRYPT_RES
};

static void wc_RsaCleanup(RsaKey* key)
{
 801fdb0:	b580      	push	{r7, lr}
 801fdb2:	b084      	sub	sp, #16
 801fdb4:	af00      	add	r7, sp, #0
 801fdb6:	6078      	str	r0, [r7, #4]
#if !defined(WOLFSSL_NO_MALLOC) && (defined(WOLFSSL_ASYNC_CRYPT) || \
    (!defined(WOLFSSL_RSA_VERIFY_ONLY) && !defined(WOLFSSL_RSA_VERIFY_INLINE)))
    if (key != NULL) {
 801fdb8:	687b      	ldr	r3, [r7, #4]
 801fdba:	2b00      	cmp	r3, #0
 801fdbc:	d050      	beq.n	801fe60 <wc_RsaCleanup+0xb0>
    #ifndef WOLFSSL_RSA_PUBLIC_ONLY
        /* if private operation zero temp buffer */
        if ((key->data != NULL && key->dataLen > 0) &&
 801fdbe:	687b      	ldr	r3, [r7, #4]
 801fdc0:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801fdc4:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
 801fdc8:	2b00      	cmp	r3, #0
 801fdca:	d022      	beq.n	801fe12 <wc_RsaCleanup+0x62>
 801fdcc:	687b      	ldr	r3, [r7, #4]
 801fdce:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801fdd2:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
 801fdd6:	2b00      	cmp	r3, #0
 801fdd8:	d01b      	beq.n	801fe12 <wc_RsaCleanup+0x62>
            (key->type == RSA_PRIVATE_DECRYPT ||
 801fdda:	687b      	ldr	r3, [r7, #4]
 801fddc:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801fde0:	f8d3 3168 	ldr.w	r3, [r3, #360]	@ 0x168
        if ((key->data != NULL && key->dataLen > 0) &&
 801fde4:	2b03      	cmp	r3, #3
 801fde6:	d006      	beq.n	801fdf6 <wc_RsaCleanup+0x46>
             key->type == RSA_PRIVATE_ENCRYPT)) {
 801fde8:	687b      	ldr	r3, [r7, #4]
 801fdea:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801fdee:	f8d3 3168 	ldr.w	r3, [r3, #360]	@ 0x168
            (key->type == RSA_PRIVATE_DECRYPT ||
 801fdf2:	2b02      	cmp	r3, #2
 801fdf4:	d10d      	bne.n	801fe12 <wc_RsaCleanup+0x62>
            ForceZero(key->data, key->dataLen);
 801fdf6:	687b      	ldr	r3, [r7, #4]
 801fdf8:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801fdfc:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
 801fe00:	687b      	ldr	r3, [r7, #4]
 801fe02:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801fe06:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
 801fe0a:	4619      	mov	r1, r3
 801fe0c:	4610      	mov	r0, r2
 801fe0e:	f7ff fea8 	bl	801fb62 <ForceZero>
        }
    #endif
        /* make sure any allocated memory is free'd */
        if (key->dataIsAlloc) {
 801fe12:	687b      	ldr	r3, [r7, #4]
 801fe14:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801fe18:	f893 3178 	ldrb.w	r3, [r3, #376]	@ 0x178
 801fe1c:	2b00      	cmp	r3, #0
 801fe1e:	d011      	beq.n	801fe44 <wc_RsaCleanup+0x94>
            XFREE(key->data, key->heap, DYNAMIC_TYPE_WOLF_BIGINT);
 801fe20:	687b      	ldr	r3, [r7, #4]
 801fe22:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801fe26:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
 801fe2a:	60fb      	str	r3, [r7, #12]
 801fe2c:	68fb      	ldr	r3, [r7, #12]
 801fe2e:	2b00      	cmp	r3, #0
 801fe30:	d002      	beq.n	801fe38 <wc_RsaCleanup+0x88>
 801fe32:	68f8      	ldr	r0, [r7, #12]
 801fe34:	f7fe fe44 	bl	801eac0 <wolfSSL_Free>
            key->dataIsAlloc = 0;
 801fe38:	687b      	ldr	r3, [r7, #4]
 801fe3a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801fe3e:	2200      	movs	r2, #0
 801fe40:	f883 2178 	strb.w	r2, [r3, #376]	@ 0x178
        }

        key->data = NULL;
 801fe44:	687b      	ldr	r3, [r7, #4]
 801fe46:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801fe4a:	461a      	mov	r2, r3
 801fe4c:	2300      	movs	r3, #0
 801fe4e:	f8c2 3164 	str.w	r3, [r2, #356]	@ 0x164
        key->dataLen = 0;
 801fe52:	687b      	ldr	r3, [r7, #4]
 801fe54:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801fe58:	461a      	mov	r2, r3
 801fe5a:	2300      	movs	r3, #0
 801fe5c:	f8c2 3170 	str.w	r3, [r2, #368]	@ 0x170
    }
#else
    (void)key;
#endif
}
 801fe60:	bf00      	nop
 801fe62:	3710      	adds	r7, #16
 801fe64:	46bd      	mov	sp, r7
 801fe66:	bd80      	pop	{r7, pc}

0801fe68 <wc_InitRsaKey_ex>:
    return 0;
}
#endif /* !WC_NO_CONSTRUCTORS */

int wc_InitRsaKey_ex(RsaKey* key, void* heap, int devId)
{
 801fe68:	b5b0      	push	{r4, r5, r7, lr}
 801fe6a:	b088      	sub	sp, #32
 801fe6c:	af02      	add	r7, sp, #8
 801fe6e:	60f8      	str	r0, [r7, #12]
 801fe70:	60b9      	str	r1, [r7, #8]
 801fe72:	607a      	str	r2, [r7, #4]
    int ret = 0;
 801fe74:	2300      	movs	r3, #0
 801fe76:	617b      	str	r3, [r7, #20]

    if (key == NULL) {
 801fe78:	68fb      	ldr	r3, [r7, #12]
 801fe7a:	2b00      	cmp	r3, #0
 801fe7c:	d102      	bne.n	801fe84 <wc_InitRsaKey_ex+0x1c>
        return BAD_FUNC_ARG;
 801fe7e:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801fe82:	e071      	b.n	801ff68 <wc_InitRsaKey_ex+0x100>
    }

    XMEMSET(key, 0, sizeof(RsaKey));
 801fe84:	f241 127c 	movw	r2, #4476	@ 0x117c
 801fe88:	2100      	movs	r1, #0
 801fe8a:	68f8      	ldr	r0, [r7, #12]
 801fe8c:	f008 fb1c 	bl	80284c8 <memset>

    key->type = RSA_TYPE_UNKNOWN;
 801fe90:	68fb      	ldr	r3, [r7, #12]
 801fe92:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801fe96:	461a      	mov	r2, r3
 801fe98:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 801fe9c:	f8c2 3168 	str.w	r3, [r2, #360]	@ 0x168
    key->state = RSA_STATE_NONE;
 801fea0:	68fb      	ldr	r3, [r7, #12]
 801fea2:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801fea6:	461a      	mov	r2, r3
 801fea8:	2300      	movs	r3, #0
 801feaa:	f8c2 316c 	str.w	r3, [r2, #364]	@ 0x16c
    key->heap = heap;
 801feae:	68fb      	ldr	r3, [r7, #12]
 801feb0:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801feb4:	461a      	mov	r2, r3
 801feb6:	68bb      	ldr	r3, [r7, #8]
 801feb8:	f8c2 3160 	str.w	r3, [r2, #352]	@ 0x160
#if !defined(WOLFSSL_NO_MALLOC) && (defined(WOLFSSL_ASYNC_CRYPT) || \
    (!defined(WOLFSSL_RSA_VERIFY_ONLY) && !defined(WOLFSSL_RSA_VERIFY_INLINE)))
    key->dataIsAlloc = 0;
 801febc:	68fb      	ldr	r3, [r7, #12]
 801febe:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801fec2:	2200      	movs	r2, #0
 801fec4:	f883 2178 	strb.w	r2, [r3, #376]	@ 0x178
#endif
    key->data = NULL;
 801fec8:	68fb      	ldr	r3, [r7, #12]
 801feca:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801fece:	461a      	mov	r2, r3
 801fed0:	2300      	movs	r3, #0
 801fed2:	f8c2 3164 	str.w	r3, [r2, #356]	@ 0x164
    key->dataLen = 0;
 801fed6:	68fb      	ldr	r3, [r7, #12]
 801fed8:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801fedc:	461a      	mov	r2, r3
 801fede:	2300      	movs	r3, #0
 801fee0:	f8c2 3170 	str.w	r3, [r2, #368]	@ 0x170
#ifdef WC_RSA_BLINDING
    key->rng = NULL;
 801fee4:	68fb      	ldr	r3, [r7, #12]
 801fee6:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801feea:	461a      	mov	r2, r3
 801feec:	2300      	movs	r3, #0
 801feee:	f8c2 3174 	str.w	r3, [r2, #372]	@ 0x174
        }
    #endif /* WC_ASYNC_ENABLE_RSA */
#endif /* WOLFSSL_ASYNC_CRYPT */

#ifndef WOLFSSL_RSA_PUBLIC_ONLY
    ret = mp_init_multi(&key->n, &key->e, NULL, NULL, NULL, NULL);
 801fef2:	68f8      	ldr	r0, [r7, #12]
 801fef4:	68fb      	ldr	r3, [r7, #12]
 801fef6:	f503 710b 	add.w	r1, r3, #556	@ 0x22c
 801fefa:	2300      	movs	r3, #0
 801fefc:	9301      	str	r3, [sp, #4]
 801fefe:	2300      	movs	r3, #0
 801ff00:	9300      	str	r3, [sp, #0]
 801ff02:	2300      	movs	r3, #0
 801ff04:	2200      	movs	r2, #0
 801ff06:	f006 fc68 	bl	80267da <mp_init_multi>
 801ff0a:	6178      	str	r0, [r7, #20]
    if (ret != MP_OKAY)
 801ff0c:	697b      	ldr	r3, [r7, #20]
 801ff0e:	2b00      	cmp	r3, #0
 801ff10:	d001      	beq.n	801ff16 <wc_InitRsaKey_ex+0xae>
        return ret;
 801ff12:	697b      	ldr	r3, [r7, #20]
 801ff14:	e028      	b.n	801ff68 <wc_InitRsaKey_ex+0x100>

#if !defined(WOLFSSL_KEY_GEN) && !defined(OPENSSL_EXTRA) && defined(RSA_LOW_MEM)
    ret = mp_init_multi(&key->d, &key->p, &key->q, NULL, NULL, NULL);
#else
    ret = mp_init_multi(&key->d, &key->p, &key->q, &key->dP, &key->dQ, &key->u);
 801ff16:	68fb      	ldr	r3, [r7, #12]
 801ff18:	f503 608b 	add.w	r0, r3, #1112	@ 0x458
 801ff1c:	68fb      	ldr	r3, [r7, #12]
 801ff1e:	f203 6184 	addw	r1, r3, #1668	@ 0x684
 801ff22:	68fb      	ldr	r3, [r7, #12]
 801ff24:	f503 640b 	add.w	r4, r3, #2224	@ 0x8b0
 801ff28:	68fb      	ldr	r3, [r7, #12]
 801ff2a:	f603 25dc 	addw	r5, r3, #2780	@ 0xadc
 801ff2e:	68fb      	ldr	r3, [r7, #12]
 801ff30:	f603 5308 	addw	r3, r3, #3336	@ 0xd08
 801ff34:	68fa      	ldr	r2, [r7, #12]
 801ff36:	f602 7234 	addw	r2, r2, #3892	@ 0xf34
 801ff3a:	9201      	str	r2, [sp, #4]
 801ff3c:	9300      	str	r3, [sp, #0]
 801ff3e:	462b      	mov	r3, r5
 801ff40:	4622      	mov	r2, r4
 801ff42:	f006 fc4a 	bl	80267da <mp_init_multi>
 801ff46:	6178      	str	r0, [r7, #20]
#endif
    if (ret != MP_OKAY) {
 801ff48:	697b      	ldr	r3, [r7, #20]
 801ff4a:	2b00      	cmp	r3, #0
 801ff4c:	d00b      	beq.n	801ff66 <wc_InitRsaKey_ex+0xfe>
        mp_clear(&key->n);
 801ff4e:	68fb      	ldr	r3, [r7, #12]
 801ff50:	4618      	mov	r0, r3
 801ff52:	f006 fc28 	bl	80267a6 <mp_clear>
        mp_clear(&key->e);
 801ff56:	68fb      	ldr	r3, [r7, #12]
 801ff58:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 801ff5c:	4618      	mov	r0, r3
 801ff5e:	f006 fc22 	bl	80267a6 <mp_clear>
        return ret;
 801ff62:	697b      	ldr	r3, [r7, #20]
 801ff64:	e000      	b.n	801ff68 <wc_InitRsaKey_ex+0x100>
    key->ctx.wrapped_pri2048_key = NULL;
    key->ctx.wrapped_pub2048_key = NULL;
    key->ctx.keySz = 0;
#endif

    return ret;
 801ff66:	697b      	ldr	r3, [r7, #20]
}
 801ff68:	4618      	mov	r0, r3
 801ff6a:	3718      	adds	r7, #24
 801ff6c:	46bd      	mov	sp, r7
 801ff6e:	bdb0      	pop	{r4, r5, r7, pc}

0801ff70 <wc_InitRsaKey>:

int wc_InitRsaKey(RsaKey* key, void* heap)
{
 801ff70:	b580      	push	{r7, lr}
 801ff72:	b082      	sub	sp, #8
 801ff74:	af00      	add	r7, sp, #0
 801ff76:	6078      	str	r0, [r7, #4]
 801ff78:	6039      	str	r1, [r7, #0]
    return wc_InitRsaKey_ex(key, heap, INVALID_DEVID);
 801ff7a:	f06f 0201 	mvn.w	r2, #1
 801ff7e:	6839      	ldr	r1, [r7, #0]
 801ff80:	6878      	ldr	r0, [r7, #4]
 801ff82:	f7ff ff71 	bl	801fe68 <wc_InitRsaKey_ex>
 801ff86:	4603      	mov	r3, r0
}
 801ff88:	4618      	mov	r0, r3
 801ff8a:	3708      	adds	r7, #8
 801ff8c:	46bd      	mov	sp, r7
 801ff8e:	bd80      	pop	{r7, pc}

0801ff90 <wc_FreeRsaKey>:
    return se050_rsa_get_key_id(key, keyId);
}
#endif /* WOLFSSL_SE050 */

int wc_FreeRsaKey(RsaKey* key)
{
 801ff90:	b580      	push	{r7, lr}
 801ff92:	b084      	sub	sp, #16
 801ff94:	af00      	add	r7, sp, #0
 801ff96:	6078      	str	r0, [r7, #4]
    int ret = 0;
 801ff98:	2300      	movs	r3, #0
 801ff9a:	60fb      	str	r3, [r7, #12]

    if (key == NULL) {
 801ff9c:	687b      	ldr	r3, [r7, #4]
 801ff9e:	2b00      	cmp	r3, #0
 801ffa0:	d102      	bne.n	801ffa8 <wc_FreeRsaKey+0x18>
        return BAD_FUNC_ARG;
 801ffa2:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801ffa6:	e05d      	b.n	8020064 <wc_FreeRsaKey+0xd4>
    }

    wc_RsaCleanup(key);
 801ffa8:	6878      	ldr	r0, [r7, #4]
 801ffaa:	f7ff ff01 	bl	801fdb0 <wc_RsaCleanup>
#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_RSA)
    wolfAsync_DevCtxFree(&key->asyncDev, WOLFSSL_ASYNC_MARKER_RSA);
#endif

#ifndef WOLFSSL_RSA_PUBLIC_ONLY
    if (key->type == RSA_PRIVATE) {
 801ffae:	687b      	ldr	r3, [r7, #4]
 801ffb0:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801ffb4:	f8d3 3168 	ldr.w	r3, [r3, #360]	@ 0x168
 801ffb8:	2b01      	cmp	r3, #1
 801ffba:	d124      	bne.n	8020006 <wc_FreeRsaKey+0x76>
#if defined(WOLFSSL_KEY_GEN) || defined(OPENSSL_EXTRA) || !defined(RSA_LOW_MEM)
        mp_forcezero(&key->u);
 801ffbc:	687b      	ldr	r3, [r7, #4]
 801ffbe:	f603 7334 	addw	r3, r3, #3892	@ 0xf34
 801ffc2:	4618      	mov	r0, r3
 801ffc4:	f006 fbda 	bl	802677c <mp_forcezero>
        mp_forcezero(&key->dQ);
 801ffc8:	687b      	ldr	r3, [r7, #4]
 801ffca:	f603 5308 	addw	r3, r3, #3336	@ 0xd08
 801ffce:	4618      	mov	r0, r3
 801ffd0:	f006 fbd4 	bl	802677c <mp_forcezero>
        mp_forcezero(&key->dP);
 801ffd4:	687b      	ldr	r3, [r7, #4]
 801ffd6:	f603 23dc 	addw	r3, r3, #2780	@ 0xadc
 801ffda:	4618      	mov	r0, r3
 801ffdc:	f006 fbce 	bl	802677c <mp_forcezero>
#endif
        mp_forcezero(&key->q);
 801ffe0:	687b      	ldr	r3, [r7, #4]
 801ffe2:	f503 630b 	add.w	r3, r3, #2224	@ 0x8b0
 801ffe6:	4618      	mov	r0, r3
 801ffe8:	f006 fbc8 	bl	802677c <mp_forcezero>
        mp_forcezero(&key->p);
 801ffec:	687b      	ldr	r3, [r7, #4]
 801ffee:	f203 6384 	addw	r3, r3, #1668	@ 0x684
 801fff2:	4618      	mov	r0, r3
 801fff4:	f006 fbc2 	bl	802677c <mp_forcezero>
        mp_forcezero(&key->d);
 801fff8:	687b      	ldr	r3, [r7, #4]
 801fffa:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 801fffe:	4618      	mov	r0, r3
 8020000:	f006 fbbc 	bl	802677c <mp_forcezero>
 8020004:	e023      	b.n	802004e <wc_FreeRsaKey+0xbe>
    }
    else {
        /* private part */
#if defined(WOLFSSL_KEY_GEN) || defined(OPENSSL_EXTRA) || !defined(RSA_LOW_MEM)
        mp_clear(&key->u);
 8020006:	687b      	ldr	r3, [r7, #4]
 8020008:	f603 7334 	addw	r3, r3, #3892	@ 0xf34
 802000c:	4618      	mov	r0, r3
 802000e:	f006 fbca 	bl	80267a6 <mp_clear>
        mp_clear(&key->dQ);
 8020012:	687b      	ldr	r3, [r7, #4]
 8020014:	f603 5308 	addw	r3, r3, #3336	@ 0xd08
 8020018:	4618      	mov	r0, r3
 802001a:	f006 fbc4 	bl	80267a6 <mp_clear>
        mp_clear(&key->dP);
 802001e:	687b      	ldr	r3, [r7, #4]
 8020020:	f603 23dc 	addw	r3, r3, #2780	@ 0xadc
 8020024:	4618      	mov	r0, r3
 8020026:	f006 fbbe 	bl	80267a6 <mp_clear>
#endif
        mp_clear(&key->q);
 802002a:	687b      	ldr	r3, [r7, #4]
 802002c:	f503 630b 	add.w	r3, r3, #2224	@ 0x8b0
 8020030:	4618      	mov	r0, r3
 8020032:	f006 fbb8 	bl	80267a6 <mp_clear>
        mp_clear(&key->p);
 8020036:	687b      	ldr	r3, [r7, #4]
 8020038:	f203 6384 	addw	r3, r3, #1668	@ 0x684
 802003c:	4618      	mov	r0, r3
 802003e:	f006 fbb2 	bl	80267a6 <mp_clear>
        mp_clear(&key->d);
 8020042:	687b      	ldr	r3, [r7, #4]
 8020044:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 8020048:	4618      	mov	r0, r3
 802004a:	f006 fbac 	bl	80267a6 <mp_clear>
    }
#endif /* WOLFSSL_RSA_PUBLIC_ONLY */

    /* public part */
    mp_clear(&key->e);
 802004e:	687b      	ldr	r3, [r7, #4]
 8020050:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8020054:	4618      	mov	r0, r3
 8020056:	f006 fba6 	bl	80267a6 <mp_clear>
    mp_clear(&key->n);
 802005a:	687b      	ldr	r3, [r7, #4]
 802005c:	4618      	mov	r0, r3
 802005e:	f006 fba2 	bl	80267a6 <mp_clear>

#if defined(WOLFSSL_RENESAS_FSPSM_CRYPTONLY)
    wc_fspsm_RsaKeyFree(key);
#endif

    return ret;
 8020062:	68fb      	ldr	r3, [r7, #12]
}
 8020064:	4618      	mov	r0, r3
 8020066:	3710      	adds	r7, #16
 8020068:	46bd      	mov	sp, r7
 802006a:	bd80      	pop	{r7, pc}

0802006c <RsaMGF1>:
   outSz: size of output buffer
 */
#if !defined(NO_SHA) || !defined(NO_SHA256) || defined(WOLFSSL_SHA384) || defined(WOLFSSL_SHA512)
static int RsaMGF1(enum wc_HashType hType, byte* seed, word32 seedSz,
                                        byte* out, word32 outSz, void* heap)
{
 802006c:	b580      	push	{r7, lr}
 802006e:	b09a      	sub	sp, #104	@ 0x68
 8020070:	af02      	add	r7, sp, #8
 8020072:	60b9      	str	r1, [r7, #8]
 8020074:	607a      	str	r2, [r7, #4]
 8020076:	603b      	str	r3, [r7, #0]
 8020078:	4603      	mov	r3, r0
 802007a:	73fb      	strb	r3, [r7, #15]
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
    byte* tmp = NULL;
 802007c:	2300      	movs	r3, #0
 802007e:	65fb      	str	r3, [r7, #92]	@ 0x5c
    byte   tmpF = 0;     /* 1 if dynamic memory needs freed */
 8020080:	2300      	movs	r3, #0
 8020082:	f887 305b 	strb.w	r3, [r7, #91]	@ 0x5b
#else
    byte tmp[RSA_MAX_SIZE/8];
#endif
    /* needs to be large enough for seed size plus counter(4) */
    byte  tmpA[WC_MAX_DIGEST_SIZE + 4];
    word32 tmpSz = 0;
 8020086:	2300      	movs	r3, #0
 8020088:	657b      	str	r3, [r7, #84]	@ 0x54
    word32 counter;
    word32 idx;
#ifdef WOLFSSL_SMALL_STACK_CACHE
    wc_HashAlg *hash;
#endif
    hLen    = wc_HashGetDigestSize(hType);
 802008a:	7bfb      	ldrb	r3, [r7, #15]
 802008c:	4618      	mov	r0, r3
 802008e:	f7fe f969 	bl	801e364 <wc_HashGetDigestSize>
 8020092:	6478      	str	r0, [r7, #68]	@ 0x44
    counter = 0;
 8020094:	2300      	movs	r3, #0
 8020096:	653b      	str	r3, [r7, #80]	@ 0x50
    idx     = 0;
 8020098:	2300      	movs	r3, #0
 802009a:	64fb      	str	r3, [r7, #76]	@ 0x4c

    (void)heap;

    XMEMSET(tmpA, 0, sizeof(tmpA));
 802009c:	f107 0314 	add.w	r3, r7, #20
 80200a0:	2224      	movs	r2, #36	@ 0x24
 80200a2:	2100      	movs	r1, #0
 80200a4:	4618      	mov	r0, r3
 80200a6:	f008 fa0f 	bl	80284c8 <memset>
    /* check error return of wc_HashGetDigestSize */
    if (hLen < 0) {
 80200aa:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80200ac:	2b00      	cmp	r3, #0
 80200ae:	da01      	bge.n	80200b4 <RsaMGF1+0x48>
        return hLen;
 80200b0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80200b2:	e08f      	b.n	80201d4 <RsaMGF1+0x168>
    }

    /* if tmp is not large enough than use some dynamic memory */
    if ((seedSz + 4) > sizeof(tmpA) || (word32)hLen > sizeof(tmpA)) {
 80200b4:	687b      	ldr	r3, [r7, #4]
 80200b6:	3304      	adds	r3, #4
 80200b8:	2b24      	cmp	r3, #36	@ 0x24
 80200ba:	d802      	bhi.n	80200c2 <RsaMGF1+0x56>
 80200bc:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80200be:	2b24      	cmp	r3, #36	@ 0x24
 80200c0:	d914      	bls.n	80200ec <RsaMGF1+0x80>
        /* find largest amount of memory needed which will be the max of
         * hLen and (seedSz + 4) since tmp is used to store the hash digest */
        tmpSz = ((seedSz + 4) > (word32)hLen)? seedSz + 4: (word32)hLen;
 80200c2:	687b      	ldr	r3, [r7, #4]
 80200c4:	1d1a      	adds	r2, r3, #4
 80200c6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80200c8:	4293      	cmp	r3, r2
 80200ca:	bf38      	it	cc
 80200cc:	4613      	movcc	r3, r2
 80200ce:	657b      	str	r3, [r7, #84]	@ 0x54
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
        tmp = (byte*)XMALLOC(tmpSz, heap, DYNAMIC_TYPE_RSA_BUFFER);
 80200d0:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 80200d2:	f7fe fcd9 	bl	801ea88 <wolfSSL_Malloc>
 80200d6:	65f8      	str	r0, [r7, #92]	@ 0x5c
        if (tmp == NULL) {
 80200d8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80200da:	2b00      	cmp	r3, #0
 80200dc:	d102      	bne.n	80200e4 <RsaMGF1+0x78>
            return MEMORY_E;
 80200de:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 80200e2:	e077      	b.n	80201d4 <RsaMGF1+0x168>
        }
        tmpF = 1; /* make sure to free memory when done */
 80200e4:	2301      	movs	r3, #1
 80200e6:	f887 305b 	strb.w	r3, [r7, #91]	@ 0x5b
 80200ea:	e007      	b.n	80200fc <RsaMGF1+0x90>
#endif
    }
    else {
        /* use array on the stack */
    #ifndef WOLFSSL_SMALL_STACK_CACHE
        tmpSz = sizeof(tmpA);
 80200ec:	2324      	movs	r3, #36	@ 0x24
 80200ee:	657b      	str	r3, [r7, #84]	@ 0x54
    #endif
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
        tmp  = tmpA;
 80200f0:	f107 0314 	add.w	r3, r7, #20
 80200f4:	65fb      	str	r3, [r7, #92]	@ 0x5c
        tmpF = 0; /* no need to free memory at end */
 80200f6:	2300      	movs	r3, #0
 80200f8:	f887 305b 	strb.w	r3, [r7, #91]	@ 0x5b
        return ret;
    }
#endif

    do {
        int i = 0;
 80200fc:	2300      	movs	r3, #0
 80200fe:	64bb      	str	r3, [r7, #72]	@ 0x48
        XMEMCPY(tmp, seed, seedSz);
 8020100:	687a      	ldr	r2, [r7, #4]
 8020102:	68b9      	ldr	r1, [r7, #8]
 8020104:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8020106:	f008 fa49 	bl	802859c <memcpy>

        /* counter to byte array appended to tmp */
        tmp[seedSz]     = (byte)((counter >> 24) & 0xFF);
 802010a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802010c:	0e19      	lsrs	r1, r3, #24
 802010e:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8020110:	687b      	ldr	r3, [r7, #4]
 8020112:	4413      	add	r3, r2
 8020114:	b2ca      	uxtb	r2, r1
 8020116:	701a      	strb	r2, [r3, #0]
        tmp[seedSz + 1] = (byte)((counter >> 16) & 0xFF);
 8020118:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802011a:	0c19      	lsrs	r1, r3, #16
 802011c:	687b      	ldr	r3, [r7, #4]
 802011e:	3301      	adds	r3, #1
 8020120:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8020122:	4413      	add	r3, r2
 8020124:	b2ca      	uxtb	r2, r1
 8020126:	701a      	strb	r2, [r3, #0]
        tmp[seedSz + 2] = (byte)((counter >>  8) & 0xFF);
 8020128:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802012a:	0a19      	lsrs	r1, r3, #8
 802012c:	687b      	ldr	r3, [r7, #4]
 802012e:	3302      	adds	r3, #2
 8020130:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8020132:	4413      	add	r3, r2
 8020134:	b2ca      	uxtb	r2, r1
 8020136:	701a      	strb	r2, [r3, #0]
        tmp[seedSz + 3] = (byte)((counter)       & 0xFF);
 8020138:	687b      	ldr	r3, [r7, #4]
 802013a:	3303      	adds	r3, #3
 802013c:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 802013e:	4413      	add	r3, r2
 8020140:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 8020142:	b2d2      	uxtb	r2, r2
 8020144:	701a      	strb	r2, [r3, #0]
        ret = wc_HashUpdate(hash, hType, tmp, (seedSz + 4));
        if (ret == 0) {
            ret = wc_HashFinal(hash, hType, tmp);
        }
#else
        ret = wc_Hash(hType, tmp, (seedSz + 4), tmp, tmpSz);
 8020146:	687b      	ldr	r3, [r7, #4]
 8020148:	1d1a      	adds	r2, r3, #4
 802014a:	7bf8      	ldrb	r0, [r7, #15]
 802014c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802014e:	9300      	str	r3, [sp, #0]
 8020150:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8020152:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 8020154:	f7fe f99e 	bl	801e494 <wc_Hash>
 8020158:	6438      	str	r0, [r7, #64]	@ 0x40
#endif
        if (ret != 0) {
 802015a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802015c:	2b00      	cmp	r3, #0
 802015e:	d00d      	beq.n	802017c <RsaMGF1+0x110>
            /* check for if dynamic memory was needed, then free */
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
            if (tmpF) {
 8020160:	f897 305b 	ldrb.w	r3, [r7, #91]	@ 0x5b
 8020164:	2b00      	cmp	r3, #0
 8020166:	d007      	beq.n	8020178 <RsaMGF1+0x10c>
                XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 8020168:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 802016a:	63bb      	str	r3, [r7, #56]	@ 0x38
 802016c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802016e:	2b00      	cmp	r3, #0
 8020170:	d002      	beq.n	8020178 <RsaMGF1+0x10c>
 8020172:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 8020174:	f7fe fca4 	bl	801eac0 <wolfSSL_Free>
            }
#endif
            return ret;
 8020178:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802017a:	e02b      	b.n	80201d4 <RsaMGF1+0x168>
        }

        for (i = 0; i < hLen && idx < outSz; i++) {
 802017c:	2300      	movs	r3, #0
 802017e:	64bb      	str	r3, [r7, #72]	@ 0x48
 8020180:	e00c      	b.n	802019c <RsaMGF1+0x130>
            out[idx++] = tmp[i];
 8020182:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8020184:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8020186:	441a      	add	r2, r3
 8020188:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802018a:	1c59      	adds	r1, r3, #1
 802018c:	64f9      	str	r1, [r7, #76]	@ 0x4c
 802018e:	6839      	ldr	r1, [r7, #0]
 8020190:	440b      	add	r3, r1
 8020192:	7812      	ldrb	r2, [r2, #0]
 8020194:	701a      	strb	r2, [r3, #0]
        for (i = 0; i < hLen && idx < outSz; i++) {
 8020196:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8020198:	3301      	adds	r3, #1
 802019a:	64bb      	str	r3, [r7, #72]	@ 0x48
 802019c:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 802019e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80201a0:	429a      	cmp	r2, r3
 80201a2:	da03      	bge.n	80201ac <RsaMGF1+0x140>
 80201a4:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80201a6:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80201a8:	429a      	cmp	r2, r3
 80201aa:	d3ea      	bcc.n	8020182 <RsaMGF1+0x116>
        }
        counter++;
 80201ac:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80201ae:	3301      	adds	r3, #1
 80201b0:	653b      	str	r3, [r7, #80]	@ 0x50
    } while (idx < outSz);
 80201b2:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80201b4:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80201b6:	429a      	cmp	r2, r3
 80201b8:	d3a0      	bcc.n	80200fc <RsaMGF1+0x90>
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
    /* check for if dynamic memory was needed, then free */
    if (tmpF) {
 80201ba:	f897 305b 	ldrb.w	r3, [r7, #91]	@ 0x5b
 80201be:	2b00      	cmp	r3, #0
 80201c0:	d007      	beq.n	80201d2 <RsaMGF1+0x166>
        XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 80201c2:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80201c4:	63fb      	str	r3, [r7, #60]	@ 0x3c
 80201c6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80201c8:	2b00      	cmp	r3, #0
 80201ca:	d002      	beq.n	80201d2 <RsaMGF1+0x166>
 80201cc:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 80201ce:	f7fe fc77 	bl	801eac0 <wolfSSL_Free>
#ifdef WOLFSSL_SMALL_STACK_CACHE
    wc_HashFree(hash, hType);
    XFREE(hash, heap, DYNAMIC_TYPE_DIGEST);
#endif

    return 0;
 80201d2:	2300      	movs	r3, #0
}
 80201d4:	4618      	mov	r0, r3
 80201d6:	3760      	adds	r7, #96	@ 0x60
 80201d8:	46bd      	mov	sp, r7
 80201da:	bd80      	pop	{r7, pc}

080201dc <RsaMGF>:
/* helper function to direct which mask generation function is used
   switched on type input
 */
static int RsaMGF(int type, byte* seed, word32 seedSz, byte* out,
                                                    word32 outSz, void* heap)
{
 80201dc:	b580      	push	{r7, lr}
 80201de:	b088      	sub	sp, #32
 80201e0:	af02      	add	r7, sp, #8
 80201e2:	60f8      	str	r0, [r7, #12]
 80201e4:	60b9      	str	r1, [r7, #8]
 80201e6:	607a      	str	r2, [r7, #4]
 80201e8:	603b      	str	r3, [r7, #0]
    int ret;

    switch(type) {
 80201ea:	68fb      	ldr	r3, [r7, #12]
 80201ec:	2b01      	cmp	r3, #1
 80201ee:	d10b      	bne.n	8020208 <RsaMGF+0x2c>
        case WC_MGF1SHA224:
            ret = RsaMGF1(WC_HASH_TYPE_SHA224, seed, seedSz, out, outSz, heap);
            break;
    #endif
        case WC_MGF1SHA256:
            ret = RsaMGF1(WC_HASH_TYPE_SHA256, seed, seedSz, out, outSz, heap);
 80201f0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80201f2:	9301      	str	r3, [sp, #4]
 80201f4:	6a3b      	ldr	r3, [r7, #32]
 80201f6:	9300      	str	r3, [sp, #0]
 80201f8:	683b      	ldr	r3, [r7, #0]
 80201fa:	687a      	ldr	r2, [r7, #4]
 80201fc:	68b9      	ldr	r1, [r7, #8]
 80201fe:	2006      	movs	r0, #6
 8020200:	f7ff ff34 	bl	802006c <RsaMGF1>
 8020204:	6178      	str	r0, [r7, #20]
            break;
 8020206:	e002      	b.n	802020e <RsaMGF+0x32>
            break;
        #endif
    #endif
        default:
            WOLFSSL_MSG("Unknown MGF type: check build options");
            ret = BAD_FUNC_ARG;
 8020208:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 802020c:	617b      	str	r3, [r7, #20]
    (void)seedSz;
    (void)out;
    (void)outSz;
    (void)heap;

    return ret;
 802020e:	697b      	ldr	r3, [r7, #20]
}
 8020210:	4618      	mov	r0, r3
 8020212:	3718      	adds	r7, #24
 8020214:	46bd      	mov	sp, r7
 8020216:	bd80      	pop	{r7, pc}

08020218 <RsaUnPad_OAEP>:
/* UnPad plaintext, set start to *output, return length of plaintext,
 * < 0 on error */
static int RsaUnPad_OAEP(byte *pkcsBlock, unsigned int pkcsBlockLen,
                            byte **output, enum wc_HashType hType, int mgf,
                            byte* optLabel, word32 labelLen, void* heap)
{
 8020218:	b580      	push	{r7, lr}
 802021a:	b098      	sub	sp, #96	@ 0x60
 802021c:	af02      	add	r7, sp, #8
 802021e:	60f8      	str	r0, [r7, #12]
 8020220:	60b9      	str	r1, [r7, #8]
 8020222:	607a      	str	r2, [r7, #4]
 8020224:	70fb      	strb	r3, [r7, #3]
    word32 idx;
    word32 i;
    word32 inc;

#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
    byte* tmp  = NULL;
 8020226:	2300      	movs	r3, #0
 8020228:	64bb      	str	r3, [r7, #72]	@ 0x48
#else
    byte tmp[RSA_MAX_SIZE/8 + RSA_PSS_PAD_SZ];
#endif

    /* no label is allowed, but catch if no label provided and length > 0 */
    if (optLabel == NULL && labelLen > 0) {
 802022a:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 802022c:	2b00      	cmp	r3, #0
 802022e:	d105      	bne.n	802023c <RsaUnPad_OAEP+0x24>
 8020230:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8020232:	2b00      	cmp	r3, #0
 8020234:	d002      	beq.n	802023c <RsaUnPad_OAEP+0x24>
        return BUFFER_E;
 8020236:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 802023a:	e0e9      	b.n	8020410 <RsaUnPad_OAEP+0x1f8>
    }

    ret = wc_HashGetDigestSize(hType);
 802023c:	78fb      	ldrb	r3, [r7, #3]
 802023e:	4618      	mov	r0, r3
 8020240:	f7fe f890 	bl	801e364 <wc_HashGetDigestSize>
 8020244:	6478      	str	r0, [r7, #68]	@ 0x44
    if ((ret < 0) || (pkcsBlockLen < (2 * (word32)ret + 2))) {
 8020246:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8020248:	2b00      	cmp	r3, #0
 802024a:	db05      	blt.n	8020258 <RsaUnPad_OAEP+0x40>
 802024c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802024e:	3301      	adds	r3, #1
 8020250:	005b      	lsls	r3, r3, #1
 8020252:	68ba      	ldr	r2, [r7, #8]
 8020254:	429a      	cmp	r2, r3
 8020256:	d202      	bcs.n	802025e <RsaUnPad_OAEP+0x46>
        return BAD_FUNC_ARG;
 8020258:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 802025c:	e0d8      	b.n	8020410 <RsaUnPad_OAEP+0x1f8>
    }
    hLen = (word32)ret;
 802025e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8020260:	643b      	str	r3, [r7, #64]	@ 0x40

#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
    tmp = (byte*)XMALLOC(pkcsBlockLen, heap, DYNAMIC_TYPE_RSA_BUFFER);
 8020262:	68b8      	ldr	r0, [r7, #8]
 8020264:	f7fe fc10 	bl	801ea88 <wolfSSL_Malloc>
 8020268:	64b8      	str	r0, [r7, #72]	@ 0x48
    if (tmp == NULL) {
 802026a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802026c:	2b00      	cmp	r3, #0
 802026e:	d102      	bne.n	8020276 <RsaUnPad_OAEP+0x5e>
        return MEMORY_E;
 8020270:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8020274:	e0cc      	b.n	8020410 <RsaUnPad_OAEP+0x1f8>
    }
#endif
    XMEMSET(tmp, 0, pkcsBlockLen);
 8020276:	68ba      	ldr	r2, [r7, #8]
 8020278:	2100      	movs	r1, #0
 802027a:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 802027c:	f008 f924 	bl	80284c8 <memset>
#ifdef WOLFSSL_CHECK_MEM_ZERO
    wc_MemZero_Add("OAEP UnPad temp", tmp, pkcsBlockLen);
#endif

    /* find seedMask value */
    if ((ret = RsaMGF(mgf, (byte*)(pkcsBlock + (hLen + 1)),
 8020280:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8020282:	3301      	adds	r3, #1
 8020284:	68fa      	ldr	r2, [r7, #12]
 8020286:	18d1      	adds	r1, r2, r3
                            pkcsBlockLen - hLen - 1, tmp, hLen, heap)) != 0) {
 8020288:	68ba      	ldr	r2, [r7, #8]
 802028a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802028c:	1ad3      	subs	r3, r2, r3
    if ((ret = RsaMGF(mgf, (byte*)(pkcsBlock + (hLen + 1)),
 802028e:	1e5a      	subs	r2, r3, #1
 8020290:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8020292:	9301      	str	r3, [sp, #4]
 8020294:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8020296:	9300      	str	r3, [sp, #0]
 8020298:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802029a:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 802029c:	f7ff ff9e 	bl	80201dc <RsaMGF>
 80202a0:	6478      	str	r0, [r7, #68]	@ 0x44
 80202a2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80202a4:	2b00      	cmp	r3, #0
 80202a6:	d009      	beq.n	80202bc <RsaUnPad_OAEP+0xa4>
#ifdef WOLFSSL_SMALL_STACK
        XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 80202a8:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80202aa:	637b      	str	r3, [r7, #52]	@ 0x34
 80202ac:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80202ae:	2b00      	cmp	r3, #0
 80202b0:	d002      	beq.n	80202b8 <RsaUnPad_OAEP+0xa0>
 80202b2:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 80202b4:	f7fe fc04 	bl	801eac0 <wolfSSL_Free>
#endif
        return ret;
 80202b8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80202ba:	e0a9      	b.n	8020410 <RsaUnPad_OAEP+0x1f8>
    }

    /* xor seedMask value with maskedSeed to get seed value */
    xorbuf(tmp, pkcsBlock + 1, hLen);
 80202bc:	68fb      	ldr	r3, [r7, #12]
 80202be:	3301      	adds	r3, #1
 80202c0:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80202c2:	4619      	mov	r1, r3
 80202c4:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 80202c6:	f7ff fbf2 	bl	801faae <xorbuf>

    /* get dbMask value */
    if ((ret = RsaMGF(mgf, tmp, hLen, tmp + hLen,
 80202ca:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80202cc:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80202ce:	18d1      	adds	r1, r2, r3
                                       pkcsBlockLen - hLen - 1, heap)) != 0) {
 80202d0:	68ba      	ldr	r2, [r7, #8]
 80202d2:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80202d4:	1ad3      	subs	r3, r2, r3
    if ((ret = RsaMGF(mgf, tmp, hLen, tmp + hLen,
 80202d6:	3b01      	subs	r3, #1
 80202d8:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 80202da:	9201      	str	r2, [sp, #4]
 80202dc:	9300      	str	r3, [sp, #0]
 80202de:	460b      	mov	r3, r1
 80202e0:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80202e2:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
 80202e4:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 80202e6:	f7ff ff79 	bl	80201dc <RsaMGF>
 80202ea:	6478      	str	r0, [r7, #68]	@ 0x44
 80202ec:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80202ee:	2b00      	cmp	r3, #0
 80202f0:	d00d      	beq.n	802030e <RsaUnPad_OAEP+0xf6>
        ForceZero(tmp, hLen);
 80202f2:	6c39      	ldr	r1, [r7, #64]	@ 0x40
 80202f4:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 80202f6:	f7ff fc34 	bl	801fb62 <ForceZero>
#ifdef WOLFSSL_SMALL_STACK
        XFREE(tmp, NULL, DYNAMIC_TYPE_RSA_BUFFER);
 80202fa:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80202fc:	63bb      	str	r3, [r7, #56]	@ 0x38
 80202fe:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8020300:	2b00      	cmp	r3, #0
 8020302:	d002      	beq.n	802030a <RsaUnPad_OAEP+0xf2>
 8020304:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 8020306:	f7fe fbdb 	bl	801eac0 <wolfSSL_Free>
#elif defined(WOLFSSL_CHECK_MEM_ZERO)
        wc_MemZero_Check(tmp, hLen);
#endif
        return ret;
 802030a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802030c:	e080      	b.n	8020410 <RsaUnPad_OAEP+0x1f8>
    }

    /* get DB value by doing maskedDB xor dbMask */
    xorbuf(pkcsBlock + hLen + 1, tmp + hLen, pkcsBlockLen - hLen - 1);
 802030e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8020310:	3301      	adds	r3, #1
 8020312:	68fa      	ldr	r2, [r7, #12]
 8020314:	18d0      	adds	r0, r2, r3
 8020316:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8020318:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802031a:	18d1      	adds	r1, r2, r3
 802031c:	68ba      	ldr	r2, [r7, #8]
 802031e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8020320:	1ad3      	subs	r3, r2, r3
 8020322:	3b01      	subs	r3, #1
 8020324:	461a      	mov	r2, r3
 8020326:	f7ff fbc2 	bl	801faae <xorbuf>

    ForceZero(tmp, pkcsBlockLen);
 802032a:	68b9      	ldr	r1, [r7, #8]
 802032c:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 802032e:	f7ff fc18 	bl	801fb62 <ForceZero>
#ifdef WOLFSSL_SMALL_STACK
    /* done with use of tmp buffer */
    XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 8020332:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8020334:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8020336:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8020338:	2b00      	cmp	r3, #0
 802033a:	d002      	beq.n	8020342 <RsaUnPad_OAEP+0x12a>
 802033c:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 802033e:	f7fe fbbf 	bl	801eac0 <wolfSSL_Free>
#elif defined(WOLFSSL_CHECK_MEM_ZERO)
    wc_MemZero_Check(tmp, pkcsBlockLen);
#endif

    /* advance idx to index of PS and msg separator, account for PS size of 0*/
    idx = hLen + 1 + hLen;
 8020342:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8020344:	005b      	lsls	r3, r3, #1
 8020346:	3301      	adds	r3, #1
 8020348:	657b      	str	r3, [r7, #84]	@ 0x54
    /* Don't reveal length of message: look at every byte. */
    inc = 1;
 802034a:	2301      	movs	r3, #1
 802034c:	64fb      	str	r3, [r7, #76]	@ 0x4c
    for (i = hLen + 1 + hLen; i < pkcsBlockLen - 1; i++) {
 802034e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8020350:	005b      	lsls	r3, r3, #1
 8020352:	3301      	adds	r3, #1
 8020354:	653b      	str	r3, [r7, #80]	@ 0x50
 8020356:	e010      	b.n	802037a <RsaUnPad_OAEP+0x162>
        /* Looking for non-zero byte. */
        inc &= 1 - (((word32)0 - pkcsBlock[i]) >> 31);
 8020358:	68fa      	ldr	r2, [r7, #12]
 802035a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802035c:	4413      	add	r3, r2
 802035e:	781b      	ldrb	r3, [r3, #0]
 8020360:	425b      	negs	r3, r3
 8020362:	17db      	asrs	r3, r3, #31
 8020364:	3301      	adds	r3, #1
 8020366:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8020368:	4013      	ands	r3, r2
 802036a:	64fb      	str	r3, [r7, #76]	@ 0x4c
        idx += inc;
 802036c:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 802036e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8020370:	4413      	add	r3, r2
 8020372:	657b      	str	r3, [r7, #84]	@ 0x54
    for (i = hLen + 1 + hLen; i < pkcsBlockLen - 1; i++) {
 8020374:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020376:	3301      	adds	r3, #1
 8020378:	653b      	str	r3, [r7, #80]	@ 0x50
 802037a:	68bb      	ldr	r3, [r7, #8]
 802037c:	3b01      	subs	r3, #1
 802037e:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 8020380:	429a      	cmp	r2, r3
 8020382:	d3e9      	bcc.n	8020358 <RsaUnPad_OAEP+0x140>
    }

    /* create hash of label for comparison with hash sent */
    if ((ret = wc_Hash(hType, optLabel, labelLen, h, hLen)) != 0) {
 8020384:	f107 0214 	add.w	r2, r7, #20
 8020388:	78f8      	ldrb	r0, [r7, #3]
 802038a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802038c:	9300      	str	r3, [sp, #0]
 802038e:	4613      	mov	r3, r2
 8020390:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8020392:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 8020394:	f7fe f87e 	bl	801e494 <wc_Hash>
 8020398:	6478      	str	r0, [r7, #68]	@ 0x44
 802039a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802039c:	2b00      	cmp	r3, #0
 802039e:	d001      	beq.n	80203a4 <RsaUnPad_OAEP+0x18c>
        return ret;
 80203a0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80203a2:	e035      	b.n	8020410 <RsaUnPad_OAEP+0x1f8>
       Comparison of lHash, Y, and separator value needs to all happen in
       constant time.
       Attackers should not be able to get error condition from the timing of
       these checks.
     */
    ret = 0;
 80203a4:	2300      	movs	r3, #0
 80203a6:	647b      	str	r3, [r7, #68]	@ 0x44
    ret |= ConstantCompare(pkcsBlock + hLen + 1, h, (int)hLen);
 80203a8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80203aa:	3301      	adds	r3, #1
 80203ac:	68fa      	ldr	r2, [r7, #12]
 80203ae:	4413      	add	r3, r2
 80203b0:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80203b2:	f107 0114 	add.w	r1, r7, #20
 80203b6:	4618      	mov	r0, r3
 80203b8:	f7ff fbec 	bl	801fb94 <ConstantCompare>
 80203bc:	4602      	mov	r2, r0
 80203be:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80203c0:	4313      	orrs	r3, r2
 80203c2:	647b      	str	r3, [r7, #68]	@ 0x44
    ret += pkcsBlock[idx++] ^ 0x01; /* separator value is 0x01 */
 80203c4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80203c6:	1c5a      	adds	r2, r3, #1
 80203c8:	657a      	str	r2, [r7, #84]	@ 0x54
 80203ca:	68fa      	ldr	r2, [r7, #12]
 80203cc:	4413      	add	r3, r2
 80203ce:	781b      	ldrb	r3, [r3, #0]
 80203d0:	f083 0301 	eor.w	r3, r3, #1
 80203d4:	b2db      	uxtb	r3, r3
 80203d6:	461a      	mov	r2, r3
 80203d8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80203da:	4413      	add	r3, r2
 80203dc:	647b      	str	r3, [r7, #68]	@ 0x44
    ret += pkcsBlock[0]     ^ 0x00; /* Y, the first value, should be 0 */
 80203de:	68fb      	ldr	r3, [r7, #12]
 80203e0:	781b      	ldrb	r3, [r3, #0]
 80203e2:	461a      	mov	r2, r3
 80203e4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80203e6:	4413      	add	r3, r2
 80203e8:	647b      	str	r3, [r7, #68]	@ 0x44

    /* Return 0 data length on error. */
    idx = ctMaskSelWord32(ctMaskEq(ret, 0), idx, pkcsBlockLen);
 80203ea:	2100      	movs	r1, #0
 80203ec:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 80203ee:	f7ff fc42 	bl	801fc76 <ctMaskEq>
 80203f2:	4603      	mov	r3, r0
 80203f4:	68ba      	ldr	r2, [r7, #8]
 80203f6:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 80203f8:	4618      	mov	r0, r3
 80203fa:	f7ff fcc0 	bl	801fd7e <ctMaskSelWord32>
 80203fe:	6578      	str	r0, [r7, #84]	@ 0x54

    /* adjust pointer to correct location in array and return size of M */
    *output = (byte*)(pkcsBlock + idx);
 8020400:	68fa      	ldr	r2, [r7, #12]
 8020402:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8020404:	441a      	add	r2, r3
 8020406:	687b      	ldr	r3, [r7, #4]
 8020408:	601a      	str	r2, [r3, #0]
    return (int)(pkcsBlockLen - idx);
 802040a:	68ba      	ldr	r2, [r7, #8]
 802040c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802040e:	1ad3      	subs	r3, r2, r3
}
 8020410:	4618      	mov	r0, r3
 8020412:	3758      	adds	r7, #88	@ 0x58
 8020414:	46bd      	mov	sp, r7
 8020416:	bd80      	pop	{r7, pc}

08020418 <RsaUnPad_PSS>:
                 and other negative values on error.
 */
static int RsaUnPad_PSS(byte *pkcsBlock, unsigned int pkcsBlockLen,
                        byte **output, enum wc_HashType hType, int mgf,
                        int saltLen, int bits, void* heap)
{
 8020418:	b580      	push	{r7, lr}
 802041a:	b090      	sub	sp, #64	@ 0x40
 802041c:	af02      	add	r7, sp, #8
 802041e:	60f8      	str	r0, [r7, #12]
 8020420:	60b9      	str	r1, [r7, #8]
 8020422:	607a      	str	r2, [r7, #4]
 8020424:	70fb      	strb	r3, [r7, #3]
    if (pkcsBlockLen > RSA_MAX_SIZE/8) {
        return MEMORY_E;
    }
#endif

    hLen = wc_HashGetDigestSize(hType);
 8020426:	78fb      	ldrb	r3, [r7, #3]
 8020428:	4618      	mov	r0, r3
 802042a:	f7fd ff9b 	bl	801e364 <wc_HashGetDigestSize>
 802042e:	6338      	str	r0, [r7, #48]	@ 0x30
    if (hLen < 0)
 8020430:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8020432:	2b00      	cmp	r3, #0
 8020434:	da01      	bge.n	802043a <RsaUnPad_PSS+0x22>
        return hLen;
 8020436:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8020438:	e0e3      	b.n	8020602 <RsaUnPad_PSS+0x1ea>
    bits = (bits - 1) & 0x7;
 802043a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802043c:	3b01      	subs	r3, #1
 802043e:	f003 0307 	and.w	r3, r3, #7
 8020442:	64bb      	str	r3, [r7, #72]	@ 0x48
    if ((pkcsBlock[0] & (0xff << bits)) != 0) {
 8020444:	68fb      	ldr	r3, [r7, #12]
 8020446:	781b      	ldrb	r3, [r3, #0]
 8020448:	4619      	mov	r1, r3
 802044a:	22ff      	movs	r2, #255	@ 0xff
 802044c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802044e:	fa02 f303 	lsl.w	r3, r2, r3
 8020452:	400b      	ands	r3, r1
 8020454:	2b00      	cmp	r3, #0
 8020456:	d002      	beq.n	802045e <RsaUnPad_PSS+0x46>
        return BAD_PADDING_E;
 8020458:	f06f 03c0 	mvn.w	r3, #192	@ 0xc0
 802045c:	e0d1      	b.n	8020602 <RsaUnPad_PSS+0x1ea>
    }
    if (bits == 0) {
 802045e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8020460:	2b00      	cmp	r3, #0
 8020462:	d105      	bne.n	8020470 <RsaUnPad_PSS+0x58>
        pkcsBlock++;
 8020464:	68fb      	ldr	r3, [r7, #12]
 8020466:	3301      	adds	r3, #1
 8020468:	60fb      	str	r3, [r7, #12]
        pkcsBlockLen--;
 802046a:	68bb      	ldr	r3, [r7, #8]
 802046c:	3b01      	subs	r3, #1
 802046e:	60bb      	str	r3, [r7, #8]
    }
    maskLen = (int)pkcsBlockLen - 1 - hLen;
 8020470:	68bb      	ldr	r3, [r7, #8]
 8020472:	1e5a      	subs	r2, r3, #1
 8020474:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8020476:	1ad3      	subs	r3, r2, r3
 8020478:	62fb      	str	r3, [r7, #44]	@ 0x2c
    if (maskLen < 0) {
 802047a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802047c:	2b00      	cmp	r3, #0
 802047e:	da02      	bge.n	8020486 <RsaUnPad_PSS+0x6e>
        WOLFSSL_MSG("RsaUnPad_PSS: Hash too large");
        return WC_KEY_SIZE_E;
 8020480:	f06f 03e9 	mvn.w	r3, #233	@ 0xe9
 8020484:	e0bd      	b.n	8020602 <RsaUnPad_PSS+0x1ea>
    }

    if (saltLen == RSA_PSS_SALT_LEN_DEFAULT) {
 8020486:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8020488:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 802048c:	d102      	bne.n	8020494 <RsaUnPad_PSS+0x7c>
        saltLen = hLen;
 802048e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8020490:	647b      	str	r3, [r7, #68]	@ 0x44
 8020492:	e00d      	b.n	80204b0 <RsaUnPad_PSS+0x98>
            if (orig_bits == 1024 && hLen == WC_SHA512_DIGEST_SIZE)
                saltLen = RSA_PSS_SALT_MAX_SZ;
        #endif
    }
#ifndef WOLFSSL_PSS_LONG_SALT
    else if (saltLen > hLen)
 8020494:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8020496:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8020498:	429a      	cmp	r2, r3
 802049a:	dd02      	ble.n	80204a2 <RsaUnPad_PSS+0x8a>
        return PSS_SALTLEN_E;
 802049c:	f06f 03f9 	mvn.w	r3, #249	@ 0xf9
 80204a0:	e0af      	b.n	8020602 <RsaUnPad_PSS+0x1ea>
#endif
#ifndef WOLFSSL_PSS_SALT_LEN_DISCOVER
    else if (saltLen < RSA_PSS_SALT_LEN_DEFAULT)
 80204a2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80204a4:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 80204a8:	da02      	bge.n	80204b0 <RsaUnPad_PSS+0x98>
        return PSS_SALTLEN_E;
 80204aa:	f06f 03f9 	mvn.w	r3, #249	@ 0xf9
 80204ae:	e0a8      	b.n	8020602 <RsaUnPad_PSS+0x1ea>
    if (maskLen < saltLen + 1) {
 80204b0:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80204b2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80204b4:	429a      	cmp	r2, r3
 80204b6:	db02      	blt.n	80204be <RsaUnPad_PSS+0xa6>
        return PSS_SALTLEN_E;
 80204b8:	f06f 03f9 	mvn.w	r3, #249	@ 0xf9
 80204bc:	e0a1      	b.n	8020602 <RsaUnPad_PSS+0x1ea>
    if (saltLen != RSA_PSS_SALT_LEN_DISCOVER && maskLen < saltLen + 1) {
        return WC_KEY_SIZE_E;
    }
#endif

    if (pkcsBlock[pkcsBlockLen - 1] != RSA_PSS_PAD_TERM) {
 80204be:	68bb      	ldr	r3, [r7, #8]
 80204c0:	3b01      	subs	r3, #1
 80204c2:	68fa      	ldr	r2, [r7, #12]
 80204c4:	4413      	add	r3, r2
 80204c6:	781b      	ldrb	r3, [r3, #0]
 80204c8:	2bbc      	cmp	r3, #188	@ 0xbc
 80204ca:	d002      	beq.n	80204d2 <RsaUnPad_PSS+0xba>
        WOLFSSL_MSG("RsaUnPad_PSS: Padding Term Error");
        return BAD_PADDING_E;
 80204cc:	f06f 03c0 	mvn.w	r3, #192	@ 0xc0
 80204d0:	e097      	b.n	8020602 <RsaUnPad_PSS+0x1ea>
    }

#if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)
    tmp = (byte*)XMALLOC((size_t)maskLen, heap, DYNAMIC_TYPE_RSA_BUFFER);
 80204d2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80204d4:	4618      	mov	r0, r3
 80204d6:	f7fe fad7 	bl	801ea88 <wolfSSL_Malloc>
 80204da:	62b8      	str	r0, [r7, #40]	@ 0x28
    if (tmp == NULL) {
 80204dc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80204de:	2b00      	cmp	r3, #0
 80204e0:	d102      	bne.n	80204e8 <RsaUnPad_PSS+0xd0>
        return MEMORY_E;
 80204e2:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 80204e6:	e08c      	b.n	8020602 <RsaUnPad_PSS+0x1ea>
    }
#endif

    if ((ret = RsaMGF(mgf, pkcsBlock + maskLen, (word32)hLen, tmp, (word32)maskLen,
 80204e8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80204ea:	68fa      	ldr	r2, [r7, #12]
 80204ec:	18d1      	adds	r1, r2, r3
 80204ee:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 80204f0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80204f2:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80204f4:	9201      	str	r2, [sp, #4]
 80204f6:	9300      	str	r3, [sp, #0]
 80204f8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80204fa:	4602      	mov	r2, r0
 80204fc:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 80204fe:	f7ff fe6d 	bl	80201dc <RsaMGF>
 8020502:	6278      	str	r0, [r7, #36]	@ 0x24
 8020504:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8020506:	2b00      	cmp	r3, #0
 8020508:	d009      	beq.n	802051e <RsaUnPad_PSS+0x106>
                                                                  heap)) != 0) {
        #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)
        XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 802050a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802050c:	617b      	str	r3, [r7, #20]
 802050e:	697b      	ldr	r3, [r7, #20]
 8020510:	2b00      	cmp	r3, #0
 8020512:	d002      	beq.n	802051a <RsaUnPad_PSS+0x102>
 8020514:	6978      	ldr	r0, [r7, #20]
 8020516:	f7fe fad3 	bl	801eac0 <wolfSSL_Free>
        #endif
        return ret;
 802051a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802051c:	e071      	b.n	8020602 <RsaUnPad_PSS+0x1ea>
    }

    tmp[0] &= (byte)((1 << bits) - 1);
 802051e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8020520:	781a      	ldrb	r2, [r3, #0]
 8020522:	2101      	movs	r1, #1
 8020524:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8020526:	fa01 f303 	lsl.w	r3, r1, r3
 802052a:	b2db      	uxtb	r3, r3
 802052c:	3b01      	subs	r3, #1
 802052e:	b2db      	uxtb	r3, r3
 8020530:	4013      	ands	r3, r2
 8020532:	b2da      	uxtb	r2, r3
 8020534:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8020536:	701a      	strb	r2, [r3, #0]
    pkcsBlock[0] &= (byte)((1 << bits) - 1);
 8020538:	68fb      	ldr	r3, [r7, #12]
 802053a:	781a      	ldrb	r2, [r3, #0]
 802053c:	2101      	movs	r1, #1
 802053e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8020540:	fa01 f303 	lsl.w	r3, r1, r3
 8020544:	b2db      	uxtb	r3, r3
 8020546:	3b01      	subs	r3, #1
 8020548:	b2db      	uxtb	r3, r3
 802054a:	4013      	ands	r3, r2
 802054c:	b2da      	uxtb	r2, r3
 802054e:	68fb      	ldr	r3, [r7, #12]
 8020550:	701a      	strb	r2, [r3, #0]
        saltLen = maskLen - (i + 1);
    }
    else
#endif
    {
        for (i = 0; i < maskLen - 1 - saltLen; i++) {
 8020552:	2300      	movs	r3, #0
 8020554:	637b      	str	r3, [r7, #52]	@ 0x34
 8020556:	e017      	b.n	8020588 <RsaUnPad_PSS+0x170>
            if (tmp[i] != pkcsBlock[i]) {
 8020558:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802055a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 802055c:	4413      	add	r3, r2
 802055e:	781a      	ldrb	r2, [r3, #0]
 8020560:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020562:	68f9      	ldr	r1, [r7, #12]
 8020564:	440b      	add	r3, r1
 8020566:	781b      	ldrb	r3, [r3, #0]
 8020568:	429a      	cmp	r2, r3
 802056a:	d00a      	beq.n	8020582 <RsaUnPad_PSS+0x16a>
                #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)
                XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 802056c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802056e:	61bb      	str	r3, [r7, #24]
 8020570:	69bb      	ldr	r3, [r7, #24]
 8020572:	2b00      	cmp	r3, #0
 8020574:	d002      	beq.n	802057c <RsaUnPad_PSS+0x164>
 8020576:	69b8      	ldr	r0, [r7, #24]
 8020578:	f7fe faa2 	bl	801eac0 <wolfSSL_Free>
                #endif
                WOLFSSL_MSG("RsaUnPad_PSS: Padding Error Match");
                return PSS_SALTLEN_E;
 802057c:	f06f 03f9 	mvn.w	r3, #249	@ 0xf9
 8020580:	e03f      	b.n	8020602 <RsaUnPad_PSS+0x1ea>
        for (i = 0; i < maskLen - 1 - saltLen; i++) {
 8020582:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020584:	3301      	adds	r3, #1
 8020586:	637b      	str	r3, [r7, #52]	@ 0x34
 8020588:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802058a:	1e5a      	subs	r2, r3, #1
 802058c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802058e:	1ad3      	subs	r3, r2, r3
 8020590:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8020592:	429a      	cmp	r2, r3
 8020594:	dbe0      	blt.n	8020558 <RsaUnPad_PSS+0x140>
            }
        }
        if (tmp[i] != (pkcsBlock[i] ^ 0x01)) {
 8020596:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020598:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 802059a:	4413      	add	r3, r2
 802059c:	781a      	ldrb	r2, [r3, #0]
 802059e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80205a0:	68f9      	ldr	r1, [r7, #12]
 80205a2:	440b      	add	r3, r1
 80205a4:	781b      	ldrb	r3, [r3, #0]
 80205a6:	f083 0301 	eor.w	r3, r3, #1
 80205aa:	b2db      	uxtb	r3, r3
 80205ac:	429a      	cmp	r2, r3
 80205ae:	d00a      	beq.n	80205c6 <RsaUnPad_PSS+0x1ae>
            #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)
            XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 80205b0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80205b2:	61fb      	str	r3, [r7, #28]
 80205b4:	69fb      	ldr	r3, [r7, #28]
 80205b6:	2b00      	cmp	r3, #0
 80205b8:	d002      	beq.n	80205c0 <RsaUnPad_PSS+0x1a8>
 80205ba:	69f8      	ldr	r0, [r7, #28]
 80205bc:	f7fe fa80 	bl	801eac0 <wolfSSL_Free>
            #endif
            WOLFSSL_MSG("RsaUnPad_PSS: Padding Error End");
            return PSS_SALTLEN_E;
 80205c0:	f06f 03f9 	mvn.w	r3, #249	@ 0xf9
 80205c4:	e01d      	b.n	8020602 <RsaUnPad_PSS+0x1ea>
        }
    }
    xorbuf(pkcsBlock + i, tmp + i, (word32)(maskLen - i));
 80205c6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80205c8:	68fa      	ldr	r2, [r7, #12]
 80205ca:	18d0      	adds	r0, r2, r3
 80205cc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80205ce:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80205d0:	18d1      	adds	r1, r2, r3
 80205d2:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80205d4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80205d6:	1ad3      	subs	r3, r2, r3
 80205d8:	461a      	mov	r2, r3
 80205da:	f7ff fa68 	bl	801faae <xorbuf>

#if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)
    XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 80205de:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80205e0:	623b      	str	r3, [r7, #32]
 80205e2:	6a3b      	ldr	r3, [r7, #32]
 80205e4:	2b00      	cmp	r3, #0
 80205e6:	d002      	beq.n	80205ee <RsaUnPad_PSS+0x1d6>
 80205e8:	6a38      	ldr	r0, [r7, #32]
 80205ea:	f7fe fa69 	bl	801eac0 <wolfSSL_Free>
#endif

    *output = pkcsBlock + maskLen - saltLen;
 80205ee:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80205f0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80205f2:	1ad3      	subs	r3, r2, r3
 80205f4:	68fa      	ldr	r2, [r7, #12]
 80205f6:	441a      	add	r2, r3
 80205f8:	687b      	ldr	r3, [r7, #4]
 80205fa:	601a      	str	r2, [r3, #0]
    return saltLen + hLen;
 80205fc:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80205fe:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8020600:	4413      	add	r3, r2
}
 8020602:	4618      	mov	r0, r3
 8020604:	3738      	adds	r7, #56	@ 0x38
 8020606:	46bd      	mov	sp, r7
 8020608:	bd80      	pop	{r7, pc}

0802060a <RsaUnPad>:

/* UnPad plaintext, set start to *output, return length of plaintext,
 * < 0 on error */
static int RsaUnPad(const byte *pkcsBlock, unsigned int pkcsBlockLen,
                    byte **output, byte padValue)
{
 802060a:	b590      	push	{r4, r7, lr}
 802060c:	b089      	sub	sp, #36	@ 0x24
 802060e:	af00      	add	r7, sp, #0
 8020610:	60f8      	str	r0, [r7, #12]
 8020612:	60b9      	str	r1, [r7, #8]
 8020614:	607a      	str	r2, [r7, #4]
 8020616:	70fb      	strb	r3, [r7, #3]
    int    ret = WC_NO_ERR_TRACE(BAD_FUNC_ARG);
 8020618:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 802061c:	61fb      	str	r3, [r7, #28]
    word16 i;

    if (output == NULL || pkcsBlockLen < 2 || pkcsBlockLen > 0xFFFF) {
 802061e:	687b      	ldr	r3, [r7, #4]
 8020620:	2b00      	cmp	r3, #0
 8020622:	d006      	beq.n	8020632 <RsaUnPad+0x28>
 8020624:	68bb      	ldr	r3, [r7, #8]
 8020626:	2b01      	cmp	r3, #1
 8020628:	d903      	bls.n	8020632 <RsaUnPad+0x28>
 802062a:	68bb      	ldr	r3, [r7, #8]
 802062c:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8020630:	d302      	bcc.n	8020638 <RsaUnPad+0x2e>
        return BAD_FUNC_ARG;
 8020632:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8020636:	e0a7      	b.n	8020788 <RsaUnPad+0x17e>
    }

    if (padValue == RSA_BLOCK_TYPE_1) {
 8020638:	78fb      	ldrb	r3, [r7, #3]
 802063a:	2b01      	cmp	r3, #1
 802063c:	d134      	bne.n	80206a8 <RsaUnPad+0x9e>
        /* First byte must be 0x00 and Second byte, block type, 0x01 */
        if (pkcsBlock[0] != 0 || pkcsBlock[1] != RSA_BLOCK_TYPE_1) {
 802063e:	68fb      	ldr	r3, [r7, #12]
 8020640:	781b      	ldrb	r3, [r3, #0]
 8020642:	2b00      	cmp	r3, #0
 8020644:	d104      	bne.n	8020650 <RsaUnPad+0x46>
 8020646:	68fb      	ldr	r3, [r7, #12]
 8020648:	3301      	adds	r3, #1
 802064a:	781b      	ldrb	r3, [r3, #0]
 802064c:	2b01      	cmp	r3, #1
 802064e:	d002      	beq.n	8020656 <RsaUnPad+0x4c>
            WOLFSSL_MSG("RsaUnPad error, invalid formatting");
            return RSA_PAD_E;
 8020650:	f06f 03c8 	mvn.w	r3, #200	@ 0xc8
 8020654:	e098      	b.n	8020788 <RsaUnPad+0x17e>
        }

        /* check the padding until we find the separator */
        for (i = 2; i < pkcsBlockLen; ) {
 8020656:	2302      	movs	r3, #2
 8020658:	837b      	strh	r3, [r7, #26]
 802065a:	e008      	b.n	802066e <RsaUnPad+0x64>
            if (pkcsBlock[i++] != 0xFF) {
 802065c:	8b7b      	ldrh	r3, [r7, #26]
 802065e:	1c5a      	adds	r2, r3, #1
 8020660:	837a      	strh	r2, [r7, #26]
 8020662:	461a      	mov	r2, r3
 8020664:	68fb      	ldr	r3, [r7, #12]
 8020666:	4413      	add	r3, r2
 8020668:	781b      	ldrb	r3, [r3, #0]
 802066a:	2bff      	cmp	r3, #255	@ 0xff
 802066c:	d104      	bne.n	8020678 <RsaUnPad+0x6e>
        for (i = 2; i < pkcsBlockLen; ) {
 802066e:	8b7b      	ldrh	r3, [r7, #26]
 8020670:	68ba      	ldr	r2, [r7, #8]
 8020672:	429a      	cmp	r2, r3
 8020674:	d8f2      	bhi.n	802065c <RsaUnPad+0x52>
 8020676:	e000      	b.n	802067a <RsaUnPad+0x70>
                break;
 8020678:	bf00      	nop
            }
        }

        /* Minimum of 11 bytes of pre-message data and must have separator. */
        if (i < RSA_MIN_PAD_SZ || pkcsBlock[i-1] != 0) {
 802067a:	8b7b      	ldrh	r3, [r7, #26]
 802067c:	2b0a      	cmp	r3, #10
 802067e:	d906      	bls.n	802068e <RsaUnPad+0x84>
 8020680:	8b7b      	ldrh	r3, [r7, #26]
 8020682:	3b01      	subs	r3, #1
 8020684:	68fa      	ldr	r2, [r7, #12]
 8020686:	4413      	add	r3, r2
 8020688:	781b      	ldrb	r3, [r3, #0]
 802068a:	2b00      	cmp	r3, #0
 802068c:	d002      	beq.n	8020694 <RsaUnPad+0x8a>
            WOLFSSL_MSG("RsaUnPad error, bad formatting");
            return RSA_PAD_E;
 802068e:	f06f 03c8 	mvn.w	r3, #200	@ 0xc8
 8020692:	e079      	b.n	8020788 <RsaUnPad+0x17e>
        }

        *output = (byte *)(pkcsBlock + i);
 8020694:	8b7b      	ldrh	r3, [r7, #26]
 8020696:	68fa      	ldr	r2, [r7, #12]
 8020698:	441a      	add	r2, r3
 802069a:	687b      	ldr	r3, [r7, #4]
 802069c:	601a      	str	r2, [r3, #0]
        ret = (int)pkcsBlockLen - i;
 802069e:	68ba      	ldr	r2, [r7, #8]
 80206a0:	8b7b      	ldrh	r3, [r7, #26]
 80206a2:	1ad3      	subs	r3, r2, r3
 80206a4:	61fb      	str	r3, [r7, #28]
 80206a6:	e06e      	b.n	8020786 <RsaUnPad+0x17c>
    }
#ifndef WOLFSSL_RSA_VERIFY_ONLY
    else {
        unsigned int j;
        word16 pastSep = 0;
 80206a8:	2300      	movs	r3, #0
 80206aa:	827b      	strh	r3, [r7, #18]
        byte   invalid = 0;
 80206ac:	2300      	movs	r3, #0
 80206ae:	747b      	strb	r3, [r7, #17]

        i = 0;
 80206b0:	2300      	movs	r3, #0
 80206b2:	837b      	strh	r3, [r7, #26]
        /* Decrypted with private key - unpad must be constant time. */
        for (j = 2; j < pkcsBlockLen; j++) {
 80206b4:	2302      	movs	r3, #2
 80206b6:	617b      	str	r3, [r7, #20]
 80206b8:	e029      	b.n	802070e <RsaUnPad+0x104>
           /* Update i if not passed the separator and at separator. */
            i |= (word16)(~pastSep) & ctMask16Eq(pkcsBlock[j], 0x00) &
 80206ba:	8a7b      	ldrh	r3, [r7, #18]
 80206bc:	43db      	mvns	r3, r3
 80206be:	b29c      	uxth	r4, r3
 80206c0:	68fa      	ldr	r2, [r7, #12]
 80206c2:	697b      	ldr	r3, [r7, #20]
 80206c4:	4413      	add	r3, r2
 80206c6:	781b      	ldrb	r3, [r3, #0]
 80206c8:	2100      	movs	r1, #0
 80206ca:	4618      	mov	r0, r3
 80206cc:	f7ff fb11 	bl	801fcf2 <ctMask16Eq>
 80206d0:	4603      	mov	r3, r0
 80206d2:	4023      	ands	r3, r4
 80206d4:	b29a      	uxth	r2, r3
                (word16)(j + 1);
 80206d6:	697b      	ldr	r3, [r7, #20]
 80206d8:	b29b      	uxth	r3, r3
 80206da:	3301      	adds	r3, #1
 80206dc:	b29b      	uxth	r3, r3
            i |= (word16)(~pastSep) & ctMask16Eq(pkcsBlock[j], 0x00) &
 80206de:	4013      	ands	r3, r2
 80206e0:	b29b      	uxth	r3, r3
 80206e2:	b21a      	sxth	r2, r3
 80206e4:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80206e8:	4313      	orrs	r3, r2
 80206ea:	b21b      	sxth	r3, r3
 80206ec:	837b      	strh	r3, [r7, #26]
            pastSep |= ctMask16Eq(pkcsBlock[j], 0x00);
 80206ee:	68fa      	ldr	r2, [r7, #12]
 80206f0:	697b      	ldr	r3, [r7, #20]
 80206f2:	4413      	add	r3, r2
 80206f4:	781b      	ldrb	r3, [r3, #0]
 80206f6:	2100      	movs	r1, #0
 80206f8:	4618      	mov	r0, r3
 80206fa:	f7ff fafa 	bl	801fcf2 <ctMask16Eq>
 80206fe:	4603      	mov	r3, r0
 8020700:	461a      	mov	r2, r3
 8020702:	8a7b      	ldrh	r3, [r7, #18]
 8020704:	4313      	orrs	r3, r2
 8020706:	827b      	strh	r3, [r7, #18]
        for (j = 2; j < pkcsBlockLen; j++) {
 8020708:	697b      	ldr	r3, [r7, #20]
 802070a:	3301      	adds	r3, #1
 802070c:	617b      	str	r3, [r7, #20]
 802070e:	697a      	ldr	r2, [r7, #20]
 8020710:	68bb      	ldr	r3, [r7, #8]
 8020712:	429a      	cmp	r2, r3
 8020714:	d3d1      	bcc.n	80206ba <RsaUnPad+0xb0>
        }

        /* Minimum of 11 bytes of pre-message data - including leading 0x00. */
        invalid |= ctMaskLT(i, RSA_MIN_PAD_SZ);
 8020716:	8b7b      	ldrh	r3, [r7, #26]
 8020718:	210b      	movs	r1, #11
 802071a:	4618      	mov	r0, r3
 802071c:	f7ff fa86 	bl	801fc2c <ctMaskLT>
 8020720:	4603      	mov	r3, r0
 8020722:	461a      	mov	r2, r3
 8020724:	7c7b      	ldrb	r3, [r7, #17]
 8020726:	4313      	orrs	r3, r2
 8020728:	747b      	strb	r3, [r7, #17]
        /* Must have seen separator. */
        invalid |= (byte)~pastSep;
 802072a:	8a7b      	ldrh	r3, [r7, #18]
 802072c:	b2db      	uxtb	r3, r3
 802072e:	43db      	mvns	r3, r3
 8020730:	b2da      	uxtb	r2, r3
 8020732:	7c7b      	ldrb	r3, [r7, #17]
 8020734:	4313      	orrs	r3, r2
 8020736:	747b      	strb	r3, [r7, #17]
        /* First byte must be 0x00. */
        invalid |= ctMaskNotEq(pkcsBlock[0], 0x00);
 8020738:	68fb      	ldr	r3, [r7, #12]
 802073a:	781b      	ldrb	r3, [r3, #0]
 802073c:	2100      	movs	r1, #0
 802073e:	4618      	mov	r0, r3
 8020740:	f7ff faef 	bl	801fd22 <ctMaskNotEq>
 8020744:	4603      	mov	r3, r0
 8020746:	461a      	mov	r2, r3
 8020748:	7c7b      	ldrb	r3, [r7, #17]
 802074a:	4313      	orrs	r3, r2
 802074c:	747b      	strb	r3, [r7, #17]
        /* Check against expected block type: padValue */
        invalid |= ctMaskNotEq(pkcsBlock[1], padValue);
 802074e:	68fb      	ldr	r3, [r7, #12]
 8020750:	3301      	adds	r3, #1
 8020752:	781b      	ldrb	r3, [r3, #0]
 8020754:	461a      	mov	r2, r3
 8020756:	78fb      	ldrb	r3, [r7, #3]
 8020758:	4619      	mov	r1, r3
 802075a:	4610      	mov	r0, r2
 802075c:	f7ff fae1 	bl	801fd22 <ctMaskNotEq>
 8020760:	4603      	mov	r3, r0
 8020762:	461a      	mov	r2, r3
 8020764:	7c7b      	ldrb	r3, [r7, #17]
 8020766:	4313      	orrs	r3, r2
 8020768:	747b      	strb	r3, [r7, #17]

        *output = (byte *)(pkcsBlock + i);
 802076a:	8b7b      	ldrh	r3, [r7, #26]
 802076c:	68fa      	ldr	r2, [r7, #12]
 802076e:	441a      	add	r2, r3
 8020770:	687b      	ldr	r3, [r7, #4]
 8020772:	601a      	str	r2, [r3, #0]
        ret = ((int)-1 + (int)(invalid >> 7)) & ((int)pkcsBlockLen - i);
 8020774:	7c7b      	ldrb	r3, [r7, #17]
 8020776:	09db      	lsrs	r3, r3, #7
 8020778:	b2db      	uxtb	r3, r3
 802077a:	1e5a      	subs	r2, r3, #1
 802077c:	68b9      	ldr	r1, [r7, #8]
 802077e:	8b7b      	ldrh	r3, [r7, #26]
 8020780:	1acb      	subs	r3, r1, r3
 8020782:	4013      	ands	r3, r2
 8020784:	61fb      	str	r3, [r7, #28]
    }
#endif

    return ret;
 8020786:	69fb      	ldr	r3, [r7, #28]
}
 8020788:	4618      	mov	r0, r3
 802078a:	3724      	adds	r7, #36	@ 0x24
 802078c:	46bd      	mov	sp, r7
 802078e:	bd90      	pop	{r4, r7, pc}

08020790 <wc_RsaUnPad_ex>:
 */
int wc_RsaUnPad_ex(byte* pkcsBlock, word32 pkcsBlockLen, byte** out,
                   byte padValue, int padType, enum wc_HashType hType,
                   int mgf, byte* optLabel, word32 labelLen, int saltLen,
                   int bits, void* heap)
{
 8020790:	b580      	push	{r7, lr}
 8020792:	b08a      	sub	sp, #40	@ 0x28
 8020794:	af04      	add	r7, sp, #16
 8020796:	60f8      	str	r0, [r7, #12]
 8020798:	60b9      	str	r1, [r7, #8]
 802079a:	607a      	str	r2, [r7, #4]
 802079c:	70fb      	strb	r3, [r7, #3]
    int ret;

    switch (padType) {
 802079e:	6a3b      	ldr	r3, [r7, #32]
 80207a0:	2b02      	cmp	r3, #2
 80207a2:	d023      	beq.n	80207ec <wc_RsaUnPad_ex+0x5c>
 80207a4:	6a3b      	ldr	r3, [r7, #32]
 80207a6:	2b02      	cmp	r3, #2
 80207a8:	dc32      	bgt.n	8020810 <wc_RsaUnPad_ex+0x80>
 80207aa:	6a3b      	ldr	r3, [r7, #32]
 80207ac:	2b00      	cmp	r3, #0
 80207ae:	d003      	beq.n	80207b8 <wc_RsaUnPad_ex+0x28>
 80207b0:	6a3b      	ldr	r3, [r7, #32]
 80207b2:	2b01      	cmp	r3, #1
 80207b4:	d008      	beq.n	80207c8 <wc_RsaUnPad_ex+0x38>
 80207b6:	e02b      	b.n	8020810 <wc_RsaUnPad_ex+0x80>
        case WC_RSA_PKCSV15_PAD:
            /*WOLFSSL_MSG("wolfSSL Using RSA PKCSV15 un-padding");*/
            ret = RsaUnPad(pkcsBlock, pkcsBlockLen, out, padValue);
 80207b8:	78fb      	ldrb	r3, [r7, #3]
 80207ba:	687a      	ldr	r2, [r7, #4]
 80207bc:	68b9      	ldr	r1, [r7, #8]
 80207be:	68f8      	ldr	r0, [r7, #12]
 80207c0:	f7ff ff23 	bl	802060a <RsaUnPad>
 80207c4:	6178      	str	r0, [r7, #20]
            break;
 80207c6:	e026      	b.n	8020816 <wc_RsaUnPad_ex+0x86>

    #ifndef WC_NO_RSA_OAEP
        case WC_RSA_OAEP_PAD:
            WOLFSSL_MSG("wolfSSL Using RSA OAEP un-padding");
            ret = RsaUnPad_OAEP((byte*)pkcsBlock, pkcsBlockLen, out,
 80207c8:	f897 2024 	ldrb.w	r2, [r7, #36]	@ 0x24
 80207cc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80207ce:	9303      	str	r3, [sp, #12]
 80207d0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80207d2:	9302      	str	r3, [sp, #8]
 80207d4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80207d6:	9301      	str	r3, [sp, #4]
 80207d8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80207da:	9300      	str	r3, [sp, #0]
 80207dc:	4613      	mov	r3, r2
 80207de:	687a      	ldr	r2, [r7, #4]
 80207e0:	68b9      	ldr	r1, [r7, #8]
 80207e2:	68f8      	ldr	r0, [r7, #12]
 80207e4:	f7ff fd18 	bl	8020218 <RsaUnPad_OAEP>
 80207e8:	6178      	str	r0, [r7, #20]
                                        hType, mgf, optLabel, labelLen, heap);
            break;
 80207ea:	e014      	b.n	8020816 <wc_RsaUnPad_ex+0x86>
    #endif

    #ifdef WC_RSA_PSS
        case WC_RSA_PSS_PAD:
            WOLFSSL_MSG("wolfSSL Using RSA PSS un-padding");
            ret = RsaUnPad_PSS((byte*)pkcsBlock, pkcsBlockLen, out, hType, mgf,
 80207ec:	f897 2024 	ldrb.w	r2, [r7, #36]	@ 0x24
 80207f0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80207f2:	9303      	str	r3, [sp, #12]
 80207f4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80207f6:	9302      	str	r3, [sp, #8]
 80207f8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80207fa:	9301      	str	r3, [sp, #4]
 80207fc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80207fe:	9300      	str	r3, [sp, #0]
 8020800:	4613      	mov	r3, r2
 8020802:	687a      	ldr	r2, [r7, #4]
 8020804:	68b9      	ldr	r1, [r7, #8]
 8020806:	68f8      	ldr	r0, [r7, #12]
 8020808:	f7ff fe06 	bl	8020418 <RsaUnPad_PSS>
 802080c:	6178      	str	r0, [r7, #20]
                                                           saltLen, bits, heap);
            break;
 802080e:	e002      	b.n	8020816 <wc_RsaUnPad_ex+0x86>
            break;
    #endif /* WC_RSA_NO_PADDING */

        default:
            WOLFSSL_MSG("Unknown RSA UnPad Type");
            ret = RSA_PAD_E;
 8020810:	f06f 03c8 	mvn.w	r3, #200	@ 0xc8
 8020814:	617b      	str	r3, [r7, #20]
    (void)labelLen;
    (void)saltLen;
    (void)bits;
    (void)heap;

    return ret;
 8020816:	697b      	ldr	r3, [r7, #20]
}
 8020818:	4618      	mov	r0, r3
 802081a:	3718      	adds	r7, #24
 802081c:	46bd      	mov	sp, r7
 802081e:	bd80      	pop	{r7, pc}

08020820 <RsaFunctionPrivate>:
#endif

#if !defined(WOLFSSL_SP_MATH)
#if !defined(WOLFSSL_RSA_PUBLIC_ONLY) && !defined(WOLFSSL_RSA_VERIFY_ONLY)
static int RsaFunctionPrivate(mp_int* tmp, RsaKey* key, WC_RNG* rng)
{
 8020820:	b580      	push	{r7, lr}
 8020822:	b08e      	sub	sp, #56	@ 0x38
 8020824:	af00      	add	r7, sp, #0
 8020826:	60f8      	str	r0, [r7, #12]
 8020828:	60b9      	str	r1, [r7, #8]
 802082a:	607a      	str	r2, [r7, #4]
    int    ret = 0;
 802082c:	2300      	movs	r3, #0
 802082e:	637b      	str	r3, [r7, #52]	@ 0x34
#if defined(WC_RSA_BLINDING) && !defined(WC_NO_RNG)
    mp_digit mp = 0;
 8020830:	2300      	movs	r3, #0
 8020832:	613b      	str	r3, [r7, #16]
    DECL_MP_INT_SIZE_DYN(rnd, mp_bitsused(&key->n), RSA_MAX_SIZE);
 8020834:	2300      	movs	r3, #0
 8020836:	633b      	str	r3, [r7, #48]	@ 0x30
    DECL_MP_INT_SIZE_DYN(rndi, mp_bitsused(&key->n), RSA_MAX_SIZE);
 8020838:	2300      	movs	r3, #0
 802083a:	62fb      	str	r3, [r7, #44]	@ 0x2c
#endif /* WC_RSA_BLINDING && !WC_NO_RNG */

    (void)rng;

#if defined(WC_RSA_BLINDING) && !defined(WC_NO_RNG)
    NEW_MP_INT_SIZE(rnd, mp_bitsused(&key->n), key->heap, DYNAMIC_TYPE_RSA);
 802083c:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 8020840:	f7fe f922 	bl	801ea88 <wolfSSL_Malloc>
 8020844:	6338      	str	r0, [r7, #48]	@ 0x30
 8020846:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8020848:	2b00      	cmp	r3, #0
 802084a:	d005      	beq.n	8020858 <RsaFunctionPrivate+0x38>
 802084c:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8020850:	2100      	movs	r1, #0
 8020852:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 8020854:	f007 fe38 	bl	80284c8 <memset>
    NEW_MP_INT_SIZE(rndi, mp_bitsused(&key->n), key->heap, DYNAMIC_TYPE_RSA);
 8020858:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 802085c:	f7fe f914 	bl	801ea88 <wolfSSL_Malloc>
 8020860:	62f8      	str	r0, [r7, #44]	@ 0x2c
 8020862:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8020864:	2b00      	cmp	r3, #0
 8020866:	d005      	beq.n	8020874 <RsaFunctionPrivate+0x54>
 8020868:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 802086c:	2100      	movs	r1, #0
 802086e:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8020870:	f007 fe2a 	bl	80284c8 <memset>
#ifdef MP_INT_SIZE_CHECK_NULL
    if ((rnd == NULL) || (rndi == NULL)) {
 8020874:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8020876:	2b00      	cmp	r3, #0
 8020878:	d002      	beq.n	8020880 <RsaFunctionPrivate+0x60>
 802087a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802087c:	2b00      	cmp	r3, #0
 802087e:	d112      	bne.n	80208a6 <RsaFunctionPrivate+0x86>
        FREE_MP_INT_SIZE(rnd, key->heap, DYNAMIC_TYPE_RSA);
 8020880:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8020882:	61bb      	str	r3, [r7, #24]
 8020884:	69bb      	ldr	r3, [r7, #24]
 8020886:	2b00      	cmp	r3, #0
 8020888:	d002      	beq.n	8020890 <RsaFunctionPrivate+0x70>
 802088a:	69b8      	ldr	r0, [r7, #24]
 802088c:	f7fe f918 	bl	801eac0 <wolfSSL_Free>
        FREE_MP_INT_SIZE(rndi, key->heap, DYNAMIC_TYPE_RSA);
 8020890:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8020892:	617b      	str	r3, [r7, #20]
 8020894:	697b      	ldr	r3, [r7, #20]
 8020896:	2b00      	cmp	r3, #0
 8020898:	d002      	beq.n	80208a0 <RsaFunctionPrivate+0x80>
 802089a:	6978      	ldr	r0, [r7, #20]
 802089c:	f7fe f910 	bl	801eac0 <wolfSSL_Free>
        return MEMORY_E;
 80208a0:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 80208a4:	e15d      	b.n	8020b62 <RsaFunctionPrivate+0x342>
    }
#endif

    if ((INIT_MP_INT_SIZE(rnd, mp_bitsused(&key->n)) != MP_OKAY) ||
 80208a6:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 80208a8:	f005 fef3 	bl	8026692 <mp_init>
 80208ac:	4603      	mov	r3, r0
 80208ae:	2b00      	cmp	r3, #0
 80208b0:	d105      	bne.n	80208be <RsaFunctionPrivate+0x9e>
            (INIT_MP_INT_SIZE(rndi, mp_bitsused(&key->n)) != MP_OKAY)) {
 80208b2:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 80208b4:	f005 feed 	bl	8026692 <mp_init>
 80208b8:	4603      	mov	r3, r0
    if ((INIT_MP_INT_SIZE(rnd, mp_bitsused(&key->n)) != MP_OKAY) ||
 80208ba:	2b00      	cmp	r3, #0
 80208bc:	d002      	beq.n	80208c4 <RsaFunctionPrivate+0xa4>
        ret = MP_INIT_E;
 80208be:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 80208c2:	637b      	str	r3, [r7, #52]	@ 0x34
    }

    if (ret == 0) {
 80208c4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80208c6:	2b00      	cmp	r3, #0
 80208c8:	d10a      	bne.n	80208e0 <RsaFunctionPrivate+0xc0>
        /* blind */
        ret = mp_rand(rnd, get_digit_count(&key->n), rng);
 80208ca:	68bb      	ldr	r3, [r7, #8]
 80208cc:	4618      	mov	r0, r3
 80208ce:	f006 fde4 	bl	802749a <get_digit_count>
 80208d2:	4603      	mov	r3, r0
 80208d4:	687a      	ldr	r2, [r7, #4]
 80208d6:	4619      	mov	r1, r3
 80208d8:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 80208da:	f006 fea2 	bl	8027622 <mp_rand>
 80208de:	6378      	str	r0, [r7, #52]	@ 0x34
    }
    if (ret == 0) {
 80208e0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80208e2:	2b00      	cmp	r3, #0
 80208e4:	d10b      	bne.n	80208fe <RsaFunctionPrivate+0xde>
        /* rndi = 1/rnd mod n */
        if (mp_invmod(rnd, &key->n, rndi) != MP_OKAY) {
 80208e6:	68bb      	ldr	r3, [r7, #8]
 80208e8:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80208ea:	4619      	mov	r1, r3
 80208ec:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 80208ee:	f006 f81d 	bl	802692c <mp_invmod>
 80208f2:	4603      	mov	r3, r0
 80208f4:	2b00      	cmp	r3, #0
 80208f6:	d002      	beq.n	80208fe <RsaFunctionPrivate+0xde>
            ret = MP_INVMOD_E;
 80208f8:	f06f 0376 	mvn.w	r3, #118	@ 0x76
 80208fc:	637b      	str	r3, [r7, #52]	@ 0x34
        }
    }
    if (ret == 0) {
 80208fe:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020900:	2b00      	cmp	r3, #0
 8020902:	d10d      	bne.n	8020920 <RsaFunctionPrivate+0x100>
        mp_memzero_add("RSA Private rndi", rndi);
    #endif

        /* rnd = rnd^e */
    #ifndef WOLFSSL_SP_MATH_ALL
        if (mp_exptmod(rnd, &key->e, &key->n, rnd) != MP_OKAY) {
 8020904:	68bb      	ldr	r3, [r7, #8]
 8020906:	f503 710b 	add.w	r1, r3, #556	@ 0x22c
 802090a:	68ba      	ldr	r2, [r7, #8]
 802090c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802090e:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 8020910:	f006 f82e 	bl	8026970 <mp_exptmod>
 8020914:	4603      	mov	r3, r0
 8020916:	2b00      	cmp	r3, #0
 8020918:	d002      	beq.n	8020920 <RsaFunctionPrivate+0x100>
            ret = MP_EXPTMOD_E;
 802091a:	f06f 036f 	mvn.w	r3, #111	@ 0x6f
 802091e:	637b      	str	r3, [r7, #52]	@ 0x34
            ret = MP_EXPTMOD_E;
        }
    #endif
    }

    if (ret == 0) {
 8020920:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020922:	2b00      	cmp	r3, #0
 8020924:	d10b      	bne.n	802093e <RsaFunctionPrivate+0x11e>
        /* tmp = tmp*rnd mod n */
        if (mp_mulmod(tmp, rnd, &key->n, tmp) != MP_OKAY) {
 8020926:	68ba      	ldr	r2, [r7, #8]
 8020928:	68fb      	ldr	r3, [r7, #12]
 802092a:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 802092c:	68f8      	ldr	r0, [r7, #12]
 802092e:	f005 ffb4 	bl	802689a <mp_mulmod>
 8020932:	4603      	mov	r3, r0
 8020934:	2b00      	cmp	r3, #0
 8020936:	d002      	beq.n	802093e <RsaFunctionPrivate+0x11e>
            ret = MP_MULMOD_E;
 8020938:	f06f 0374 	mvn.w	r3, #116	@ 0x74
 802093c:	637b      	str	r3, [r7, #52]	@ 0x34
        if (mp_exptmod(tmp, &key->d, &key->n, tmp) != MP_OKAY) {
            ret = MP_EXPTMOD_E;
        }
    }
#else
    if (ret == 0 && (mp_iszero(&key->p) || mp_iszero(&key->q) ||
 802093e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020940:	2b00      	cmp	r3, #0
 8020942:	d132      	bne.n	80209aa <RsaFunctionPrivate+0x18a>
 8020944:	68bb      	ldr	r3, [r7, #8]
 8020946:	f203 6384 	addw	r3, r3, #1668	@ 0x684
 802094a:	4618      	mov	r0, r3
 802094c:	f006 f8fb 	bl	8026b46 <mp_iszero>
 8020950:	4603      	mov	r3, r0
 8020952:	2b00      	cmp	r3, #0
 8020954:	d11a      	bne.n	802098c <RsaFunctionPrivate+0x16c>
 8020956:	68bb      	ldr	r3, [r7, #8]
 8020958:	f503 630b 	add.w	r3, r3, #2224	@ 0x8b0
 802095c:	4618      	mov	r0, r3
 802095e:	f006 f8f2 	bl	8026b46 <mp_iszero>
 8020962:	4603      	mov	r3, r0
 8020964:	2b00      	cmp	r3, #0
 8020966:	d111      	bne.n	802098c <RsaFunctionPrivate+0x16c>
            mp_iszero(&key->dP) || mp_iszero(&key->dQ))) {
 8020968:	68bb      	ldr	r3, [r7, #8]
 802096a:	f603 23dc 	addw	r3, r3, #2780	@ 0xadc
 802096e:	4618      	mov	r0, r3
 8020970:	f006 f8e9 	bl	8026b46 <mp_iszero>
 8020974:	4603      	mov	r3, r0
    if (ret == 0 && (mp_iszero(&key->p) || mp_iszero(&key->q) ||
 8020976:	2b00      	cmp	r3, #0
 8020978:	d108      	bne.n	802098c <RsaFunctionPrivate+0x16c>
            mp_iszero(&key->dP) || mp_iszero(&key->dQ))) {
 802097a:	68bb      	ldr	r3, [r7, #8]
 802097c:	f603 5308 	addw	r3, r3, #3336	@ 0xd08
 8020980:	4618      	mov	r0, r3
 8020982:	f006 f8e0 	bl	8026b46 <mp_iszero>
 8020986:	4603      	mov	r3, r0
 8020988:	2b00      	cmp	r3, #0
 802098a:	d00e      	beq.n	80209aa <RsaFunctionPrivate+0x18a>
        if (mp_exptmod(tmp, &key->d, &key->n, tmp) != MP_OKAY) {
 802098c:	68bb      	ldr	r3, [r7, #8]
 802098e:	f503 618b 	add.w	r1, r3, #1112	@ 0x458
 8020992:	68ba      	ldr	r2, [r7, #8]
 8020994:	68fb      	ldr	r3, [r7, #12]
 8020996:	68f8      	ldr	r0, [r7, #12]
 8020998:	f005 ffea 	bl	8026970 <mp_exptmod>
 802099c:	4603      	mov	r3, r0
 802099e:	2b00      	cmp	r3, #0
 80209a0:	d070      	beq.n	8020a84 <RsaFunctionPrivate+0x264>
            ret = MP_EXPTMOD_E;
 80209a2:	f06f 036f 	mvn.w	r3, #111	@ 0x6f
 80209a6:	637b      	str	r3, [r7, #52]	@ 0x34
        if (mp_exptmod(tmp, &key->d, &key->n, tmp) != MP_OKAY) {
 80209a8:	e06c      	b.n	8020a84 <RsaFunctionPrivate+0x264>
        }
    }
    else if (ret == 0) {
 80209aa:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80209ac:	2b00      	cmp	r3, #0
 80209ae:	d169      	bne.n	8020a84 <RsaFunctionPrivate+0x264>
        mp_int* tmpa = tmp;
 80209b0:	68fb      	ldr	r3, [r7, #12]
 80209b2:	62bb      	str	r3, [r7, #40]	@ 0x28
#if defined(WC_RSA_BLINDING) && !defined(WC_NO_RNG)
        mp_int* tmpb = rnd;
 80209b4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80209b6:	627b      	str	r3, [r7, #36]	@ 0x24
            mp_memzero_add("RSA Sync tmpb", tmpb);
        }
    #endif

        /* tmpb = tmp^dQ mod q */
        if (ret == 0 && mp_exptmod(tmp, &key->dQ, &key->q, tmpb) != MP_OKAY)
 80209b8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80209ba:	2b00      	cmp	r3, #0
 80209bc:	d10f      	bne.n	80209de <RsaFunctionPrivate+0x1be>
 80209be:	68bb      	ldr	r3, [r7, #8]
 80209c0:	f603 5108 	addw	r1, r3, #3336	@ 0xd08
 80209c4:	68bb      	ldr	r3, [r7, #8]
 80209c6:	f503 620b 	add.w	r2, r3, #2224	@ 0x8b0
 80209ca:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80209cc:	68f8      	ldr	r0, [r7, #12]
 80209ce:	f005 ffcf 	bl	8026970 <mp_exptmod>
 80209d2:	4603      	mov	r3, r0
 80209d4:	2b00      	cmp	r3, #0
 80209d6:	d002      	beq.n	80209de <RsaFunctionPrivate+0x1be>
            ret = MP_EXPTMOD_E;
 80209d8:	f06f 036f 	mvn.w	r3, #111	@ 0x6f
 80209dc:	637b      	str	r3, [r7, #52]	@ 0x34

        /* tmpa = tmp^dP mod p */
        if (ret == 0 && mp_exptmod(tmp, &key->dP, &key->p, tmpa) != MP_OKAY)
 80209de:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80209e0:	2b00      	cmp	r3, #0
 80209e2:	d10f      	bne.n	8020a04 <RsaFunctionPrivate+0x1e4>
 80209e4:	68bb      	ldr	r3, [r7, #8]
 80209e6:	f603 21dc 	addw	r1, r3, #2780	@ 0xadc
 80209ea:	68bb      	ldr	r3, [r7, #8]
 80209ec:	f203 6284 	addw	r2, r3, #1668	@ 0x684
 80209f0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80209f2:	68f8      	ldr	r0, [r7, #12]
 80209f4:	f005 ffbc 	bl	8026970 <mp_exptmod>
 80209f8:	4603      	mov	r3, r0
 80209fa:	2b00      	cmp	r3, #0
 80209fc:	d002      	beq.n	8020a04 <RsaFunctionPrivate+0x1e4>
            ret = MP_EXPTMOD_E;
 80209fe:	f06f 036f 	mvn.w	r3, #111	@ 0x6f
 8020a02:	637b      	str	r3, [r7, #52]	@ 0x34
    #if (defined(WOLFSSL_SP_MATH) || (defined(WOLFSSL_SP_MATH_ALL)) && \
                                              !defined(WOLFSSL_SP_INT_NEGATIVE))
        if (ret == 0 && mp_submod(tmpa, tmpb, &key->p, tmp) != MP_OKAY)
            ret = MP_SUB_E;
    #else
        if (ret == 0 && mp_sub(tmpa, tmpb, tmp) != MP_OKAY)
 8020a04:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020a06:	2b00      	cmp	r3, #0
 8020a08:	d10a      	bne.n	8020a20 <RsaFunctionPrivate+0x200>
 8020a0a:	68fa      	ldr	r2, [r7, #12]
 8020a0c:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8020a0e:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8020a10:	f005 ff23 	bl	802685a <mp_sub>
 8020a14:	4603      	mov	r3, r0
 8020a16:	2b00      	cmp	r3, #0
 8020a18:	d002      	beq.n	8020a20 <RsaFunctionPrivate+0x200>
            ret = MP_SUB_E;
 8020a1a:	f06f 0371 	mvn.w	r3, #113	@ 0x71
 8020a1e:	637b      	str	r3, [r7, #52]	@ 0x34
    #endif

        if (ret == 0 && mp_mulmod(tmp, &key->u, &key->p, tmp) != MP_OKAY)
 8020a20:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020a22:	2b00      	cmp	r3, #0
 8020a24:	d10f      	bne.n	8020a46 <RsaFunctionPrivate+0x226>
 8020a26:	68bb      	ldr	r3, [r7, #8]
 8020a28:	f603 7134 	addw	r1, r3, #3892	@ 0xf34
 8020a2c:	68bb      	ldr	r3, [r7, #8]
 8020a2e:	f203 6284 	addw	r2, r3, #1668	@ 0x684
 8020a32:	68fb      	ldr	r3, [r7, #12]
 8020a34:	68f8      	ldr	r0, [r7, #12]
 8020a36:	f005 ff30 	bl	802689a <mp_mulmod>
 8020a3a:	4603      	mov	r3, r0
 8020a3c:	2b00      	cmp	r3, #0
 8020a3e:	d002      	beq.n	8020a46 <RsaFunctionPrivate+0x226>
            ret = MP_MULMOD_E;
 8020a40:	f06f 0374 	mvn.w	r3, #116	@ 0x74
 8020a44:	637b      	str	r3, [r7, #52]	@ 0x34

        /* tmp = tmpb + q * tmp */
        if (ret == 0 && mp_mul(tmp, &key->q, tmp) != MP_OKAY)
 8020a46:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020a48:	2b00      	cmp	r3, #0
 8020a4a:	d10d      	bne.n	8020a68 <RsaFunctionPrivate+0x248>
 8020a4c:	68bb      	ldr	r3, [r7, #8]
 8020a4e:	f503 630b 	add.w	r3, r3, #2224	@ 0x8b0
 8020a52:	68fa      	ldr	r2, [r7, #12]
 8020a54:	4619      	mov	r1, r3
 8020a56:	68f8      	ldr	r0, [r7, #12]
 8020a58:	f005 ff0f 	bl	802687a <mp_mul>
 8020a5c:	4603      	mov	r3, r0
 8020a5e:	2b00      	cmp	r3, #0
 8020a60:	d002      	beq.n	8020a68 <RsaFunctionPrivate+0x248>
            ret = MP_MUL_E;
 8020a62:	f06f 0373 	mvn.w	r3, #115	@ 0x73
 8020a66:	637b      	str	r3, [r7, #52]	@ 0x34

        if (ret == 0 && mp_add(tmp, tmpb, tmp) != MP_OKAY)
 8020a68:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020a6a:	2b00      	cmp	r3, #0
 8020a6c:	d10a      	bne.n	8020a84 <RsaFunctionPrivate+0x264>
 8020a6e:	68fa      	ldr	r2, [r7, #12]
 8020a70:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8020a72:	68f8      	ldr	r0, [r7, #12]
 8020a74:	f005 fee1 	bl	802683a <mp_add>
 8020a78:	4603      	mov	r3, r0
 8020a7a:	2b00      	cmp	r3, #0
 8020a7c:	d002      	beq.n	8020a84 <RsaFunctionPrivate+0x264>
            ret = MP_ADD_E;
 8020a7e:	f06f 0372 	mvn.w	r3, #114	@ 0x72
 8020a82:	637b      	str	r3, [r7, #52]	@ 0x34

#if defined(WC_RSA_BLINDING) && !defined(WC_NO_RNG)
    /* Multiply result (tmp) by blinding invertor (rndi).
     * Use Montgomery form to make operation more constant time.
     */
    if ((ret == 0) && (mp_montgomery_setup(&key->n, &mp) != MP_OKAY)) {
 8020a84:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020a86:	2b00      	cmp	r3, #0
 8020a88:	d10c      	bne.n	8020aa4 <RsaFunctionPrivate+0x284>
 8020a8a:	68bb      	ldr	r3, [r7, #8]
 8020a8c:	f107 0210 	add.w	r2, r7, #16
 8020a90:	4611      	mov	r1, r2
 8020a92:	4618      	mov	r0, r3
 8020a94:	f006 fada 	bl	802704c <mp_montgomery_setup>
 8020a98:	4603      	mov	r3, r0
 8020a9a:	2b00      	cmp	r3, #0
 8020a9c:	d002      	beq.n	8020aa4 <RsaFunctionPrivate+0x284>
        ret = MP_MULMOD_E;
 8020a9e:	f06f 0374 	mvn.w	r3, #116	@ 0x74
 8020aa2:	637b      	str	r3, [r7, #52]	@ 0x34
    }
    if ((ret == 0) && (mp_montgomery_calc_normalization(rnd, &key->n) !=
 8020aa4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020aa6:	2b00      	cmp	r3, #0
 8020aa8:	d10a      	bne.n	8020ac0 <RsaFunctionPrivate+0x2a0>
 8020aaa:	68bb      	ldr	r3, [r7, #8]
 8020aac:	4619      	mov	r1, r3
 8020aae:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 8020ab0:	f006 f87f 	bl	8026bb2 <mp_montgomery_calc_normalization>
 8020ab4:	4603      	mov	r3, r0
 8020ab6:	2b00      	cmp	r3, #0
 8020ab8:	d002      	beq.n	8020ac0 <RsaFunctionPrivate+0x2a0>
            MP_OKAY)) {
        ret = MP_MULMOD_E;
 8020aba:	f06f 0374 	mvn.w	r3, #116	@ 0x74
 8020abe:	637b      	str	r3, [r7, #52]	@ 0x34
    }
    /* Convert blinding invert to Montgomery form. */
    if ((ret == 0) && (mp_mul(rndi, rnd, rndi) != MP_OKAY)) {
 8020ac0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020ac2:	2b00      	cmp	r3, #0
 8020ac4:	d10a      	bne.n	8020adc <RsaFunctionPrivate+0x2bc>
 8020ac6:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8020ac8:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 8020aca:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8020acc:	f005 fed5 	bl	802687a <mp_mul>
 8020ad0:	4603      	mov	r3, r0
 8020ad2:	2b00      	cmp	r3, #0
 8020ad4:	d002      	beq.n	8020adc <RsaFunctionPrivate+0x2bc>
        ret = MP_MULMOD_E;
 8020ad6:	f06f 0374 	mvn.w	r3, #116	@ 0x74
 8020ada:	637b      	str	r3, [r7, #52]	@ 0x34
    }
    if ((ret == 0) && (mp_mod(rndi, &key->n, rndi) != MP_OKAY)) {
 8020adc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020ade:	2b00      	cmp	r3, #0
 8020ae0:	d10b      	bne.n	8020afa <RsaFunctionPrivate+0x2da>
 8020ae2:	68bb      	ldr	r3, [r7, #8]
 8020ae4:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8020ae6:	4619      	mov	r1, r3
 8020ae8:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8020aea:	f005 ff0f 	bl	802690c <mp_mod>
 8020aee:	4603      	mov	r3, r0
 8020af0:	2b00      	cmp	r3, #0
 8020af2:	d002      	beq.n	8020afa <RsaFunctionPrivate+0x2da>
        ret = MP_MULMOD_E;
 8020af4:	f06f 0374 	mvn.w	r3, #116	@ 0x74
 8020af8:	637b      	str	r3, [r7, #52]	@ 0x34
    }
    /* Multiply result by blinding invert. */
    if ((ret == 0) && (mp_mul(tmp, rndi, tmp) != MP_OKAY)) {
 8020afa:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020afc:	2b00      	cmp	r3, #0
 8020afe:	d10a      	bne.n	8020b16 <RsaFunctionPrivate+0x2f6>
 8020b00:	68fa      	ldr	r2, [r7, #12]
 8020b02:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8020b04:	68f8      	ldr	r0, [r7, #12]
 8020b06:	f005 feb8 	bl	802687a <mp_mul>
 8020b0a:	4603      	mov	r3, r0
 8020b0c:	2b00      	cmp	r3, #0
 8020b0e:	d002      	beq.n	8020b16 <RsaFunctionPrivate+0x2f6>
        ret = MP_MULMOD_E;
 8020b10:	f06f 0374 	mvn.w	r3, #116	@ 0x74
 8020b14:	637b      	str	r3, [r7, #52]	@ 0x34
    }
    /* Reduce result. */
    if ((ret == 0) && (mp_montgomery_reduce_ct(tmp, &key->n, mp) != MP_OKAY)) {
 8020b16:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020b18:	2b00      	cmp	r3, #0
 8020b1a:	d10b      	bne.n	8020b34 <RsaFunctionPrivate+0x314>
 8020b1c:	68b9      	ldr	r1, [r7, #8]
 8020b1e:	693a      	ldr	r2, [r7, #16]
 8020b20:	2301      	movs	r3, #1
 8020b22:	68f8      	ldr	r0, [r7, #12]
 8020b24:	f006 fa80 	bl	8027028 <mp_montgomery_reduce_ex>
 8020b28:	4603      	mov	r3, r0
 8020b2a:	2b00      	cmp	r3, #0
 8020b2c:	d002      	beq.n	8020b34 <RsaFunctionPrivate+0x314>
        ret = MP_MULMOD_E;
 8020b2e:	f06f 0374 	mvn.w	r3, #116	@ 0x74
 8020b32:	637b      	str	r3, [r7, #52]	@ 0x34
    }

    mp_forcezero(rndi);
 8020b34:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8020b36:	f005 fe21 	bl	802677c <mp_forcezero>
    mp_forcezero(rnd);
 8020b3a:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 8020b3c:	f005 fe1e 	bl	802677c <mp_forcezero>
    FREE_MP_INT_SIZE(rndi, key->heap, DYNAMIC_TYPE_RSA);
 8020b40:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8020b42:	623b      	str	r3, [r7, #32]
 8020b44:	6a3b      	ldr	r3, [r7, #32]
 8020b46:	2b00      	cmp	r3, #0
 8020b48:	d002      	beq.n	8020b50 <RsaFunctionPrivate+0x330>
 8020b4a:	6a38      	ldr	r0, [r7, #32]
 8020b4c:	f7fd ffb8 	bl	801eac0 <wolfSSL_Free>
    FREE_MP_INT_SIZE(rnd, key->heap, DYNAMIC_TYPE_RSA);
 8020b50:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8020b52:	61fb      	str	r3, [r7, #28]
 8020b54:	69fb      	ldr	r3, [r7, #28]
 8020b56:	2b00      	cmp	r3, #0
 8020b58:	d002      	beq.n	8020b60 <RsaFunctionPrivate+0x340>
 8020b5a:	69f8      	ldr	r0, [r7, #28]
 8020b5c:	f7fd ffb0 	bl	801eac0 <wolfSSL_Free>
#if !defined(MP_INT_SIZE_CHECK_NULL) && defined(WOLFSSL_CHECK_MEM_ZERO)
    mp_memzero_check(rnd);
    mp_memzero_check(rndi);
#endif
#endif /* WC_RSA_BLINDING && !WC_NO_RNG */
    return ret;
 8020b60:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
 8020b62:	4618      	mov	r0, r3
 8020b64:	3738      	adds	r7, #56	@ 0x38
 8020b66:	46bd      	mov	sp, r7
 8020b68:	bd80      	pop	{r7, pc}

08020b6a <RsaFunctionSync>:
#endif

static int RsaFunctionSync(const byte* in, word32 inLen, byte* out,
    word32* outLen, int type, RsaKey* key, WC_RNG* rng)
{
 8020b6a:	b580      	push	{r7, lr}
 8020b6c:	b088      	sub	sp, #32
 8020b6e:	af00      	add	r7, sp, #0
 8020b70:	60f8      	str	r0, [r7, #12]
 8020b72:	60b9      	str	r1, [r7, #8]
 8020b74:	607a      	str	r2, [r7, #4]
 8020b76:	603b      	str	r3, [r7, #0]
    DECL_MP_INT_SIZE_DYN(tmp, mp_bitsused(&key->n), RSA_MAX_SIZE);
 8020b78:	2300      	movs	r3, #0
 8020b7a:	61bb      	str	r3, [r7, #24]
    int    ret = 0;
 8020b7c:	2300      	movs	r3, #0
 8020b7e:	61fb      	str	r3, [r7, #28]

    (void)rng;

    NEW_MP_INT_SIZE(tmp, mp_bitsused(&key->n), key->heap, DYNAMIC_TYPE_RSA);
 8020b80:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 8020b84:	f7fd ff80 	bl	801ea88 <wolfSSL_Malloc>
 8020b88:	61b8      	str	r0, [r7, #24]
 8020b8a:	69bb      	ldr	r3, [r7, #24]
 8020b8c:	2b00      	cmp	r3, #0
 8020b8e:	d005      	beq.n	8020b9c <RsaFunctionSync+0x32>
 8020b90:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8020b94:	2100      	movs	r1, #0
 8020b96:	69b8      	ldr	r0, [r7, #24]
 8020b98:	f007 fc96 	bl	80284c8 <memset>
#ifdef MP_INT_SIZE_CHECK_NULL
    if (tmp == NULL) {
 8020b9c:	69bb      	ldr	r3, [r7, #24]
 8020b9e:	2b00      	cmp	r3, #0
 8020ba0:	d102      	bne.n	8020ba8 <RsaFunctionSync+0x3e>
        WOLFSSL_MSG("NEW_MP_INT_SIZE tmp is NULL, return MEMORY_E");
        return MEMORY_E;
 8020ba2:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8020ba6:	e05c      	b.n	8020c62 <RsaFunctionSync+0xf8>
    }
#endif

    if (INIT_MP_INT_SIZE(tmp, mp_bitsused(&key->n)) != MP_OKAY) {
 8020ba8:	69b8      	ldr	r0, [r7, #24]
 8020baa:	f005 fd72 	bl	8026692 <mp_init>
 8020bae:	4603      	mov	r3, r0
 8020bb0:	2b00      	cmp	r3, #0
 8020bb2:	d002      	beq.n	8020bba <RsaFunctionSync+0x50>
        WOLFSSL_MSG("INIT_MP_INT_SIZE failed.");
        ret = MP_INIT_E;
 8020bb4:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 8020bb8:	61fb      	str	r3, [r7, #28]
    }

#ifndef TEST_UNPAD_CONSTANT_TIME
    if (ret == 0 && mp_read_unsigned_bin(tmp, in, inLen) != MP_OKAY)
 8020bba:	69fb      	ldr	r3, [r7, #28]
 8020bbc:	2b00      	cmp	r3, #0
 8020bbe:	d10b      	bne.n	8020bd8 <RsaFunctionSync+0x6e>
 8020bc0:	68bb      	ldr	r3, [r7, #8]
 8020bc2:	461a      	mov	r2, r3
 8020bc4:	68f9      	ldr	r1, [r7, #12]
 8020bc6:	69b8      	ldr	r0, [r7, #24]
 8020bc8:	f005 ff3c 	bl	8026a44 <mp_read_unsigned_bin>
 8020bcc:	4603      	mov	r3, r0
 8020bce:	2b00      	cmp	r3, #0
 8020bd0:	d002      	beq.n	8020bd8 <RsaFunctionSync+0x6e>
        ret = MP_READ_E;
 8020bd2:	f06f 036e 	mvn.w	r3, #110	@ 0x6e
 8020bd6:	61fb      	str	r3, [r7, #28]
    if (ret == 0) {
        mp_memzero_add("RSA sync tmp", tmp);
    }
#endif

    if (ret == 0) {
 8020bd8:	69fb      	ldr	r3, [r7, #28]
 8020bda:	2b00      	cmp	r3, #0
 8020bdc:	d125      	bne.n	8020c2a <RsaFunctionSync+0xc0>
        switch(type) {
 8020bde:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8020be0:	2b01      	cmp	r3, #1
 8020be2:	dc03      	bgt.n	8020bec <RsaFunctionSync+0x82>
 8020be4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8020be6:	2b00      	cmp	r3, #0
 8020be8:	da0b      	bge.n	8020c02 <RsaFunctionSync+0x98>
 8020bea:	e019      	b.n	8020c20 <RsaFunctionSync+0xb6>
 8020bec:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8020bee:	3b02      	subs	r3, #2
 8020bf0:	2b01      	cmp	r3, #1
 8020bf2:	d815      	bhi.n	8020c20 <RsaFunctionSync+0xb6>
    #if !defined(WOLFSSL_RSA_PUBLIC_ONLY) && !defined(WOLFSSL_RSA_VERIFY_ONLY)
        case RSA_PRIVATE_DECRYPT:
        case RSA_PRIVATE_ENCRYPT:
        {
            ret = RsaFunctionPrivate(tmp, key, rng);
 8020bf4:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8020bf6:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8020bf8:	69b8      	ldr	r0, [r7, #24]
 8020bfa:	f7ff fe11 	bl	8020820 <RsaFunctionPrivate>
 8020bfe:	61f8      	str	r0, [r7, #28]
            break;
 8020c00:	e013      	b.n	8020c2a <RsaFunctionSync+0xc0>
        }
    #endif
        case RSA_PUBLIC_ENCRYPT:
        case RSA_PUBLIC_DECRYPT:
            if (mp_exptmod_nct(tmp, &key->e, &key->n, tmp) != MP_OKAY) {
 8020c02:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8020c04:	f503 710b 	add.w	r1, r3, #556	@ 0x22c
 8020c08:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8020c0a:	69bb      	ldr	r3, [r7, #24]
 8020c0c:	69b8      	ldr	r0, [r7, #24]
 8020c0e:	f005 fec1 	bl	8026994 <mp_exptmod_nct>
 8020c12:	4603      	mov	r3, r0
 8020c14:	2b00      	cmp	r3, #0
 8020c16:	d007      	beq.n	8020c28 <RsaFunctionSync+0xbe>
                WOLFSSL_MSG("mp_exptmod_nct failed");
                ret = MP_EXPTMOD_E;
 8020c18:	f06f 036f 	mvn.w	r3, #111	@ 0x6f
 8020c1c:	61fb      	str	r3, [r7, #28]
            }
            break;
 8020c1e:	e003      	b.n	8020c28 <RsaFunctionSync+0xbe>
        default:
            ret = RSA_WRONG_TYPE_E;
 8020c20:	f06f 0381 	mvn.w	r3, #129	@ 0x81
 8020c24:	61fb      	str	r3, [r7, #28]
            break;
 8020c26:	e000      	b.n	8020c2a <RsaFunctionSync+0xc0>
            break;
 8020c28:	bf00      	nop
        }
    }

    if (ret == 0) {
 8020c2a:	69fb      	ldr	r3, [r7, #28]
 8020c2c:	2b00      	cmp	r3, #0
 8020c2e:	d10c      	bne.n	8020c4a <RsaFunctionSync+0xe0>
        WOLFSSL_MSG("mp_to_unsigned_bin_len_ct...");
        if (mp_to_unsigned_bin_len_ct(tmp, out, (int)*outLen) != MP_OKAY) {
 8020c30:	683b      	ldr	r3, [r7, #0]
 8020c32:	681b      	ldr	r3, [r3, #0]
 8020c34:	461a      	mov	r2, r3
 8020c36:	6879      	ldr	r1, [r7, #4]
 8020c38:	69b8      	ldr	r0, [r7, #24]
 8020c3a:	f005 fef3 	bl	8026a24 <mp_to_unsigned_bin_len>
 8020c3e:	4603      	mov	r3, r0
 8020c40:	2b00      	cmp	r3, #0
 8020c42:	d002      	beq.n	8020c4a <RsaFunctionSync+0xe0>
            WOLFSSL_MSG("mp_to_unsigned_bin_len_ct failed");
            ret = MP_TO_E;
 8020c44:	f06f 0370 	mvn.w	r3, #112	@ 0x70
 8020c48:	61fb      	str	r3, [r7, #28]
    (void)type;
    (void)key;
    XMEMCPY(out, in, inLen);
#endif

    mp_forcezero(tmp);
 8020c4a:	69b8      	ldr	r0, [r7, #24]
 8020c4c:	f005 fd96 	bl	802677c <mp_forcezero>
    FREE_MP_INT_SIZE(tmp, key->heap, DYNAMIC_TYPE_RSA);
 8020c50:	69bb      	ldr	r3, [r7, #24]
 8020c52:	617b      	str	r3, [r7, #20]
 8020c54:	697b      	ldr	r3, [r7, #20]
 8020c56:	2b00      	cmp	r3, #0
 8020c58:	d002      	beq.n	8020c60 <RsaFunctionSync+0xf6>
 8020c5a:	6978      	ldr	r0, [r7, #20]
 8020c5c:	f7fd ff30 	bl	801eac0 <wolfSSL_Free>
#if !defined(MP_INT_SIZE_CHECK_NULL) && defined(WOLFSSL_CHECK_MEM_ZERO)
    mp_memzero_check(tmp);
#endif
    return ret;
 8020c60:	69fb      	ldr	r3, [r7, #28]
}
 8020c62:	4618      	mov	r0, r3
 8020c64:	3720      	adds	r7, #32
 8020c66:	46bd      	mov	sp, r7
 8020c68:	bd80      	pop	{r7, pc}

08020c6a <wc_RsaFunctionSync>:
#endif /* !WOLFSSL_SP_MATH */

static int wc_RsaFunctionSync(const byte* in, word32 inLen, byte* out,
                          word32* outLen, int type, RsaKey* key, WC_RNG* rng)
{
 8020c6a:	b580      	push	{r7, lr}
 8020c6c:	b08a      	sub	sp, #40	@ 0x28
 8020c6e:	af04      	add	r7, sp, #16
 8020c70:	60f8      	str	r0, [r7, #12]
 8020c72:	60b9      	str	r1, [r7, #8]
 8020c74:	607a      	str	r2, [r7, #4]
 8020c76:	603b      	str	r3, [r7, #0]
    int ret;
    word32 keyLen;

    ret = wc_RsaEncryptSize(key);
 8020c78:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8020c7a:	f000 fbb3 	bl	80213e4 <wc_RsaEncryptSize>
 8020c7e:	6178      	str	r0, [r7, #20]
    if (ret < 0) {
 8020c80:	697b      	ldr	r3, [r7, #20]
 8020c82:	2b00      	cmp	r3, #0
 8020c84:	da01      	bge.n	8020c8a <wc_RsaFunctionSync+0x20>
#ifdef DEBUG_WOLFSSL
        WOLFSSL_MSG_EX("wc_RsaEncryptSize failed err = %d", ret);
#endif
        return ret;
 8020c86:	697b      	ldr	r3, [r7, #20]
 8020c88:	e02d      	b.n	8020ce6 <wc_RsaFunctionSync+0x7c>
    }
    keyLen = (word32)ret;
 8020c8a:	697b      	ldr	r3, [r7, #20]
 8020c8c:	613b      	str	r3, [r7, #16]

    if (inLen > keyLen) {
 8020c8e:	68ba      	ldr	r2, [r7, #8]
 8020c90:	693b      	ldr	r3, [r7, #16]
 8020c92:	429a      	cmp	r2, r3
 8020c94:	d902      	bls.n	8020c9c <wc_RsaFunctionSync+0x32>
        WOLFSSL_MSG("Expected that inLen be no longer RSA key length");
        return BAD_FUNC_ARG;
 8020c96:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8020c9a:	e024      	b.n	8020ce6 <wc_RsaFunctionSync+0x7c>
    }
    if (keyLen > *outLen) {
 8020c9c:	683b      	ldr	r3, [r7, #0]
 8020c9e:	681b      	ldr	r3, [r3, #0]
 8020ca0:	693a      	ldr	r2, [r7, #16]
 8020ca2:	429a      	cmp	r2, r3
 8020ca4:	d902      	bls.n	8020cac <wc_RsaFunctionSync+0x42>
        WOLFSSL_MSG("Expected that outLen be no shorter RSA key length");
        return RSA_BUFFER_E;
 8020ca6:	f06f 0382 	mvn.w	r3, #130	@ 0x82
 8020caa:	e01c      	b.n	8020ce6 <wc_RsaFunctionSync+0x7c>
    }

    if (mp_iseven(&key->n)) {
 8020cac:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8020cae:	681b      	ldr	r3, [r3, #0]
 8020cb0:	2b00      	cmp	r3, #0
 8020cb2:	dd08      	ble.n	8020cc6 <wc_RsaFunctionSync+0x5c>
 8020cb4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8020cb6:	68db      	ldr	r3, [r3, #12]
 8020cb8:	f003 0301 	and.w	r3, r3, #1
 8020cbc:	2b00      	cmp	r3, #0
 8020cbe:	d102      	bne.n	8020cc6 <wc_RsaFunctionSync+0x5c>
        WOLFSSL_MSG("MP_VAL is even");
        return MP_VAL;
 8020cc0:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8020cc4:	e00f      	b.n	8020ce6 <wc_RsaFunctionSync+0x7c>
#else
    WOLFSSL_MSG("SP Key Size Error");
    return WC_KEY_SIZE_E;
#endif
#else
    *outLen = keyLen;
 8020cc6:	683b      	ldr	r3, [r7, #0]
 8020cc8:	693a      	ldr	r2, [r7, #16]
 8020cca:	601a      	str	r2, [r3, #0]
    return RsaFunctionSync(in, inLen, out, outLen, type, key, rng);
 8020ccc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8020cce:	9302      	str	r3, [sp, #8]
 8020cd0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8020cd2:	9301      	str	r3, [sp, #4]
 8020cd4:	6a3b      	ldr	r3, [r7, #32]
 8020cd6:	9300      	str	r3, [sp, #0]
 8020cd8:	683b      	ldr	r3, [r7, #0]
 8020cda:	687a      	ldr	r2, [r7, #4]
 8020cdc:	68b9      	ldr	r1, [r7, #8]
 8020cde:	68f8      	ldr	r0, [r7, #12]
 8020ce0:	f7ff ff43 	bl	8020b6a <RsaFunctionSync>
 8020ce4:	4603      	mov	r3, r0
#endif /* WOLFSSL_SP_MATH */
}
 8020ce6:	4618      	mov	r0, r3
 8020ce8:	3718      	adds	r7, #24
 8020cea:	46bd      	mov	sp, r7
 8020cec:	bd80      	pop	{r7, pc}

08020cee <RsaFunctionCheckIn>:
#if !defined(WOLFSSL_RSA_VERIFY_ONLY) && !defined(TEST_UNPAD_CONSTANT_TIME) && \
    !defined(NO_RSA_BOUNDS_CHECK)
/* Check that 1 < in < n-1. (Requirement of 800-56B.) */
int RsaFunctionCheckIn(const byte* in, word32 inLen, RsaKey* key,
    int checkSmallCt)
{
 8020cee:	b580      	push	{r7, lr}
 8020cf0:	b088      	sub	sp, #32
 8020cf2:	af00      	add	r7, sp, #0
 8020cf4:	60f8      	str	r0, [r7, #12]
 8020cf6:	60b9      	str	r1, [r7, #8]
 8020cf8:	607a      	str	r2, [r7, #4]
 8020cfa:	603b      	str	r3, [r7, #0]
    int ret = 0;
 8020cfc:	2300      	movs	r3, #0
 8020cfe:	61fb      	str	r3, [r7, #28]
    DECL_MP_INT_SIZE_DYN(c, mp_bitsused(&key->n), RSA_MAX_SIZE);
 8020d00:	2300      	movs	r3, #0
 8020d02:	61bb      	str	r3, [r7, #24]

    NEW_MP_INT_SIZE(c, mp_bitsused(&key->n), key->heap, DYNAMIC_TYPE_RSA);
 8020d04:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 8020d08:	f7fd febe 	bl	801ea88 <wolfSSL_Malloc>
 8020d0c:	61b8      	str	r0, [r7, #24]
 8020d0e:	69bb      	ldr	r3, [r7, #24]
 8020d10:	2b00      	cmp	r3, #0
 8020d12:	d005      	beq.n	8020d20 <RsaFunctionCheckIn+0x32>
 8020d14:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8020d18:	2100      	movs	r1, #0
 8020d1a:	69b8      	ldr	r0, [r7, #24]
 8020d1c:	f007 fbd4 	bl	80284c8 <memset>
#ifdef MP_INT_SIZE_CHECK_NULL
    if (c == NULL)
 8020d20:	69bb      	ldr	r3, [r7, #24]
 8020d22:	2b00      	cmp	r3, #0
 8020d24:	d102      	bne.n	8020d2c <RsaFunctionCheckIn+0x3e>
        ret = MEMORY_E;
 8020d26:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8020d2a:	61fb      	str	r3, [r7, #28]
#endif

    if (ret == 0 && INIT_MP_INT_SIZE(c, mp_bitsused(&key->n)) != MP_OKAY) {
 8020d2c:	69fb      	ldr	r3, [r7, #28]
 8020d2e:	2b00      	cmp	r3, #0
 8020d30:	d108      	bne.n	8020d44 <RsaFunctionCheckIn+0x56>
 8020d32:	69b8      	ldr	r0, [r7, #24]
 8020d34:	f005 fcad 	bl	8026692 <mp_init>
 8020d38:	4603      	mov	r3, r0
 8020d3a:	2b00      	cmp	r3, #0
 8020d3c:	d002      	beq.n	8020d44 <RsaFunctionCheckIn+0x56>
        ret = MP_INIT_E;
 8020d3e:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 8020d42:	61fb      	str	r3, [r7, #28]
    }
    if (ret == 0) {
 8020d44:	69fb      	ldr	r3, [r7, #28]
 8020d46:	2b00      	cmp	r3, #0
 8020d48:	d10b      	bne.n	8020d62 <RsaFunctionCheckIn+0x74>
        if (mp_read_unsigned_bin(c, in, inLen) != 0)
 8020d4a:	68bb      	ldr	r3, [r7, #8]
 8020d4c:	461a      	mov	r2, r3
 8020d4e:	68f9      	ldr	r1, [r7, #12]
 8020d50:	69b8      	ldr	r0, [r7, #24]
 8020d52:	f005 fe77 	bl	8026a44 <mp_read_unsigned_bin>
 8020d56:	4603      	mov	r3, r0
 8020d58:	2b00      	cmp	r3, #0
 8020d5a:	d002      	beq.n	8020d62 <RsaFunctionCheckIn+0x74>
            ret = MP_READ_E;
 8020d5c:	f06f 036e 	mvn.w	r3, #110	@ 0x6e
 8020d60:	61fb      	str	r3, [r7, #28]
    }
    if (ret == 0) {
 8020d62:	69fb      	ldr	r3, [r7, #28]
 8020d64:	2b00      	cmp	r3, #0
 8020d66:	d10c      	bne.n	8020d82 <RsaFunctionCheckIn+0x94>
        /* check c > 1 */
        if (checkSmallCt && (mp_cmp_d(c, 1) != MP_GT))
 8020d68:	683b      	ldr	r3, [r7, #0]
 8020d6a:	2b00      	cmp	r3, #0
 8020d6c:	d009      	beq.n	8020d82 <RsaFunctionCheckIn+0x94>
 8020d6e:	2101      	movs	r1, #1
 8020d70:	69b8      	ldr	r0, [r7, #24]
 8020d72:	f005 fe2f 	bl	80269d4 <mp_cmp_d>
 8020d76:	4603      	mov	r3, r0
 8020d78:	2b01      	cmp	r3, #1
 8020d7a:	d002      	beq.n	8020d82 <RsaFunctionCheckIn+0x94>
            ret = RSA_OUT_OF_RANGE_E;
 8020d7c:	f06f 03fc 	mvn.w	r3, #252	@ 0xfc
 8020d80:	61fb      	str	r3, [r7, #28]
    }
    if (ret == 0) {
 8020d82:	69fb      	ldr	r3, [r7, #28]
 8020d84:	2b00      	cmp	r3, #0
 8020d86:	d10a      	bne.n	8020d9e <RsaFunctionCheckIn+0xb0>
        /* add c+1 */
        if (mp_add_d(c, 1, c) != MP_OKAY)
 8020d88:	69ba      	ldr	r2, [r7, #24]
 8020d8a:	2101      	movs	r1, #1
 8020d8c:	69b8      	ldr	r0, [r7, #24]
 8020d8e:	f005 ffe0 	bl	8026d52 <mp_add_d>
 8020d92:	4603      	mov	r3, r0
 8020d94:	2b00      	cmp	r3, #0
 8020d96:	d002      	beq.n	8020d9e <RsaFunctionCheckIn+0xb0>
            ret = MP_ADD_E;
 8020d98:	f06f 0372 	mvn.w	r3, #114	@ 0x72
 8020d9c:	61fb      	str	r3, [r7, #28]
    }
    if (ret == 0) {
 8020d9e:	69fb      	ldr	r3, [r7, #28]
 8020da0:	2b00      	cmp	r3, #0
 8020da2:	d10b      	bne.n	8020dbc <RsaFunctionCheckIn+0xce>
        /* check c+1 < n */
        if (mp_cmp(c, &key->n) != MP_LT)
 8020da4:	687b      	ldr	r3, [r7, #4]
 8020da6:	4619      	mov	r1, r3
 8020da8:	69b8      	ldr	r0, [r7, #24]
 8020daa:	f005 fe05 	bl	80269b8 <mp_cmp>
 8020dae:	4603      	mov	r3, r0
 8020db0:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8020db4:	d002      	beq.n	8020dbc <RsaFunctionCheckIn+0xce>
            ret = RSA_OUT_OF_RANGE_E;
 8020db6:	f06f 03fc 	mvn.w	r3, #252	@ 0xfc
 8020dba:	61fb      	str	r3, [r7, #28]
    }
    mp_clear(c);
 8020dbc:	69b8      	ldr	r0, [r7, #24]
 8020dbe:	f005 fcf2 	bl	80267a6 <mp_clear>

    FREE_MP_INT_SIZE(c, key->heap, DYNAMIC_TYPE_RSA);
 8020dc2:	69bb      	ldr	r3, [r7, #24]
 8020dc4:	617b      	str	r3, [r7, #20]
 8020dc6:	697b      	ldr	r3, [r7, #20]
 8020dc8:	2b00      	cmp	r3, #0
 8020dca:	d002      	beq.n	8020dd2 <RsaFunctionCheckIn+0xe4>
 8020dcc:	6978      	ldr	r0, [r7, #20]
 8020dce:	f7fd fe77 	bl	801eac0 <wolfSSL_Free>

    return ret;
 8020dd2:	69fb      	ldr	r3, [r7, #28]
}
 8020dd4:	4618      	mov	r0, r3
 8020dd6:	3720      	adds	r7, #32
 8020dd8:	46bd      	mov	sp, r7
 8020dda:	bd80      	pop	{r7, pc}

08020ddc <wc_RsaFunction_ex>:
#endif /* WOLF_CRYPTO_CB_ONLY_RSA */

static int wc_RsaFunction_ex(const byte* in, word32 inLen, byte* out,
                             word32* outLen, int type, RsaKey* key, WC_RNG* rng,
                             int checkSmallCt)
{
 8020ddc:	b580      	push	{r7, lr}
 8020dde:	b08a      	sub	sp, #40	@ 0x28
 8020de0:	af04      	add	r7, sp, #16
 8020de2:	60f8      	str	r0, [r7, #12]
 8020de4:	60b9      	str	r1, [r7, #8]
 8020de6:	607a      	str	r2, [r7, #4]
 8020de8:	603b      	str	r3, [r7, #0]
    int ret = 0;
 8020dea:	2300      	movs	r3, #0
 8020dec:	617b      	str	r3, [r7, #20]
    (void)checkSmallCt;
#if defined(WOLF_CRYPTO_CB) && defined(WOLF_CRYPTO_CB_RSA_PAD)
    RsaPadding padding;
#endif

    if (key == NULL || in == NULL || inLen == 0 || out == NULL ||
 8020dee:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8020df0:	2b00      	cmp	r3, #0
 8020df2:	d013      	beq.n	8020e1c <wc_RsaFunction_ex+0x40>
 8020df4:	68fb      	ldr	r3, [r7, #12]
 8020df6:	2b00      	cmp	r3, #0
 8020df8:	d010      	beq.n	8020e1c <wc_RsaFunction_ex+0x40>
 8020dfa:	68bb      	ldr	r3, [r7, #8]
 8020dfc:	2b00      	cmp	r3, #0
 8020dfe:	d00d      	beq.n	8020e1c <wc_RsaFunction_ex+0x40>
 8020e00:	687b      	ldr	r3, [r7, #4]
 8020e02:	2b00      	cmp	r3, #0
 8020e04:	d00a      	beq.n	8020e1c <wc_RsaFunction_ex+0x40>
 8020e06:	683b      	ldr	r3, [r7, #0]
 8020e08:	2b00      	cmp	r3, #0
 8020e0a:	d007      	beq.n	8020e1c <wc_RsaFunction_ex+0x40>
            outLen == NULL || *outLen == 0 || type == RSA_TYPE_UNKNOWN) {
 8020e0c:	683b      	ldr	r3, [r7, #0]
 8020e0e:	681b      	ldr	r3, [r3, #0]
 8020e10:	2b00      	cmp	r3, #0
 8020e12:	d003      	beq.n	8020e1c <wc_RsaFunction_ex+0x40>
 8020e14:	6a3b      	ldr	r3, [r7, #32]
 8020e16:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8020e1a:	d102      	bne.n	8020e22 <wc_RsaFunction_ex+0x46>
        return BAD_FUNC_ARG;
 8020e1c:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8020e20:	e034      	b.n	8020e8c <wc_RsaFunction_ex+0xb0>
#else /* !WOLF_CRYPTO_CB_ONLY_RSA */
    SAVE_VECTOR_REGISTERS(return _svr_ret;);

#if !defined(WOLFSSL_RSA_VERIFY_ONLY) && !defined(TEST_UNPAD_CONSTANT_TIME) && \
    !defined(NO_RSA_BOUNDS_CHECK)
    if (type == RSA_PRIVATE_DECRYPT &&
 8020e22:	6a3b      	ldr	r3, [r7, #32]
 8020e24:	2b03      	cmp	r3, #3
 8020e26:	d112      	bne.n	8020e4e <wc_RsaFunction_ex+0x72>
        key->state == RSA_STATE_DECRYPT_EXPTMOD) {
 8020e28:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8020e2a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8020e2e:	f8d3 316c 	ldr.w	r3, [r3, #364]	@ 0x16c
    if (type == RSA_PRIVATE_DECRYPT &&
 8020e32:	2b04      	cmp	r3, #4
 8020e34:	d10b      	bne.n	8020e4e <wc_RsaFunction_ex+0x72>

        ret = RsaFunctionCheckIn(in, inLen, key, checkSmallCt);
 8020e36:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8020e38:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8020e3a:	68b9      	ldr	r1, [r7, #8]
 8020e3c:	68f8      	ldr	r0, [r7, #12]
 8020e3e:	f7ff ff56 	bl	8020cee <RsaFunctionCheckIn>
 8020e42:	6178      	str	r0, [r7, #20]
        if (ret != 0) {
 8020e44:	697b      	ldr	r3, [r7, #20]
 8020e46:	2b00      	cmp	r3, #0
 8020e48:	d001      	beq.n	8020e4e <wc_RsaFunction_ex+0x72>
            RESTORE_VECTOR_REGISTERS();
            return ret;
 8020e4a:	697b      	ldr	r3, [r7, #20]
 8020e4c:	e01e      	b.n	8020e8c <wc_RsaFunction_ex+0xb0>
        ret = wc_RsaFunctionNonBlock(in, inLen, out, outLen, type, key);
    }
    else
#endif
    {
        ret = wc_RsaFunctionSync(in, inLen, out, outLen, type, key, rng);
 8020e4e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8020e50:	9302      	str	r3, [sp, #8]
 8020e52:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8020e54:	9301      	str	r3, [sp, #4]
 8020e56:	6a3b      	ldr	r3, [r7, #32]
 8020e58:	9300      	str	r3, [sp, #0]
 8020e5a:	683b      	ldr	r3, [r7, #0]
 8020e5c:	687a      	ldr	r2, [r7, #4]
 8020e5e:	68b9      	ldr	r1, [r7, #8]
 8020e60:	68f8      	ldr	r0, [r7, #12]
 8020e62:	f7ff ff02 	bl	8020c6a <wc_RsaFunctionSync>
 8020e66:	6178      	str	r0, [r7, #20]
    }

    RESTORE_VECTOR_REGISTERS();

    /* handle error */
    if (ret < 0 && ret != WC_NO_ERR_TRACE(WC_PENDING_E)
 8020e68:	697b      	ldr	r3, [r7, #20]
 8020e6a:	2b00      	cmp	r3, #0
 8020e6c:	da0d      	bge.n	8020e8a <wc_RsaFunction_ex+0xae>
 8020e6e:	697b      	ldr	r3, [r7, #20]
 8020e70:	f113 0f6c 	cmn.w	r3, #108	@ 0x6c
 8020e74:	d009      	beq.n	8020e8a <wc_RsaFunction_ex+0xae>
        if (ret == WC_NO_ERR_TRACE(MP_EXPTMOD_E)) {
            /* This can happen due to incorrectly set FP_MAX_BITS or missing XREALLOC */
            WOLFSSL_MSG("RSA_FUNCTION MP_EXPTMOD_E: memory/config problem");
        }

        key->state = RSA_STATE_NONE;
 8020e76:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8020e78:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8020e7c:	461a      	mov	r2, r3
 8020e7e:	2300      	movs	r3, #0
 8020e80:	f8c2 316c 	str.w	r3, [r2, #364]	@ 0x16c
        wc_RsaCleanup(key);
 8020e84:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8020e86:	f7fe ff93 	bl	801fdb0 <wc_RsaCleanup>
    }
    return ret;
 8020e8a:	697b      	ldr	r3, [r7, #20]
#endif /* !WOLF_CRYPTO_CB_ONLY_RSA */
}
 8020e8c:	4618      	mov	r0, r3
 8020e8e:	3718      	adds	r7, #24
 8020e90:	46bd      	mov	sp, r7
 8020e92:	bd80      	pop	{r7, pc}

08020e94 <RsaPrivateDecryptEx>:
                            word32 outLen, byte** outPtr, RsaKey* key,
                            int rsa_type, byte pad_value, int pad_type,
                            enum wc_HashType hash, int mgf,
                            byte* label, word32 labelSz, int saltLen,
                            WC_RNG* rng)
{
 8020e94:	b5b0      	push	{r4, r5, r7, lr}
 8020e96:	b092      	sub	sp, #72	@ 0x48
 8020e98:	af08      	add	r7, sp, #32
 8020e9a:	60f8      	str	r0, [r7, #12]
 8020e9c:	60b9      	str	r1, [r7, #8]
 8020e9e:	607a      	str	r2, [r7, #4]
 8020ea0:	603b      	str	r3, [r7, #0]
    int ret = WC_NO_ERR_TRACE(RSA_WRONG_TYPE_E);
 8020ea2:	f06f 0381 	mvn.w	r3, #129	@ 0x81
 8020ea6:	627b      	str	r3, [r7, #36]	@ 0x24
    byte* pad = NULL;
 8020ea8:	2300      	movs	r3, #0
 8020eaa:	613b      	str	r3, [r7, #16]
#if defined(WOLF_CRYPTO_CB) && defined(WOLF_CRYPTO_CB_RSA_PAD)
    RsaPadding padding;
#endif

    if (in == NULL || inLen == 0 || out == NULL || key == NULL) {
 8020eac:	68fb      	ldr	r3, [r7, #12]
 8020eae:	2b00      	cmp	r3, #0
 8020eb0:	d008      	beq.n	8020ec4 <RsaPrivateDecryptEx+0x30>
 8020eb2:	68bb      	ldr	r3, [r7, #8]
 8020eb4:	2b00      	cmp	r3, #0
 8020eb6:	d005      	beq.n	8020ec4 <RsaPrivateDecryptEx+0x30>
 8020eb8:	687b      	ldr	r3, [r7, #4]
 8020eba:	2b00      	cmp	r3, #0
 8020ebc:	d002      	beq.n	8020ec4 <RsaPrivateDecryptEx+0x30>
 8020ebe:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8020ec0:	2b00      	cmp	r3, #0
 8020ec2:	d102      	bne.n	8020eca <RsaPrivateDecryptEx+0x36>
        return BAD_FUNC_ARG;
 8020ec4:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8020ec8:	e164      	b.n	8021194 <RsaPrivateDecryptEx+0x300>
    }

    switch (key->state) {
 8020eca:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8020ecc:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8020ed0:	f8d3 316c 	ldr.w	r3, [r3, #364]	@ 0x16c
 8020ed4:	2b06      	cmp	r3, #6
 8020ed6:	f200 8145 	bhi.w	8021164 <RsaPrivateDecryptEx+0x2d0>
 8020eda:	a201      	add	r2, pc, #4	@ (adr r2, 8020ee0 <RsaPrivateDecryptEx+0x4c>)
 8020edc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8020ee0:	08020efd 	.word	0x08020efd
 8020ee4:	08021165 	.word	0x08021165
 8020ee8:	08021165 	.word	0x08021165
 8020eec:	08021165 	.word	0x08021165
 8020ef0:	08020fa7 	.word	0x08020fa7
 8020ef4:	0802100b 	.word	0x0802100b
 8020ef8:	0802116d 	.word	0x0802116d
    case RSA_STATE_NONE:
        key->dataLen = inLen;
 8020efc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8020efe:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8020f02:	461a      	mov	r2, r3
 8020f04:	68bb      	ldr	r3, [r7, #8]
 8020f06:	f8c2 3170 	str.w	r3, [r2, #368]	@ 0x170


#if !defined(WOLFSSL_RSA_VERIFY_ONLY) && !defined(WOLFSSL_RSA_VERIFY_INLINE) && \
    !defined(WOLFSSL_NO_MALLOC)
        /* verify the tmp ptr is NULL, otherwise indicates bad state */
        if (key->data != NULL) {
 8020f0a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8020f0c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8020f10:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
 8020f14:	2b00      	cmp	r3, #0
 8020f16:	d003      	beq.n	8020f20 <RsaPrivateDecryptEx+0x8c>
            ret = BAD_STATE_E;
 8020f18:	f06f 03bf 	mvn.w	r3, #191	@ 0xbf
 8020f1c:	627b      	str	r3, [r7, #36]	@ 0x24
            break;
 8020f1e:	e128      	b.n	8021172 <RsaPrivateDecryptEx+0x2de>
        }

        /* if not doing this inline then allocate a buffer for it */
        if (outPtr == NULL) {
 8020f20:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8020f22:	2b00      	cmp	r3, #0
 8020f24:	d12b      	bne.n	8020f7e <RsaPrivateDecryptEx+0xea>
            key->data = (byte*)XMALLOC(inLen, key->heap,
 8020f26:	68b8      	ldr	r0, [r7, #8]
 8020f28:	f7fd fdae 	bl	801ea88 <wolfSSL_Malloc>
 8020f2c:	4602      	mov	r2, r0
 8020f2e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8020f30:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8020f34:	f8c3 2164 	str.w	r2, [r3, #356]	@ 0x164
                                                      DYNAMIC_TYPE_WOLF_BIGINT);
            key->dataIsAlloc = 1;
 8020f38:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8020f3a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8020f3e:	2201      	movs	r2, #1
 8020f40:	f883 2178 	strb.w	r2, [r3, #376]	@ 0x178
            if (key->data == NULL) {
 8020f44:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8020f46:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8020f4a:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
 8020f4e:	2b00      	cmp	r3, #0
 8020f50:	d103      	bne.n	8020f5a <RsaPrivateDecryptEx+0xc6>
                ret = MEMORY_E;
 8020f52:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8020f56:	627b      	str	r3, [r7, #36]	@ 0x24
                break;
 8020f58:	e10b      	b.n	8021172 <RsaPrivateDecryptEx+0x2de>
            }
            XMEMCPY(key->data, in, inLen);
 8020f5a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8020f5c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8020f60:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
 8020f64:	68ba      	ldr	r2, [r7, #8]
 8020f66:	68f9      	ldr	r1, [r7, #12]
 8020f68:	4618      	mov	r0, r3
 8020f6a:	f007 fb17 	bl	802859c <memcpy>
            key->dataLen = inLen;
 8020f6e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8020f70:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8020f74:	461a      	mov	r2, r3
 8020f76:	68bb      	ldr	r3, [r7, #8]
 8020f78:	f8c2 3170 	str.w	r3, [r2, #368]	@ 0x170
 8020f7c:	e00c      	b.n	8020f98 <RsaPrivateDecryptEx+0x104>
        }
        else {
            key->dataIsAlloc = 0;
 8020f7e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8020f80:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8020f84:	2200      	movs	r2, #0
 8020f86:	f883 2178 	strb.w	r2, [r3, #376]	@ 0x178
            key->data = out;
 8020f8a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8020f8c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8020f90:	461a      	mov	r2, r3
 8020f92:	687b      	ldr	r3, [r7, #4]
 8020f94:	f8c2 3164 	str.w	r3, [r2, #356]	@ 0x164
        }
#endif

        key->state = RSA_STATE_DECRYPT_EXPTMOD;
 8020f98:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8020f9a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8020f9e:	461a      	mov	r2, r3
 8020fa0:	2304      	movs	r3, #4
 8020fa2:	f8c2 316c 	str.w	r3, [r2, #364]	@ 0x16c
        }
    }
#endif
#if !defined(WOLFSSL_RSA_VERIFY_ONLY) && !defined(WOLFSSL_RSA_VERIFY_INLINE) && \
    !defined(WOLFSSL_NO_MALLOC)
        ret = wc_RsaFunction_ex(key->data, inLen, key->data, &key->dataLen,
 8020fa6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8020fa8:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8020fac:	f8d3 0164 	ldr.w	r0, [r3, #356]	@ 0x164
 8020fb0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8020fb2:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8020fb6:	f8d3 1164 	ldr.w	r1, [r3, #356]	@ 0x164
 8020fba:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8020fbc:	f503 538b 	add.w	r3, r3, #4448	@ 0x1160
 8020fc0:	3310      	adds	r3, #16
 8020fc2:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8020fc4:	2a01      	cmp	r2, #1
 8020fc6:	bf14      	ite	ne
 8020fc8:	2201      	movne	r2, #1
 8020fca:	2200      	moveq	r2, #0
 8020fcc:	b2d2      	uxtb	r2, r2
 8020fce:	9203      	str	r2, [sp, #12]
 8020fd0:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8020fd2:	9202      	str	r2, [sp, #8]
 8020fd4:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8020fd6:	9201      	str	r2, [sp, #4]
 8020fd8:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8020fda:	9200      	str	r2, [sp, #0]
 8020fdc:	460a      	mov	r2, r1
 8020fde:	68b9      	ldr	r1, [r7, #8]
 8020fe0:	f7ff fefc 	bl	8020ddc <wc_RsaFunction_ex>
 8020fe4:	6278      	str	r0, [r7, #36]	@ 0x24
#else
        ret = wc_RsaFunction_ex(in, inLen, out, &key->dataLen, rsa_type, key,
                                              rng, pad_type != WC_RSA_OAEP_PAD);
#endif

        if (ret >= 0 || ret == WC_NO_ERR_TRACE(WC_PENDING_E)) {
 8020fe6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8020fe8:	2b00      	cmp	r3, #0
 8020fea:	da03      	bge.n	8020ff4 <RsaPrivateDecryptEx+0x160>
 8020fec:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8020fee:	f113 0f6c 	cmn.w	r3, #108	@ 0x6c
 8020ff2:	d106      	bne.n	8021002 <RsaPrivateDecryptEx+0x16e>
            key->state = RSA_STATE_DECRYPT_UNPAD;
 8020ff4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8020ff6:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8020ffa:	461a      	mov	r2, r3
 8020ffc:	2305      	movs	r3, #5
 8020ffe:	f8c2 316c 	str.w	r3, [r2, #364]	@ 0x16c
        }
        if (ret < 0) {
 8021002:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8021004:	2b00      	cmp	r3, #0
 8021006:	f2c0 80b3 	blt.w	8021170 <RsaPrivateDecryptEx+0x2dc>
        FALL_THROUGH;

    case RSA_STATE_DECRYPT_UNPAD:
#if !defined(WOLFSSL_RSA_VERIFY_ONLY) && !defined(WOLFSSL_RSA_VERIFY_INLINE) && \
    !defined(WOLFSSL_NO_MALLOC)
        ret = wc_RsaUnPad_ex(key->data,
 802100a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802100c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8021010:	f8d3 4164 	ldr.w	r4, [r3, #356]	@ 0x164
 8021014:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021016:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 802101a:	f8d3 5170 	ldr.w	r5, [r3, #368]	@ 0x170
            key->dataLen, &pad, pad_value, pad_type, hash, mgf,
            label, labelSz, saltLen, mp_count_bits(&key->n), key->heap);
 802101e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
        ret = wc_RsaUnPad_ex(key->data,
 8021020:	4618      	mov	r0, r3
 8021022:	f005 fda1 	bl	8026b68 <mp_count_bits>
 8021026:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021028:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 802102c:	f8d3 3160 	ldr.w	r3, [r3, #352]	@ 0x160
 8021030:	f897 1044 	ldrb.w	r1, [r7, #68]	@ 0x44
 8021034:	f107 0210 	add.w	r2, r7, #16
 8021038:	9307      	str	r3, [sp, #28]
 802103a:	9006      	str	r0, [sp, #24]
 802103c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 802103e:	9305      	str	r3, [sp, #20]
 8021040:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8021042:	9304      	str	r3, [sp, #16]
 8021044:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8021046:	9303      	str	r3, [sp, #12]
 8021048:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802104a:	9302      	str	r3, [sp, #8]
 802104c:	f897 304c 	ldrb.w	r3, [r7, #76]	@ 0x4c
 8021050:	9301      	str	r3, [sp, #4]
 8021052:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8021054:	9300      	str	r3, [sp, #0]
 8021056:	460b      	mov	r3, r1
 8021058:	4629      	mov	r1, r5
 802105a:	4620      	mov	r0, r4
 802105c:	f7ff fb98 	bl	8020790 <wc_RsaUnPad_ex>
 8021060:	6278      	str	r0, [r7, #36]	@ 0x24
#else
        ret = wc_RsaUnPad_ex(out,
            key->dataLen, &pad, pad_value, pad_type, hash, mgf, label,
            labelSz, saltLen, mp_count_bits(&key->n), key->heap);
#endif
        if (rsa_type == RSA_PUBLIC_DECRYPT && ret > (int)outLen) {
 8021062:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8021064:	2b01      	cmp	r3, #1
 8021066:	d107      	bne.n	8021078 <RsaPrivateDecryptEx+0x1e4>
 8021068:	683b      	ldr	r3, [r7, #0]
 802106a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 802106c:	429a      	cmp	r2, r3
 802106e:	dd03      	ble.n	8021078 <RsaPrivateDecryptEx+0x1e4>
            ret = RSA_BUFFER_E;
 8021070:	f06f 0382 	mvn.w	r3, #130	@ 0x82
 8021074:	627b      	str	r3, [r7, #36]	@ 0x24
 8021076:	e06d      	b.n	8021154 <RsaPrivateDecryptEx+0x2c0>
        }
        else if (ret >= 0 && pad != NULL) {
 8021078:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802107a:	2b00      	cmp	r3, #0
 802107c:	db6a      	blt.n	8021154 <RsaPrivateDecryptEx+0x2c0>
 802107e:	693b      	ldr	r3, [r7, #16]
 8021080:	2b00      	cmp	r3, #0
 8021082:	d067      	beq.n	8021154 <RsaPrivateDecryptEx+0x2c0>
            /* only copy output if not inline */
            if (outPtr == NULL) {
 8021084:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8021086:	2b00      	cmp	r3, #0
 8021088:	d148      	bne.n	802111c <RsaPrivateDecryptEx+0x288>
#if !defined(WOLFSSL_RSA_VERIFY_ONLY) && !defined(WOLFSSL_RSA_VERIFY_INLINE) && \
    !defined(WOLFSSL_NO_MALLOC)
                if (rsa_type == RSA_PRIVATE_DECRYPT) {
 802108a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802108c:	2b03      	cmp	r3, #3
 802108e:	d13e      	bne.n	802110e <RsaPrivateDecryptEx+0x27a>
                    word32 i = 0;
 8021090:	2300      	movs	r3, #0
 8021092:	623b      	str	r3, [r7, #32]
                    word32 j;
                    int start = (int)((size_t)pad - (size_t)key->data);
 8021094:	693b      	ldr	r3, [r7, #16]
 8021096:	461a      	mov	r2, r3
 8021098:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802109a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 802109e:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
 80210a2:	1ad3      	subs	r3, r2, r3
 80210a4:	61bb      	str	r3, [r7, #24]

                    for (j = 0; j < key->dataLen; j++) {
 80210a6:	2300      	movs	r3, #0
 80210a8:	61fb      	str	r3, [r7, #28]
 80210aa:	e027      	b.n	80210fc <RsaPrivateDecryptEx+0x268>
                        signed char c;
                        out[i] = key->data[j];
 80210ac:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80210ae:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 80210b2:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
 80210b6:	69fb      	ldr	r3, [r7, #28]
 80210b8:	441a      	add	r2, r3
 80210ba:	6879      	ldr	r1, [r7, #4]
 80210bc:	6a3b      	ldr	r3, [r7, #32]
 80210be:	440b      	add	r3, r1
 80210c0:	7812      	ldrb	r2, [r2, #0]
 80210c2:	701a      	strb	r2, [r3, #0]
                        c  = (signed char)ctMaskGTE((int)j, start);
 80210c4:	69fb      	ldr	r3, [r7, #28]
 80210c6:	69b9      	ldr	r1, [r7, #24]
 80210c8:	4618      	mov	r0, r3
 80210ca:	f7fe fd9d 	bl	801fc08 <ctMaskGTE>
 80210ce:	4603      	mov	r3, r0
 80210d0:	75fb      	strb	r3, [r7, #23]
                        c &= (signed char)ctMaskLT((int)i, (int)outLen);
 80210d2:	6a3b      	ldr	r3, [r7, #32]
 80210d4:	683a      	ldr	r2, [r7, #0]
 80210d6:	4611      	mov	r1, r2
 80210d8:	4618      	mov	r0, r3
 80210da:	f7fe fda7 	bl	801fc2c <ctMaskLT>
 80210de:	4603      	mov	r3, r0
 80210e0:	b25a      	sxtb	r2, r3
 80210e2:	7dfb      	ldrb	r3, [r7, #23]
 80210e4:	4013      	ands	r3, r2
 80210e6:	75fb      	strb	r3, [r7, #23]
                        /* 0 - no add, -1 add */
                        i += (word32)((byte)(-c));
 80210e8:	7dfb      	ldrb	r3, [r7, #23]
 80210ea:	425b      	negs	r3, r3
 80210ec:	b2db      	uxtb	r3, r3
 80210ee:	461a      	mov	r2, r3
 80210f0:	6a3b      	ldr	r3, [r7, #32]
 80210f2:	4413      	add	r3, r2
 80210f4:	623b      	str	r3, [r7, #32]
                    for (j = 0; j < key->dataLen; j++) {
 80210f6:	69fb      	ldr	r3, [r7, #28]
 80210f8:	3301      	adds	r3, #1
 80210fa:	61fb      	str	r3, [r7, #28]
 80210fc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80210fe:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8021102:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
 8021106:	69fa      	ldr	r2, [r7, #28]
 8021108:	429a      	cmp	r2, r3
 802110a:	d3cf      	bcc.n	80210ac <RsaPrivateDecryptEx+0x218>
 802110c:	e009      	b.n	8021122 <RsaPrivateDecryptEx+0x28e>
                    }
                }
                else
#endif
                {
                    XMEMCPY(out, pad, (size_t)ret);
 802110e:	693b      	ldr	r3, [r7, #16]
 8021110:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8021112:	4619      	mov	r1, r3
 8021114:	6878      	ldr	r0, [r7, #4]
 8021116:	f007 fa41 	bl	802859c <memcpy>
 802111a:	e002      	b.n	8021122 <RsaPrivateDecryptEx+0x28e>
                }
            }
            else {
                *outPtr = pad;
 802111c:	693a      	ldr	r2, [r7, #16]
 802111e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8021120:	601a      	str	r2, [r3, #0]
            }

#if !defined(WOLFSSL_RSA_VERIFY_ONLY)
            ret = ctMaskSelInt(ctMaskLTE(ret, (int)outLen), ret,
 8021122:	683b      	ldr	r3, [r7, #0]
 8021124:	4619      	mov	r1, r3
 8021126:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8021128:	f7fe fd93 	bl	801fc52 <ctMaskLTE>
 802112c:	4603      	mov	r3, r0
 802112e:	f06f 0282 	mvn.w	r2, #130	@ 0x82
 8021132:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8021134:	4618      	mov	r0, r3
 8021136:	f7fe fe0a 	bl	801fd4e <ctMaskSelInt>
 802113a:	6278      	str	r0, [r7, #36]	@ 0x24
                               WC_NO_ERR_TRACE(RSA_BUFFER_E));
    #ifndef WOLFSSL_RSA_DECRYPT_TO_0_LEN
            ret = ctMaskSelInt(ctMaskNotEq(ret, 0), ret,
 802113c:	2100      	movs	r1, #0
 802113e:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8021140:	f7fe fdef 	bl	801fd22 <ctMaskNotEq>
 8021144:	4603      	mov	r3, r0
 8021146:	f06f 0282 	mvn.w	r2, #130	@ 0x82
 802114a:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 802114c:	4618      	mov	r0, r3
 802114e:	f7fe fdfe 	bl	801fd4e <ctMaskSelInt>
 8021152:	6278      	str	r0, [r7, #36]	@ 0x24
            if (outLen < (word32)ret)
                ret = RSA_BUFFER_E;
#endif
        }

        key->state = RSA_STATE_DECRYPT_RES;
 8021154:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021156:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 802115a:	461a      	mov	r2, r3
 802115c:	2306      	movs	r3, #6
 802115e:	f8c2 316c 	str.w	r3, [r2, #364]	@ 0x16c
                if (outPtr)
                    *outPtr = in;
            }
        }
    #endif
        break;
 8021162:	e003      	b.n	802116c <RsaPrivateDecryptEx+0x2d8>

    default:
        ret = BAD_STATE_E;
 8021164:	f06f 03bf 	mvn.w	r3, #191	@ 0xbf
 8021168:	627b      	str	r3, [r7, #36]	@ 0x24
        break;
 802116a:	e002      	b.n	8021172 <RsaPrivateDecryptEx+0x2de>
        break;
 802116c:	bf00      	nop
 802116e:	e000      	b.n	8021172 <RsaPrivateDecryptEx+0x2de>
            break;
 8021170:	bf00      	nop
    }

    /* if async pending then return and skip done cleanup below */
    if (ret == WC_NO_ERR_TRACE(WC_PENDING_E)
 8021172:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8021174:	f113 0f6c 	cmn.w	r3, #108	@ 0x6c
 8021178:	d101      	bne.n	802117e <RsaPrivateDecryptEx+0x2ea>
    #ifdef WC_RSA_NONBLOCK
        || ret == FP_WOULDBLOCK
    #endif
    ) {
        return ret;
 802117a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802117c:	e00a      	b.n	8021194 <RsaPrivateDecryptEx+0x300>
    }

    key->state = RSA_STATE_NONE;
 802117e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021180:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8021184:	461a      	mov	r2, r3
 8021186:	2300      	movs	r3, #0
 8021188:	f8c2 316c 	str.w	r3, [r2, #364]	@ 0x16c
    wc_RsaCleanup(key);
 802118c:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 802118e:	f7fe fe0f 	bl	801fdb0 <wc_RsaCleanup>

    return ret;
 8021192:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 8021194:	4618      	mov	r0, r3
 8021196:	3728      	adds	r7, #40	@ 0x28
 8021198:	46bd      	mov	sp, r7
 802119a:	bdb0      	pop	{r4, r5, r7, pc}

0802119c <wc_RsaPrivateDecrypt>:
#endif /* WC_NO_RSA_OAEP */


int wc_RsaPrivateDecrypt(const byte* in, word32 inLen, byte* out,
                                                 word32 outLen, RsaKey* key)
{
 802119c:	b580      	push	{r7, lr}
 802119e:	b092      	sub	sp, #72	@ 0x48
 80211a0:	af0c      	add	r7, sp, #48	@ 0x30
 80211a2:	60f8      	str	r0, [r7, #12]
 80211a4:	60b9      	str	r1, [r7, #8]
 80211a6:	607a      	str	r2, [r7, #4]
 80211a8:	603b      	str	r3, [r7, #0]
    WC_RNG* rng;
    int ret;
#ifdef WC_RSA_BLINDING
    rng = key->rng;
 80211aa:	6a3b      	ldr	r3, [r7, #32]
 80211ac:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 80211b0:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
 80211b4:	617b      	str	r3, [r7, #20]
#else
    rng = NULL;
#endif
    SAVE_VECTOR_REGISTERS(return _svr_ret;);
    ret = RsaPrivateDecryptEx(in, inLen, out, outLen, NULL, key,
 80211b6:	697b      	ldr	r3, [r7, #20]
 80211b8:	930a      	str	r3, [sp, #40]	@ 0x28
 80211ba:	2300      	movs	r3, #0
 80211bc:	9309      	str	r3, [sp, #36]	@ 0x24
 80211be:	2300      	movs	r3, #0
 80211c0:	9308      	str	r3, [sp, #32]
 80211c2:	2300      	movs	r3, #0
 80211c4:	9307      	str	r3, [sp, #28]
 80211c6:	2300      	movs	r3, #0
 80211c8:	9306      	str	r3, [sp, #24]
 80211ca:	2300      	movs	r3, #0
 80211cc:	9305      	str	r3, [sp, #20]
 80211ce:	2300      	movs	r3, #0
 80211d0:	9304      	str	r3, [sp, #16]
 80211d2:	2302      	movs	r3, #2
 80211d4:	9303      	str	r3, [sp, #12]
 80211d6:	2303      	movs	r3, #3
 80211d8:	9302      	str	r3, [sp, #8]
 80211da:	6a3b      	ldr	r3, [r7, #32]
 80211dc:	9301      	str	r3, [sp, #4]
 80211de:	2300      	movs	r3, #0
 80211e0:	9300      	str	r3, [sp, #0]
 80211e2:	683b      	ldr	r3, [r7, #0]
 80211e4:	687a      	ldr	r2, [r7, #4]
 80211e6:	68b9      	ldr	r1, [r7, #8]
 80211e8:	68f8      	ldr	r0, [r7, #12]
 80211ea:	f7ff fe53 	bl	8020e94 <RsaPrivateDecryptEx>
 80211ee:	6138      	str	r0, [r7, #16]
        RSA_PRIVATE_DECRYPT, RSA_BLOCK_TYPE_2, WC_RSA_PKCSV15_PAD,
        WC_HASH_TYPE_NONE, WC_MGF1NONE, NULL, 0, 0, rng);
    RESTORE_VECTOR_REGISTERS();
    return ret;
 80211f0:	693b      	ldr	r3, [r7, #16]
}
 80211f2:	4618      	mov	r0, r3
 80211f4:	3718      	adds	r7, #24
 80211f6:	46bd      	mov	sp, r7
 80211f8:	bd80      	pop	{r7, pc}

080211fa <wc_RsaSSL_VerifyInline>:
#endif /* WC_NO_RSA_OAEP || WC_RSA_NO_PADDING */
#endif /* WOLFSSL_RSA_PUBLIC_ONLY */

#if !defined(WOLFSSL_CRYPTOCELL)
int wc_RsaSSL_VerifyInline(byte* in, word32 inLen, byte** out, RsaKey* key)
{
 80211fa:	b580      	push	{r7, lr}
 80211fc:	b092      	sub	sp, #72	@ 0x48
 80211fe:	af0c      	add	r7, sp, #48	@ 0x30
 8021200:	60f8      	str	r0, [r7, #12]
 8021202:	60b9      	str	r1, [r7, #8]
 8021204:	607a      	str	r2, [r7, #4]
 8021206:	603b      	str	r3, [r7, #0]
    WC_RNG* rng;
    int ret;
#ifdef WC_RSA_BLINDING
    rng = key->rng;
 8021208:	683b      	ldr	r3, [r7, #0]
 802120a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 802120e:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
 8021212:	617b      	str	r3, [r7, #20]
#else
    rng = NULL;
#endif
    SAVE_VECTOR_REGISTERS(return _svr_ret;);
    ret = RsaPrivateDecryptEx(in, inLen, in, inLen, out, key,
 8021214:	697b      	ldr	r3, [r7, #20]
 8021216:	930a      	str	r3, [sp, #40]	@ 0x28
 8021218:	2300      	movs	r3, #0
 802121a:	9309      	str	r3, [sp, #36]	@ 0x24
 802121c:	2300      	movs	r3, #0
 802121e:	9308      	str	r3, [sp, #32]
 8021220:	2300      	movs	r3, #0
 8021222:	9307      	str	r3, [sp, #28]
 8021224:	2300      	movs	r3, #0
 8021226:	9306      	str	r3, [sp, #24]
 8021228:	2300      	movs	r3, #0
 802122a:	9305      	str	r3, [sp, #20]
 802122c:	2300      	movs	r3, #0
 802122e:	9304      	str	r3, [sp, #16]
 8021230:	2301      	movs	r3, #1
 8021232:	9303      	str	r3, [sp, #12]
 8021234:	2301      	movs	r3, #1
 8021236:	9302      	str	r3, [sp, #8]
 8021238:	683b      	ldr	r3, [r7, #0]
 802123a:	9301      	str	r3, [sp, #4]
 802123c:	687b      	ldr	r3, [r7, #4]
 802123e:	9300      	str	r3, [sp, #0]
 8021240:	68bb      	ldr	r3, [r7, #8]
 8021242:	68fa      	ldr	r2, [r7, #12]
 8021244:	68b9      	ldr	r1, [r7, #8]
 8021246:	68f8      	ldr	r0, [r7, #12]
 8021248:	f7ff fe24 	bl	8020e94 <RsaPrivateDecryptEx>
 802124c:	6138      	str	r0, [r7, #16]
        RSA_PUBLIC_DECRYPT, RSA_BLOCK_TYPE_1, WC_RSA_PKCSV15_PAD,
        WC_HASH_TYPE_NONE, WC_MGF1NONE, NULL, 0, 0, rng);
    RESTORE_VECTOR_REGISTERS();
    return ret;
 802124e:	693b      	ldr	r3, [r7, #16]
}
 8021250:	4618      	mov	r0, r3
 8021252:	3718      	adds	r7, #24
 8021254:	46bd      	mov	sp, r7
 8021256:	bd80      	pop	{r7, pc}

08021258 <wc_RsaPSS_VerifyInline_ex>:
 * returns the length of the PSS data on success and negative indicates failure.
 */
int wc_RsaPSS_VerifyInline_ex(byte* in, word32 inLen, byte** out,
                              enum wc_HashType hash, int mgf, int saltLen,
                              RsaKey* key)
{
 8021258:	b580      	push	{r7, lr}
 802125a:	b092      	sub	sp, #72	@ 0x48
 802125c:	af0c      	add	r7, sp, #48	@ 0x30
 802125e:	60f8      	str	r0, [r7, #12]
 8021260:	60b9      	str	r1, [r7, #8]
 8021262:	607a      	str	r2, [r7, #4]
 8021264:	70fb      	strb	r3, [r7, #3]
    WC_RNG* rng;
    int ret;
#ifdef WC_RSA_BLINDING
    rng = key->rng;
 8021266:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8021268:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 802126c:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
 8021270:	617b      	str	r3, [r7, #20]
#else
    rng = NULL;
#endif
    SAVE_VECTOR_REGISTERS(return _svr_ret;);
    ret = RsaPrivateDecryptEx(in, inLen, in, inLen, out, key,
 8021272:	697b      	ldr	r3, [r7, #20]
 8021274:	930a      	str	r3, [sp, #40]	@ 0x28
 8021276:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8021278:	9309      	str	r3, [sp, #36]	@ 0x24
 802127a:	2300      	movs	r3, #0
 802127c:	9308      	str	r3, [sp, #32]
 802127e:	2300      	movs	r3, #0
 8021280:	9307      	str	r3, [sp, #28]
 8021282:	6a3b      	ldr	r3, [r7, #32]
 8021284:	9306      	str	r3, [sp, #24]
 8021286:	78fb      	ldrb	r3, [r7, #3]
 8021288:	9305      	str	r3, [sp, #20]
 802128a:	2302      	movs	r3, #2
 802128c:	9304      	str	r3, [sp, #16]
 802128e:	2301      	movs	r3, #1
 8021290:	9303      	str	r3, [sp, #12]
 8021292:	2301      	movs	r3, #1
 8021294:	9302      	str	r3, [sp, #8]
 8021296:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8021298:	9301      	str	r3, [sp, #4]
 802129a:	687b      	ldr	r3, [r7, #4]
 802129c:	9300      	str	r3, [sp, #0]
 802129e:	68bb      	ldr	r3, [r7, #8]
 80212a0:	68fa      	ldr	r2, [r7, #12]
 80212a2:	68b9      	ldr	r1, [r7, #8]
 80212a4:	68f8      	ldr	r0, [r7, #12]
 80212a6:	f7ff fdf5 	bl	8020e94 <RsaPrivateDecryptEx>
 80212aa:	6138      	str	r0, [r7, #16]
        RSA_PUBLIC_DECRYPT, RSA_BLOCK_TYPE_1, WC_RSA_PSS_PAD,
        hash, mgf, NULL, 0, saltLen, rng);
    RESTORE_VECTOR_REGISTERS();
    return ret;
 80212ac:	693b      	ldr	r3, [r7, #16]
}
 80212ae:	4618      	mov	r0, r3
 80212b0:	3718      	adds	r7, #24
 80212b2:	46bd      	mov	sp, r7
 80212b4:	bd80      	pop	{r7, pc}

080212b6 <wc_RsaPSS_CheckPadding_ex2>:
 * algorithm length and 0 on success.
 */
int wc_RsaPSS_CheckPadding_ex2(const byte* in, word32 inSz, byte* sig,
                               word32 sigSz, enum wc_HashType hashType,
                               int saltLen, int bits, void* heap)
{
 80212b6:	b580      	push	{r7, lr}
 80212b8:	b09c      	sub	sp, #112	@ 0x70
 80212ba:	af02      	add	r7, sp, #8
 80212bc:	60f8      	str	r0, [r7, #12]
 80212be:	60b9      	str	r1, [r7, #8]
 80212c0:	607a      	str	r2, [r7, #4]
 80212c2:	603b      	str	r3, [r7, #0]
    int ret = 0;
 80212c4:	2300      	movs	r3, #0
 80212c6:	667b      	str	r3, [r7, #100]	@ 0x64
    byte sigCheckBuf[WC_MAX_DIGEST_SIZE*2 + RSA_PSS_PAD_SZ];
    byte *sigCheck = sigCheckBuf;
 80212c8:	f107 0314 	add.w	r3, r7, #20
 80212cc:	663b      	str	r3, [r7, #96]	@ 0x60

    (void)bits;

    if (in == NULL || sig == NULL ||
 80212ce:	68fb      	ldr	r3, [r7, #12]
 80212d0:	2b00      	cmp	r3, #0
 80212d2:	d00c      	beq.n	80212ee <wc_RsaPSS_CheckPadding_ex2+0x38>
 80212d4:	687b      	ldr	r3, [r7, #4]
 80212d6:	2b00      	cmp	r3, #0
 80212d8:	d009      	beq.n	80212ee <wc_RsaPSS_CheckPadding_ex2+0x38>
                               inSz != (word32)wc_HashGetDigestSize(hashType)) {
 80212da:	f897 3070 	ldrb.w	r3, [r7, #112]	@ 0x70
 80212de:	4618      	mov	r0, r3
 80212e0:	f7fd f840 	bl	801e364 <wc_HashGetDigestSize>
 80212e4:	4603      	mov	r3, r0
 80212e6:	461a      	mov	r2, r3
    if (in == NULL || sig == NULL ||
 80212e8:	68bb      	ldr	r3, [r7, #8]
 80212ea:	4293      	cmp	r3, r2
 80212ec:	d002      	beq.n	80212f4 <wc_RsaPSS_CheckPadding_ex2+0x3e>
        ret = BAD_FUNC_ARG;
 80212ee:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80212f2:	667b      	str	r3, [r7, #100]	@ 0x64
    }

    if (ret == 0) {
 80212f4:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80212f6:	2b00      	cmp	r3, #0
 80212f8:	d115      	bne.n	8021326 <wc_RsaPSS_CheckPadding_ex2+0x70>
        if (saltLen == RSA_PSS_SALT_LEN_DEFAULT) {
 80212fa:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80212fc:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8021300:	d102      	bne.n	8021308 <wc_RsaPSS_CheckPadding_ex2+0x52>
            saltLen = (int)inSz;
 8021302:	68bb      	ldr	r3, [r7, #8]
 8021304:	677b      	str	r3, [r7, #116]	@ 0x74
 8021306:	e00e      	b.n	8021326 <wc_RsaPSS_CheckPadding_ex2+0x70>
                    saltLen = RSA_PSS_SALT_MAX_SZ;
                }
            #endif
        }
#ifndef WOLFSSL_PSS_LONG_SALT
        else if (saltLen > (int)inSz) {
 8021308:	68bb      	ldr	r3, [r7, #8]
 802130a:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 802130c:	429a      	cmp	r2, r3
 802130e:	dd03      	ble.n	8021318 <wc_RsaPSS_CheckPadding_ex2+0x62>
            ret = PSS_SALTLEN_E;
 8021310:	f06f 03f9 	mvn.w	r3, #249	@ 0xf9
 8021314:	667b      	str	r3, [r7, #100]	@ 0x64
 8021316:	e006      	b.n	8021326 <wc_RsaPSS_CheckPadding_ex2+0x70>
        }
#endif
#ifndef WOLFSSL_PSS_SALT_LEN_DISCOVER
        else if (saltLen < RSA_PSS_SALT_LEN_DEFAULT) {
 8021318:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 802131a:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 802131e:	da02      	bge.n	8021326 <wc_RsaPSS_CheckPadding_ex2+0x70>
            ret = PSS_SALTLEN_E;
 8021320:	f06f 03f9 	mvn.w	r3, #249	@ 0xf9
 8021324:	667b      	str	r3, [r7, #100]	@ 0x64
        }
#endif
    }

    /* Sig = Salt | Exp Hash */
    if (ret == 0) {
 8021326:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8021328:	2b00      	cmp	r3, #0
 802132a:	d113      	bne.n	8021354 <wc_RsaPSS_CheckPadding_ex2+0x9e>
        word32 totalSz;
        if ((WC_SAFE_SUM_WORD32(inSz, (word32)saltLen, totalSz) == 0) ||
 802132c:	68bb      	ldr	r3, [r7, #8]
 802132e:	43da      	mvns	r2, r3
 8021330:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8021332:	429a      	cmp	r2, r3
 8021334:	d308      	bcc.n	8021348 <wc_RsaPSS_CheckPadding_ex2+0x92>
 8021336:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8021338:	68ba      	ldr	r2, [r7, #8]
 802133a:	4413      	add	r3, r2
 802133c:	65fb      	str	r3, [r7, #92]	@ 0x5c
 802133e:	683a      	ldr	r2, [r7, #0]
 8021340:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8021342:	429a      	cmp	r2, r3
 8021344:	d006      	beq.n	8021354 <wc_RsaPSS_CheckPadding_ex2+0x9e>
 8021346:	e002      	b.n	802134e <wc_RsaPSS_CheckPadding_ex2+0x98>
 8021348:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 802134c:	65fb      	str	r3, [r7, #92]	@ 0x5c
            (sigSz != totalSz))
        {
            ret = PSS_SALTLEN_E;
 802134e:	f06f 03f9 	mvn.w	r3, #249	@ 0xf9
 8021352:	667b      	str	r3, [r7, #100]	@ 0x64
        if (sigCheck == NULL) {
            ret = MEMORY_E;
        }
    }
#else
    if (ret == 0 && sizeof(sigCheckBuf) < (RSA_PSS_PAD_SZ + inSz + (word32)saltLen)) {
 8021354:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8021356:	2b00      	cmp	r3, #0
 8021358:	d108      	bne.n	802136c <wc_RsaPSS_CheckPadding_ex2+0xb6>
 802135a:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 802135c:	68bb      	ldr	r3, [r7, #8]
 802135e:	4413      	add	r3, r2
 8021360:	3308      	adds	r3, #8
 8021362:	2b48      	cmp	r3, #72	@ 0x48
 8021364:	d902      	bls.n	802136c <wc_RsaPSS_CheckPadding_ex2+0xb6>
        ret = BUFFER_E;
 8021366:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 802136a:	667b      	str	r3, [r7, #100]	@ 0x64
    }
#endif

    /* Exp Hash = HASH(8 * 0x00 | Message Hash | Salt) */
    if (ret == 0) {
 802136c:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 802136e:	2b00      	cmp	r3, #0
 8021370:	d122      	bne.n	80213b8 <wc_RsaPSS_CheckPadding_ex2+0x102>
        XMEMSET(sigCheck, 0, RSA_PSS_PAD_SZ);
 8021372:	2208      	movs	r2, #8
 8021374:	2100      	movs	r1, #0
 8021376:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 8021378:	f007 f8a6 	bl	80284c8 <memset>
        XMEMCPY(sigCheck + RSA_PSS_PAD_SZ, in, inSz);
 802137c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 802137e:	3308      	adds	r3, #8
 8021380:	68ba      	ldr	r2, [r7, #8]
 8021382:	68f9      	ldr	r1, [r7, #12]
 8021384:	4618      	mov	r0, r3
 8021386:	f007 f909 	bl	802859c <memcpy>
        XMEMCPY(sigCheck + RSA_PSS_PAD_SZ + inSz, sig, (size_t)saltLen);
 802138a:	68bb      	ldr	r3, [r7, #8]
 802138c:	3308      	adds	r3, #8
 802138e:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8021390:	4413      	add	r3, r2
 8021392:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8021394:	6879      	ldr	r1, [r7, #4]
 8021396:	4618      	mov	r0, r3
 8021398:	f007 f900 	bl	802859c <memcpy>
        ret = wc_Hash(hashType, sigCheck, RSA_PSS_PAD_SZ + inSz + (word32)saltLen,
 802139c:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 802139e:	68bb      	ldr	r3, [r7, #8]
 80213a0:	4413      	add	r3, r2
 80213a2:	f103 0208 	add.w	r2, r3, #8
 80213a6:	f897 0070 	ldrb.w	r0, [r7, #112]	@ 0x70
 80213aa:	68bb      	ldr	r3, [r7, #8]
 80213ac:	9300      	str	r3, [sp, #0]
 80213ae:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80213b0:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 80213b2:	f7fd f86f 	bl	801e494 <wc_Hash>
 80213b6:	6678      	str	r0, [r7, #100]	@ 0x64
                      sigCheck, inSz);
    }
    if (ret == 0) {
 80213b8:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80213ba:	2b00      	cmp	r3, #0
 80213bc:	d10d      	bne.n	80213da <wc_RsaPSS_CheckPadding_ex2+0x124>
        if (XMEMCMP(sigCheck, sig + saltLen, inSz) != 0) {
 80213be:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80213c0:	687a      	ldr	r2, [r7, #4]
 80213c2:	4413      	add	r3, r2
 80213c4:	68ba      	ldr	r2, [r7, #8]
 80213c6:	4619      	mov	r1, r3
 80213c8:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 80213ca:	f007 f853 	bl	8028474 <memcmp>
 80213ce:	4603      	mov	r3, r0
 80213d0:	2b00      	cmp	r3, #0
 80213d2:	d002      	beq.n	80213da <wc_RsaPSS_CheckPadding_ex2+0x124>
            WOLFSSL_MSG("RsaPSS_CheckPadding: Padding Error");
            ret = BAD_PADDING_E;
 80213d4:	f06f 03c0 	mvn.w	r3, #192	@ 0xc0
 80213d8:	667b      	str	r3, [r7, #100]	@ 0x64
        XFREE(sigCheck, heap, DYNAMIC_TYPE_RSA_BUFFER);
    }
#endif

    (void)heap; /* unused if memory is disabled */
    return ret;
 80213da:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
}
 80213dc:	4618      	mov	r0, r3
 80213de:	3768      	adds	r7, #104	@ 0x68
 80213e0:	46bd      	mov	sp, r7
 80213e2:	bd80      	pop	{r7, pc}

080213e4 <wc_RsaEncryptSize>:
}
#endif
#endif

int wc_RsaEncryptSize(const RsaKey* key)
{
 80213e4:	b580      	push	{r7, lr}
 80213e6:	b084      	sub	sp, #16
 80213e8:	af00      	add	r7, sp, #0
 80213ea:	6078      	str	r0, [r7, #4]
    int ret;

    if (key == NULL) {
 80213ec:	687b      	ldr	r3, [r7, #4]
 80213ee:	2b00      	cmp	r3, #0
 80213f0:	d102      	bne.n	80213f8 <wc_RsaEncryptSize+0x14>
        return BAD_FUNC_ARG;
 80213f2:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80213f6:	e005      	b.n	8021404 <wc_RsaEncryptSize+0x20>
    }

    ret = mp_unsigned_bin_size(&key->n);
 80213f8:	687b      	ldr	r3, [r7, #4]
 80213fa:	4618      	mov	r0, r3
 80213fc:	f005 faf8 	bl	80269f0 <mp_unsigned_bin_size>
 8021400:	60f8      	str	r0, [r7, #12]
            ret = 2048/8; /* hardware handles, use 2048-bit as default */
        }
    }
#endif

    return ret;
 8021402:	68fb      	ldr	r3, [r7, #12]
}
 8021404:	4618      	mov	r0, r3
 8021406:	3710      	adds	r7, #16
 8021408:	46bd      	mov	sp, r7
 802140a:	bd80      	pop	{r7, pc}

0802140c <wc_RsaSetRNG>:
#endif /* WOLFSSL_KEY_GEN */


#ifdef WC_RSA_BLINDING
int wc_RsaSetRNG(RsaKey* key, WC_RNG* rng)
{
 802140c:	b480      	push	{r7}
 802140e:	b083      	sub	sp, #12
 8021410:	af00      	add	r7, sp, #0
 8021412:	6078      	str	r0, [r7, #4]
 8021414:	6039      	str	r1, [r7, #0]
    if (key == NULL || rng == NULL)
 8021416:	687b      	ldr	r3, [r7, #4]
 8021418:	2b00      	cmp	r3, #0
 802141a:	d002      	beq.n	8021422 <wc_RsaSetRNG+0x16>
 802141c:	683b      	ldr	r3, [r7, #0]
 802141e:	2b00      	cmp	r3, #0
 8021420:	d102      	bne.n	8021428 <wc_RsaSetRNG+0x1c>
        return BAD_FUNC_ARG;
 8021422:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8021426:	e007      	b.n	8021438 <wc_RsaSetRNG+0x2c>

    key->rng = rng;
 8021428:	687b      	ldr	r3, [r7, #4]
 802142a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 802142e:	461a      	mov	r2, r3
 8021430:	683b      	ldr	r3, [r7, #0]
 8021432:	f8c2 3174 	str.w	r3, [r2, #372]	@ 0x174

    return 0;
 8021436:	2300      	movs	r3, #0
}
 8021438:	4618      	mov	r0, r3
 802143a:	370c      	adds	r7, #12
 802143c:	46bd      	mov	sp, r7
 802143e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021442:	4770      	bx	lr

08021444 <rotlFixed>:
    {
 8021444:	b480      	push	{r7}
 8021446:	b083      	sub	sp, #12
 8021448:	af00      	add	r7, sp, #0
 802144a:	6078      	str	r0, [r7, #4]
 802144c:	6039      	str	r1, [r7, #0]
        return (x << y) | (x >> (sizeof(x) * 8 - y));
 802144e:	687a      	ldr	r2, [r7, #4]
 8021450:	683b      	ldr	r3, [r7, #0]
 8021452:	f1c3 0320 	rsb	r3, r3, #32
 8021456:	fa62 f303 	ror.w	r3, r2, r3
    }
 802145a:	4618      	mov	r0, r3
 802145c:	370c      	adds	r7, #12
 802145e:	46bd      	mov	sp, r7
 8021460:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021464:	4770      	bx	lr

08021466 <rotrFixed>:
    {
 8021466:	b480      	push	{r7}
 8021468:	b083      	sub	sp, #12
 802146a:	af00      	add	r7, sp, #0
 802146c:	6078      	str	r0, [r7, #4]
 802146e:	6039      	str	r1, [r7, #0]
        return (x >> y) | (x << (sizeof(x) * 8 - y));
 8021470:	687a      	ldr	r2, [r7, #4]
 8021472:	683b      	ldr	r3, [r7, #0]
 8021474:	fa62 f303 	ror.w	r3, r2, r3
    }
 8021478:	4618      	mov	r0, r3
 802147a:	370c      	adds	r7, #12
 802147c:	46bd      	mov	sp, r7
 802147e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021482:	4770      	bx	lr

08021484 <ByteReverseWord32>:
{
 8021484:	b580      	push	{r7, lr}
 8021486:	b082      	sub	sp, #8
 8021488:	af00      	add	r7, sp, #0
 802148a:	6078      	str	r0, [r7, #4]
    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
 802148c:	687b      	ldr	r3, [r7, #4]
 802148e:	0a1b      	lsrs	r3, r3, #8
 8021490:	f003 12ff 	and.w	r2, r3, #16711935	@ 0xff00ff
 8021494:	687b      	ldr	r3, [r7, #4]
 8021496:	021b      	lsls	r3, r3, #8
 8021498:	f003 23ff 	and.w	r3, r3, #4278255360	@ 0xff00ff00
 802149c:	4313      	orrs	r3, r2
 802149e:	607b      	str	r3, [r7, #4]
    return rotlFixed(value, 16U);
 80214a0:	2110      	movs	r1, #16
 80214a2:	6878      	ldr	r0, [r7, #4]
 80214a4:	f7ff ffce 	bl	8021444 <rotlFixed>
 80214a8:	4603      	mov	r3, r0
}
 80214aa:	4618      	mov	r0, r3
 80214ac:	3708      	adds	r7, #8
 80214ae:	46bd      	mov	sp, r7
 80214b0:	bd80      	pop	{r7, pc}

080214b2 <ByteReverseWords>:
{
 80214b2:	b590      	push	{r4, r7, lr}
 80214b4:	b087      	sub	sp, #28
 80214b6:	af00      	add	r7, sp, #0
 80214b8:	60f8      	str	r0, [r7, #12]
 80214ba:	60b9      	str	r1, [r7, #8]
 80214bc:	607a      	str	r2, [r7, #4]
        word32 count = byteCount/(word32)sizeof(word32);
 80214be:	687b      	ldr	r3, [r7, #4]
 80214c0:	089b      	lsrs	r3, r3, #2
 80214c2:	613b      	str	r3, [r7, #16]
        for (i = 0; i < count; i++)
 80214c4:	2300      	movs	r3, #0
 80214c6:	617b      	str	r3, [r7, #20]
 80214c8:	e010      	b.n	80214ec <ByteReverseWords+0x3a>
            out[i] = ByteReverseWord32(in[i]);
 80214ca:	697b      	ldr	r3, [r7, #20]
 80214cc:	009b      	lsls	r3, r3, #2
 80214ce:	68ba      	ldr	r2, [r7, #8]
 80214d0:	4413      	add	r3, r2
 80214d2:	6819      	ldr	r1, [r3, #0]
 80214d4:	697b      	ldr	r3, [r7, #20]
 80214d6:	009b      	lsls	r3, r3, #2
 80214d8:	68fa      	ldr	r2, [r7, #12]
 80214da:	18d4      	adds	r4, r2, r3
 80214dc:	4608      	mov	r0, r1
 80214de:	f7ff ffd1 	bl	8021484 <ByteReverseWord32>
 80214e2:	4603      	mov	r3, r0
 80214e4:	6023      	str	r3, [r4, #0]
        for (i = 0; i < count; i++)
 80214e6:	697b      	ldr	r3, [r7, #20]
 80214e8:	3301      	adds	r3, #1
 80214ea:	617b      	str	r3, [r7, #20]
 80214ec:	697a      	ldr	r2, [r7, #20]
 80214ee:	693b      	ldr	r3, [r7, #16]
 80214f0:	429a      	cmp	r2, r3
 80214f2:	d3ea      	bcc.n	80214ca <ByteReverseWords+0x18>
}
 80214f4:	bf00      	nop
 80214f6:	bf00      	nop
 80214f8:	371c      	adds	r7, #28
 80214fa:	46bd      	mov	sp, r7
 80214fc:	bd90      	pop	{r4, r7, pc}

080214fe <ForceZero>:
{
 80214fe:	b480      	push	{r7}
 8021500:	b085      	sub	sp, #20
 8021502:	af00      	add	r7, sp, #0
 8021504:	6078      	str	r0, [r7, #4]
 8021506:	6039      	str	r1, [r7, #0]
    volatile byte* z = (volatile byte*)mem;
 8021508:	687b      	ldr	r3, [r7, #4]
 802150a:	60fb      	str	r3, [r7, #12]
    while (len--) *z++ = 0;
 802150c:	e004      	b.n	8021518 <ForceZero+0x1a>
 802150e:	68fb      	ldr	r3, [r7, #12]
 8021510:	1c5a      	adds	r2, r3, #1
 8021512:	60fa      	str	r2, [r7, #12]
 8021514:	2200      	movs	r2, #0
 8021516:	701a      	strb	r2, [r3, #0]
 8021518:	683b      	ldr	r3, [r7, #0]
 802151a:	1e5a      	subs	r2, r3, #1
 802151c:	603a      	str	r2, [r7, #0]
 802151e:	2b00      	cmp	r3, #0
 8021520:	d1f5      	bne.n	802150e <ForceZero+0x10>
}
 8021522:	bf00      	nop
 8021524:	bf00      	nop
 8021526:	3714      	adds	r7, #20
 8021528:	46bd      	mov	sp, r7
 802152a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802152e:	4770      	bx	lr

08021530 <min>:
    {
 8021530:	b480      	push	{r7}
 8021532:	b083      	sub	sp, #12
 8021534:	af00      	add	r7, sp, #0
 8021536:	6078      	str	r0, [r7, #4]
 8021538:	6039      	str	r1, [r7, #0]
        return a > b ? b : a;
 802153a:	687a      	ldr	r2, [r7, #4]
 802153c:	683b      	ldr	r3, [r7, #0]
 802153e:	4293      	cmp	r3, r2
 8021540:	bf28      	it	cs
 8021542:	4613      	movcs	r3, r2
    }
 8021544:	4618      	mov	r0, r3
 8021546:	370c      	adds	r7, #12
 8021548:	46bd      	mov	sp, r7
 802154a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802154e:	4770      	bx	lr

08021550 <InitSha256>:
#endif
static void Sha256_SetTransform(SHA256_SETTRANSFORM_ARGS);
#endif

static int InitSha256(wc_Sha256* sha256)
{
 8021550:	b580      	push	{r7, lr}
 8021552:	b082      	sub	sp, #8
 8021554:	af00      	add	r7, sp, #0
 8021556:	6078      	str	r0, [r7, #4]
    XMEMSET(sha256->digest, 0, sizeof(sha256->digest));
 8021558:	687b      	ldr	r3, [r7, #4]
 802155a:	2220      	movs	r2, #32
 802155c:	2100      	movs	r1, #0
 802155e:	4618      	mov	r0, r3
 8021560:	f006 ffb2 	bl	80284c8 <memset>
    sha256->digest[0] = 0x6A09E667L;
 8021564:	687b      	ldr	r3, [r7, #4]
 8021566:	4a12      	ldr	r2, [pc, #72]	@ (80215b0 <InitSha256+0x60>)
 8021568:	601a      	str	r2, [r3, #0]
    sha256->digest[1] = 0xBB67AE85L;
 802156a:	687b      	ldr	r3, [r7, #4]
 802156c:	4a11      	ldr	r2, [pc, #68]	@ (80215b4 <InitSha256+0x64>)
 802156e:	605a      	str	r2, [r3, #4]
    sha256->digest[2] = 0x3C6EF372L;
 8021570:	687b      	ldr	r3, [r7, #4]
 8021572:	4a11      	ldr	r2, [pc, #68]	@ (80215b8 <InitSha256+0x68>)
 8021574:	609a      	str	r2, [r3, #8]
    sha256->digest[3] = 0xA54FF53AL;
 8021576:	687b      	ldr	r3, [r7, #4]
 8021578:	4a10      	ldr	r2, [pc, #64]	@ (80215bc <InitSha256+0x6c>)
 802157a:	60da      	str	r2, [r3, #12]
    sha256->digest[4] = 0x510E527FL;
 802157c:	687b      	ldr	r3, [r7, #4]
 802157e:	4a10      	ldr	r2, [pc, #64]	@ (80215c0 <InitSha256+0x70>)
 8021580:	611a      	str	r2, [r3, #16]
    sha256->digest[5] = 0x9B05688CL;
 8021582:	687b      	ldr	r3, [r7, #4]
 8021584:	4a0f      	ldr	r2, [pc, #60]	@ (80215c4 <InitSha256+0x74>)
 8021586:	615a      	str	r2, [r3, #20]
    sha256->digest[6] = 0x1F83D9ABL;
 8021588:	687b      	ldr	r3, [r7, #4]
 802158a:	4a0f      	ldr	r2, [pc, #60]	@ (80215c8 <InitSha256+0x78>)
 802158c:	619a      	str	r2, [r3, #24]
    sha256->digest[7] = 0x5BE0CD19L;
 802158e:	687b      	ldr	r3, [r7, #4]
 8021590:	4a0e      	ldr	r2, [pc, #56]	@ (80215cc <InitSha256+0x7c>)
 8021592:	61da      	str	r2, [r3, #28]

    sha256->buffLen = 0;
 8021594:	687b      	ldr	r3, [r7, #4]
 8021596:	2200      	movs	r2, #0
 8021598:	661a      	str	r2, [r3, #96]	@ 0x60
    sha256->loLen   = 0;
 802159a:	687b      	ldr	r3, [r7, #4]
 802159c:	2200      	movs	r2, #0
 802159e:	665a      	str	r2, [r3, #100]	@ 0x64
    sha256->hiLen   = 0;
 80215a0:	687b      	ldr	r3, [r7, #4]
 80215a2:	2200      	movs	r2, #0
 80215a4:	669a      	str	r2, [r3, #104]	@ 0x68

#ifdef HAVE_ARIA
    sha256->hSession = NULL;
#endif

    return 0;
 80215a6:	2300      	movs	r3, #0
}
 80215a8:	4618      	mov	r0, r3
 80215aa:	3708      	adds	r7, #8
 80215ac:	46bd      	mov	sp, r7
 80215ae:	bd80      	pop	{r7, pc}
 80215b0:	6a09e667 	.word	0x6a09e667
 80215b4:	bb67ae85 	.word	0xbb67ae85
 80215b8:	3c6ef372 	.word	0x3c6ef372
 80215bc:	a54ff53a 	.word	0xa54ff53a
 80215c0:	510e527f 	.word	0x510e527f
 80215c4:	9b05688c 	.word	0x9b05688c
 80215c8:	1f83d9ab 	.word	0x1f83d9ab
 80215cc:	5be0cd19 	.word	0x5be0cd19

080215d0 <wc_InitSha256_ex>:

#else
    #define NEED_SOFT_SHA256

    int wc_InitSha256_ex(wc_Sha256* sha256, void* heap, int devId)
    {
 80215d0:	b580      	push	{r7, lr}
 80215d2:	b086      	sub	sp, #24
 80215d4:	af00      	add	r7, sp, #0
 80215d6:	60f8      	str	r0, [r7, #12]
 80215d8:	60b9      	str	r1, [r7, #8]
 80215da:	607a      	str	r2, [r7, #4]
        int ret = 0;
 80215dc:	2300      	movs	r3, #0
 80215de:	617b      	str	r3, [r7, #20]
        if (sha256 == NULL)
 80215e0:	68fb      	ldr	r3, [r7, #12]
 80215e2:	2b00      	cmp	r3, #0
 80215e4:	d102      	bne.n	80215ec <wc_InitSha256_ex+0x1c>
            return BAD_FUNC_ARG;
 80215e6:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80215ea:	e00c      	b.n	8021606 <wc_InitSha256_ex+0x36>
        ret = InitSha256(sha256);
 80215ec:	68f8      	ldr	r0, [r7, #12]
 80215ee:	f7ff ffaf 	bl	8021550 <InitSha256>
 80215f2:	6178      	str	r0, [r7, #20]
        if (ret != 0)
 80215f4:	697b      	ldr	r3, [r7, #20]
 80215f6:	2b00      	cmp	r3, #0
 80215f8:	d001      	beq.n	80215fe <wc_InitSha256_ex+0x2e>
            return ret;
 80215fa:	697b      	ldr	r3, [r7, #20]
 80215fc:	e003      	b.n	8021606 <wc_InitSha256_ex+0x36>

        sha256->heap = heap;
 80215fe:	68fb      	ldr	r3, [r7, #12]
 8021600:	68ba      	ldr	r2, [r7, #8]
 8021602:	66da      	str	r2, [r3, #108]	@ 0x6c
    #endif /* WOLFSSL_ASYNC_CRYPT */
    #ifdef WOLFSSL_IMXRT1170_CAAM
         ret = wc_CAAM_HashInit(&sha256->hndl, &sha256->ctx, WC_HASH_TYPE_SHA256);
    #endif

        return ret;
 8021604:	697b      	ldr	r3, [r7, #20]
    }
 8021606:	4618      	mov	r0, r3
 8021608:	3718      	adds	r7, #24
 802160a:	46bd      	mov	sp, r7
 802160c:	bd80      	pop	{r7, pc}
	...

08021610 <Transform_Sha256>:
         t1 = Sigma0(a(j)) + Maj(a(j), b(j), c(j)); \
         d(j) += t0; \
         h(j)  = t0 + t1

    static int Transform_Sha256(wc_Sha256* sha256, const byte* data)
    {
 8021610:	b5b0      	push	{r4, r5, r7, lr}
 8021612:	b090      	sub	sp, #64	@ 0x40
 8021614:	af00      	add	r7, sp, #0
 8021616:	6078      	str	r0, [r7, #4]
 8021618:	6039      	str	r1, [r7, #0]
                return MEMORY_E;
            sha256->W = W;
        }
    #elif defined(WOLFSSL_SMALL_STACK)
        word32* W;
        W = (word32*)XMALLOC(sizeof(word32) * WC_SHA256_BLOCK_SIZE, NULL,
 802161a:	f44f 7080 	mov.w	r0, #256	@ 0x100
 802161e:	f7fd fa33 	bl	801ea88 <wolfSSL_Malloc>
 8021622:	63b8      	str	r0, [r7, #56]	@ 0x38
                                                       DYNAMIC_TYPE_TMP_BUFFER);
        if (W == NULL)
 8021624:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8021626:	2b00      	cmp	r3, #0
 8021628:	d102      	bne.n	8021630 <Transform_Sha256+0x20>
            return MEMORY_E;
 802162a:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 802162e:	e364      	b.n	8021cfa <Transform_Sha256+0x6ea>
    #else
        word32 W[WC_SHA256_BLOCK_SIZE];
    #endif

        /* Copy context->state[] to working vars */
        for (i = 0; i < 8; i++)
 8021630:	2300      	movs	r3, #0
 8021632:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8021634:	e00c      	b.n	8021650 <Transform_Sha256+0x40>
            S[i] = sha256->digest[i];
 8021636:	687b      	ldr	r3, [r7, #4]
 8021638:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 802163a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 802163e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021640:	009b      	lsls	r3, r3, #2
 8021642:	3340      	adds	r3, #64	@ 0x40
 8021644:	443b      	add	r3, r7
 8021646:	f843 2c34 	str.w	r2, [r3, #-52]
        for (i = 0; i < 8; i++)
 802164a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802164c:	3301      	adds	r3, #1
 802164e:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8021650:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021652:	2b07      	cmp	r3, #7
 8021654:	ddef      	ble.n	8021636 <Transform_Sha256+0x26>

        for (i = 0; i < 16; i++)
 8021656:	2300      	movs	r3, #0
 8021658:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802165a:	e00d      	b.n	8021678 <Transform_Sha256+0x68>
            W[i] = *((const word32*)&data[i*(int)sizeof(word32)]);
 802165c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802165e:	009b      	lsls	r3, r3, #2
 8021660:	461a      	mov	r2, r3
 8021662:	683b      	ldr	r3, [r7, #0]
 8021664:	441a      	add	r2, r3
 8021666:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021668:	009b      	lsls	r3, r3, #2
 802166a:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 802166c:	440b      	add	r3, r1
 802166e:	6812      	ldr	r2, [r2, #0]
 8021670:	601a      	str	r2, [r3, #0]
        for (i = 0; i < 16; i++)
 8021672:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021674:	3301      	adds	r3, #1
 8021676:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8021678:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802167a:	2b0f      	cmp	r3, #15
 802167c:	ddee      	ble.n	802165c <Transform_Sha256+0x4c>

        for (i = 16; i < WC_SHA256_BLOCK_SIZE; i++)
 802167e:	2310      	movs	r3, #16
 8021680:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8021682:	e066      	b.n	8021752 <Transform_Sha256+0x142>
            W[i] = Gamma1(W[i-2]) + W[i-7] + Gamma0(W[i-15]) + W[i-16];
 8021684:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021686:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 802168a:	3b02      	subs	r3, #2
 802168c:	009b      	lsls	r3, r3, #2
 802168e:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8021690:	4413      	add	r3, r2
 8021692:	681b      	ldr	r3, [r3, #0]
 8021694:	2111      	movs	r1, #17
 8021696:	4618      	mov	r0, r3
 8021698:	f7ff fee5 	bl	8021466 <rotrFixed>
 802169c:	4604      	mov	r4, r0
 802169e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80216a0:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 80216a4:	3b02      	subs	r3, #2
 80216a6:	009b      	lsls	r3, r3, #2
 80216a8:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 80216aa:	4413      	add	r3, r2
 80216ac:	681b      	ldr	r3, [r3, #0]
 80216ae:	2113      	movs	r1, #19
 80216b0:	4618      	mov	r0, r3
 80216b2:	f7ff fed8 	bl	8021466 <rotrFixed>
 80216b6:	4603      	mov	r3, r0
 80216b8:	ea84 0203 	eor.w	r2, r4, r3
 80216bc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80216be:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 80216c2:	3b02      	subs	r3, #2
 80216c4:	009b      	lsls	r3, r3, #2
 80216c6:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 80216c8:	440b      	add	r3, r1
 80216ca:	681b      	ldr	r3, [r3, #0]
 80216cc:	0a9b      	lsrs	r3, r3, #10
 80216ce:	405a      	eors	r2, r3
 80216d0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80216d2:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 80216d6:	3b07      	subs	r3, #7
 80216d8:	009b      	lsls	r3, r3, #2
 80216da:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 80216dc:	440b      	add	r3, r1
 80216de:	681b      	ldr	r3, [r3, #0]
 80216e0:	18d4      	adds	r4, r2, r3
 80216e2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80216e4:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 80216e8:	3b0f      	subs	r3, #15
 80216ea:	009b      	lsls	r3, r3, #2
 80216ec:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 80216ee:	4413      	add	r3, r2
 80216f0:	681b      	ldr	r3, [r3, #0]
 80216f2:	2107      	movs	r1, #7
 80216f4:	4618      	mov	r0, r3
 80216f6:	f7ff feb6 	bl	8021466 <rotrFixed>
 80216fa:	4605      	mov	r5, r0
 80216fc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80216fe:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 8021702:	3b0f      	subs	r3, #15
 8021704:	009b      	lsls	r3, r3, #2
 8021706:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8021708:	4413      	add	r3, r2
 802170a:	681b      	ldr	r3, [r3, #0]
 802170c:	2112      	movs	r1, #18
 802170e:	4618      	mov	r0, r3
 8021710:	f7ff fea9 	bl	8021466 <rotrFixed>
 8021714:	4603      	mov	r3, r0
 8021716:	ea85 0203 	eor.w	r2, r5, r3
 802171a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802171c:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 8021720:	3b0f      	subs	r3, #15
 8021722:	009b      	lsls	r3, r3, #2
 8021724:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 8021726:	440b      	add	r3, r1
 8021728:	681b      	ldr	r3, [r3, #0]
 802172a:	08db      	lsrs	r3, r3, #3
 802172c:	4053      	eors	r3, r2
 802172e:	18e1      	adds	r1, r4, r3
 8021730:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021732:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 8021736:	3b10      	subs	r3, #16
 8021738:	009b      	lsls	r3, r3, #2
 802173a:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 802173c:	4413      	add	r3, r2
 802173e:	681a      	ldr	r2, [r3, #0]
 8021740:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021742:	009b      	lsls	r3, r3, #2
 8021744:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 8021746:	4403      	add	r3, r0
 8021748:	440a      	add	r2, r1
 802174a:	601a      	str	r2, [r3, #0]
        for (i = 16; i < WC_SHA256_BLOCK_SIZE; i++)
 802174c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802174e:	3301      	adds	r3, #1
 8021750:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8021752:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021754:	2b3f      	cmp	r3, #63	@ 0x3f
 8021756:	dd95      	ble.n	8021684 <Transform_Sha256+0x74>
                RND(j);
            }
        }
    #else
        /* partially loop unrolled */
        for (i = 0; i < WC_SHA256_BLOCK_SIZE; i += 8) {
 8021758:	2300      	movs	r3, #0
 802175a:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802175c:	e2a3      	b.n	8021ca6 <Transform_Sha256+0x696>
            RND(0); RND(1); RND(2); RND(3);
 802175e:	6abc      	ldr	r4, [r7, #40]	@ 0x28
 8021760:	69fb      	ldr	r3, [r7, #28]
 8021762:	2106      	movs	r1, #6
 8021764:	4618      	mov	r0, r3
 8021766:	f7ff fe7e 	bl	8021466 <rotrFixed>
 802176a:	4605      	mov	r5, r0
 802176c:	69fb      	ldr	r3, [r7, #28]
 802176e:	210b      	movs	r1, #11
 8021770:	4618      	mov	r0, r3
 8021772:	f7ff fe78 	bl	8021466 <rotrFixed>
 8021776:	4603      	mov	r3, r0
 8021778:	405d      	eors	r5, r3
 802177a:	69fb      	ldr	r3, [r7, #28]
 802177c:	2119      	movs	r1, #25
 802177e:	4618      	mov	r0, r3
 8021780:	f7ff fe71 	bl	8021466 <rotrFixed>
 8021784:	4603      	mov	r3, r0
 8021786:	406b      	eors	r3, r5
 8021788:	18e2      	adds	r2, r4, r3
 802178a:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 802178c:	69f8      	ldr	r0, [r7, #28]
 802178e:	6a3c      	ldr	r4, [r7, #32]
 8021790:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8021792:	4063      	eors	r3, r4
 8021794:	4003      	ands	r3, r0
 8021796:	404b      	eors	r3, r1
 8021798:	441a      	add	r2, r3
 802179a:	49bd      	ldr	r1, [pc, #756]	@ (8021a90 <Transform_Sha256+0x480>)
 802179c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802179e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80217a2:	441a      	add	r2, r3
 80217a4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80217a6:	009b      	lsls	r3, r3, #2
 80217a8:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 80217aa:	440b      	add	r3, r1
 80217ac:	681b      	ldr	r3, [r3, #0]
 80217ae:	4413      	add	r3, r2
 80217b0:	633b      	str	r3, [r7, #48]	@ 0x30
 80217b2:	68fb      	ldr	r3, [r7, #12]
 80217b4:	2102      	movs	r1, #2
 80217b6:	4618      	mov	r0, r3
 80217b8:	f7ff fe55 	bl	8021466 <rotrFixed>
 80217bc:	4604      	mov	r4, r0
 80217be:	68fb      	ldr	r3, [r7, #12]
 80217c0:	210d      	movs	r1, #13
 80217c2:	4618      	mov	r0, r3
 80217c4:	f7ff fe4f 	bl	8021466 <rotrFixed>
 80217c8:	4603      	mov	r3, r0
 80217ca:	405c      	eors	r4, r3
 80217cc:	68fb      	ldr	r3, [r7, #12]
 80217ce:	2116      	movs	r1, #22
 80217d0:	4618      	mov	r0, r3
 80217d2:	f7ff fe48 	bl	8021466 <rotrFixed>
 80217d6:	4603      	mov	r3, r0
 80217d8:	ea84 0203 	eor.w	r2, r4, r3
 80217dc:	68f9      	ldr	r1, [r7, #12]
 80217de:	693b      	ldr	r3, [r7, #16]
 80217e0:	4319      	orrs	r1, r3
 80217e2:	697b      	ldr	r3, [r7, #20]
 80217e4:	4019      	ands	r1, r3
 80217e6:	68f8      	ldr	r0, [r7, #12]
 80217e8:	693b      	ldr	r3, [r7, #16]
 80217ea:	4003      	ands	r3, r0
 80217ec:	430b      	orrs	r3, r1
 80217ee:	4413      	add	r3, r2
 80217f0:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80217f2:	69ba      	ldr	r2, [r7, #24]
 80217f4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80217f6:	4413      	add	r3, r2
 80217f8:	61bb      	str	r3, [r7, #24]
 80217fa:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80217fc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80217fe:	4413      	add	r3, r2
 8021800:	62bb      	str	r3, [r7, #40]	@ 0x28
 8021802:	6a7c      	ldr	r4, [r7, #36]	@ 0x24
 8021804:	69bb      	ldr	r3, [r7, #24]
 8021806:	2106      	movs	r1, #6
 8021808:	4618      	mov	r0, r3
 802180a:	f7ff fe2c 	bl	8021466 <rotrFixed>
 802180e:	4605      	mov	r5, r0
 8021810:	69bb      	ldr	r3, [r7, #24]
 8021812:	210b      	movs	r1, #11
 8021814:	4618      	mov	r0, r3
 8021816:	f7ff fe26 	bl	8021466 <rotrFixed>
 802181a:	4603      	mov	r3, r0
 802181c:	405d      	eors	r5, r3
 802181e:	69bb      	ldr	r3, [r7, #24]
 8021820:	2119      	movs	r1, #25
 8021822:	4618      	mov	r0, r3
 8021824:	f7ff fe1f 	bl	8021466 <rotrFixed>
 8021828:	4603      	mov	r3, r0
 802182a:	406b      	eors	r3, r5
 802182c:	18e2      	adds	r2, r4, r3
 802182e:	6a39      	ldr	r1, [r7, #32]
 8021830:	69b8      	ldr	r0, [r7, #24]
 8021832:	69fc      	ldr	r4, [r7, #28]
 8021834:	6a3b      	ldr	r3, [r7, #32]
 8021836:	4063      	eors	r3, r4
 8021838:	4003      	ands	r3, r0
 802183a:	404b      	eors	r3, r1
 802183c:	441a      	add	r2, r3
 802183e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021840:	3301      	adds	r3, #1
 8021842:	4993      	ldr	r1, [pc, #588]	@ (8021a90 <Transform_Sha256+0x480>)
 8021844:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8021848:	441a      	add	r2, r3
 802184a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802184c:	3301      	adds	r3, #1
 802184e:	009b      	lsls	r3, r3, #2
 8021850:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 8021852:	440b      	add	r3, r1
 8021854:	681b      	ldr	r3, [r3, #0]
 8021856:	4413      	add	r3, r2
 8021858:	633b      	str	r3, [r7, #48]	@ 0x30
 802185a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802185c:	2102      	movs	r1, #2
 802185e:	4618      	mov	r0, r3
 8021860:	f7ff fe01 	bl	8021466 <rotrFixed>
 8021864:	4604      	mov	r4, r0
 8021866:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8021868:	210d      	movs	r1, #13
 802186a:	4618      	mov	r0, r3
 802186c:	f7ff fdfb 	bl	8021466 <rotrFixed>
 8021870:	4603      	mov	r3, r0
 8021872:	405c      	eors	r4, r3
 8021874:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8021876:	2116      	movs	r1, #22
 8021878:	4618      	mov	r0, r3
 802187a:	f7ff fdf4 	bl	8021466 <rotrFixed>
 802187e:	4603      	mov	r3, r0
 8021880:	ea84 0203 	eor.w	r2, r4, r3
 8021884:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 8021886:	68fb      	ldr	r3, [r7, #12]
 8021888:	4319      	orrs	r1, r3
 802188a:	693b      	ldr	r3, [r7, #16]
 802188c:	4019      	ands	r1, r3
 802188e:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8021890:	68fb      	ldr	r3, [r7, #12]
 8021892:	4003      	ands	r3, r0
 8021894:	430b      	orrs	r3, r1
 8021896:	4413      	add	r3, r2
 8021898:	62fb      	str	r3, [r7, #44]	@ 0x2c
 802189a:	697a      	ldr	r2, [r7, #20]
 802189c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802189e:	4413      	add	r3, r2
 80218a0:	617b      	str	r3, [r7, #20]
 80218a2:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80218a4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80218a6:	4413      	add	r3, r2
 80218a8:	627b      	str	r3, [r7, #36]	@ 0x24
 80218aa:	6a3c      	ldr	r4, [r7, #32]
 80218ac:	697b      	ldr	r3, [r7, #20]
 80218ae:	2106      	movs	r1, #6
 80218b0:	4618      	mov	r0, r3
 80218b2:	f7ff fdd8 	bl	8021466 <rotrFixed>
 80218b6:	4605      	mov	r5, r0
 80218b8:	697b      	ldr	r3, [r7, #20]
 80218ba:	210b      	movs	r1, #11
 80218bc:	4618      	mov	r0, r3
 80218be:	f7ff fdd2 	bl	8021466 <rotrFixed>
 80218c2:	4603      	mov	r3, r0
 80218c4:	405d      	eors	r5, r3
 80218c6:	697b      	ldr	r3, [r7, #20]
 80218c8:	2119      	movs	r1, #25
 80218ca:	4618      	mov	r0, r3
 80218cc:	f7ff fdcb 	bl	8021466 <rotrFixed>
 80218d0:	4603      	mov	r3, r0
 80218d2:	406b      	eors	r3, r5
 80218d4:	18e2      	adds	r2, r4, r3
 80218d6:	69f9      	ldr	r1, [r7, #28]
 80218d8:	6978      	ldr	r0, [r7, #20]
 80218da:	69bc      	ldr	r4, [r7, #24]
 80218dc:	69fb      	ldr	r3, [r7, #28]
 80218de:	4063      	eors	r3, r4
 80218e0:	4003      	ands	r3, r0
 80218e2:	404b      	eors	r3, r1
 80218e4:	441a      	add	r2, r3
 80218e6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80218e8:	3302      	adds	r3, #2
 80218ea:	4969      	ldr	r1, [pc, #420]	@ (8021a90 <Transform_Sha256+0x480>)
 80218ec:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80218f0:	441a      	add	r2, r3
 80218f2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80218f4:	3302      	adds	r3, #2
 80218f6:	009b      	lsls	r3, r3, #2
 80218f8:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 80218fa:	440b      	add	r3, r1
 80218fc:	681b      	ldr	r3, [r3, #0]
 80218fe:	4413      	add	r3, r2
 8021900:	633b      	str	r3, [r7, #48]	@ 0x30
 8021902:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8021904:	2102      	movs	r1, #2
 8021906:	4618      	mov	r0, r3
 8021908:	f7ff fdad 	bl	8021466 <rotrFixed>
 802190c:	4604      	mov	r4, r0
 802190e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8021910:	210d      	movs	r1, #13
 8021912:	4618      	mov	r0, r3
 8021914:	f7ff fda7 	bl	8021466 <rotrFixed>
 8021918:	4603      	mov	r3, r0
 802191a:	405c      	eors	r4, r3
 802191c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802191e:	2116      	movs	r1, #22
 8021920:	4618      	mov	r0, r3
 8021922:	f7ff fda0 	bl	8021466 <rotrFixed>
 8021926:	4603      	mov	r3, r0
 8021928:	ea84 0203 	eor.w	r2, r4, r3
 802192c:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 802192e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8021930:	4319      	orrs	r1, r3
 8021932:	68fb      	ldr	r3, [r7, #12]
 8021934:	4019      	ands	r1, r3
 8021936:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8021938:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802193a:	4003      	ands	r3, r0
 802193c:	430b      	orrs	r3, r1
 802193e:	4413      	add	r3, r2
 8021940:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8021942:	693a      	ldr	r2, [r7, #16]
 8021944:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8021946:	4413      	add	r3, r2
 8021948:	613b      	str	r3, [r7, #16]
 802194a:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 802194c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802194e:	4413      	add	r3, r2
 8021950:	623b      	str	r3, [r7, #32]
 8021952:	69fc      	ldr	r4, [r7, #28]
 8021954:	693b      	ldr	r3, [r7, #16]
 8021956:	2106      	movs	r1, #6
 8021958:	4618      	mov	r0, r3
 802195a:	f7ff fd84 	bl	8021466 <rotrFixed>
 802195e:	4605      	mov	r5, r0
 8021960:	693b      	ldr	r3, [r7, #16]
 8021962:	210b      	movs	r1, #11
 8021964:	4618      	mov	r0, r3
 8021966:	f7ff fd7e 	bl	8021466 <rotrFixed>
 802196a:	4603      	mov	r3, r0
 802196c:	405d      	eors	r5, r3
 802196e:	693b      	ldr	r3, [r7, #16]
 8021970:	2119      	movs	r1, #25
 8021972:	4618      	mov	r0, r3
 8021974:	f7ff fd77 	bl	8021466 <rotrFixed>
 8021978:	4603      	mov	r3, r0
 802197a:	406b      	eors	r3, r5
 802197c:	18e2      	adds	r2, r4, r3
 802197e:	69b9      	ldr	r1, [r7, #24]
 8021980:	6938      	ldr	r0, [r7, #16]
 8021982:	697c      	ldr	r4, [r7, #20]
 8021984:	69bb      	ldr	r3, [r7, #24]
 8021986:	4063      	eors	r3, r4
 8021988:	4003      	ands	r3, r0
 802198a:	404b      	eors	r3, r1
 802198c:	441a      	add	r2, r3
 802198e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021990:	3303      	adds	r3, #3
 8021992:	493f      	ldr	r1, [pc, #252]	@ (8021a90 <Transform_Sha256+0x480>)
 8021994:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8021998:	441a      	add	r2, r3
 802199a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802199c:	3303      	adds	r3, #3
 802199e:	009b      	lsls	r3, r3, #2
 80219a0:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 80219a2:	440b      	add	r3, r1
 80219a4:	681b      	ldr	r3, [r3, #0]
 80219a6:	4413      	add	r3, r2
 80219a8:	633b      	str	r3, [r7, #48]	@ 0x30
 80219aa:	6a3b      	ldr	r3, [r7, #32]
 80219ac:	2102      	movs	r1, #2
 80219ae:	4618      	mov	r0, r3
 80219b0:	f7ff fd59 	bl	8021466 <rotrFixed>
 80219b4:	4604      	mov	r4, r0
 80219b6:	6a3b      	ldr	r3, [r7, #32]
 80219b8:	210d      	movs	r1, #13
 80219ba:	4618      	mov	r0, r3
 80219bc:	f7ff fd53 	bl	8021466 <rotrFixed>
 80219c0:	4603      	mov	r3, r0
 80219c2:	405c      	eors	r4, r3
 80219c4:	6a3b      	ldr	r3, [r7, #32]
 80219c6:	2116      	movs	r1, #22
 80219c8:	4618      	mov	r0, r3
 80219ca:	f7ff fd4c 	bl	8021466 <rotrFixed>
 80219ce:	4603      	mov	r3, r0
 80219d0:	ea84 0203 	eor.w	r2, r4, r3
 80219d4:	6a39      	ldr	r1, [r7, #32]
 80219d6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80219d8:	4319      	orrs	r1, r3
 80219da:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80219dc:	4019      	ands	r1, r3
 80219de:	6a38      	ldr	r0, [r7, #32]
 80219e0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80219e2:	4003      	ands	r3, r0
 80219e4:	430b      	orrs	r3, r1
 80219e6:	4413      	add	r3, r2
 80219e8:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80219ea:	68fa      	ldr	r2, [r7, #12]
 80219ec:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80219ee:	4413      	add	r3, r2
 80219f0:	60fb      	str	r3, [r7, #12]
 80219f2:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80219f4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80219f6:	4413      	add	r3, r2
 80219f8:	61fb      	str	r3, [r7, #28]
            RND(4); RND(5); RND(6); RND(7);
 80219fa:	69bc      	ldr	r4, [r7, #24]
 80219fc:	68fb      	ldr	r3, [r7, #12]
 80219fe:	2106      	movs	r1, #6
 8021a00:	4618      	mov	r0, r3
 8021a02:	f7ff fd30 	bl	8021466 <rotrFixed>
 8021a06:	4605      	mov	r5, r0
 8021a08:	68fb      	ldr	r3, [r7, #12]
 8021a0a:	210b      	movs	r1, #11
 8021a0c:	4618      	mov	r0, r3
 8021a0e:	f7ff fd2a 	bl	8021466 <rotrFixed>
 8021a12:	4603      	mov	r3, r0
 8021a14:	405d      	eors	r5, r3
 8021a16:	68fb      	ldr	r3, [r7, #12]
 8021a18:	2119      	movs	r1, #25
 8021a1a:	4618      	mov	r0, r3
 8021a1c:	f7ff fd23 	bl	8021466 <rotrFixed>
 8021a20:	4603      	mov	r3, r0
 8021a22:	406b      	eors	r3, r5
 8021a24:	18e2      	adds	r2, r4, r3
 8021a26:	6979      	ldr	r1, [r7, #20]
 8021a28:	68f8      	ldr	r0, [r7, #12]
 8021a2a:	693c      	ldr	r4, [r7, #16]
 8021a2c:	697b      	ldr	r3, [r7, #20]
 8021a2e:	4063      	eors	r3, r4
 8021a30:	4003      	ands	r3, r0
 8021a32:	404b      	eors	r3, r1
 8021a34:	441a      	add	r2, r3
 8021a36:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021a38:	3304      	adds	r3, #4
 8021a3a:	4915      	ldr	r1, [pc, #84]	@ (8021a90 <Transform_Sha256+0x480>)
 8021a3c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8021a40:	441a      	add	r2, r3
 8021a42:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021a44:	3304      	adds	r3, #4
 8021a46:	009b      	lsls	r3, r3, #2
 8021a48:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 8021a4a:	440b      	add	r3, r1
 8021a4c:	681b      	ldr	r3, [r3, #0]
 8021a4e:	4413      	add	r3, r2
 8021a50:	633b      	str	r3, [r7, #48]	@ 0x30
 8021a52:	69fb      	ldr	r3, [r7, #28]
 8021a54:	2102      	movs	r1, #2
 8021a56:	4618      	mov	r0, r3
 8021a58:	f7ff fd05 	bl	8021466 <rotrFixed>
 8021a5c:	4604      	mov	r4, r0
 8021a5e:	69fb      	ldr	r3, [r7, #28]
 8021a60:	210d      	movs	r1, #13
 8021a62:	4618      	mov	r0, r3
 8021a64:	f7ff fcff 	bl	8021466 <rotrFixed>
 8021a68:	4603      	mov	r3, r0
 8021a6a:	405c      	eors	r4, r3
 8021a6c:	69fb      	ldr	r3, [r7, #28]
 8021a6e:	2116      	movs	r1, #22
 8021a70:	4618      	mov	r0, r3
 8021a72:	f7ff fcf8 	bl	8021466 <rotrFixed>
 8021a76:	4603      	mov	r3, r0
 8021a78:	ea84 0203 	eor.w	r2, r4, r3
 8021a7c:	69f9      	ldr	r1, [r7, #28]
 8021a7e:	6a3b      	ldr	r3, [r7, #32]
 8021a80:	4319      	orrs	r1, r3
 8021a82:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8021a84:	4019      	ands	r1, r3
 8021a86:	69f8      	ldr	r0, [r7, #28]
 8021a88:	6a3b      	ldr	r3, [r7, #32]
 8021a8a:	4003      	ands	r3, r0
 8021a8c:	430b      	orrs	r3, r1
 8021a8e:	e001      	b.n	8021a94 <Transform_Sha256+0x484>
 8021a90:	08033d00 	.word	0x08033d00
 8021a94:	4413      	add	r3, r2
 8021a96:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8021a98:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8021a9a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8021a9c:	4413      	add	r3, r2
 8021a9e:	62bb      	str	r3, [r7, #40]	@ 0x28
 8021aa0:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8021aa2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8021aa4:	4413      	add	r3, r2
 8021aa6:	61bb      	str	r3, [r7, #24]
 8021aa8:	697c      	ldr	r4, [r7, #20]
 8021aaa:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8021aac:	2106      	movs	r1, #6
 8021aae:	4618      	mov	r0, r3
 8021ab0:	f7ff fcd9 	bl	8021466 <rotrFixed>
 8021ab4:	4605      	mov	r5, r0
 8021ab6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8021ab8:	210b      	movs	r1, #11
 8021aba:	4618      	mov	r0, r3
 8021abc:	f7ff fcd3 	bl	8021466 <rotrFixed>
 8021ac0:	4603      	mov	r3, r0
 8021ac2:	405d      	eors	r5, r3
 8021ac4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8021ac6:	2119      	movs	r1, #25
 8021ac8:	4618      	mov	r0, r3
 8021aca:	f7ff fccc 	bl	8021466 <rotrFixed>
 8021ace:	4603      	mov	r3, r0
 8021ad0:	406b      	eors	r3, r5
 8021ad2:	18e2      	adds	r2, r4, r3
 8021ad4:	6939      	ldr	r1, [r7, #16]
 8021ad6:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8021ad8:	68fc      	ldr	r4, [r7, #12]
 8021ada:	693b      	ldr	r3, [r7, #16]
 8021adc:	4063      	eors	r3, r4
 8021ade:	4003      	ands	r3, r0
 8021ae0:	404b      	eors	r3, r1
 8021ae2:	441a      	add	r2, r3
 8021ae4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021ae6:	3305      	adds	r3, #5
 8021ae8:	4986      	ldr	r1, [pc, #536]	@ (8021d04 <Transform_Sha256+0x6f4>)
 8021aea:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8021aee:	441a      	add	r2, r3
 8021af0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021af2:	3305      	adds	r3, #5
 8021af4:	009b      	lsls	r3, r3, #2
 8021af6:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 8021af8:	440b      	add	r3, r1
 8021afa:	681b      	ldr	r3, [r3, #0]
 8021afc:	4413      	add	r3, r2
 8021afe:	633b      	str	r3, [r7, #48]	@ 0x30
 8021b00:	69bb      	ldr	r3, [r7, #24]
 8021b02:	2102      	movs	r1, #2
 8021b04:	4618      	mov	r0, r3
 8021b06:	f7ff fcae 	bl	8021466 <rotrFixed>
 8021b0a:	4604      	mov	r4, r0
 8021b0c:	69bb      	ldr	r3, [r7, #24]
 8021b0e:	210d      	movs	r1, #13
 8021b10:	4618      	mov	r0, r3
 8021b12:	f7ff fca8 	bl	8021466 <rotrFixed>
 8021b16:	4603      	mov	r3, r0
 8021b18:	405c      	eors	r4, r3
 8021b1a:	69bb      	ldr	r3, [r7, #24]
 8021b1c:	2116      	movs	r1, #22
 8021b1e:	4618      	mov	r0, r3
 8021b20:	f7ff fca1 	bl	8021466 <rotrFixed>
 8021b24:	4603      	mov	r3, r0
 8021b26:	ea84 0203 	eor.w	r2, r4, r3
 8021b2a:	69b9      	ldr	r1, [r7, #24]
 8021b2c:	69fb      	ldr	r3, [r7, #28]
 8021b2e:	4319      	orrs	r1, r3
 8021b30:	6a3b      	ldr	r3, [r7, #32]
 8021b32:	4019      	ands	r1, r3
 8021b34:	69b8      	ldr	r0, [r7, #24]
 8021b36:	69fb      	ldr	r3, [r7, #28]
 8021b38:	4003      	ands	r3, r0
 8021b3a:	430b      	orrs	r3, r1
 8021b3c:	4413      	add	r3, r2
 8021b3e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8021b40:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8021b42:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8021b44:	4413      	add	r3, r2
 8021b46:	627b      	str	r3, [r7, #36]	@ 0x24
 8021b48:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8021b4a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8021b4c:	4413      	add	r3, r2
 8021b4e:	617b      	str	r3, [r7, #20]
 8021b50:	693c      	ldr	r4, [r7, #16]
 8021b52:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8021b54:	2106      	movs	r1, #6
 8021b56:	4618      	mov	r0, r3
 8021b58:	f7ff fc85 	bl	8021466 <rotrFixed>
 8021b5c:	4605      	mov	r5, r0
 8021b5e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8021b60:	210b      	movs	r1, #11
 8021b62:	4618      	mov	r0, r3
 8021b64:	f7ff fc7f 	bl	8021466 <rotrFixed>
 8021b68:	4603      	mov	r3, r0
 8021b6a:	405d      	eors	r5, r3
 8021b6c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8021b6e:	2119      	movs	r1, #25
 8021b70:	4618      	mov	r0, r3
 8021b72:	f7ff fc78 	bl	8021466 <rotrFixed>
 8021b76:	4603      	mov	r3, r0
 8021b78:	406b      	eors	r3, r5
 8021b7a:	18e2      	adds	r2, r4, r3
 8021b7c:	68f9      	ldr	r1, [r7, #12]
 8021b7e:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8021b80:	6abc      	ldr	r4, [r7, #40]	@ 0x28
 8021b82:	68fb      	ldr	r3, [r7, #12]
 8021b84:	4063      	eors	r3, r4
 8021b86:	4003      	ands	r3, r0
 8021b88:	404b      	eors	r3, r1
 8021b8a:	441a      	add	r2, r3
 8021b8c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021b8e:	3306      	adds	r3, #6
 8021b90:	495c      	ldr	r1, [pc, #368]	@ (8021d04 <Transform_Sha256+0x6f4>)
 8021b92:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8021b96:	441a      	add	r2, r3
 8021b98:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021b9a:	3306      	adds	r3, #6
 8021b9c:	009b      	lsls	r3, r3, #2
 8021b9e:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 8021ba0:	440b      	add	r3, r1
 8021ba2:	681b      	ldr	r3, [r3, #0]
 8021ba4:	4413      	add	r3, r2
 8021ba6:	633b      	str	r3, [r7, #48]	@ 0x30
 8021ba8:	697b      	ldr	r3, [r7, #20]
 8021baa:	2102      	movs	r1, #2
 8021bac:	4618      	mov	r0, r3
 8021bae:	f7ff fc5a 	bl	8021466 <rotrFixed>
 8021bb2:	4604      	mov	r4, r0
 8021bb4:	697b      	ldr	r3, [r7, #20]
 8021bb6:	210d      	movs	r1, #13
 8021bb8:	4618      	mov	r0, r3
 8021bba:	f7ff fc54 	bl	8021466 <rotrFixed>
 8021bbe:	4603      	mov	r3, r0
 8021bc0:	405c      	eors	r4, r3
 8021bc2:	697b      	ldr	r3, [r7, #20]
 8021bc4:	2116      	movs	r1, #22
 8021bc6:	4618      	mov	r0, r3
 8021bc8:	f7ff fc4d 	bl	8021466 <rotrFixed>
 8021bcc:	4603      	mov	r3, r0
 8021bce:	ea84 0203 	eor.w	r2, r4, r3
 8021bd2:	6979      	ldr	r1, [r7, #20]
 8021bd4:	69bb      	ldr	r3, [r7, #24]
 8021bd6:	4319      	orrs	r1, r3
 8021bd8:	69fb      	ldr	r3, [r7, #28]
 8021bda:	4019      	ands	r1, r3
 8021bdc:	6978      	ldr	r0, [r7, #20]
 8021bde:	69bb      	ldr	r3, [r7, #24]
 8021be0:	4003      	ands	r3, r0
 8021be2:	430b      	orrs	r3, r1
 8021be4:	4413      	add	r3, r2
 8021be6:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8021be8:	6a3a      	ldr	r2, [r7, #32]
 8021bea:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8021bec:	4413      	add	r3, r2
 8021bee:	623b      	str	r3, [r7, #32]
 8021bf0:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8021bf2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8021bf4:	4413      	add	r3, r2
 8021bf6:	613b      	str	r3, [r7, #16]
 8021bf8:	68fc      	ldr	r4, [r7, #12]
 8021bfa:	6a3b      	ldr	r3, [r7, #32]
 8021bfc:	2106      	movs	r1, #6
 8021bfe:	4618      	mov	r0, r3
 8021c00:	f7ff fc31 	bl	8021466 <rotrFixed>
 8021c04:	4605      	mov	r5, r0
 8021c06:	6a3b      	ldr	r3, [r7, #32]
 8021c08:	210b      	movs	r1, #11
 8021c0a:	4618      	mov	r0, r3
 8021c0c:	f7ff fc2b 	bl	8021466 <rotrFixed>
 8021c10:	4603      	mov	r3, r0
 8021c12:	405d      	eors	r5, r3
 8021c14:	6a3b      	ldr	r3, [r7, #32]
 8021c16:	2119      	movs	r1, #25
 8021c18:	4618      	mov	r0, r3
 8021c1a:	f7ff fc24 	bl	8021466 <rotrFixed>
 8021c1e:	4603      	mov	r3, r0
 8021c20:	406b      	eors	r3, r5
 8021c22:	18e2      	adds	r2, r4, r3
 8021c24:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 8021c26:	6a38      	ldr	r0, [r7, #32]
 8021c28:	6a7c      	ldr	r4, [r7, #36]	@ 0x24
 8021c2a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8021c2c:	4063      	eors	r3, r4
 8021c2e:	4003      	ands	r3, r0
 8021c30:	404b      	eors	r3, r1
 8021c32:	441a      	add	r2, r3
 8021c34:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021c36:	3307      	adds	r3, #7
 8021c38:	4932      	ldr	r1, [pc, #200]	@ (8021d04 <Transform_Sha256+0x6f4>)
 8021c3a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8021c3e:	441a      	add	r2, r3
 8021c40:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021c42:	3307      	adds	r3, #7
 8021c44:	009b      	lsls	r3, r3, #2
 8021c46:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 8021c48:	440b      	add	r3, r1
 8021c4a:	681b      	ldr	r3, [r3, #0]
 8021c4c:	4413      	add	r3, r2
 8021c4e:	633b      	str	r3, [r7, #48]	@ 0x30
 8021c50:	693b      	ldr	r3, [r7, #16]
 8021c52:	2102      	movs	r1, #2
 8021c54:	4618      	mov	r0, r3
 8021c56:	f7ff fc06 	bl	8021466 <rotrFixed>
 8021c5a:	4604      	mov	r4, r0
 8021c5c:	693b      	ldr	r3, [r7, #16]
 8021c5e:	210d      	movs	r1, #13
 8021c60:	4618      	mov	r0, r3
 8021c62:	f7ff fc00 	bl	8021466 <rotrFixed>
 8021c66:	4603      	mov	r3, r0
 8021c68:	405c      	eors	r4, r3
 8021c6a:	693b      	ldr	r3, [r7, #16]
 8021c6c:	2116      	movs	r1, #22
 8021c6e:	4618      	mov	r0, r3
 8021c70:	f7ff fbf9 	bl	8021466 <rotrFixed>
 8021c74:	4603      	mov	r3, r0
 8021c76:	ea84 0203 	eor.w	r2, r4, r3
 8021c7a:	6939      	ldr	r1, [r7, #16]
 8021c7c:	697b      	ldr	r3, [r7, #20]
 8021c7e:	4319      	orrs	r1, r3
 8021c80:	69bb      	ldr	r3, [r7, #24]
 8021c82:	4019      	ands	r1, r3
 8021c84:	6938      	ldr	r0, [r7, #16]
 8021c86:	697b      	ldr	r3, [r7, #20]
 8021c88:	4003      	ands	r3, r0
 8021c8a:	430b      	orrs	r3, r1
 8021c8c:	4413      	add	r3, r2
 8021c8e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8021c90:	69fa      	ldr	r2, [r7, #28]
 8021c92:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8021c94:	4413      	add	r3, r2
 8021c96:	61fb      	str	r3, [r7, #28]
 8021c98:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8021c9a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8021c9c:	4413      	add	r3, r2
 8021c9e:	60fb      	str	r3, [r7, #12]
        for (i = 0; i < WC_SHA256_BLOCK_SIZE; i += 8) {
 8021ca0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021ca2:	3308      	adds	r3, #8
 8021ca4:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8021ca6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021ca8:	2b3f      	cmp	r3, #63	@ 0x3f
 8021caa:	f77f ad58 	ble.w	802175e <Transform_Sha256+0x14e>
        }
    #endif /* USE_SLOW_SHA256 */

        /* Add the working vars back into digest state[] */
        for (i = 0; i < 8; i++) {
 8021cae:	2300      	movs	r3, #0
 8021cb0:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8021cb2:	e011      	b.n	8021cd8 <Transform_Sha256+0x6c8>
            sha256->digest[i] += S[i];
 8021cb4:	687b      	ldr	r3, [r7, #4]
 8021cb6:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8021cb8:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8021cbc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021cbe:	009b      	lsls	r3, r3, #2
 8021cc0:	3340      	adds	r3, #64	@ 0x40
 8021cc2:	443b      	add	r3, r7
 8021cc4:	f853 3c34 	ldr.w	r3, [r3, #-52]
 8021cc8:	18d1      	adds	r1, r2, r3
 8021cca:	687b      	ldr	r3, [r7, #4]
 8021ccc:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8021cce:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        for (i = 0; i < 8; i++) {
 8021cd2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021cd4:	3301      	adds	r3, #1
 8021cd6:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8021cd8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021cda:	2b07      	cmp	r3, #7
 8021cdc:	ddea      	ble.n	8021cb4 <Transform_Sha256+0x6a4>
        }

    #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SMALL_STACK_CACHE)
        ForceZero(W, sizeof(word32) * WC_SHA256_BLOCK_SIZE);
 8021cde:	f44f 7180 	mov.w	r1, #256	@ 0x100
 8021ce2:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 8021ce4:	f7ff fc0b 	bl	80214fe <ForceZero>
        XFREE(W, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 8021ce8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8021cea:	637b      	str	r3, [r7, #52]	@ 0x34
 8021cec:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8021cee:	2b00      	cmp	r3, #0
 8021cf0:	d002      	beq.n	8021cf8 <Transform_Sha256+0x6e8>
 8021cf2:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 8021cf4:	f7fc fee4 	bl	801eac0 <wolfSSL_Free>
    #endif
        return 0;
 8021cf8:	2300      	movs	r3, #0
    }
 8021cfa:	4618      	mov	r0, r3
 8021cfc:	3740      	adds	r7, #64	@ 0x40
 8021cfe:	46bd      	mov	sp, r7
 8021d00:	bdb0      	pop	{r4, r5, r7, pc}
 8021d02:	bf00      	nop
 8021d04:	08033d00 	.word	0x08033d00

08021d08 <AddLength>:


#ifdef XTRANSFORM

    static WC_INLINE void AddLength(wc_Sha256* sha256, word32 len)
    {
 8021d08:	b480      	push	{r7}
 8021d0a:	b085      	sub	sp, #20
 8021d0c:	af00      	add	r7, sp, #0
 8021d0e:	6078      	str	r0, [r7, #4]
 8021d10:	6039      	str	r1, [r7, #0]
        word32 tmp = sha256->loLen;
 8021d12:	687b      	ldr	r3, [r7, #4]
 8021d14:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8021d16:	60fb      	str	r3, [r7, #12]
        if ((sha256->loLen += len) < tmp) {
 8021d18:	687b      	ldr	r3, [r7, #4]
 8021d1a:	6e5a      	ldr	r2, [r3, #100]	@ 0x64
 8021d1c:	683b      	ldr	r3, [r7, #0]
 8021d1e:	441a      	add	r2, r3
 8021d20:	687b      	ldr	r3, [r7, #4]
 8021d22:	665a      	str	r2, [r3, #100]	@ 0x64
 8021d24:	687b      	ldr	r3, [r7, #4]
 8021d26:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8021d28:	68fa      	ldr	r2, [r7, #12]
 8021d2a:	429a      	cmp	r2, r3
 8021d2c:	d904      	bls.n	8021d38 <AddLength+0x30>
            sha256->hiLen++;                       /* carry low to high */
 8021d2e:	687b      	ldr	r3, [r7, #4]
 8021d30:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 8021d32:	1c5a      	adds	r2, r3, #1
 8021d34:	687b      	ldr	r3, [r7, #4]
 8021d36:	669a      	str	r2, [r3, #104]	@ 0x68
        }
    }
 8021d38:	bf00      	nop
 8021d3a:	3714      	adds	r7, #20
 8021d3c:	46bd      	mov	sp, r7
 8021d3e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021d42:	4770      	bx	lr

08021d44 <Sha256Update>:

    /* do block size increments/updates */
    static WC_INLINE int Sha256Update(wc_Sha256* sha256, const byte* data,
        word32 len)
    {
 8021d44:	b580      	push	{r7, lr}
 8021d46:	b088      	sub	sp, #32
 8021d48:	af00      	add	r7, sp, #0
 8021d4a:	60f8      	str	r0, [r7, #12]
 8021d4c:	60b9      	str	r1, [r7, #8]
 8021d4e:	607a      	str	r2, [r7, #4]
        int ret = 0;
 8021d50:	2300      	movs	r3, #0
 8021d52:	61fb      	str	r3, [r7, #28]
        word32 blocksLen;
        byte* local;

        /* check that internal buffLen is valid */
        if (sha256->buffLen >= WC_SHA256_BLOCK_SIZE) {
 8021d54:	68fb      	ldr	r3, [r7, #12]
 8021d56:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8021d58:	2b3f      	cmp	r3, #63	@ 0x3f
 8021d5a:	d902      	bls.n	8021d62 <Sha256Update+0x1e>
            return BUFFER_E;
 8021d5c:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8021d60:	e075      	b.n	8021e4e <Sha256Update+0x10a>
        }

        /* add length for final */
        AddLength(sha256, len);
 8021d62:	6879      	ldr	r1, [r7, #4]
 8021d64:	68f8      	ldr	r0, [r7, #12]
 8021d66:	f7ff ffcf 	bl	8021d08 <AddLength>

        local = (byte*)sha256->buffer;
 8021d6a:	68fb      	ldr	r3, [r7, #12]
 8021d6c:	3320      	adds	r3, #32
 8021d6e:	61bb      	str	r3, [r7, #24]

        /* process any remainder from previous operation */
        if (sha256->buffLen > 0) {
 8021d70:	68fb      	ldr	r3, [r7, #12]
 8021d72:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8021d74:	2b00      	cmp	r3, #0
 8021d76:	d056      	beq.n	8021e26 <Sha256Update+0xe2>
            blocksLen = min(len, WC_SHA256_BLOCK_SIZE - sha256->buffLen);
 8021d78:	68fb      	ldr	r3, [r7, #12]
 8021d7a:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8021d7c:	f1c3 0340 	rsb	r3, r3, #64	@ 0x40
 8021d80:	4619      	mov	r1, r3
 8021d82:	6878      	ldr	r0, [r7, #4]
 8021d84:	f7ff fbd4 	bl	8021530 <min>
 8021d88:	6178      	str	r0, [r7, #20]
            XMEMCPY(&local[sha256->buffLen], data, blocksLen);
 8021d8a:	68fb      	ldr	r3, [r7, #12]
 8021d8c:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8021d8e:	69ba      	ldr	r2, [r7, #24]
 8021d90:	4413      	add	r3, r2
 8021d92:	697a      	ldr	r2, [r7, #20]
 8021d94:	68b9      	ldr	r1, [r7, #8]
 8021d96:	4618      	mov	r0, r3
 8021d98:	f006 fc00 	bl	802859c <memcpy>

            sha256->buffLen += blocksLen;
 8021d9c:	68fb      	ldr	r3, [r7, #12]
 8021d9e:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
 8021da0:	697b      	ldr	r3, [r7, #20]
 8021da2:	441a      	add	r2, r3
 8021da4:	68fb      	ldr	r3, [r7, #12]
 8021da6:	661a      	str	r2, [r3, #96]	@ 0x60
            data            += blocksLen;
 8021da8:	68ba      	ldr	r2, [r7, #8]
 8021daa:	697b      	ldr	r3, [r7, #20]
 8021dac:	4413      	add	r3, r2
 8021dae:	60bb      	str	r3, [r7, #8]
            len             -= blocksLen;
 8021db0:	687a      	ldr	r2, [r7, #4]
 8021db2:	697b      	ldr	r3, [r7, #20]
 8021db4:	1ad3      	subs	r3, r2, r3
 8021db6:	607b      	str	r3, [r7, #4]

            if (sha256->buffLen == WC_SHA256_BLOCK_SIZE) {
 8021db8:	68fb      	ldr	r3, [r7, #12]
 8021dba:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8021dbc:	2b40      	cmp	r3, #64	@ 0x40
 8021dbe:	d132      	bne.n	8021e26 <Sha256Update+0xe2>
                    esp_sha_try_hw_lock(&sha256->ctx);
                }
            #endif

            if (SHA256_UPDATE_REV_BYTES(&sha256->ctx)) {
                ByteReverseWords(sha256->buffer, sha256->buffer,
 8021dc0:	68fb      	ldr	r3, [r7, #12]
 8021dc2:	f103 0020 	add.w	r0, r3, #32
 8021dc6:	68fb      	ldr	r3, [r7, #12]
 8021dc8:	3320      	adds	r3, #32
 8021dca:	2240      	movs	r2, #64	@ 0x40
 8021dcc:	4619      	mov	r1, r3
 8021dce:	f7ff fb70 	bl	80214b2 <ByteReverseWords>
                    #endif
                    esp_sha256_process(sha256, (const byte*)local);
                }
            #else
                /* Always SW */
                ret = XTRANSFORM(sha256, (const byte*)local);
 8021dd2:	69b9      	ldr	r1, [r7, #24]
 8021dd4:	68f8      	ldr	r0, [r7, #12]
 8021dd6:	f7ff fc1b 	bl	8021610 <Transform_Sha256>
 8021dda:	61f8      	str	r0, [r7, #28]
            #endif
                if (ret == 0)
 8021ddc:	69fb      	ldr	r3, [r7, #28]
 8021dde:	2b00      	cmp	r3, #0
 8021de0:	d103      	bne.n	8021dea <Sha256Update+0xa6>
                    sha256->buffLen = 0;
 8021de2:	68fb      	ldr	r3, [r7, #12]
 8021de4:	2200      	movs	r2, #0
 8021de6:	661a      	str	r2, [r3, #96]	@ 0x60
 8021de8:	e01d      	b.n	8021e26 <Sha256Update+0xe2>
                else
                    len = 0; /* error */
 8021dea:	2300      	movs	r3, #0
 8021dec:	607b      	str	r3, [r7, #4]
    #endif /* XTRANSFORM_LEN */
    #if !defined(XTRANSFORM_LEN) || \
        (defined(WOLFSSL_X86_64_BUILD) && defined(USE_INTEL_SPEEDUP) && \
         (defined(HAVE_INTEL_AVX1) || defined(HAVE_INTEL_AVX2)))
        {
            while (len >= WC_SHA256_BLOCK_SIZE) {
 8021dee:	e01a      	b.n	8021e26 <Sha256Update+0xe2>
                word32* local32 = sha256->buffer;
 8021df0:	68fb      	ldr	r3, [r7, #12]
 8021df2:	3320      	adds	r3, #32
 8021df4:	613b      	str	r3, [r7, #16]
                    local32 = (word32*)data;
                }
                else
            #endif
                {
                    XMEMCPY(local32, data, WC_SHA256_BLOCK_SIZE);
 8021df6:	2240      	movs	r2, #64	@ 0x40
 8021df8:	68b9      	ldr	r1, [r7, #8]
 8021dfa:	6938      	ldr	r0, [r7, #16]
 8021dfc:	f006 fbce 	bl	802859c <memcpy>
                }

                data += WC_SHA256_BLOCK_SIZE;
 8021e00:	68bb      	ldr	r3, [r7, #8]
 8021e02:	3340      	adds	r3, #64	@ 0x40
 8021e04:	60bb      	str	r3, [r7, #8]
                len  -= WC_SHA256_BLOCK_SIZE;
 8021e06:	687b      	ldr	r3, [r7, #4]
 8021e08:	3b40      	subs	r3, #64	@ 0x40
 8021e0a:	607b      	str	r3, [r7, #4]
                    esp_sha_try_hw_lock(&sha256->ctx);
                }
            #endif

            if (SHA256_UPDATE_REV_BYTES(&sha256->ctx)) {
                ByteReverseWords(local32, local32, WC_SHA256_BLOCK_SIZE);
 8021e0c:	2240      	movs	r2, #64	@ 0x40
 8021e0e:	6939      	ldr	r1, [r7, #16]
 8021e10:	6938      	ldr	r0, [r7, #16]
 8021e12:	f7ff fb4e 	bl	80214b2 <ByteReverseWords>
                else {
                    ESP_LOGV(TAG, "Sha256Update process hardware");
                    esp_sha256_process(sha256, (const byte*)local32);
                }
            #else
                ret = XTRANSFORM(sha256, (const byte*)local32);
 8021e16:	6939      	ldr	r1, [r7, #16]
 8021e18:	68f8      	ldr	r0, [r7, #12]
 8021e1a:	f7ff fbf9 	bl	8021610 <Transform_Sha256>
 8021e1e:	61f8      	str	r0, [r7, #28]
            #endif

                if (ret != 0)
 8021e20:	69fb      	ldr	r3, [r7, #28]
 8021e22:	2b00      	cmp	r3, #0
 8021e24:	d103      	bne.n	8021e2e <Sha256Update+0xea>
            while (len >= WC_SHA256_BLOCK_SIZE) {
 8021e26:	687b      	ldr	r3, [r7, #4]
 8021e28:	2b3f      	cmp	r3, #63	@ 0x3f
 8021e2a:	d8e1      	bhi.n	8021df0 <Sha256Update+0xac>
 8021e2c:	e000      	b.n	8021e30 <Sha256Update+0xec>
                    break;
 8021e2e:	bf00      	nop
            }
        }
    #endif

        /* save remainder */
        if (ret == 0 && len > 0) {
 8021e30:	69fb      	ldr	r3, [r7, #28]
 8021e32:	2b00      	cmp	r3, #0
 8021e34:	d10a      	bne.n	8021e4c <Sha256Update+0x108>
 8021e36:	687b      	ldr	r3, [r7, #4]
 8021e38:	2b00      	cmp	r3, #0
 8021e3a:	d007      	beq.n	8021e4c <Sha256Update+0x108>
            XMEMCPY(local, data, len);
 8021e3c:	687a      	ldr	r2, [r7, #4]
 8021e3e:	68b9      	ldr	r1, [r7, #8]
 8021e40:	69b8      	ldr	r0, [r7, #24]
 8021e42:	f006 fbab 	bl	802859c <memcpy>
            sha256->buffLen = len;
 8021e46:	68fb      	ldr	r3, [r7, #12]
 8021e48:	687a      	ldr	r2, [r7, #4]
 8021e4a:	661a      	str	r2, [r3, #96]	@ 0x60
        }

        return ret;
 8021e4c:	69fb      	ldr	r3, [r7, #28]
    }
 8021e4e:	4618      	mov	r0, r3
 8021e50:	3720      	adds	r7, #32
 8021e52:	46bd      	mov	sp, r7
 8021e54:	bd80      	pop	{r7, pc}

08021e56 <wc_Sha256Update>:
#if defined(WOLFSSL_KCAPI_HASH)
    /* implemented in wolfcrypt/src/port/kcapi/kcapi_hash.c */

#else
    int wc_Sha256Update(wc_Sha256* sha256, const byte* data, word32 len)
    {
 8021e56:	b580      	push	{r7, lr}
 8021e58:	b084      	sub	sp, #16
 8021e5a:	af00      	add	r7, sp, #0
 8021e5c:	60f8      	str	r0, [r7, #12]
 8021e5e:	60b9      	str	r1, [r7, #8]
 8021e60:	607a      	str	r2, [r7, #4]
        if (sha256 == NULL) {
 8021e62:	68fb      	ldr	r3, [r7, #12]
 8021e64:	2b00      	cmp	r3, #0
 8021e66:	d102      	bne.n	8021e6e <wc_Sha256Update+0x18>
            return BAD_FUNC_ARG;
 8021e68:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8021e6c:	e013      	b.n	8021e96 <wc_Sha256Update+0x40>
        }
        if (data == NULL && len == 0) {
 8021e6e:	68bb      	ldr	r3, [r7, #8]
 8021e70:	2b00      	cmp	r3, #0
 8021e72:	d104      	bne.n	8021e7e <wc_Sha256Update+0x28>
 8021e74:	687b      	ldr	r3, [r7, #4]
 8021e76:	2b00      	cmp	r3, #0
 8021e78:	d101      	bne.n	8021e7e <wc_Sha256Update+0x28>
            /* valid, but do nothing */
            return 0;
 8021e7a:	2300      	movs	r3, #0
 8021e7c:	e00b      	b.n	8021e96 <wc_Sha256Update+0x40>
        }
        if (data == NULL) {
 8021e7e:	68bb      	ldr	r3, [r7, #8]
 8021e80:	2b00      	cmp	r3, #0
 8021e82:	d102      	bne.n	8021e8a <wc_Sha256Update+0x34>
            return BAD_FUNC_ARG;
 8021e84:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8021e88:	e005      	b.n	8021e96 <wc_Sha256Update+0x40>
            return IntelQaSymSha256(&sha256->asyncDev, NULL, data, len);
        #endif
        }
    #endif /* WOLFSSL_ASYNC_CRYPT */

        return Sha256Update(sha256, data, len);
 8021e8a:	687a      	ldr	r2, [r7, #4]
 8021e8c:	68b9      	ldr	r1, [r7, #8]
 8021e8e:	68f8      	ldr	r0, [r7, #12]
 8021e90:	f7ff ff58 	bl	8021d44 <Sha256Update>
 8021e94:	4603      	mov	r3, r0
    }
 8021e96:	4618      	mov	r0, r3
 8021e98:	3710      	adds	r7, #16
 8021e9a:	46bd      	mov	sp, r7
 8021e9c:	bd80      	pop	{r7, pc}

08021e9e <Sha256Final>:
#endif

    static WC_INLINE int Sha256Final(wc_Sha256* sha256)
    {
 8021e9e:	b580      	push	{r7, lr}
 8021ea0:	b084      	sub	sp, #16
 8021ea2:	af00      	add	r7, sp, #0
 8021ea4:	6078      	str	r0, [r7, #4]
        int ret;
        byte* local;

        /* we'll add a 0x80 byte at the end,
        ** so make sure we have appropriate buffer length. */
        if (sha256->buffLen > WC_SHA256_BLOCK_SIZE - 1) {
 8021ea6:	687b      	ldr	r3, [r7, #4]
 8021ea8:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8021eaa:	2b3f      	cmp	r3, #63	@ 0x3f
 8021eac:	d902      	bls.n	8021eb4 <Sha256Final+0x16>
            /* exit with error code if there's a bad buffer size in buffLen */
            return BAD_STATE_E;
 8021eae:	f06f 03bf 	mvn.w	r3, #191	@ 0xbf
 8021eb2:	e06a      	b.n	8021f8a <Sha256Final+0xec>
        } /* buffLen check */

        local = (byte*)sha256->buffer;
 8021eb4:	687b      	ldr	r3, [r7, #4]
 8021eb6:	3320      	adds	r3, #32
 8021eb8:	60fb      	str	r3, [r7, #12]
        local[sha256->buffLen++] = 0x80; /* add 1 */
 8021eba:	687b      	ldr	r3, [r7, #4]
 8021ebc:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8021ebe:	1c59      	adds	r1, r3, #1
 8021ec0:	687a      	ldr	r2, [r7, #4]
 8021ec2:	6611      	str	r1, [r2, #96]	@ 0x60
 8021ec4:	68fa      	ldr	r2, [r7, #12]
 8021ec6:	4413      	add	r3, r2
 8021ec8:	2280      	movs	r2, #128	@ 0x80
 8021eca:	701a      	strb	r2, [r3, #0]

        /* pad with zeros */
        if (sha256->buffLen > WC_SHA256_PAD_SIZE) {
 8021ecc:	687b      	ldr	r3, [r7, #4]
 8021ece:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8021ed0:	2b38      	cmp	r3, #56	@ 0x38
 8021ed2:	d925      	bls.n	8021f20 <Sha256Final+0x82>
            if (sha256->buffLen < WC_SHA256_BLOCK_SIZE) {
 8021ed4:	687b      	ldr	r3, [r7, #4]
 8021ed6:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8021ed8:	2b3f      	cmp	r3, #63	@ 0x3f
 8021eda:	d80b      	bhi.n	8021ef4 <Sha256Final+0x56>
                XMEMSET(&local[sha256->buffLen], 0,
 8021edc:	687b      	ldr	r3, [r7, #4]
 8021ede:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8021ee0:	68fa      	ldr	r2, [r7, #12]
 8021ee2:	18d0      	adds	r0, r2, r3
 8021ee4:	687b      	ldr	r3, [r7, #4]
 8021ee6:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8021ee8:	f1c3 0340 	rsb	r3, r3, #64	@ 0x40
 8021eec:	461a      	mov	r2, r3
 8021eee:	2100      	movs	r1, #0
 8021ef0:	f006 faea 	bl	80284c8 <memset>
                esp_sha_try_hw_lock(&sha256->ctx);
            }
        #endif

        if (SHA256_UPDATE_REV_BYTES(&sha256->ctx)) {
            ByteReverseWords(sha256->buffer, sha256->buffer,
 8021ef4:	687b      	ldr	r3, [r7, #4]
 8021ef6:	f103 0020 	add.w	r0, r3, #32
 8021efa:	687b      	ldr	r3, [r7, #4]
 8021efc:	3320      	adds	r3, #32
 8021efe:	2240      	movs	r2, #64	@ 0x40
 8021f00:	4619      	mov	r1, r3
 8021f02:	f7ff fad6 	bl	80214b2 <ByteReverseWords>
            }
            else {
                ret = esp_sha256_process(sha256, (const byte*)local);
            }
        #else
            ret = XTRANSFORM(sha256, (const byte*)local);
 8021f06:	68f9      	ldr	r1, [r7, #12]
 8021f08:	6878      	ldr	r0, [r7, #4]
 8021f0a:	f7ff fb81 	bl	8021610 <Transform_Sha256>
 8021f0e:	60b8      	str	r0, [r7, #8]
        #endif
            if (ret != 0)
 8021f10:	68bb      	ldr	r3, [r7, #8]
 8021f12:	2b00      	cmp	r3, #0
 8021f14:	d001      	beq.n	8021f1a <Sha256Final+0x7c>
                return ret;
 8021f16:	68bb      	ldr	r3, [r7, #8]
 8021f18:	e037      	b.n	8021f8a <Sha256Final+0xec>

            sha256->buffLen = 0;
 8021f1a:	687b      	ldr	r3, [r7, #4]
 8021f1c:	2200      	movs	r2, #0
 8021f1e:	661a      	str	r2, [r3, #96]	@ 0x60
        }
        XMEMSET(&local[sha256->buffLen], 0,
 8021f20:	687b      	ldr	r3, [r7, #4]
 8021f22:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8021f24:	68fa      	ldr	r2, [r7, #12]
 8021f26:	18d0      	adds	r0, r2, r3
 8021f28:	687b      	ldr	r3, [r7, #4]
 8021f2a:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8021f2c:	f1c3 0338 	rsb	r3, r3, #56	@ 0x38
 8021f30:	461a      	mov	r2, r3
 8021f32:	2100      	movs	r1, #0
 8021f34:	f006 fac8 	bl	80284c8 <memset>
            WC_SHA256_PAD_SIZE - sha256->buffLen);

        /* put 64 bit length in separate 32 bit parts */
        sha256->hiLen = (sha256->loLen >> (8 * sizeof(sha256->loLen) - 3)) +
 8021f38:	687b      	ldr	r3, [r7, #4]
 8021f3a:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8021f3c:	0f5a      	lsrs	r2, r3, #29
                                                         (sha256->hiLen << 3);
 8021f3e:	687b      	ldr	r3, [r7, #4]
 8021f40:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 8021f42:	00db      	lsls	r3, r3, #3
        sha256->hiLen = (sha256->loLen >> (8 * sizeof(sha256->loLen) - 3)) +
 8021f44:	441a      	add	r2, r3
 8021f46:	687b      	ldr	r3, [r7, #4]
 8021f48:	669a      	str	r2, [r3, #104]	@ 0x68
        sha256->loLen = sha256->loLen << 3;
 8021f4a:	687b      	ldr	r3, [r7, #4]
 8021f4c:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8021f4e:	00da      	lsls	r2, r3, #3
 8021f50:	687b      	ldr	r3, [r7, #4]
 8021f52:	665a      	str	r2, [r3, #100]	@ 0x64
        }
    #endif

        /* store lengths */
        if (SHA256_UPDATE_REV_BYTES(&sha256->ctx)) {
            ByteReverseWords(sha256->buffer, sha256->buffer,
 8021f54:	687b      	ldr	r3, [r7, #4]
 8021f56:	f103 0020 	add.w	r0, r3, #32
 8021f5a:	687b      	ldr	r3, [r7, #4]
 8021f5c:	3320      	adds	r3, #32
 8021f5e:	2238      	movs	r2, #56	@ 0x38
 8021f60:	4619      	mov	r1, r3
 8021f62:	f7ff faa6 	bl	80214b2 <ByteReverseWords>
                WC_SHA256_PAD_SIZE);
        }
        /* ! 64-bit length ordering dependent on digest endian type ! */
        XMEMCPY(&local[WC_SHA256_PAD_SIZE], &sha256->hiLen, sizeof(word32));
 8021f66:	68fb      	ldr	r3, [r7, #12]
 8021f68:	3338      	adds	r3, #56	@ 0x38
 8021f6a:	687a      	ldr	r2, [r7, #4]
 8021f6c:	3268      	adds	r2, #104	@ 0x68
 8021f6e:	6812      	ldr	r2, [r2, #0]
 8021f70:	601a      	str	r2, [r3, #0]
        XMEMCPY(&local[WC_SHA256_PAD_SIZE + sizeof(word32)], &sha256->loLen,
 8021f72:	68fb      	ldr	r3, [r7, #12]
 8021f74:	333c      	adds	r3, #60	@ 0x3c
 8021f76:	687a      	ldr	r2, [r7, #4]
 8021f78:	3264      	adds	r2, #100	@ 0x64
 8021f7a:	6812      	ldr	r2, [r2, #0]
 8021f7c:	601a      	str	r2, [r3, #0]
        }
        else {
            ret = esp_sha256_digest_process(sha256, 1);
        }
    #else
        ret = XTRANSFORM(sha256, (const byte*)local);
 8021f7e:	68f9      	ldr	r1, [r7, #12]
 8021f80:	6878      	ldr	r0, [r7, #4]
 8021f82:	f7ff fb45 	bl	8021610 <Transform_Sha256>
 8021f86:	60b8      	str	r0, [r7, #8]
    #endif

        return ret;
 8021f88:	68bb      	ldr	r3, [r7, #8]
    }
 8021f8a:	4618      	mov	r0, r3
 8021f8c:	3710      	adds	r7, #16
 8021f8e:	46bd      	mov	sp, r7
 8021f90:	bd80      	pop	{r7, pc}

08021f92 <wc_Sha256Final>:

        return 0;
    }

    int wc_Sha256Final(wc_Sha256* sha256, byte* hash)
    {
 8021f92:	b580      	push	{r7, lr}
 8021f94:	b084      	sub	sp, #16
 8021f96:	af00      	add	r7, sp, #0
 8021f98:	6078      	str	r0, [r7, #4]
 8021f9a:	6039      	str	r1, [r7, #0]
        int ret;

        if (sha256 == NULL || hash == NULL) {
 8021f9c:	687b      	ldr	r3, [r7, #4]
 8021f9e:	2b00      	cmp	r3, #0
 8021fa0:	d002      	beq.n	8021fa8 <wc_Sha256Final+0x16>
 8021fa2:	683b      	ldr	r3, [r7, #0]
 8021fa4:	2b00      	cmp	r3, #0
 8021fa6:	d102      	bne.n	8021fae <wc_Sha256Final+0x1c>
            return BAD_FUNC_ARG;
 8021fa8:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8021fac:	e018      	b.n	8021fe0 <wc_Sha256Final+0x4e>
                                            WC_SHA256_DIGEST_SIZE);
        #endif
        }
    #endif /* WOLFSSL_ASYNC_CRYPT */

        ret = Sha256Final(sha256);
 8021fae:	6878      	ldr	r0, [r7, #4]
 8021fb0:	f7ff ff75 	bl	8021e9e <Sha256Final>
 8021fb4:	60f8      	str	r0, [r7, #12]
        if (ret != 0) {
 8021fb6:	68fb      	ldr	r3, [r7, #12]
 8021fb8:	2b00      	cmp	r3, #0
 8021fba:	d001      	beq.n	8021fc0 <wc_Sha256Final+0x2e>
            return ret;
 8021fbc:	68fb      	ldr	r3, [r7, #12]
 8021fbe:	e00f      	b.n	8021fe0 <wc_Sha256Final+0x4e>
        }

    #if defined(LITTLE_ENDIAN_ORDER)
        if (SHA256_REV_BYTES(&sha256->ctx)) {
            ByteReverseWords(sha256->digest, sha256->digest,
 8021fc0:	687b      	ldr	r3, [r7, #4]
 8021fc2:	6879      	ldr	r1, [r7, #4]
 8021fc4:	2220      	movs	r2, #32
 8021fc6:	4618      	mov	r0, r3
 8021fc8:	f7ff fa73 	bl	80214b2 <ByteReverseWords>
                WC_SHA256_DIGEST_SIZE);
        }
    #endif
        XMEMCPY(hash, sha256->digest, WC_SHA256_DIGEST_SIZE);
 8021fcc:	687b      	ldr	r3, [r7, #4]
 8021fce:	2220      	movs	r2, #32
 8021fd0:	4619      	mov	r1, r3
 8021fd2:	6838      	ldr	r0, [r7, #0]
 8021fd4:	f006 fae2 	bl	802859c <memcpy>

        return InitSha256(sha256);  /* reset state */
 8021fd8:	6878      	ldr	r0, [r7, #4]
 8021fda:	f7ff fab9 	bl	8021550 <InitSha256>
 8021fde:	4603      	mov	r3, r0
    }
 8021fe0:	4618      	mov	r0, r3
 8021fe2:	3710      	adds	r7, #16
 8021fe4:	46bd      	mov	sp, r7
 8021fe6:	bd80      	pop	{r7, pc}

08021fe8 <wc_InitSha256>:
#endif /* !defined(WOLFSSL_HAVE_PSA) || defined(WOLFSSL_PSA_NO_HASH)  */
#endif /*  WOLFSSL_SHA224 */


int wc_InitSha256(wc_Sha256* sha256)
{
 8021fe8:	b580      	push	{r7, lr}
 8021fea:	b084      	sub	sp, #16
 8021fec:	af00      	add	r7, sp, #0
 8021fee:	6078      	str	r0, [r7, #4]
    int devId = INVALID_DEVID;
 8021ff0:	f06f 0301 	mvn.w	r3, #1
 8021ff4:	60fb      	str	r3, [r7, #12]

#ifdef WOLF_CRYPTO_CB
    devId = wc_CryptoCb_DefaultDevID();
#endif
    return wc_InitSha256_ex(sha256, NULL, devId);
 8021ff6:	68fa      	ldr	r2, [r7, #12]
 8021ff8:	2100      	movs	r1, #0
 8021ffa:	6878      	ldr	r0, [r7, #4]
 8021ffc:	f7ff fae8 	bl	80215d0 <wc_InitSha256_ex>
 8022000:	4603      	mov	r3, r0
}
 8022002:	4618      	mov	r0, r3
 8022004:	3710      	adds	r7, #16
 8022006:	46bd      	mov	sp, r7
 8022008:	bd80      	pop	{r7, pc}

0802200a <wc_Sha256Free>:

#if !defined(WOLFSSL_HAVE_PSA) || defined(WOLFSSL_PSA_NO_HASH)
    /* implemented in wolfcrypt/src/port/psa/psa_hash.c */

void wc_Sha256Free(wc_Sha256* sha256)
{
 802200a:	b580      	push	{r7, lr}
 802200c:	b082      	sub	sp, #8
 802200e:	af00      	add	r7, sp, #0
 8022010:	6078      	str	r0, [r7, #4]
    if (sha256 == NULL)
 8022012:	687b      	ldr	r3, [r7, #4]
 8022014:	2b00      	cmp	r3, #0
 8022016:	d004      	beq.n	8022022 <wc_Sha256Free+0x18>
    }
    else {
        ESP_LOGV(TAG, "Hardware unlock not needed in wc_Sha256Free.");
    }
#endif
    ForceZero(sha256, sizeof(*sha256));
 8022018:	2170      	movs	r1, #112	@ 0x70
 802201a:	6878      	ldr	r0, [r7, #4]
 802201c:	f7ff fa6f 	bl	80214fe <ForceZero>
 8022020:	e000      	b.n	8022024 <wc_Sha256Free+0x1a>
        return;
 8022022:	bf00      	nop
} /* wc_Sha256Free */
 8022024:	3708      	adds	r7, #8
 8022026:	46bd      	mov	sp, r7
 8022028:	bd80      	pop	{r7, pc}

0802202a <wc_SignatureGetSize>:
}
#endif /* !NO_RSA && !NO_ASN */

int wc_SignatureGetSize(enum wc_SignatureType sig_type,
    const void* key, word32 key_len)
{
 802202a:	b580      	push	{r7, lr}
 802202c:	b086      	sub	sp, #24
 802202e:	af00      	add	r7, sp, #0
 8022030:	4603      	mov	r3, r0
 8022032:	60b9      	str	r1, [r7, #8]
 8022034:	607a      	str	r2, [r7, #4]
 8022036:	73fb      	strb	r3, [r7, #15]
    int sig_len = WC_NO_ERR_TRACE(BAD_FUNC_ARG);
 8022038:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 802203c:	617b      	str	r3, [r7, #20]

    /* Suppress possible unused args if all signature types are disabled */
    (void)key;
    (void)key_len;

    switch(sig_type) {
 802203e:	7bfb      	ldrb	r3, [r7, #15]
 8022040:	2b01      	cmp	r3, #1
 8022042:	d005      	beq.n	8022050 <wc_SignatureGetSize+0x26>
 8022044:	2b00      	cmp	r3, #0
 8022046:	dd16      	ble.n	8022076 <wc_SignatureGetSize+0x4c>
 8022048:	3b02      	subs	r3, #2
 802204a:	2b01      	cmp	r3, #1
 802204c:	d813      	bhi.n	8022076 <wc_SignatureGetSize+0x4c>
 802204e:	e008      	b.n	8022062 <wc_SignatureGetSize+0x38>
        case WC_SIGNATURE_TYPE_ECC:
#ifdef HAVE_ECC
            /* Sanity check that void* key is at least ecc_key in size */
            if (key_len >= sizeof(ecc_key)) {
 8022050:	687b      	ldr	r3, [r7, #4]
 8022052:	f5b3 7fb8 	cmp.w	r3, #368	@ 0x170
 8022056:	d312      	bcc.n	802207e <wc_SignatureGetSize+0x54>
                sig_len = wc_ecc_sig_size((ecc_key*)key);
 8022058:	68b8      	ldr	r0, [r7, #8]
 802205a:	f7fc f8f3 	bl	801e244 <wc_ecc_sig_size>
 802205e:	6178      	str	r0, [r7, #20]
                WOLFSSL_MSG("wc_SignatureGetSize: Invalid ECC key size");
            }
#else
            sig_len = SIG_TYPE_E;
#endif
            break;
 8022060:	e00d      	b.n	802207e <wc_SignatureGetSize+0x54>

        case WC_SIGNATURE_TYPE_RSA_W_ENC:
        case WC_SIGNATURE_TYPE_RSA:
#ifndef NO_RSA
            /* Sanity check that void* key is at least RsaKey in size */
            if (key_len >= sizeof(RsaKey)) {
 8022062:	687b      	ldr	r3, [r7, #4]
 8022064:	f241 127b 	movw	r2, #4475	@ 0x117b
 8022068:	4293      	cmp	r3, r2
 802206a:	d90a      	bls.n	8022082 <wc_SignatureGetSize+0x58>
                sig_len = wc_RsaEncryptSize((RsaKey*)key);
 802206c:	68b8      	ldr	r0, [r7, #8]
 802206e:	f7ff f9b9 	bl	80213e4 <wc_RsaEncryptSize>
 8022072:	6178      	str	r0, [r7, #20]
                WOLFSSL_MSG("wc_SignatureGetSize: Invalid RsaKey key size");
            }
#else
            sig_len = SIG_TYPE_E;
#endif
            break;
 8022074:	e005      	b.n	8022082 <wc_SignatureGetSize+0x58>

        case WC_SIGNATURE_TYPE_NONE:
        default:
            sig_len = BAD_FUNC_ARG;
 8022076:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 802207a:	617b      	str	r3, [r7, #20]
            break;
 802207c:	e002      	b.n	8022084 <wc_SignatureGetSize+0x5a>
            break;
 802207e:	bf00      	nop
 8022080:	e000      	b.n	8022084 <wc_SignatureGetSize+0x5a>
            break;
 8022082:	bf00      	nop
    }
    return sig_len;
 8022084:	697b      	ldr	r3, [r7, #20]
}
 8022086:	4618      	mov	r0, r3
 8022088:	3718      	adds	r7, #24
 802208a:	46bd      	mov	sp, r7
 802208c:	bd80      	pop	{r7, pc}

0802208e <wc_SignatureVerifyHash>:
int wc_SignatureVerifyHash(
    enum wc_HashType hash_type, enum wc_SignatureType sig_type,
    const byte* hash_data, word32 hash_len,
    const byte* sig, word32 sig_len,
    const void* key, word32 key_len)
{
 802208e:	b580      	push	{r7, lr}
 8022090:	b08c      	sub	sp, #48	@ 0x30
 8022092:	af02      	add	r7, sp, #8
 8022094:	60ba      	str	r2, [r7, #8]
 8022096:	607b      	str	r3, [r7, #4]
 8022098:	4603      	mov	r3, r0
 802209a:	73fb      	strb	r3, [r7, #15]
 802209c:	460b      	mov	r3, r1
 802209e:	73bb      	strb	r3, [r7, #14]
    int ret;

    /* Check arguments */
    if (hash_data == NULL || hash_len == 0 ||
 80220a0:	68bb      	ldr	r3, [r7, #8]
 80220a2:	2b00      	cmp	r3, #0
 80220a4:	d00e      	beq.n	80220c4 <wc_SignatureVerifyHash+0x36>
 80220a6:	687b      	ldr	r3, [r7, #4]
 80220a8:	2b00      	cmp	r3, #0
 80220aa:	d00b      	beq.n	80220c4 <wc_SignatureVerifyHash+0x36>
 80220ac:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80220ae:	2b00      	cmp	r3, #0
 80220b0:	d008      	beq.n	80220c4 <wc_SignatureVerifyHash+0x36>
        sig == NULL || sig_len == 0 ||
 80220b2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80220b4:	2b00      	cmp	r3, #0
 80220b6:	d005      	beq.n	80220c4 <wc_SignatureVerifyHash+0x36>
 80220b8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80220ba:	2b00      	cmp	r3, #0
 80220bc:	d002      	beq.n	80220c4 <wc_SignatureVerifyHash+0x36>
        key == NULL || key_len == 0) {
 80220be:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80220c0:	2b00      	cmp	r3, #0
 80220c2:	d102      	bne.n	80220ca <wc_SignatureVerifyHash+0x3c>
        return BAD_FUNC_ARG;
 80220c4:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80220c8:	e098      	b.n	80221fc <wc_SignatureVerifyHash+0x16e>
    }

    /* Validate signature len (1 to max is okay) */
    if ((int)sig_len > wc_SignatureGetSize(sig_type, key, key_len)) {
 80220ca:	7bbb      	ldrb	r3, [r7, #14]
 80220cc:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80220ce:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 80220d0:	4618      	mov	r0, r3
 80220d2:	f7ff ffaa 	bl	802202a <wc_SignatureGetSize>
 80220d6:	4602      	mov	r2, r0
 80220d8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80220da:	429a      	cmp	r2, r3
 80220dc:	da02      	bge.n	80220e4 <wc_SignatureVerifyHash+0x56>
        WOLFSSL_MSG("wc_SignatureVerify: Invalid sig type/len");
        return BAD_FUNC_ARG;
 80220de:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80220e2:	e08b      	b.n	80221fc <wc_SignatureVerifyHash+0x16e>
    }

    /* Validate hash size */
    ret = wc_HashGetDigestSize(hash_type);
 80220e4:	7bfb      	ldrb	r3, [r7, #15]
 80220e6:	4618      	mov	r0, r3
 80220e8:	f7fc f93c 	bl	801e364 <wc_HashGetDigestSize>
 80220ec:	6278      	str	r0, [r7, #36]	@ 0x24
    if (ret < 0) {
 80220ee:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80220f0:	2b00      	cmp	r3, #0
 80220f2:	da01      	bge.n	80220f8 <wc_SignatureVerifyHash+0x6a>
        WOLFSSL_MSG("wc_SignatureVerify: Invalid hash type/len");
        return ret;
 80220f4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80220f6:	e081      	b.n	80221fc <wc_SignatureVerifyHash+0x16e>
    }
    ret = 0;
 80220f8:	2300      	movs	r3, #0
 80220fa:	627b      	str	r3, [r7, #36]	@ 0x24

    /* Verify signature using hash */
    switch (sig_type) {
 80220fc:	7bbb      	ldrb	r3, [r7, #14]
 80220fe:	2b01      	cmp	r3, #1
 8022100:	d005      	beq.n	802210e <wc_SignatureVerifyHash+0x80>
 8022102:	2b00      	cmp	r3, #0
 8022104:	dd72      	ble.n	80221ec <wc_SignatureVerifyHash+0x15e>
 8022106:	3b02      	subs	r3, #2
 8022108:	2b01      	cmp	r3, #1
 802210a:	d86f      	bhi.n	80221ec <wc_SignatureVerifyHash+0x15e>
 802210c:	e01e      	b.n	802214c <wc_SignatureVerifyHash+0xbe>
        case WC_SIGNATURE_TYPE_ECC:
        {
#if defined(HAVE_ECC) && defined(HAVE_ECC_VERIFY)
            int is_valid_sig = 0;
 802210e:	2300      	movs	r3, #0
 8022110:	617b      	str	r3, [r7, #20]
            do {
            #ifdef WOLFSSL_ASYNC_CRYPT
                ret = wc_AsyncWait(ret, &((ecc_key*)key)->asyncDev,
                    WC_ASYNC_FLAG_CALL_AGAIN);
            #endif
            if (ret >= 0)
 8022112:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8022114:	2b00      	cmp	r3, #0
 8022116:	db0b      	blt.n	8022130 <wc_SignatureVerifyHash+0xa2>
                ret = wc_ecc_verify_hash(sig, sig_len, hash_data, hash_len,
 8022118:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802211a:	9301      	str	r3, [sp, #4]
 802211c:	f107 0314 	add.w	r3, r7, #20
 8022120:	9300      	str	r3, [sp, #0]
 8022122:	687b      	ldr	r3, [r7, #4]
 8022124:	68ba      	ldr	r2, [r7, #8]
 8022126:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 8022128:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 802212a:	f7fb fb87 	bl	801d83c <wc_ecc_verify_hash>
 802212e:	6278      	str	r0, [r7, #36]	@ 0x24
                    &is_valid_sig, (ecc_key*)key);
            } while (ret == WC_NO_ERR_TRACE(WC_PENDING_E));
 8022130:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8022132:	f113 0f6c 	cmn.w	r3, #108	@ 0x6c
 8022136:	d0ec      	beq.n	8022112 <wc_SignatureVerifyHash+0x84>
            if (ret != 0 || is_valid_sig != 1) {
 8022138:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802213a:	2b00      	cmp	r3, #0
 802213c:	d102      	bne.n	8022144 <wc_SignatureVerifyHash+0xb6>
 802213e:	697b      	ldr	r3, [r7, #20]
 8022140:	2b01      	cmp	r3, #1
 8022142:	d057      	beq.n	80221f4 <wc_SignatureVerifyHash+0x166>
                ret = SIG_VERIFY_E;
 8022144:	f06f 03e4 	mvn.w	r3, #228	@ 0xe4
 8022148:	627b      	str	r3, [r7, #36]	@ 0x24
            }
#else
            ret = SIG_TYPE_E;
#endif
            break;
 802214a:	e053      	b.n	80221f4 <wc_SignatureVerifyHash+0x166>
        if (ret != 0) {
            ret = SIG_VERIFY_E;
        }
    #else

            word32 plain_len = hash_len;
 802214c:	687b      	ldr	r3, [r7, #4]
 802214e:	623b      	str	r3, [r7, #32]
        #else
            ALIGN64 byte plain_data[MAX_ENCODED_SIG_SZ];
        #endif

            /* Make sure the plain text output is at least key size */
            if (plain_len < sig_len) {
 8022150:	6a3a      	ldr	r2, [r7, #32]
 8022152:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8022154:	429a      	cmp	r2, r3
 8022156:	d201      	bcs.n	802215c <wc_SignatureVerifyHash+0xce>
                plain_len = sig_len;
 8022158:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802215a:	623b      	str	r3, [r7, #32]
            }
        #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
            plain_data = (byte*)XMALLOC(plain_len, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 802215c:	6a38      	ldr	r0, [r7, #32]
 802215e:	f7fc fc93 	bl	801ea88 <wolfSSL_Malloc>
 8022162:	61f8      	str	r0, [r7, #28]
            if (plain_data)
 8022164:	69fb      	ldr	r3, [r7, #28]
 8022166:	2b00      	cmp	r3, #0
 8022168:	d03c      	beq.n	80221e4 <wc_SignatureVerifyHash+0x156>
        #else
            if (plain_len <= sizeof(plain_data))
        #endif
            {
                byte* plain_ptr = NULL;
 802216a:	2300      	movs	r3, #0
 802216c:	613b      	str	r3, [r7, #16]
                XMEMSET(plain_data, 0, plain_len);
 802216e:	6a3a      	ldr	r2, [r7, #32]
 8022170:	2100      	movs	r1, #0
 8022172:	69f8      	ldr	r0, [r7, #28]
 8022174:	f006 f9a8 	bl	80284c8 <memset>
                XMEMCPY(plain_data, sig, sig_len);
 8022178:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 802217a:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 802217c:	69f8      	ldr	r0, [r7, #28]
 802217e:	f006 fa0d 	bl	802859c <memcpy>
                do {
                #ifdef WOLFSSL_ASYNC_CRYPT
                    ret = wc_AsyncWait(ret, &((RsaKey*)key)->asyncDev,
                        WC_ASYNC_FLAG_CALL_AGAIN);
                #endif
                if (ret >= 0)
 8022182:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8022184:	2b00      	cmp	r3, #0
 8022186:	db07      	blt.n	8022198 <wc_SignatureVerifyHash+0x10a>
                        ret = wc_RsaSSL_VerifyInline(plain_data, sig_len,
 8022188:	f107 0210 	add.w	r2, r7, #16
 802218c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802218e:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 8022190:	69f8      	ldr	r0, [r7, #28]
 8022192:	f7ff f832 	bl	80211fa <wc_RsaSSL_VerifyInline>
 8022196:	6278      	str	r0, [r7, #36]	@ 0x24
                            &plain_ptr, (RsaKey*)key);
                } while (ret == WC_NO_ERR_TRACE(WC_PENDING_E));
 8022198:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802219a:	f113 0f6c 	cmn.w	r3, #108	@ 0x6c
 802219e:	d0f0      	beq.n	8022182 <wc_SignatureVerifyHash+0xf4>
                if (ret >= 0 && plain_ptr) {
 80221a0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80221a2:	2b00      	cmp	r3, #0
 80221a4:	db15      	blt.n	80221d2 <wc_SignatureVerifyHash+0x144>
 80221a6:	693b      	ldr	r3, [r7, #16]
 80221a8:	2b00      	cmp	r3, #0
 80221aa:	d012      	beq.n	80221d2 <wc_SignatureVerifyHash+0x144>
                    if ((word32)ret == hash_len &&
 80221ac:	687b      	ldr	r3, [r7, #4]
 80221ae:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80221b0:	429a      	cmp	r2, r3
 80221b2:	d10b      	bne.n	80221cc <wc_SignatureVerifyHash+0x13e>
                            XMEMCMP(plain_ptr, hash_data, hash_len) == 0) {
 80221b4:	693b      	ldr	r3, [r7, #16]
 80221b6:	687a      	ldr	r2, [r7, #4]
 80221b8:	68b9      	ldr	r1, [r7, #8]
 80221ba:	4618      	mov	r0, r3
 80221bc:	f006 f95a 	bl	8028474 <memcmp>
 80221c0:	4603      	mov	r3, r0
                    if ((word32)ret == hash_len &&
 80221c2:	2b00      	cmp	r3, #0
 80221c4:	d102      	bne.n	80221cc <wc_SignatureVerifyHash+0x13e>
                        ret = 0; /* Success */
 80221c6:	2300      	movs	r3, #0
 80221c8:	627b      	str	r3, [r7, #36]	@ 0x24
 80221ca:	e002      	b.n	80221d2 <wc_SignatureVerifyHash+0x144>
                    }
                    else {
                        ret = SIG_VERIFY_E;
 80221cc:	f06f 03e4 	mvn.w	r3, #228	@ 0xe4
 80221d0:	627b      	str	r3, [r7, #36]	@ 0x24
                    }
                }
            #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
                XFREE(plain_data, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 80221d2:	69fb      	ldr	r3, [r7, #28]
 80221d4:	61bb      	str	r3, [r7, #24]
 80221d6:	69bb      	ldr	r3, [r7, #24]
 80221d8:	2b00      	cmp	r3, #0
 80221da:	d00d      	beq.n	80221f8 <wc_SignatureVerifyHash+0x16a>
 80221dc:	69b8      	ldr	r0, [r7, #24]
 80221de:	f7fc fc6f 	bl	801eac0 <wolfSSL_Free>
                WOLFSSL_MSG("RSA Signature Verify failed!");
            }
#else
            ret = SIG_TYPE_E;
#endif
            break;
 80221e2:	e009      	b.n	80221f8 <wc_SignatureVerifyHash+0x16a>
                ret = MEMORY_E;
 80221e4:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 80221e8:	627b      	str	r3, [r7, #36]	@ 0x24
            break;
 80221ea:	e005      	b.n	80221f8 <wc_SignatureVerifyHash+0x16a>
        }

        case WC_SIGNATURE_TYPE_NONE:
        default:
            ret = BAD_FUNC_ARG;
 80221ec:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80221f0:	627b      	str	r3, [r7, #36]	@ 0x24
            break;
 80221f2:	e002      	b.n	80221fa <wc_SignatureVerifyHash+0x16c>
            break;
 80221f4:	bf00      	nop
 80221f6:	e000      	b.n	80221fa <wc_SignatureVerifyHash+0x16c>
            break;
 80221f8:	bf00      	nop
    }

    return ret;
 80221fa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 80221fc:	4618      	mov	r0, r3
 80221fe:	3728      	adds	r7, #40	@ 0x28
 8022200:	46bd      	mov	sp, r7
 8022202:	bd80      	pop	{r7, pc}

08022204 <ForceZero>:
{
 8022204:	b480      	push	{r7}
 8022206:	b085      	sub	sp, #20
 8022208:	af00      	add	r7, sp, #0
 802220a:	6078      	str	r0, [r7, #4]
 802220c:	6039      	str	r1, [r7, #0]
    volatile byte* z = (volatile byte*)mem;
 802220e:	687b      	ldr	r3, [r7, #4]
 8022210:	60fb      	str	r3, [r7, #12]
    while (len--) *z++ = 0;
 8022212:	e004      	b.n	802221e <ForceZero+0x1a>
 8022214:	68fb      	ldr	r3, [r7, #12]
 8022216:	1c5a      	adds	r2, r3, #1
 8022218:	60fa      	str	r2, [r7, #12]
 802221a:	2200      	movs	r2, #0
 802221c:	701a      	strb	r2, [r3, #0]
 802221e:	683b      	ldr	r3, [r7, #0]
 8022220:	1e5a      	subs	r2, r3, #1
 8022222:	603a      	str	r2, [r7, #0]
 8022224:	2b00      	cmp	r3, #0
 8022226:	d1f5      	bne.n	8022214 <ForceZero+0x10>
}
 8022228:	bf00      	nop
 802222a:	bf00      	nop
 802222c:	3714      	adds	r7, #20
 802222e:	46bd      	mov	sp, r7
 8022230:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022234:	4770      	bx	lr

08022236 <HexCharToByte>:
{
 8022236:	b480      	push	{r7}
 8022238:	b085      	sub	sp, #20
 802223a:	af00      	add	r7, sp, #0
 802223c:	4603      	mov	r3, r0
 802223e:	71fb      	strb	r3, [r7, #7]
    signed char ret = (signed char)ch;
 8022240:	79fb      	ldrb	r3, [r7, #7]
 8022242:	73fb      	strb	r3, [r7, #15]
    if (ret >= '0' && ret <= '9')
 8022244:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8022248:	2b2f      	cmp	r3, #47	@ 0x2f
 802224a:	dd08      	ble.n	802225e <HexCharToByte+0x28>
 802224c:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8022250:	2b39      	cmp	r3, #57	@ 0x39
 8022252:	dc04      	bgt.n	802225e <HexCharToByte+0x28>
        ret = (signed char)(ret - '0');
 8022254:	7bfb      	ldrb	r3, [r7, #15]
 8022256:	3b30      	subs	r3, #48	@ 0x30
 8022258:	b2db      	uxtb	r3, r3
 802225a:	73fb      	strb	r3, [r7, #15]
 802225c:	e01b      	b.n	8022296 <HexCharToByte+0x60>
    else if (ret >= 'A' && ret <= 'F')
 802225e:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8022262:	2b40      	cmp	r3, #64	@ 0x40
 8022264:	dd08      	ble.n	8022278 <HexCharToByte+0x42>
 8022266:	f997 300f 	ldrsb.w	r3, [r7, #15]
 802226a:	2b46      	cmp	r3, #70	@ 0x46
 802226c:	dc04      	bgt.n	8022278 <HexCharToByte+0x42>
        ret = (signed char)(ret - ('A' - 10));
 802226e:	7bfb      	ldrb	r3, [r7, #15]
 8022270:	3b37      	subs	r3, #55	@ 0x37
 8022272:	b2db      	uxtb	r3, r3
 8022274:	73fb      	strb	r3, [r7, #15]
 8022276:	e00e      	b.n	8022296 <HexCharToByte+0x60>
    else if (ret >= 'a' && ret <= 'f')
 8022278:	f997 300f 	ldrsb.w	r3, [r7, #15]
 802227c:	2b60      	cmp	r3, #96	@ 0x60
 802227e:	dd08      	ble.n	8022292 <HexCharToByte+0x5c>
 8022280:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8022284:	2b66      	cmp	r3, #102	@ 0x66
 8022286:	dc04      	bgt.n	8022292 <HexCharToByte+0x5c>
        ret = (signed char)(ret - ('a' - 10));
 8022288:	7bfb      	ldrb	r3, [r7, #15]
 802228a:	3b57      	subs	r3, #87	@ 0x57
 802228c:	b2db      	uxtb	r3, r3
 802228e:	73fb      	strb	r3, [r7, #15]
 8022290:	e001      	b.n	8022296 <HexCharToByte+0x60>
        ret = -1; /* error case - return code must be signed */
 8022292:	23ff      	movs	r3, #255	@ 0xff
 8022294:	73fb      	strb	r3, [r7, #15]
    return ret;
 8022296:	f997 300f 	ldrsb.w	r3, [r7, #15]
}
 802229a:	4618      	mov	r0, r3
 802229c:	3714      	adds	r7, #20
 802229e:	46bd      	mov	sp, r7
 80222a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80222a4:	4770      	bx	lr

080222a6 <CharIsWhiteSpace>:
{
 80222a6:	b480      	push	{r7}
 80222a8:	b083      	sub	sp, #12
 80222aa:	af00      	add	r7, sp, #0
 80222ac:	4603      	mov	r3, r0
 80222ae:	71fb      	strb	r3, [r7, #7]
    switch (ch) {
 80222b0:	79fb      	ldrb	r3, [r7, #7]
 80222b2:	2b0a      	cmp	r3, #10
 80222b4:	dc02      	bgt.n	80222bc <CharIsWhiteSpace+0x16>
 80222b6:	2b09      	cmp	r3, #9
 80222b8:	da02      	bge.n	80222c0 <CharIsWhiteSpace+0x1a>
 80222ba:	e003      	b.n	80222c4 <CharIsWhiteSpace+0x1e>
 80222bc:	2b20      	cmp	r3, #32
 80222be:	d101      	bne.n	80222c4 <CharIsWhiteSpace+0x1e>
            return 1;
 80222c0:	2301      	movs	r3, #1
 80222c2:	e000      	b.n	80222c6 <CharIsWhiteSpace+0x20>
            return 0;
 80222c4:	2300      	movs	r3, #0
}
 80222c6:	4618      	mov	r0, r3
 80222c8:	370c      	adds	r7, #12
 80222ca:	46bd      	mov	sp, r7
 80222cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80222d0:	4770      	bx	lr

080222d2 <fp_add>:


/* Functions */

int fp_add(fp_int *a, fp_int *b, fp_int *c)
{
 80222d2:	b580      	push	{r7, lr}
 80222d4:	b088      	sub	sp, #32
 80222d6:	af00      	add	r7, sp, #0
 80222d8:	60f8      	str	r0, [r7, #12]
 80222da:	60b9      	str	r1, [r7, #8]
 80222dc:	607a      	str	r2, [r7, #4]
  int sa, sb;
  int ret = FP_OKAY;
 80222de:	2300      	movs	r3, #0
 80222e0:	61fb      	str	r3, [r7, #28]

  /* get sign of both inputs */
  sa = a->sign;
 80222e2:	68fb      	ldr	r3, [r7, #12]
 80222e4:	685b      	ldr	r3, [r3, #4]
 80222e6:	61bb      	str	r3, [r7, #24]
  sb = b->sign;
 80222e8:	68bb      	ldr	r3, [r7, #8]
 80222ea:	685b      	ldr	r3, [r3, #4]
 80222ec:	617b      	str	r3, [r7, #20]

  /* handle two cases, not four */
  if (sa == sb) {
 80222ee:	69ba      	ldr	r2, [r7, #24]
 80222f0:	697b      	ldr	r3, [r7, #20]
 80222f2:	429a      	cmp	r2, r3
 80222f4:	d109      	bne.n	802230a <fp_add+0x38>
    /* both positive or both negative */
    /* add their magnitudes, copy the sign */
    c->sign = sa;
 80222f6:	687b      	ldr	r3, [r7, #4]
 80222f8:	69ba      	ldr	r2, [r7, #24]
 80222fa:	605a      	str	r2, [r3, #4]
    ret = s_fp_add (a, b, c);
 80222fc:	687a      	ldr	r2, [r7, #4]
 80222fe:	68b9      	ldr	r1, [r7, #8]
 8022300:	68f8      	ldr	r0, [r7, #12]
 8022302:	f000 f820 	bl	8022346 <s_fp_add>
 8022306:	61f8      	str	r0, [r7, #28]
 8022308:	e018      	b.n	802233c <fp_add+0x6a>
  } else {
    /* one positive, the other negative */
    /* subtract the one with the greater magnitude from */
    /* the one of the lesser magnitude.  The result gets */
    /* the sign of the one with the greater magnitude. */
    if (fp_cmp_mag (a, b) == FP_LT) {
 802230a:	68b9      	ldr	r1, [r7, #8]
 802230c:	68f8      	ldr	r0, [r7, #12]
 802230e:	f003 fc1a 	bl	8025b46 <fp_cmp_mag>
 8022312:	4603      	mov	r3, r0
 8022314:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8022318:	d108      	bne.n	802232c <fp_add+0x5a>
      c->sign = sb;
 802231a:	687b      	ldr	r3, [r7, #4]
 802231c:	697a      	ldr	r2, [r7, #20]
 802231e:	605a      	str	r2, [r3, #4]
      s_fp_sub (b, a, c);
 8022320:	687a      	ldr	r2, [r7, #4]
 8022322:	68f9      	ldr	r1, [r7, #12]
 8022324:	68b8      	ldr	r0, [r7, #8]
 8022326:	f000 f8f6 	bl	8022516 <s_fp_sub>
 802232a:	e007      	b.n	802233c <fp_add+0x6a>
    } else {
      c->sign = sa;
 802232c:	687b      	ldr	r3, [r7, #4]
 802232e:	69ba      	ldr	r2, [r7, #24]
 8022330:	605a      	str	r2, [r3, #4]
      s_fp_sub (a, b, c);
 8022332:	687a      	ldr	r2, [r7, #4]
 8022334:	68b9      	ldr	r1, [r7, #8]
 8022336:	68f8      	ldr	r0, [r7, #12]
 8022338:	f000 f8ed 	bl	8022516 <s_fp_sub>
    }
  }

  return ret;
 802233c:	69fb      	ldr	r3, [r7, #28]
}
 802233e:	4618      	mov	r0, r3
 8022340:	3720      	adds	r7, #32
 8022342:	46bd      	mov	sp, r7
 8022344:	bd80      	pop	{r7, pc}

08022346 <s_fp_add>:

/* unsigned addition */
int s_fp_add(fp_int *a, fp_int *b, fp_int *c)
{
 8022346:	e92d 0fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp}
 802234a:	b08d      	sub	sp, #52	@ 0x34
 802234c:	af00      	add	r7, sp, #0
 802234e:	6178      	str	r0, [r7, #20]
 8022350:	6139      	str	r1, [r7, #16]
 8022352:	60fa      	str	r2, [r7, #12]
  int      x, y, oldused;
  fp_word  t;

  y       = MAX(a->used, b->used);
 8022354:	693b      	ldr	r3, [r7, #16]
 8022356:	681a      	ldr	r2, [r3, #0]
 8022358:	697b      	ldr	r3, [r7, #20]
 802235a:	681b      	ldr	r3, [r3, #0]
 802235c:	4293      	cmp	r3, r2
 802235e:	bfb8      	it	lt
 8022360:	4613      	movlt	r3, r2
 8022362:	61fb      	str	r3, [r7, #28]
  oldused = MIN(c->used, FP_SIZE);   /* help static analysis w/ largest size */
 8022364:	68fb      	ldr	r3, [r7, #12]
 8022366:	681b      	ldr	r3, [r3, #0]
 8022368:	2b88      	cmp	r3, #136	@ 0x88
 802236a:	bfa8      	it	ge
 802236c:	2388      	movge	r3, #136	@ 0x88
 802236e:	61bb      	str	r3, [r7, #24]
  c->used = y;
 8022370:	68fb      	ldr	r3, [r7, #12]
 8022372:	69fa      	ldr	r2, [r7, #28]
 8022374:	601a      	str	r2, [r3, #0]

  t = 0;
 8022376:	f04f 0200 	mov.w	r2, #0
 802237a:	f04f 0300 	mov.w	r3, #0
 802237e:	e9c7 2308 	strd	r2, r3, [r7, #32]
      t        >>= DIGIT_BIT;
  }

#else
  /* the original code */
  for (x = 0; x < y; x++) {
 8022382:	2300      	movs	r3, #0
 8022384:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8022386:	e033      	b.n	80223f0 <s_fp_add+0xaa>
      t         += ((fp_word)a->dp[x]) + ((fp_word)b->dp[x]);
 8022388:	697a      	ldr	r2, [r7, #20]
 802238a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802238c:	3302      	adds	r3, #2
 802238e:	009b      	lsls	r3, r3, #2
 8022390:	4413      	add	r3, r2
 8022392:	685b      	ldr	r3, [r3, #4]
 8022394:	2200      	movs	r2, #0
 8022396:	4698      	mov	r8, r3
 8022398:	4691      	mov	r9, r2
 802239a:	693a      	ldr	r2, [r7, #16]
 802239c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802239e:	3302      	adds	r3, #2
 80223a0:	009b      	lsls	r3, r3, #2
 80223a2:	4413      	add	r3, r2
 80223a4:	685b      	ldr	r3, [r3, #4]
 80223a6:	2200      	movs	r2, #0
 80223a8:	469a      	mov	sl, r3
 80223aa:	4693      	mov	fp, r2
 80223ac:	eb18 040a 	adds.w	r4, r8, sl
 80223b0:	eb49 050b 	adc.w	r5, r9, fp
 80223b4:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 80223b8:	1911      	adds	r1, r2, r4
 80223ba:	6039      	str	r1, [r7, #0]
 80223bc:	416b      	adcs	r3, r5
 80223be:	607b      	str	r3, [r7, #4]
 80223c0:	e9d7 2300 	ldrd	r2, r3, [r7]
 80223c4:	e9c7 2308 	strd	r2, r3, [r7, #32]
      c->dp[x]   = (fp_digit)t;
 80223c8:	6a3a      	ldr	r2, [r7, #32]
 80223ca:	68f9      	ldr	r1, [r7, #12]
 80223cc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80223ce:	3302      	adds	r3, #2
 80223d0:	009b      	lsls	r3, r3, #2
 80223d2:	440b      	add	r3, r1
 80223d4:	605a      	str	r2, [r3, #4]
      t        >>= DIGIT_BIT;
 80223d6:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 80223da:	f04f 0200 	mov.w	r2, #0
 80223de:	f04f 0300 	mov.w	r3, #0
 80223e2:	000a      	movs	r2, r1
 80223e4:	2300      	movs	r3, #0
 80223e6:	e9c7 2308 	strd	r2, r3, [r7, #32]
  for (x = 0; x < y; x++) {
 80223ea:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80223ec:	3301      	adds	r3, #1
 80223ee:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80223f0:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80223f2:	69fb      	ldr	r3, [r7, #28]
 80223f4:	429a      	cmp	r2, r3
 80223f6:	dbc7      	blt.n	8022388 <s_fp_add+0x42>
  }
#endif /* HONOR_MATH_USED_LENGTH */

  if (t != 0) {
 80223f8:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 80223fc:	4313      	orrs	r3, r2
 80223fe:	d013      	beq.n	8022428 <s_fp_add+0xe2>
     if (x == FP_SIZE)
 8022400:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022402:	2b88      	cmp	r3, #136	@ 0x88
 8022404:	d102      	bne.n	802240c <s_fp_add+0xc6>
         return FP_VAL;
 8022406:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 802240a:	e03e      	b.n	802248a <s_fp_add+0x144>
     c->dp[c->used++] = (fp_digit)t;
 802240c:	68fb      	ldr	r3, [r7, #12]
 802240e:	681b      	ldr	r3, [r3, #0]
 8022410:	1c59      	adds	r1, r3, #1
 8022412:	68fa      	ldr	r2, [r7, #12]
 8022414:	6011      	str	r1, [r2, #0]
 8022416:	6a3a      	ldr	r2, [r7, #32]
 8022418:	68f9      	ldr	r1, [r7, #12]
 802241a:	3302      	adds	r3, #2
 802241c:	009b      	lsls	r3, r3, #2
 802241e:	440b      	add	r3, r1
 8022420:	605a      	str	r2, [r3, #4]
     ++x;
 8022422:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022424:	3301      	adds	r3, #1
 8022426:	62fb      	str	r3, [r7, #44]	@ 0x2c
  }

  c->used = x;
 8022428:	68fb      	ldr	r3, [r7, #12]
 802242a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 802242c:	601a      	str	r2, [r3, #0]

  /* zero any excess digits on the destination that we didn't write to */
  for (; x < oldused; x++) {
 802242e:	e009      	b.n	8022444 <s_fp_add+0xfe>
     c->dp[x] = 0;
 8022430:	68fa      	ldr	r2, [r7, #12]
 8022432:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022434:	3302      	adds	r3, #2
 8022436:	009b      	lsls	r3, r3, #2
 8022438:	4413      	add	r3, r2
 802243a:	2200      	movs	r2, #0
 802243c:	605a      	str	r2, [r3, #4]
  for (; x < oldused; x++) {
 802243e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022440:	3301      	adds	r3, #1
 8022442:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8022444:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8022446:	69bb      	ldr	r3, [r7, #24]
 8022448:	429a      	cmp	r2, r3
 802244a:	dbf1      	blt.n	8022430 <s_fp_add+0xea>
  }
  fp_clamp(c);
 802244c:	e004      	b.n	8022458 <s_fp_add+0x112>
 802244e:	68fb      	ldr	r3, [r7, #12]
 8022450:	681b      	ldr	r3, [r3, #0]
 8022452:	1e5a      	subs	r2, r3, #1
 8022454:	68fb      	ldr	r3, [r7, #12]
 8022456:	601a      	str	r2, [r3, #0]
 8022458:	68fb      	ldr	r3, [r7, #12]
 802245a:	681b      	ldr	r3, [r3, #0]
 802245c:	2b00      	cmp	r3, #0
 802245e:	d009      	beq.n	8022474 <s_fp_add+0x12e>
 8022460:	68fb      	ldr	r3, [r7, #12]
 8022462:	681b      	ldr	r3, [r3, #0]
 8022464:	3b01      	subs	r3, #1
 8022466:	68fa      	ldr	r2, [r7, #12]
 8022468:	3302      	adds	r3, #2
 802246a:	009b      	lsls	r3, r3, #2
 802246c:	4413      	add	r3, r2
 802246e:	685b      	ldr	r3, [r3, #4]
 8022470:	2b00      	cmp	r3, #0
 8022472:	d0ec      	beq.n	802244e <s_fp_add+0x108>
 8022474:	68fb      	ldr	r3, [r7, #12]
 8022476:	681b      	ldr	r3, [r3, #0]
 8022478:	2b00      	cmp	r3, #0
 802247a:	d002      	beq.n	8022482 <s_fp_add+0x13c>
 802247c:	68fb      	ldr	r3, [r7, #12]
 802247e:	685b      	ldr	r3, [r3, #4]
 8022480:	e000      	b.n	8022484 <s_fp_add+0x13e>
 8022482:	2300      	movs	r3, #0
 8022484:	68fa      	ldr	r2, [r7, #12]
 8022486:	6053      	str	r3, [r2, #4]
  return FP_OKAY;
 8022488:	2300      	movs	r3, #0
}
 802248a:	4618      	mov	r0, r3
 802248c:	3734      	adds	r7, #52	@ 0x34
 802248e:	46bd      	mov	sp, r7
 8022490:	e8bd 0fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp}
 8022494:	4770      	bx	lr

08022496 <fp_sub>:

/* c = a - b */
int fp_sub(fp_int *a, fp_int *b, fp_int *c)
{
 8022496:	b580      	push	{r7, lr}
 8022498:	b088      	sub	sp, #32
 802249a:	af00      	add	r7, sp, #0
 802249c:	60f8      	str	r0, [r7, #12]
 802249e:	60b9      	str	r1, [r7, #8]
 80224a0:	607a      	str	r2, [r7, #4]
  int sa, sb;
  int ret = FP_OKAY;
 80224a2:	2300      	movs	r3, #0
 80224a4:	61fb      	str	r3, [r7, #28]

  sa = a->sign;
 80224a6:	68fb      	ldr	r3, [r7, #12]
 80224a8:	685b      	ldr	r3, [r3, #4]
 80224aa:	61bb      	str	r3, [r7, #24]
  sb = b->sign;
 80224ac:	68bb      	ldr	r3, [r7, #8]
 80224ae:	685b      	ldr	r3, [r3, #4]
 80224b0:	617b      	str	r3, [r7, #20]

  if (sa != sb) {
 80224b2:	69ba      	ldr	r2, [r7, #24]
 80224b4:	697b      	ldr	r3, [r7, #20]
 80224b6:	429a      	cmp	r2, r3
 80224b8:	d009      	beq.n	80224ce <fp_sub+0x38>
    /* subtract a negative from a positive, OR */
    /* subtract a positive from a negative. */
    /* In either case, ADD their magnitudes, */
    /* and use the sign of the first number. */
    c->sign = sa;
 80224ba:	687b      	ldr	r3, [r7, #4]
 80224bc:	69ba      	ldr	r2, [r7, #24]
 80224be:	605a      	str	r2, [r3, #4]
    ret = s_fp_add (a, b, c);
 80224c0:	687a      	ldr	r2, [r7, #4]
 80224c2:	68b9      	ldr	r1, [r7, #8]
 80224c4:	68f8      	ldr	r0, [r7, #12]
 80224c6:	f7ff ff3e 	bl	8022346 <s_fp_add>
 80224ca:	61f8      	str	r0, [r7, #28]
 80224cc:	e01e      	b.n	802250c <fp_sub+0x76>
  } else {
    /* subtract a positive from a positive, OR */
    /* subtract a negative from a negative. */
    /* First, take the difference between their */
    /* magnitudes, then... */
    if (fp_cmp_mag (a, b) != FP_LT) {
 80224ce:	68b9      	ldr	r1, [r7, #8]
 80224d0:	68f8      	ldr	r0, [r7, #12]
 80224d2:	f003 fb38 	bl	8025b46 <fp_cmp_mag>
 80224d6:	4603      	mov	r3, r0
 80224d8:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 80224dc:	d008      	beq.n	80224f0 <fp_sub+0x5a>
      /* Copy the sign from the first */
      c->sign = sa;
 80224de:	687b      	ldr	r3, [r7, #4]
 80224e0:	69ba      	ldr	r2, [r7, #24]
 80224e2:	605a      	str	r2, [r3, #4]
      /* The first has a larger or equal magnitude */
      s_fp_sub (a, b, c);
 80224e4:	687a      	ldr	r2, [r7, #4]
 80224e6:	68b9      	ldr	r1, [r7, #8]
 80224e8:	68f8      	ldr	r0, [r7, #12]
 80224ea:	f000 f814 	bl	8022516 <s_fp_sub>
 80224ee:	e00d      	b.n	802250c <fp_sub+0x76>
    } else {
      /* The result has the *opposite* sign from */
      /* the first number. */
      c->sign = (sa == FP_ZPOS) ? FP_NEG : FP_ZPOS;
 80224f0:	69bb      	ldr	r3, [r7, #24]
 80224f2:	2b00      	cmp	r3, #0
 80224f4:	bf0c      	ite	eq
 80224f6:	2301      	moveq	r3, #1
 80224f8:	2300      	movne	r3, #0
 80224fa:	b2db      	uxtb	r3, r3
 80224fc:	461a      	mov	r2, r3
 80224fe:	687b      	ldr	r3, [r7, #4]
 8022500:	605a      	str	r2, [r3, #4]
      /* The second has a larger magnitude */
      s_fp_sub (b, a, c);
 8022502:	687a      	ldr	r2, [r7, #4]
 8022504:	68f9      	ldr	r1, [r7, #12]
 8022506:	68b8      	ldr	r0, [r7, #8]
 8022508:	f000 f805 	bl	8022516 <s_fp_sub>
    }
  }
  return ret;
 802250c:	69fb      	ldr	r3, [r7, #28]
}
 802250e:	4618      	mov	r0, r3
 8022510:	3720      	adds	r7, #32
 8022512:	46bd      	mov	sp, r7
 8022514:	bd80      	pop	{r7, pc}

08022516 <s_fp_sub>:

/* unsigned subtraction ||a|| >= ||b|| ALWAYS! */
void s_fp_sub(fp_int *a, fp_int *b, fp_int *c)
{
 8022516:	e92d 0fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp}
 802251a:	b095      	sub	sp, #84	@ 0x54
 802251c:	af00      	add	r7, sp, #0
 802251e:	6378      	str	r0, [r7, #52]	@ 0x34
 8022520:	6339      	str	r1, [r7, #48]	@ 0x30
 8022522:	62fa      	str	r2, [r7, #44]	@ 0x2c
  int      x, oldbused, oldused;
  fp_word  t;

  oldused  = c->used;
 8022524:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022526:	681b      	ldr	r3, [r3, #0]
 8022528:	63fb      	str	r3, [r7, #60]	@ 0x3c
  oldbused = b->used;
 802252a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802252c:	681b      	ldr	r3, [r3, #0]
 802252e:	63bb      	str	r3, [r7, #56]	@ 0x38
  c->used  = a->used;
 8022530:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8022532:	681a      	ldr	r2, [r3, #0]
 8022534:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022536:	601a      	str	r2, [r3, #0]
  t       = 0;
 8022538:	f04f 0200 	mov.w	r2, #0
 802253c:	f04f 0300 	mov.w	r3, #0
 8022540:	e9c7 2310 	strd	r2, r3, [r7, #64]	@ 0x40
  for (x = 0; x < oldbused; x++) {
 8022544:	2300      	movs	r3, #0
 8022546:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8022548:	e040      	b.n	80225cc <s_fp_sub+0xb6>
     t         = ((fp_word)a->dp[x]) - (((fp_word)b->dp[x]) + t);
 802254a:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 802254c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802254e:	3302      	adds	r3, #2
 8022550:	009b      	lsls	r3, r3, #2
 8022552:	4413      	add	r3, r2
 8022554:	685b      	ldr	r3, [r3, #4]
 8022556:	2200      	movs	r2, #0
 8022558:	61bb      	str	r3, [r7, #24]
 802255a:	61fa      	str	r2, [r7, #28]
 802255c:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 802255e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8022560:	3302      	adds	r3, #2
 8022562:	009b      	lsls	r3, r3, #2
 8022564:	4413      	add	r3, r2
 8022566:	685b      	ldr	r3, [r3, #4]
 8022568:	2200      	movs	r2, #0
 802256a:	623b      	str	r3, [r7, #32]
 802256c:	627a      	str	r2, [r7, #36]	@ 0x24
 802256e:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	@ 0x40
 8022572:	6a39      	ldr	r1, [r7, #32]
 8022574:	188c      	adds	r4, r1, r2
 8022576:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8022578:	eb41 0503 	adc.w	r5, r1, r3
 802257c:	e9d7 1206 	ldrd	r1, r2, [r7, #24]
 8022580:	460b      	mov	r3, r1
 8022582:	1b1b      	subs	r3, r3, r4
 8022584:	613b      	str	r3, [r7, #16]
 8022586:	4613      	mov	r3, r2
 8022588:	eb63 0305 	sbc.w	r3, r3, r5
 802258c:	617b      	str	r3, [r7, #20]
 802258e:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 8022592:	e9c7 2310 	strd	r2, r3, [r7, #64]	@ 0x40
     c->dp[x]  = (fp_digit)t;
 8022596:	6c39      	ldr	r1, [r7, #64]	@ 0x40
 8022598:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 802259a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802259c:	3302      	adds	r3, #2
 802259e:	009b      	lsls	r3, r3, #2
 80225a0:	4413      	add	r3, r2
 80225a2:	6059      	str	r1, [r3, #4]
     t         = (t >> DIGIT_BIT)&1;
 80225a4:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	@ 0x40
 80225a8:	f04f 0000 	mov.w	r0, #0
 80225ac:	f04f 0100 	mov.w	r1, #0
 80225b0:	0018      	movs	r0, r3
 80225b2:	2100      	movs	r1, #0
 80225b4:	f000 0301 	and.w	r3, r0, #1
 80225b8:	60bb      	str	r3, [r7, #8]
 80225ba:	2300      	movs	r3, #0
 80225bc:	60fb      	str	r3, [r7, #12]
 80225be:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 80225c2:	e9c7 2310 	strd	r2, r3, [r7, #64]	@ 0x40
  for (x = 0; x < oldbused; x++) {
 80225c6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80225c8:	3301      	adds	r3, #1
 80225ca:	64fb      	str	r3, [r7, #76]	@ 0x4c
 80225cc:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80225ce:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80225d0:	429a      	cmp	r2, r3
 80225d2:	dbba      	blt.n	802254a <s_fp_sub+0x34>
  }
  for (; x < a->used; x++) {
 80225d4:	e02b      	b.n	802262e <s_fp_sub+0x118>
     t         = ((fp_word)a->dp[x]) - t;
 80225d6:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 80225d8:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80225da:	3302      	adds	r3, #2
 80225dc:	009b      	lsls	r3, r3, #2
 80225de:	4413      	add	r3, r2
 80225e0:	685b      	ldr	r3, [r3, #4]
 80225e2:	2200      	movs	r2, #0
 80225e4:	4698      	mov	r8, r3
 80225e6:	4691      	mov	r9, r2
 80225e8:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	@ 0x40
 80225ec:	ebb8 0a02 	subs.w	sl, r8, r2
 80225f0:	eb69 0b03 	sbc.w	fp, r9, r3
 80225f4:	e9c7 ab10 	strd	sl, fp, [r7, #64]	@ 0x40
     c->dp[x]  = (fp_digit)t;
 80225f8:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80225fa:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 80225fc:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80225fe:	3302      	adds	r3, #2
 8022600:	009b      	lsls	r3, r3, #2
 8022602:	440b      	add	r3, r1
 8022604:	605a      	str	r2, [r3, #4]
     t         = (t >> DIGIT_BIT)&1;
 8022606:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	@ 0x40
 802260a:	f04f 0200 	mov.w	r2, #0
 802260e:	f04f 0300 	mov.w	r3, #0
 8022612:	000a      	movs	r2, r1
 8022614:	2300      	movs	r3, #0
 8022616:	f002 0301 	and.w	r3, r2, #1
 802261a:	603b      	str	r3, [r7, #0]
 802261c:	2300      	movs	r3, #0
 802261e:	607b      	str	r3, [r7, #4]
 8022620:	e9d7 3400 	ldrd	r3, r4, [r7]
 8022624:	e9c7 3410 	strd	r3, r4, [r7, #64]	@ 0x40
  for (; x < a->used; x++) {
 8022628:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802262a:	3301      	adds	r3, #1
 802262c:	64fb      	str	r3, [r7, #76]	@ 0x4c
 802262e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8022630:	681b      	ldr	r3, [r3, #0]
 8022632:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8022634:	429a      	cmp	r2, r3
 8022636:	dbce      	blt.n	80225d6 <s_fp_sub+0xc0>
   }

  /* zero any excess digits on the destination that we didn't write to */
  for (; x < oldused; x++) {
 8022638:	e009      	b.n	802264e <s_fp_sub+0x138>
     c->dp[x] = 0;
 802263a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 802263c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802263e:	3302      	adds	r3, #2
 8022640:	009b      	lsls	r3, r3, #2
 8022642:	4413      	add	r3, r2
 8022644:	2200      	movs	r2, #0
 8022646:	605a      	str	r2, [r3, #4]
  for (; x < oldused; x++) {
 8022648:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802264a:	3301      	adds	r3, #1
 802264c:	64fb      	str	r3, [r7, #76]	@ 0x4c
 802264e:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8022650:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8022652:	429a      	cmp	r2, r3
 8022654:	dbf1      	blt.n	802263a <s_fp_sub+0x124>
  }
  fp_clamp(c);
 8022656:	e004      	b.n	8022662 <s_fp_sub+0x14c>
 8022658:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802265a:	681b      	ldr	r3, [r3, #0]
 802265c:	1e5a      	subs	r2, r3, #1
 802265e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022660:	601a      	str	r2, [r3, #0]
 8022662:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022664:	681b      	ldr	r3, [r3, #0]
 8022666:	2b00      	cmp	r3, #0
 8022668:	d009      	beq.n	802267e <s_fp_sub+0x168>
 802266a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802266c:	681b      	ldr	r3, [r3, #0]
 802266e:	3b01      	subs	r3, #1
 8022670:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8022672:	3302      	adds	r3, #2
 8022674:	009b      	lsls	r3, r3, #2
 8022676:	4413      	add	r3, r2
 8022678:	685b      	ldr	r3, [r3, #4]
 802267a:	2b00      	cmp	r3, #0
 802267c:	d0ec      	beq.n	8022658 <s_fp_sub+0x142>
 802267e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022680:	681b      	ldr	r3, [r3, #0]
 8022682:	2b00      	cmp	r3, #0
 8022684:	d002      	beq.n	802268c <s_fp_sub+0x176>
 8022686:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022688:	685b      	ldr	r3, [r3, #4]
 802268a:	e000      	b.n	802268e <s_fp_sub+0x178>
 802268c:	2300      	movs	r3, #0
 802268e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8022690:	6053      	str	r3, [r2, #4]
}
 8022692:	bf00      	nop
 8022694:	3754      	adds	r7, #84	@ 0x54
 8022696:	46bd      	mov	sp, r7
 8022698:	e8bd 0fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp}
 802269c:	4770      	bx	lr

0802269e <fp_mul>:

/* c = a * b */
int fp_mul(fp_int *A, fp_int *B, fp_int *C)
{
 802269e:	b580      	push	{r7, lr}
 80226a0:	b088      	sub	sp, #32
 80226a2:	af00      	add	r7, sp, #0
 80226a4:	60f8      	str	r0, [r7, #12]
 80226a6:	60b9      	str	r1, [r7, #8]
 80226a8:	607a      	str	r2, [r7, #4]
    int   ret = FP_OKAY;
 80226aa:	2300      	movs	r3, #0
 80226ac:	61fb      	str	r3, [r7, #28]
    int   y, yy, oldused;

    oldused = C->used;
 80226ae:	687b      	ldr	r3, [r7, #4]
 80226b0:	681b      	ldr	r3, [r3, #0]
 80226b2:	617b      	str	r3, [r7, #20]

    y  = MAX(A->used, B->used);
 80226b4:	68bb      	ldr	r3, [r7, #8]
 80226b6:	681a      	ldr	r2, [r3, #0]
 80226b8:	68fb      	ldr	r3, [r7, #12]
 80226ba:	681b      	ldr	r3, [r3, #0]
 80226bc:	4293      	cmp	r3, r2
 80226be:	bfb8      	it	lt
 80226c0:	4613      	movlt	r3, r2
 80226c2:	61bb      	str	r3, [r7, #24]
    yy = MIN(A->used, B->used);
 80226c4:	68bb      	ldr	r3, [r7, #8]
 80226c6:	681a      	ldr	r2, [r3, #0]
 80226c8:	68fb      	ldr	r3, [r7, #12]
 80226ca:	681b      	ldr	r3, [r3, #0]
 80226cc:	4293      	cmp	r3, r2
 80226ce:	bfa8      	it	ge
 80226d0:	4613      	movge	r3, r2
 80226d2:	613b      	str	r3, [r7, #16]

    /* fail if we are out of range */
    if (y + yy >= FP_SIZE) {
 80226d4:	69ba      	ldr	r2, [r7, #24]
 80226d6:	693b      	ldr	r3, [r7, #16]
 80226d8:	4413      	add	r3, r2
 80226da:	2b87      	cmp	r3, #135	@ 0x87
 80226dc:	dd03      	ble.n	80226e6 <fp_mul+0x48>
       ret = FP_VAL;
 80226de:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 80226e2:	61fb      	str	r3, [r7, #28]
       goto clean;
 80226e4:	e005      	b.n	80226f2 <fp_mul+0x54>
        if (yy >= 56 && y <= 64) {
           ret = fp_mul_comba64(A,B,C);
           goto clean;
        }
#endif
        ret = fp_mul_comba(A,B,C);
 80226e6:	687a      	ldr	r2, [r7, #4]
 80226e8:	68b9      	ldr	r1, [r7, #8]
 80226ea:	68f8      	ldr	r0, [r7, #12]
 80226ec:	f000 f9bb 	bl	8022a66 <fp_mul_comba>
 80226f0:	61f8      	str	r0, [r7, #28]

clean:
    /* zero any excess digits on the destination that we didn't write to */
    for (y = C->used; y >= 0 && y < oldused; y++) {
 80226f2:	687b      	ldr	r3, [r7, #4]
 80226f4:	681b      	ldr	r3, [r3, #0]
 80226f6:	61bb      	str	r3, [r7, #24]
 80226f8:	e009      	b.n	802270e <fp_mul+0x70>
        C->dp[y] = 0;
 80226fa:	687a      	ldr	r2, [r7, #4]
 80226fc:	69bb      	ldr	r3, [r7, #24]
 80226fe:	3302      	adds	r3, #2
 8022700:	009b      	lsls	r3, r3, #2
 8022702:	4413      	add	r3, r2
 8022704:	2200      	movs	r2, #0
 8022706:	605a      	str	r2, [r3, #4]
    for (y = C->used; y >= 0 && y < oldused; y++) {
 8022708:	69bb      	ldr	r3, [r7, #24]
 802270a:	3301      	adds	r3, #1
 802270c:	61bb      	str	r3, [r7, #24]
 802270e:	69bb      	ldr	r3, [r7, #24]
 8022710:	2b00      	cmp	r3, #0
 8022712:	db03      	blt.n	802271c <fp_mul+0x7e>
 8022714:	69ba      	ldr	r2, [r7, #24]
 8022716:	697b      	ldr	r3, [r7, #20]
 8022718:	429a      	cmp	r2, r3
 802271a:	dbee      	blt.n	80226fa <fp_mul+0x5c>
    }

    return ret;
 802271c:	69fb      	ldr	r3, [r7, #28]
}
 802271e:	4618      	mov	r0, r3
 8022720:	3720      	adds	r7, #32
 8022722:	46bd      	mov	sp, r7
 8022724:	bd80      	pop	{r7, pc}

08022726 <fp_mul_2>:

int fp_mul_2(fp_int * a, fp_int * b)
{
 8022726:	b480      	push	{r7}
 8022728:	b089      	sub	sp, #36	@ 0x24
 802272a:	af00      	add	r7, sp, #0
 802272c:	6078      	str	r0, [r7, #4]
 802272e:	6039      	str	r1, [r7, #0]
  int     x, oldused;

  /* Make sure value to double and result are in range. */
  if ((a->used > (FP_SIZE-1)) || ((a->used == (FP_SIZE - 1)) &&
 8022730:	687b      	ldr	r3, [r7, #4]
 8022732:	681b      	ldr	r3, [r3, #0]
 8022734:	2b87      	cmp	r3, #135	@ 0x87
 8022736:	dc08      	bgt.n	802274a <fp_mul_2+0x24>
 8022738:	687b      	ldr	r3, [r7, #4]
 802273a:	681b      	ldr	r3, [r3, #0]
 802273c:	2b87      	cmp	r3, #135	@ 0x87
 802273e:	d107      	bne.n	8022750 <fp_mul_2+0x2a>
              ((a->dp[FP_SIZE - 1] & ((fp_digit)1 << (DIGIT_BIT - 1))) != 0))) {
 8022740:	687b      	ldr	r3, [r7, #4]
 8022742:	f8d3 3228 	ldr.w	r3, [r3, #552]	@ 0x228
  if ((a->used > (FP_SIZE-1)) || ((a->used == (FP_SIZE - 1)) &&
 8022746:	2b00      	cmp	r3, #0
 8022748:	da02      	bge.n	8022750 <fp_mul_2+0x2a>
    return FP_VAL;
 802274a:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 802274e:	e052      	b.n	80227f6 <fp_mul_2+0xd0>
  }

  oldused = b->used;
 8022750:	683b      	ldr	r3, [r7, #0]
 8022752:	681b      	ldr	r3, [r3, #0]
 8022754:	60fb      	str	r3, [r7, #12]
  b->used = a->used;
 8022756:	687b      	ldr	r3, [r7, #4]
 8022758:	681a      	ldr	r2, [r3, #0]
 802275a:	683b      	ldr	r3, [r7, #0]
 802275c:	601a      	str	r2, [r3, #0]

  {
    fp_digit r, rr, *tmpa, *tmpb;

    /* alias for source */
    tmpa = a->dp;
 802275e:	687b      	ldr	r3, [r7, #4]
 8022760:	330c      	adds	r3, #12
 8022762:	617b      	str	r3, [r7, #20]

    /* alias for dest */
    tmpb = b->dp;
 8022764:	683b      	ldr	r3, [r7, #0]
 8022766:	330c      	adds	r3, #12
 8022768:	613b      	str	r3, [r7, #16]

    /* carry */
    r = 0;
 802276a:	2300      	movs	r3, #0
 802276c:	61bb      	str	r3, [r7, #24]
    for (x = 0; x < a->used; x++) {
 802276e:	2300      	movs	r3, #0
 8022770:	61fb      	str	r3, [r7, #28]
 8022772:	e013      	b.n	802279c <fp_mul_2+0x76>

      /* get what will be the *next* carry bit from the
       * MSB of the current digit
       */
      rr = *tmpa >> ((fp_digit)(DIGIT_BIT - 1));
 8022774:	697b      	ldr	r3, [r7, #20]
 8022776:	681b      	ldr	r3, [r3, #0]
 8022778:	0fdb      	lsrs	r3, r3, #31
 802277a:	60bb      	str	r3, [r7, #8]

      /* now shift up this digit, add in the carry [from the previous] */
      *tmpb++ = ((*tmpa++ << ((fp_digit)1)) | r);
 802277c:	697b      	ldr	r3, [r7, #20]
 802277e:	1d1a      	adds	r2, r3, #4
 8022780:	617a      	str	r2, [r7, #20]
 8022782:	681b      	ldr	r3, [r3, #0]
 8022784:	0059      	lsls	r1, r3, #1
 8022786:	693b      	ldr	r3, [r7, #16]
 8022788:	1d1a      	adds	r2, r3, #4
 802278a:	613a      	str	r2, [r7, #16]
 802278c:	69ba      	ldr	r2, [r7, #24]
 802278e:	430a      	orrs	r2, r1
 8022790:	601a      	str	r2, [r3, #0]

      /* copy the carry that would be from the source
       * digit into the next iteration
       */
      r = rr;
 8022792:	68bb      	ldr	r3, [r7, #8]
 8022794:	61bb      	str	r3, [r7, #24]
    for (x = 0; x < a->used; x++) {
 8022796:	69fb      	ldr	r3, [r7, #28]
 8022798:	3301      	adds	r3, #1
 802279a:	61fb      	str	r3, [r7, #28]
 802279c:	687b      	ldr	r3, [r7, #4]
 802279e:	681b      	ldr	r3, [r3, #0]
 80227a0:	69fa      	ldr	r2, [r7, #28]
 80227a2:	429a      	cmp	r2, r3
 80227a4:	dbe6      	blt.n	8022774 <fp_mul_2+0x4e>
    }

    /* new leading digit? */
    if (r != 0) {
 80227a6:	69bb      	ldr	r3, [r7, #24]
 80227a8:	2b00      	cmp	r3, #0
 80227aa:	d007      	beq.n	80227bc <fp_mul_2+0x96>
      /* add a MSB which is always 1 at this point */
      *tmpb = 1;
 80227ac:	693b      	ldr	r3, [r7, #16]
 80227ae:	2201      	movs	r2, #1
 80227b0:	601a      	str	r2, [r3, #0]
      ++(b->used);
 80227b2:	683b      	ldr	r3, [r7, #0]
 80227b4:	681b      	ldr	r3, [r3, #0]
 80227b6:	1c5a      	adds	r2, r3, #1
 80227b8:	683b      	ldr	r3, [r7, #0]
 80227ba:	601a      	str	r2, [r3, #0]
    }

    /* zero any excess digits on the destination that we didn't write to */
    tmpb = b->dp + b->used;
 80227bc:	683b      	ldr	r3, [r7, #0]
 80227be:	f103 020c 	add.w	r2, r3, #12
 80227c2:	683b      	ldr	r3, [r7, #0]
 80227c4:	681b      	ldr	r3, [r3, #0]
 80227c6:	009b      	lsls	r3, r3, #2
 80227c8:	4413      	add	r3, r2
 80227ca:	613b      	str	r3, [r7, #16]
    for (x = b->used; x < oldused; x++) {
 80227cc:	683b      	ldr	r3, [r7, #0]
 80227ce:	681b      	ldr	r3, [r3, #0]
 80227d0:	61fb      	str	r3, [r7, #28]
 80227d2:	e007      	b.n	80227e4 <fp_mul_2+0xbe>
      *tmpb++ = 0;
 80227d4:	693b      	ldr	r3, [r7, #16]
 80227d6:	1d1a      	adds	r2, r3, #4
 80227d8:	613a      	str	r2, [r7, #16]
 80227da:	2200      	movs	r2, #0
 80227dc:	601a      	str	r2, [r3, #0]
    for (x = b->used; x < oldused; x++) {
 80227de:	69fb      	ldr	r3, [r7, #28]
 80227e0:	3301      	adds	r3, #1
 80227e2:	61fb      	str	r3, [r7, #28]
 80227e4:	69fa      	ldr	r2, [r7, #28]
 80227e6:	68fb      	ldr	r3, [r7, #12]
 80227e8:	429a      	cmp	r2, r3
 80227ea:	dbf3      	blt.n	80227d4 <fp_mul_2+0xae>
    }
  }
  b->sign = a->sign;
 80227ec:	687b      	ldr	r3, [r7, #4]
 80227ee:	685a      	ldr	r2, [r3, #4]
 80227f0:	683b      	ldr	r3, [r7, #0]
 80227f2:	605a      	str	r2, [r3, #4]

  return FP_OKAY;
 80227f4:	2300      	movs	r3, #0
}
 80227f6:	4618      	mov	r0, r3
 80227f8:	3724      	adds	r7, #36	@ 0x24
 80227fa:	46bd      	mov	sp, r7
 80227fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022800:	4770      	bx	lr

08022802 <fp_mul_d>:

/* c = a * b */
int fp_mul_d(fp_int *a, fp_digit b, fp_int *c)
{
 8022802:	e92d 0fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp}
 8022806:	b08b      	sub	sp, #44	@ 0x2c
 8022808:	af00      	add	r7, sp, #0
 802280a:	6178      	str	r0, [r7, #20]
 802280c:	6139      	str	r1, [r7, #16]
 802280e:	60fa      	str	r2, [r7, #12]
   fp_word  w;
   int      x, oldused;

   oldused = c->used;
 8022810:	68fb      	ldr	r3, [r7, #12]
 8022812:	681b      	ldr	r3, [r3, #0]
 8022814:	61bb      	str	r3, [r7, #24]
   c->used = a->used;
 8022816:	697b      	ldr	r3, [r7, #20]
 8022818:	681a      	ldr	r2, [r3, #0]
 802281a:	68fb      	ldr	r3, [r7, #12]
 802281c:	601a      	str	r2, [r3, #0]
   c->sign = a->sign;
 802281e:	697b      	ldr	r3, [r7, #20]
 8022820:	685a      	ldr	r2, [r3, #4]
 8022822:	68fb      	ldr	r3, [r7, #12]
 8022824:	605a      	str	r2, [r3, #4]
   w       = 0;
 8022826:	f04f 0200 	mov.w	r2, #0
 802282a:	f04f 0300 	mov.w	r3, #0
 802282e:	e9c7 2308 	strd	r2, r3, [r7, #32]
   for (x = 0; x < a->used; x++) {
 8022832:	2300      	movs	r3, #0
 8022834:	61fb      	str	r3, [r7, #28]
 8022836:	e033      	b.n	80228a0 <fp_mul_d+0x9e>
       w         = ((fp_word)a->dp[x]) * ((fp_word)b) + w;
 8022838:	697a      	ldr	r2, [r7, #20]
 802283a:	69fb      	ldr	r3, [r7, #28]
 802283c:	3302      	adds	r3, #2
 802283e:	009b      	lsls	r3, r3, #2
 8022840:	4413      	add	r3, r2
 8022842:	685b      	ldr	r3, [r3, #4]
 8022844:	2200      	movs	r2, #0
 8022846:	4698      	mov	r8, r3
 8022848:	4691      	mov	r9, r2
 802284a:	693b      	ldr	r3, [r7, #16]
 802284c:	2200      	movs	r2, #0
 802284e:	469a      	mov	sl, r3
 8022850:	4693      	mov	fp, r2
 8022852:	fb0a f209 	mul.w	r2, sl, r9
 8022856:	fb08 f30b 	mul.w	r3, r8, fp
 802285a:	4413      	add	r3, r2
 802285c:	fba8 450a 	umull	r4, r5, r8, sl
 8022860:	442b      	add	r3, r5
 8022862:	461d      	mov	r5, r3
 8022864:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8022868:	1911      	adds	r1, r2, r4
 802286a:	6039      	str	r1, [r7, #0]
 802286c:	416b      	adcs	r3, r5
 802286e:	607b      	str	r3, [r7, #4]
 8022870:	e9d7 2300 	ldrd	r2, r3, [r7]
 8022874:	e9c7 2308 	strd	r2, r3, [r7, #32]
       c->dp[x]  = (fp_digit)w;
 8022878:	6a3a      	ldr	r2, [r7, #32]
 802287a:	68f9      	ldr	r1, [r7, #12]
 802287c:	69fb      	ldr	r3, [r7, #28]
 802287e:	3302      	adds	r3, #2
 8022880:	009b      	lsls	r3, r3, #2
 8022882:	440b      	add	r3, r1
 8022884:	605a      	str	r2, [r3, #4]
       w         = w >> DIGIT_BIT;
 8022886:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 802288a:	f04f 0200 	mov.w	r2, #0
 802288e:	f04f 0300 	mov.w	r3, #0
 8022892:	000a      	movs	r2, r1
 8022894:	2300      	movs	r3, #0
 8022896:	e9c7 2308 	strd	r2, r3, [r7, #32]
   for (x = 0; x < a->used; x++) {
 802289a:	69fb      	ldr	r3, [r7, #28]
 802289c:	3301      	adds	r3, #1
 802289e:	61fb      	str	r3, [r7, #28]
 80228a0:	697b      	ldr	r3, [r7, #20]
 80228a2:	681b      	ldr	r3, [r3, #0]
 80228a4:	69fa      	ldr	r2, [r7, #28]
 80228a6:	429a      	cmp	r2, r3
 80228a8:	dbc6      	blt.n	8022838 <fp_mul_d+0x36>
   }
   if (w != 0) {
 80228aa:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 80228ae:	4313      	orrs	r3, r2
 80228b0:	d01f      	beq.n	80228f2 <fp_mul_d+0xf0>
      if (a->used == FP_SIZE)
 80228b2:	697b      	ldr	r3, [r7, #20]
 80228b4:	681b      	ldr	r3, [r3, #0]
 80228b6:	2b88      	cmp	r3, #136	@ 0x88
 80228b8:	d102      	bne.n	80228c0 <fp_mul_d+0xbe>
          return FP_VAL;
 80228ba:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 80228be:	e03e      	b.n	802293e <fp_mul_d+0x13c>
      c->dp[c->used++] = (fp_digit) w;
 80228c0:	68fb      	ldr	r3, [r7, #12]
 80228c2:	681b      	ldr	r3, [r3, #0]
 80228c4:	1c59      	adds	r1, r3, #1
 80228c6:	68fa      	ldr	r2, [r7, #12]
 80228c8:	6011      	str	r1, [r2, #0]
 80228ca:	6a3a      	ldr	r2, [r7, #32]
 80228cc:	68f9      	ldr	r1, [r7, #12]
 80228ce:	3302      	adds	r3, #2
 80228d0:	009b      	lsls	r3, r3, #2
 80228d2:	440b      	add	r3, r1
 80228d4:	605a      	str	r2, [r3, #4]
      ++x;
 80228d6:	69fb      	ldr	r3, [r7, #28]
 80228d8:	3301      	adds	r3, #1
 80228da:	61fb      	str	r3, [r7, #28]
   }

   /* zero any excess digits on the destination that we didn't write to */
   /* also checking FP_SIZE here for static analysis */
   for (; x < oldused && x < FP_SIZE; x++) {
 80228dc:	e009      	b.n	80228f2 <fp_mul_d+0xf0>
      c->dp[x] = 0;
 80228de:	68fa      	ldr	r2, [r7, #12]
 80228e0:	69fb      	ldr	r3, [r7, #28]
 80228e2:	3302      	adds	r3, #2
 80228e4:	009b      	lsls	r3, r3, #2
 80228e6:	4413      	add	r3, r2
 80228e8:	2200      	movs	r2, #0
 80228ea:	605a      	str	r2, [r3, #4]
   for (; x < oldused && x < FP_SIZE; x++) {
 80228ec:	69fb      	ldr	r3, [r7, #28]
 80228ee:	3301      	adds	r3, #1
 80228f0:	61fb      	str	r3, [r7, #28]
 80228f2:	69fa      	ldr	r2, [r7, #28]
 80228f4:	69bb      	ldr	r3, [r7, #24]
 80228f6:	429a      	cmp	r2, r3
 80228f8:	da08      	bge.n	802290c <fp_mul_d+0x10a>
 80228fa:	69fb      	ldr	r3, [r7, #28]
 80228fc:	2b87      	cmp	r3, #135	@ 0x87
 80228fe:	ddee      	ble.n	80228de <fp_mul_d+0xdc>
   }

   fp_clamp(c);
 8022900:	e004      	b.n	802290c <fp_mul_d+0x10a>
 8022902:	68fb      	ldr	r3, [r7, #12]
 8022904:	681b      	ldr	r3, [r3, #0]
 8022906:	1e5a      	subs	r2, r3, #1
 8022908:	68fb      	ldr	r3, [r7, #12]
 802290a:	601a      	str	r2, [r3, #0]
 802290c:	68fb      	ldr	r3, [r7, #12]
 802290e:	681b      	ldr	r3, [r3, #0]
 8022910:	2b00      	cmp	r3, #0
 8022912:	d009      	beq.n	8022928 <fp_mul_d+0x126>
 8022914:	68fb      	ldr	r3, [r7, #12]
 8022916:	681b      	ldr	r3, [r3, #0]
 8022918:	3b01      	subs	r3, #1
 802291a:	68fa      	ldr	r2, [r7, #12]
 802291c:	3302      	adds	r3, #2
 802291e:	009b      	lsls	r3, r3, #2
 8022920:	4413      	add	r3, r2
 8022922:	685b      	ldr	r3, [r3, #4]
 8022924:	2b00      	cmp	r3, #0
 8022926:	d0ec      	beq.n	8022902 <fp_mul_d+0x100>
 8022928:	68fb      	ldr	r3, [r7, #12]
 802292a:	681b      	ldr	r3, [r3, #0]
 802292c:	2b00      	cmp	r3, #0
 802292e:	d002      	beq.n	8022936 <fp_mul_d+0x134>
 8022930:	68fb      	ldr	r3, [r7, #12]
 8022932:	685b      	ldr	r3, [r3, #4]
 8022934:	e000      	b.n	8022938 <fp_mul_d+0x136>
 8022936:	2300      	movs	r3, #0
 8022938:	68fa      	ldr	r2, [r7, #12]
 802293a:	6053      	str	r3, [r2, #4]
   return FP_OKAY;
 802293c:	2300      	movs	r3, #0
}
 802293e:	4618      	mov	r0, r3
 8022940:	372c      	adds	r7, #44	@ 0x2c
 8022942:	46bd      	mov	sp, r7
 8022944:	e8bd 0fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp}
 8022948:	4770      	bx	lr

0802294a <fp_mul_2d>:

/* c = a * 2**d */
int fp_mul_2d(fp_int *a, int b, fp_int *c)
{
 802294a:	b580      	push	{r7, lr}
 802294c:	b08a      	sub	sp, #40	@ 0x28
 802294e:	af00      	add	r7, sp, #0
 8022950:	60f8      	str	r0, [r7, #12]
 8022952:	60b9      	str	r1, [r7, #8]
 8022954:	607a      	str	r2, [r7, #4]
   fp_digit carry, carrytmp, shift;
   int x;

   /* copy it */
   fp_copy(a, c);
 8022956:	6879      	ldr	r1, [r7, #4]
 8022958:	68f8      	ldr	r0, [r7, #12]
 802295a:	f004 f893 	bl	8026a84 <fp_copy>

   /* handle whole digits */
   if (b >= DIGIT_BIT) {
 802295e:	68bb      	ldr	r3, [r7, #8]
 8022960:	2b1f      	cmp	r3, #31
 8022962:	dd0e      	ble.n	8022982 <fp_mul_2d+0x38>
      int ret = fp_lshd(c, b/DIGIT_BIT);
 8022964:	68bb      	ldr	r3, [r7, #8]
 8022966:	2b00      	cmp	r3, #0
 8022968:	da00      	bge.n	802296c <fp_mul_2d+0x22>
 802296a:	331f      	adds	r3, #31
 802296c:	115b      	asrs	r3, r3, #5
 802296e:	4619      	mov	r1, r3
 8022970:	6878      	ldr	r0, [r7, #4]
 8022972:	f003 fd0d 	bl	8026390 <fp_lshd>
 8022976:	61f8      	str	r0, [r7, #28]
      if (ret != FP_OKAY)
 8022978:	69fb      	ldr	r3, [r7, #28]
 802297a:	2b00      	cmp	r3, #0
 802297c:	d001      	beq.n	8022982 <fp_mul_2d+0x38>
         return ret;
 802297e:	69fb      	ldr	r3, [r7, #28]
 8022980:	e06d      	b.n	8022a5e <fp_mul_2d+0x114>
   }
   b %= DIGIT_BIT;
 8022982:	68bb      	ldr	r3, [r7, #8]
 8022984:	425a      	negs	r2, r3
 8022986:	f003 031f 	and.w	r3, r3, #31
 802298a:	f002 021f 	and.w	r2, r2, #31
 802298e:	bf58      	it	pl
 8022990:	4253      	negpl	r3, r2
 8022992:	60bb      	str	r3, [r7, #8]

   /* shift the digits */
   if (b != 0) {
 8022994:	68bb      	ldr	r3, [r7, #8]
 8022996:	2b00      	cmp	r3, #0
 8022998:	d048      	beq.n	8022a2c <fp_mul_2d+0xe2>
      carry = 0;
 802299a:	2300      	movs	r3, #0
 802299c:	627b      	str	r3, [r7, #36]	@ 0x24
      shift = DIGIT_BIT - b;
 802299e:	68bb      	ldr	r3, [r7, #8]
 80229a0:	f1c3 0320 	rsb	r3, r3, #32
 80229a4:	61bb      	str	r3, [r7, #24]
      for (x = 0; x < c->used; x++) {
 80229a6:	2300      	movs	r3, #0
 80229a8:	623b      	str	r3, [r7, #32]
 80229aa:	e01e      	b.n	80229ea <fp_mul_2d+0xa0>
          carrytmp = c->dp[x] >> shift;
 80229ac:	687a      	ldr	r2, [r7, #4]
 80229ae:	6a3b      	ldr	r3, [r7, #32]
 80229b0:	3302      	adds	r3, #2
 80229b2:	009b      	lsls	r3, r3, #2
 80229b4:	4413      	add	r3, r2
 80229b6:	685a      	ldr	r2, [r3, #4]
 80229b8:	69bb      	ldr	r3, [r7, #24]
 80229ba:	fa22 f303 	lsr.w	r3, r2, r3
 80229be:	617b      	str	r3, [r7, #20]
          c->dp[x] = (c->dp[x] << b) + carry;
 80229c0:	687a      	ldr	r2, [r7, #4]
 80229c2:	6a3b      	ldr	r3, [r7, #32]
 80229c4:	3302      	adds	r3, #2
 80229c6:	009b      	lsls	r3, r3, #2
 80229c8:	4413      	add	r3, r2
 80229ca:	685a      	ldr	r2, [r3, #4]
 80229cc:	68bb      	ldr	r3, [r7, #8]
 80229ce:	409a      	lsls	r2, r3
 80229d0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80229d2:	441a      	add	r2, r3
 80229d4:	6879      	ldr	r1, [r7, #4]
 80229d6:	6a3b      	ldr	r3, [r7, #32]
 80229d8:	3302      	adds	r3, #2
 80229da:	009b      	lsls	r3, r3, #2
 80229dc:	440b      	add	r3, r1
 80229de:	605a      	str	r2, [r3, #4]
          carry = carrytmp;
 80229e0:	697b      	ldr	r3, [r7, #20]
 80229e2:	627b      	str	r3, [r7, #36]	@ 0x24
      for (x = 0; x < c->used; x++) {
 80229e4:	6a3b      	ldr	r3, [r7, #32]
 80229e6:	3301      	adds	r3, #1
 80229e8:	623b      	str	r3, [r7, #32]
 80229ea:	687b      	ldr	r3, [r7, #4]
 80229ec:	681b      	ldr	r3, [r3, #0]
 80229ee:	6a3a      	ldr	r2, [r7, #32]
 80229f0:	429a      	cmp	r2, r3
 80229f2:	dbdb      	blt.n	80229ac <fp_mul_2d+0x62>
      }
      /* store last carry if room */
      if (carry && x < FP_SIZE) {
 80229f4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80229f6:	2b00      	cmp	r3, #0
 80229f8:	d00d      	beq.n	8022a16 <fp_mul_2d+0xcc>
 80229fa:	6a3b      	ldr	r3, [r7, #32]
 80229fc:	2b87      	cmp	r3, #135	@ 0x87
 80229fe:	dc0a      	bgt.n	8022a16 <fp_mul_2d+0xcc>
         c->dp[c->used++] = carry;
 8022a00:	687b      	ldr	r3, [r7, #4]
 8022a02:	681b      	ldr	r3, [r3, #0]
 8022a04:	1c59      	adds	r1, r3, #1
 8022a06:	687a      	ldr	r2, [r7, #4]
 8022a08:	6011      	str	r1, [r2, #0]
 8022a0a:	687a      	ldr	r2, [r7, #4]
 8022a0c:	3302      	adds	r3, #2
 8022a0e:	009b      	lsls	r3, r3, #2
 8022a10:	4413      	add	r3, r2
 8022a12:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8022a14:	605a      	str	r2, [r3, #4]
      }
      if (x == FP_SIZE)
 8022a16:	6a3b      	ldr	r3, [r7, #32]
 8022a18:	2b88      	cmp	r3, #136	@ 0x88
 8022a1a:	d107      	bne.n	8022a2c <fp_mul_2d+0xe2>
         return FP_VAL;
 8022a1c:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8022a20:	e01d      	b.n	8022a5e <fp_mul_2d+0x114>
   }
   fp_clamp(c);
 8022a22:	687b      	ldr	r3, [r7, #4]
 8022a24:	681b      	ldr	r3, [r3, #0]
 8022a26:	1e5a      	subs	r2, r3, #1
 8022a28:	687b      	ldr	r3, [r7, #4]
 8022a2a:	601a      	str	r2, [r3, #0]
 8022a2c:	687b      	ldr	r3, [r7, #4]
 8022a2e:	681b      	ldr	r3, [r3, #0]
 8022a30:	2b00      	cmp	r3, #0
 8022a32:	d009      	beq.n	8022a48 <fp_mul_2d+0xfe>
 8022a34:	687b      	ldr	r3, [r7, #4]
 8022a36:	681b      	ldr	r3, [r3, #0]
 8022a38:	3b01      	subs	r3, #1
 8022a3a:	687a      	ldr	r2, [r7, #4]
 8022a3c:	3302      	adds	r3, #2
 8022a3e:	009b      	lsls	r3, r3, #2
 8022a40:	4413      	add	r3, r2
 8022a42:	685b      	ldr	r3, [r3, #4]
 8022a44:	2b00      	cmp	r3, #0
 8022a46:	d0ec      	beq.n	8022a22 <fp_mul_2d+0xd8>
 8022a48:	687b      	ldr	r3, [r7, #4]
 8022a4a:	681b      	ldr	r3, [r3, #0]
 8022a4c:	2b00      	cmp	r3, #0
 8022a4e:	d002      	beq.n	8022a56 <fp_mul_2d+0x10c>
 8022a50:	687b      	ldr	r3, [r7, #4]
 8022a52:	685b      	ldr	r3, [r3, #4]
 8022a54:	e000      	b.n	8022a58 <fp_mul_2d+0x10e>
 8022a56:	2300      	movs	r3, #0
 8022a58:	687a      	ldr	r2, [r7, #4]
 8022a5a:	6053      	str	r3, [r2, #4]
   return FP_OKAY;
 8022a5c:	2300      	movs	r3, #0
}
 8022a5e:	4618      	mov	r0, r3
 8022a60:	3728      	adds	r7, #40	@ 0x28
 8022a62:	46bd      	mov	sp, r7
 8022a64:	bd80      	pop	{r7, pc}

08022a66 <fp_mul_comba>:
}
#endif

/*  C = (A * B)   */
int fp_mul_comba(fp_int *A, fp_int *B, fp_int *C)
{
 8022a66:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8022a6a:	b0a0      	sub	sp, #128	@ 0x80
 8022a6c:	af00      	add	r7, sp, #0
 8022a6e:	62f8      	str	r0, [r7, #44]	@ 0x2c
 8022a70:	62b9      	str	r1, [r7, #40]	@ 0x28
 8022a72:	627a      	str	r2, [r7, #36]	@ 0x24
   int       ret = 0;
 8022a74:	2300      	movs	r3, #0
 8022a76:	65fb      	str	r3, [r7, #92]	@ 0x5c
   fp_int    tmp[1];
#else
   fp_int    *tmp;
#endif

   if (A->used + B->used >= FP_SIZE) return FP_VAL;
 8022a78:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022a7a:	681a      	ldr	r2, [r3, #0]
 8022a7c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8022a7e:	681b      	ldr	r3, [r3, #0]
 8022a80:	4413      	add	r3, r2
 8022a82:	2b87      	cmp	r3, #135	@ 0x87
 8022a84:	dd02      	ble.n	8022a8c <fp_mul_comba+0x26>
 8022a86:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8022a8a:	e0f4      	b.n	8022c76 <fp_mul_comba+0x210>

   IF_HAVE_INTEL_MULX(ret = fp_mul_comba_mulx(A, B, C), return ret) ;

#ifdef WOLFSSL_SMALL_STACK
   tmp = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
 8022a8c:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 8022a90:	f7fb fffa 	bl	801ea88 <wolfSSL_Malloc>
 8022a94:	65b8      	str	r0, [r7, #88]	@ 0x58
   if (tmp == NULL)
 8022a96:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8022a98:	2b00      	cmp	r3, #0
 8022a9a:	d102      	bne.n	8022aa2 <fp_mul_comba+0x3c>
       return FP_MEM;
 8022a9c:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 8022aa0:	e0e9      	b.n	8022c76 <fp_mul_comba+0x210>
#endif

   COMBA_START;
   COMBA_CLEAR;
 8022aa2:	2300      	movs	r3, #0
 8022aa4:	66bb      	str	r3, [r7, #104]	@ 0x68
 8022aa6:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8022aa8:	66fb      	str	r3, [r7, #108]	@ 0x6c
 8022aaa:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8022aac:	673b      	str	r3, [r7, #112]	@ 0x70

   /* get size of output and trim */
   pa = A->used + B->used;
 8022aae:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022ab0:	681a      	ldr	r2, [r3, #0]
 8022ab2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8022ab4:	681b      	ldr	r3, [r3, #0]
 8022ab6:	4413      	add	r3, r2
 8022ab8:	677b      	str	r3, [r7, #116]	@ 0x74
   if (pa >= FP_SIZE) {
 8022aba:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8022abc:	2b87      	cmp	r3, #135	@ 0x87
 8022abe:	dd01      	ble.n	8022ac4 <fp_mul_comba+0x5e>
      pa = FP_SIZE-1;
 8022ac0:	2387      	movs	r3, #135	@ 0x87
 8022ac2:	677b      	str	r3, [r7, #116]	@ 0x74
   }

   /* Always take branch to use tmp variable. This avoids a cache attack for
    * determining if C equals A */
   if (1) {
      fp_init(tmp);
 8022ac4:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 8022ac6:	f003 fdf3 	bl	80266b0 <fp_init>
      dst = tmp;
 8022aca:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8022acc:	657b      	str	r3, [r7, #84]	@ 0x54
   }

   for (ix = 0; ix < pa; ix++) {
 8022ace:	2300      	movs	r3, #0
 8022ad0:	67fb      	str	r3, [r7, #124]	@ 0x7c
 8022ad2:	e096      	b.n	8022c02 <fp_mul_comba+0x19c>
      /* get offsets into the two bignums */
      ty = MIN(ix, (B->used > 0 ? B->used - 1 : 0));
 8022ad4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8022ad6:	681b      	ldr	r3, [r3, #0]
 8022ad8:	2b01      	cmp	r3, #1
 8022ada:	bfb8      	it	lt
 8022adc:	2301      	movlt	r3, #1
 8022ade:	1e5a      	subs	r2, r3, #1
 8022ae0:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8022ae2:	4293      	cmp	r3, r2
 8022ae4:	bfa8      	it	ge
 8022ae6:	4613      	movge	r3, r2
 8022ae8:	64fb      	str	r3, [r7, #76]	@ 0x4c
      tx = ix - ty;
 8022aea:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 8022aec:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8022aee:	1ad3      	subs	r3, r2, r3
 8022af0:	64bb      	str	r3, [r7, #72]	@ 0x48

      /* setup temp aliases */
      tmpx = A->dp + tx;
 8022af2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022af4:	f103 020c 	add.w	r2, r3, #12
 8022af8:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8022afa:	009b      	lsls	r3, r3, #2
 8022afc:	4413      	add	r3, r2
 8022afe:	667b      	str	r3, [r7, #100]	@ 0x64
      tmpy = B->dp + ty;
 8022b00:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8022b02:	f103 020c 	add.w	r2, r3, #12
 8022b06:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8022b08:	009b      	lsls	r3, r3, #2
 8022b0a:	4413      	add	r3, r2
 8022b0c:	663b      	str	r3, [r7, #96]	@ 0x60

      /* this is the number of times the loop will iterate, essentially its
         while (tx++ < a->used && ty-- >= 0) { ... }
       */
      iy = MIN(A->used-tx, ty+1);
 8022b0e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022b10:	681a      	ldr	r2, [r3, #0]
 8022b12:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8022b14:	1ad2      	subs	r2, r2, r3
 8022b16:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8022b18:	4293      	cmp	r3, r2
 8022b1a:	db04      	blt.n	8022b26 <fp_mul_comba+0xc0>
 8022b1c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022b1e:	681a      	ldr	r2, [r3, #0]
 8022b20:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8022b22:	1ad3      	subs	r3, r2, r3
 8022b24:	e001      	b.n	8022b2a <fp_mul_comba+0xc4>
 8022b26:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8022b28:	3301      	adds	r3, #1
 8022b2a:	647b      	str	r3, [r7, #68]	@ 0x44

      /* execute loop */
      COMBA_FORWARD;
 8022b2c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8022b2e:	673b      	str	r3, [r7, #112]	@ 0x70
 8022b30:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8022b32:	66fb      	str	r3, [r7, #108]	@ 0x6c
 8022b34:	2300      	movs	r3, #0
 8022b36:	66bb      	str	r3, [r7, #104]	@ 0x68
      for (iz = 0; iz < iy; ++iz) {
 8022b38:	2300      	movs	r3, #0
 8022b3a:	67bb      	str	r3, [r7, #120]	@ 0x78
 8022b3c:	e053      	b.n	8022be6 <fp_mul_comba+0x180>
          fp_digit _tmpx = *tmpx++;
 8022b3e:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 8022b40:	1d13      	adds	r3, r2, #4
 8022b42:	667b      	str	r3, [r7, #100]	@ 0x64
 8022b44:	6813      	ldr	r3, [r2, #0]
 8022b46:	643b      	str	r3, [r7, #64]	@ 0x40
          fp_digit _tmpy = *tmpy--;
 8022b48:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8022b4a:	1f13      	subs	r3, r2, #4
 8022b4c:	663b      	str	r3, [r7, #96]	@ 0x60
 8022b4e:	6813      	ldr	r3, [r2, #0]
 8022b50:	63fb      	str	r3, [r7, #60]	@ 0x3c
          MULADD(_tmpx, _tmpy);
 8022b52:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8022b54:	2200      	movs	r2, #0
 8022b56:	613b      	str	r3, [r7, #16]
 8022b58:	617a      	str	r2, [r7, #20]
 8022b5a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8022b5c:	2200      	movs	r2, #0
 8022b5e:	4698      	mov	r8, r3
 8022b60:	4691      	mov	r9, r2
 8022b62:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8022b64:	2200      	movs	r2, #0
 8022b66:	469a      	mov	sl, r3
 8022b68:	4693      	mov	fp, r2
 8022b6a:	fb0a f209 	mul.w	r2, sl, r9
 8022b6e:	fb08 f30b 	mul.w	r3, r8, fp
 8022b72:	4413      	add	r3, r2
 8022b74:	fba8 450a 	umull	r4, r5, r8, sl
 8022b78:	442b      	add	r3, r5
 8022b7a:	461d      	mov	r5, r3
 8022b7c:	e9d7 1204 	ldrd	r1, r2, [r7, #16]
 8022b80:	460b      	mov	r3, r1
 8022b82:	191b      	adds	r3, r3, r4
 8022b84:	60bb      	str	r3, [r7, #8]
 8022b86:	4613      	mov	r3, r2
 8022b88:	416b      	adcs	r3, r5
 8022b8a:	60fb      	str	r3, [r7, #12]
 8022b8c:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 8022b90:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
 8022b94:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8022b96:	673b      	str	r3, [r7, #112]	@ 0x70
 8022b98:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8022b9a:	2200      	movs	r2, #0
 8022b9c:	61bb      	str	r3, [r7, #24]
 8022b9e:	61fa      	str	r2, [r7, #28]
 8022ba0:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	@ 0x30
 8022ba4:	f04f 0000 	mov.w	r0, #0
 8022ba8:	f04f 0100 	mov.w	r1, #0
 8022bac:	0018      	movs	r0, r3
 8022bae:	2100      	movs	r1, #0
 8022bb0:	69bb      	ldr	r3, [r7, #24]
 8022bb2:	181b      	adds	r3, r3, r0
 8022bb4:	603b      	str	r3, [r7, #0]
 8022bb6:	69fb      	ldr	r3, [r7, #28]
 8022bb8:	414b      	adcs	r3, r1
 8022bba:	607b      	str	r3, [r7, #4]
 8022bbc:	e9d7 2300 	ldrd	r2, r3, [r7]
 8022bc0:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
 8022bc4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8022bc6:	66fb      	str	r3, [r7, #108]	@ 0x6c
 8022bc8:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	@ 0x30
 8022bcc:	f04f 0000 	mov.w	r0, #0
 8022bd0:	f04f 0100 	mov.w	r1, #0
 8022bd4:	0018      	movs	r0, r3
 8022bd6:	2100      	movs	r1, #0
 8022bd8:	4602      	mov	r2, r0
 8022bda:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8022bdc:	4413      	add	r3, r2
 8022bde:	66bb      	str	r3, [r7, #104]	@ 0x68
      for (iz = 0; iz < iy; ++iz) {
 8022be0:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8022be2:	3301      	adds	r3, #1
 8022be4:	67bb      	str	r3, [r7, #120]	@ 0x78
 8022be6:	6fba      	ldr	r2, [r7, #120]	@ 0x78
 8022be8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8022bea:	429a      	cmp	r2, r3
 8022bec:	dba7      	blt.n	8022b3e <fp_mul_comba+0xd8>
      }

      /* store term */
      COMBA_STORE(dst->dp[ix]);
 8022bee:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 8022bf0:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8022bf2:	3302      	adds	r3, #2
 8022bf4:	009a      	lsls	r2, r3, #2
 8022bf6:	440a      	add	r2, r1
 8022bf8:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8022bfa:	6053      	str	r3, [r2, #4]
   for (ix = 0; ix < pa; ix++) {
 8022bfc:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8022bfe:	3301      	adds	r3, #1
 8022c00:	67fb      	str	r3, [r7, #124]	@ 0x7c
 8022c02:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 8022c04:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8022c06:	429a      	cmp	r2, r3
 8022c08:	f6ff af64 	blt.w	8022ad4 <fp_mul_comba+0x6e>
  }
  COMBA_FINI;

  dst->used = pa;
 8022c0c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022c0e:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8022c10:	601a      	str	r2, [r3, #0]

  /* warning: WOLFSSL_SP_INT_NEGATIVE may disable negative numbers */
  dst->sign = A->sign ^ B->sign;
 8022c12:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022c14:	685a      	ldr	r2, [r3, #4]
 8022c16:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8022c18:	685b      	ldr	r3, [r3, #4]
 8022c1a:	405a      	eors	r2, r3
 8022c1c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022c1e:	605a      	str	r2, [r3, #4]
  fp_clamp(dst);
 8022c20:	e004      	b.n	8022c2c <fp_mul_comba+0x1c6>
 8022c22:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022c24:	681b      	ldr	r3, [r3, #0]
 8022c26:	1e5a      	subs	r2, r3, #1
 8022c28:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022c2a:	601a      	str	r2, [r3, #0]
 8022c2c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022c2e:	681b      	ldr	r3, [r3, #0]
 8022c30:	2b00      	cmp	r3, #0
 8022c32:	d009      	beq.n	8022c48 <fp_mul_comba+0x1e2>
 8022c34:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022c36:	681b      	ldr	r3, [r3, #0]
 8022c38:	3b01      	subs	r3, #1
 8022c3a:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8022c3c:	3302      	adds	r3, #2
 8022c3e:	009b      	lsls	r3, r3, #2
 8022c40:	4413      	add	r3, r2
 8022c42:	685b      	ldr	r3, [r3, #4]
 8022c44:	2b00      	cmp	r3, #0
 8022c46:	d0ec      	beq.n	8022c22 <fp_mul_comba+0x1bc>
 8022c48:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022c4a:	681b      	ldr	r3, [r3, #0]
 8022c4c:	2b00      	cmp	r3, #0
 8022c4e:	d002      	beq.n	8022c56 <fp_mul_comba+0x1f0>
 8022c50:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022c52:	685b      	ldr	r3, [r3, #4]
 8022c54:	e000      	b.n	8022c58 <fp_mul_comba+0x1f2>
 8022c56:	2300      	movs	r3, #0
 8022c58:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8022c5a:	6053      	str	r3, [r2, #4]
  fp_copy(dst, C);
 8022c5c:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8022c5e:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 8022c60:	f003 ff10 	bl	8026a84 <fp_copy>

  /* Variables used but not seen by cppcheck. */
  (void)c0; (void)c1; (void)c2;

#ifdef WOLFSSL_SMALL_STACK
  XFREE(tmp, NULL, DYNAMIC_TYPE_BIGINT);
 8022c64:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8022c66:	653b      	str	r3, [r7, #80]	@ 0x50
 8022c68:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8022c6a:	2b00      	cmp	r3, #0
 8022c6c:	d002      	beq.n	8022c74 <fp_mul_comba+0x20e>
 8022c6e:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 8022c70:	f7fb ff26 	bl	801eac0 <wolfSSL_Free>
#endif
  return ret;
 8022c74:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
}
 8022c76:	4618      	mov	r0, r3
 8022c78:	3780      	adds	r7, #128	@ 0x80
 8022c7a:	46bd      	mov	sp, r7
 8022c7c:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

08022c80 <fp_div>:

/* a/b => cb + d == a */
int fp_div(fp_int *a, fp_int *b, fp_int *c, fp_int *d)
{
 8022c80:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8022c84:	b09e      	sub	sp, #120	@ 0x78
 8022c86:	af00      	add	r7, sp, #0
 8022c88:	6178      	str	r0, [r7, #20]
 8022c8a:	6139      	str	r1, [r7, #16]
 8022c8c:	60fa      	str	r2, [r7, #12]
 8022c8e:	60bb      	str	r3, [r7, #8]
#else
  fp_int  *q, *x, *y, *t1, *t2;
#endif

  /* is divisor zero ? */
  if (fp_iszero (b) == FP_YES) {
 8022c90:	693b      	ldr	r3, [r7, #16]
 8022c92:	681b      	ldr	r3, [r3, #0]
 8022c94:	2b00      	cmp	r3, #0
 8022c96:	d102      	bne.n	8022c9e <fp_div+0x1e>
    return FP_VAL;
 8022c98:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8022c9c:	e2e0      	b.n	8023260 <fp_div+0x5e0>
  }

  /* if a < b then q=0, r = a */
  if (fp_cmp_mag (a, b) == FP_LT)
 8022c9e:	6939      	ldr	r1, [r7, #16]
 8022ca0:	6978      	ldr	r0, [r7, #20]
 8022ca2:	f002 ff50 	bl	8025b46 <fp_cmp_mag>
 8022ca6:	4603      	mov	r3, r0
 8022ca8:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8022cac:	d10e      	bne.n	8022ccc <fp_div+0x4c>
  {
    if (d != NULL) {
 8022cae:	68bb      	ldr	r3, [r7, #8]
 8022cb0:	2b00      	cmp	r3, #0
 8022cb2:	d003      	beq.n	8022cbc <fp_div+0x3c>
      fp_copy (a, d);
 8022cb4:	68b9      	ldr	r1, [r7, #8]
 8022cb6:	6978      	ldr	r0, [r7, #20]
 8022cb8:	f003 fee4 	bl	8026a84 <fp_copy>
    }
    if (c != NULL) {
 8022cbc:	68fb      	ldr	r3, [r7, #12]
 8022cbe:	2b00      	cmp	r3, #0
 8022cc0:	d002      	beq.n	8022cc8 <fp_div+0x48>
      fp_zero (c);
 8022cc2:	68f8      	ldr	r0, [r7, #12]
 8022cc4:	f003 fd02 	bl	80266cc <fp_zero>
    }
    return FP_OKAY;
 8022cc8:	2300      	movs	r3, #0
 8022cca:	e2c9      	b.n	8023260 <fp_div+0x5e0>
  }

#ifdef WOLFSSL_SMALL_STACK          /* 0  1  2  3   4  */
  /* allocate 5 elements of fp_int for q, x, y, t1, t2 */
  q = (fp_int*)XMALLOC(sizeof(fp_int) * 5, NULL, DYNAMIC_TYPE_BIGINT);
 8022ccc:	f640 20dc 	movw	r0, #2780	@ 0xadc
 8022cd0:	f7fb feda 	bl	801ea88 <wolfSSL_Malloc>
 8022cd4:	66f8      	str	r0, [r7, #108]	@ 0x6c
  if (q == NULL) {
 8022cd6:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8022cd8:	2b00      	cmp	r3, #0
 8022cda:	d102      	bne.n	8022ce2 <fp_div+0x62>
      return FP_MEM;
 8022cdc:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 8022ce0:	e2be      	b.n	8023260 <fp_div+0x5e0>
  }
  x = &q[1]; y = &q[2]; t1 = &q[3]; t2 = &q[4];
 8022ce2:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8022ce4:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8022ce8:	66bb      	str	r3, [r7, #104]	@ 0x68
 8022cea:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8022cec:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 8022cf0:	667b      	str	r3, [r7, #100]	@ 0x64
 8022cf2:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8022cf4:	f203 6384 	addw	r3, r3, #1668	@ 0x684
 8022cf8:	663b      	str	r3, [r7, #96]	@ 0x60
 8022cfa:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8022cfc:	f503 630b 	add.w	r3, r3, #2224	@ 0x8b0
 8022d00:	65fb      	str	r3, [r7, #92]	@ 0x5c
#endif

  fp_init(q);
 8022d02:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 8022d04:	f003 fcd4 	bl	80266b0 <fp_init>
  /* qb + d = a, and b is an integer > 0, therefore q <= a */
  q->used = a->used;
 8022d08:	697b      	ldr	r3, [r7, #20]
 8022d0a:	681a      	ldr	r2, [r3, #0]
 8022d0c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8022d0e:	601a      	str	r2, [r3, #0]

  fp_init(t1);
 8022d10:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 8022d12:	f003 fccd 	bl	80266b0 <fp_init>
  fp_init(t2);
 8022d16:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8022d18:	f003 fcca 	bl	80266b0 <fp_init>
  ** Init a copy (x) of the input (a)
  **
  ** ALERT: Not calling fp_init_copy() as some compiler optimization settings
  ** such as -O2 will complain that (x) or (y) "may be used uninitialized".
  ** The fp_init() is here only to appease the compiler.  */
  fp_init(x);
 8022d1c:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 8022d1e:	f003 fcc7 	bl	80266b0 <fp_init>
  fp_copy(a, x); /* copy (src = a) to (dst = x) */
 8022d22:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 8022d24:	6978      	ldr	r0, [r7, #20]
 8022d26:	f003 fead 	bl	8026a84 <fp_copy>

  fp_init(y);
 8022d2a:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8022d2c:	f003 fcc0 	bl	80266b0 <fp_init>
  fp_copy(b, y); /* copy (src = b) to (dst = y) */
 8022d30:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 8022d32:	6938      	ldr	r0, [r7, #16]
 8022d34:	f003 fea6 	bl	8026a84 <fp_copy>

  /* fix the sign */
  neg = (a->sign == b->sign) ? FP_ZPOS : FP_NEG;
 8022d38:	697b      	ldr	r3, [r7, #20]
 8022d3a:	685a      	ldr	r2, [r3, #4]
 8022d3c:	693b      	ldr	r3, [r7, #16]
 8022d3e:	685b      	ldr	r3, [r3, #4]
 8022d40:	429a      	cmp	r2, r3
 8022d42:	bf14      	ite	ne
 8022d44:	2301      	movne	r3, #1
 8022d46:	2300      	moveq	r3, #0
 8022d48:	b2db      	uxtb	r3, r3
 8022d4a:	65bb      	str	r3, [r7, #88]	@ 0x58
  x->sign = y->sign = FP_ZPOS;
 8022d4c:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8022d4e:	2200      	movs	r2, #0
 8022d50:	605a      	str	r2, [r3, #4]
 8022d52:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8022d54:	685a      	ldr	r2, [r3, #4]
 8022d56:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8022d58:	605a      	str	r2, [r3, #4]

  /* normalize both x and y, ensure that y >= b/2, [b == 2**DIGIT_BIT] */
  norm = fp_count_bits(y) % DIGIT_BIT;
 8022d5a:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8022d5c:	f003 fabc 	bl	80262d8 <fp_count_bits>
 8022d60:	4603      	mov	r3, r0
 8022d62:	425a      	negs	r2, r3
 8022d64:	f003 031f 	and.w	r3, r3, #31
 8022d68:	f002 021f 	and.w	r2, r2, #31
 8022d6c:	bf58      	it	pl
 8022d6e:	4253      	negpl	r3, r2
 8022d70:	673b      	str	r3, [r7, #112]	@ 0x70
  if (norm < (int)(DIGIT_BIT-1)) {
 8022d72:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8022d74:	2b1e      	cmp	r3, #30
 8022d76:	dc29      	bgt.n	8022dcc <fp_div+0x14c>
    norm = (DIGIT_BIT-1) - norm;
 8022d78:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8022d7a:	f1c3 031f 	rsb	r3, r3, #31
 8022d7e:	673b      	str	r3, [r7, #112]	@ 0x70
    ret = fp_mul_2d (x, norm, x);
 8022d80:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8022d82:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 8022d84:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 8022d86:	f7ff fde0 	bl	802294a <fp_mul_2d>
 8022d8a:	6578      	str	r0, [r7, #84]	@ 0x54
    if (ret != FP_OKAY) {
 8022d8c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022d8e:	2b00      	cmp	r3, #0
 8022d90:	d009      	beq.n	8022da6 <fp_div+0x126>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(q, NULL, DYNAMIC_TYPE_BIGINT);
 8022d92:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8022d94:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8022d96:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8022d98:	2b00      	cmp	r3, #0
 8022d9a:	d002      	beq.n	8022da2 <fp_div+0x122>
 8022d9c:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 8022d9e:	f7fb fe8f 	bl	801eac0 <wolfSSL_Free>
    #endif
      return ret;
 8022da2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022da4:	e25c      	b.n	8023260 <fp_div+0x5e0>
    }
    ret = fp_mul_2d (y, norm, y);
 8022da6:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 8022da8:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 8022daa:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8022dac:	f7ff fdcd 	bl	802294a <fp_mul_2d>
 8022db0:	6578      	str	r0, [r7, #84]	@ 0x54
    if (ret != FP_OKAY) {
 8022db2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022db4:	2b00      	cmp	r3, #0
 8022db6:	d00b      	beq.n	8022dd0 <fp_div+0x150>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(q, NULL, DYNAMIC_TYPE_BIGINT);
 8022db8:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8022dba:	653b      	str	r3, [r7, #80]	@ 0x50
 8022dbc:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8022dbe:	2b00      	cmp	r3, #0
 8022dc0:	d002      	beq.n	8022dc8 <fp_div+0x148>
 8022dc2:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 8022dc4:	f7fb fe7c 	bl	801eac0 <wolfSSL_Free>
    #endif
      return ret;
 8022dc8:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022dca:	e249      	b.n	8023260 <fp_div+0x5e0>
    }
  } else {
    norm = 0;
 8022dcc:	2300      	movs	r3, #0
 8022dce:	673b      	str	r3, [r7, #112]	@ 0x70
  }

  /* note hac does 0 based, so if used==5 then its 0,1,2,3,4, e.g. use 4 */
  n = x->used - 1;
 8022dd0:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8022dd2:	681b      	ldr	r3, [r3, #0]
 8022dd4:	3b01      	subs	r3, #1
 8022dd6:	64bb      	str	r3, [r7, #72]	@ 0x48
  t = y->used - 1;
 8022dd8:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8022dda:	681b      	ldr	r3, [r3, #0]
 8022ddc:	3b01      	subs	r3, #1
 8022dde:	647b      	str	r3, [r7, #68]	@ 0x44

  /* while (x >= y*b**n-t) do { q[n-t] += 1; x -= y*b**{n-t} } */
  ret = fp_lshd (y, n - t); /* y = y*b**{n-t} */
 8022de0:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8022de2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8022de4:	1ad3      	subs	r3, r2, r3
 8022de6:	4619      	mov	r1, r3
 8022de8:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8022dea:	f003 fad1 	bl	8026390 <fp_lshd>
 8022dee:	6578      	str	r0, [r7, #84]	@ 0x54
  if (ret != FP_OKAY) {
 8022df0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022df2:	2b00      	cmp	r3, #0
 8022df4:	d02a      	beq.n	8022e4c <fp_div+0x1cc>
  #ifdef WOLFSSL_SMALL_STACK
    XFREE(q, NULL, DYNAMIC_TYPE_BIGINT);
 8022df6:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8022df8:	61bb      	str	r3, [r7, #24]
 8022dfa:	69bb      	ldr	r3, [r7, #24]
 8022dfc:	2b00      	cmp	r3, #0
 8022dfe:	d002      	beq.n	8022e06 <fp_div+0x186>
 8022e00:	69b8      	ldr	r0, [r7, #24]
 8022e02:	f7fb fe5d 	bl	801eac0 <wolfSSL_Free>
  #endif
    return ret;
 8022e06:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022e08:	e22a      	b.n	8023260 <fp_div+0x5e0>
  }

  while (fp_cmp (x, y) != FP_LT) {
    ++(q->dp[n - t]);
 8022e0a:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8022e0c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8022e0e:	1ad2      	subs	r2, r2, r3
 8022e10:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 8022e12:	1c93      	adds	r3, r2, #2
 8022e14:	009b      	lsls	r3, r3, #2
 8022e16:	440b      	add	r3, r1
 8022e18:	685b      	ldr	r3, [r3, #4]
 8022e1a:	1c59      	adds	r1, r3, #1
 8022e1c:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 8022e1e:	1c93      	adds	r3, r2, #2
 8022e20:	009b      	lsls	r3, r3, #2
 8022e22:	4403      	add	r3, r0
 8022e24:	6059      	str	r1, [r3, #4]
    ret = fp_sub (x, y, x);
 8022e26:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8022e28:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 8022e2a:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 8022e2c:	f7ff fb33 	bl	8022496 <fp_sub>
 8022e30:	6578      	str	r0, [r7, #84]	@ 0x54
    if (ret != FP_OKAY) {
 8022e32:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022e34:	2b00      	cmp	r3, #0
 8022e36:	d009      	beq.n	8022e4c <fp_div+0x1cc>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(q, NULL, DYNAMIC_TYPE_BIGINT);
 8022e38:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8022e3a:	61fb      	str	r3, [r7, #28]
 8022e3c:	69fb      	ldr	r3, [r7, #28]
 8022e3e:	2b00      	cmp	r3, #0
 8022e40:	d002      	beq.n	8022e48 <fp_div+0x1c8>
 8022e42:	69f8      	ldr	r0, [r7, #28]
 8022e44:	f7fb fe3c 	bl	801eac0 <wolfSSL_Free>
    #endif
      return ret;
 8022e48:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022e4a:	e209      	b.n	8023260 <fp_div+0x5e0>
  while (fp_cmp (x, y) != FP_LT) {
 8022e4c:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 8022e4e:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 8022e50:	f002 fe14 	bl	8025a7c <fp_cmp>
 8022e54:	4603      	mov	r3, r0
 8022e56:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8022e5a:	d1d6      	bne.n	8022e0a <fp_div+0x18a>
    }
  }

  /* reset y by shifting it back down */
  fp_rshd (y, n - t);
 8022e5c:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8022e5e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8022e60:	1ad3      	subs	r3, r2, r3
 8022e62:	4619      	mov	r1, r3
 8022e64:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8022e66:	f003 fb78 	bl	802655a <fp_rshd>

  /* step 3. for i from n down to (t + 1) */
  for (i = n; i >= (t + 1); i--) {
 8022e6a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8022e6c:	677b      	str	r3, [r7, #116]	@ 0x74
 8022e6e:	e179      	b.n	8023164 <fp_div+0x4e4>
    if (i > x->used) {
 8022e70:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8022e72:	681b      	ldr	r3, [r3, #0]
 8022e74:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8022e76:	429a      	cmp	r2, r3
 8022e78:	f300 8170 	bgt.w	802315c <fp_div+0x4dc>
      continue;
    }

    /* step 3.1 if xi == yt then set q{i-t-1} to b-1,
     * otherwise set q{i-t-1} to (xi*b + x{i-1})/yt */
    if (x->dp[i] == y->dp[t]) {
 8022e7c:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8022e7e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8022e80:	3302      	adds	r3, #2
 8022e82:	009b      	lsls	r3, r3, #2
 8022e84:	4413      	add	r3, r2
 8022e86:	685a      	ldr	r2, [r3, #4]
 8022e88:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 8022e8a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8022e8c:	3302      	adds	r3, #2
 8022e8e:	009b      	lsls	r3, r3, #2
 8022e90:	440b      	add	r3, r1
 8022e92:	685b      	ldr	r3, [r3, #4]
 8022e94:	429a      	cmp	r2, r3
 8022e96:	d10b      	bne.n	8022eb0 <fp_div+0x230>
      q->dp[i - t - 1] = (fp_digit) ((((fp_word)1) << DIGIT_BIT) - 1);
 8022e98:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8022e9a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8022e9c:	1ad3      	subs	r3, r2, r3
 8022e9e:	3b01      	subs	r3, #1
 8022ea0:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8022ea2:	3302      	adds	r3, #2
 8022ea4:	009b      	lsls	r3, r3, #2
 8022ea6:	4413      	add	r3, r2
 8022ea8:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8022eac:	605a      	str	r2, [r3, #4]
 8022eae:	e03f      	b.n	8022f30 <fp_div+0x2b0>
    } else {
      fp_word tmp;
      tmp = ((fp_word) x->dp[i]) << ((fp_word) DIGIT_BIT);
 8022eb0:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8022eb2:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8022eb4:	3302      	adds	r3, #2
 8022eb6:	009b      	lsls	r3, r3, #2
 8022eb8:	4413      	add	r3, r2
 8022eba:	685b      	ldr	r3, [r3, #4]
 8022ebc:	2200      	movs	r2, #0
 8022ebe:	469a      	mov	sl, r3
 8022ec0:	4693      	mov	fp, r2
 8022ec2:	f04f 0200 	mov.w	r2, #0
 8022ec6:	f04f 0300 	mov.w	r3, #0
 8022eca:	4653      	mov	r3, sl
 8022ecc:	2200      	movs	r2, #0
 8022ece:	e9c7 230e 	strd	r2, r3, [r7, #56]	@ 0x38
      tmp |= ((fp_word) x->dp[i - 1]);
 8022ed2:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8022ed4:	3b01      	subs	r3, #1
 8022ed6:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8022ed8:	3302      	adds	r3, #2
 8022eda:	009b      	lsls	r3, r3, #2
 8022edc:	4413      	add	r3, r2
 8022ede:	685b      	ldr	r3, [r3, #4]
 8022ee0:	2200      	movs	r2, #0
 8022ee2:	461c      	mov	r4, r3
 8022ee4:	4615      	mov	r5, r2
 8022ee6:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	@ 0x38
 8022eea:	ea42 0804 	orr.w	r8, r2, r4
 8022eee:	ea43 0905 	orr.w	r9, r3, r5
 8022ef2:	e9c7 890e 	strd	r8, r9, [r7, #56]	@ 0x38
#ifdef WOLFSSL_LINUXKM
      /* Linux kernel macro for in-place 64 bit integer division. */
      do_div(tmp, (fp_word)y->dp[t]);
#else
      tmp /= ((fp_word)y->dp[t]);
 8022ef6:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 8022ef8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8022efa:	3302      	adds	r3, #2
 8022efc:	009b      	lsls	r3, r3, #2
 8022efe:	4413      	add	r3, r2
 8022f00:	685b      	ldr	r3, [r3, #4]
 8022f02:	2200      	movs	r2, #0
 8022f04:	603b      	str	r3, [r7, #0]
 8022f06:	607a      	str	r2, [r7, #4]
 8022f08:	e9d7 2300 	ldrd	r2, r3, [r7]
 8022f0c:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	@ 0x38
 8022f10:	f7dd f9c6 	bl	80002a0 <__aeabi_uldivmod>
 8022f14:	4602      	mov	r2, r0
 8022f16:	460b      	mov	r3, r1
 8022f18:	e9c7 230e 	strd	r2, r3, [r7, #56]	@ 0x38
#endif
      q->dp[i - t - 1] = (fp_digit) (tmp);
 8022f1c:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8022f1e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8022f20:	1ad3      	subs	r3, r2, r3
 8022f22:	3b01      	subs	r3, #1
 8022f24:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8022f26:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 8022f28:	3302      	adds	r3, #2
 8022f2a:	009b      	lsls	r3, r3, #2
 8022f2c:	440b      	add	r3, r1
 8022f2e:	605a      	str	r2, [r3, #4]
    /* while (q{i-t-1} * (yt * b + y{t-1})) >
             xi * b**2 + xi-1 * b + xi-2

       do q{i-t-1} -= 1;
    */
    q->dp[i - t - 1] = (q->dp[i - t - 1] + 1);
 8022f30:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8022f32:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8022f34:	1ad3      	subs	r3, r2, r3
 8022f36:	3b01      	subs	r3, #1
 8022f38:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8022f3a:	3302      	adds	r3, #2
 8022f3c:	009b      	lsls	r3, r3, #2
 8022f3e:	4413      	add	r3, r2
 8022f40:	685a      	ldr	r2, [r3, #4]
 8022f42:	6f79      	ldr	r1, [r7, #116]	@ 0x74
 8022f44:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8022f46:	1acb      	subs	r3, r1, r3
 8022f48:	3b01      	subs	r3, #1
 8022f4a:	3201      	adds	r2, #1
 8022f4c:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 8022f4e:	3302      	adds	r3, #2
 8022f50:	009b      	lsls	r3, r3, #2
 8022f52:	440b      	add	r3, r1
 8022f54:	605a      	str	r2, [r3, #4]
    do {
      q->dp[i - t - 1] = (q->dp[i - t - 1] - 1);
 8022f56:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8022f58:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8022f5a:	1ad3      	subs	r3, r2, r3
 8022f5c:	3b01      	subs	r3, #1
 8022f5e:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8022f60:	3302      	adds	r3, #2
 8022f62:	009b      	lsls	r3, r3, #2
 8022f64:	4413      	add	r3, r2
 8022f66:	685a      	ldr	r2, [r3, #4]
 8022f68:	6f79      	ldr	r1, [r7, #116]	@ 0x74
 8022f6a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8022f6c:	1acb      	subs	r3, r1, r3
 8022f6e:	3b01      	subs	r3, #1
 8022f70:	3a01      	subs	r2, #1
 8022f72:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 8022f74:	3302      	adds	r3, #2
 8022f76:	009b      	lsls	r3, r3, #2
 8022f78:	440b      	add	r3, r1
 8022f7a:	605a      	str	r2, [r3, #4]

      /* find left hand */
      fp_zero (t1);
 8022f7c:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 8022f7e:	f003 fba5 	bl	80266cc <fp_zero>
      t1->dp[0] = (t - 1 < 0) ? 0 : y->dp[t - 1];
 8022f82:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8022f84:	2b00      	cmp	r3, #0
 8022f86:	dd07      	ble.n	8022f98 <fp_div+0x318>
 8022f88:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8022f8a:	3b01      	subs	r3, #1
 8022f8c:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 8022f8e:	3302      	adds	r3, #2
 8022f90:	009b      	lsls	r3, r3, #2
 8022f92:	4413      	add	r3, r2
 8022f94:	685b      	ldr	r3, [r3, #4]
 8022f96:	e000      	b.n	8022f9a <fp_div+0x31a>
 8022f98:	2300      	movs	r3, #0
 8022f9a:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8022f9c:	60d3      	str	r3, [r2, #12]
      t1->dp[1] = y->dp[t];
 8022f9e:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 8022fa0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8022fa2:	3302      	adds	r3, #2
 8022fa4:	009b      	lsls	r3, r3, #2
 8022fa6:	4413      	add	r3, r2
 8022fa8:	685a      	ldr	r2, [r3, #4]
 8022faa:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8022fac:	611a      	str	r2, [r3, #16]
      t1->used = 2;
 8022fae:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8022fb0:	2202      	movs	r2, #2
 8022fb2:	601a      	str	r2, [r3, #0]
      ret = fp_mul_d (t1, q->dp[i - t - 1], t1);
 8022fb4:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8022fb6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8022fb8:	1ad3      	subs	r3, r2, r3
 8022fba:	3b01      	subs	r3, #1
 8022fbc:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8022fbe:	3302      	adds	r3, #2
 8022fc0:	009b      	lsls	r3, r3, #2
 8022fc2:	4413      	add	r3, r2
 8022fc4:	685b      	ldr	r3, [r3, #4]
 8022fc6:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8022fc8:	4619      	mov	r1, r3
 8022fca:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 8022fcc:	f7ff fc19 	bl	8022802 <fp_mul_d>
 8022fd0:	6578      	str	r0, [r7, #84]	@ 0x54
      if (ret != FP_OKAY) {
 8022fd2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022fd4:	2b00      	cmp	r3, #0
 8022fd6:	d009      	beq.n	8022fec <fp_div+0x36c>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(q, NULL, DYNAMIC_TYPE_BIGINT);
 8022fd8:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8022fda:	623b      	str	r3, [r7, #32]
 8022fdc:	6a3b      	ldr	r3, [r7, #32]
 8022fde:	2b00      	cmp	r3, #0
 8022fe0:	d002      	beq.n	8022fe8 <fp_div+0x368>
 8022fe2:	6a38      	ldr	r0, [r7, #32]
 8022fe4:	f7fb fd6c 	bl	801eac0 <wolfSSL_Free>
      #endif
        return ret;
 8022fe8:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022fea:	e139      	b.n	8023260 <fp_div+0x5e0>
      }

      /* find right hand */
      t2->dp[0] = (i - 2 < 0) ? 0 : x->dp[i - 2];
 8022fec:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8022fee:	2b01      	cmp	r3, #1
 8022ff0:	dd07      	ble.n	8023002 <fp_div+0x382>
 8022ff2:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8022ff4:	3b02      	subs	r3, #2
 8022ff6:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8022ff8:	3302      	adds	r3, #2
 8022ffa:	009b      	lsls	r3, r3, #2
 8022ffc:	4413      	add	r3, r2
 8022ffe:	685b      	ldr	r3, [r3, #4]
 8023000:	e000      	b.n	8023004 <fp_div+0x384>
 8023002:	2300      	movs	r3, #0
 8023004:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8023006:	60d3      	str	r3, [r2, #12]
      t2->dp[1] = (i - 1 < 0) ? 0 : x->dp[i - 1];
 8023008:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 802300a:	2b00      	cmp	r3, #0
 802300c:	dd07      	ble.n	802301e <fp_div+0x39e>
 802300e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023010:	3b01      	subs	r3, #1
 8023012:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8023014:	3302      	adds	r3, #2
 8023016:	009b      	lsls	r3, r3, #2
 8023018:	4413      	add	r3, r2
 802301a:	685b      	ldr	r3, [r3, #4]
 802301c:	e000      	b.n	8023020 <fp_div+0x3a0>
 802301e:	2300      	movs	r3, #0
 8023020:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8023022:	6113      	str	r3, [r2, #16]
      t2->dp[2] = x->dp[i];
 8023024:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8023026:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023028:	3302      	adds	r3, #2
 802302a:	009b      	lsls	r3, r3, #2
 802302c:	4413      	add	r3, r2
 802302e:	685a      	ldr	r2, [r3, #4]
 8023030:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023032:	615a      	str	r2, [r3, #20]
      t2->used = 3;
 8023034:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023036:	2203      	movs	r2, #3
 8023038:	601a      	str	r2, [r3, #0]
    } while (fp_cmp_mag(t1, t2) == FP_GT);
 802303a:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 802303c:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 802303e:	f002 fd82 	bl	8025b46 <fp_cmp_mag>
 8023042:	4603      	mov	r3, r0
 8023044:	2b01      	cmp	r3, #1
 8023046:	d086      	beq.n	8022f56 <fp_div+0x2d6>

    /* step 3.3 x = x - q{i-t-1} * y * b**{i-t-1} */
    ret = fp_mul_d (y, q->dp[i - t - 1], t1);
 8023048:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 802304a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802304c:	1ad3      	subs	r3, r2, r3
 802304e:	3b01      	subs	r3, #1
 8023050:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8023052:	3302      	adds	r3, #2
 8023054:	009b      	lsls	r3, r3, #2
 8023056:	4413      	add	r3, r2
 8023058:	685b      	ldr	r3, [r3, #4]
 802305a:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 802305c:	4619      	mov	r1, r3
 802305e:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8023060:	f7ff fbcf 	bl	8022802 <fp_mul_d>
 8023064:	6578      	str	r0, [r7, #84]	@ 0x54
    if (ret != FP_OKAY) {
 8023066:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023068:	2b00      	cmp	r3, #0
 802306a:	d009      	beq.n	8023080 <fp_div+0x400>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(q, NULL, DYNAMIC_TYPE_BIGINT);
 802306c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 802306e:	627b      	str	r3, [r7, #36]	@ 0x24
 8023070:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8023072:	2b00      	cmp	r3, #0
 8023074:	d002      	beq.n	802307c <fp_div+0x3fc>
 8023076:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8023078:	f7fb fd22 	bl	801eac0 <wolfSSL_Free>
    #endif
      return ret;
 802307c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802307e:	e0ef      	b.n	8023260 <fp_div+0x5e0>
    }
    ret = fp_lshd  (t1, i - t - 1);
 8023080:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8023082:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023084:	1ad3      	subs	r3, r2, r3
 8023086:	3b01      	subs	r3, #1
 8023088:	4619      	mov	r1, r3
 802308a:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 802308c:	f003 f980 	bl	8026390 <fp_lshd>
 8023090:	6578      	str	r0, [r7, #84]	@ 0x54
    if (ret != FP_OKAY) {
 8023092:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023094:	2b00      	cmp	r3, #0
 8023096:	d009      	beq.n	80230ac <fp_div+0x42c>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(q, NULL, DYNAMIC_TYPE_BIGINT);
 8023098:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 802309a:	62bb      	str	r3, [r7, #40]	@ 0x28
 802309c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802309e:	2b00      	cmp	r3, #0
 80230a0:	d002      	beq.n	80230a8 <fp_div+0x428>
 80230a2:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 80230a4:	f7fb fd0c 	bl	801eac0 <wolfSSL_Free>
    #endif
      return ret;
 80230a8:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80230aa:	e0d9      	b.n	8023260 <fp_div+0x5e0>
    }
    ret = fp_sub   (x, t1, x);
 80230ac:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 80230ae:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 80230b0:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 80230b2:	f7ff f9f0 	bl	8022496 <fp_sub>
 80230b6:	6578      	str	r0, [r7, #84]	@ 0x54
    if (ret != FP_OKAY) {
 80230b8:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80230ba:	2b00      	cmp	r3, #0
 80230bc:	d009      	beq.n	80230d2 <fp_div+0x452>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(q, NULL, DYNAMIC_TYPE_BIGINT);
 80230be:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80230c0:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80230c2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80230c4:	2b00      	cmp	r3, #0
 80230c6:	d002      	beq.n	80230ce <fp_div+0x44e>
 80230c8:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 80230ca:	f7fb fcf9 	bl	801eac0 <wolfSSL_Free>
    #endif
      return ret;
 80230ce:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80230d0:	e0c6      	b.n	8023260 <fp_div+0x5e0>
    }

    /* if x < 0 then { x = x + y*b**{i-t-1}; q{i-t-1} -= 1; } */
    if (x->sign == FP_NEG) {
 80230d2:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80230d4:	685b      	ldr	r3, [r3, #4]
 80230d6:	2b01      	cmp	r3, #1
 80230d8:	d141      	bne.n	802315e <fp_div+0x4de>
      fp_copy (y, t1);
 80230da:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 80230dc:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 80230de:	f003 fcd1 	bl	8026a84 <fp_copy>
      ret = fp_lshd (t1, i - t - 1);
 80230e2:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 80230e4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80230e6:	1ad3      	subs	r3, r2, r3
 80230e8:	3b01      	subs	r3, #1
 80230ea:	4619      	mov	r1, r3
 80230ec:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 80230ee:	f003 f94f 	bl	8026390 <fp_lshd>
 80230f2:	6578      	str	r0, [r7, #84]	@ 0x54
      if (ret != FP_OKAY) {
 80230f4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80230f6:	2b00      	cmp	r3, #0
 80230f8:	d009      	beq.n	802310e <fp_div+0x48e>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(q, NULL, DYNAMIC_TYPE_BIGINT);
 80230fa:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80230fc:	633b      	str	r3, [r7, #48]	@ 0x30
 80230fe:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8023100:	2b00      	cmp	r3, #0
 8023102:	d002      	beq.n	802310a <fp_div+0x48a>
 8023104:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 8023106:	f7fb fcdb 	bl	801eac0 <wolfSSL_Free>
      #endif
        return ret;
 802310a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802310c:	e0a8      	b.n	8023260 <fp_div+0x5e0>
      }
      ret = fp_add (x, t1, x);
 802310e:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8023110:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 8023112:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 8023114:	f7ff f8dd 	bl	80222d2 <fp_add>
 8023118:	6578      	str	r0, [r7, #84]	@ 0x54
      if (ret != FP_OKAY) {
 802311a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802311c:	2b00      	cmp	r3, #0
 802311e:	d009      	beq.n	8023134 <fp_div+0x4b4>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(q, NULL, DYNAMIC_TYPE_BIGINT);
 8023120:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8023122:	637b      	str	r3, [r7, #52]	@ 0x34
 8023124:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8023126:	2b00      	cmp	r3, #0
 8023128:	d002      	beq.n	8023130 <fp_div+0x4b0>
 802312a:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 802312c:	f7fb fcc8 	bl	801eac0 <wolfSSL_Free>
      #endif
        return ret;
 8023130:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023132:	e095      	b.n	8023260 <fp_div+0x5e0>
      }
      q->dp[i - t - 1] = q->dp[i - t - 1] - 1;
 8023134:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8023136:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023138:	1ad3      	subs	r3, r2, r3
 802313a:	3b01      	subs	r3, #1
 802313c:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 802313e:	3302      	adds	r3, #2
 8023140:	009b      	lsls	r3, r3, #2
 8023142:	4413      	add	r3, r2
 8023144:	685a      	ldr	r2, [r3, #4]
 8023146:	6f79      	ldr	r1, [r7, #116]	@ 0x74
 8023148:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802314a:	1acb      	subs	r3, r1, r3
 802314c:	3b01      	subs	r3, #1
 802314e:	3a01      	subs	r2, #1
 8023150:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 8023152:	3302      	adds	r3, #2
 8023154:	009b      	lsls	r3, r3, #2
 8023156:	440b      	add	r3, r1
 8023158:	605a      	str	r2, [r3, #4]
 802315a:	e000      	b.n	802315e <fp_div+0x4de>
      continue;
 802315c:	bf00      	nop
  for (i = n; i >= (t + 1); i--) {
 802315e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023160:	3b01      	subs	r3, #1
 8023162:	677b      	str	r3, [r7, #116]	@ 0x74
 8023164:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8023166:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023168:	429a      	cmp	r2, r3
 802316a:	f6ff ae81 	blt.w	8022e70 <fp_div+0x1f0>
  /* now q is the quotient and x is the remainder
   * [which we have to normalize]
   */

  /* get sign before writing to c */
  x->sign = x->used == 0 ? FP_ZPOS : a->sign;
 802316e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8023170:	681b      	ldr	r3, [r3, #0]
 8023172:	2b00      	cmp	r3, #0
 8023174:	d002      	beq.n	802317c <fp_div+0x4fc>
 8023176:	697b      	ldr	r3, [r7, #20]
 8023178:	685b      	ldr	r3, [r3, #4]
 802317a:	e000      	b.n	802317e <fp_div+0x4fe>
 802317c:	2300      	movs	r3, #0
 802317e:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8023180:	6053      	str	r3, [r2, #4]

  if (c != NULL) {
 8023182:	68fb      	ldr	r3, [r7, #12]
 8023184:	2b00      	cmp	r3, #0
 8023186:	d024      	beq.n	80231d2 <fp_div+0x552>
    fp_clamp (q);
 8023188:	e004      	b.n	8023194 <fp_div+0x514>
 802318a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 802318c:	681b      	ldr	r3, [r3, #0]
 802318e:	1e5a      	subs	r2, r3, #1
 8023190:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8023192:	601a      	str	r2, [r3, #0]
 8023194:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8023196:	681b      	ldr	r3, [r3, #0]
 8023198:	2b00      	cmp	r3, #0
 802319a:	d009      	beq.n	80231b0 <fp_div+0x530>
 802319c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 802319e:	681b      	ldr	r3, [r3, #0]
 80231a0:	3b01      	subs	r3, #1
 80231a2:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 80231a4:	3302      	adds	r3, #2
 80231a6:	009b      	lsls	r3, r3, #2
 80231a8:	4413      	add	r3, r2
 80231aa:	685b      	ldr	r3, [r3, #4]
 80231ac:	2b00      	cmp	r3, #0
 80231ae:	d0ec      	beq.n	802318a <fp_div+0x50a>
 80231b0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80231b2:	681b      	ldr	r3, [r3, #0]
 80231b4:	2b00      	cmp	r3, #0
 80231b6:	d002      	beq.n	80231be <fp_div+0x53e>
 80231b8:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80231ba:	685b      	ldr	r3, [r3, #4]
 80231bc:	e000      	b.n	80231c0 <fp_div+0x540>
 80231be:	2300      	movs	r3, #0
 80231c0:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 80231c2:	6053      	str	r3, [r2, #4]
    fp_copy (q, c);
 80231c4:	68f9      	ldr	r1, [r7, #12]
 80231c6:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 80231c8:	f003 fc5c 	bl	8026a84 <fp_copy>
    c->sign = neg;
 80231cc:	68fb      	ldr	r3, [r7, #12]
 80231ce:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 80231d0:	605a      	str	r2, [r3, #4]
  }

  if (d != NULL) {
 80231d2:	68bb      	ldr	r3, [r7, #8]
 80231d4:	2b00      	cmp	r3, #0
 80231d6:	d03a      	beq.n	802324e <fp_div+0x5ce>
    fp_div_2d (x, norm, x, NULL);
 80231d8:	2300      	movs	r3, #0
 80231da:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 80231dc:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 80231de:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 80231e0:	f000 f986 	bl	80234f0 <fp_div_2d>

    /* zero any excess digits on the destination that we didn't write to */
    for (i = b->used; i < x->used; i++) {
 80231e4:	693b      	ldr	r3, [r7, #16]
 80231e6:	681b      	ldr	r3, [r3, #0]
 80231e8:	677b      	str	r3, [r7, #116]	@ 0x74
 80231ea:	e009      	b.n	8023200 <fp_div+0x580>
        x->dp[i] = 0;
 80231ec:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 80231ee:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80231f0:	3302      	adds	r3, #2
 80231f2:	009b      	lsls	r3, r3, #2
 80231f4:	4413      	add	r3, r2
 80231f6:	2200      	movs	r2, #0
 80231f8:	605a      	str	r2, [r3, #4]
    for (i = b->used; i < x->used; i++) {
 80231fa:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80231fc:	3301      	adds	r3, #1
 80231fe:	677b      	str	r3, [r7, #116]	@ 0x74
 8023200:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8023202:	681b      	ldr	r3, [r3, #0]
 8023204:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8023206:	429a      	cmp	r2, r3
 8023208:	dbf0      	blt.n	80231ec <fp_div+0x56c>
    }
    fp_clamp(x);
 802320a:	e004      	b.n	8023216 <fp_div+0x596>
 802320c:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 802320e:	681b      	ldr	r3, [r3, #0]
 8023210:	1e5a      	subs	r2, r3, #1
 8023212:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8023214:	601a      	str	r2, [r3, #0]
 8023216:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8023218:	681b      	ldr	r3, [r3, #0]
 802321a:	2b00      	cmp	r3, #0
 802321c:	d009      	beq.n	8023232 <fp_div+0x5b2>
 802321e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8023220:	681b      	ldr	r3, [r3, #0]
 8023222:	3b01      	subs	r3, #1
 8023224:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8023226:	3302      	adds	r3, #2
 8023228:	009b      	lsls	r3, r3, #2
 802322a:	4413      	add	r3, r2
 802322c:	685b      	ldr	r3, [r3, #4]
 802322e:	2b00      	cmp	r3, #0
 8023230:	d0ec      	beq.n	802320c <fp_div+0x58c>
 8023232:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8023234:	681b      	ldr	r3, [r3, #0]
 8023236:	2b00      	cmp	r3, #0
 8023238:	d002      	beq.n	8023240 <fp_div+0x5c0>
 802323a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 802323c:	685b      	ldr	r3, [r3, #4]
 802323e:	e000      	b.n	8023242 <fp_div+0x5c2>
 8023240:	2300      	movs	r3, #0
 8023242:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8023244:	6053      	str	r3, [r2, #4]
    fp_copy (x, d);
 8023246:	68b9      	ldr	r1, [r7, #8]
 8023248:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 802324a:	f003 fc1b 	bl	8026a84 <fp_copy>
  }

#ifdef WOLFSSL_SMALL_STACK
  XFREE(q, NULL, DYNAMIC_TYPE_BIGINT);
 802324e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8023250:	643b      	str	r3, [r7, #64]	@ 0x40
 8023252:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8023254:	2b00      	cmp	r3, #0
 8023256:	d002      	beq.n	802325e <fp_div+0x5de>
 8023258:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 802325a:	f7fb fc31 	bl	801eac0 <wolfSSL_Free>
#endif
  return FP_OKAY;
 802325e:	2300      	movs	r3, #0
}
 8023260:	4618      	mov	r0, r3
 8023262:	3778      	adds	r7, #120	@ 0x78
 8023264:	46bd      	mov	sp, r7
 8023266:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

0802326a <fp_div_2>:

/* b = a/2 */
void fp_div_2(fp_int * a, fp_int * b)
{
 802326a:	b480      	push	{r7}
 802326c:	b089      	sub	sp, #36	@ 0x24
 802326e:	af00      	add	r7, sp, #0
 8023270:	6078      	str	r0, [r7, #4]
 8023272:	6039      	str	r1, [r7, #0]
  int     x, oldused;

  oldused = b->used;
 8023274:	683b      	ldr	r3, [r7, #0]
 8023276:	681b      	ldr	r3, [r3, #0]
 8023278:	60fb      	str	r3, [r7, #12]
  b->used = a->used;
 802327a:	687b      	ldr	r3, [r7, #4]
 802327c:	681a      	ldr	r2, [r3, #0]
 802327e:	683b      	ldr	r3, [r7, #0]
 8023280:	601a      	str	r2, [r3, #0]
  {
    fp_digit r, rr, *tmpa, *tmpb;

    /* source alias */
    tmpa = a->dp + b->used - 1;
 8023282:	687b      	ldr	r3, [r7, #4]
 8023284:	f103 020c 	add.w	r2, r3, #12
 8023288:	683b      	ldr	r3, [r7, #0]
 802328a:	681b      	ldr	r3, [r3, #0]
 802328c:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 8023290:	3b01      	subs	r3, #1
 8023292:	009b      	lsls	r3, r3, #2
 8023294:	4413      	add	r3, r2
 8023296:	617b      	str	r3, [r7, #20]

    /* dest alias */
    tmpb = b->dp + b->used - 1;
 8023298:	683b      	ldr	r3, [r7, #0]
 802329a:	f103 020c 	add.w	r2, r3, #12
 802329e:	683b      	ldr	r3, [r7, #0]
 80232a0:	681b      	ldr	r3, [r3, #0]
 80232a2:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 80232a6:	3b01      	subs	r3, #1
 80232a8:	009b      	lsls	r3, r3, #2
 80232aa:	4413      	add	r3, r2
 80232ac:	613b      	str	r3, [r7, #16]

    /* carry */
    r = 0;
 80232ae:	2300      	movs	r3, #0
 80232b0:	61bb      	str	r3, [r7, #24]
    for (x = b->used - 1; x >= 0; x--) {
 80232b2:	683b      	ldr	r3, [r7, #0]
 80232b4:	681b      	ldr	r3, [r3, #0]
 80232b6:	3b01      	subs	r3, #1
 80232b8:	61fb      	str	r3, [r7, #28]
 80232ba:	e015      	b.n	80232e8 <fp_div_2+0x7e>
      /* get the carry for the next iteration */
      rr = *tmpa & 1;
 80232bc:	697b      	ldr	r3, [r7, #20]
 80232be:	681b      	ldr	r3, [r3, #0]
 80232c0:	f003 0301 	and.w	r3, r3, #1
 80232c4:	60bb      	str	r3, [r7, #8]

      /* shift the current digit, add in carry and store */
      *tmpb-- = (*tmpa-- >> 1) | (r << (DIGIT_BIT - 1));
 80232c6:	697b      	ldr	r3, [r7, #20]
 80232c8:	1f1a      	subs	r2, r3, #4
 80232ca:	617a      	str	r2, [r7, #20]
 80232cc:	681b      	ldr	r3, [r3, #0]
 80232ce:	0859      	lsrs	r1, r3, #1
 80232d0:	69bb      	ldr	r3, [r7, #24]
 80232d2:	07da      	lsls	r2, r3, #31
 80232d4:	693b      	ldr	r3, [r7, #16]
 80232d6:	1f18      	subs	r0, r3, #4
 80232d8:	6138      	str	r0, [r7, #16]
 80232da:	430a      	orrs	r2, r1
 80232dc:	601a      	str	r2, [r3, #0]

      /* forward carry to next iteration */
      r = rr;
 80232de:	68bb      	ldr	r3, [r7, #8]
 80232e0:	61bb      	str	r3, [r7, #24]
    for (x = b->used - 1; x >= 0; x--) {
 80232e2:	69fb      	ldr	r3, [r7, #28]
 80232e4:	3b01      	subs	r3, #1
 80232e6:	61fb      	str	r3, [r7, #28]
 80232e8:	69fb      	ldr	r3, [r7, #28]
 80232ea:	2b00      	cmp	r3, #0
 80232ec:	dae6      	bge.n	80232bc <fp_div_2+0x52>
    }

    /* zero any excess digits on the destination that we didn't write to */
    tmpb = b->dp + b->used;
 80232ee:	683b      	ldr	r3, [r7, #0]
 80232f0:	f103 020c 	add.w	r2, r3, #12
 80232f4:	683b      	ldr	r3, [r7, #0]
 80232f6:	681b      	ldr	r3, [r3, #0]
 80232f8:	009b      	lsls	r3, r3, #2
 80232fa:	4413      	add	r3, r2
 80232fc:	613b      	str	r3, [r7, #16]
    for (x = b->used; x < oldused; x++) {
 80232fe:	683b      	ldr	r3, [r7, #0]
 8023300:	681b      	ldr	r3, [r3, #0]
 8023302:	61fb      	str	r3, [r7, #28]
 8023304:	e007      	b.n	8023316 <fp_div_2+0xac>
      *tmpb++ = 0;
 8023306:	693b      	ldr	r3, [r7, #16]
 8023308:	1d1a      	adds	r2, r3, #4
 802330a:	613a      	str	r2, [r7, #16]
 802330c:	2200      	movs	r2, #0
 802330e:	601a      	str	r2, [r3, #0]
    for (x = b->used; x < oldused; x++) {
 8023310:	69fb      	ldr	r3, [r7, #28]
 8023312:	3301      	adds	r3, #1
 8023314:	61fb      	str	r3, [r7, #28]
 8023316:	69fa      	ldr	r2, [r7, #28]
 8023318:	68fb      	ldr	r3, [r7, #12]
 802331a:	429a      	cmp	r2, r3
 802331c:	dbf3      	blt.n	8023306 <fp_div_2+0x9c>
    }
  }
  b->sign = a->sign;
 802331e:	687b      	ldr	r3, [r7, #4]
 8023320:	685a      	ldr	r2, [r3, #4]
 8023322:	683b      	ldr	r3, [r7, #0]
 8023324:	605a      	str	r2, [r3, #4]
  fp_clamp (b);
 8023326:	e004      	b.n	8023332 <fp_div_2+0xc8>
 8023328:	683b      	ldr	r3, [r7, #0]
 802332a:	681b      	ldr	r3, [r3, #0]
 802332c:	1e5a      	subs	r2, r3, #1
 802332e:	683b      	ldr	r3, [r7, #0]
 8023330:	601a      	str	r2, [r3, #0]
 8023332:	683b      	ldr	r3, [r7, #0]
 8023334:	681b      	ldr	r3, [r3, #0]
 8023336:	2b00      	cmp	r3, #0
 8023338:	d009      	beq.n	802334e <fp_div_2+0xe4>
 802333a:	683b      	ldr	r3, [r7, #0]
 802333c:	681b      	ldr	r3, [r3, #0]
 802333e:	3b01      	subs	r3, #1
 8023340:	683a      	ldr	r2, [r7, #0]
 8023342:	3302      	adds	r3, #2
 8023344:	009b      	lsls	r3, r3, #2
 8023346:	4413      	add	r3, r2
 8023348:	685b      	ldr	r3, [r3, #4]
 802334a:	2b00      	cmp	r3, #0
 802334c:	d0ec      	beq.n	8023328 <fp_div_2+0xbe>
 802334e:	683b      	ldr	r3, [r7, #0]
 8023350:	681b      	ldr	r3, [r3, #0]
 8023352:	2b00      	cmp	r3, #0
 8023354:	d002      	beq.n	802335c <fp_div_2+0xf2>
 8023356:	683b      	ldr	r3, [r7, #0]
 8023358:	685b      	ldr	r3, [r3, #4]
 802335a:	e000      	b.n	802335e <fp_div_2+0xf4>
 802335c:	2300      	movs	r3, #0
 802335e:	683a      	ldr	r2, [r7, #0]
 8023360:	6053      	str	r3, [r2, #4]
}
 8023362:	bf00      	nop
 8023364:	3724      	adds	r7, #36	@ 0x24
 8023366:	46bd      	mov	sp, r7
 8023368:	f85d 7b04 	ldr.w	r7, [sp], #4
 802336c:	4770      	bx	lr

0802336e <fp_div_2_mod_ct>:

/* c = a / 2 (mod b) - constant time (a < b and positive) */
int fp_div_2_mod_ct(fp_int *a, fp_int *b, fp_int *c)
{
 802336e:	e92d 0fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp}
 8023372:	b08d      	sub	sp, #52	@ 0x34
 8023374:	af00      	add	r7, sp, #0
 8023376:	6178      	str	r0, [r7, #20]
 8023378:	6139      	str	r1, [r7, #16]
 802337a:	60fa      	str	r2, [r7, #12]
  fp_word  w = 0;
 802337c:	f04f 0200 	mov.w	r2, #0
 8023380:	f04f 0300 	mov.w	r3, #0
 8023384:	e9c7 230a 	strd	r2, r3, [r7, #40]	@ 0x28
  fp_digit mask;
  int i;

  mask = (fp_digit)0 - (a->dp[0] & 1);
 8023388:	697b      	ldr	r3, [r7, #20]
 802338a:	68db      	ldr	r3, [r3, #12]
 802338c:	f003 0301 	and.w	r3, r3, #1
 8023390:	425b      	negs	r3, r3
 8023392:	623b      	str	r3, [r7, #32]
  for (i = 0; i < b->used; i++) {
 8023394:	2300      	movs	r3, #0
 8023396:	627b      	str	r3, [r7, #36]	@ 0x24
 8023398:	e047      	b.n	802342a <fp_div_2_mod_ct+0xbc>
      fp_digit mask_a = (fp_digit)0 - (i < a->used);
 802339a:	697b      	ldr	r3, [r7, #20]
 802339c:	681b      	ldr	r3, [r3, #0]
 802339e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80233a0:	429a      	cmp	r2, r3
 80233a2:	bfb4      	ite	lt
 80233a4:	2301      	movlt	r3, #1
 80233a6:	2300      	movge	r3, #0
 80233a8:	b2db      	uxtb	r3, r3
 80233aa:	425b      	negs	r3, r3
 80233ac:	61fb      	str	r3, [r7, #28]

      w         += b->dp[i] & mask;
 80233ae:	693a      	ldr	r2, [r7, #16]
 80233b0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80233b2:	3302      	adds	r3, #2
 80233b4:	009b      	lsls	r3, r3, #2
 80233b6:	4413      	add	r3, r2
 80233b8:	685a      	ldr	r2, [r3, #4]
 80233ba:	6a3b      	ldr	r3, [r7, #32]
 80233bc:	4013      	ands	r3, r2
 80233be:	2200      	movs	r2, #0
 80233c0:	461c      	mov	r4, r3
 80233c2:	4615      	mov	r5, r2
 80233c4:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	@ 0x28
 80233c8:	eb12 0a04 	adds.w	sl, r2, r4
 80233cc:	eb43 0b05 	adc.w	fp, r3, r5
 80233d0:	e9c7 ab0a 	strd	sl, fp, [r7, #40]	@ 0x28
      w         += a->dp[i] & mask_a;
 80233d4:	697a      	ldr	r2, [r7, #20]
 80233d6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80233d8:	3302      	adds	r3, #2
 80233da:	009b      	lsls	r3, r3, #2
 80233dc:	4413      	add	r3, r2
 80233de:	685a      	ldr	r2, [r3, #4]
 80233e0:	69fb      	ldr	r3, [r7, #28]
 80233e2:	4013      	ands	r3, r2
 80233e4:	2200      	movs	r2, #0
 80233e6:	4698      	mov	r8, r3
 80233e8:	4691      	mov	r9, r2
 80233ea:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	@ 0x28
 80233ee:	eb12 0108 	adds.w	r1, r2, r8
 80233f2:	6039      	str	r1, [r7, #0]
 80233f4:	eb43 0309 	adc.w	r3, r3, r9
 80233f8:	607b      	str	r3, [r7, #4]
 80233fa:	e9d7 2300 	ldrd	r2, r3, [r7]
 80233fe:	e9c7 230a 	strd	r2, r3, [r7, #40]	@ 0x28
      c->dp[i]   = (fp_digit)w;
 8023402:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8023404:	68f9      	ldr	r1, [r7, #12]
 8023406:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8023408:	3302      	adds	r3, #2
 802340a:	009b      	lsls	r3, r3, #2
 802340c:	440b      	add	r3, r1
 802340e:	605a      	str	r2, [r3, #4]
      w        >>= DIGIT_BIT;
 8023410:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	@ 0x28
 8023414:	f04f 0200 	mov.w	r2, #0
 8023418:	f04f 0300 	mov.w	r3, #0
 802341c:	000a      	movs	r2, r1
 802341e:	2300      	movs	r3, #0
 8023420:	e9c7 230a 	strd	r2, r3, [r7, #40]	@ 0x28
  for (i = 0; i < b->used; i++) {
 8023424:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8023426:	3301      	adds	r3, #1
 8023428:	627b      	str	r3, [r7, #36]	@ 0x24
 802342a:	693b      	ldr	r3, [r7, #16]
 802342c:	681b      	ldr	r3, [r3, #0]
 802342e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8023430:	429a      	cmp	r2, r3
 8023432:	dbb2      	blt.n	802339a <fp_div_2_mod_ct+0x2c>
  }
  for (i = 0; i < b->used-1; i++) {
 8023434:	2300      	movs	r3, #0
 8023436:	627b      	str	r3, [r7, #36]	@ 0x24
 8023438:	e018      	b.n	802346c <fp_div_2_mod_ct+0xfe>
      c->dp[i] = (c->dp[i] >> 1) | (c->dp[i+1] << (DIGIT_BIT - 1));
 802343a:	68fa      	ldr	r2, [r7, #12]
 802343c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802343e:	3302      	adds	r3, #2
 8023440:	009b      	lsls	r3, r3, #2
 8023442:	4413      	add	r3, r2
 8023444:	685b      	ldr	r3, [r3, #4]
 8023446:	085a      	lsrs	r2, r3, #1
 8023448:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802344a:	3301      	adds	r3, #1
 802344c:	68f9      	ldr	r1, [r7, #12]
 802344e:	3302      	adds	r3, #2
 8023450:	009b      	lsls	r3, r3, #2
 8023452:	440b      	add	r3, r1
 8023454:	685b      	ldr	r3, [r3, #4]
 8023456:	07db      	lsls	r3, r3, #31
 8023458:	431a      	orrs	r2, r3
 802345a:	68f9      	ldr	r1, [r7, #12]
 802345c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802345e:	3302      	adds	r3, #2
 8023460:	009b      	lsls	r3, r3, #2
 8023462:	440b      	add	r3, r1
 8023464:	605a      	str	r2, [r3, #4]
  for (i = 0; i < b->used-1; i++) {
 8023466:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8023468:	3301      	adds	r3, #1
 802346a:	627b      	str	r3, [r7, #36]	@ 0x24
 802346c:	693b      	ldr	r3, [r7, #16]
 802346e:	681b      	ldr	r3, [r3, #0]
 8023470:	3b01      	subs	r3, #1
 8023472:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8023474:	429a      	cmp	r2, r3
 8023476:	dbe0      	blt.n	802343a <fp_div_2_mod_ct+0xcc>
  }
  c->dp[i] = (c->dp[i] >> 1) | ((fp_digit)w << (DIGIT_BIT - 1));
 8023478:	68fa      	ldr	r2, [r7, #12]
 802347a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802347c:	3302      	adds	r3, #2
 802347e:	009b      	lsls	r3, r3, #2
 8023480:	4413      	add	r3, r2
 8023482:	685b      	ldr	r3, [r3, #4]
 8023484:	085a      	lsrs	r2, r3, #1
 8023486:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8023488:	07db      	lsls	r3, r3, #31
 802348a:	431a      	orrs	r2, r3
 802348c:	68f9      	ldr	r1, [r7, #12]
 802348e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8023490:	3302      	adds	r3, #2
 8023492:	009b      	lsls	r3, r3, #2
 8023494:	440b      	add	r3, r1
 8023496:	605a      	str	r2, [r3, #4]
  c->used = i + 1;
 8023498:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802349a:	1c5a      	adds	r2, r3, #1
 802349c:	68fb      	ldr	r3, [r7, #12]
 802349e:	601a      	str	r2, [r3, #0]
  c->sign = FP_ZPOS;
 80234a0:	68fb      	ldr	r3, [r7, #12]
 80234a2:	2200      	movs	r2, #0
 80234a4:	605a      	str	r2, [r3, #4]
  fp_clamp(c);
 80234a6:	e004      	b.n	80234b2 <fp_div_2_mod_ct+0x144>
 80234a8:	68fb      	ldr	r3, [r7, #12]
 80234aa:	681b      	ldr	r3, [r3, #0]
 80234ac:	1e5a      	subs	r2, r3, #1
 80234ae:	68fb      	ldr	r3, [r7, #12]
 80234b0:	601a      	str	r2, [r3, #0]
 80234b2:	68fb      	ldr	r3, [r7, #12]
 80234b4:	681b      	ldr	r3, [r3, #0]
 80234b6:	2b00      	cmp	r3, #0
 80234b8:	d009      	beq.n	80234ce <fp_div_2_mod_ct+0x160>
 80234ba:	68fb      	ldr	r3, [r7, #12]
 80234bc:	681b      	ldr	r3, [r3, #0]
 80234be:	3b01      	subs	r3, #1
 80234c0:	68fa      	ldr	r2, [r7, #12]
 80234c2:	3302      	adds	r3, #2
 80234c4:	009b      	lsls	r3, r3, #2
 80234c6:	4413      	add	r3, r2
 80234c8:	685b      	ldr	r3, [r3, #4]
 80234ca:	2b00      	cmp	r3, #0
 80234cc:	d0ec      	beq.n	80234a8 <fp_div_2_mod_ct+0x13a>
 80234ce:	68fb      	ldr	r3, [r7, #12]
 80234d0:	681b      	ldr	r3, [r3, #0]
 80234d2:	2b00      	cmp	r3, #0
 80234d4:	d002      	beq.n	80234dc <fp_div_2_mod_ct+0x16e>
 80234d6:	68fb      	ldr	r3, [r7, #12]
 80234d8:	685b      	ldr	r3, [r3, #4]
 80234da:	e000      	b.n	80234de <fp_div_2_mod_ct+0x170>
 80234dc:	2300      	movs	r3, #0
 80234de:	68fa      	ldr	r2, [r7, #12]
 80234e0:	6053      	str	r3, [r2, #4]

  return FP_OKAY;
 80234e2:	2300      	movs	r3, #0
}
 80234e4:	4618      	mov	r0, r3
 80234e6:	3734      	adds	r7, #52	@ 0x34
 80234e8:	46bd      	mov	sp, r7
 80234ea:	e8bd 0fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp}
 80234ee:	4770      	bx	lr

080234f0 <fp_div_2d>:

/* c = a / 2**b */
void fp_div_2d(fp_int *a, int b, fp_int *c, fp_int *d)
{
 80234f0:	b580      	push	{r7, lr}
 80234f2:	b086      	sub	sp, #24
 80234f4:	af00      	add	r7, sp, #0
 80234f6:	60f8      	str	r0, [r7, #12]
 80234f8:	60b9      	str	r1, [r7, #8]
 80234fa:	607a      	str	r2, [r7, #4]
 80234fc:	603b      	str	r3, [r7, #0]
  int      D;

  /* if the shift count is <= 0 then we do no work */
  if (b <= 0) {
 80234fe:	68bb      	ldr	r3, [r7, #8]
 8023500:	2b00      	cmp	r3, #0
 8023502:	dc0a      	bgt.n	802351a <fp_div_2d+0x2a>
    fp_copy (a, c);
 8023504:	6879      	ldr	r1, [r7, #4]
 8023506:	68f8      	ldr	r0, [r7, #12]
 8023508:	f003 fabc 	bl	8026a84 <fp_copy>
    if (d != NULL) {
 802350c:	683b      	ldr	r3, [r7, #0]
 802350e:	2b00      	cmp	r3, #0
 8023510:	d05a      	beq.n	80235c8 <fp_div_2d+0xd8>
      fp_zero (d);
 8023512:	6838      	ldr	r0, [r7, #0]
 8023514:	f003 f8da 	bl	80266cc <fp_zero>
    }
    return;
 8023518:	e056      	b.n	80235c8 <fp_div_2d+0xd8>
  }

  /* get the remainder before a is changed in calculating c */
  if (a == c && d != NULL) {
 802351a:	68fa      	ldr	r2, [r7, #12]
 802351c:	687b      	ldr	r3, [r7, #4]
 802351e:	429a      	cmp	r2, r3
 8023520:	d107      	bne.n	8023532 <fp_div_2d+0x42>
 8023522:	683b      	ldr	r3, [r7, #0]
 8023524:	2b00      	cmp	r3, #0
 8023526:	d004      	beq.n	8023532 <fp_div_2d+0x42>
    fp_mod_2d (a, b, d);
 8023528:	683a      	ldr	r2, [r7, #0]
 802352a:	68b9      	ldr	r1, [r7, #8]
 802352c:	68f8      	ldr	r0, [r7, #12]
 802352e:	f000 f88f 	bl	8023650 <fp_mod_2d>
  }

  /* copy */
  fp_copy(a, c);
 8023532:	6879      	ldr	r1, [r7, #4]
 8023534:	68f8      	ldr	r0, [r7, #12]
 8023536:	f003 faa5 	bl	8026a84 <fp_copy>

  /* shift by as many digits in the bit count */
  if (b >= (int)DIGIT_BIT) {
 802353a:	68bb      	ldr	r3, [r7, #8]
 802353c:	2b1f      	cmp	r3, #31
 802353e:	dd08      	ble.n	8023552 <fp_div_2d+0x62>
    fp_rshd (c, b / DIGIT_BIT);
 8023540:	68bb      	ldr	r3, [r7, #8]
 8023542:	2b00      	cmp	r3, #0
 8023544:	da00      	bge.n	8023548 <fp_div_2d+0x58>
 8023546:	331f      	adds	r3, #31
 8023548:	115b      	asrs	r3, r3, #5
 802354a:	4619      	mov	r1, r3
 802354c:	6878      	ldr	r0, [r7, #4]
 802354e:	f003 f804 	bl	802655a <fp_rshd>
  }

  /* shift any bit count < DIGIT_BIT */
  D = (b % DIGIT_BIT);
 8023552:	68bb      	ldr	r3, [r7, #8]
 8023554:	425a      	negs	r2, r3
 8023556:	f003 031f 	and.w	r3, r3, #31
 802355a:	f002 021f 	and.w	r2, r2, #31
 802355e:	bf58      	it	pl
 8023560:	4253      	negpl	r3, r2
 8023562:	617b      	str	r3, [r7, #20]
  if (D != 0) {
 8023564:	697b      	ldr	r3, [r7, #20]
 8023566:	2b00      	cmp	r3, #0
 8023568:	d003      	beq.n	8023572 <fp_div_2d+0x82>
    fp_rshb(c, D);
 802356a:	6979      	ldr	r1, [r7, #20]
 802356c:	6878      	ldr	r0, [r7, #4]
 802356e:	f002 ff70 	bl	8026452 <fp_rshb>
  }

  /* get the remainder if a is not changed in calculating c */
  if (a != c && d != NULL) {
 8023572:	68fa      	ldr	r2, [r7, #12]
 8023574:	687b      	ldr	r3, [r7, #4]
 8023576:	429a      	cmp	r2, r3
 8023578:	d00d      	beq.n	8023596 <fp_div_2d+0xa6>
 802357a:	683b      	ldr	r3, [r7, #0]
 802357c:	2b00      	cmp	r3, #0
 802357e:	d00a      	beq.n	8023596 <fp_div_2d+0xa6>
    fp_mod_2d (a, b, d);
 8023580:	683a      	ldr	r2, [r7, #0]
 8023582:	68b9      	ldr	r1, [r7, #8]
 8023584:	68f8      	ldr	r0, [r7, #12]
 8023586:	f000 f863 	bl	8023650 <fp_mod_2d>
  }

  fp_clamp (c);
 802358a:	e004      	b.n	8023596 <fp_div_2d+0xa6>
 802358c:	687b      	ldr	r3, [r7, #4]
 802358e:	681b      	ldr	r3, [r3, #0]
 8023590:	1e5a      	subs	r2, r3, #1
 8023592:	687b      	ldr	r3, [r7, #4]
 8023594:	601a      	str	r2, [r3, #0]
 8023596:	687b      	ldr	r3, [r7, #4]
 8023598:	681b      	ldr	r3, [r3, #0]
 802359a:	2b00      	cmp	r3, #0
 802359c:	d009      	beq.n	80235b2 <fp_div_2d+0xc2>
 802359e:	687b      	ldr	r3, [r7, #4]
 80235a0:	681b      	ldr	r3, [r3, #0]
 80235a2:	3b01      	subs	r3, #1
 80235a4:	687a      	ldr	r2, [r7, #4]
 80235a6:	3302      	adds	r3, #2
 80235a8:	009b      	lsls	r3, r3, #2
 80235aa:	4413      	add	r3, r2
 80235ac:	685b      	ldr	r3, [r3, #4]
 80235ae:	2b00      	cmp	r3, #0
 80235b0:	d0ec      	beq.n	802358c <fp_div_2d+0x9c>
 80235b2:	687b      	ldr	r3, [r7, #4]
 80235b4:	681b      	ldr	r3, [r3, #0]
 80235b6:	2b00      	cmp	r3, #0
 80235b8:	d002      	beq.n	80235c0 <fp_div_2d+0xd0>
 80235ba:	687b      	ldr	r3, [r7, #4]
 80235bc:	685b      	ldr	r3, [r3, #4]
 80235be:	e000      	b.n	80235c2 <fp_div_2d+0xd2>
 80235c0:	2300      	movs	r3, #0
 80235c2:	687a      	ldr	r2, [r7, #4]
 80235c4:	6053      	str	r3, [r2, #4]
 80235c6:	e000      	b.n	80235ca <fp_div_2d+0xda>
    return;
 80235c8:	bf00      	nop
}
 80235ca:	3718      	adds	r7, #24
 80235cc:	46bd      	mov	sp, r7
 80235ce:	bd80      	pop	{r7, pc}

080235d0 <fp_mod>:

/* c = a mod b, 0 <= c < b  */
int fp_mod(fp_int *a, fp_int *b, fp_int *c)
{
 80235d0:	b580      	push	{r7, lr}
 80235d2:	b088      	sub	sp, #32
 80235d4:	af00      	add	r7, sp, #0
 80235d6:	60f8      	str	r0, [r7, #12]
 80235d8:	60b9      	str	r1, [r7, #8]
 80235da:	607a      	str	r2, [r7, #4]
   fp_int *t;
#endif
   int    err;

#ifdef WOLFSSL_SMALL_STACK
   t = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
 80235dc:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 80235e0:	f7fb fa52 	bl	801ea88 <wolfSSL_Malloc>
 80235e4:	61b8      	str	r0, [r7, #24]
   if (t == NULL)
 80235e6:	69bb      	ldr	r3, [r7, #24]
 80235e8:	2b00      	cmp	r3, #0
 80235ea:	d102      	bne.n	80235f2 <fp_mod+0x22>
       return FP_MEM;
 80235ec:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 80235f0:	e02a      	b.n	8023648 <fp_mod+0x78>
#endif

   fp_init(t);
 80235f2:	69b8      	ldr	r0, [r7, #24]
 80235f4:	f003 f85c 	bl	80266b0 <fp_init>
   err = fp_div(a, b, NULL, t);
 80235f8:	69bb      	ldr	r3, [r7, #24]
 80235fa:	2200      	movs	r2, #0
 80235fc:	68b9      	ldr	r1, [r7, #8]
 80235fe:	68f8      	ldr	r0, [r7, #12]
 8023600:	f7ff fb3e 	bl	8022c80 <fp_div>
 8023604:	61f8      	str	r0, [r7, #28]
   if (err == FP_OKAY) {
 8023606:	69fb      	ldr	r3, [r7, #28]
 8023608:	2b00      	cmp	r3, #0
 802360a:	d114      	bne.n	8023636 <fp_mod+0x66>
      if (!fp_iszero(t) && (t->sign != b->sign)) {
 802360c:	69bb      	ldr	r3, [r7, #24]
 802360e:	681b      	ldr	r3, [r3, #0]
 8023610:	2b00      	cmp	r3, #0
 8023612:	d00c      	beq.n	802362e <fp_mod+0x5e>
 8023614:	69bb      	ldr	r3, [r7, #24]
 8023616:	685a      	ldr	r2, [r3, #4]
 8023618:	68bb      	ldr	r3, [r7, #8]
 802361a:	685b      	ldr	r3, [r3, #4]
 802361c:	429a      	cmp	r2, r3
 802361e:	d006      	beq.n	802362e <fp_mod+0x5e>
         err = fp_add(t, b, c);
 8023620:	687a      	ldr	r2, [r7, #4]
 8023622:	68b9      	ldr	r1, [r7, #8]
 8023624:	69b8      	ldr	r0, [r7, #24]
 8023626:	f7fe fe54 	bl	80222d2 <fp_add>
 802362a:	61f8      	str	r0, [r7, #28]
 802362c:	e003      	b.n	8023636 <fp_mod+0x66>
      } else {
         fp_copy(t, c);
 802362e:	6879      	ldr	r1, [r7, #4]
 8023630:	69b8      	ldr	r0, [r7, #24]
 8023632:	f003 fa27 	bl	8026a84 <fp_copy>
     }
  }

#ifdef WOLFSSL_SMALL_STACK
  XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
 8023636:	69bb      	ldr	r3, [r7, #24]
 8023638:	617b      	str	r3, [r7, #20]
 802363a:	697b      	ldr	r3, [r7, #20]
 802363c:	2b00      	cmp	r3, #0
 802363e:	d002      	beq.n	8023646 <fp_mod+0x76>
 8023640:	6978      	ldr	r0, [r7, #20]
 8023642:	f7fb fa3d 	bl	801eac0 <wolfSSL_Free>
#endif
  return err;
 8023646:	69fb      	ldr	r3, [r7, #28]
}
 8023648:	4618      	mov	r0, r3
 802364a:	3720      	adds	r7, #32
 802364c:	46bd      	mov	sp, r7
 802364e:	bd80      	pop	{r7, pc}

08023650 <fp_mod_2d>:

/* c = a mod 2**d */
void fp_mod_2d(fp_int *a, int b, fp_int *c)
{
 8023650:	b580      	push	{r7, lr}
 8023652:	b088      	sub	sp, #32
 8023654:	af00      	add	r7, sp, #0
 8023656:	60f8      	str	r0, [r7, #12]
 8023658:	60b9      	str	r1, [r7, #8]
 802365a:	607a      	str	r2, [r7, #4]
   unsigned int x;
   unsigned int bmax;

   /* zero if count less than or equal to zero */
   if (b <= 0) {
 802365c:	68bb      	ldr	r3, [r7, #8]
 802365e:	2b00      	cmp	r3, #0
 8023660:	dc03      	bgt.n	802366a <fp_mod_2d+0x1a>
      fp_zero(c);
 8023662:	6878      	ldr	r0, [r7, #4]
 8023664:	f003 f832 	bl	80266cc <fp_zero>
      return;
 8023668:	e0b7      	b.n	80237da <fp_mod_2d+0x18a>
   }

   /* get copy of input */
   fp_copy(a, c);
 802366a:	6879      	ldr	r1, [r7, #4]
 802366c:	68f8      	ldr	r0, [r7, #12]
 802366e:	f003 fa09 	bl	8026a84 <fp_copy>

   /* if 2**d is larger than we just return */
   if (c->sign == FP_ZPOS && b >= (DIGIT_BIT * a->used)) {
 8023672:	687b      	ldr	r3, [r7, #4]
 8023674:	685b      	ldr	r3, [r3, #4]
 8023676:	2b00      	cmp	r3, #0
 8023678:	d106      	bne.n	8023688 <fp_mod_2d+0x38>
 802367a:	68fb      	ldr	r3, [r7, #12]
 802367c:	681b      	ldr	r3, [r3, #0]
 802367e:	015b      	lsls	r3, r3, #5
 8023680:	68ba      	ldr	r2, [r7, #8]
 8023682:	429a      	cmp	r2, r3
 8023684:	f280 80a6 	bge.w	80237d4 <fp_mod_2d+0x184>
      return;
   }

   bmax = ((unsigned int)b + DIGIT_BIT - 1) / DIGIT_BIT;
 8023688:	68bb      	ldr	r3, [r7, #8]
 802368a:	331f      	adds	r3, #31
 802368c:	095b      	lsrs	r3, r3, #5
 802368e:	617b      	str	r3, [r7, #20]

   /* If a is negative and bmax is greater than or equal to FP_SIZE, then the
    * result can't fit within c. Just return. */
   if (c->sign == FP_NEG && bmax >= FP_SIZE) {
 8023690:	687b      	ldr	r3, [r7, #4]
 8023692:	685b      	ldr	r3, [r3, #4]
 8023694:	2b01      	cmp	r3, #1
 8023696:	d103      	bne.n	80236a0 <fp_mod_2d+0x50>
 8023698:	697b      	ldr	r3, [r7, #20]
 802369a:	2b87      	cmp	r3, #135	@ 0x87
 802369c:	f200 809c 	bhi.w	80237d8 <fp_mod_2d+0x188>
      return;
   }

  /* zero digits above the last digit of the modulus */
   for (x = bmax; x < (unsigned int)c->used; x++) {
 80236a0:	697b      	ldr	r3, [r7, #20]
 80236a2:	61fb      	str	r3, [r7, #28]
 80236a4:	e009      	b.n	80236ba <fp_mod_2d+0x6a>
    c->dp[x] = 0;
 80236a6:	687a      	ldr	r2, [r7, #4]
 80236a8:	69fb      	ldr	r3, [r7, #28]
 80236aa:	3302      	adds	r3, #2
 80236ac:	009b      	lsls	r3, r3, #2
 80236ae:	4413      	add	r3, r2
 80236b0:	2200      	movs	r2, #0
 80236b2:	605a      	str	r2, [r3, #4]
   for (x = bmax; x < (unsigned int)c->used; x++) {
 80236b4:	69fb      	ldr	r3, [r7, #28]
 80236b6:	3301      	adds	r3, #1
 80236b8:	61fb      	str	r3, [r7, #28]
 80236ba:	687b      	ldr	r3, [r7, #4]
 80236bc:	681b      	ldr	r3, [r3, #0]
 80236be:	461a      	mov	r2, r3
 80236c0:	69fb      	ldr	r3, [r7, #28]
 80236c2:	4293      	cmp	r3, r2
 80236c4:	d3ef      	bcc.n	80236a6 <fp_mod_2d+0x56>
  }

  if (c->sign == FP_NEG) {
 80236c6:	687b      	ldr	r3, [r7, #4]
 80236c8:	685b      	ldr	r3, [r3, #4]
 80236ca:	2b01      	cmp	r3, #1
 80236cc:	d142      	bne.n	8023754 <fp_mod_2d+0x104>
     fp_digit carry = 0;
 80236ce:	2300      	movs	r3, #0
 80236d0:	61bb      	str	r3, [r7, #24]
     /* negate value */
     for (x = 0; x < (unsigned int)c->used; x++) {
 80236d2:	2300      	movs	r3, #0
 80236d4:	61fb      	str	r3, [r7, #28]
 80236d6:	e021      	b.n	802371c <fp_mod_2d+0xcc>
         fp_digit next = c->dp[x] > 0;
 80236d8:	687a      	ldr	r2, [r7, #4]
 80236da:	69fb      	ldr	r3, [r7, #28]
 80236dc:	3302      	adds	r3, #2
 80236de:	009b      	lsls	r3, r3, #2
 80236e0:	4413      	add	r3, r2
 80236e2:	685b      	ldr	r3, [r3, #4]
 80236e4:	2b00      	cmp	r3, #0
 80236e6:	bf14      	ite	ne
 80236e8:	2301      	movne	r3, #1
 80236ea:	2300      	moveq	r3, #0
 80236ec:	b2db      	uxtb	r3, r3
 80236ee:	613b      	str	r3, [r7, #16]
         c->dp[x] = (fp_digit)0 - c->dp[x] - carry;
 80236f0:	687a      	ldr	r2, [r7, #4]
 80236f2:	69fb      	ldr	r3, [r7, #28]
 80236f4:	3302      	adds	r3, #2
 80236f6:	009b      	lsls	r3, r3, #2
 80236f8:	4413      	add	r3, r2
 80236fa:	685b      	ldr	r3, [r3, #4]
 80236fc:	425a      	negs	r2, r3
 80236fe:	69bb      	ldr	r3, [r7, #24]
 8023700:	1ad2      	subs	r2, r2, r3
 8023702:	6879      	ldr	r1, [r7, #4]
 8023704:	69fb      	ldr	r3, [r7, #28]
 8023706:	3302      	adds	r3, #2
 8023708:	009b      	lsls	r3, r3, #2
 802370a:	440b      	add	r3, r1
 802370c:	605a      	str	r2, [r3, #4]
         carry |= next;
 802370e:	69ba      	ldr	r2, [r7, #24]
 8023710:	693b      	ldr	r3, [r7, #16]
 8023712:	4313      	orrs	r3, r2
 8023714:	61bb      	str	r3, [r7, #24]
     for (x = 0; x < (unsigned int)c->used; x++) {
 8023716:	69fb      	ldr	r3, [r7, #28]
 8023718:	3301      	adds	r3, #1
 802371a:	61fb      	str	r3, [r7, #28]
 802371c:	687b      	ldr	r3, [r7, #4]
 802371e:	681b      	ldr	r3, [r3, #0]
 8023720:	461a      	mov	r2, r3
 8023722:	69fb      	ldr	r3, [r7, #28]
 8023724:	4293      	cmp	r3, r2
 8023726:	d3d7      	bcc.n	80236d8 <fp_mod_2d+0x88>
     }
     for (; x < bmax; x++) {
 8023728:	e00a      	b.n	8023740 <fp_mod_2d+0xf0>
         c->dp[x] = (fp_digit)0 - carry;
 802372a:	69bb      	ldr	r3, [r7, #24]
 802372c:	425a      	negs	r2, r3
 802372e:	6879      	ldr	r1, [r7, #4]
 8023730:	69fb      	ldr	r3, [r7, #28]
 8023732:	3302      	adds	r3, #2
 8023734:	009b      	lsls	r3, r3, #2
 8023736:	440b      	add	r3, r1
 8023738:	605a      	str	r2, [r3, #4]
     for (; x < bmax; x++) {
 802373a:	69fb      	ldr	r3, [r7, #28]
 802373c:	3301      	adds	r3, #1
 802373e:	61fb      	str	r3, [r7, #28]
 8023740:	69fa      	ldr	r2, [r7, #28]
 8023742:	697b      	ldr	r3, [r7, #20]
 8023744:	429a      	cmp	r2, r3
 8023746:	d3f0      	bcc.n	802372a <fp_mod_2d+0xda>
     }
     c->used = (int)bmax;
 8023748:	697a      	ldr	r2, [r7, #20]
 802374a:	687b      	ldr	r3, [r7, #4]
 802374c:	601a      	str	r2, [r3, #0]
     c->sign = FP_ZPOS;
 802374e:	687b      	ldr	r3, [r7, #4]
 8023750:	2200      	movs	r2, #0
 8023752:	605a      	str	r2, [r3, #4]
  }

  /* clear the digit that is not completely outside/inside the modulus */
  x = DIGIT_BIT - (b % DIGIT_BIT);
 8023754:	68bb      	ldr	r3, [r7, #8]
 8023756:	425a      	negs	r2, r3
 8023758:	f003 031f 	and.w	r3, r3, #31
 802375c:	f002 021f 	and.w	r2, r2, #31
 8023760:	bf58      	it	pl
 8023762:	4253      	negpl	r3, r2
 8023764:	f1c3 0320 	rsb	r3, r3, #32
 8023768:	61fb      	str	r3, [r7, #28]
  if (x != DIGIT_BIT) {
 802376a:	69fb      	ldr	r3, [r7, #28]
 802376c:	2b20      	cmp	r3, #32
 802376e:	d018      	beq.n	80237a2 <fp_mod_2d+0x152>
     c->dp[bmax - 1] &= ~((fp_digit)0) >> x;
 8023770:	697b      	ldr	r3, [r7, #20]
 8023772:	3b01      	subs	r3, #1
 8023774:	687a      	ldr	r2, [r7, #4]
 8023776:	3302      	adds	r3, #2
 8023778:	009b      	lsls	r3, r3, #2
 802377a:	4413      	add	r3, r2
 802377c:	6859      	ldr	r1, [r3, #4]
 802377e:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8023782:	69fb      	ldr	r3, [r7, #28]
 8023784:	40da      	lsrs	r2, r3
 8023786:	697b      	ldr	r3, [r7, #20]
 8023788:	3b01      	subs	r3, #1
 802378a:	400a      	ands	r2, r1
 802378c:	6879      	ldr	r1, [r7, #4]
 802378e:	3302      	adds	r3, #2
 8023790:	009b      	lsls	r3, r3, #2
 8023792:	440b      	add	r3, r1
 8023794:	605a      	str	r2, [r3, #4]
  }

  fp_clamp (c);
 8023796:	e004      	b.n	80237a2 <fp_mod_2d+0x152>
 8023798:	687b      	ldr	r3, [r7, #4]
 802379a:	681b      	ldr	r3, [r3, #0]
 802379c:	1e5a      	subs	r2, r3, #1
 802379e:	687b      	ldr	r3, [r7, #4]
 80237a0:	601a      	str	r2, [r3, #0]
 80237a2:	687b      	ldr	r3, [r7, #4]
 80237a4:	681b      	ldr	r3, [r3, #0]
 80237a6:	2b00      	cmp	r3, #0
 80237a8:	d009      	beq.n	80237be <fp_mod_2d+0x16e>
 80237aa:	687b      	ldr	r3, [r7, #4]
 80237ac:	681b      	ldr	r3, [r3, #0]
 80237ae:	3b01      	subs	r3, #1
 80237b0:	687a      	ldr	r2, [r7, #4]
 80237b2:	3302      	adds	r3, #2
 80237b4:	009b      	lsls	r3, r3, #2
 80237b6:	4413      	add	r3, r2
 80237b8:	685b      	ldr	r3, [r3, #4]
 80237ba:	2b00      	cmp	r3, #0
 80237bc:	d0ec      	beq.n	8023798 <fp_mod_2d+0x148>
 80237be:	687b      	ldr	r3, [r7, #4]
 80237c0:	681b      	ldr	r3, [r3, #0]
 80237c2:	2b00      	cmp	r3, #0
 80237c4:	d002      	beq.n	80237cc <fp_mod_2d+0x17c>
 80237c6:	687b      	ldr	r3, [r7, #4]
 80237c8:	685b      	ldr	r3, [r3, #4]
 80237ca:	e000      	b.n	80237ce <fp_mod_2d+0x17e>
 80237cc:	2300      	movs	r3, #0
 80237ce:	687a      	ldr	r2, [r7, #4]
 80237d0:	6053      	str	r3, [r2, #4]
 80237d2:	e002      	b.n	80237da <fp_mod_2d+0x18a>
      return;
 80237d4:	bf00      	nop
 80237d6:	e000      	b.n	80237da <fp_mod_2d+0x18a>
      return;
 80237d8:	bf00      	nop
}
 80237da:	3720      	adds	r7, #32
 80237dc:	46bd      	mov	sp, r7
 80237de:	bd80      	pop	{r7, pc}

080237e0 <fp_invmod_slow>:

static int fp_invmod_slow (fp_int * a, fp_int * b, fp_int * c)
{
 80237e0:	b580      	push	{r7, lr}
 80237e2:	b09e      	sub	sp, #120	@ 0x78
 80237e4:	af00      	add	r7, sp, #0
 80237e6:	60f8      	str	r0, [r7, #12]
 80237e8:	60b9      	str	r1, [r7, #8]
 80237ea:	607a      	str	r2, [r7, #4]
  fp_int  *x, *y, *u, *v, *A, *B, *C, *D;
#endif
  int     err;

  /* b cannot be negative */
  if (b->sign == FP_NEG || fp_iszero(b) == FP_YES) {
 80237ec:	68bb      	ldr	r3, [r7, #8]
 80237ee:	685b      	ldr	r3, [r3, #4]
 80237f0:	2b01      	cmp	r3, #1
 80237f2:	d003      	beq.n	80237fc <fp_invmod_slow+0x1c>
 80237f4:	68bb      	ldr	r3, [r7, #8]
 80237f6:	681b      	ldr	r3, [r3, #0]
 80237f8:	2b00      	cmp	r3, #0
 80237fa:	d102      	bne.n	8023802 <fp_invmod_slow+0x22>
    return FP_VAL;
 80237fc:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8023800:	e239      	b.n	8023c76 <fp_invmod_slow+0x496>
  }
  if (fp_iszero(a) == FP_YES) {
 8023802:	68fb      	ldr	r3, [r7, #12]
 8023804:	681b      	ldr	r3, [r3, #0]
 8023806:	2b00      	cmp	r3, #0
 8023808:	d102      	bne.n	8023810 <fp_invmod_slow+0x30>
    return FP_VAL;
 802380a:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 802380e:	e232      	b.n	8023c76 <fp_invmod_slow+0x496>
  }

#ifdef WOLFSSL_SMALL_STACK
  x = (fp_int*)XMALLOC(sizeof(fp_int) * 8, NULL, DYNAMIC_TYPE_BIGINT);
 8023810:	f44f 508b 	mov.w	r0, #4448	@ 0x1160
 8023814:	f7fb f938 	bl	801ea88 <wolfSSL_Malloc>
 8023818:	6778      	str	r0, [r7, #116]	@ 0x74
  if (x == NULL) {
 802381a:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 802381c:	2b00      	cmp	r3, #0
 802381e:	d102      	bne.n	8023826 <fp_invmod_slow+0x46>
      return FP_MEM;
 8023820:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 8023824:	e227      	b.n	8023c76 <fp_invmod_slow+0x496>
  }
  y = &x[1]; u = &x[2]; v = &x[3]; A = &x[4]; B = &x[5]; C = &x[6]; D = &x[7];
 8023826:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023828:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 802382c:	673b      	str	r3, [r7, #112]	@ 0x70
 802382e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023830:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 8023834:	66fb      	str	r3, [r7, #108]	@ 0x6c
 8023836:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023838:	f203 6384 	addw	r3, r3, #1668	@ 0x684
 802383c:	66bb      	str	r3, [r7, #104]	@ 0x68
 802383e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023840:	f503 630b 	add.w	r3, r3, #2224	@ 0x8b0
 8023844:	667b      	str	r3, [r7, #100]	@ 0x64
 8023846:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023848:	f603 23dc 	addw	r3, r3, #2780	@ 0xadc
 802384c:	663b      	str	r3, [r7, #96]	@ 0x60
 802384e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023850:	f603 5308 	addw	r3, r3, #3336	@ 0xd08
 8023854:	65fb      	str	r3, [r7, #92]	@ 0x5c
 8023856:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023858:	f603 7334 	addw	r3, r3, #3892	@ 0xf34
 802385c:	65bb      	str	r3, [r7, #88]	@ 0x58
#endif

  /* init temps */
  fp_init(x);    fp_init(y);
 802385e:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 8023860:	f002 ff26 	bl	80266b0 <fp_init>
 8023864:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 8023866:	f002 ff23 	bl	80266b0 <fp_init>
  fp_init(u);    fp_init(v);
 802386a:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 802386c:	f002 ff20 	bl	80266b0 <fp_init>
 8023870:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 8023872:	f002 ff1d 	bl	80266b0 <fp_init>
  fp_init(A);    fp_init(B);
 8023876:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8023878:	f002 ff1a 	bl	80266b0 <fp_init>
 802387c:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 802387e:	f002 ff17 	bl	80266b0 <fp_init>
  fp_init(C);    fp_init(D);
 8023882:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8023884:	f002 ff14 	bl	80266b0 <fp_init>
 8023888:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 802388a:	f002 ff11 	bl	80266b0 <fp_init>

  /* x = a, y = b */
  if ((err = fp_mod(a, b, x)) != FP_OKAY) {
 802388e:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8023890:	68b9      	ldr	r1, [r7, #8]
 8023892:	68f8      	ldr	r0, [r7, #12]
 8023894:	f7ff fe9c 	bl	80235d0 <fp_mod>
 8023898:	6578      	str	r0, [r7, #84]	@ 0x54
 802389a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802389c:	2b00      	cmp	r3, #0
 802389e:	d009      	beq.n	80238b4 <fp_invmod_slow+0xd4>
  #ifdef WOLFSSL_SMALL_STACK
    XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 80238a0:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80238a2:	613b      	str	r3, [r7, #16]
 80238a4:	693b      	ldr	r3, [r7, #16]
 80238a6:	2b00      	cmp	r3, #0
 80238a8:	d002      	beq.n	80238b0 <fp_invmod_slow+0xd0>
 80238aa:	6938      	ldr	r0, [r7, #16]
 80238ac:	f7fb f908 	bl	801eac0 <wolfSSL_Free>
  #endif
    return err;
 80238b0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80238b2:	e1e0      	b.n	8023c76 <fp_invmod_slow+0x496>
  }
  fp_copy(b, y);
 80238b4:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 80238b6:	68b8      	ldr	r0, [r7, #8]
 80238b8:	f003 f8e4 	bl	8026a84 <fp_copy>

  if (fp_iszero(x) == FP_YES) {
 80238bc:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80238be:	681b      	ldr	r3, [r3, #0]
 80238c0:	2b00      	cmp	r3, #0
 80238c2:	d10a      	bne.n	80238da <fp_invmod_slow+0xfa>
    /* invmod doesn't exist for this a and b */
  #ifdef WOLFSSL_SMALL_STACK
    XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 80238c4:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80238c6:	617b      	str	r3, [r7, #20]
 80238c8:	697b      	ldr	r3, [r7, #20]
 80238ca:	2b00      	cmp	r3, #0
 80238cc:	d002      	beq.n	80238d4 <fp_invmod_slow+0xf4>
 80238ce:	6978      	ldr	r0, [r7, #20]
 80238d0:	f7fb f8f6 	bl	801eac0 <wolfSSL_Free>
  #endif
    return FP_VAL;
 80238d4:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 80238d8:	e1cd      	b.n	8023c76 <fp_invmod_slow+0x496>
  }

  /* 2. [modified] if x,y are both even then return an error! */
  if (fp_iseven(x) == FP_YES && fp_iseven(y) == FP_YES) {
 80238da:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80238dc:	681b      	ldr	r3, [r3, #0]
 80238de:	2b00      	cmp	r3, #0
 80238e0:	dd07      	ble.n	80238f2 <fp_invmod_slow+0x112>
 80238e2:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80238e4:	68db      	ldr	r3, [r3, #12]
 80238e6:	f003 0301 	and.w	r3, r3, #1
 80238ea:	2b00      	cmp	r3, #0
 80238ec:	d101      	bne.n	80238f2 <fp_invmod_slow+0x112>
 80238ee:	2301      	movs	r3, #1
 80238f0:	e000      	b.n	80238f4 <fp_invmod_slow+0x114>
 80238f2:	2300      	movs	r3, #0
 80238f4:	2b01      	cmp	r3, #1
 80238f6:	d119      	bne.n	802392c <fp_invmod_slow+0x14c>
 80238f8:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 80238fa:	681b      	ldr	r3, [r3, #0]
 80238fc:	2b00      	cmp	r3, #0
 80238fe:	dd07      	ble.n	8023910 <fp_invmod_slow+0x130>
 8023900:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8023902:	68db      	ldr	r3, [r3, #12]
 8023904:	f003 0301 	and.w	r3, r3, #1
 8023908:	2b00      	cmp	r3, #0
 802390a:	d101      	bne.n	8023910 <fp_invmod_slow+0x130>
 802390c:	2301      	movs	r3, #1
 802390e:	e000      	b.n	8023912 <fp_invmod_slow+0x132>
 8023910:	2300      	movs	r3, #0
 8023912:	2b01      	cmp	r3, #1
 8023914:	d10a      	bne.n	802392c <fp_invmod_slow+0x14c>
  #ifdef WOLFSSL_SMALL_STACK
    XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023916:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023918:	653b      	str	r3, [r7, #80]	@ 0x50
 802391a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802391c:	2b00      	cmp	r3, #0
 802391e:	d002      	beq.n	8023926 <fp_invmod_slow+0x146>
 8023920:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 8023922:	f7fb f8cd 	bl	801eac0 <wolfSSL_Free>
  #endif
    return FP_VAL;
 8023926:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 802392a:	e1a4      	b.n	8023c76 <fp_invmod_slow+0x496>
  }

  /* 3. u=x, v=y, A=1, B=0, C=0,D=1 */
  fp_copy (x, u);
 802392c:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 802392e:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 8023930:	f003 f8a8 	bl	8026a84 <fp_copy>
  fp_copy (y, v);
 8023934:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 8023936:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 8023938:	f003 f8a4 	bl	8026a84 <fp_copy>
  fp_set (A, 1);
 802393c:	2101      	movs	r1, #1
 802393e:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8023940:	f002 fc87 	bl	8026252 <fp_set>
  fp_set (D, 1);
 8023944:	2101      	movs	r1, #1
 8023946:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 8023948:	f002 fc83 	bl	8026252 <fp_set>

top:
  /* 4.  while u is even do */
  while (fp_iseven (u) == FP_YES) {
 802394c:	e04f      	b.n	80239ee <fp_invmod_slow+0x20e>
    /* 4.1 u = u/2 */
    fp_div_2 (u, u);
 802394e:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 8023950:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 8023952:	f7ff fc8a 	bl	802326a <fp_div_2>

    /* 4.2 if A or B is odd then */
    if (fp_isodd (A) == FP_YES || fp_isodd (B) == FP_YES) {
 8023956:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8023958:	681b      	ldr	r3, [r3, #0]
 802395a:	2b00      	cmp	r3, #0
 802395c:	dd07      	ble.n	802396e <fp_invmod_slow+0x18e>
 802395e:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8023960:	68db      	ldr	r3, [r3, #12]
 8023962:	f003 0301 	and.w	r3, r3, #1
 8023966:	2b00      	cmp	r3, #0
 8023968:	d001      	beq.n	802396e <fp_invmod_slow+0x18e>
 802396a:	2301      	movs	r3, #1
 802396c:	e000      	b.n	8023970 <fp_invmod_slow+0x190>
 802396e:	2300      	movs	r3, #0
 8023970:	2b01      	cmp	r3, #1
 8023972:	d00e      	beq.n	8023992 <fp_invmod_slow+0x1b2>
 8023974:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8023976:	681b      	ldr	r3, [r3, #0]
 8023978:	2b00      	cmp	r3, #0
 802397a:	dd07      	ble.n	802398c <fp_invmod_slow+0x1ac>
 802397c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 802397e:	68db      	ldr	r3, [r3, #12]
 8023980:	f003 0301 	and.w	r3, r3, #1
 8023984:	2b00      	cmp	r3, #0
 8023986:	d001      	beq.n	802398c <fp_invmod_slow+0x1ac>
 8023988:	2301      	movs	r3, #1
 802398a:	e000      	b.n	802398e <fp_invmod_slow+0x1ae>
 802398c:	2300      	movs	r3, #0
 802398e:	2b01      	cmp	r3, #1
 8023990:	d125      	bne.n	80239de <fp_invmod_slow+0x1fe>
      /* A = (A+y)/2, B = (B-x)/2 */
      err = fp_add (A, y, A);
 8023992:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 8023994:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 8023996:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8023998:	f7fe fc9b 	bl	80222d2 <fp_add>
 802399c:	6578      	str	r0, [r7, #84]	@ 0x54
      if (err != FP_OKAY) {
 802399e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80239a0:	2b00      	cmp	r3, #0
 80239a2:	d009      	beq.n	80239b8 <fp_invmod_slow+0x1d8>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 80239a4:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80239a6:	61bb      	str	r3, [r7, #24]
 80239a8:	69bb      	ldr	r3, [r7, #24]
 80239aa:	2b00      	cmp	r3, #0
 80239ac:	d002      	beq.n	80239b4 <fp_invmod_slow+0x1d4>
 80239ae:	69b8      	ldr	r0, [r7, #24]
 80239b0:	f7fb f886 	bl	801eac0 <wolfSSL_Free>
      #endif
        return err;
 80239b4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80239b6:	e15e      	b.n	8023c76 <fp_invmod_slow+0x496>
      }
      err = fp_sub (B, x, B);
 80239b8:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 80239ba:	6f79      	ldr	r1, [r7, #116]	@ 0x74
 80239bc:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 80239be:	f7fe fd6a 	bl	8022496 <fp_sub>
 80239c2:	6578      	str	r0, [r7, #84]	@ 0x54
      if (err != FP_OKAY) {
 80239c4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80239c6:	2b00      	cmp	r3, #0
 80239c8:	d009      	beq.n	80239de <fp_invmod_slow+0x1fe>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 80239ca:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80239cc:	61fb      	str	r3, [r7, #28]
 80239ce:	69fb      	ldr	r3, [r7, #28]
 80239d0:	2b00      	cmp	r3, #0
 80239d2:	d002      	beq.n	80239da <fp_invmod_slow+0x1fa>
 80239d4:	69f8      	ldr	r0, [r7, #28]
 80239d6:	f7fb f873 	bl	801eac0 <wolfSSL_Free>
      #endif
        return err;
 80239da:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80239dc:	e14b      	b.n	8023c76 <fp_invmod_slow+0x496>
      }
    }
    /* A = A/2, B = B/2 */
    fp_div_2 (A, A);
 80239de:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 80239e0:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 80239e2:	f7ff fc42 	bl	802326a <fp_div_2>
    fp_div_2 (B, B);
 80239e6:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 80239e8:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 80239ea:	f7ff fc3e 	bl	802326a <fp_div_2>
  while (fp_iseven (u) == FP_YES) {
 80239ee:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80239f0:	681b      	ldr	r3, [r3, #0]
 80239f2:	2b00      	cmp	r3, #0
 80239f4:	dd07      	ble.n	8023a06 <fp_invmod_slow+0x226>
 80239f6:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80239f8:	68db      	ldr	r3, [r3, #12]
 80239fa:	f003 0301 	and.w	r3, r3, #1
 80239fe:	2b00      	cmp	r3, #0
 8023a00:	d101      	bne.n	8023a06 <fp_invmod_slow+0x226>
 8023a02:	2301      	movs	r3, #1
 8023a04:	e000      	b.n	8023a08 <fp_invmod_slow+0x228>
 8023a06:	2300      	movs	r3, #0
 8023a08:	2b01      	cmp	r3, #1
 8023a0a:	d0a0      	beq.n	802394e <fp_invmod_slow+0x16e>
  }

  /* 5.  while v is even do */
  while (fp_iseven (v) == FP_YES) {
 8023a0c:	e04f      	b.n	8023aae <fp_invmod_slow+0x2ce>
    /* 5.1 v = v/2 */
    fp_div_2 (v, v);
 8023a0e:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 8023a10:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 8023a12:	f7ff fc2a 	bl	802326a <fp_div_2>

    /* 5.2 if C or D is odd then */
    if (fp_isodd (C) == FP_YES || fp_isodd (D) == FP_YES) {
 8023a16:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023a18:	681b      	ldr	r3, [r3, #0]
 8023a1a:	2b00      	cmp	r3, #0
 8023a1c:	dd07      	ble.n	8023a2e <fp_invmod_slow+0x24e>
 8023a1e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023a20:	68db      	ldr	r3, [r3, #12]
 8023a22:	f003 0301 	and.w	r3, r3, #1
 8023a26:	2b00      	cmp	r3, #0
 8023a28:	d001      	beq.n	8023a2e <fp_invmod_slow+0x24e>
 8023a2a:	2301      	movs	r3, #1
 8023a2c:	e000      	b.n	8023a30 <fp_invmod_slow+0x250>
 8023a2e:	2300      	movs	r3, #0
 8023a30:	2b01      	cmp	r3, #1
 8023a32:	d00e      	beq.n	8023a52 <fp_invmod_slow+0x272>
 8023a34:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8023a36:	681b      	ldr	r3, [r3, #0]
 8023a38:	2b00      	cmp	r3, #0
 8023a3a:	dd07      	ble.n	8023a4c <fp_invmod_slow+0x26c>
 8023a3c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8023a3e:	68db      	ldr	r3, [r3, #12]
 8023a40:	f003 0301 	and.w	r3, r3, #1
 8023a44:	2b00      	cmp	r3, #0
 8023a46:	d001      	beq.n	8023a4c <fp_invmod_slow+0x26c>
 8023a48:	2301      	movs	r3, #1
 8023a4a:	e000      	b.n	8023a4e <fp_invmod_slow+0x26e>
 8023a4c:	2300      	movs	r3, #0
 8023a4e:	2b01      	cmp	r3, #1
 8023a50:	d125      	bne.n	8023a9e <fp_invmod_slow+0x2be>
      /* C = (C+y)/2, D = (D-x)/2 */
      err = fp_add (C, y, C);
 8023a52:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8023a54:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 8023a56:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8023a58:	f7fe fc3b 	bl	80222d2 <fp_add>
 8023a5c:	6578      	str	r0, [r7, #84]	@ 0x54
      if (err != FP_OKAY) {
 8023a5e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023a60:	2b00      	cmp	r3, #0
 8023a62:	d009      	beq.n	8023a78 <fp_invmod_slow+0x298>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023a64:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023a66:	623b      	str	r3, [r7, #32]
 8023a68:	6a3b      	ldr	r3, [r7, #32]
 8023a6a:	2b00      	cmp	r3, #0
 8023a6c:	d002      	beq.n	8023a74 <fp_invmod_slow+0x294>
 8023a6e:	6a38      	ldr	r0, [r7, #32]
 8023a70:	f7fb f826 	bl	801eac0 <wolfSSL_Free>
      #endif
        return err;
 8023a74:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023a76:	e0fe      	b.n	8023c76 <fp_invmod_slow+0x496>
      }
      err = fp_sub (D, x, D);
 8023a78:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8023a7a:	6f79      	ldr	r1, [r7, #116]	@ 0x74
 8023a7c:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 8023a7e:	f7fe fd0a 	bl	8022496 <fp_sub>
 8023a82:	6578      	str	r0, [r7, #84]	@ 0x54
      if (err != FP_OKAY) {
 8023a84:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023a86:	2b00      	cmp	r3, #0
 8023a88:	d009      	beq.n	8023a9e <fp_invmod_slow+0x2be>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023a8a:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023a8c:	627b      	str	r3, [r7, #36]	@ 0x24
 8023a8e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8023a90:	2b00      	cmp	r3, #0
 8023a92:	d002      	beq.n	8023a9a <fp_invmod_slow+0x2ba>
 8023a94:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8023a96:	f7fb f813 	bl	801eac0 <wolfSSL_Free>
      #endif
        return err;
 8023a9a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023a9c:	e0eb      	b.n	8023c76 <fp_invmod_slow+0x496>
      }
    }
    /* C = C/2, D = D/2 */
    fp_div_2 (C, C);
 8023a9e:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 8023aa0:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8023aa2:	f7ff fbe2 	bl	802326a <fp_div_2>
    fp_div_2 (D, D);
 8023aa6:	6db9      	ldr	r1, [r7, #88]	@ 0x58
 8023aa8:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 8023aaa:	f7ff fbde 	bl	802326a <fp_div_2>
  while (fp_iseven (v) == FP_YES) {
 8023aae:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8023ab0:	681b      	ldr	r3, [r3, #0]
 8023ab2:	2b00      	cmp	r3, #0
 8023ab4:	dd07      	ble.n	8023ac6 <fp_invmod_slow+0x2e6>
 8023ab6:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8023ab8:	68db      	ldr	r3, [r3, #12]
 8023aba:	f003 0301 	and.w	r3, r3, #1
 8023abe:	2b00      	cmp	r3, #0
 8023ac0:	d101      	bne.n	8023ac6 <fp_invmod_slow+0x2e6>
 8023ac2:	2301      	movs	r3, #1
 8023ac4:	e000      	b.n	8023ac8 <fp_invmod_slow+0x2e8>
 8023ac6:	2300      	movs	r3, #0
 8023ac8:	2b01      	cmp	r3, #1
 8023aca:	d0a0      	beq.n	8023a0e <fp_invmod_slow+0x22e>
  }

  /* 6.  if u >= v then */
  if (fp_cmp (u, v) != FP_LT) {
 8023acc:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 8023ace:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 8023ad0:	f001 ffd4 	bl	8025a7c <fp_cmp>
 8023ad4:	4603      	mov	r3, r0
 8023ad6:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8023ada:	d038      	beq.n	8023b4e <fp_invmod_slow+0x36e>
    /* u = u - v, A = A - C, B = B - D */
    err = fp_sub (u, v, u);
 8023adc:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8023ade:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 8023ae0:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 8023ae2:	f7fe fcd8 	bl	8022496 <fp_sub>
 8023ae6:	6578      	str	r0, [r7, #84]	@ 0x54
    if (err != FP_OKAY) {
 8023ae8:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023aea:	2b00      	cmp	r3, #0
 8023aec:	d009      	beq.n	8023b02 <fp_invmod_slow+0x322>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023aee:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023af0:	63bb      	str	r3, [r7, #56]	@ 0x38
 8023af2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8023af4:	2b00      	cmp	r3, #0
 8023af6:	d002      	beq.n	8023afe <fp_invmod_slow+0x31e>
 8023af8:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 8023afa:	f7fa ffe1 	bl	801eac0 <wolfSSL_Free>
    #endif
      return err;
 8023afe:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023b00:	e0b9      	b.n	8023c76 <fp_invmod_slow+0x496>
    }
    err = fp_sub (A, C, A);
 8023b02:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 8023b04:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 8023b06:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8023b08:	f7fe fcc5 	bl	8022496 <fp_sub>
 8023b0c:	6578      	str	r0, [r7, #84]	@ 0x54
    if (err != FP_OKAY) {
 8023b0e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023b10:	2b00      	cmp	r3, #0
 8023b12:	d009      	beq.n	8023b28 <fp_invmod_slow+0x348>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023b14:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023b16:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8023b18:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8023b1a:	2b00      	cmp	r3, #0
 8023b1c:	d002      	beq.n	8023b24 <fp_invmod_slow+0x344>
 8023b1e:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8023b20:	f7fa ffce 	bl	801eac0 <wolfSSL_Free>
    #endif
      return err;
 8023b24:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023b26:	e0a6      	b.n	8023c76 <fp_invmod_slow+0x496>
    }
    err = fp_sub (B, D, B);
 8023b28:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8023b2a:	6db9      	ldr	r1, [r7, #88]	@ 0x58
 8023b2c:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 8023b2e:	f7fe fcb2 	bl	8022496 <fp_sub>
 8023b32:	6578      	str	r0, [r7, #84]	@ 0x54
    if (err != FP_OKAY) {
 8023b34:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023b36:	2b00      	cmp	r3, #0
 8023b38:	d042      	beq.n	8023bc0 <fp_invmod_slow+0x3e0>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023b3a:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023b3c:	643b      	str	r3, [r7, #64]	@ 0x40
 8023b3e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8023b40:	2b00      	cmp	r3, #0
 8023b42:	d002      	beq.n	8023b4a <fp_invmod_slow+0x36a>
 8023b44:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 8023b46:	f7fa ffbb 	bl	801eac0 <wolfSSL_Free>
    #endif
      return err;
 8023b4a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023b4c:	e093      	b.n	8023c76 <fp_invmod_slow+0x496>
    }
  } else {
    /* v - v - u, C = C - A, D = D - B */
    err = fp_sub (v, u, v);
 8023b4e:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8023b50:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 8023b52:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 8023b54:	f7fe fc9f 	bl	8022496 <fp_sub>
 8023b58:	6578      	str	r0, [r7, #84]	@ 0x54
    if (err != FP_OKAY) {
 8023b5a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023b5c:	2b00      	cmp	r3, #0
 8023b5e:	d009      	beq.n	8023b74 <fp_invmod_slow+0x394>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023b60:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023b62:	647b      	str	r3, [r7, #68]	@ 0x44
 8023b64:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023b66:	2b00      	cmp	r3, #0
 8023b68:	d002      	beq.n	8023b70 <fp_invmod_slow+0x390>
 8023b6a:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 8023b6c:	f7fa ffa8 	bl	801eac0 <wolfSSL_Free>
    #endif
      return err;
 8023b70:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023b72:	e080      	b.n	8023c76 <fp_invmod_slow+0x496>
    }
    err = fp_sub (C, A, C);
 8023b74:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8023b76:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 8023b78:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8023b7a:	f7fe fc8c 	bl	8022496 <fp_sub>
 8023b7e:	6578      	str	r0, [r7, #84]	@ 0x54
    if (err != FP_OKAY) {
 8023b80:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023b82:	2b00      	cmp	r3, #0
 8023b84:	d009      	beq.n	8023b9a <fp_invmod_slow+0x3ba>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023b86:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023b88:	64bb      	str	r3, [r7, #72]	@ 0x48
 8023b8a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8023b8c:	2b00      	cmp	r3, #0
 8023b8e:	d002      	beq.n	8023b96 <fp_invmod_slow+0x3b6>
 8023b90:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 8023b92:	f7fa ff95 	bl	801eac0 <wolfSSL_Free>
    #endif
      return err;
 8023b96:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023b98:	e06d      	b.n	8023c76 <fp_invmod_slow+0x496>
    }
    err = fp_sub (D, B, D);
 8023b9a:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8023b9c:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 8023b9e:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 8023ba0:	f7fe fc79 	bl	8022496 <fp_sub>
 8023ba4:	6578      	str	r0, [r7, #84]	@ 0x54
    if (err != FP_OKAY) {
 8023ba6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023ba8:	2b00      	cmp	r3, #0
 8023baa:	d009      	beq.n	8023bc0 <fp_invmod_slow+0x3e0>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023bac:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023bae:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8023bb0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8023bb2:	2b00      	cmp	r3, #0
 8023bb4:	d002      	beq.n	8023bbc <fp_invmod_slow+0x3dc>
 8023bb6:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 8023bb8:	f7fa ff82 	bl	801eac0 <wolfSSL_Free>
    #endif
      return err;
 8023bbc:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023bbe:	e05a      	b.n	8023c76 <fp_invmod_slow+0x496>
    }
  }

  /* if not zero goto step 4 */
  if (fp_iszero (u) == FP_NO)
 8023bc0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8023bc2:	681b      	ldr	r3, [r3, #0]
 8023bc4:	2b00      	cmp	r3, #0
 8023bc6:	d000      	beq.n	8023bca <fp_invmod_slow+0x3ea>
    goto top;
 8023bc8:	e6c0      	b.n	802394c <fp_invmod_slow+0x16c>

  /* now a = C, b = D, gcd == g*v */

  /* if v != 1 then there is no inverse */
  if (fp_cmp_d (v, 1) != FP_EQ) {
 8023bca:	2101      	movs	r1, #1
 8023bcc:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 8023bce:	f001 ff82 	bl	8025ad6 <fp_cmp_d>
 8023bd2:	4603      	mov	r3, r0
 8023bd4:	2b00      	cmp	r3, #0
 8023bd6:	d01d      	beq.n	8023c14 <fp_invmod_slow+0x434>
  #ifdef WOLFSSL_SMALL_STACK
    XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023bd8:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023bda:	62bb      	str	r3, [r7, #40]	@ 0x28
 8023bdc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8023bde:	2b00      	cmp	r3, #0
 8023be0:	d002      	beq.n	8023be8 <fp_invmod_slow+0x408>
 8023be2:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8023be4:	f7fa ff6c 	bl	801eac0 <wolfSSL_Free>
  #endif
    return FP_VAL;
 8023be8:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8023bec:	e043      	b.n	8023c76 <fp_invmod_slow+0x496>
  }

  /* if its too low */
  while (fp_cmp_d(C, 0) == FP_LT) {
    err = fp_add(C, b, C);
 8023bee:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8023bf0:	68b9      	ldr	r1, [r7, #8]
 8023bf2:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8023bf4:	f7fe fb6d 	bl	80222d2 <fp_add>
 8023bf8:	6578      	str	r0, [r7, #84]	@ 0x54
    if (err != FP_OKAY) {
 8023bfa:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023bfc:	2b00      	cmp	r3, #0
 8023bfe:	d009      	beq.n	8023c14 <fp_invmod_slow+0x434>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023c00:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023c02:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8023c04:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8023c06:	2b00      	cmp	r3, #0
 8023c08:	d002      	beq.n	8023c10 <fp_invmod_slow+0x430>
 8023c0a:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8023c0c:	f7fa ff58 	bl	801eac0 <wolfSSL_Free>
    #endif
      return err;
 8023c10:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023c12:	e030      	b.n	8023c76 <fp_invmod_slow+0x496>
  while (fp_cmp_d(C, 0) == FP_LT) {
 8023c14:	2100      	movs	r1, #0
 8023c16:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8023c18:	f001 ff5d 	bl	8025ad6 <fp_cmp_d>
 8023c1c:	4603      	mov	r3, r0
 8023c1e:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8023c22:	d0e4      	beq.n	8023bee <fp_invmod_slow+0x40e>
    }
  }

  /* too big */
  while (fp_cmp_mag(C, b) != FP_LT) {
 8023c24:	e012      	b.n	8023c4c <fp_invmod_slow+0x46c>
    err = fp_sub(C, b, C);
 8023c26:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8023c28:	68b9      	ldr	r1, [r7, #8]
 8023c2a:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8023c2c:	f7fe fc33 	bl	8022496 <fp_sub>
 8023c30:	6578      	str	r0, [r7, #84]	@ 0x54
    if (err != FP_OKAY) {
 8023c32:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023c34:	2b00      	cmp	r3, #0
 8023c36:	d009      	beq.n	8023c4c <fp_invmod_slow+0x46c>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023c38:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023c3a:	633b      	str	r3, [r7, #48]	@ 0x30
 8023c3c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8023c3e:	2b00      	cmp	r3, #0
 8023c40:	d002      	beq.n	8023c48 <fp_invmod_slow+0x468>
 8023c42:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 8023c44:	f7fa ff3c 	bl	801eac0 <wolfSSL_Free>
    #endif
      return err;
 8023c48:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023c4a:	e014      	b.n	8023c76 <fp_invmod_slow+0x496>
  while (fp_cmp_mag(C, b) != FP_LT) {
 8023c4c:	68b9      	ldr	r1, [r7, #8]
 8023c4e:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8023c50:	f001 ff79 	bl	8025b46 <fp_cmp_mag>
 8023c54:	4603      	mov	r3, r0
 8023c56:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8023c5a:	d1e4      	bne.n	8023c26 <fp_invmod_slow+0x446>
    }
  }

  /* C is now the inverse */
  fp_copy(C, c);
 8023c5c:	6879      	ldr	r1, [r7, #4]
 8023c5e:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8023c60:	f002 ff10 	bl	8026a84 <fp_copy>
#ifdef WOLFSSL_SMALL_STACK
  XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023c64:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023c66:	637b      	str	r3, [r7, #52]	@ 0x34
 8023c68:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8023c6a:	2b00      	cmp	r3, #0
 8023c6c:	d002      	beq.n	8023c74 <fp_invmod_slow+0x494>
 8023c6e:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 8023c70:	f7fa ff26 	bl	801eac0 <wolfSSL_Free>
#endif
  return FP_OKAY;
 8023c74:	2300      	movs	r3, #0
}
 8023c76:	4618      	mov	r0, r3
 8023c78:	3778      	adds	r7, #120	@ 0x78
 8023c7a:	46bd      	mov	sp, r7
 8023c7c:	bd80      	pop	{r7, pc}

08023c7e <fp_invmod>:

/* c = 1/a (mod b) for odd b only */
int fp_invmod(fp_int *a, fp_int *b, fp_int *c)
{
 8023c7e:	b580      	push	{r7, lr}
 8023c80:	b098      	sub	sp, #96	@ 0x60
 8023c82:	af00      	add	r7, sp, #0
 8023c84:	60f8      	str	r0, [r7, #12]
 8023c86:	60b9      	str	r1, [r7, #8]
 8023c88:	607a      	str	r2, [r7, #4]
#else
  fp_int  *x, *y, *u, *v, *B, *D;
#endif
  int     err;

  if (b->sign == FP_NEG || fp_iszero(b) == FP_YES) {
 8023c8a:	68bb      	ldr	r3, [r7, #8]
 8023c8c:	685b      	ldr	r3, [r3, #4]
 8023c8e:	2b01      	cmp	r3, #1
 8023c90:	d003      	beq.n	8023c9a <fp_invmod+0x1c>
 8023c92:	68bb      	ldr	r3, [r7, #8]
 8023c94:	681b      	ldr	r3, [r3, #0]
 8023c96:	2b00      	cmp	r3, #0
 8023c98:	d102      	bne.n	8023ca0 <fp_invmod+0x22>
    return FP_VAL;
 8023c9a:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8023c9e:	e1ad      	b.n	8023ffc <fp_invmod+0x37e>
  }

  /* [modified] sanity check on "a" */
  if (fp_iszero(a) == FP_YES) {
 8023ca0:	68fb      	ldr	r3, [r7, #12]
 8023ca2:	681b      	ldr	r3, [r3, #0]
 8023ca4:	2b00      	cmp	r3, #0
 8023ca6:	d102      	bne.n	8023cae <fp_invmod+0x30>
    return FP_VAL; /* can not divide by 0 here */
 8023ca8:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8023cac:	e1a6      	b.n	8023ffc <fp_invmod+0x37e>
  }

  /* 2. [modified] b must be odd   */
  if (fp_iseven(b) == FP_YES) {
 8023cae:	68bb      	ldr	r3, [r7, #8]
 8023cb0:	681b      	ldr	r3, [r3, #0]
 8023cb2:	2b00      	cmp	r3, #0
 8023cb4:	dd07      	ble.n	8023cc6 <fp_invmod+0x48>
 8023cb6:	68bb      	ldr	r3, [r7, #8]
 8023cb8:	68db      	ldr	r3, [r3, #12]
 8023cba:	f003 0301 	and.w	r3, r3, #1
 8023cbe:	2b00      	cmp	r3, #0
 8023cc0:	d101      	bne.n	8023cc6 <fp_invmod+0x48>
 8023cc2:	2301      	movs	r3, #1
 8023cc4:	e000      	b.n	8023cc8 <fp_invmod+0x4a>
 8023cc6:	2300      	movs	r3, #0
 8023cc8:	2b01      	cmp	r3, #1
 8023cca:	d106      	bne.n	8023cda <fp_invmod+0x5c>
    return fp_invmod_slow(a,b,c);
 8023ccc:	687a      	ldr	r2, [r7, #4]
 8023cce:	68b9      	ldr	r1, [r7, #8]
 8023cd0:	68f8      	ldr	r0, [r7, #12]
 8023cd2:	f7ff fd85 	bl	80237e0 <fp_invmod_slow>
 8023cd6:	4603      	mov	r3, r0
 8023cd8:	e190      	b.n	8023ffc <fp_invmod+0x37e>
  }

#ifdef WOLFSSL_SMALL_STACK
  x = (fp_int*)XMALLOC(sizeof(fp_int) * 6, NULL, DYNAMIC_TYPE_BIGINT);
 8023cda:	f640 5008 	movw	r0, #3336	@ 0xd08
 8023cde:	f7fa fed3 	bl	801ea88 <wolfSSL_Malloc>
 8023ce2:	65f8      	str	r0, [r7, #92]	@ 0x5c
  if (x == NULL) {
 8023ce4:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023ce6:	2b00      	cmp	r3, #0
 8023ce8:	d102      	bne.n	8023cf0 <fp_invmod+0x72>
      return FP_MEM;
 8023cea:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 8023cee:	e185      	b.n	8023ffc <fp_invmod+0x37e>
  }
  y = &x[1]; u = &x[2]; v = &x[3]; B = &x[4]; D = &x[5];
 8023cf0:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023cf2:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8023cf6:	65bb      	str	r3, [r7, #88]	@ 0x58
 8023cf8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023cfa:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 8023cfe:	657b      	str	r3, [r7, #84]	@ 0x54
 8023d00:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023d02:	f203 6384 	addw	r3, r3, #1668	@ 0x684
 8023d06:	653b      	str	r3, [r7, #80]	@ 0x50
 8023d08:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023d0a:	f503 630b 	add.w	r3, r3, #2224	@ 0x8b0
 8023d0e:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8023d10:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023d12:	f603 23dc 	addw	r3, r3, #2780	@ 0xadc
 8023d16:	64bb      	str	r3, [r7, #72]	@ 0x48
#endif

  /* init all our temps */
  fp_init(x);  fp_init(y);
 8023d18:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8023d1a:	f002 fcc9 	bl	80266b0 <fp_init>
 8023d1e:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 8023d20:	f002 fcc6 	bl	80266b0 <fp_init>
  fp_init(u);  fp_init(v);
 8023d24:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 8023d26:	f002 fcc3 	bl	80266b0 <fp_init>
 8023d2a:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 8023d2c:	f002 fcc0 	bl	80266b0 <fp_init>
  fp_init(B);  fp_init(D);
 8023d30:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 8023d32:	f002 fcbd 	bl	80266b0 <fp_init>
 8023d36:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 8023d38:	f002 fcba 	bl	80266b0 <fp_init>

  if (fp_iszero(a) == FP_YES) {
 8023d3c:	68fb      	ldr	r3, [r7, #12]
 8023d3e:	681b      	ldr	r3, [r3, #0]
 8023d40:	2b00      	cmp	r3, #0
 8023d42:	d10a      	bne.n	8023d5a <fp_invmod+0xdc>
  #ifdef WOLFSSL_SMALL_STACK
    XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023d44:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023d46:	613b      	str	r3, [r7, #16]
 8023d48:	693b      	ldr	r3, [r7, #16]
 8023d4a:	2b00      	cmp	r3, #0
 8023d4c:	d002      	beq.n	8023d54 <fp_invmod+0xd6>
 8023d4e:	6938      	ldr	r0, [r7, #16]
 8023d50:	f7fa feb6 	bl	801eac0 <wolfSSL_Free>
  #endif
    return FP_VAL;
 8023d54:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8023d58:	e150      	b.n	8023ffc <fp_invmod+0x37e>
  }

  /* x == modulus, y == value to invert */
  fp_copy(b, x);
 8023d5a:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 8023d5c:	68b8      	ldr	r0, [r7, #8]
 8023d5e:	f002 fe91 	bl	8026a84 <fp_copy>

  /* we need y = |a| */
  if ((err = mp_mod(a, b, y)) != FP_OKAY) {
 8023d62:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8023d64:	68b9      	ldr	r1, [r7, #8]
 8023d66:	68f8      	ldr	r0, [r7, #12]
 8023d68:	f002 fdd0 	bl	802690c <mp_mod>
 8023d6c:	6478      	str	r0, [r7, #68]	@ 0x44
 8023d6e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023d70:	2b00      	cmp	r3, #0
 8023d72:	d009      	beq.n	8023d88 <fp_invmod+0x10a>
  #ifdef WOLFSSL_SMALL_STACK
    XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023d74:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023d76:	617b      	str	r3, [r7, #20]
 8023d78:	697b      	ldr	r3, [r7, #20]
 8023d7a:	2b00      	cmp	r3, #0
 8023d7c:	d002      	beq.n	8023d84 <fp_invmod+0x106>
 8023d7e:	6978      	ldr	r0, [r7, #20]
 8023d80:	f7fa fe9e 	bl	801eac0 <wolfSSL_Free>
  #endif
    return err;
 8023d84:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023d86:	e139      	b.n	8023ffc <fp_invmod+0x37e>
  }

  if (fp_iszero(y) == FP_YES) {
 8023d88:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8023d8a:	681b      	ldr	r3, [r3, #0]
 8023d8c:	2b00      	cmp	r3, #0
 8023d8e:	d10a      	bne.n	8023da6 <fp_invmod+0x128>
    /* invmod doesn't exist for this a and b */
  #ifdef WOLFSSL_SMALL_STACK
    XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023d90:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023d92:	61bb      	str	r3, [r7, #24]
 8023d94:	69bb      	ldr	r3, [r7, #24]
 8023d96:	2b00      	cmp	r3, #0
 8023d98:	d002      	beq.n	8023da0 <fp_invmod+0x122>
 8023d9a:	69b8      	ldr	r0, [r7, #24]
 8023d9c:	f7fa fe90 	bl	801eac0 <wolfSSL_Free>
  #endif
    return FP_VAL;
 8023da0:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8023da4:	e12a      	b.n	8023ffc <fp_invmod+0x37e>
  }

  /* 3. u=x, v=y, A=1, B=0, C=0,D=1 */
  fp_copy(x, u);
 8023da6:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 8023da8:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8023daa:	f002 fe6b 	bl	8026a84 <fp_copy>
  fp_copy(y, v);
 8023dae:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 8023db0:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 8023db2:	f002 fe67 	bl	8026a84 <fp_copy>
  fp_set (D, 1);
 8023db6:	2101      	movs	r1, #1
 8023db8:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 8023dba:	f002 fa4a 	bl	8026252 <fp_set>

top:
  /* 4.  while u is even do */
  while (fp_iseven (u) == FP_YES) {
 8023dbe:	e029      	b.n	8023e14 <fp_invmod+0x196>
    /* 4.1 u = u/2 */
    fp_div_2 (u, u);
 8023dc0:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 8023dc2:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 8023dc4:	f7ff fa51 	bl	802326a <fp_div_2>

    /* 4.2 if B is odd then */
    if (fp_isodd (B) == FP_YES) {
 8023dc8:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8023dca:	681b      	ldr	r3, [r3, #0]
 8023dcc:	2b00      	cmp	r3, #0
 8023dce:	dd07      	ble.n	8023de0 <fp_invmod+0x162>
 8023dd0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8023dd2:	68db      	ldr	r3, [r3, #12]
 8023dd4:	f003 0301 	and.w	r3, r3, #1
 8023dd8:	2b00      	cmp	r3, #0
 8023dda:	d001      	beq.n	8023de0 <fp_invmod+0x162>
 8023ddc:	2301      	movs	r3, #1
 8023dde:	e000      	b.n	8023de2 <fp_invmod+0x164>
 8023de0:	2300      	movs	r3, #0
 8023de2:	2b01      	cmp	r3, #1
 8023de4:	d112      	bne.n	8023e0c <fp_invmod+0x18e>
      err = fp_sub (B, x, B);
 8023de6:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8023de8:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 8023dea:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 8023dec:	f7fe fb53 	bl	8022496 <fp_sub>
 8023df0:	6478      	str	r0, [r7, #68]	@ 0x44
      if (err != FP_OKAY) {
 8023df2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023df4:	2b00      	cmp	r3, #0
 8023df6:	d009      	beq.n	8023e0c <fp_invmod+0x18e>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023df8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023dfa:	61fb      	str	r3, [r7, #28]
 8023dfc:	69fb      	ldr	r3, [r7, #28]
 8023dfe:	2b00      	cmp	r3, #0
 8023e00:	d002      	beq.n	8023e08 <fp_invmod+0x18a>
 8023e02:	69f8      	ldr	r0, [r7, #28]
 8023e04:	f7fa fe5c 	bl	801eac0 <wolfSSL_Free>
      #endif
        return err;
 8023e08:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023e0a:	e0f7      	b.n	8023ffc <fp_invmod+0x37e>
      }
    }
    /* B = B/2 */
    fp_div_2 (B, B);
 8023e0c:	6cf9      	ldr	r1, [r7, #76]	@ 0x4c
 8023e0e:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 8023e10:	f7ff fa2b 	bl	802326a <fp_div_2>
  while (fp_iseven (u) == FP_YES) {
 8023e14:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023e16:	681b      	ldr	r3, [r3, #0]
 8023e18:	2b00      	cmp	r3, #0
 8023e1a:	dd07      	ble.n	8023e2c <fp_invmod+0x1ae>
 8023e1c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023e1e:	68db      	ldr	r3, [r3, #12]
 8023e20:	f003 0301 	and.w	r3, r3, #1
 8023e24:	2b00      	cmp	r3, #0
 8023e26:	d101      	bne.n	8023e2c <fp_invmod+0x1ae>
 8023e28:	2301      	movs	r3, #1
 8023e2a:	e000      	b.n	8023e2e <fp_invmod+0x1b0>
 8023e2c:	2300      	movs	r3, #0
 8023e2e:	2b01      	cmp	r3, #1
 8023e30:	d0c6      	beq.n	8023dc0 <fp_invmod+0x142>
  }

  /* 5.  while v is even do */
  while (fp_iseven (v) == FP_YES) {
 8023e32:	e029      	b.n	8023e88 <fp_invmod+0x20a>
    /* 5.1 v = v/2 */
    fp_div_2 (v, v);
 8023e34:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 8023e36:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 8023e38:	f7ff fa17 	bl	802326a <fp_div_2>

    /* 5.2 if D is odd then */
    if (fp_isodd (D) == FP_YES) {
 8023e3c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8023e3e:	681b      	ldr	r3, [r3, #0]
 8023e40:	2b00      	cmp	r3, #0
 8023e42:	dd07      	ble.n	8023e54 <fp_invmod+0x1d6>
 8023e44:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8023e46:	68db      	ldr	r3, [r3, #12]
 8023e48:	f003 0301 	and.w	r3, r3, #1
 8023e4c:	2b00      	cmp	r3, #0
 8023e4e:	d001      	beq.n	8023e54 <fp_invmod+0x1d6>
 8023e50:	2301      	movs	r3, #1
 8023e52:	e000      	b.n	8023e56 <fp_invmod+0x1d8>
 8023e54:	2300      	movs	r3, #0
 8023e56:	2b01      	cmp	r3, #1
 8023e58:	d112      	bne.n	8023e80 <fp_invmod+0x202>
      /* D = (D-x)/2 */
      err = fp_sub (D, x, D);
 8023e5a:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8023e5c:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 8023e5e:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 8023e60:	f7fe fb19 	bl	8022496 <fp_sub>
 8023e64:	6478      	str	r0, [r7, #68]	@ 0x44
      if (err != FP_OKAY) {
 8023e66:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023e68:	2b00      	cmp	r3, #0
 8023e6a:	d009      	beq.n	8023e80 <fp_invmod+0x202>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023e6c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023e6e:	623b      	str	r3, [r7, #32]
 8023e70:	6a3b      	ldr	r3, [r7, #32]
 8023e72:	2b00      	cmp	r3, #0
 8023e74:	d002      	beq.n	8023e7c <fp_invmod+0x1fe>
 8023e76:	6a38      	ldr	r0, [r7, #32]
 8023e78:	f7fa fe22 	bl	801eac0 <wolfSSL_Free>
      #endif
        return err;
 8023e7c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023e7e:	e0bd      	b.n	8023ffc <fp_invmod+0x37e>
      }
    }
    /* D = D/2 */
    fp_div_2 (D, D);
 8023e80:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
 8023e82:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 8023e84:	f7ff f9f1 	bl	802326a <fp_div_2>
  while (fp_iseven (v) == FP_YES) {
 8023e88:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8023e8a:	681b      	ldr	r3, [r3, #0]
 8023e8c:	2b00      	cmp	r3, #0
 8023e8e:	dd07      	ble.n	8023ea0 <fp_invmod+0x222>
 8023e90:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8023e92:	68db      	ldr	r3, [r3, #12]
 8023e94:	f003 0301 	and.w	r3, r3, #1
 8023e98:	2b00      	cmp	r3, #0
 8023e9a:	d101      	bne.n	8023ea0 <fp_invmod+0x222>
 8023e9c:	2301      	movs	r3, #1
 8023e9e:	e000      	b.n	8023ea2 <fp_invmod+0x224>
 8023ea0:	2300      	movs	r3, #0
 8023ea2:	2b01      	cmp	r3, #1
 8023ea4:	d0c6      	beq.n	8023e34 <fp_invmod+0x1b6>
  }

  /* 6.  if u >= v then */
  if (fp_cmp (u, v) != FP_LT) {
 8023ea6:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 8023ea8:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 8023eaa:	f001 fde7 	bl	8025a7c <fp_cmp>
 8023eae:	4603      	mov	r3, r0
 8023eb0:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8023eb4:	d025      	beq.n	8023f02 <fp_invmod+0x284>
    /* u = u - v, B = B - D */
    err = fp_sub (u, v, u);
 8023eb6:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8023eb8:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 8023eba:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 8023ebc:	f7fe faeb 	bl	8022496 <fp_sub>
 8023ec0:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err != FP_OKAY) {
 8023ec2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023ec4:	2b00      	cmp	r3, #0
 8023ec6:	d009      	beq.n	8023edc <fp_invmod+0x25e>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023ec8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023eca:	637b      	str	r3, [r7, #52]	@ 0x34
 8023ecc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8023ece:	2b00      	cmp	r3, #0
 8023ed0:	d002      	beq.n	8023ed8 <fp_invmod+0x25a>
 8023ed2:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 8023ed4:	f7fa fdf4 	bl	801eac0 <wolfSSL_Free>
    #endif
      return err;
 8023ed8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023eda:	e08f      	b.n	8023ffc <fp_invmod+0x37e>
    }
    err = fp_sub (B, D, B);
 8023edc:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8023ede:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
 8023ee0:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 8023ee2:	f7fe fad8 	bl	8022496 <fp_sub>
 8023ee6:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err != FP_OKAY) {
 8023ee8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023eea:	2b00      	cmp	r3, #0
 8023eec:	d02f      	beq.n	8023f4e <fp_invmod+0x2d0>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023eee:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023ef0:	63bb      	str	r3, [r7, #56]	@ 0x38
 8023ef2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8023ef4:	2b00      	cmp	r3, #0
 8023ef6:	d002      	beq.n	8023efe <fp_invmod+0x280>
 8023ef8:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 8023efa:	f7fa fde1 	bl	801eac0 <wolfSSL_Free>
    #endif
      return err;
 8023efe:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023f00:	e07c      	b.n	8023ffc <fp_invmod+0x37e>
    }
  } else {
    /* v - v - u, D = D - B */
    err = fp_sub (v, u, v);
 8023f02:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 8023f04:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 8023f06:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 8023f08:	f7fe fac5 	bl	8022496 <fp_sub>
 8023f0c:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err != FP_OKAY) {
 8023f0e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023f10:	2b00      	cmp	r3, #0
 8023f12:	d009      	beq.n	8023f28 <fp_invmod+0x2aa>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023f14:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023f16:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8023f18:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8023f1a:	2b00      	cmp	r3, #0
 8023f1c:	d002      	beq.n	8023f24 <fp_invmod+0x2a6>
 8023f1e:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8023f20:	f7fa fdce 	bl	801eac0 <wolfSSL_Free>
    #endif
      return err;
 8023f24:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023f26:	e069      	b.n	8023ffc <fp_invmod+0x37e>
    }
    err = fp_sub (D, B, D);
 8023f28:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8023f2a:	6cf9      	ldr	r1, [r7, #76]	@ 0x4c
 8023f2c:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 8023f2e:	f7fe fab2 	bl	8022496 <fp_sub>
 8023f32:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err != FP_OKAY) {
 8023f34:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023f36:	2b00      	cmp	r3, #0
 8023f38:	d009      	beq.n	8023f4e <fp_invmod+0x2d0>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023f3a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023f3c:	643b      	str	r3, [r7, #64]	@ 0x40
 8023f3e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8023f40:	2b00      	cmp	r3, #0
 8023f42:	d002      	beq.n	8023f4a <fp_invmod+0x2cc>
 8023f44:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 8023f46:	f7fa fdbb 	bl	801eac0 <wolfSSL_Free>
    #endif
      return err;
 8023f4a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023f4c:	e056      	b.n	8023ffc <fp_invmod+0x37e>
    }
  }

  /* if not zero goto step 4 */
  if (fp_iszero (u) == FP_NO) {
 8023f4e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023f50:	681b      	ldr	r3, [r3, #0]
 8023f52:	2b00      	cmp	r3, #0
 8023f54:	d000      	beq.n	8023f58 <fp_invmod+0x2da>
    goto top;
 8023f56:	e732      	b.n	8023dbe <fp_invmod+0x140>
  }

  /* now a = C, b = D, gcd == g*v */

  /* if v != 1 then there is no inverse */
  if (fp_cmp_d (v, 1) != FP_EQ) {
 8023f58:	2101      	movs	r1, #1
 8023f5a:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 8023f5c:	f001 fdbb 	bl	8025ad6 <fp_cmp_d>
 8023f60:	4603      	mov	r3, r0
 8023f62:	2b00      	cmp	r3, #0
 8023f64:	d01d      	beq.n	8023fa2 <fp_invmod+0x324>
  #ifdef WOLFSSL_SMALL_STACK
    XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023f66:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023f68:	627b      	str	r3, [r7, #36]	@ 0x24
 8023f6a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8023f6c:	2b00      	cmp	r3, #0
 8023f6e:	d002      	beq.n	8023f76 <fp_invmod+0x2f8>
 8023f70:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8023f72:	f7fa fda5 	bl	801eac0 <wolfSSL_Free>
  #endif
    return FP_VAL;
 8023f76:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8023f7a:	e03f      	b.n	8023ffc <fp_invmod+0x37e>
  }

  /* b is now the inverse */
  while (D->sign == FP_NEG) {
    err = fp_add (D, b, D);
 8023f7c:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8023f7e:	68b9      	ldr	r1, [r7, #8]
 8023f80:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 8023f82:	f7fe f9a6 	bl	80222d2 <fp_add>
 8023f86:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err != FP_OKAY) {
 8023f88:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023f8a:	2b00      	cmp	r3, #0
 8023f8c:	d009      	beq.n	8023fa2 <fp_invmod+0x324>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023f8e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023f90:	62bb      	str	r3, [r7, #40]	@ 0x28
 8023f92:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8023f94:	2b00      	cmp	r3, #0
 8023f96:	d002      	beq.n	8023f9e <fp_invmod+0x320>
 8023f98:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8023f9a:	f7fa fd91 	bl	801eac0 <wolfSSL_Free>
    #endif
      return FP_OKAY;
 8023f9e:	2300      	movs	r3, #0
 8023fa0:	e02c      	b.n	8023ffc <fp_invmod+0x37e>
  while (D->sign == FP_NEG) {
 8023fa2:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8023fa4:	685b      	ldr	r3, [r3, #4]
 8023fa6:	2b01      	cmp	r3, #1
 8023fa8:	d0e8      	beq.n	8023f7c <fp_invmod+0x2fe>
    }
  }
  /* too big */
  while (fp_cmp_mag(D, b) != FP_LT) {
 8023faa:	e012      	b.n	8023fd2 <fp_invmod+0x354>
    err = fp_sub(D, b, D);
 8023fac:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8023fae:	68b9      	ldr	r1, [r7, #8]
 8023fb0:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 8023fb2:	f7fe fa70 	bl	8022496 <fp_sub>
 8023fb6:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err != FP_OKAY) {
 8023fb8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023fba:	2b00      	cmp	r3, #0
 8023fbc:	d009      	beq.n	8023fd2 <fp_invmod+0x354>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023fbe:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023fc0:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8023fc2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8023fc4:	2b00      	cmp	r3, #0
 8023fc6:	d002      	beq.n	8023fce <fp_invmod+0x350>
 8023fc8:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8023fca:	f7fa fd79 	bl	801eac0 <wolfSSL_Free>
    #endif
      return err;
 8023fce:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023fd0:	e014      	b.n	8023ffc <fp_invmod+0x37e>
  while (fp_cmp_mag(D, b) != FP_LT) {
 8023fd2:	68b9      	ldr	r1, [r7, #8]
 8023fd4:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 8023fd6:	f001 fdb6 	bl	8025b46 <fp_cmp_mag>
 8023fda:	4603      	mov	r3, r0
 8023fdc:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8023fe0:	d1e4      	bne.n	8023fac <fp_invmod+0x32e>
    }
  }
  fp_copy (D, c);
 8023fe2:	6879      	ldr	r1, [r7, #4]
 8023fe4:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 8023fe6:	f002 fd4d 	bl	8026a84 <fp_copy>
#ifdef WOLFSSL_SMALL_STACK
  XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023fea:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023fec:	633b      	str	r3, [r7, #48]	@ 0x30
 8023fee:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8023ff0:	2b00      	cmp	r3, #0
 8023ff2:	d002      	beq.n	8023ffa <fp_invmod+0x37c>
 8023ff4:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 8023ff6:	f7fa fd63 	bl	801eac0 <wolfSSL_Free>
#endif
  return FP_OKAY;
 8023ffa:	2300      	movs	r3, #0
}
 8023ffc:	4618      	mov	r0, r3
 8023ffe:	3760      	adds	r7, #96	@ 0x60
 8024000:	46bd      	mov	sp, r7
 8024002:	bd80      	pop	{r7, pc}

08024004 <fp_invmod_mont_ct>:

#define CT_INV_MOD_PRE_CNT      8

/* modulus (b) must be greater than 2 and a prime */
int fp_invmod_mont_ct(fp_int *a, fp_int *b, fp_int *c, fp_digit mp)
{
 8024004:	b580      	push	{r7, lr}
 8024006:	b08c      	sub	sp, #48	@ 0x30
 8024008:	af00      	add	r7, sp, #0
 802400a:	60f8      	str	r0, [r7, #12]
 802400c:	60b9      	str	r1, [r7, #8]
 802400e:	607a      	str	r2, [r7, #4]
 8024010:	603b      	str	r3, [r7, #0]
  int i, j, err = FP_OKAY;
 8024012:	2300      	movs	r3, #0
 8024014:	627b      	str	r3, [r7, #36]	@ 0x24
  fp_int* t;
  fp_int* e;
  fp_int* pre;
#endif

  if ((a->used * 2 > FP_SIZE) || (b->used * 2 > FP_SIZE)) {
 8024016:	68fb      	ldr	r3, [r7, #12]
 8024018:	681b      	ldr	r3, [r3, #0]
 802401a:	005b      	lsls	r3, r3, #1
 802401c:	2b88      	cmp	r3, #136	@ 0x88
 802401e:	dc04      	bgt.n	802402a <fp_invmod_mont_ct+0x26>
 8024020:	68bb      	ldr	r3, [r7, #8]
 8024022:	681b      	ldr	r3, [r3, #0]
 8024024:	005b      	lsls	r3, r3, #1
 8024026:	2b88      	cmp	r3, #136	@ 0x88
 8024028:	dd02      	ble.n	8024030 <fp_invmod_mont_ct+0x2c>
    return FP_VAL;
 802402a:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 802402e:	e128      	b.n	8024282 <fp_invmod_mont_ct+0x27e>
  }

#ifdef WOLFSSL_SMALL_STACK
  t = (fp_int*)XMALLOC(sizeof(fp_int) * (2 + CT_INV_MOD_PRE_CNT), NULL,
 8024030:	f241 50b8 	movw	r0, #5560	@ 0x15b8
 8024034:	f7fa fd28 	bl	801ea88 <wolfSSL_Malloc>
 8024038:	6238      	str	r0, [r7, #32]
                                                           DYNAMIC_TYPE_BIGINT);
  if (t == NULL)
 802403a:	6a3b      	ldr	r3, [r7, #32]
 802403c:	2b00      	cmp	r3, #0
 802403e:	d102      	bne.n	8024046 <fp_invmod_mont_ct+0x42>
    return FP_MEM;
 8024040:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 8024044:	e11d      	b.n	8024282 <fp_invmod_mont_ct+0x27e>
  e = t + 1;
 8024046:	6a3b      	ldr	r3, [r7, #32]
 8024048:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 802404c:	61fb      	str	r3, [r7, #28]
  pre = t + 2;
 802404e:	6a3b      	ldr	r3, [r7, #32]
 8024050:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 8024054:	61bb      	str	r3, [r7, #24]
#endif

  fp_init(t);
 8024056:	6a38      	ldr	r0, [r7, #32]
 8024058:	f002 fb2a 	bl	80266b0 <fp_init>
  fp_init(e);
 802405c:	69f8      	ldr	r0, [r7, #28]
 802405e:	f002 fb27 	bl	80266b0 <fp_init>

  fp_init(&pre[0]);
 8024062:	69b8      	ldr	r0, [r7, #24]
 8024064:	f002 fb24 	bl	80266b0 <fp_init>
  fp_copy(a, &pre[0]);
 8024068:	69b9      	ldr	r1, [r7, #24]
 802406a:	68f8      	ldr	r0, [r7, #12]
 802406c:	f002 fd0a 	bl	8026a84 <fp_copy>
  for (i = 1; i < CT_INV_MOD_PRE_CNT; i++) {
 8024070:	2301      	movs	r3, #1
 8024072:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8024074:	e059      	b.n	802412a <fp_invmod_mont_ct+0x126>
    fp_init(&pre[i]);
 8024076:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8024078:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 802407c:	fb02 f303 	mul.w	r3, r2, r3
 8024080:	69ba      	ldr	r2, [r7, #24]
 8024082:	4413      	add	r3, r2
 8024084:	4618      	mov	r0, r3
 8024086:	f002 fb13 	bl	80266b0 <fp_init>
    err |= fp_sqr(&pre[i-1], &pre[i]);
 802408a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802408c:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024090:	fb02 f303 	mul.w	r3, r2, r3
 8024094:	f5a3 730b 	sub.w	r3, r3, #556	@ 0x22c
 8024098:	69ba      	ldr	r2, [r7, #24]
 802409a:	18d0      	adds	r0, r2, r3
 802409c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802409e:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 80240a2:	fb02 f303 	mul.w	r3, r2, r3
 80240a6:	69ba      	ldr	r2, [r7, #24]
 80240a8:	4413      	add	r3, r2
 80240aa:	4619      	mov	r1, r3
 80240ac:	f001 fa9f 	bl	80255ee <fp_sqr>
 80240b0:	4602      	mov	r2, r0
 80240b2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80240b4:	4313      	orrs	r3, r2
 80240b6:	627b      	str	r3, [r7, #36]	@ 0x24
    err |= fp_montgomery_reduce(&pre[i], b, mp);
 80240b8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80240ba:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 80240be:	fb02 f303 	mul.w	r3, r2, r3
 80240c2:	69ba      	ldr	r2, [r7, #24]
 80240c4:	4413      	add	r3, r2
 80240c6:	683a      	ldr	r2, [r7, #0]
 80240c8:	68b9      	ldr	r1, [r7, #8]
 80240ca:	4618      	mov	r0, r3
 80240cc:	f001 ff4b 	bl	8025f66 <fp_montgomery_reduce>
 80240d0:	4602      	mov	r2, r0
 80240d2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80240d4:	4313      	orrs	r3, r2
 80240d6:	627b      	str	r3, [r7, #36]	@ 0x24
    err |= fp_mul(&pre[i], a, &pre[i]);
 80240d8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80240da:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 80240de:	fb02 f303 	mul.w	r3, r2, r3
 80240e2:	69ba      	ldr	r2, [r7, #24]
 80240e4:	18d0      	adds	r0, r2, r3
 80240e6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80240e8:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 80240ec:	fb02 f303 	mul.w	r3, r2, r3
 80240f0:	69ba      	ldr	r2, [r7, #24]
 80240f2:	4413      	add	r3, r2
 80240f4:	461a      	mov	r2, r3
 80240f6:	68f9      	ldr	r1, [r7, #12]
 80240f8:	f7fe fad1 	bl	802269e <fp_mul>
 80240fc:	4602      	mov	r2, r0
 80240fe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024100:	4313      	orrs	r3, r2
 8024102:	627b      	str	r3, [r7, #36]	@ 0x24
    err |= fp_montgomery_reduce(&pre[i], b, mp);
 8024104:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8024106:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 802410a:	fb02 f303 	mul.w	r3, r2, r3
 802410e:	69ba      	ldr	r2, [r7, #24]
 8024110:	4413      	add	r3, r2
 8024112:	683a      	ldr	r2, [r7, #0]
 8024114:	68b9      	ldr	r1, [r7, #8]
 8024116:	4618      	mov	r0, r3
 8024118:	f001 ff25 	bl	8025f66 <fp_montgomery_reduce>
 802411c:	4602      	mov	r2, r0
 802411e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024120:	4313      	orrs	r3, r2
 8024122:	627b      	str	r3, [r7, #36]	@ 0x24
  for (i = 1; i < CT_INV_MOD_PRE_CNT; i++) {
 8024124:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8024126:	3301      	adds	r3, #1
 8024128:	62fb      	str	r3, [r7, #44]	@ 0x2c
 802412a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802412c:	2b07      	cmp	r3, #7
 802412e:	dda2      	ble.n	8024076 <fp_invmod_mont_ct+0x72>
  }

  err |= fp_sub_d(b, 2, e);
 8024130:	69fa      	ldr	r2, [r7, #28]
 8024132:	2102      	movs	r1, #2
 8024134:	68b8      	ldr	r0, [r7, #8]
 8024136:	f002 fa70 	bl	802661a <fp_sub_d>
 802413a:	4602      	mov	r2, r0
 802413c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802413e:	4313      	orrs	r3, r2
 8024140:	627b      	str	r3, [r7, #36]	@ 0x24
  /* Highest bit is always set. */
  j = 1;
 8024142:	2301      	movs	r3, #1
 8024144:	62bb      	str	r3, [r7, #40]	@ 0x28
  for (i = fp_count_bits(e)-2; i >= 0; i--) {
 8024146:	69f8      	ldr	r0, [r7, #28]
 8024148:	f002 f8c6 	bl	80262d8 <fp_count_bits>
 802414c:	4603      	mov	r3, r0
 802414e:	3b02      	subs	r3, #2
 8024150:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8024152:	e010      	b.n	8024176 <fp_invmod_mont_ct+0x172>
      if (!fp_is_bit_set(e, i) || j == CT_INV_MOD_PRE_CNT)
 8024154:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8024156:	4619      	mov	r1, r3
 8024158:	69f8      	ldr	r0, [r7, #28]
 802415a:	f002 f893 	bl	8026284 <fp_is_bit_set>
 802415e:	4603      	mov	r3, r0
 8024160:	2b00      	cmp	r3, #0
 8024162:	d00b      	beq.n	802417c <fp_invmod_mont_ct+0x178>
 8024164:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8024166:	2b08      	cmp	r3, #8
 8024168:	d008      	beq.n	802417c <fp_invmod_mont_ct+0x178>
          break;
      j++;
 802416a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802416c:	3301      	adds	r3, #1
 802416e:	62bb      	str	r3, [r7, #40]	@ 0x28
  for (i = fp_count_bits(e)-2; i >= 0; i--) {
 8024170:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8024172:	3b01      	subs	r3, #1
 8024174:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8024176:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8024178:	2b00      	cmp	r3, #0
 802417a:	daeb      	bge.n	8024154 <fp_invmod_mont_ct+0x150>
  }
  fp_copy(&pre[j-1], t);
 802417c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802417e:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024182:	fb02 f303 	mul.w	r3, r2, r3
 8024186:	f5a3 730b 	sub.w	r3, r3, #556	@ 0x22c
 802418a:	69ba      	ldr	r2, [r7, #24]
 802418c:	4413      	add	r3, r2
 802418e:	6a39      	ldr	r1, [r7, #32]
 8024190:	4618      	mov	r0, r3
 8024192:	f002 fc77 	bl	8026a84 <fp_copy>
  j = 0;
 8024196:	2300      	movs	r3, #0
 8024198:	62bb      	str	r3, [r7, #40]	@ 0x28
  for (; i >= 0; i--) {
 802419a:	e043      	b.n	8024224 <fp_invmod_mont_ct+0x220>
    int set = fp_is_bit_set(e, i);
 802419c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802419e:	4619      	mov	r1, r3
 80241a0:	69f8      	ldr	r0, [r7, #28]
 80241a2:	f002 f86f 	bl	8026284 <fp_is_bit_set>
 80241a6:	6138      	str	r0, [r7, #16]

    if ((j == CT_INV_MOD_PRE_CNT) || (!set && j > 0)) {
 80241a8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80241aa:	2b08      	cmp	r3, #8
 80241ac:	d005      	beq.n	80241ba <fp_invmod_mont_ct+0x1b6>
 80241ae:	693b      	ldr	r3, [r7, #16]
 80241b0:	2b00      	cmp	r3, #0
 80241b2:	d11f      	bne.n	80241f4 <fp_invmod_mont_ct+0x1f0>
 80241b4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80241b6:	2b00      	cmp	r3, #0
 80241b8:	dd1c      	ble.n	80241f4 <fp_invmod_mont_ct+0x1f0>
      err |= fp_mul(t, &pre[j-1], t);
 80241ba:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80241bc:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 80241c0:	fb02 f303 	mul.w	r3, r2, r3
 80241c4:	f5a3 730b 	sub.w	r3, r3, #556	@ 0x22c
 80241c8:	69ba      	ldr	r2, [r7, #24]
 80241ca:	4413      	add	r3, r2
 80241cc:	6a3a      	ldr	r2, [r7, #32]
 80241ce:	4619      	mov	r1, r3
 80241d0:	6a38      	ldr	r0, [r7, #32]
 80241d2:	f7fe fa64 	bl	802269e <fp_mul>
 80241d6:	4602      	mov	r2, r0
 80241d8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80241da:	4313      	orrs	r3, r2
 80241dc:	627b      	str	r3, [r7, #36]	@ 0x24
      err |= fp_montgomery_reduce(t, b, mp);
 80241de:	683a      	ldr	r2, [r7, #0]
 80241e0:	68b9      	ldr	r1, [r7, #8]
 80241e2:	6a38      	ldr	r0, [r7, #32]
 80241e4:	f001 febf 	bl	8025f66 <fp_montgomery_reduce>
 80241e8:	4602      	mov	r2, r0
 80241ea:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80241ec:	4313      	orrs	r3, r2
 80241ee:	627b      	str	r3, [r7, #36]	@ 0x24
      j = 0;
 80241f0:	2300      	movs	r3, #0
 80241f2:	62bb      	str	r3, [r7, #40]	@ 0x28
    }
    err |= fp_sqr(t, t);
 80241f4:	6a39      	ldr	r1, [r7, #32]
 80241f6:	6a38      	ldr	r0, [r7, #32]
 80241f8:	f001 f9f9 	bl	80255ee <fp_sqr>
 80241fc:	4602      	mov	r2, r0
 80241fe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024200:	4313      	orrs	r3, r2
 8024202:	627b      	str	r3, [r7, #36]	@ 0x24
    err |= fp_montgomery_reduce(t, b, mp);
 8024204:	683a      	ldr	r2, [r7, #0]
 8024206:	68b9      	ldr	r1, [r7, #8]
 8024208:	6a38      	ldr	r0, [r7, #32]
 802420a:	f001 feac 	bl	8025f66 <fp_montgomery_reduce>
 802420e:	4602      	mov	r2, r0
 8024210:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024212:	4313      	orrs	r3, r2
 8024214:	627b      	str	r3, [r7, #36]	@ 0x24
    j += set;
 8024216:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8024218:	693b      	ldr	r3, [r7, #16]
 802421a:	4413      	add	r3, r2
 802421c:	62bb      	str	r3, [r7, #40]	@ 0x28
  for (; i >= 0; i--) {
 802421e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8024220:	3b01      	subs	r3, #1
 8024222:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8024224:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8024226:	2b00      	cmp	r3, #0
 8024228:	dab8      	bge.n	802419c <fp_invmod_mont_ct+0x198>
  }
  if (j > 0) {
 802422a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802422c:	2b00      	cmp	r3, #0
 802422e:	dd1b      	ble.n	8024268 <fp_invmod_mont_ct+0x264>
    err |= fp_mul(t, &pre[j-1], c);
 8024230:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8024232:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024236:	fb02 f303 	mul.w	r3, r2, r3
 802423a:	f5a3 730b 	sub.w	r3, r3, #556	@ 0x22c
 802423e:	69ba      	ldr	r2, [r7, #24]
 8024240:	4413      	add	r3, r2
 8024242:	687a      	ldr	r2, [r7, #4]
 8024244:	4619      	mov	r1, r3
 8024246:	6a38      	ldr	r0, [r7, #32]
 8024248:	f7fe fa29 	bl	802269e <fp_mul>
 802424c:	4602      	mov	r2, r0
 802424e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024250:	4313      	orrs	r3, r2
 8024252:	627b      	str	r3, [r7, #36]	@ 0x24
    err |= fp_montgomery_reduce(c, b, mp);
 8024254:	683a      	ldr	r2, [r7, #0]
 8024256:	68b9      	ldr	r1, [r7, #8]
 8024258:	6878      	ldr	r0, [r7, #4]
 802425a:	f001 fe84 	bl	8025f66 <fp_montgomery_reduce>
 802425e:	4602      	mov	r2, r0
 8024260:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024262:	4313      	orrs	r3, r2
 8024264:	627b      	str	r3, [r7, #36]	@ 0x24
 8024266:	e003      	b.n	8024270 <fp_invmod_mont_ct+0x26c>
  }
  else
    fp_copy(t, c);
 8024268:	6879      	ldr	r1, [r7, #4]
 802426a:	6a38      	ldr	r0, [r7, #32]
 802426c:	f002 fc0a 	bl	8026a84 <fp_copy>

#ifdef WOLFSSL_SMALL_STACK
  XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
 8024270:	6a3b      	ldr	r3, [r7, #32]
 8024272:	617b      	str	r3, [r7, #20]
 8024274:	697b      	ldr	r3, [r7, #20]
 8024276:	2b00      	cmp	r3, #0
 8024278:	d002      	beq.n	8024280 <fp_invmod_mont_ct+0x27c>
 802427a:	6978      	ldr	r0, [r7, #20]
 802427c:	f7fa fc20 	bl	801eac0 <wolfSSL_Free>
#endif

  return err;
 8024280:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 8024282:	4618      	mov	r0, r3
 8024284:	3730      	adds	r7, #48	@ 0x30
 8024286:	46bd      	mov	sp, r7
 8024288:	bd80      	pop	{r7, pc}

0802428a <fp_mulmod>:

/* d = a * b (mod c) */
int fp_mulmod(fp_int *a, fp_int *b, fp_int *c, fp_int *d)
{
 802428a:	b580      	push	{r7, lr}
 802428c:	b088      	sub	sp, #32
 802428e:	af00      	add	r7, sp, #0
 8024290:	60f8      	str	r0, [r7, #12]
 8024292:	60b9      	str	r1, [r7, #8]
 8024294:	607a      	str	r2, [r7, #4]
 8024296:	603b      	str	r3, [r7, #0]
#else
   fp_int *t;
#endif

#ifdef WOLFSSL_SMALL_STACK
   t = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
 8024298:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 802429c:	f7fa fbf4 	bl	801ea88 <wolfSSL_Malloc>
 80242a0:	61b8      	str	r0, [r7, #24]
   if (t == NULL)
 80242a2:	69bb      	ldr	r3, [r7, #24]
 80242a4:	2b00      	cmp	r3, #0
 80242a6:	d102      	bne.n	80242ae <fp_mulmod+0x24>
       return FP_MEM;
 80242a8:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 80242ac:	e029      	b.n	8024302 <fp_mulmod+0x78>
#endif

  fp_init(t);
 80242ae:	69b8      	ldr	r0, [r7, #24]
 80242b0:	f002 f9fe 	bl	80266b0 <fp_init>
  err = fp_mul(a, b, t);
 80242b4:	69ba      	ldr	r2, [r7, #24]
 80242b6:	68b9      	ldr	r1, [r7, #8]
 80242b8:	68f8      	ldr	r0, [r7, #12]
 80242ba:	f7fe f9f0 	bl	802269e <fp_mul>
 80242be:	61f8      	str	r0, [r7, #28]
  if (err == FP_OKAY) {
 80242c0:	69fb      	ldr	r3, [r7, #28]
 80242c2:	2b00      	cmp	r3, #0
 80242c4:	d114      	bne.n	80242f0 <fp_mulmod+0x66>
  #if defined(ALT_ECC_SIZE) || defined(HAVE_WOLF_BIGINT)
    if (d->size < FP_SIZE) {
 80242c6:	683b      	ldr	r3, [r7, #0]
 80242c8:	689b      	ldr	r3, [r3, #8]
 80242ca:	2b87      	cmp	r3, #135	@ 0x87
 80242cc:	dc0a      	bgt.n	80242e4 <fp_mulmod+0x5a>
      err = fp_mod(t, c, t);
 80242ce:	69ba      	ldr	r2, [r7, #24]
 80242d0:	6879      	ldr	r1, [r7, #4]
 80242d2:	69b8      	ldr	r0, [r7, #24]
 80242d4:	f7ff f97c 	bl	80235d0 <fp_mod>
 80242d8:	61f8      	str	r0, [r7, #28]
      fp_copy(t, d);
 80242da:	6839      	ldr	r1, [r7, #0]
 80242dc:	69b8      	ldr	r0, [r7, #24]
 80242de:	f002 fbd1 	bl	8026a84 <fp_copy>
 80242e2:	e005      	b.n	80242f0 <fp_mulmod+0x66>
    } else
  #endif
    {
      err = fp_mod(t, c, d);
 80242e4:	683a      	ldr	r2, [r7, #0]
 80242e6:	6879      	ldr	r1, [r7, #4]
 80242e8:	69b8      	ldr	r0, [r7, #24]
 80242ea:	f7ff f971 	bl	80235d0 <fp_mod>
 80242ee:	61f8      	str	r0, [r7, #28]
    }
  }

#ifdef WOLFSSL_SMALL_STACK
  XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
 80242f0:	69bb      	ldr	r3, [r7, #24]
 80242f2:	617b      	str	r3, [r7, #20]
 80242f4:	697b      	ldr	r3, [r7, #20]
 80242f6:	2b00      	cmp	r3, #0
 80242f8:	d002      	beq.n	8024300 <fp_mulmod+0x76>
 80242fa:	6978      	ldr	r0, [r7, #20]
 80242fc:	f7fa fbe0 	bl	801eac0 <wolfSSL_Free>
#endif
  return err;
 8024300:	69fb      	ldr	r3, [r7, #28]
}
 8024302:	4618      	mov	r0, r3
 8024304:	3720      	adds	r7, #32
 8024306:	46bd      	mov	sp, r7
 8024308:	bd80      	pop	{r7, pc}

0802430a <fp_submod_ct>:

/* d = a - b (mod c) - constant time (a < c and b < c and all positive)
 * c and d must not be the same pointers.
 */
int fp_submod_ct(fp_int *a, fp_int *b, fp_int *c, fp_int *d)
{
 802430a:	e92d 0fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp}
 802430e:	b09b      	sub	sp, #108	@ 0x6c
 8024310:	af00      	add	r7, sp, #0
 8024312:	6578      	str	r0, [r7, #84]	@ 0x54
 8024314:	6539      	str	r1, [r7, #80]	@ 0x50
 8024316:	64fa      	str	r2, [r7, #76]	@ 0x4c
 8024318:	64bb      	str	r3, [r7, #72]	@ 0x48
  fp_sword w;
  fp_digit mask;
  int i;

  if (c->used + 1 > FP_SIZE) {
 802431a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802431c:	681b      	ldr	r3, [r3, #0]
 802431e:	2b87      	cmp	r3, #135	@ 0x87
 8024320:	dd02      	ble.n	8024328 <fp_submod_ct+0x1e>
    return FP_VAL;
 8024322:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8024326:	e106      	b.n	8024536 <fp_submod_ct+0x22c>
  }
  if (c == d) {
 8024328:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 802432a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802432c:	429a      	cmp	r2, r3
 802432e:	d102      	bne.n	8024336 <fp_submod_ct+0x2c>
    return FP_VAL;
 8024330:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8024334:	e0ff      	b.n	8024536 <fp_submod_ct+0x22c>
  }

  /* In constant time, subtract b from a putting result in d. */
  w = 0;
 8024336:	f04f 0200 	mov.w	r2, #0
 802433a:	f04f 0300 	mov.w	r3, #0
 802433e:	e9c7 2318 	strd	r2, r3, [r7, #96]	@ 0x60
  for (i = 0; i < c->used; i++) {
 8024342:	2300      	movs	r3, #0
 8024344:	65fb      	str	r3, [r7, #92]	@ 0x5c
 8024346:	e03e      	b.n	80243c6 <fp_submod_ct+0xbc>
    w         += a->dp[i];
 8024348:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 802434a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 802434c:	3302      	adds	r3, #2
 802434e:	009b      	lsls	r3, r3, #2
 8024350:	4413      	add	r3, r2
 8024352:	685b      	ldr	r3, [r3, #4]
 8024354:	2200      	movs	r2, #0
 8024356:	643b      	str	r3, [r7, #64]	@ 0x40
 8024358:	647a      	str	r2, [r7, #68]	@ 0x44
 802435a:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
 802435e:	6c39      	ldr	r1, [r7, #64]	@ 0x40
 8024360:	1851      	adds	r1, r2, r1
 8024362:	62b9      	str	r1, [r7, #40]	@ 0x28
 8024364:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 8024366:	414b      	adcs	r3, r1
 8024368:	62fb      	str	r3, [r7, #44]	@ 0x2c
 802436a:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	@ 0x28
 802436e:	e9c7 2318 	strd	r2, r3, [r7, #96]	@ 0x60
    w         -= b->dp[i];
 8024372:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 8024374:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8024376:	3302      	adds	r3, #2
 8024378:	009b      	lsls	r3, r3, #2
 802437a:	4413      	add	r3, r2
 802437c:	685b      	ldr	r3, [r3, #4]
 802437e:	2200      	movs	r2, #0
 8024380:	63bb      	str	r3, [r7, #56]	@ 0x38
 8024382:	63fa      	str	r2, [r7, #60]	@ 0x3c
 8024384:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
 8024388:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 802438a:	1a51      	subs	r1, r2, r1
 802438c:	6239      	str	r1, [r7, #32]
 802438e:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 8024390:	eb63 0301 	sbc.w	r3, r3, r1
 8024394:	627b      	str	r3, [r7, #36]	@ 0x24
 8024396:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 802439a:	e9c7 2318 	strd	r2, r3, [r7, #96]	@ 0x60
    d->dp[i]   = (fp_digit)w;
 802439e:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 80243a0:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80243a2:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80243a4:	3302      	adds	r3, #2
 80243a6:	009b      	lsls	r3, r3, #2
 80243a8:	4413      	add	r3, r2
 80243aa:	6059      	str	r1, [r3, #4]
    w        >>= DIGIT_BIT;
 80243ac:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
 80243b0:	f04f 0000 	mov.w	r0, #0
 80243b4:	f04f 0100 	mov.w	r1, #0
 80243b8:	0018      	movs	r0, r3
 80243ba:	17d9      	asrs	r1, r3, #31
 80243bc:	e9c7 0118 	strd	r0, r1, [r7, #96]	@ 0x60
  for (i = 0; i < c->used; i++) {
 80243c0:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80243c2:	3301      	adds	r3, #1
 80243c4:	65fb      	str	r3, [r7, #92]	@ 0x5c
 80243c6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80243c8:	681a      	ldr	r2, [r3, #0]
 80243ca:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80243cc:	4293      	cmp	r3, r2
 80243ce:	dbbb      	blt.n	8024348 <fp_submod_ct+0x3e>
  }
  w  += a->dp[i];
 80243d0:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 80243d2:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80243d4:	3302      	adds	r3, #2
 80243d6:	009b      	lsls	r3, r3, #2
 80243d8:	4413      	add	r3, r2
 80243da:	685b      	ldr	r3, [r3, #4]
 80243dc:	2200      	movs	r2, #0
 80243de:	461c      	mov	r4, r3
 80243e0:	4615      	mov	r5, r2
 80243e2:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
 80243e6:	1911      	adds	r1, r2, r4
 80243e8:	61b9      	str	r1, [r7, #24]
 80243ea:	416b      	adcs	r3, r5
 80243ec:	61fb      	str	r3, [r7, #28]
 80243ee:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
 80243f2:	e9c7 3418 	strd	r3, r4, [r7, #96]	@ 0x60
  w  -= b->dp[i];
 80243f6:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 80243f8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80243fa:	3302      	adds	r3, #2
 80243fc:	009b      	lsls	r3, r3, #2
 80243fe:	4413      	add	r3, r2
 8024400:	685b      	ldr	r3, [r3, #4]
 8024402:	2200      	movs	r2, #0
 8024404:	633b      	str	r3, [r7, #48]	@ 0x30
 8024406:	637a      	str	r2, [r7, #52]	@ 0x34
 8024408:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
 802440c:	e9d7 450c 	ldrd	r4, r5, [r7, #48]	@ 0x30
 8024410:	4621      	mov	r1, r4
 8024412:	1a51      	subs	r1, r2, r1
 8024414:	6139      	str	r1, [r7, #16]
 8024416:	4629      	mov	r1, r5
 8024418:	eb63 0301 	sbc.w	r3, r3, r1
 802441c:	617b      	str	r3, [r7, #20]
 802441e:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
 8024422:	e9c7 3418 	strd	r3, r4, [r7, #96]	@ 0x60
  w >>= DIGIT_BIT;
 8024426:	e9d7 0118 	ldrd	r0, r1, [r7, #96]	@ 0x60
 802442a:	f04f 0200 	mov.w	r2, #0
 802442e:	f04f 0300 	mov.w	r3, #0
 8024432:	000a      	movs	r2, r1
 8024434:	17cb      	asrs	r3, r1, #31
 8024436:	e9c7 2318 	strd	r2, r3, [r7, #96]	@ 0x60
  /* When w is negative then we need to add modulus to make result positive. */
  mask = (fp_digit)0 - (w < 0);
 802443a:	e9d7 0118 	ldrd	r0, r1, [r7, #96]	@ 0x60
 802443e:	f04f 0200 	mov.w	r2, #0
 8024442:	f04f 0300 	mov.w	r3, #0
 8024446:	0fca      	lsrs	r2, r1, #31
 8024448:	2300      	movs	r3, #0
 802444a:	b2d3      	uxtb	r3, r2
 802444c:	425b      	negs	r3, r3
 802444e:	65bb      	str	r3, [r7, #88]	@ 0x58
  /* Constant time, conditionally, add modulus to difference. */
  w = 0;
 8024450:	f04f 0200 	mov.w	r2, #0
 8024454:	f04f 0300 	mov.w	r3, #0
 8024458:	e9c7 2318 	strd	r2, r3, [r7, #96]	@ 0x60
  for (i = 0; i < c->used; i++) {
 802445c:	2300      	movs	r3, #0
 802445e:	65fb      	str	r3, [r7, #92]	@ 0x5c
 8024460:	e03f      	b.n	80244e2 <fp_submod_ct+0x1d8>
    w         += d->dp[i];
 8024462:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8024464:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8024466:	3302      	adds	r3, #2
 8024468:	009b      	lsls	r3, r3, #2
 802446a:	4413      	add	r3, r2
 802446c:	685b      	ldr	r3, [r3, #4]
 802446e:	2200      	movs	r2, #0
 8024470:	4698      	mov	r8, r3
 8024472:	4691      	mov	r9, r2
 8024474:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
 8024478:	eb12 0108 	adds.w	r1, r2, r8
 802447c:	60b9      	str	r1, [r7, #8]
 802447e:	eb43 0309 	adc.w	r3, r3, r9
 8024482:	60fb      	str	r3, [r7, #12]
 8024484:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
 8024488:	e9c7 3418 	strd	r3, r4, [r7, #96]	@ 0x60
    w         += c->dp[i] & mask;
 802448c:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 802448e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8024490:	3302      	adds	r3, #2
 8024492:	009b      	lsls	r3, r3, #2
 8024494:	4413      	add	r3, r2
 8024496:	685a      	ldr	r2, [r3, #4]
 8024498:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 802449a:	4013      	ands	r3, r2
 802449c:	2200      	movs	r2, #0
 802449e:	469a      	mov	sl, r3
 80244a0:	4693      	mov	fp, r2
 80244a2:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
 80244a6:	eb12 010a 	adds.w	r1, r2, sl
 80244aa:	6039      	str	r1, [r7, #0]
 80244ac:	eb43 030b 	adc.w	r3, r3, fp
 80244b0:	607b      	str	r3, [r7, #4]
 80244b2:	e9d7 3400 	ldrd	r3, r4, [r7]
 80244b6:	e9c7 3418 	strd	r3, r4, [r7, #96]	@ 0x60
    d->dp[i]   = (fp_digit)w;
 80244ba:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 80244bc:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
 80244be:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80244c0:	3302      	adds	r3, #2
 80244c2:	009b      	lsls	r3, r3, #2
 80244c4:	440b      	add	r3, r1
 80244c6:	605a      	str	r2, [r3, #4]
    w        >>= DIGIT_BIT;
 80244c8:	e9d7 0118 	ldrd	r0, r1, [r7, #96]	@ 0x60
 80244cc:	f04f 0200 	mov.w	r2, #0
 80244d0:	f04f 0300 	mov.w	r3, #0
 80244d4:	000a      	movs	r2, r1
 80244d6:	17cb      	asrs	r3, r1, #31
 80244d8:	e9c7 2318 	strd	r2, r3, [r7, #96]	@ 0x60
  for (i = 0; i < c->used; i++) {
 80244dc:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80244de:	3301      	adds	r3, #1
 80244e0:	65fb      	str	r3, [r7, #92]	@ 0x5c
 80244e2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80244e4:	681b      	ldr	r3, [r3, #0]
 80244e6:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 80244e8:	429a      	cmp	r2, r3
 80244ea:	dbba      	blt.n	8024462 <fp_submod_ct+0x158>
  }
  /* Result will always have digits equal to or less than those in modulus. */
  d->used = i;
 80244ec:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80244ee:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 80244f0:	601a      	str	r2, [r3, #0]
  d->sign = FP_ZPOS;
 80244f2:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80244f4:	2200      	movs	r2, #0
 80244f6:	605a      	str	r2, [r3, #4]
  fp_clamp(d);
 80244f8:	e004      	b.n	8024504 <fp_submod_ct+0x1fa>
 80244fa:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80244fc:	681b      	ldr	r3, [r3, #0]
 80244fe:	1e5a      	subs	r2, r3, #1
 8024500:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8024502:	601a      	str	r2, [r3, #0]
 8024504:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8024506:	681b      	ldr	r3, [r3, #0]
 8024508:	2b00      	cmp	r3, #0
 802450a:	d009      	beq.n	8024520 <fp_submod_ct+0x216>
 802450c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802450e:	681b      	ldr	r3, [r3, #0]
 8024510:	3b01      	subs	r3, #1
 8024512:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8024514:	3302      	adds	r3, #2
 8024516:	009b      	lsls	r3, r3, #2
 8024518:	4413      	add	r3, r2
 802451a:	685b      	ldr	r3, [r3, #4]
 802451c:	2b00      	cmp	r3, #0
 802451e:	d0ec      	beq.n	80244fa <fp_submod_ct+0x1f0>
 8024520:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8024522:	681b      	ldr	r3, [r3, #0]
 8024524:	2b00      	cmp	r3, #0
 8024526:	d002      	beq.n	802452e <fp_submod_ct+0x224>
 8024528:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802452a:	685b      	ldr	r3, [r3, #4]
 802452c:	e000      	b.n	8024530 <fp_submod_ct+0x226>
 802452e:	2300      	movs	r3, #0
 8024530:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8024532:	6053      	str	r3, [r2, #4]

  return FP_OKAY;
 8024534:	2300      	movs	r3, #0
}
 8024536:	4618      	mov	r0, r3
 8024538:	376c      	adds	r7, #108	@ 0x6c
 802453a:	46bd      	mov	sp, r7
 802453c:	e8bd 0fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp}
 8024540:	4770      	bx	lr

08024542 <fp_addmod_ct>:

/* d = a + b (mod c) - constant time (a < c and b < c and all positive)
 * c and d must not be the same pointers.
 */
int fp_addmod_ct(fp_int *a, fp_int *b, fp_int *c, fp_int *d)
{
 8024542:	e92d 0fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp}
 8024546:	b0a5      	sub	sp, #148	@ 0x94
 8024548:	af00      	add	r7, sp, #0
 802454a:	6778      	str	r0, [r7, #116]	@ 0x74
 802454c:	6739      	str	r1, [r7, #112]	@ 0x70
 802454e:	66fa      	str	r2, [r7, #108]	@ 0x6c
 8024550:	66bb      	str	r3, [r7, #104]	@ 0x68
  fp_word  w;
  fp_sword s;
  fp_digit mask;
  int i;

  if (c == d) {
 8024552:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8024554:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024556:	429a      	cmp	r2, r3
 8024558:	d102      	bne.n	8024560 <fp_addmod_ct+0x1e>
    return FP_VAL;
 802455a:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 802455e:	e11d      	b.n	802479c <fp_addmod_ct+0x25a>

  /* Add a to b into d. Do the subtract of modulus but don't store result.
   * When subtract result is negative, the overflow will be negative.
   * Only need to subtract mod when result is positive - overflow is positive.
   */
  w = 0;
 8024560:	f04f 0200 	mov.w	r2, #0
 8024564:	f04f 0300 	mov.w	r3, #0
 8024568:	e9c7 2322 	strd	r2, r3, [r7, #136]	@ 0x88
  s = 0;
 802456c:	f04f 0200 	mov.w	r2, #0
 8024570:	f04f 0300 	mov.w	r3, #0
 8024574:	e9c7 2320 	strd	r2, r3, [r7, #128]	@ 0x80
  for (i = 0; i < c->used; i++) {
 8024578:	2300      	movs	r3, #0
 802457a:	67fb      	str	r3, [r7, #124]	@ 0x7c
 802457c:	e06f      	b.n	802465e <fp_addmod_ct+0x11c>
    w         += a->dp[i];
 802457e:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8024580:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8024582:	3302      	adds	r3, #2
 8024584:	009b      	lsls	r3, r3, #2
 8024586:	4413      	add	r3, r2
 8024588:	685b      	ldr	r3, [r3, #4]
 802458a:	2200      	movs	r2, #0
 802458c:	663b      	str	r3, [r7, #96]	@ 0x60
 802458e:	667a      	str	r2, [r7, #100]	@ 0x64
 8024590:	e9d7 2322 	ldrd	r2, r3, [r7, #136]	@ 0x88
 8024594:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 8024596:	1851      	adds	r1, r2, r1
 8024598:	6439      	str	r1, [r7, #64]	@ 0x40
 802459a:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 802459c:	414b      	adcs	r3, r1
 802459e:	647b      	str	r3, [r7, #68]	@ 0x44
 80245a0:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	@ 0x40
 80245a4:	e9c7 2322 	strd	r2, r3, [r7, #136]	@ 0x88
    w         += b->dp[i];
 80245a8:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 80245aa:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 80245ac:	3302      	adds	r3, #2
 80245ae:	009b      	lsls	r3, r3, #2
 80245b0:	4413      	add	r3, r2
 80245b2:	685b      	ldr	r3, [r3, #4]
 80245b4:	2200      	movs	r2, #0
 80245b6:	65bb      	str	r3, [r7, #88]	@ 0x58
 80245b8:	65fa      	str	r2, [r7, #92]	@ 0x5c
 80245ba:	e9d7 2322 	ldrd	r2, r3, [r7, #136]	@ 0x88
 80245be:	6db9      	ldr	r1, [r7, #88]	@ 0x58
 80245c0:	1851      	adds	r1, r2, r1
 80245c2:	63b9      	str	r1, [r7, #56]	@ 0x38
 80245c4:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 80245c6:	414b      	adcs	r3, r1
 80245c8:	63fb      	str	r3, [r7, #60]	@ 0x3c
 80245ca:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	@ 0x38
 80245ce:	e9c7 2322 	strd	r2, r3, [r7, #136]	@ 0x88
    d->dp[i]   = (fp_digit)w;
 80245d2:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 80245d6:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 80245d8:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 80245da:	3302      	adds	r3, #2
 80245dc:	009b      	lsls	r3, r3, #2
 80245de:	4413      	add	r3, r2
 80245e0:	6059      	str	r1, [r3, #4]
    s         += (fp_digit)w;
 80245e2:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 80245e6:	2200      	movs	r2, #0
 80245e8:	653b      	str	r3, [r7, #80]	@ 0x50
 80245ea:	657a      	str	r2, [r7, #84]	@ 0x54
 80245ec:	e9d7 2320 	ldrd	r2, r3, [r7, #128]	@ 0x80
 80245f0:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 80245f2:	1851      	adds	r1, r2, r1
 80245f4:	6339      	str	r1, [r7, #48]	@ 0x30
 80245f6:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 80245f8:	414b      	adcs	r3, r1
 80245fa:	637b      	str	r3, [r7, #52]	@ 0x34
 80245fc:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	@ 0x30
 8024600:	e9c7 2320 	strd	r2, r3, [r7, #128]	@ 0x80
    s         -= c->dp[i];
 8024604:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8024606:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8024608:	3302      	adds	r3, #2
 802460a:	009b      	lsls	r3, r3, #2
 802460c:	4413      	add	r3, r2
 802460e:	685b      	ldr	r3, [r3, #4]
 8024610:	2200      	movs	r2, #0
 8024612:	64bb      	str	r3, [r7, #72]	@ 0x48
 8024614:	64fa      	str	r2, [r7, #76]	@ 0x4c
 8024616:	e9d7 2320 	ldrd	r2, r3, [r7, #128]	@ 0x80
 802461a:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
 802461c:	1a51      	subs	r1, r2, r1
 802461e:	62b9      	str	r1, [r7, #40]	@ 0x28
 8024620:	6cf9      	ldr	r1, [r7, #76]	@ 0x4c
 8024622:	eb63 0301 	sbc.w	r3, r3, r1
 8024626:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8024628:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	@ 0x28
 802462c:	e9c7 2320 	strd	r2, r3, [r7, #128]	@ 0x80
    w        >>= DIGIT_BIT;
 8024630:	e9d7 2322 	ldrd	r2, r3, [r7, #136]	@ 0x88
 8024634:	f04f 0000 	mov.w	r0, #0
 8024638:	f04f 0100 	mov.w	r1, #0
 802463c:	0018      	movs	r0, r3
 802463e:	2100      	movs	r1, #0
 8024640:	e9c7 0122 	strd	r0, r1, [r7, #136]	@ 0x88
    s        >>= DIGIT_BIT;
 8024644:	e9d7 2320 	ldrd	r2, r3, [r7, #128]	@ 0x80
 8024648:	f04f 0000 	mov.w	r0, #0
 802464c:	f04f 0100 	mov.w	r1, #0
 8024650:	0018      	movs	r0, r3
 8024652:	17d9      	asrs	r1, r3, #31
 8024654:	e9c7 0120 	strd	r0, r1, [r7, #128]	@ 0x80
  for (i = 0; i < c->used; i++) {
 8024658:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 802465a:	3301      	adds	r3, #1
 802465c:	67fb      	str	r3, [r7, #124]	@ 0x7c
 802465e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024660:	681a      	ldr	r2, [r3, #0]
 8024662:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8024664:	4293      	cmp	r3, r2
 8024666:	db8a      	blt.n	802457e <fp_addmod_ct+0x3c>
  }
  s += (fp_digit)w;
 8024668:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 802466c:	2200      	movs	r2, #0
 802466e:	469a      	mov	sl, r3
 8024670:	4693      	mov	fp, r2
 8024672:	e9d7 2320 	ldrd	r2, r3, [r7, #128]	@ 0x80
 8024676:	eb12 010a 	adds.w	r1, r2, sl
 802467a:	6239      	str	r1, [r7, #32]
 802467c:	eb43 030b 	adc.w	r3, r3, fp
 8024680:	627b      	str	r3, [r7, #36]	@ 0x24
 8024682:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8024686:	e9c7 2320 	strd	r2, r3, [r7, #128]	@ 0x80
  /* s will be positive when subtracting modulus is needed. */
  mask = (fp_digit)0 - (s >= 0);
 802468a:	e9d7 2320 	ldrd	r2, r3, [r7, #128]	@ 0x80
 802468e:	43d1      	mvns	r1, r2
 8024690:	61b9      	str	r1, [r7, #24]
 8024692:	43db      	mvns	r3, r3
 8024694:	61fb      	str	r3, [r7, #28]
 8024696:	f04f 0200 	mov.w	r2, #0
 802469a:	f04f 0300 	mov.w	r3, #0
 802469e:	69f9      	ldr	r1, [r7, #28]
 80246a0:	0fca      	lsrs	r2, r1, #31
 80246a2:	2300      	movs	r3, #0
 80246a4:	b2d3      	uxtb	r3, r2
 80246a6:	425b      	negs	r3, r3
 80246a8:	67bb      	str	r3, [r7, #120]	@ 0x78

  /* Constant time, conditionally, subtract modulus from sum. */
  w = 0;
 80246aa:	f04f 0200 	mov.w	r2, #0
 80246ae:	f04f 0300 	mov.w	r3, #0
 80246b2:	e9c7 2322 	strd	r2, r3, [r7, #136]	@ 0x88
  for (i = 0; i < c->used; i++) {
 80246b6:	2300      	movs	r3, #0
 80246b8:	67fb      	str	r3, [r7, #124]	@ 0x7c
 80246ba:	e045      	b.n	8024748 <fp_addmod_ct+0x206>
    w        += c->dp[i] & mask;
 80246bc:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 80246be:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 80246c0:	3302      	adds	r3, #2
 80246c2:	009b      	lsls	r3, r3, #2
 80246c4:	4413      	add	r3, r2
 80246c6:	685a      	ldr	r2, [r3, #4]
 80246c8:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 80246ca:	4013      	ands	r3, r2
 80246cc:	2200      	movs	r2, #0
 80246ce:	461c      	mov	r4, r3
 80246d0:	4615      	mov	r5, r2
 80246d2:	e9d7 2322 	ldrd	r2, r3, [r7, #136]	@ 0x88
 80246d6:	1911      	adds	r1, r2, r4
 80246d8:	6139      	str	r1, [r7, #16]
 80246da:	416b      	adcs	r3, r5
 80246dc:	617b      	str	r3, [r7, #20]
 80246de:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 80246e2:	e9c7 2322 	strd	r2, r3, [r7, #136]	@ 0x88
    w         = d->dp[i] - w;
 80246e6:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 80246e8:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 80246ea:	3302      	adds	r3, #2
 80246ec:	009b      	lsls	r3, r3, #2
 80246ee:	4413      	add	r3, r2
 80246f0:	685b      	ldr	r3, [r3, #4]
 80246f2:	2200      	movs	r2, #0
 80246f4:	4698      	mov	r8, r3
 80246f6:	4691      	mov	r9, r2
 80246f8:	e9d7 2322 	ldrd	r2, r3, [r7, #136]	@ 0x88
 80246fc:	ebb8 0102 	subs.w	r1, r8, r2
 8024700:	60b9      	str	r1, [r7, #8]
 8024702:	eb69 0303 	sbc.w	r3, r9, r3
 8024706:	60fb      	str	r3, [r7, #12]
 8024708:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 802470c:	e9c7 2322 	strd	r2, r3, [r7, #136]	@ 0x88
    d->dp[i]  = (fp_digit)w;
 8024710:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 8024714:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 8024716:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8024718:	3302      	adds	r3, #2
 802471a:	009b      	lsls	r3, r3, #2
 802471c:	440b      	add	r3, r1
 802471e:	605a      	str	r2, [r3, #4]
    w         = (w >> DIGIT_BIT)&1;
 8024720:	e9d7 0122 	ldrd	r0, r1, [r7, #136]	@ 0x88
 8024724:	f04f 0200 	mov.w	r2, #0
 8024728:	f04f 0300 	mov.w	r3, #0
 802472c:	000a      	movs	r2, r1
 802472e:	2300      	movs	r3, #0
 8024730:	f002 0301 	and.w	r3, r2, #1
 8024734:	603b      	str	r3, [r7, #0]
 8024736:	2300      	movs	r3, #0
 8024738:	607b      	str	r3, [r7, #4]
 802473a:	e9d7 2300 	ldrd	r2, r3, [r7]
 802473e:	e9c7 2322 	strd	r2, r3, [r7, #136]	@ 0x88
  for (i = 0; i < c->used; i++) {
 8024742:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8024744:	3301      	adds	r3, #1
 8024746:	67fb      	str	r3, [r7, #124]	@ 0x7c
 8024748:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 802474a:	681b      	ldr	r3, [r3, #0]
 802474c:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 802474e:	429a      	cmp	r2, r3
 8024750:	dbb4      	blt.n	80246bc <fp_addmod_ct+0x17a>
  }
  /* Result will always have digits equal to or less than those in modulus. */
  d->used = i;
 8024752:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024754:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 8024756:	601a      	str	r2, [r3, #0]
  d->sign = FP_ZPOS;
 8024758:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 802475a:	2200      	movs	r2, #0
 802475c:	605a      	str	r2, [r3, #4]
  fp_clamp(d);
 802475e:	e004      	b.n	802476a <fp_addmod_ct+0x228>
 8024760:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024762:	681b      	ldr	r3, [r3, #0]
 8024764:	1e5a      	subs	r2, r3, #1
 8024766:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024768:	601a      	str	r2, [r3, #0]
 802476a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 802476c:	681b      	ldr	r3, [r3, #0]
 802476e:	2b00      	cmp	r3, #0
 8024770:	d009      	beq.n	8024786 <fp_addmod_ct+0x244>
 8024772:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024774:	681b      	ldr	r3, [r3, #0]
 8024776:	3b01      	subs	r3, #1
 8024778:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 802477a:	3302      	adds	r3, #2
 802477c:	009b      	lsls	r3, r3, #2
 802477e:	4413      	add	r3, r2
 8024780:	685b      	ldr	r3, [r3, #4]
 8024782:	2b00      	cmp	r3, #0
 8024784:	d0ec      	beq.n	8024760 <fp_addmod_ct+0x21e>
 8024786:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024788:	681b      	ldr	r3, [r3, #0]
 802478a:	2b00      	cmp	r3, #0
 802478c:	d002      	beq.n	8024794 <fp_addmod_ct+0x252>
 802478e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024790:	685b      	ldr	r3, [r3, #4]
 8024792:	e000      	b.n	8024796 <fp_addmod_ct+0x254>
 8024794:	2300      	movs	r3, #0
 8024796:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8024798:	6053      	str	r3, [r2, #4]

  return FP_OKAY;
 802479a:	2300      	movs	r3, #0
}
 802479c:	4618      	mov	r0, r3
 802479e:	3794      	adds	r7, #148	@ 0x94
 80247a0:	46bd      	mov	sp, r7
 80247a2:	e8bd 0fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp}
 80247a6:	4770      	bx	lr

080247a8 <_fp_exptmod_ct>:
   Based on work by Marc Joye, Sung-Ming Yen, "The Montgomery Powering Ladder",
   Cryptographic Hardware and Embedded Systems, CHES 2002
*/
static int _fp_exptmod_ct(fp_int * G, fp_int * X, int digits, fp_int * P,
                          fp_int * Y)
{
 80247a8:	b590      	push	{r4, r7, lr}
 80247aa:	b095      	sub	sp, #84	@ 0x54
 80247ac:	af00      	add	r7, sp, #0
 80247ae:	60f8      	str	r0, [r7, #12]
 80247b0:	60b9      	str	r1, [r7, #8]
 80247b2:	607a      	str	r2, [r7, #4]
 80247b4:	603b      	str	r3, [r7, #0]
#endif
  fp_digit buf, mp;
  int      err, bitcnt, digidx, y;

  /* now setup montgomery  */
  if ((err = fp_montgomery_setup (P, &mp)) != FP_OKAY) {
 80247b6:	f107 0314 	add.w	r3, r7, #20
 80247ba:	4619      	mov	r1, r3
 80247bc:	6838      	ldr	r0, [r7, #0]
 80247be:	f001 fa0b 	bl	8025bd8 <fp_montgomery_setup>
 80247c2:	6438      	str	r0, [r7, #64]	@ 0x40
 80247c4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80247c6:	2b00      	cmp	r3, #0
 80247c8:	d001      	beq.n	80247ce <_fp_exptmod_ct+0x26>
     return err;
 80247ca:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80247cc:	e146      	b.n	8024a5c <_fp_exptmod_ct+0x2b4>
  }

#ifdef WOLFSSL_SMALL_STACK
#ifndef WC_NO_CACHE_RESISTANT
   R = (fp_int*)XMALLOC(sizeof(fp_int) * 3, NULL, DYNAMIC_TYPE_BIGINT);
 80247ce:	f240 6084 	movw	r0, #1668	@ 0x684
 80247d2:	f7fa f959 	bl	801ea88 <wolfSSL_Malloc>
 80247d6:	63f8      	str	r0, [r7, #60]	@ 0x3c
#else
   R = (fp_int*)XMALLOC(sizeof(fp_int) * 2, NULL, DYNAMIC_TYPE_BIGINT);
#endif
   if (R == NULL)
 80247d8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80247da:	2b00      	cmp	r3, #0
 80247dc:	d102      	bne.n	80247e4 <_fp_exptmod_ct+0x3c>
       return FP_MEM;
 80247de:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 80247e2:	e13b      	b.n	8024a5c <_fp_exptmod_ct+0x2b4>
#endif
  fp_init(&R[0]);
 80247e4:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 80247e6:	f001 ff63 	bl	80266b0 <fp_init>
  fp_init(&R[1]);
 80247ea:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80247ec:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 80247f0:	4618      	mov	r0, r3
 80247f2:	f001 ff5d 	bl	80266b0 <fp_init>
#ifndef WC_NO_CACHE_RESISTANT
  fp_init(&R[2]);
 80247f6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80247f8:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 80247fc:	4618      	mov	r0, r3
 80247fe:	f001 ff57 	bl	80266b0 <fp_init>
#endif

  /* now we need R mod m */
  err = fp_montgomery_calc_normalization (&R[0], P);
 8024802:	6839      	ldr	r1, [r7, #0]
 8024804:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8024806:	f001 fa28 	bl	8025c5a <fp_montgomery_calc_normalization>
 802480a:	6438      	str	r0, [r7, #64]	@ 0x40
  if (err != FP_OKAY) {
 802480c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802480e:	2b00      	cmp	r3, #0
 8024810:	d009      	beq.n	8024826 <_fp_exptmod_ct+0x7e>
  #ifdef WOLFSSL_SMALL_STACK
    XFREE(R, NULL, DYNAMIC_TYPE_BIGINT);
 8024812:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024814:	61bb      	str	r3, [r7, #24]
 8024816:	69bb      	ldr	r3, [r7, #24]
 8024818:	2b00      	cmp	r3, #0
 802481a:	d002      	beq.n	8024822 <_fp_exptmod_ct+0x7a>
 802481c:	69b8      	ldr	r0, [r7, #24]
 802481e:	f7fa f94f 	bl	801eac0 <wolfSSL_Free>
  #endif
    return err;
 8024822:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8024824:	e11a      	b.n	8024a5c <_fp_exptmod_ct+0x2b4>
  }

  /* now set R[0][1] to G * R mod m */
  if (fp_cmp_mag(P, G) != FP_GT) {
 8024826:	68f9      	ldr	r1, [r7, #12]
 8024828:	6838      	ldr	r0, [r7, #0]
 802482a:	f001 f98c 	bl	8025b46 <fp_cmp_mag>
 802482e:	4603      	mov	r3, r0
 8024830:	2b01      	cmp	r3, #1
 8024832:	d015      	beq.n	8024860 <_fp_exptmod_ct+0xb8>
     /* G > P so we reduce it first */
     err = fp_mod(G, P, &R[1]);
 8024834:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024836:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 802483a:	461a      	mov	r2, r3
 802483c:	6839      	ldr	r1, [r7, #0]
 802483e:	68f8      	ldr	r0, [r7, #12]
 8024840:	f7fe fec6 	bl	80235d0 <fp_mod>
 8024844:	6438      	str	r0, [r7, #64]	@ 0x40
     if (err != FP_OKAY) {
 8024846:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8024848:	2b00      	cmp	r3, #0
 802484a:	d010      	beq.n	802486e <_fp_exptmod_ct+0xc6>
#ifdef WOLFSSL_SMALL_STACK
         XFREE(R, NULL, DYNAMIC_TYPE_BIGINT);
 802484c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802484e:	63bb      	str	r3, [r7, #56]	@ 0x38
 8024850:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8024852:	2b00      	cmp	r3, #0
 8024854:	d002      	beq.n	802485c <_fp_exptmod_ct+0xb4>
 8024856:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 8024858:	f7fa f932 	bl	801eac0 <wolfSSL_Free>
#endif
         return err;
 802485c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802485e:	e0fd      	b.n	8024a5c <_fp_exptmod_ct+0x2b4>
     }
  } else {
     fp_copy(G, &R[1]);
 8024860:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024862:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8024866:	4619      	mov	r1, r3
 8024868:	68f8      	ldr	r0, [r7, #12]
 802486a:	f002 f90b 	bl	8026a84 <fp_copy>
  }
  err = fp_mulmod (&R[1], &R[0], P, &R[1]);
 802486e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024870:	f503 700b 	add.w	r0, r3, #556	@ 0x22c
 8024874:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024876:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 802487a:	683a      	ldr	r2, [r7, #0]
 802487c:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 802487e:	f7ff fd04 	bl	802428a <fp_mulmod>
 8024882:	6438      	str	r0, [r7, #64]	@ 0x40
  if (err != FP_OKAY) {
 8024884:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8024886:	2b00      	cmp	r3, #0
 8024888:	d009      	beq.n	802489e <_fp_exptmod_ct+0xf6>
#ifdef WOLFSSL_SMALL_STACK
      XFREE(R, NULL, DYNAMIC_TYPE_BIGINT);
 802488a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802488c:	61fb      	str	r3, [r7, #28]
 802488e:	69fb      	ldr	r3, [r7, #28]
 8024890:	2b00      	cmp	r3, #0
 8024892:	d002      	beq.n	802489a <_fp_exptmod_ct+0xf2>
 8024894:	69f8      	ldr	r0, [r7, #28]
 8024896:	f7fa f913 	bl	801eac0 <wolfSSL_Free>
#endif
      return err;
 802489a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802489c:	e0de      	b.n	8024a5c <_fp_exptmod_ct+0x2b4>
  /* for j = t-1 downto 0 do
        r_!k = R0*R1; r_k = r_k^2
  */

  /* set initial mode and bit cnt */
  bitcnt = 1;
 802489e:	2301      	movs	r3, #1
 80248a0:	64bb      	str	r3, [r7, #72]	@ 0x48
  buf    = 0;
 80248a2:	2300      	movs	r3, #0
 80248a4:	64fb      	str	r3, [r7, #76]	@ 0x4c
  digidx = digits - 1;
 80248a6:	687b      	ldr	r3, [r7, #4]
 80248a8:	3b01      	subs	r3, #1
 80248aa:	647b      	str	r3, [r7, #68]	@ 0x44

  for (;;) {
    /* grab next digit as required */
    if (--bitcnt == 0) {
 80248ac:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80248ae:	3b01      	subs	r3, #1
 80248b0:	64bb      	str	r3, [r7, #72]	@ 0x48
 80248b2:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80248b4:	2b00      	cmp	r3, #0
 80248b6:	d10f      	bne.n	80248d8 <_fp_exptmod_ct+0x130>
      /* if digidx == -1 we are out of digits so break */
      if (digidx == -1) {
 80248b8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80248ba:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 80248be:	f000 80b8 	beq.w	8024a32 <_fp_exptmod_ct+0x28a>
        break;
      }
      /* read next digit and reset bitcnt */
      buf    = X->dp[digidx--];
 80248c2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80248c4:	1e5a      	subs	r2, r3, #1
 80248c6:	647a      	str	r2, [r7, #68]	@ 0x44
 80248c8:	68ba      	ldr	r2, [r7, #8]
 80248ca:	3302      	adds	r3, #2
 80248cc:	009b      	lsls	r3, r3, #2
 80248ce:	4413      	add	r3, r2
 80248d0:	685b      	ldr	r3, [r3, #4]
 80248d2:	64fb      	str	r3, [r7, #76]	@ 0x4c
      bitcnt = (int)DIGIT_BIT;
 80248d4:	2320      	movs	r3, #32
 80248d6:	64bb      	str	r3, [r7, #72]	@ 0x48
    }

    /* grab the next msb from the exponent */
    y     = (int)(buf >> (DIGIT_BIT - 1)) & 1;
 80248d8:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80248da:	0fdb      	lsrs	r3, r3, #31
 80248dc:	633b      	str	r3, [r7, #48]	@ 0x30
    buf <<= (fp_digit)1;
 80248de:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80248e0:	005b      	lsls	r3, r3, #1
 80248e2:	64fb      	str	r3, [r7, #76]	@ 0x4c
    #endif
      return err;
    }
#else
    /* do ops */
    err = fp_mul(&R[0], &R[1], &R[2]);
 80248e4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80248e6:	f503 710b 	add.w	r1, r3, #556	@ 0x22c
 80248ea:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80248ec:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 80248f0:	461a      	mov	r2, r3
 80248f2:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 80248f4:	f7fd fed3 	bl	802269e <fp_mul>
 80248f8:	6438      	str	r0, [r7, #64]	@ 0x40
    if (err != FP_OKAY) {
 80248fa:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80248fc:	2b00      	cmp	r3, #0
 80248fe:	d009      	beq.n	8024914 <_fp_exptmod_ct+0x16c>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(R, NULL, DYNAMIC_TYPE_BIGINT);
 8024900:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024902:	623b      	str	r3, [r7, #32]
 8024904:	6a3b      	ldr	r3, [r7, #32]
 8024906:	2b00      	cmp	r3, #0
 8024908:	d002      	beq.n	8024910 <_fp_exptmod_ct+0x168>
 802490a:	6a38      	ldr	r0, [r7, #32]
 802490c:	f7fa f8d8 	bl	801eac0 <wolfSSL_Free>
    #endif
      return err;
 8024910:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8024912:	e0a3      	b.n	8024a5c <_fp_exptmod_ct+0x2b4>
    }
    err = fp_montgomery_reduce(&R[2], P, mp);
 8024914:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024916:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 802491a:	697a      	ldr	r2, [r7, #20]
 802491c:	6839      	ldr	r1, [r7, #0]
 802491e:	4618      	mov	r0, r3
 8024920:	f001 fb21 	bl	8025f66 <fp_montgomery_reduce>
 8024924:	6438      	str	r0, [r7, #64]	@ 0x40
    if (err != FP_OKAY) {
 8024926:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8024928:	2b00      	cmp	r3, #0
 802492a:	d009      	beq.n	8024940 <_fp_exptmod_ct+0x198>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(R, NULL, DYNAMIC_TYPE_BIGINT);
 802492c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802492e:	627b      	str	r3, [r7, #36]	@ 0x24
 8024930:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024932:	2b00      	cmp	r3, #0
 8024934:	d002      	beq.n	802493c <_fp_exptmod_ct+0x194>
 8024936:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8024938:	f7fa f8c2 	bl	801eac0 <wolfSSL_Free>
    #endif
      return err;
 802493c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802493e:	e08d      	b.n	8024a5c <_fp_exptmod_ct+0x2b4>
    }
    /* instead of using R[y^1] for mul, which leaks key bit to cache monitor,
     * use R[2] as temp, make sure address calc is constant, keep
     * &R[0] and &R[1] in cache */
    fp_copy(&R[2],
 8024940:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024942:	f503 608b 	add.w	r0, r3, #1112	@ 0x458
            (fp_int*) ( ((wc_ptr_t)&R[0] & wc_off_on_addr[y]) +
 8024946:	4a47      	ldr	r2, [pc, #284]	@ (8024a64 <_fp_exptmod_ct+0x2bc>)
 8024948:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802494a:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 802494e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024950:	401a      	ands	r2, r3
                        ((wc_ptr_t)&R[1] & wc_off_on_addr[y^1]) ) );
 8024952:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024954:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8024958:	461c      	mov	r4, r3
 802495a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802495c:	f083 0301 	eor.w	r3, r3, #1
 8024960:	4940      	ldr	r1, [pc, #256]	@ (8024a64 <_fp_exptmod_ct+0x2bc>)
 8024962:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8024966:	4023      	ands	r3, r4
            (fp_int*) ( ((wc_ptr_t)&R[0] & wc_off_on_addr[y]) +
 8024968:	4413      	add	r3, r2
    fp_copy(&R[2],
 802496a:	4619      	mov	r1, r3
 802496c:	f002 f88a 	bl	8026a84 <fp_copy>

    /* instead of using R[y] for sqr, which leaks key bit to cache monitor,
     * use R[2] as temp, make sure address calc is constant, keep
     * &R[0] and &R[1] in cache */
    fp_copy((fp_int*) ( ((wc_ptr_t)&R[0] & wc_off_on_addr[y^1]) +
 8024970:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8024972:	f083 0301 	eor.w	r3, r3, #1
 8024976:	4a3b      	ldr	r2, [pc, #236]	@ (8024a64 <_fp_exptmod_ct+0x2bc>)
 8024978:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 802497c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802497e:	401a      	ands	r2, r3
                        ((wc_ptr_t)&R[1] & wc_off_on_addr[y]) ),
 8024980:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024982:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8024986:	4618      	mov	r0, r3
 8024988:	4936      	ldr	r1, [pc, #216]	@ (8024a64 <_fp_exptmod_ct+0x2bc>)
 802498a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802498c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8024990:	4003      	ands	r3, r0
    fp_copy((fp_int*) ( ((wc_ptr_t)&R[0] & wc_off_on_addr[y^1]) +
 8024992:	4413      	add	r3, r2
 8024994:	461a      	mov	r2, r3
 8024996:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024998:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 802499c:	4619      	mov	r1, r3
 802499e:	4610      	mov	r0, r2
 80249a0:	f002 f870 	bl	8026a84 <fp_copy>
            &R[2]);
    err = fp_sqr(&R[2], &R[2]);
 80249a4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80249a6:	f503 628b 	add.w	r2, r3, #1112	@ 0x458
 80249aa:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80249ac:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 80249b0:	4619      	mov	r1, r3
 80249b2:	4610      	mov	r0, r2
 80249b4:	f000 fe1b 	bl	80255ee <fp_sqr>
 80249b8:	6438      	str	r0, [r7, #64]	@ 0x40
    if (err != FP_OKAY) {
 80249ba:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80249bc:	2b00      	cmp	r3, #0
 80249be:	d009      	beq.n	80249d4 <_fp_exptmod_ct+0x22c>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(R, NULL, DYNAMIC_TYPE_BIGINT);
 80249c0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80249c2:	62bb      	str	r3, [r7, #40]	@ 0x28
 80249c4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80249c6:	2b00      	cmp	r3, #0
 80249c8:	d002      	beq.n	80249d0 <_fp_exptmod_ct+0x228>
 80249ca:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 80249cc:	f7fa f878 	bl	801eac0 <wolfSSL_Free>
    #endif
      return err;
 80249d0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80249d2:	e043      	b.n	8024a5c <_fp_exptmod_ct+0x2b4>
    }
    err = fp_montgomery_reduce(&R[2], P, mp);
 80249d4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80249d6:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 80249da:	697a      	ldr	r2, [r7, #20]
 80249dc:	6839      	ldr	r1, [r7, #0]
 80249de:	4618      	mov	r0, r3
 80249e0:	f001 fac1 	bl	8025f66 <fp_montgomery_reduce>
 80249e4:	6438      	str	r0, [r7, #64]	@ 0x40
    if (err != FP_OKAY) {
 80249e6:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80249e8:	2b00      	cmp	r3, #0
 80249ea:	d009      	beq.n	8024a00 <_fp_exptmod_ct+0x258>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(R, NULL, DYNAMIC_TYPE_BIGINT);
 80249ec:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80249ee:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80249f0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80249f2:	2b00      	cmp	r3, #0
 80249f4:	d002      	beq.n	80249fc <_fp_exptmod_ct+0x254>
 80249f6:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 80249f8:	f7fa f862 	bl	801eac0 <wolfSSL_Free>
    #endif
      return err;
 80249fc:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80249fe:	e02d      	b.n	8024a5c <_fp_exptmod_ct+0x2b4>
    }
    fp_copy(&R[2],
 8024a00:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024a02:	f503 608b 	add.w	r0, r3, #1112	@ 0x458
            (fp_int*) ( ((wc_ptr_t)&R[0] & wc_off_on_addr[y^1]) +
 8024a06:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8024a08:	f083 0301 	eor.w	r3, r3, #1
 8024a0c:	4a15      	ldr	r2, [pc, #84]	@ (8024a64 <_fp_exptmod_ct+0x2bc>)
 8024a0e:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8024a12:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024a14:	401a      	ands	r2, r3
                        ((wc_ptr_t)&R[1] & wc_off_on_addr[y]) ) );
 8024a16:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024a18:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8024a1c:	461c      	mov	r4, r3
 8024a1e:	4911      	ldr	r1, [pc, #68]	@ (8024a64 <_fp_exptmod_ct+0x2bc>)
 8024a20:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8024a22:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8024a26:	4023      	ands	r3, r4
            (fp_int*) ( ((wc_ptr_t)&R[0] & wc_off_on_addr[y^1]) +
 8024a28:	4413      	add	r3, r2
    fp_copy(&R[2],
 8024a2a:	4619      	mov	r1, r3
 8024a2c:	f002 f82a 	bl	8026a84 <fp_copy>
    if (--bitcnt == 0) {
 8024a30:	e73c      	b.n	80248ac <_fp_exptmod_ct+0x104>
        break;
 8024a32:	bf00      	nop
#endif /* WC_NO_CACHE_RESISTANT */
  }

   err = fp_montgomery_reduce(&R[0], P, mp);
 8024a34:	697b      	ldr	r3, [r7, #20]
 8024a36:	461a      	mov	r2, r3
 8024a38:	6839      	ldr	r1, [r7, #0]
 8024a3a:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8024a3c:	f001 fa93 	bl	8025f66 <fp_montgomery_reduce>
 8024a40:	6438      	str	r0, [r7, #64]	@ 0x40
   fp_copy(&R[0], Y);
 8024a42:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 8024a44:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8024a46:	f002 f81d 	bl	8026a84 <fp_copy>
#ifdef WOLFSSL_SMALL_STACK
   XFREE(R, NULL, DYNAMIC_TYPE_BIGINT);
 8024a4a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024a4c:	637b      	str	r3, [r7, #52]	@ 0x34
 8024a4e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8024a50:	2b00      	cmp	r3, #0
 8024a52:	d002      	beq.n	8024a5a <_fp_exptmod_ct+0x2b2>
 8024a54:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 8024a56:	f7fa f833 	bl	801eac0 <wolfSSL_Free>
#endif

   return err;
 8024a5a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
}
 8024a5c:	4618      	mov	r0, r3
 8024a5e:	3754      	adds	r7, #84	@ 0x54
 8024a60:	46bd      	mov	sp, r7
 8024a62:	bd90      	pop	{r4, r7, pc}
 8024a64:	08033e00 	.word	0x08033e00

08024a68 <_fp_exptmod_nct>:

/* y = g**x (mod b)
 * Some restrictions... x must be positive and < b
 */
static int _fp_exptmod_nct(fp_int * G, fp_int * X, fp_int * P, fp_int * Y)
{
 8024a68:	b580      	push	{r7, lr}
 8024a6a:	b0a4      	sub	sp, #144	@ 0x90
 8024a6c:	af00      	add	r7, sp, #0
 8024a6e:	60f8      	str	r0, [r7, #12]
 8024a70:	60b9      	str	r1, [r7, #8]
 8024a72:	607a      	str	r2, [r7, #4]
 8024a74:	603b      	str	r3, [r7, #0]
#else
  fp_int   M[(1 << 6) + 1];
#endif

  /* find window size */
  x = fp_count_bits (X);
 8024a76:	68b8      	ldr	r0, [r7, #8]
 8024a78:	f001 fc2e 	bl	80262d8 <fp_count_bits>
 8024a7c:	6778      	str	r0, [r7, #116]	@ 0x74
  if (x <= 21) {
 8024a7e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8024a80:	2b15      	cmp	r3, #21
 8024a82:	dc02      	bgt.n	8024a8a <_fp_exptmod_nct+0x22>
    winsize = 1;
 8024a84:	2301      	movs	r3, #1
 8024a86:	673b      	str	r3, [r7, #112]	@ 0x70
 8024a88:	e014      	b.n	8024ab4 <_fp_exptmod_nct+0x4c>
  } else if (x <= 36) {
 8024a8a:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8024a8c:	2b24      	cmp	r3, #36	@ 0x24
 8024a8e:	dc02      	bgt.n	8024a96 <_fp_exptmod_nct+0x2e>
    winsize = 3;
 8024a90:	2303      	movs	r3, #3
 8024a92:	673b      	str	r3, [r7, #112]	@ 0x70
 8024a94:	e00e      	b.n	8024ab4 <_fp_exptmod_nct+0x4c>
  } else if (x <= 140) {
 8024a96:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8024a98:	2b8c      	cmp	r3, #140	@ 0x8c
 8024a9a:	dc02      	bgt.n	8024aa2 <_fp_exptmod_nct+0x3a>
    winsize = 4;
 8024a9c:	2304      	movs	r3, #4
 8024a9e:	673b      	str	r3, [r7, #112]	@ 0x70
 8024aa0:	e008      	b.n	8024ab4 <_fp_exptmod_nct+0x4c>
  } else if (x <= 450) {
 8024aa2:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8024aa4:	f5b3 7fe1 	cmp.w	r3, #450	@ 0x1c2
 8024aa8:	dc02      	bgt.n	8024ab0 <_fp_exptmod_nct+0x48>
    winsize = 5;
 8024aaa:	2305      	movs	r3, #5
 8024aac:	673b      	str	r3, [r7, #112]	@ 0x70
 8024aae:	e001      	b.n	8024ab4 <_fp_exptmod_nct+0x4c>
  } else {
    winsize = 6;
 8024ab0:	2306      	movs	r3, #6
 8024ab2:	673b      	str	r3, [r7, #112]	@ 0x70
  }

  /* now setup montgomery  */
  if ((err = fp_montgomery_setup (P, &mp)) != FP_OKAY) {
 8024ab4:	f107 0314 	add.w	r3, r7, #20
 8024ab8:	4619      	mov	r1, r3
 8024aba:	6878      	ldr	r0, [r7, #4]
 8024abc:	f001 f88c 	bl	8025bd8 <fp_montgomery_setup>
 8024ac0:	66f8      	str	r0, [r7, #108]	@ 0x6c
 8024ac2:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024ac4:	2b00      	cmp	r3, #0
 8024ac6:	d001      	beq.n	8024acc <_fp_exptmod_nct+0x64>
     return err;
 8024ac8:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024aca:	e2a3      	b.n	8025014 <_fp_exptmod_nct+0x5ac>
  }

#ifndef WOLFSSL_NO_MALLOC
  /* only allocate space for what's needed for window plus res */
  M = (fp_int*)XMALLOC(sizeof(fp_int)*((1 << winsize) + 1), NULL,
 8024acc:	2201      	movs	r2, #1
 8024ace:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8024ad0:	fa02 f303 	lsl.w	r3, r2, r3
 8024ad4:	3301      	adds	r3, #1
 8024ad6:	461a      	mov	r2, r3
 8024ad8:	f44f 730b 	mov.w	r3, #556	@ 0x22c
 8024adc:	fb02 f303 	mul.w	r3, r2, r3
 8024ae0:	4618      	mov	r0, r3
 8024ae2:	f7f9 ffd1 	bl	801ea88 <wolfSSL_Malloc>
 8024ae6:	66b8      	str	r0, [r7, #104]	@ 0x68
                                                           DYNAMIC_TYPE_BIGINT);
  if (M == NULL) {
 8024ae8:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024aea:	2b00      	cmp	r3, #0
 8024aec:	d102      	bne.n	8024af4 <_fp_exptmod_nct+0x8c>
     return FP_MEM;
 8024aee:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 8024af2:	e28f      	b.n	8025014 <_fp_exptmod_nct+0x5ac>
  }
#endif
  res = &M[(word32)(1 << winsize)];
 8024af4:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024af8:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8024afa:	fa02 f303 	lsl.w	r3, r2, r3
 8024afe:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8024b00:	4413      	add	r3, r2
 8024b02:	667b      	str	r3, [r7, #100]	@ 0x64

  /* init M array */
  for(x = 0; x < (1 << winsize); x++)
 8024b04:	2300      	movs	r3, #0
 8024b06:	677b      	str	r3, [r7, #116]	@ 0x74
 8024b08:	e00c      	b.n	8024b24 <_fp_exptmod_nct+0xbc>
    fp_init(&M[x]);
 8024b0a:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8024b0c:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024b10:	fb02 f303 	mul.w	r3, r2, r3
 8024b14:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8024b16:	4413      	add	r3, r2
 8024b18:	4618      	mov	r0, r3
 8024b1a:	f001 fdc9 	bl	80266b0 <fp_init>
  for(x = 0; x < (1 << winsize); x++)
 8024b1e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8024b20:	3301      	adds	r3, #1
 8024b22:	677b      	str	r3, [r7, #116]	@ 0x74
 8024b24:	2201      	movs	r2, #1
 8024b26:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8024b28:	fa02 f303 	lsl.w	r3, r2, r3
 8024b2c:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8024b2e:	429a      	cmp	r2, r3
 8024b30:	dbeb      	blt.n	8024b0a <_fp_exptmod_nct+0xa2>

  /* setup result */
  fp_init(res);
 8024b32:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8024b34:	f001 fdbc 	bl	80266b0 <fp_init>
   *
   * The first half of the table is not computed though except for M[0] and M[1]
   */

  /* now we need R mod m */
  err = fp_montgomery_calc_normalization (res, P);
 8024b38:	6879      	ldr	r1, [r7, #4]
 8024b3a:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8024b3c:	f001 f88d 	bl	8025c5a <fp_montgomery_calc_normalization>
 8024b40:	66f8      	str	r0, [r7, #108]	@ 0x6c
  if (err != FP_OKAY) {
 8024b42:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024b44:	2b00      	cmp	r3, #0
 8024b46:	d009      	beq.n	8024b5c <_fp_exptmod_nct+0xf4>
#ifndef WOLFSSL_NO_MALLOC
    XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024b48:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024b4a:	61bb      	str	r3, [r7, #24]
 8024b4c:	69bb      	ldr	r3, [r7, #24]
 8024b4e:	2b00      	cmp	r3, #0
 8024b50:	d002      	beq.n	8024b58 <_fp_exptmod_nct+0xf0>
 8024b52:	69b8      	ldr	r0, [r7, #24]
 8024b54:	f7f9 ffb4 	bl	801eac0 <wolfSSL_Free>
#endif
    return err;
 8024b58:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024b5a:	e25b      	b.n	8025014 <_fp_exptmod_nct+0x5ac>
  }

  /* now set M[1] to G * R mod m */
  if (fp_cmp_mag(P, G) != FP_GT) {
 8024b5c:	68f9      	ldr	r1, [r7, #12]
 8024b5e:	6878      	ldr	r0, [r7, #4]
 8024b60:	f000 fff1 	bl	8025b46 <fp_cmp_mag>
 8024b64:	4603      	mov	r3, r0
 8024b66:	2b01      	cmp	r3, #1
 8024b68:	d015      	beq.n	8024b96 <_fp_exptmod_nct+0x12e>
     /* G > P so we reduce it first */
     err = fp_mod(G, P, &M[1]);
 8024b6a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024b6c:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8024b70:	461a      	mov	r2, r3
 8024b72:	6879      	ldr	r1, [r7, #4]
 8024b74:	68f8      	ldr	r0, [r7, #12]
 8024b76:	f7fe fd2b 	bl	80235d0 <fp_mod>
 8024b7a:	66f8      	str	r0, [r7, #108]	@ 0x6c
     if (err != FP_OKAY) {
 8024b7c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024b7e:	2b00      	cmp	r3, #0
 8024b80:	d010      	beq.n	8024ba4 <_fp_exptmod_nct+0x13c>
     #ifndef WOLFSSL_NO_MALLOC
        XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024b82:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024b84:	663b      	str	r3, [r7, #96]	@ 0x60
 8024b86:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8024b88:	2b00      	cmp	r3, #0
 8024b8a:	d002      	beq.n	8024b92 <_fp_exptmod_nct+0x12a>
 8024b8c:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 8024b8e:	f7f9 ff97 	bl	801eac0 <wolfSSL_Free>
     #endif
        return err;
 8024b92:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024b94:	e23e      	b.n	8025014 <_fp_exptmod_nct+0x5ac>
     }
  } else {
     fp_copy(G, &M[1]);
 8024b96:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024b98:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8024b9c:	4619      	mov	r1, r3
 8024b9e:	68f8      	ldr	r0, [r7, #12]
 8024ba0:	f001 ff70 	bl	8026a84 <fp_copy>
  }
  err = fp_mulmod (&M[1], res, P, &M[1]);
 8024ba4:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024ba6:	f503 700b 	add.w	r0, r3, #556	@ 0x22c
 8024baa:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024bac:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8024bb0:	687a      	ldr	r2, [r7, #4]
 8024bb2:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 8024bb4:	f7ff fb69 	bl	802428a <fp_mulmod>
 8024bb8:	66f8      	str	r0, [r7, #108]	@ 0x6c
  if (err != FP_OKAY) {
 8024bba:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024bbc:	2b00      	cmp	r3, #0
 8024bbe:	d009      	beq.n	8024bd4 <_fp_exptmod_nct+0x16c>
  #ifndef WOLFSSL_NO_MALLOC
     XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024bc0:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024bc2:	61fb      	str	r3, [r7, #28]
 8024bc4:	69fb      	ldr	r3, [r7, #28]
 8024bc6:	2b00      	cmp	r3, #0
 8024bc8:	d002      	beq.n	8024bd0 <_fp_exptmod_nct+0x168>
 8024bca:	69f8      	ldr	r0, [r7, #28]
 8024bcc:	f7f9 ff78 	bl	801eac0 <wolfSSL_Free>
  #endif
     return err;
 8024bd0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024bd2:	e21f      	b.n	8025014 <_fp_exptmod_nct+0x5ac>
  }

  /* compute the value at M[1<<(winsize-1)] by
   * squaring M[1] (winsize-1) times */
  fp_copy (&M[1], &M[(word32)(1 << (winsize - 1))]);
 8024bd4:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024bd6:	f503 700b 	add.w	r0, r3, #556	@ 0x22c
 8024bda:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8024bdc:	3b01      	subs	r3, #1
 8024bde:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024be2:	fa02 f303 	lsl.w	r3, r2, r3
 8024be6:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8024be8:	4413      	add	r3, r2
 8024bea:	4619      	mov	r1, r3
 8024bec:	f001 ff4a 	bl	8026a84 <fp_copy>
  for (x = 0; x < (winsize - 1); x++) {
 8024bf0:	2300      	movs	r3, #0
 8024bf2:	677b      	str	r3, [r7, #116]	@ 0x74
 8024bf4:	e03e      	b.n	8024c74 <_fp_exptmod_nct+0x20c>
    err = fp_sqr (&M[(word32)(1 << (winsize - 1))],
 8024bf6:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8024bf8:	3b01      	subs	r3, #1
 8024bfa:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024bfe:	fa02 f303 	lsl.w	r3, r2, r3
 8024c02:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8024c04:	18d0      	adds	r0, r2, r3
                  &M[(word32)(1 << (winsize - 1))]);
 8024c06:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8024c08:	3b01      	subs	r3, #1
 8024c0a:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024c0e:	fa02 f303 	lsl.w	r3, r2, r3
    err = fp_sqr (&M[(word32)(1 << (winsize - 1))],
 8024c12:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8024c14:	4413      	add	r3, r2
 8024c16:	4619      	mov	r1, r3
 8024c18:	f000 fce9 	bl	80255ee <fp_sqr>
 8024c1c:	66f8      	str	r0, [r7, #108]	@ 0x6c
    if (err != FP_OKAY) {
 8024c1e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024c20:	2b00      	cmp	r3, #0
 8024c22:	d009      	beq.n	8024c38 <_fp_exptmod_nct+0x1d0>
#ifndef WOLFSSL_NO_MALLOC
      XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024c24:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024c26:	623b      	str	r3, [r7, #32]
 8024c28:	6a3b      	ldr	r3, [r7, #32]
 8024c2a:	2b00      	cmp	r3, #0
 8024c2c:	d002      	beq.n	8024c34 <_fp_exptmod_nct+0x1cc>
 8024c2e:	6a38      	ldr	r0, [r7, #32]
 8024c30:	f7f9 ff46 	bl	801eac0 <wolfSSL_Free>
#endif
      return err;
 8024c34:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024c36:	e1ed      	b.n	8025014 <_fp_exptmod_nct+0x5ac>
    }
    err = fp_montgomery_reduce_ex(&M[(word32)(1 << (winsize - 1))], P, mp, 0);
 8024c38:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8024c3a:	3b01      	subs	r3, #1
 8024c3c:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024c40:	fa02 f303 	lsl.w	r3, r2, r3
 8024c44:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8024c46:	18d0      	adds	r0, r2, r3
 8024c48:	697a      	ldr	r2, [r7, #20]
 8024c4a:	2300      	movs	r3, #0
 8024c4c:	6879      	ldr	r1, [r7, #4]
 8024c4e:	f001 f856 	bl	8025cfe <fp_montgomery_reduce_ex>
 8024c52:	66f8      	str	r0, [r7, #108]	@ 0x6c
    if (err != FP_OKAY) {
 8024c54:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024c56:	2b00      	cmp	r3, #0
 8024c58:	d009      	beq.n	8024c6e <_fp_exptmod_nct+0x206>
#ifndef WOLFSSL_NO_MALLOC
      XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024c5a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024c5c:	627b      	str	r3, [r7, #36]	@ 0x24
 8024c5e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024c60:	2b00      	cmp	r3, #0
 8024c62:	d002      	beq.n	8024c6a <_fp_exptmod_nct+0x202>
 8024c64:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8024c66:	f7f9 ff2b 	bl	801eac0 <wolfSSL_Free>
#endif
      return err;
 8024c6a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024c6c:	e1d2      	b.n	8025014 <_fp_exptmod_nct+0x5ac>
  for (x = 0; x < (winsize - 1); x++) {
 8024c6e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8024c70:	3301      	adds	r3, #1
 8024c72:	677b      	str	r3, [r7, #116]	@ 0x74
 8024c74:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8024c76:	3b01      	subs	r3, #1
 8024c78:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8024c7a:	429a      	cmp	r2, r3
 8024c7c:	dbbb      	blt.n	8024bf6 <_fp_exptmod_nct+0x18e>
    }
  }

  /* create upper table */
  for (x = (1 << (winsize - 1)) + 1; x < (1 << winsize); x++) {
 8024c7e:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8024c80:	3b01      	subs	r3, #1
 8024c82:	2201      	movs	r2, #1
 8024c84:	fa02 f303 	lsl.w	r3, r2, r3
 8024c88:	3301      	adds	r3, #1
 8024c8a:	677b      	str	r3, [r7, #116]	@ 0x74
 8024c8c:	e040      	b.n	8024d10 <_fp_exptmod_nct+0x2a8>
    err = fp_mul(&M[x - 1], &M[1], &M[x]);
 8024c8e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8024c90:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024c94:	fb02 f303 	mul.w	r3, r2, r3
 8024c98:	f5a3 730b 	sub.w	r3, r3, #556	@ 0x22c
 8024c9c:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8024c9e:	18d0      	adds	r0, r2, r3
 8024ca0:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024ca2:	f503 710b 	add.w	r1, r3, #556	@ 0x22c
 8024ca6:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8024ca8:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024cac:	fb02 f303 	mul.w	r3, r2, r3
 8024cb0:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8024cb2:	4413      	add	r3, r2
 8024cb4:	461a      	mov	r2, r3
 8024cb6:	f7fd fcf2 	bl	802269e <fp_mul>
 8024cba:	66f8      	str	r0, [r7, #108]	@ 0x6c
    if (err != FP_OKAY) {
 8024cbc:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024cbe:	2b00      	cmp	r3, #0
 8024cc0:	d009      	beq.n	8024cd6 <_fp_exptmod_nct+0x26e>
#ifndef WOLFSSL_NO_MALLOC
      XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024cc2:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024cc4:	62bb      	str	r3, [r7, #40]	@ 0x28
 8024cc6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8024cc8:	2b00      	cmp	r3, #0
 8024cca:	d002      	beq.n	8024cd2 <_fp_exptmod_nct+0x26a>
 8024ccc:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8024cce:	f7f9 fef7 	bl	801eac0 <wolfSSL_Free>
#endif
      return err;
 8024cd2:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024cd4:	e19e      	b.n	8025014 <_fp_exptmod_nct+0x5ac>
    }
    err = fp_montgomery_reduce_ex(&M[x], P, mp, 0);
 8024cd6:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8024cd8:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024cdc:	fb02 f303 	mul.w	r3, r2, r3
 8024ce0:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8024ce2:	18d0      	adds	r0, r2, r3
 8024ce4:	697a      	ldr	r2, [r7, #20]
 8024ce6:	2300      	movs	r3, #0
 8024ce8:	6879      	ldr	r1, [r7, #4]
 8024cea:	f001 f808 	bl	8025cfe <fp_montgomery_reduce_ex>
 8024cee:	66f8      	str	r0, [r7, #108]	@ 0x6c
    if (err != FP_OKAY) {
 8024cf0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024cf2:	2b00      	cmp	r3, #0
 8024cf4:	d009      	beq.n	8024d0a <_fp_exptmod_nct+0x2a2>
#ifndef WOLFSSL_NO_MALLOC
      XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024cf6:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024cf8:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8024cfa:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8024cfc:	2b00      	cmp	r3, #0
 8024cfe:	d002      	beq.n	8024d06 <_fp_exptmod_nct+0x29e>
 8024d00:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8024d02:	f7f9 fedd 	bl	801eac0 <wolfSSL_Free>
#endif
      return err;
 8024d06:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024d08:	e184      	b.n	8025014 <_fp_exptmod_nct+0x5ac>
  for (x = (1 << (winsize - 1)) + 1; x < (1 << winsize); x++) {
 8024d0a:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8024d0c:	3301      	adds	r3, #1
 8024d0e:	677b      	str	r3, [r7, #116]	@ 0x74
 8024d10:	2201      	movs	r2, #1
 8024d12:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8024d14:	fa02 f303 	lsl.w	r3, r2, r3
 8024d18:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8024d1a:	429a      	cmp	r2, r3
 8024d1c:	dbb7      	blt.n	8024c8e <_fp_exptmod_nct+0x226>
    }
  }

  /* set initial mode and bit cnt */
  mode   = 0;
 8024d1e:	2300      	movs	r3, #0
 8024d20:	67fb      	str	r3, [r7, #124]	@ 0x7c
  bitcnt = (x % DIGIT_BIT) + 1;
 8024d22:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8024d24:	425a      	negs	r2, r3
 8024d26:	f003 031f 	and.w	r3, r3, #31
 8024d2a:	f002 021f 	and.w	r2, r2, #31
 8024d2e:	bf58      	it	pl
 8024d30:	4253      	negpl	r3, r2
 8024d32:	3301      	adds	r3, #1
 8024d34:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
  buf    = 0;
 8024d38:	2300      	movs	r3, #0
 8024d3a:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
  digidx = X->used - 1;
 8024d3e:	68bb      	ldr	r3, [r7, #8]
 8024d40:	681b      	ldr	r3, [r3, #0]
 8024d42:	3b01      	subs	r3, #1
 8024d44:	67bb      	str	r3, [r7, #120]	@ 0x78
  bitcpy = 0;
 8024d46:	2300      	movs	r3, #0
 8024d48:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
  bitbuf = 0;
 8024d4c:	2300      	movs	r3, #0
 8024d4e:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88

  for (;;) {
    /* grab next digit as required */
    if (--bitcnt == 0) {
 8024d52:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8024d56:	3b01      	subs	r3, #1
 8024d58:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
 8024d5c:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8024d60:	2b00      	cmp	r3, #0
 8024d62:	d111      	bne.n	8024d88 <_fp_exptmod_nct+0x320>
      /* if digidx == -1 we are out of digits so break */
      if (digidx == -1) {
 8024d64:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8024d66:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8024d6a:	f000 80ce 	beq.w	8024f0a <_fp_exptmod_nct+0x4a2>
        break;
      }
      /* read next digit and reset bitcnt */
      buf    = X->dp[digidx--];
 8024d6e:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8024d70:	1e5a      	subs	r2, r3, #1
 8024d72:	67ba      	str	r2, [r7, #120]	@ 0x78
 8024d74:	68ba      	ldr	r2, [r7, #8]
 8024d76:	3302      	adds	r3, #2
 8024d78:	009b      	lsls	r3, r3, #2
 8024d7a:	4413      	add	r3, r2
 8024d7c:	685b      	ldr	r3, [r3, #4]
 8024d7e:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
      bitcnt = (int)DIGIT_BIT;
 8024d82:	2320      	movs	r3, #32
 8024d84:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
    }

    /* grab the next msb from the exponent */
    y     = (int)(buf >> (DIGIT_BIT - 1)) & 1;
 8024d88:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8024d8c:	0fdb      	lsrs	r3, r3, #31
 8024d8e:	64bb      	str	r3, [r7, #72]	@ 0x48
    buf <<= (fp_digit)1;
 8024d90:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8024d94:	005b      	lsls	r3, r3, #1
 8024d96:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
    /* if the bit is zero and mode == 0 then we ignore it
     * These represent the leading zero bits before the first 1 bit
     * in the exponent.  Technically this opt is not required but it
     * does lower the # of trivial squaring/reductions used
     */
    if (mode == 0 && y == 0) {
 8024d9a:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8024d9c:	2b00      	cmp	r3, #0
 8024d9e:	d103      	bne.n	8024da8 <_fp_exptmod_nct+0x340>
 8024da0:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8024da2:	2b00      	cmp	r3, #0
 8024da4:	f000 80ad 	beq.w	8024f02 <_fp_exptmod_nct+0x49a>
      continue;
    }

    /* if the bit is zero and mode == 1 then we square */
    if (mode == 1 && y == 0) {
 8024da8:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8024daa:	2b01      	cmp	r3, #1
 8024dac:	d129      	bne.n	8024e02 <_fp_exptmod_nct+0x39a>
 8024dae:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8024db0:	2b00      	cmp	r3, #0
 8024db2:	d126      	bne.n	8024e02 <_fp_exptmod_nct+0x39a>
      err = fp_sqr(res, res);
 8024db4:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 8024db6:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8024db8:	f000 fc19 	bl	80255ee <fp_sqr>
 8024dbc:	66f8      	str	r0, [r7, #108]	@ 0x6c
      if (err != FP_OKAY) {
 8024dbe:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024dc0:	2b00      	cmp	r3, #0
 8024dc2:	d009      	beq.n	8024dd8 <_fp_exptmod_nct+0x370>
#ifndef WOLFSSL_NO_MALLOC
        XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024dc4:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024dc6:	643b      	str	r3, [r7, #64]	@ 0x40
 8024dc8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8024dca:	2b00      	cmp	r3, #0
 8024dcc:	d002      	beq.n	8024dd4 <_fp_exptmod_nct+0x36c>
 8024dce:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 8024dd0:	f7f9 fe76 	bl	801eac0 <wolfSSL_Free>
#endif
        return err;
 8024dd4:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024dd6:	e11d      	b.n	8025014 <_fp_exptmod_nct+0x5ac>
      }
      err = fp_montgomery_reduce_ex(res, P, mp, 0);
 8024dd8:	697a      	ldr	r2, [r7, #20]
 8024dda:	2300      	movs	r3, #0
 8024ddc:	6879      	ldr	r1, [r7, #4]
 8024dde:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8024de0:	f000 ff8d 	bl	8025cfe <fp_montgomery_reduce_ex>
 8024de4:	66f8      	str	r0, [r7, #108]	@ 0x6c
      if (err != FP_OKAY) {
 8024de6:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024de8:	2b00      	cmp	r3, #0
 8024dea:	f000 808c 	beq.w	8024f06 <_fp_exptmod_nct+0x49e>
#ifndef WOLFSSL_NO_MALLOC
        XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024dee:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024df0:	647b      	str	r3, [r7, #68]	@ 0x44
 8024df2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8024df4:	2b00      	cmp	r3, #0
 8024df6:	d002      	beq.n	8024dfe <_fp_exptmod_nct+0x396>
 8024df8:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 8024dfa:	f7f9 fe61 	bl	801eac0 <wolfSSL_Free>
#endif
        return err;
 8024dfe:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024e00:	e108      	b.n	8025014 <_fp_exptmod_nct+0x5ac>
      }
      continue;
    }

    /* else we add it to the window */
    bitbuf |= (y << (winsize - ++bitcpy));
 8024e02:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8024e06:	3301      	adds	r3, #1
 8024e08:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
 8024e0c:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 8024e0e:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8024e12:	1ad3      	subs	r3, r2, r3
 8024e14:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8024e16:	fa02 f303 	lsl.w	r3, r2, r3
 8024e1a:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 8024e1e:	4313      	orrs	r3, r2
 8024e20:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
    mode    = 2;
 8024e24:	2302      	movs	r3, #2
 8024e26:	67fb      	str	r3, [r7, #124]	@ 0x7c

    if (bitcpy == winsize) {
 8024e28:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 8024e2c:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8024e2e:	429a      	cmp	r2, r3
 8024e30:	d18f      	bne.n	8024d52 <_fp_exptmod_nct+0x2ea>
      /* ok window is filled so square as required and multiply  */
      /* square first */
      for (x = 0; x < winsize; x++) {
 8024e32:	2300      	movs	r3, #0
 8024e34:	677b      	str	r3, [r7, #116]	@ 0x74
 8024e36:	e028      	b.n	8024e8a <_fp_exptmod_nct+0x422>
        err = fp_sqr(res, res);
 8024e38:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 8024e3a:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8024e3c:	f000 fbd7 	bl	80255ee <fp_sqr>
 8024e40:	66f8      	str	r0, [r7, #108]	@ 0x6c
        if (err != FP_OKAY) {
 8024e42:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024e44:	2b00      	cmp	r3, #0
 8024e46:	d009      	beq.n	8024e5c <_fp_exptmod_nct+0x3f4>
#ifndef WOLFSSL_NO_MALLOC
          XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024e48:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024e4a:	633b      	str	r3, [r7, #48]	@ 0x30
 8024e4c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8024e4e:	2b00      	cmp	r3, #0
 8024e50:	d002      	beq.n	8024e58 <_fp_exptmod_nct+0x3f0>
 8024e52:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 8024e54:	f7f9 fe34 	bl	801eac0 <wolfSSL_Free>
#endif
          return err;
 8024e58:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024e5a:	e0db      	b.n	8025014 <_fp_exptmod_nct+0x5ac>
        }
        err = fp_montgomery_reduce_ex(res, P, mp, 0);
 8024e5c:	697a      	ldr	r2, [r7, #20]
 8024e5e:	2300      	movs	r3, #0
 8024e60:	6879      	ldr	r1, [r7, #4]
 8024e62:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8024e64:	f000 ff4b 	bl	8025cfe <fp_montgomery_reduce_ex>
 8024e68:	66f8      	str	r0, [r7, #108]	@ 0x6c
        if (err != FP_OKAY) {
 8024e6a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024e6c:	2b00      	cmp	r3, #0
 8024e6e:	d009      	beq.n	8024e84 <_fp_exptmod_nct+0x41c>
#ifndef WOLFSSL_NO_MALLOC
          XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024e70:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024e72:	637b      	str	r3, [r7, #52]	@ 0x34
 8024e74:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8024e76:	2b00      	cmp	r3, #0
 8024e78:	d002      	beq.n	8024e80 <_fp_exptmod_nct+0x418>
 8024e7a:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 8024e7c:	f7f9 fe20 	bl	801eac0 <wolfSSL_Free>
#endif
          return err;
 8024e80:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024e82:	e0c7      	b.n	8025014 <_fp_exptmod_nct+0x5ac>
      for (x = 0; x < winsize; x++) {
 8024e84:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8024e86:	3301      	adds	r3, #1
 8024e88:	677b      	str	r3, [r7, #116]	@ 0x74
 8024e8a:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8024e8c:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8024e8e:	429a      	cmp	r2, r3
 8024e90:	dbd2      	blt.n	8024e38 <_fp_exptmod_nct+0x3d0>
        }
      }

      /* then multiply */
      err = fp_mul(res, &M[bitbuf], res);
 8024e92:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 8024e96:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024e9a:	fb02 f303 	mul.w	r3, r2, r3
 8024e9e:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8024ea0:	4413      	add	r3, r2
 8024ea2:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 8024ea4:	4619      	mov	r1, r3
 8024ea6:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8024ea8:	f7fd fbf9 	bl	802269e <fp_mul>
 8024eac:	66f8      	str	r0, [r7, #108]	@ 0x6c
      if (err != FP_OKAY) {
 8024eae:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024eb0:	2b00      	cmp	r3, #0
 8024eb2:	d009      	beq.n	8024ec8 <_fp_exptmod_nct+0x460>
#ifndef WOLFSSL_NO_MALLOC
        XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024eb4:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024eb6:	63bb      	str	r3, [r7, #56]	@ 0x38
 8024eb8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8024eba:	2b00      	cmp	r3, #0
 8024ebc:	d002      	beq.n	8024ec4 <_fp_exptmod_nct+0x45c>
 8024ebe:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 8024ec0:	f7f9 fdfe 	bl	801eac0 <wolfSSL_Free>
#endif
        return err;
 8024ec4:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024ec6:	e0a5      	b.n	8025014 <_fp_exptmod_nct+0x5ac>
      }
      err = fp_montgomery_reduce_ex(res, P, mp, 0);
 8024ec8:	697a      	ldr	r2, [r7, #20]
 8024eca:	2300      	movs	r3, #0
 8024ecc:	6879      	ldr	r1, [r7, #4]
 8024ece:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8024ed0:	f000 ff15 	bl	8025cfe <fp_montgomery_reduce_ex>
 8024ed4:	66f8      	str	r0, [r7, #108]	@ 0x6c
      if (err != FP_OKAY) {
 8024ed6:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024ed8:	2b00      	cmp	r3, #0
 8024eda:	d009      	beq.n	8024ef0 <_fp_exptmod_nct+0x488>
#ifndef WOLFSSL_NO_MALLOC
        XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024edc:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024ede:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8024ee0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024ee2:	2b00      	cmp	r3, #0
 8024ee4:	d002      	beq.n	8024eec <_fp_exptmod_nct+0x484>
 8024ee6:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8024ee8:	f7f9 fdea 	bl	801eac0 <wolfSSL_Free>
#endif
        return err;
 8024eec:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024eee:	e091      	b.n	8025014 <_fp_exptmod_nct+0x5ac>
      }

      /* empty window and reset */
      bitcpy = 0;
 8024ef0:	2300      	movs	r3, #0
 8024ef2:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
      bitbuf = 0;
 8024ef6:	2300      	movs	r3, #0
 8024ef8:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
      mode   = 1;
 8024efc:	2301      	movs	r3, #1
 8024efe:	67fb      	str	r3, [r7, #124]	@ 0x7c
 8024f00:	e727      	b.n	8024d52 <_fp_exptmod_nct+0x2ea>
      continue;
 8024f02:	bf00      	nop
 8024f04:	e725      	b.n	8024d52 <_fp_exptmod_nct+0x2ea>
      continue;
 8024f06:	bf00      	nop
    if (--bitcnt == 0) {
 8024f08:	e723      	b.n	8024d52 <_fp_exptmod_nct+0x2ea>
        break;
 8024f0a:	bf00      	nop
    }
  }

  /* if bits remain then square/multiply */
  if (mode == 2 && bitcpy > 0) {
 8024f0c:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8024f0e:	2b02      	cmp	r3, #2
 8024f10:	d16c      	bne.n	8024fec <_fp_exptmod_nct+0x584>
 8024f12:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8024f16:	2b00      	cmp	r3, #0
 8024f18:	dd68      	ble.n	8024fec <_fp_exptmod_nct+0x584>
    /* square then multiply if the bit is set */
    for (x = 0; x < bitcpy; x++) {
 8024f1a:	2300      	movs	r3, #0
 8024f1c:	677b      	str	r3, [r7, #116]	@ 0x74
 8024f1e:	e060      	b.n	8024fe2 <_fp_exptmod_nct+0x57a>
      err = fp_sqr(res, res);
 8024f20:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 8024f22:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8024f24:	f000 fb63 	bl	80255ee <fp_sqr>
 8024f28:	66f8      	str	r0, [r7, #108]	@ 0x6c
      if (err != FP_OKAY) {
 8024f2a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024f2c:	2b00      	cmp	r3, #0
 8024f2e:	d009      	beq.n	8024f44 <_fp_exptmod_nct+0x4dc>
#ifndef WOLFSSL_NO_MALLOC
        XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024f30:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024f32:	653b      	str	r3, [r7, #80]	@ 0x50
 8024f34:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8024f36:	2b00      	cmp	r3, #0
 8024f38:	d002      	beq.n	8024f40 <_fp_exptmod_nct+0x4d8>
 8024f3a:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 8024f3c:	f7f9 fdc0 	bl	801eac0 <wolfSSL_Free>
#endif
        return err;
 8024f40:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024f42:	e067      	b.n	8025014 <_fp_exptmod_nct+0x5ac>
      }
      err = fp_montgomery_reduce_ex(res, P, mp, 0);
 8024f44:	697a      	ldr	r2, [r7, #20]
 8024f46:	2300      	movs	r3, #0
 8024f48:	6879      	ldr	r1, [r7, #4]
 8024f4a:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8024f4c:	f000 fed7 	bl	8025cfe <fp_montgomery_reduce_ex>
 8024f50:	66f8      	str	r0, [r7, #108]	@ 0x6c
      if (err != FP_OKAY) {
 8024f52:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024f54:	2b00      	cmp	r3, #0
 8024f56:	d009      	beq.n	8024f6c <_fp_exptmod_nct+0x504>
#ifndef WOLFSSL_NO_MALLOC
        XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024f58:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024f5a:	657b      	str	r3, [r7, #84]	@ 0x54
 8024f5c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8024f5e:	2b00      	cmp	r3, #0
 8024f60:	d002      	beq.n	8024f68 <_fp_exptmod_nct+0x500>
 8024f62:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 8024f64:	f7f9 fdac 	bl	801eac0 <wolfSSL_Free>
#endif
        return err;
 8024f68:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024f6a:	e053      	b.n	8025014 <_fp_exptmod_nct+0x5ac>
      }

      /* get next bit of the window */
      bitbuf <<= 1;
 8024f6c:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 8024f70:	005b      	lsls	r3, r3, #1
 8024f72:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
      if ((bitbuf & (1 << winsize)) != 0) {
 8024f76:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 8024f7a:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8024f7c:	fa42 f303 	asr.w	r3, r2, r3
 8024f80:	f003 0301 	and.w	r3, r3, #1
 8024f84:	2b00      	cmp	r3, #0
 8024f86:	d029      	beq.n	8024fdc <_fp_exptmod_nct+0x574>
        /* then multiply */
        err = fp_mul(res, &M[1], res);
 8024f88:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024f8a:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8024f8e:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 8024f90:	4619      	mov	r1, r3
 8024f92:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8024f94:	f7fd fb83 	bl	802269e <fp_mul>
 8024f98:	66f8      	str	r0, [r7, #108]	@ 0x6c
        if (err != FP_OKAY) {
 8024f9a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024f9c:	2b00      	cmp	r3, #0
 8024f9e:	d009      	beq.n	8024fb4 <_fp_exptmod_nct+0x54c>
#ifndef WOLFSSL_NO_MALLOC
          XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024fa0:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024fa2:	65bb      	str	r3, [r7, #88]	@ 0x58
 8024fa4:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8024fa6:	2b00      	cmp	r3, #0
 8024fa8:	d002      	beq.n	8024fb0 <_fp_exptmod_nct+0x548>
 8024faa:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 8024fac:	f7f9 fd88 	bl	801eac0 <wolfSSL_Free>
#endif
          return err;
 8024fb0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024fb2:	e02f      	b.n	8025014 <_fp_exptmod_nct+0x5ac>
        }
        err = fp_montgomery_reduce_ex(res, P, mp, 0);
 8024fb4:	697a      	ldr	r2, [r7, #20]
 8024fb6:	2300      	movs	r3, #0
 8024fb8:	6879      	ldr	r1, [r7, #4]
 8024fba:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8024fbc:	f000 fe9f 	bl	8025cfe <fp_montgomery_reduce_ex>
 8024fc0:	66f8      	str	r0, [r7, #108]	@ 0x6c
        if (err != FP_OKAY) {
 8024fc2:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024fc4:	2b00      	cmp	r3, #0
 8024fc6:	d009      	beq.n	8024fdc <_fp_exptmod_nct+0x574>
#ifndef WOLFSSL_NO_MALLOC
          XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024fc8:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024fca:	65fb      	str	r3, [r7, #92]	@ 0x5c
 8024fcc:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8024fce:	2b00      	cmp	r3, #0
 8024fd0:	d002      	beq.n	8024fd8 <_fp_exptmod_nct+0x570>
 8024fd2:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8024fd4:	f7f9 fd74 	bl	801eac0 <wolfSSL_Free>
#endif
          return err;
 8024fd8:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024fda:	e01b      	b.n	8025014 <_fp_exptmod_nct+0x5ac>
    for (x = 0; x < bitcpy; x++) {
 8024fdc:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8024fde:	3301      	adds	r3, #1
 8024fe0:	677b      	str	r3, [r7, #116]	@ 0x74
 8024fe2:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8024fe4:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8024fe8:	429a      	cmp	r2, r3
 8024fea:	db99      	blt.n	8024f20 <_fp_exptmod_nct+0x4b8>
   * recall that any value in a Montgomery system is
   * actually multiplied by R mod n.  So we have
   * to reduce one more time to cancel out the factor
   * of R.
   */
  err = fp_montgomery_reduce_ex(res, P, mp, 0);
 8024fec:	697a      	ldr	r2, [r7, #20]
 8024fee:	2300      	movs	r3, #0
 8024ff0:	6879      	ldr	r1, [r7, #4]
 8024ff2:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8024ff4:	f000 fe83 	bl	8025cfe <fp_montgomery_reduce_ex>
 8024ff8:	66f8      	str	r0, [r7, #108]	@ 0x6c

  /* swap res with Y */
  fp_copy (res, Y);
 8024ffa:	6839      	ldr	r1, [r7, #0]
 8024ffc:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8024ffe:	f001 fd41 	bl	8026a84 <fp_copy>

#ifndef WOLFSSL_NO_MALLOC
  XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8025002:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8025004:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8025006:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8025008:	2b00      	cmp	r3, #0
 802500a:	d002      	beq.n	8025012 <_fp_exptmod_nct+0x5aa>
 802500c:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 802500e:	f7f9 fd57 	bl	801eac0 <wolfSSL_Free>
#endif
  return err;
 8025012:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
}
 8025014:	4618      	mov	r0, r3
 8025016:	3790      	adds	r7, #144	@ 0x90
 8025018:	46bd      	mov	sp, r7
 802501a:	bd80      	pop	{r7, pc}

0802501c <_fp_exptmod_base_2>:
/* y = 2**x (mod b)
 * Some restrictions... x must be positive and < b
 */
static int _fp_exptmod_base_2(fp_int * X, int digits, fp_int * P,
                              fp_int * Y)
{
 802501c:	b580      	push	{r7, lr}
 802501e:	b09c      	sub	sp, #112	@ 0x70
 8025020:	af00      	add	r7, sp, #0
 8025022:	60f8      	str	r0, [r7, #12]
 8025024:	60b9      	str	r1, [r7, #8]
 8025026:	607a      	str	r2, [r7, #4]
 8025028:	603b      	str	r3, [r7, #0]
  fp_int   res[1];
  fp_int   tmp[1];
#endif

#ifdef WOLFSSL_SMALL_STACK
  res = (fp_int*)XMALLOC(2*sizeof(fp_int), NULL, DYNAMIC_TYPE_TMP_BUFFER);
 802502a:	f44f 608b 	mov.w	r0, #1112	@ 0x458
 802502e:	f7f9 fd2b 	bl	801ea88 <wolfSSL_Malloc>
 8025032:	6578      	str	r0, [r7, #84]	@ 0x54
  if (res == NULL) {
 8025034:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8025036:	2b00      	cmp	r3, #0
 8025038:	d102      	bne.n	8025040 <_fp_exptmod_base_2+0x24>
     return FP_MEM;
 802503a:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 802503e:	e15d      	b.n	80252fc <_fp_exptmod_base_2+0x2e0>
  }
  tmp = &res[1];
 8025040:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8025042:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8025046:	653b      	str	r3, [r7, #80]	@ 0x50
#endif

  /* now setup montgomery  */
  if ((err = fp_montgomery_setup(P, &mp)) != FP_OKAY) {
 8025048:	f107 0314 	add.w	r3, r7, #20
 802504c:	4619      	mov	r1, r3
 802504e:	6878      	ldr	r0, [r7, #4]
 8025050:	f000 fdc2 	bl	8025bd8 <fp_montgomery_setup>
 8025054:	64f8      	str	r0, [r7, #76]	@ 0x4c
 8025056:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8025058:	2b00      	cmp	r3, #0
 802505a:	d009      	beq.n	8025070 <_fp_exptmod_base_2+0x54>
#ifdef WOLFSSL_SMALL_STACK
     XFREE(res, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 802505c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802505e:	61bb      	str	r3, [r7, #24]
 8025060:	69bb      	ldr	r3, [r7, #24]
 8025062:	2b00      	cmp	r3, #0
 8025064:	d002      	beq.n	802506c <_fp_exptmod_base_2+0x50>
 8025066:	69b8      	ldr	r0, [r7, #24]
 8025068:	f7f9 fd2a 	bl	801eac0 <wolfSSL_Free>
#endif
     return err;
 802506c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802506e:	e145      	b.n	80252fc <_fp_exptmod_base_2+0x2e0>
  }

  /* setup result */
  fp_init(res);
 8025070:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 8025072:	f001 fb1d 	bl	80266b0 <fp_init>
  fp_init(tmp);
 8025076:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 8025078:	f001 fb1a 	bl	80266b0 <fp_init>

  err = fp_mul_2d(P, 1 << WINSIZE, tmp);
 802507c:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 802507e:	2108      	movs	r1, #8
 8025080:	6878      	ldr	r0, [r7, #4]
 8025082:	f7fd fc62 	bl	802294a <fp_mul_2d>
 8025086:	64f8      	str	r0, [r7, #76]	@ 0x4c
  if (err != FP_OKAY) {
 8025088:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802508a:	2b00      	cmp	r3, #0
 802508c:	d009      	beq.n	80250a2 <_fp_exptmod_base_2+0x86>
  #ifdef WOLFSSL_SMALL_STACK
    XFREE(res, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 802508e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8025090:	61fb      	str	r3, [r7, #28]
 8025092:	69fb      	ldr	r3, [r7, #28]
 8025094:	2b00      	cmp	r3, #0
 8025096:	d002      	beq.n	802509e <_fp_exptmod_base_2+0x82>
 8025098:	69f8      	ldr	r0, [r7, #28]
 802509a:	f7f9 fd11 	bl	801eac0 <wolfSSL_Free>
  #endif
    return err;
 802509e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80250a0:	e12c      	b.n	80252fc <_fp_exptmod_base_2+0x2e0>
  }

  /* now we need R mod m */
  err = fp_montgomery_calc_normalization(res, P);
 80250a2:	6879      	ldr	r1, [r7, #4]
 80250a4:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 80250a6:	f000 fdd8 	bl	8025c5a <fp_montgomery_calc_normalization>
 80250aa:	64f8      	str	r0, [r7, #76]	@ 0x4c
  if (err != FP_OKAY) {
 80250ac:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80250ae:	2b00      	cmp	r3, #0
 80250b0:	d009      	beq.n	80250c6 <_fp_exptmod_base_2+0xaa>
  #ifdef WOLFSSL_SMALL_STACK
    XFREE(res, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 80250b2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80250b4:	623b      	str	r3, [r7, #32]
 80250b6:	6a3b      	ldr	r3, [r7, #32]
 80250b8:	2b00      	cmp	r3, #0
 80250ba:	d002      	beq.n	80250c2 <_fp_exptmod_base_2+0xa6>
 80250bc:	6a38      	ldr	r0, [r7, #32]
 80250be:	f7f9 fcff 	bl	801eac0 <wolfSSL_Free>
  #endif
    return err;
 80250c2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80250c4:	e11a      	b.n	80252fc <_fp_exptmod_base_2+0x2e0>
  }

  /* Get the top bits left over after taking WINSIZE bits starting at the
   * least-significant.
   */
  digidx = digits - 1;
 80250c6:	68bb      	ldr	r3, [r7, #8]
 80250c8:	3b01      	subs	r3, #1
 80250ca:	65fb      	str	r3, [r7, #92]	@ 0x5c
  bitcpy = (digits * DIGIT_BIT) % WINSIZE;
 80250cc:	68bb      	ldr	r3, [r7, #8]
 80250ce:	015a      	lsls	r2, r3, #5
 80250d0:	4b8c      	ldr	r3, [pc, #560]	@ (8025304 <_fp_exptmod_base_2+0x2e8>)
 80250d2:	fb83 3102 	smull	r3, r1, r3, r2
 80250d6:	17d3      	asrs	r3, r2, #31
 80250d8:	1ac9      	subs	r1, r1, r3
 80250da:	460b      	mov	r3, r1
 80250dc:	005b      	lsls	r3, r3, #1
 80250de:	440b      	add	r3, r1
 80250e0:	1ad3      	subs	r3, r2, r3
 80250e2:	667b      	str	r3, [r7, #100]	@ 0x64
  if (bitcpy > 0) {
 80250e4:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80250e6:	2b00      	cmp	r3, #0
 80250e8:	dd53      	ble.n	8025192 <_fp_exptmod_base_2+0x176>
      bitcnt = (int)DIGIT_BIT - bitcpy;
 80250ea:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80250ec:	f1c3 0320 	rsb	r3, r3, #32
 80250f0:	663b      	str	r3, [r7, #96]	@ 0x60
      buf    = X->dp[digidx--];
 80250f2:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80250f4:	1e5a      	subs	r2, r3, #1
 80250f6:	65fa      	str	r2, [r7, #92]	@ 0x5c
 80250f8:	68fa      	ldr	r2, [r7, #12]
 80250fa:	3302      	adds	r3, #2
 80250fc:	009b      	lsls	r3, r3, #2
 80250fe:	4413      	add	r3, r2
 8025100:	685b      	ldr	r3, [r3, #4]
 8025102:	66fb      	str	r3, [r7, #108]	@ 0x6c
      bitbuf = (int)(buf >> bitcnt);
 8025104:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8025106:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8025108:	fa22 f303 	lsr.w	r3, r2, r3
 802510c:	66bb      	str	r3, [r7, #104]	@ 0x68
      /* Multiply montgomery representation of 1 by 2 ^ top */
      err = fp_mul_2d(res, bitbuf, res);
 802510e:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8025110:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 8025112:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 8025114:	f7fd fc19 	bl	802294a <fp_mul_2d>
 8025118:	64f8      	str	r0, [r7, #76]	@ 0x4c
      if (err != FP_OKAY) {
 802511a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802511c:	2b00      	cmp	r3, #0
 802511e:	d009      	beq.n	8025134 <_fp_exptmod_base_2+0x118>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(res, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 8025120:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8025122:	643b      	str	r3, [r7, #64]	@ 0x40
 8025124:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8025126:	2b00      	cmp	r3, #0
 8025128:	d002      	beq.n	8025130 <_fp_exptmod_base_2+0x114>
 802512a:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 802512c:	f7f9 fcc8 	bl	801eac0 <wolfSSL_Free>
      #endif
        return err;
 8025130:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8025132:	e0e3      	b.n	80252fc <_fp_exptmod_base_2+0x2e0>
      }
      err = fp_add(res, tmp, res);
 8025134:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8025136:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 8025138:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 802513a:	f7fd f8ca 	bl	80222d2 <fp_add>
 802513e:	64f8      	str	r0, [r7, #76]	@ 0x4c
      if (err != FP_OKAY) {
 8025140:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8025142:	2b00      	cmp	r3, #0
 8025144:	d009      	beq.n	802515a <_fp_exptmod_base_2+0x13e>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(res, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 8025146:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8025148:	647b      	str	r3, [r7, #68]	@ 0x44
 802514a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802514c:	2b00      	cmp	r3, #0
 802514e:	d002      	beq.n	8025156 <_fp_exptmod_base_2+0x13a>
 8025150:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 8025152:	f7f9 fcb5 	bl	801eac0 <wolfSSL_Free>
      #endif
        return err;
 8025156:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8025158:	e0d0      	b.n	80252fc <_fp_exptmod_base_2+0x2e0>
      }
      err = fp_mod(res, P, res);
 802515a:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 802515c:	6879      	ldr	r1, [r7, #4]
 802515e:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 8025160:	f7fe fa36 	bl	80235d0 <fp_mod>
 8025164:	64f8      	str	r0, [r7, #76]	@ 0x4c
      if (err != FP_OKAY) {
 8025166:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8025168:	2b00      	cmp	r3, #0
 802516a:	d009      	beq.n	8025180 <_fp_exptmod_base_2+0x164>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(res, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 802516c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802516e:	64bb      	str	r3, [r7, #72]	@ 0x48
 8025170:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8025172:	2b00      	cmp	r3, #0
 8025174:	d002      	beq.n	802517c <_fp_exptmod_base_2+0x160>
 8025176:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 8025178:	f7f9 fca2 	bl	801eac0 <wolfSSL_Free>
      #endif
        return err;
 802517c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802517e:	e0bd      	b.n	80252fc <_fp_exptmod_base_2+0x2e0>
      }
      /* Move out bits used */
      buf  <<= bitcpy;
 8025180:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8025182:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8025184:	fa02 f303 	lsl.w	r3, r2, r3
 8025188:	66fb      	str	r3, [r7, #108]	@ 0x6c
      bitcnt++;
 802518a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 802518c:	3301      	adds	r3, #1
 802518e:	663b      	str	r3, [r7, #96]	@ 0x60
 8025190:	e003      	b.n	802519a <_fp_exptmod_base_2+0x17e>
  }
  else {
      bitcnt = 1;
 8025192:	2301      	movs	r3, #1
 8025194:	663b      	str	r3, [r7, #96]	@ 0x60
      buf    = 0;
 8025196:	2300      	movs	r3, #0
 8025198:	66fb      	str	r3, [r7, #108]	@ 0x6c
  }

  /* empty window and reset  */
  bitbuf = 0;
 802519a:	2300      	movs	r3, #0
 802519c:	66bb      	str	r3, [r7, #104]	@ 0x68
  bitcpy = 0;
 802519e:	2300      	movs	r3, #0
 80251a0:	667b      	str	r3, [r7, #100]	@ 0x64

  for (;;) {
    /* grab next digit as required */
    if (--bitcnt == 0) {
 80251a2:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80251a4:	3b01      	subs	r3, #1
 80251a6:	663b      	str	r3, [r7, #96]	@ 0x60
 80251a8:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80251aa:	2b00      	cmp	r3, #0
 80251ac:	d10f      	bne.n	80251ce <_fp_exptmod_base_2+0x1b2>
      /* if digidx == -1 we are out of digits so break */
      if (digidx == -1) {
 80251ae:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80251b0:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 80251b4:	f000 808d 	beq.w	80252d2 <_fp_exptmod_base_2+0x2b6>
        break;
      }
      /* read next digit and reset bitcnt */
      buf    = X->dp[digidx--];
 80251b8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80251ba:	1e5a      	subs	r2, r3, #1
 80251bc:	65fa      	str	r2, [r7, #92]	@ 0x5c
 80251be:	68fa      	ldr	r2, [r7, #12]
 80251c0:	3302      	adds	r3, #2
 80251c2:	009b      	lsls	r3, r3, #2
 80251c4:	4413      	add	r3, r2
 80251c6:	685b      	ldr	r3, [r3, #4]
 80251c8:	66fb      	str	r3, [r7, #108]	@ 0x6c
      bitcnt = (int)DIGIT_BIT;
 80251ca:	2320      	movs	r3, #32
 80251cc:	663b      	str	r3, [r7, #96]	@ 0x60
    }

    /* grab the next msb from the exponent */
    y       = (int)(buf >> (DIGIT_BIT - 1)) & 1;
 80251ce:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80251d0:	0fdb      	lsrs	r3, r3, #31
 80251d2:	63bb      	str	r3, [r7, #56]	@ 0x38
    buf   <<= (fp_digit)1;
 80251d4:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80251d6:	005b      	lsls	r3, r3, #1
 80251d8:	66fb      	str	r3, [r7, #108]	@ 0x6c
    /* add bit to the window */
  #ifndef WC_PROTECT_ENCRYPTED_MEM
    bitbuf |= (y << (WINSIZE - ++bitcpy));
 80251da:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80251dc:	3301      	adds	r3, #1
 80251de:	667b      	str	r3, [r7, #100]	@ 0x64
 80251e0:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80251e2:	f1c3 0303 	rsb	r3, r3, #3
 80251e6:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 80251e8:	fa02 f303 	lsl.w	r3, r2, r3
 80251ec:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 80251ee:	4313      	orrs	r3, r2
 80251f0:	66bb      	str	r3, [r7, #104]	@ 0x68
  #else
    /* Ensure value changes even when y is zero. */
    bitbuf += (WINMASK + 1) + (y << (WINSIZE - ++bitcpy));
  #endif

    if (bitcpy == WINSIZE) {
 80251f2:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80251f4:	2b03      	cmp	r3, #3
 80251f6:	d1d4      	bne.n	80251a2 <_fp_exptmod_base_2+0x186>
      /* ok window is filled so square as required and multiply  */
      /* square first */
      for (x = 0; x < WINSIZE; x++) {
 80251f8:	2300      	movs	r3, #0
 80251fa:	65bb      	str	r3, [r7, #88]	@ 0x58
 80251fc:	e028      	b.n	8025250 <_fp_exptmod_base_2+0x234>
        err = fp_sqr(res, res);
 80251fe:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 8025200:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 8025202:	f000 f9f4 	bl	80255ee <fp_sqr>
 8025206:	64f8      	str	r0, [r7, #76]	@ 0x4c
        if (err != FP_OKAY) {
 8025208:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802520a:	2b00      	cmp	r3, #0
 802520c:	d009      	beq.n	8025222 <_fp_exptmod_base_2+0x206>
        #ifdef WOLFSSL_SMALL_STACK
          XFREE(res, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 802520e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8025210:	627b      	str	r3, [r7, #36]	@ 0x24
 8025212:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8025214:	2b00      	cmp	r3, #0
 8025216:	d002      	beq.n	802521e <_fp_exptmod_base_2+0x202>
 8025218:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 802521a:	f7f9 fc51 	bl	801eac0 <wolfSSL_Free>
        #endif
          return err;
 802521e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8025220:	e06c      	b.n	80252fc <_fp_exptmod_base_2+0x2e0>
        }
        err = fp_montgomery_reduce(res, P, mp);
 8025222:	697b      	ldr	r3, [r7, #20]
 8025224:	461a      	mov	r2, r3
 8025226:	6879      	ldr	r1, [r7, #4]
 8025228:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 802522a:	f000 fe9c 	bl	8025f66 <fp_montgomery_reduce>
 802522e:	64f8      	str	r0, [r7, #76]	@ 0x4c
        if (err != FP_OKAY) {
 8025230:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8025232:	2b00      	cmp	r3, #0
 8025234:	d009      	beq.n	802524a <_fp_exptmod_base_2+0x22e>
        #ifdef WOLFSSL_SMALL_STACK
          XFREE(res, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 8025236:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8025238:	62bb      	str	r3, [r7, #40]	@ 0x28
 802523a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802523c:	2b00      	cmp	r3, #0
 802523e:	d002      	beq.n	8025246 <_fp_exptmod_base_2+0x22a>
 8025240:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8025242:	f7f9 fc3d 	bl	801eac0 <wolfSSL_Free>
        #endif
          return err;
 8025246:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8025248:	e058      	b.n	80252fc <_fp_exptmod_base_2+0x2e0>
      for (x = 0; x < WINSIZE; x++) {
 802524a:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 802524c:	3301      	adds	r3, #1
 802524e:	65bb      	str	r3, [r7, #88]	@ 0x58
 8025250:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8025252:	2b02      	cmp	r3, #2
 8025254:	ddd3      	ble.n	80251fe <_fp_exptmod_base_2+0x1e2>
        }
      }

      /* then multiply by 2^bitbuf */
    #ifndef WC_PROTECT_ENCRYPTED_MEM
      err = fp_mul_2d(res, bitbuf, res);
 8025256:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8025258:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 802525a:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 802525c:	f7fd fb75 	bl	802294a <fp_mul_2d>
 8025260:	64f8      	str	r0, [r7, #76]	@ 0x4c
    #else
      /* Get the window bits. */
      err = fp_mul_2d(res, bitbuf & WINMASK, res);
    #endif
      if (err != FP_OKAY) {
 8025262:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8025264:	2b00      	cmp	r3, #0
 8025266:	d009      	beq.n	802527c <_fp_exptmod_base_2+0x260>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(res, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 8025268:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802526a:	62fb      	str	r3, [r7, #44]	@ 0x2c
 802526c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802526e:	2b00      	cmp	r3, #0
 8025270:	d002      	beq.n	8025278 <_fp_exptmod_base_2+0x25c>
 8025272:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8025274:	f7f9 fc24 	bl	801eac0 <wolfSSL_Free>
      #endif
        return err;
 8025278:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802527a:	e03f      	b.n	80252fc <_fp_exptmod_base_2+0x2e0>
      }
      /* Add in value to make mod operation take same time */
      err = fp_add(res, tmp, res);
 802527c:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 802527e:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 8025280:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 8025282:	f7fd f826 	bl	80222d2 <fp_add>
 8025286:	64f8      	str	r0, [r7, #76]	@ 0x4c
      if (err != FP_OKAY) {
 8025288:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802528a:	2b00      	cmp	r3, #0
 802528c:	d009      	beq.n	80252a2 <_fp_exptmod_base_2+0x286>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(res, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 802528e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8025290:	633b      	str	r3, [r7, #48]	@ 0x30
 8025292:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8025294:	2b00      	cmp	r3, #0
 8025296:	d002      	beq.n	802529e <_fp_exptmod_base_2+0x282>
 8025298:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 802529a:	f7f9 fc11 	bl	801eac0 <wolfSSL_Free>
      #endif
        return err;
 802529e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80252a0:	e02c      	b.n	80252fc <_fp_exptmod_base_2+0x2e0>
      }
      err = fp_mod(res, P, res);
 80252a2:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 80252a4:	6879      	ldr	r1, [r7, #4]
 80252a6:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 80252a8:	f7fe f992 	bl	80235d0 <fp_mod>
 80252ac:	64f8      	str	r0, [r7, #76]	@ 0x4c
      if (err != FP_OKAY) {
 80252ae:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80252b0:	2b00      	cmp	r3, #0
 80252b2:	d009      	beq.n	80252c8 <_fp_exptmod_base_2+0x2ac>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(res, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 80252b4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80252b6:	637b      	str	r3, [r7, #52]	@ 0x34
 80252b8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80252ba:	2b00      	cmp	r3, #0
 80252bc:	d002      	beq.n	80252c4 <_fp_exptmod_base_2+0x2a8>
 80252be:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 80252c0:	f7f9 fbfe 	bl	801eac0 <wolfSSL_Free>
      #endif
        return err;
 80252c4:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80252c6:	e019      	b.n	80252fc <_fp_exptmod_base_2+0x2e0>
      }

      /* empty window and reset */
      bitcpy = 0;
 80252c8:	2300      	movs	r3, #0
 80252ca:	667b      	str	r3, [r7, #100]	@ 0x64
    #ifndef WC_PROTECT_ENCRYPTED_MEM
      bitbuf = 0;
 80252cc:	2300      	movs	r3, #0
 80252ce:	66bb      	str	r3, [r7, #104]	@ 0x68
    if (--bitcnt == 0) {
 80252d0:	e767      	b.n	80251a2 <_fp_exptmod_base_2+0x186>
        break;
 80252d2:	bf00      	nop
   * recall that any value in a Montgomery system is
   * actually multiplied by R mod n.  So we have
   * to reduce one more time to cancel out the factor
   * of R.
   */
  err = fp_montgomery_reduce(res, P, mp);
 80252d4:	697b      	ldr	r3, [r7, #20]
 80252d6:	461a      	mov	r2, r3
 80252d8:	6879      	ldr	r1, [r7, #4]
 80252da:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 80252dc:	f000 fe43 	bl	8025f66 <fp_montgomery_reduce>
 80252e0:	64f8      	str	r0, [r7, #76]	@ 0x4c

  /* swap res with Y */
  fp_copy(res, Y);
 80252e2:	6839      	ldr	r1, [r7, #0]
 80252e4:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 80252e6:	f001 fbcd 	bl	8026a84 <fp_copy>

#ifdef WOLFSSL_SMALL_STACK
  XFREE(res, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 80252ea:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80252ec:	63fb      	str	r3, [r7, #60]	@ 0x3c
 80252ee:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80252f0:	2b00      	cmp	r3, #0
 80252f2:	d002      	beq.n	80252fa <_fp_exptmod_base_2+0x2de>
 80252f4:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 80252f6:	f7f9 fbe3 	bl	801eac0 <wolfSSL_Free>
#endif
  return err;
 80252fa:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
}
 80252fc:	4618      	mov	r0, r3
 80252fe:	3770      	adds	r7, #112	@ 0x70
 8025300:	46bd      	mov	sp, r7
 8025302:	bd80      	pop	{r7, pc}
 8025304:	55555556 	.word	0x55555556

08025308 <fp_exptmod>:
#undef WINSIZE
#endif

/* Y = (G * X) mod P */
int fp_exptmod(fp_int * G, fp_int * X, fp_int * P, fp_int * Y)
{
 8025308:	b580      	push	{r7, lr}
 802530a:	b08a      	sub	sp, #40	@ 0x28
 802530c:	af02      	add	r7, sp, #8
 802530e:	60f8      	str	r0, [r7, #12]
 8025310:	60b9      	str	r1, [r7, #8]
 8025312:	607a      	str	r2, [r7, #4]
 8025314:	603b      	str	r3, [r7, #0]
#if defined(WOLFSSL_ESP32_CRYPT_RSA_PRI_EXPTMOD)
    int retHW = FP_OKAY;
#endif

   /* handle modulus of zero and prevent overflows */
   if (fp_iszero(P) || (P->used > (FP_SIZE/2))) {
 8025316:	687b      	ldr	r3, [r7, #4]
 8025318:	681b      	ldr	r3, [r3, #0]
 802531a:	2b00      	cmp	r3, #0
 802531c:	d003      	beq.n	8025326 <fp_exptmod+0x1e>
 802531e:	687b      	ldr	r3, [r7, #4]
 8025320:	681b      	ldr	r3, [r3, #0]
 8025322:	2b44      	cmp	r3, #68	@ 0x44
 8025324:	dd02      	ble.n	802532c <fp_exptmod+0x24>
      return FP_VAL;
 8025326:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 802532a:	e09c      	b.n	8025466 <fp_exptmod+0x15e>
   }
   if (fp_isone(P)) {
 802532c:	687b      	ldr	r3, [r7, #4]
 802532e:	681b      	ldr	r3, [r3, #0]
 8025330:	2b01      	cmp	r3, #1
 8025332:	d10d      	bne.n	8025350 <fp_exptmod+0x48>
 8025334:	687b      	ldr	r3, [r7, #4]
 8025336:	68db      	ldr	r3, [r3, #12]
 8025338:	2b01      	cmp	r3, #1
 802533a:	d109      	bne.n	8025350 <fp_exptmod+0x48>
 802533c:	687b      	ldr	r3, [r7, #4]
 802533e:	685b      	ldr	r3, [r3, #4]
 8025340:	2b00      	cmp	r3, #0
 8025342:	d105      	bne.n	8025350 <fp_exptmod+0x48>
      fp_set(Y, 0);
 8025344:	2100      	movs	r1, #0
 8025346:	6838      	ldr	r0, [r7, #0]
 8025348:	f000 ff83 	bl	8026252 <fp_set>
      return FP_OKAY;
 802534c:	2300      	movs	r3, #0
 802534e:	e08a      	b.n	8025466 <fp_exptmod+0x15e>
   }
   if (fp_iszero(X)) {
 8025350:	68bb      	ldr	r3, [r7, #8]
 8025352:	681b      	ldr	r3, [r3, #0]
 8025354:	2b00      	cmp	r3, #0
 8025356:	d105      	bne.n	8025364 <fp_exptmod+0x5c>
      fp_set(Y, 1);
 8025358:	2101      	movs	r1, #1
 802535a:	6838      	ldr	r0, [r7, #0]
 802535c:	f000 ff79 	bl	8026252 <fp_set>
      return FP_OKAY;
 8025360:	2300      	movs	r3, #0
 8025362:	e080      	b.n	8025466 <fp_exptmod+0x15e>
   }
   if (fp_iszero(G)) {
 8025364:	68fb      	ldr	r3, [r7, #12]
 8025366:	681b      	ldr	r3, [r3, #0]
 8025368:	2b00      	cmp	r3, #0
 802536a:	d105      	bne.n	8025378 <fp_exptmod+0x70>
      fp_set(Y, 0);
 802536c:	2100      	movs	r1, #0
 802536e:	6838      	ldr	r0, [r7, #0]
 8025370:	f000 ff6f 	bl	8026252 <fp_set>
      return FP_OKAY;
 8025374:	2300      	movs	r3, #0
 8025376:	e076      	b.n	8025466 <fp_exptmod+0x15e>
      } /* switch */
   } /* if validation check */
   /* fall through to software calcs */
#endif /* WOLFSSL_ESP32_CRYPT_RSA_PRI_EXPTMOD */

   if (X->sign == FP_NEG) {
 8025378:	68bb      	ldr	r3, [r7, #8]
 802537a:	685b      	ldr	r3, [r3, #4]
 802537c:	2b01      	cmp	r3, #1
 802537e:	d157      	bne.n	8025430 <fp_exptmod+0x128>
   #else
      fp_int *tmp;
   #endif

   #ifdef WOLFSSL_SMALL_STACK
      tmp = (fp_int*)XMALLOC(sizeof(fp_int) * 2, NULL, DYNAMIC_TYPE_BIGINT);
 8025380:	f44f 608b 	mov.w	r0, #1112	@ 0x458
 8025384:	f7f9 fb80 	bl	801ea88 <wolfSSL_Malloc>
 8025388:	61b8      	str	r0, [r7, #24]
      if (tmp == NULL)
 802538a:	69bb      	ldr	r3, [r7, #24]
 802538c:	2b00      	cmp	r3, #0
 802538e:	d102      	bne.n	8025396 <fp_exptmod+0x8e>
          return FP_MEM;
 8025390:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 8025394:	e067      	b.n	8025466 <fp_exptmod+0x15e>
   #endif

      /* yes, copy G and invmod it */
      fp_init_copy(&tmp[0], G);
 8025396:	68f9      	ldr	r1, [r7, #12]
 8025398:	69b8      	ldr	r0, [r7, #24]
 802539a:	f001 fbb2 	bl	8026b02 <fp_init_copy>
      fp_init_copy(&tmp[1], P);
 802539e:	69bb      	ldr	r3, [r7, #24]
 80253a0:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 80253a4:	6879      	ldr	r1, [r7, #4]
 80253a6:	4618      	mov	r0, r3
 80253a8:	f001 fbab 	bl	8026b02 <fp_init_copy>
      tmp[1].sign = FP_ZPOS;
 80253ac:	69bb      	ldr	r3, [r7, #24]
 80253ae:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 80253b2:	2200      	movs	r2, #0
 80253b4:	605a      	str	r2, [r3, #4]
      err = fp_invmod(&tmp[0], &tmp[1], &tmp[0]);
 80253b6:	69bb      	ldr	r3, [r7, #24]
 80253b8:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 80253bc:	69ba      	ldr	r2, [r7, #24]
 80253be:	4619      	mov	r1, r3
 80253c0:	69b8      	ldr	r0, [r7, #24]
 80253c2:	f7fe fc5c 	bl	8023c7e <fp_invmod>
 80253c6:	61f8      	str	r0, [r7, #28]
      if (err == FP_OKAY) {
 80253c8:	69fb      	ldr	r3, [r7, #28]
 80253ca:	2b00      	cmp	r3, #0
 80253cc:	d126      	bne.n	802541c <fp_exptmod+0x114>
         fp_copy(X, &tmp[1]);
 80253ce:	69bb      	ldr	r3, [r7, #24]
 80253d0:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 80253d4:	4619      	mov	r1, r3
 80253d6:	68b8      	ldr	r0, [r7, #8]
 80253d8:	f001 fb54 	bl	8026a84 <fp_copy>
         tmp[1].sign = FP_ZPOS;
 80253dc:	69bb      	ldr	r3, [r7, #24]
 80253de:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 80253e2:	2200      	movs	r2, #0
 80253e4:	605a      	str	r2, [r3, #4]
   #ifdef TFM_TIMING_RESISTANT
         err =  _fp_exptmod_ct(&tmp[0], &tmp[1], tmp[1].used, P, Y);
 80253e6:	69bb      	ldr	r3, [r7, #24]
 80253e8:	f503 710b 	add.w	r1, r3, #556	@ 0x22c
 80253ec:	69bb      	ldr	r3, [r7, #24]
 80253ee:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 80253f2:	681a      	ldr	r2, [r3, #0]
 80253f4:	683b      	ldr	r3, [r7, #0]
 80253f6:	9300      	str	r3, [sp, #0]
 80253f8:	687b      	ldr	r3, [r7, #4]
 80253fa:	69b8      	ldr	r0, [r7, #24]
 80253fc:	f7ff f9d4 	bl	80247a8 <_fp_exptmod_ct>
 8025400:	61f8      	str	r0, [r7, #28]
   #else
         err =  _fp_exptmod_nct(&tmp[0], &tmp[1], P, Y);
   #endif
         if ((err == 0) && (P->sign == FP_NEG)) {
 8025402:	69fb      	ldr	r3, [r7, #28]
 8025404:	2b00      	cmp	r3, #0
 8025406:	d109      	bne.n	802541c <fp_exptmod+0x114>
 8025408:	687b      	ldr	r3, [r7, #4]
 802540a:	685b      	ldr	r3, [r3, #4]
 802540c:	2b01      	cmp	r3, #1
 802540e:	d105      	bne.n	802541c <fp_exptmod+0x114>
            err = fp_add(Y, P, Y);
 8025410:	683a      	ldr	r2, [r7, #0]
 8025412:	6879      	ldr	r1, [r7, #4]
 8025414:	6838      	ldr	r0, [r7, #0]
 8025416:	f7fc ff5c 	bl	80222d2 <fp_add>
 802541a:	61f8      	str	r0, [r7, #28]
         }
      }
   #ifdef WOLFSSL_SMALL_STACK
      XFREE(tmp, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 802541c:	69bb      	ldr	r3, [r7, #24]
 802541e:	617b      	str	r3, [r7, #20]
 8025420:	697b      	ldr	r3, [r7, #20]
 8025422:	2b00      	cmp	r3, #0
 8025424:	d002      	beq.n	802542c <fp_exptmod+0x124>
 8025426:	6978      	ldr	r0, [r7, #20]
 8025428:	f7f9 fb4a 	bl	801eac0 <wolfSSL_Free>
   #endif
      return err;
 802542c:	69fb      	ldr	r3, [r7, #28]
 802542e:	e01a      	b.n	8025466 <fp_exptmod+0x15e>
#else
      return FP_VAL;
#endif /* POSITIVE_EXP_ONLY check */
   }
   else if (G->used == 1 && G->dp[0] == 2) {
 8025430:	68fb      	ldr	r3, [r7, #12]
 8025432:	681b      	ldr	r3, [r3, #0]
 8025434:	2b01      	cmp	r3, #1
 8025436:	d10c      	bne.n	8025452 <fp_exptmod+0x14a>
 8025438:	68fb      	ldr	r3, [r7, #12]
 802543a:	68db      	ldr	r3, [r3, #12]
 802543c:	2b02      	cmp	r3, #2
 802543e:	d108      	bne.n	8025452 <fp_exptmod+0x14a>
      return _fp_exptmod_base_2(X, X->used, P, Y);
 8025440:	68bb      	ldr	r3, [r7, #8]
 8025442:	6819      	ldr	r1, [r3, #0]
 8025444:	683b      	ldr	r3, [r7, #0]
 8025446:	687a      	ldr	r2, [r7, #4]
 8025448:	68b8      	ldr	r0, [r7, #8]
 802544a:	f7ff fde7 	bl	802501c <_fp_exptmod_base_2>
 802544e:	4603      	mov	r3, r0
 8025450:	e009      	b.n	8025466 <fp_exptmod+0x15e>
   }
   else {
      /* Positive exponent so just exptmod */
#ifdef TFM_TIMING_RESISTANT
      return _fp_exptmod_ct(G, X, X->used, P, Y);
 8025452:	68bb      	ldr	r3, [r7, #8]
 8025454:	681a      	ldr	r2, [r3, #0]
 8025456:	683b      	ldr	r3, [r7, #0]
 8025458:	9300      	str	r3, [sp, #0]
 802545a:	687b      	ldr	r3, [r7, #4]
 802545c:	68b9      	ldr	r1, [r7, #8]
 802545e:	68f8      	ldr	r0, [r7, #12]
 8025460:	f7ff f9a2 	bl	80247a8 <_fp_exptmod_ct>
 8025464:	4603      	mov	r3, r0
#else
      return _fp_exptmod_nct(G, X, P, Y);
#endif
   }
}
 8025466:	4618      	mov	r0, r3
 8025468:	3720      	adds	r7, #32
 802546a:	46bd      	mov	sp, r7
 802546c:	bd80      	pop	{r7, pc}

0802546e <fp_exptmod_nct>:
#endif
   }
}

int fp_exptmod_nct(fp_int * G, fp_int * X, fp_int * P, fp_int * Y)
{
 802546e:	b580      	push	{r7, lr}
 8025470:	b088      	sub	sp, #32
 8025472:	af00      	add	r7, sp, #0
 8025474:	60f8      	str	r0, [r7, #12]
 8025476:	60b9      	str	r1, [r7, #8]
 8025478:	607a      	str	r2, [r7, #4]
 802547a:	603b      	str	r3, [r7, #0]
#if defined(WOLFSSL_ESP32_CRYPT_RSA_PRI_EXPTMOD)
   int retHW = FP_OKAY;
#endif

   /* handle modulus of zero and prevent overflows */
   if (fp_iszero(P) || (P->used > (FP_SIZE/2))) {
 802547c:	687b      	ldr	r3, [r7, #4]
 802547e:	681b      	ldr	r3, [r3, #0]
 8025480:	2b00      	cmp	r3, #0
 8025482:	d003      	beq.n	802548c <fp_exptmod_nct+0x1e>
 8025484:	687b      	ldr	r3, [r7, #4]
 8025486:	681b      	ldr	r3, [r3, #0]
 8025488:	2b44      	cmp	r3, #68	@ 0x44
 802548a:	dd02      	ble.n	8025492 <fp_exptmod_nct+0x24>
      return FP_VAL;
 802548c:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8025490:	e07f      	b.n	8025592 <fp_exptmod_nct+0x124>
   }
   if (fp_isone(P)) {
 8025492:	687b      	ldr	r3, [r7, #4]
 8025494:	681b      	ldr	r3, [r3, #0]
 8025496:	2b01      	cmp	r3, #1
 8025498:	d10d      	bne.n	80254b6 <fp_exptmod_nct+0x48>
 802549a:	687b      	ldr	r3, [r7, #4]
 802549c:	68db      	ldr	r3, [r3, #12]
 802549e:	2b01      	cmp	r3, #1
 80254a0:	d109      	bne.n	80254b6 <fp_exptmod_nct+0x48>
 80254a2:	687b      	ldr	r3, [r7, #4]
 80254a4:	685b      	ldr	r3, [r3, #4]
 80254a6:	2b00      	cmp	r3, #0
 80254a8:	d105      	bne.n	80254b6 <fp_exptmod_nct+0x48>
      fp_set(Y, 0);
 80254aa:	2100      	movs	r1, #0
 80254ac:	6838      	ldr	r0, [r7, #0]
 80254ae:	f000 fed0 	bl	8026252 <fp_set>
      return FP_OKAY;
 80254b2:	2300      	movs	r3, #0
 80254b4:	e06d      	b.n	8025592 <fp_exptmod_nct+0x124>
   }
   if (fp_iszero(X)) {
 80254b6:	68bb      	ldr	r3, [r7, #8]
 80254b8:	681b      	ldr	r3, [r3, #0]
 80254ba:	2b00      	cmp	r3, #0
 80254bc:	d105      	bne.n	80254ca <fp_exptmod_nct+0x5c>
      fp_set(Y, 1);
 80254be:	2101      	movs	r1, #1
 80254c0:	6838      	ldr	r0, [r7, #0]
 80254c2:	f000 fec6 	bl	8026252 <fp_set>
      return FP_OKAY;
 80254c6:	2300      	movs	r3, #0
 80254c8:	e063      	b.n	8025592 <fp_exptmod_nct+0x124>
   }
   if (fp_iszero(G)) {
 80254ca:	68fb      	ldr	r3, [r7, #12]
 80254cc:	681b      	ldr	r3, [r3, #0]
 80254ce:	2b00      	cmp	r3, #0
 80254d0:	d105      	bne.n	80254de <fp_exptmod_nct+0x70>
      fp_set(Y, 0);
 80254d2:	2100      	movs	r1, #0
 80254d4:	6838      	ldr	r0, [r7, #0]
 80254d6:	f000 febc 	bl	8026252 <fp_set>
      return FP_OKAY;
 80254da:	2300      	movs	r3, #0
 80254dc:	e059      	b.n	8025592 <fp_exptmod_nct+0x124>
         break;
   }
   /* falling through to SW: */
#endif

   if (X->sign == FP_NEG) {
 80254de:	68bb      	ldr	r3, [r7, #8]
 80254e0:	685b      	ldr	r3, [r3, #4]
 80254e2:	2b01      	cmp	r3, #1
 80254e4:	d14e      	bne.n	8025584 <fp_exptmod_nct+0x116>
   #else
      fp_int *tmp;
   #endif

   #ifdef WOLFSSL_SMALL_STACK
      tmp = (fp_int*)XMALLOC(sizeof(fp_int) * 2, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 80254e6:	f44f 608b 	mov.w	r0, #1112	@ 0x458
 80254ea:	f7f9 facd 	bl	801ea88 <wolfSSL_Malloc>
 80254ee:	61b8      	str	r0, [r7, #24]
      if (tmp == NULL)
 80254f0:	69bb      	ldr	r3, [r7, #24]
 80254f2:	2b00      	cmp	r3, #0
 80254f4:	d102      	bne.n	80254fc <fp_exptmod_nct+0x8e>
          return FP_MEM;
 80254f6:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 80254fa:	e04a      	b.n	8025592 <fp_exptmod_nct+0x124>
   #endif

      /* yes, copy G and invmod it */
      fp_init_copy(&tmp[0], G);
 80254fc:	68f9      	ldr	r1, [r7, #12]
 80254fe:	69b8      	ldr	r0, [r7, #24]
 8025500:	f001 faff 	bl	8026b02 <fp_init_copy>
      fp_init_copy(&tmp[1], P);
 8025504:	69bb      	ldr	r3, [r7, #24]
 8025506:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 802550a:	6879      	ldr	r1, [r7, #4]
 802550c:	4618      	mov	r0, r3
 802550e:	f001 faf8 	bl	8026b02 <fp_init_copy>
      tmp[1].sign = FP_ZPOS;
 8025512:	69bb      	ldr	r3, [r7, #24]
 8025514:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8025518:	2200      	movs	r2, #0
 802551a:	605a      	str	r2, [r3, #4]
      err = fp_invmod(&tmp[0], &tmp[1], &tmp[0]);
 802551c:	69bb      	ldr	r3, [r7, #24]
 802551e:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8025522:	69ba      	ldr	r2, [r7, #24]
 8025524:	4619      	mov	r1, r3
 8025526:	69b8      	ldr	r0, [r7, #24]
 8025528:	f7fe fba9 	bl	8023c7e <fp_invmod>
 802552c:	61f8      	str	r0, [r7, #28]
      if (err == FP_OKAY) {
 802552e:	69fb      	ldr	r3, [r7, #28]
 8025530:	2b00      	cmp	r3, #0
 8025532:	d11d      	bne.n	8025570 <fp_exptmod_nct+0x102>
         X->sign = FP_ZPOS;
 8025534:	68bb      	ldr	r3, [r7, #8]
 8025536:	2200      	movs	r2, #0
 8025538:	605a      	str	r2, [r3, #4]
         err =  _fp_exptmod_nct(&tmp[0], X, P, Y);
 802553a:	683b      	ldr	r3, [r7, #0]
 802553c:	687a      	ldr	r2, [r7, #4]
 802553e:	68b9      	ldr	r1, [r7, #8]
 8025540:	69b8      	ldr	r0, [r7, #24]
 8025542:	f7ff fa91 	bl	8024a68 <_fp_exptmod_nct>
 8025546:	61f8      	str	r0, [r7, #28]
         if (X != Y) {
 8025548:	68ba      	ldr	r2, [r7, #8]
 802554a:	683b      	ldr	r3, [r7, #0]
 802554c:	429a      	cmp	r2, r3
 802554e:	d002      	beq.n	8025556 <fp_exptmod_nct+0xe8>
            X->sign = FP_NEG;
 8025550:	68bb      	ldr	r3, [r7, #8]
 8025552:	2201      	movs	r2, #1
 8025554:	605a      	str	r2, [r3, #4]
         }
         if ((err == 0) && (P->sign == FP_NEG)) {
 8025556:	69fb      	ldr	r3, [r7, #28]
 8025558:	2b00      	cmp	r3, #0
 802555a:	d109      	bne.n	8025570 <fp_exptmod_nct+0x102>
 802555c:	687b      	ldr	r3, [r7, #4]
 802555e:	685b      	ldr	r3, [r3, #4]
 8025560:	2b01      	cmp	r3, #1
 8025562:	d105      	bne.n	8025570 <fp_exptmod_nct+0x102>
            err = fp_add(Y, P, Y);
 8025564:	683a      	ldr	r2, [r7, #0]
 8025566:	6879      	ldr	r1, [r7, #4]
 8025568:	6838      	ldr	r0, [r7, #0]
 802556a:	f7fc feb2 	bl	80222d2 <fp_add>
 802556e:	61f8      	str	r0, [r7, #28]
         }
      }
   #ifdef WOLFSSL_SMALL_STACK
      XFREE(tmp, NULL, DYNAMIC_TYPE_BIGINT);
 8025570:	69bb      	ldr	r3, [r7, #24]
 8025572:	617b      	str	r3, [r7, #20]
 8025574:	697b      	ldr	r3, [r7, #20]
 8025576:	2b00      	cmp	r3, #0
 8025578:	d002      	beq.n	8025580 <fp_exptmod_nct+0x112>
 802557a:	6978      	ldr	r0, [r7, #20]
 802557c:	f7f9 faa0 	bl	801eac0 <wolfSSL_Free>
   #endif
      return err;
 8025580:	69fb      	ldr	r3, [r7, #28]
 8025582:	e006      	b.n	8025592 <fp_exptmod_nct+0x124>
      return FP_VAL;
#endif
   }
   else {
      /* Positive exponent so just exptmod */
      return  _fp_exptmod_nct(G, X, P, Y);
 8025584:	683b      	ldr	r3, [r7, #0]
 8025586:	687a      	ldr	r2, [r7, #4]
 8025588:	68b9      	ldr	r1, [r7, #8]
 802558a:	68f8      	ldr	r0, [r7, #12]
 802558c:	f7ff fa6c 	bl	8024a68 <_fp_exptmod_nct>
 8025590:	4603      	mov	r3, r0
   }
}
 8025592:	4618      	mov	r0, r3
 8025594:	3720      	adds	r7, #32
 8025596:	46bd      	mov	sp, r7
 8025598:	bd80      	pop	{r7, pc}

0802559a <fp_2expt>:

/* computes a = 2**b */
void fp_2expt(fp_int *a, int b)
{
 802559a:	b580      	push	{r7, lr}
 802559c:	b084      	sub	sp, #16
 802559e:	af00      	add	r7, sp, #0
 80255a0:	6078      	str	r0, [r7, #4]
 80255a2:	6039      	str	r1, [r7, #0]
   int     z;

   /* zero a as per default */
   fp_zero (a);
 80255a4:	6878      	ldr	r0, [r7, #4]
 80255a6:	f001 f891 	bl	80266cc <fp_zero>

   if (b < 0) {
 80255aa:	683b      	ldr	r3, [r7, #0]
 80255ac:	2b00      	cmp	r3, #0
 80255ae:	db18      	blt.n	80255e2 <fp_2expt+0x48>
      return;
   }

   z = b / DIGIT_BIT;
 80255b0:	683b      	ldr	r3, [r7, #0]
 80255b2:	2b00      	cmp	r3, #0
 80255b4:	da00      	bge.n	80255b8 <fp_2expt+0x1e>
 80255b6:	331f      	adds	r3, #31
 80255b8:	115b      	asrs	r3, r3, #5
 80255ba:	60fb      	str	r3, [r7, #12]
   if (z >= FP_SIZE) {
 80255bc:	68fb      	ldr	r3, [r7, #12]
 80255be:	2b87      	cmp	r3, #135	@ 0x87
 80255c0:	dc11      	bgt.n	80255e6 <fp_2expt+0x4c>
      return;
   }

  /* set the used count of where the bit will go */
  a->used = z + 1;
 80255c2:	68fb      	ldr	r3, [r7, #12]
 80255c4:	1c5a      	adds	r2, r3, #1
 80255c6:	687b      	ldr	r3, [r7, #4]
 80255c8:	601a      	str	r2, [r3, #0]

  /* put the single bit in its place */
  a->dp[z] = ((fp_digit)1) << (b % DIGIT_BIT);
 80255ca:	683b      	ldr	r3, [r7, #0]
 80255cc:	f003 031f 	and.w	r3, r3, #31
 80255d0:	2201      	movs	r2, #1
 80255d2:	409a      	lsls	r2, r3
 80255d4:	6879      	ldr	r1, [r7, #4]
 80255d6:	68fb      	ldr	r3, [r7, #12]
 80255d8:	3302      	adds	r3, #2
 80255da:	009b      	lsls	r3, r3, #2
 80255dc:	440b      	add	r3, r1
 80255de:	605a      	str	r2, [r3, #4]
 80255e0:	e002      	b.n	80255e8 <fp_2expt+0x4e>
      return;
 80255e2:	bf00      	nop
 80255e4:	e000      	b.n	80255e8 <fp_2expt+0x4e>
      return;
 80255e6:	bf00      	nop
}
 80255e8:	3710      	adds	r7, #16
 80255ea:	46bd      	mov	sp, r7
 80255ec:	bd80      	pop	{r7, pc}

080255ee <fp_sqr>:

/* b = a*a  */
int fp_sqr(fp_int *A, fp_int *B)
{
 80255ee:	b580      	push	{r7, lr}
 80255f0:	b086      	sub	sp, #24
 80255f2:	af00      	add	r7, sp, #0
 80255f4:	6078      	str	r0, [r7, #4]
 80255f6:	6039      	str	r1, [r7, #0]
    int err;
    int y, oldused;

    oldused = B->used;
 80255f8:	683b      	ldr	r3, [r7, #0]
 80255fa:	681b      	ldr	r3, [r3, #0]
 80255fc:	60fb      	str	r3, [r7, #12]
    y = A->used;
 80255fe:	687b      	ldr	r3, [r7, #4]
 8025600:	681b      	ldr	r3, [r3, #0]
 8025602:	613b      	str	r3, [r7, #16]

    /* error if we're out of range */
    if (y + y >= FP_SIZE) {
 8025604:	693b      	ldr	r3, [r7, #16]
 8025606:	005b      	lsls	r3, r3, #1
 8025608:	2b87      	cmp	r3, #135	@ 0x87
 802560a:	dd03      	ble.n	8025614 <fp_sqr+0x26>
       err = FP_VAL;
 802560c:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8025610:	617b      	str	r3, [r7, #20]
       goto clean;
 8025612:	e004      	b.n	802561e <fp_sqr+0x30>
        if (y <= 64) {
           err = fp_sqr_comba64(A,B);
           goto clean;
        }
#endif
       err = fp_sqr_comba(A, B);
 8025614:	6839      	ldr	r1, [r7, #0]
 8025616:	6878      	ldr	r0, [r7, #4]
 8025618:	f000 f81b 	bl	8025652 <fp_sqr_comba>
 802561c:	6178      	str	r0, [r7, #20]

clean:
  /* zero any excess digits on the destination that we didn't write to */
  for (y = B->used; y >= 0 && y < oldused; y++) {
 802561e:	683b      	ldr	r3, [r7, #0]
 8025620:	681b      	ldr	r3, [r3, #0]
 8025622:	613b      	str	r3, [r7, #16]
 8025624:	e009      	b.n	802563a <fp_sqr+0x4c>
    B->dp[y] = 0;
 8025626:	683a      	ldr	r2, [r7, #0]
 8025628:	693b      	ldr	r3, [r7, #16]
 802562a:	3302      	adds	r3, #2
 802562c:	009b      	lsls	r3, r3, #2
 802562e:	4413      	add	r3, r2
 8025630:	2200      	movs	r2, #0
 8025632:	605a      	str	r2, [r3, #4]
  for (y = B->used; y >= 0 && y < oldused; y++) {
 8025634:	693b      	ldr	r3, [r7, #16]
 8025636:	3301      	adds	r3, #1
 8025638:	613b      	str	r3, [r7, #16]
 802563a:	693b      	ldr	r3, [r7, #16]
 802563c:	2b00      	cmp	r3, #0
 802563e:	db03      	blt.n	8025648 <fp_sqr+0x5a>
 8025640:	693a      	ldr	r2, [r7, #16]
 8025642:	68fb      	ldr	r3, [r7, #12]
 8025644:	429a      	cmp	r2, r3
 8025646:	dbee      	blt.n	8025626 <fp_sqr+0x38>
  }

  return err;
 8025648:	697b      	ldr	r3, [r7, #20]
}
 802564a:	4618      	mov	r0, r3
 802564c:	3718      	adds	r7, #24
 802564e:	46bd      	mov	sp, r7
 8025650:	bd80      	pop	{r7, pc}

08025652 <fp_sqr_comba>:

/* generic comba squarer */
int fp_sqr_comba(fp_int *A, fp_int *B)
{
 8025652:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8025656:	b0b6      	sub	sp, #216	@ 0xd8
 8025658:	af00      	add	r7, sp, #0
 802565a:	67f8      	str	r0, [r7, #124]	@ 0x7c
 802565c:	67b9      	str	r1, [r7, #120]	@ 0x78
  int       pa, ix, iz;
  fp_digit  c0, c1, c2;
#ifdef TFM_ISO
  fp_word   tt = 0;
 802565e:	f04f 0200 	mov.w	r2, #0
 8025662:	f04f 0300 	mov.w	r3, #0
 8025666:	e9c7 232a 	strd	r2, r3, [r7, #168]	@ 0xa8
#else
   fp_int    *tmp;
#endif

#ifdef WOLFSSL_SMALL_STACK
   tmp = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
 802566a:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 802566e:	f7f9 fa0b 	bl	801ea88 <wolfSSL_Malloc>
 8025672:	f8c7 00a4 	str.w	r0, [r7, #164]	@ 0xa4
   if (tmp == NULL)
 8025676:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 802567a:	2b00      	cmp	r3, #0
 802567c:	d102      	bne.n	8025684 <fp_sqr_comba+0x32>
       return FP_MEM;
 802567e:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 8025682:	e1f6      	b.n	8025a72 <fp_sqr_comba+0x420>
#endif

  /* get size of output and trim */
  pa = A->used + A->used;
 8025684:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8025686:	681b      	ldr	r3, [r3, #0]
 8025688:	005b      	lsls	r3, r3, #1
 802568a:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
  if (pa >= FP_SIZE) {
 802568e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8025692:	2b87      	cmp	r3, #135	@ 0x87
 8025694:	dd02      	ble.n	802569c <fp_sqr_comba+0x4a>
     pa = FP_SIZE-1;
 8025696:	2387      	movs	r3, #135	@ 0x87
 8025698:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
  }

  /* number of output digits to produce */
  COMBA_START;
  COMBA_CLEAR;
 802569c:	2300      	movs	r3, #0
 802569e:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 80256a2:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 80256a6:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
 80256aa:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80256ae:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8

  if (A == B) {
 80256b2:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 80256b4:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 80256b6:	429a      	cmp	r2, r3
 80256b8:	d108      	bne.n	80256cc <fp_sqr_comba+0x7a>
     fp_init(tmp);
 80256ba:	f8d7 00a4 	ldr.w	r0, [r7, #164]	@ 0xa4
 80256be:	f000 fff7 	bl	80266b0 <fp_init>
     dst = tmp;
 80256c2:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 80256c6:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
 80256ca:	e005      	b.n	80256d8 <fp_sqr_comba+0x86>
  } else {
     fp_zero(B);
 80256cc:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 80256ce:	f000 fffd 	bl	80266cc <fp_zero>
     dst = B;
 80256d2:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 80256d4:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
  }

  for (ix = 0; ix < pa; ix++) {
 80256d8:	2300      	movs	r3, #0
 80256da:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
 80256de:	e17f      	b.n	80259e0 <fp_sqr_comba+0x38e>
      int      tx, ty, iy;
      fp_digit *tmpy, *tmpx;

      /* get offsets into the two bignums */
      ty = MIN(A->used-1, ix);
 80256e0:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 80256e2:	681a      	ldr	r2, [r3, #0]
 80256e4:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 80256e8:	4293      	cmp	r3, r2
 80256ea:	db03      	blt.n	80256f4 <fp_sqr_comba+0xa2>
 80256ec:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 80256ee:	681b      	ldr	r3, [r3, #0]
 80256f0:	3b01      	subs	r3, #1
 80256f2:	e001      	b.n	80256f8 <fp_sqr_comba+0xa6>
 80256f4:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 80256f8:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
      tx = ix - ty;
 80256fc:	f8d7 20d0 	ldr.w	r2, [r7, #208]	@ 0xd0
 8025700:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 8025704:	1ad3      	subs	r3, r2, r3
 8025706:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98

      /* setup temp aliases */
      tmpx = A->dp + tx;
 802570a:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 802570c:	f103 020c 	add.w	r2, r3, #12
 8025710:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 8025714:	009b      	lsls	r3, r3, #2
 8025716:	4413      	add	r3, r2
 8025718:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
      tmpy = A->dp + ty;
 802571c:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 802571e:	f103 020c 	add.w	r2, r3, #12
 8025722:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 8025726:	009b      	lsls	r3, r3, #2
 8025728:	4413      	add	r3, r2
 802572a:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8

      /* this is the number of times the loop will iterate,
         while (tx++ < a->used && ty-- >= 0) { ... }
       */
      iy = MIN(A->used-tx, ty+1);
 802572e:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8025730:	681a      	ldr	r2, [r3, #0]
 8025732:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 8025736:	1ad2      	subs	r2, r2, r3
 8025738:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 802573c:	4293      	cmp	r3, r2
 802573e:	db05      	blt.n	802574c <fp_sqr_comba+0xfa>
 8025740:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8025742:	681a      	ldr	r2, [r3, #0]
 8025744:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 8025748:	1ad3      	subs	r3, r2, r3
 802574a:	e002      	b.n	8025752 <fp_sqr_comba+0x100>
 802574c:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 8025750:	3301      	adds	r3, #1
 8025752:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
      /* now for squaring tx can never equal ty
       * we halve the distance since they approach
       * at a rate of 2x and we have to round because
       * odd cases need to be executed
       */
      iy = MIN(iy, (ty-tx+1)>>1);
 8025756:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 802575a:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 802575e:	1ad3      	subs	r3, r2, r3
 8025760:	3301      	adds	r3, #1
 8025762:	105a      	asrs	r2, r3, #1
 8025764:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 8025768:	4293      	cmp	r3, r2
 802576a:	bfa8      	it	ge
 802576c:	4613      	movge	r3, r2
 802576e:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94

      /* forward carries */
      COMBA_FORWARD;
 8025772:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8025776:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 802577a:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 802577e:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
 8025782:	2300      	movs	r3, #0
 8025784:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0

      /* execute loop */
      for (iz = 0; iz < iy; iz++) {
 8025788:	2300      	movs	r3, #0
 802578a:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
 802578e:	e0a9      	b.n	80258e4 <fp_sqr_comba+0x292>
          SQRADD2(*tmpx++, *tmpy--);
 8025790:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 8025794:	1d13      	adds	r3, r2, #4
 8025796:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
 802579a:	6813      	ldr	r3, [r2, #0]
 802579c:	2200      	movs	r2, #0
 802579e:	673b      	str	r3, [r7, #112]	@ 0x70
 80257a0:	677a      	str	r2, [r7, #116]	@ 0x74
 80257a2:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 80257a6:	1f13      	subs	r3, r2, #4
 80257a8:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
 80257ac:	6813      	ldr	r3, [r2, #0]
 80257ae:	2200      	movs	r2, #0
 80257b0:	66bb      	str	r3, [r7, #104]	@ 0x68
 80257b2:	66fa      	str	r2, [r7, #108]	@ 0x6c
 80257b4:	e9d7 011c 	ldrd	r0, r1, [r7, #112]	@ 0x70
 80257b8:	460b      	mov	r3, r1
 80257ba:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 80257bc:	fb02 f203 	mul.w	r2, r2, r3
 80257c0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80257c2:	e9c7 011c 	strd	r0, r1, [r7, #112]	@ 0x70
 80257c6:	4601      	mov	r1, r0
 80257c8:	fb01 f303 	mul.w	r3, r1, r3
 80257cc:	4413      	add	r3, r2
 80257ce:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 80257d0:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 80257d2:	fba2 8901 	umull	r8, r9, r2, r1
 80257d6:	444b      	add	r3, r9
 80257d8:	4699      	mov	r9, r3
 80257da:	e9c7 8920 	strd	r8, r9, [r7, #128]	@ 0x80
 80257de:	e9c7 8920 	strd	r8, r9, [r7, #128]	@ 0x80
 80257e2:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 80257e6:	2200      	movs	r2, #0
 80257e8:	663b      	str	r3, [r7, #96]	@ 0x60
 80257ea:	667a      	str	r2, [r7, #100]	@ 0x64
 80257ec:	e9d7 2320 	ldrd	r2, r3, [r7, #128]	@ 0x80
 80257f0:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 80257f2:	1851      	adds	r1, r2, r1
 80257f4:	62b9      	str	r1, [r7, #40]	@ 0x28
 80257f6:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 80257f8:	414b      	adcs	r3, r1
 80257fa:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80257fc:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	@ 0x28
 8025800:	e9c7 232a 	strd	r2, r3, [r7, #168]	@ 0xa8
 8025804:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8025808:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 802580c:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8025810:	2200      	movs	r2, #0
 8025812:	65bb      	str	r3, [r7, #88]	@ 0x58
 8025814:	65fa      	str	r2, [r7, #92]	@ 0x5c
 8025816:	e9d7 232a 	ldrd	r2, r3, [r7, #168]	@ 0xa8
 802581a:	f04f 0000 	mov.w	r0, #0
 802581e:	f04f 0100 	mov.w	r1, #0
 8025822:	0018      	movs	r0, r3
 8025824:	2100      	movs	r1, #0
 8025826:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8025828:	181b      	adds	r3, r3, r0
 802582a:	623b      	str	r3, [r7, #32]
 802582c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 802582e:	414b      	adcs	r3, r1
 8025830:	627b      	str	r3, [r7, #36]	@ 0x24
 8025832:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8025836:	e9c7 232a 	strd	r2, r3, [r7, #168]	@ 0xa8
 802583a:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 802583e:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
 8025842:	e9d7 232a 	ldrd	r2, r3, [r7, #168]	@ 0xa8
 8025846:	f04f 0000 	mov.w	r0, #0
 802584a:	f04f 0100 	mov.w	r1, #0
 802584e:	0018      	movs	r0, r3
 8025850:	2100      	movs	r1, #0
 8025852:	4602      	mov	r2, r0
 8025854:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8025858:	4413      	add	r3, r2
 802585a:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 802585e:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8025862:	2200      	movs	r2, #0
 8025864:	653b      	str	r3, [r7, #80]	@ 0x50
 8025866:	657a      	str	r2, [r7, #84]	@ 0x54
 8025868:	e9d7 2320 	ldrd	r2, r3, [r7, #128]	@ 0x80
 802586c:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 802586e:	1851      	adds	r1, r2, r1
 8025870:	61b9      	str	r1, [r7, #24]
 8025872:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 8025874:	414b      	adcs	r3, r1
 8025876:	61fb      	str	r3, [r7, #28]
 8025878:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 802587c:	e9c7 232a 	strd	r2, r3, [r7, #168]	@ 0xa8
 8025880:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8025884:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 8025888:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 802588c:	2200      	movs	r2, #0
 802588e:	64bb      	str	r3, [r7, #72]	@ 0x48
 8025890:	64fa      	str	r2, [r7, #76]	@ 0x4c
 8025892:	e9d7 232a 	ldrd	r2, r3, [r7, #168]	@ 0xa8
 8025896:	f04f 0000 	mov.w	r0, #0
 802589a:	f04f 0100 	mov.w	r1, #0
 802589e:	0018      	movs	r0, r3
 80258a0:	2100      	movs	r1, #0
 80258a2:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80258a4:	181b      	adds	r3, r3, r0
 80258a6:	613b      	str	r3, [r7, #16]
 80258a8:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80258aa:	414b      	adcs	r3, r1
 80258ac:	617b      	str	r3, [r7, #20]
 80258ae:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 80258b2:	e9c7 232a 	strd	r2, r3, [r7, #168]	@ 0xa8
 80258b6:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 80258ba:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
 80258be:	e9d7 232a 	ldrd	r2, r3, [r7, #168]	@ 0xa8
 80258c2:	f04f 0000 	mov.w	r0, #0
 80258c6:	f04f 0100 	mov.w	r1, #0
 80258ca:	0018      	movs	r0, r3
 80258cc:	2100      	movs	r1, #0
 80258ce:	4602      	mov	r2, r0
 80258d0:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 80258d4:	4413      	add	r3, r2
 80258d6:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
      for (iz = 0; iz < iy; iz++) {
 80258da:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 80258de:	3301      	adds	r3, #1
 80258e0:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
 80258e4:	f8d7 20cc 	ldr.w	r2, [r7, #204]	@ 0xcc
 80258e8:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 80258ec:	429a      	cmp	r2, r3
 80258ee:	f6ff af4f 	blt.w	8025790 <fp_sqr_comba+0x13e>
      }

      /* even columns have the square term in them */
      if ((ix&1) == 0) {
 80258f2:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 80258f6:	f003 0301 	and.w	r3, r3, #1
 80258fa:	2b00      	cmp	r3, #0
 80258fc:	d161      	bne.n	80259c2 <fp_sqr_comba+0x370>
          /* TAO change COMBA_ADD back to SQRADD */
          SQRADD(A->dp[ix>>1], A->dp[ix>>1]);
 80258fe:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8025902:	2200      	movs	r2, #0
 8025904:	63bb      	str	r3, [r7, #56]	@ 0x38
 8025906:	63fa      	str	r2, [r7, #60]	@ 0x3c
 8025908:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 802590c:	105b      	asrs	r3, r3, #1
 802590e:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 8025910:	3302      	adds	r3, #2
 8025912:	009b      	lsls	r3, r3, #2
 8025914:	4413      	add	r3, r2
 8025916:	685b      	ldr	r3, [r3, #4]
 8025918:	2200      	movs	r2, #0
 802591a:	633b      	str	r3, [r7, #48]	@ 0x30
 802591c:	637a      	str	r2, [r7, #52]	@ 0x34
 802591e:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8025922:	105b      	asrs	r3, r3, #1
 8025924:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 8025926:	3302      	adds	r3, #2
 8025928:	009b      	lsls	r3, r3, #2
 802592a:	4413      	add	r3, r2
 802592c:	685b      	ldr	r3, [r3, #4]
 802592e:	2200      	movs	r2, #0
 8025930:	469a      	mov	sl, r3
 8025932:	4693      	mov	fp, r2
 8025934:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	@ 0x30
 8025938:	460b      	mov	r3, r1
 802593a:	fb0a f203 	mul.w	r2, sl, r3
 802593e:	4603      	mov	r3, r0
 8025940:	fb03 f30b 	mul.w	r3, r3, fp
 8025944:	4413      	add	r3, r2
 8025946:	4602      	mov	r2, r0
 8025948:	fba2 450a 	umull	r4, r5, r2, sl
 802594c:	442b      	add	r3, r5
 802594e:	461d      	mov	r5, r3
 8025950:	e9d7 120e 	ldrd	r1, r2, [r7, #56]	@ 0x38
 8025954:	460b      	mov	r3, r1
 8025956:	191b      	adds	r3, r3, r4
 8025958:	60bb      	str	r3, [r7, #8]
 802595a:	4613      	mov	r3, r2
 802595c:	416b      	adcs	r3, r5
 802595e:	60fb      	str	r3, [r7, #12]
 8025960:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 8025964:	e9c7 2322 	strd	r2, r3, [r7, #136]	@ 0x88
 8025968:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 802596c:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 8025970:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8025974:	2200      	movs	r2, #0
 8025976:	643b      	str	r3, [r7, #64]	@ 0x40
 8025978:	647a      	str	r2, [r7, #68]	@ 0x44
 802597a:	e9d7 2322 	ldrd	r2, r3, [r7, #136]	@ 0x88
 802597e:	f04f 0000 	mov.w	r0, #0
 8025982:	f04f 0100 	mov.w	r1, #0
 8025986:	0018      	movs	r0, r3
 8025988:	2100      	movs	r1, #0
 802598a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802598c:	181b      	adds	r3, r3, r0
 802598e:	603b      	str	r3, [r7, #0]
 8025990:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8025992:	414b      	adcs	r3, r1
 8025994:	607b      	str	r3, [r7, #4]
 8025996:	e9d7 2300 	ldrd	r2, r3, [r7]
 802599a:	e9c7 2322 	strd	r2, r3, [r7, #136]	@ 0x88
 802599e:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 80259a2:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
 80259a6:	e9d7 2322 	ldrd	r2, r3, [r7, #136]	@ 0x88
 80259aa:	f04f 0000 	mov.w	r0, #0
 80259ae:	f04f 0100 	mov.w	r1, #0
 80259b2:	0018      	movs	r0, r3
 80259b4:	2100      	movs	r1, #0
 80259b6:	4602      	mov	r2, r0
 80259b8:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 80259bc:	4413      	add	r3, r2
 80259be:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
      }

      /* store it */
      COMBA_STORE(dst->dp[ix]);
 80259c2:	f8d7 10bc 	ldr.w	r1, [r7, #188]	@ 0xbc
 80259c6:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 80259ca:	3302      	adds	r3, #2
 80259cc:	009a      	lsls	r2, r3, #2
 80259ce:	440a      	add	r2, r1
 80259d0:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 80259d4:	6053      	str	r3, [r2, #4]
  for (ix = 0; ix < pa; ix++) {
 80259d6:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 80259da:	3301      	adds	r3, #1
 80259dc:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
 80259e0:	f8d7 20d0 	ldr.w	r2, [r7, #208]	@ 0xd0
 80259e4:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80259e8:	429a      	cmp	r2, r3
 80259ea:	f6ff ae79 	blt.w	80256e0 <fp_sqr_comba+0x8e>
  }

  COMBA_FINI;

  /* setup dest */
  dst->used = pa;
 80259ee:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 80259f2:	f8d7 20d4 	ldr.w	r2, [r7, #212]	@ 0xd4
 80259f6:	601a      	str	r2, [r3, #0]
  fp_clamp (dst);
 80259f8:	e006      	b.n	8025a08 <fp_sqr_comba+0x3b6>
 80259fa:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 80259fe:	681b      	ldr	r3, [r3, #0]
 8025a00:	1e5a      	subs	r2, r3, #1
 8025a02:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8025a06:	601a      	str	r2, [r3, #0]
 8025a08:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8025a0c:	681b      	ldr	r3, [r3, #0]
 8025a0e:	2b00      	cmp	r3, #0
 8025a10:	d00b      	beq.n	8025a2a <fp_sqr_comba+0x3d8>
 8025a12:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8025a16:	681b      	ldr	r3, [r3, #0]
 8025a18:	3b01      	subs	r3, #1
 8025a1a:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 8025a1e:	3302      	adds	r3, #2
 8025a20:	009b      	lsls	r3, r3, #2
 8025a22:	4413      	add	r3, r2
 8025a24:	685b      	ldr	r3, [r3, #4]
 8025a26:	2b00      	cmp	r3, #0
 8025a28:	d0e7      	beq.n	80259fa <fp_sqr_comba+0x3a8>
 8025a2a:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8025a2e:	681b      	ldr	r3, [r3, #0]
 8025a30:	2b00      	cmp	r3, #0
 8025a32:	d003      	beq.n	8025a3c <fp_sqr_comba+0x3ea>
 8025a34:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8025a38:	685b      	ldr	r3, [r3, #4]
 8025a3a:	e000      	b.n	8025a3e <fp_sqr_comba+0x3ec>
 8025a3c:	2300      	movs	r3, #0
 8025a3e:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 8025a42:	6053      	str	r3, [r2, #4]
  if (dst != B) {
 8025a44:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 8025a48:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8025a4a:	429a      	cmp	r2, r3
 8025a4c:	d004      	beq.n	8025a58 <fp_sqr_comba+0x406>
     fp_copy(dst, B);
 8025a4e:	6fb9      	ldr	r1, [r7, #120]	@ 0x78
 8025a50:	f8d7 00bc 	ldr.w	r0, [r7, #188]	@ 0xbc
 8025a54:	f001 f816 	bl	8026a84 <fp_copy>
#ifdef TFM_ISO
  (void)tt;
#endif

#ifdef WOLFSSL_SMALL_STACK
  XFREE(tmp, NULL, DYNAMIC_TYPE_BIGINT);
 8025a58:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8025a5c:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
 8025a60:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 8025a64:	2b00      	cmp	r3, #0
 8025a66:	d003      	beq.n	8025a70 <fp_sqr_comba+0x41e>
 8025a68:	f8d7 00a0 	ldr.w	r0, [r7, #160]	@ 0xa0
 8025a6c:	f7f9 f828 	bl	801eac0 <wolfSSL_Free>
#endif
  return FP_OKAY;
 8025a70:	2300      	movs	r3, #0
}
 8025a72:	4618      	mov	r0, r3
 8025a74:	37d8      	adds	r7, #216	@ 0xd8
 8025a76:	46bd      	mov	sp, r7
 8025a78:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

08025a7c <fp_cmp>:

int fp_cmp(fp_int *a, fp_int *b)
{
 8025a7c:	b580      	push	{r7, lr}
 8025a7e:	b082      	sub	sp, #8
 8025a80:	af00      	add	r7, sp, #0
 8025a82:	6078      	str	r0, [r7, #4]
 8025a84:	6039      	str	r1, [r7, #0]
   if (a->sign == FP_NEG && b->sign == FP_ZPOS) {
 8025a86:	687b      	ldr	r3, [r7, #4]
 8025a88:	685b      	ldr	r3, [r3, #4]
 8025a8a:	2b01      	cmp	r3, #1
 8025a8c:	d106      	bne.n	8025a9c <fp_cmp+0x20>
 8025a8e:	683b      	ldr	r3, [r7, #0]
 8025a90:	685b      	ldr	r3, [r3, #4]
 8025a92:	2b00      	cmp	r3, #0
 8025a94:	d102      	bne.n	8025a9c <fp_cmp+0x20>
      return FP_LT;
 8025a96:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8025a9a:	e018      	b.n	8025ace <fp_cmp+0x52>
   } else if (a->sign == FP_ZPOS && b->sign == FP_NEG) {
 8025a9c:	687b      	ldr	r3, [r7, #4]
 8025a9e:	685b      	ldr	r3, [r3, #4]
 8025aa0:	2b00      	cmp	r3, #0
 8025aa2:	d105      	bne.n	8025ab0 <fp_cmp+0x34>
 8025aa4:	683b      	ldr	r3, [r7, #0]
 8025aa6:	685b      	ldr	r3, [r3, #4]
 8025aa8:	2b01      	cmp	r3, #1
 8025aaa:	d101      	bne.n	8025ab0 <fp_cmp+0x34>
      return FP_GT;
 8025aac:	2301      	movs	r3, #1
 8025aae:	e00e      	b.n	8025ace <fp_cmp+0x52>
   } else {
      /* compare digits */
      if (a->sign == FP_NEG) {
 8025ab0:	687b      	ldr	r3, [r7, #4]
 8025ab2:	685b      	ldr	r3, [r3, #4]
 8025ab4:	2b01      	cmp	r3, #1
 8025ab6:	d105      	bne.n	8025ac4 <fp_cmp+0x48>
         /* if negative compare opposite direction */
         return fp_cmp_mag(b, a);
 8025ab8:	6879      	ldr	r1, [r7, #4]
 8025aba:	6838      	ldr	r0, [r7, #0]
 8025abc:	f000 f843 	bl	8025b46 <fp_cmp_mag>
 8025ac0:	4603      	mov	r3, r0
 8025ac2:	e004      	b.n	8025ace <fp_cmp+0x52>
      } else {
         return fp_cmp_mag(a, b);
 8025ac4:	6839      	ldr	r1, [r7, #0]
 8025ac6:	6878      	ldr	r0, [r7, #4]
 8025ac8:	f000 f83d 	bl	8025b46 <fp_cmp_mag>
 8025acc:	4603      	mov	r3, r0
      }
   }
}
 8025ace:	4618      	mov	r0, r3
 8025ad0:	3708      	adds	r7, #8
 8025ad2:	46bd      	mov	sp, r7
 8025ad4:	bd80      	pop	{r7, pc}

08025ad6 <fp_cmp_d>:

/* compare against a single digit */
int fp_cmp_d(fp_int *a, fp_digit b)
{
 8025ad6:	b480      	push	{r7}
 8025ad8:	b083      	sub	sp, #12
 8025ada:	af00      	add	r7, sp, #0
 8025adc:	6078      	str	r0, [r7, #4]
 8025ade:	6039      	str	r1, [r7, #0]
  /* special case for zero*/
  if (a->used == 0 && b == 0)
 8025ae0:	687b      	ldr	r3, [r7, #4]
 8025ae2:	681b      	ldr	r3, [r3, #0]
 8025ae4:	2b00      	cmp	r3, #0
 8025ae6:	d104      	bne.n	8025af2 <fp_cmp_d+0x1c>
 8025ae8:	683b      	ldr	r3, [r7, #0]
 8025aea:	2b00      	cmp	r3, #0
 8025aec:	d101      	bne.n	8025af2 <fp_cmp_d+0x1c>
    return FP_EQ;
 8025aee:	2300      	movs	r3, #0
 8025af0:	e023      	b.n	8025b3a <fp_cmp_d+0x64>

  /* compare based on sign */
  if ((b && a->used == 0) || a->sign == FP_NEG) {
 8025af2:	683b      	ldr	r3, [r7, #0]
 8025af4:	2b00      	cmp	r3, #0
 8025af6:	d003      	beq.n	8025b00 <fp_cmp_d+0x2a>
 8025af8:	687b      	ldr	r3, [r7, #4]
 8025afa:	681b      	ldr	r3, [r3, #0]
 8025afc:	2b00      	cmp	r3, #0
 8025afe:	d003      	beq.n	8025b08 <fp_cmp_d+0x32>
 8025b00:	687b      	ldr	r3, [r7, #4]
 8025b02:	685b      	ldr	r3, [r3, #4]
 8025b04:	2b01      	cmp	r3, #1
 8025b06:	d102      	bne.n	8025b0e <fp_cmp_d+0x38>
    return FP_LT;
 8025b08:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8025b0c:	e015      	b.n	8025b3a <fp_cmp_d+0x64>
  }

  /* compare based on magnitude */
  if (a->used > 1) {
 8025b0e:	687b      	ldr	r3, [r7, #4]
 8025b10:	681b      	ldr	r3, [r3, #0]
 8025b12:	2b01      	cmp	r3, #1
 8025b14:	dd01      	ble.n	8025b1a <fp_cmp_d+0x44>
    return FP_GT;
 8025b16:	2301      	movs	r3, #1
 8025b18:	e00f      	b.n	8025b3a <fp_cmp_d+0x64>
  }

  /* compare the only digit of a to b */
  if (a->dp[0] > b) {
 8025b1a:	687b      	ldr	r3, [r7, #4]
 8025b1c:	68db      	ldr	r3, [r3, #12]
 8025b1e:	683a      	ldr	r2, [r7, #0]
 8025b20:	429a      	cmp	r2, r3
 8025b22:	d201      	bcs.n	8025b28 <fp_cmp_d+0x52>
    return FP_GT;
 8025b24:	2301      	movs	r3, #1
 8025b26:	e008      	b.n	8025b3a <fp_cmp_d+0x64>
  } else if (a->dp[0] < b) {
 8025b28:	687b      	ldr	r3, [r7, #4]
 8025b2a:	68db      	ldr	r3, [r3, #12]
 8025b2c:	683a      	ldr	r2, [r7, #0]
 8025b2e:	429a      	cmp	r2, r3
 8025b30:	d902      	bls.n	8025b38 <fp_cmp_d+0x62>
    return FP_LT;
 8025b32:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8025b36:	e000      	b.n	8025b3a <fp_cmp_d+0x64>
  } else {
    return FP_EQ;
 8025b38:	2300      	movs	r3, #0
  }

}
 8025b3a:	4618      	mov	r0, r3
 8025b3c:	370c      	adds	r7, #12
 8025b3e:	46bd      	mov	sp, r7
 8025b40:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025b44:	4770      	bx	lr

08025b46 <fp_cmp_mag>:

int fp_cmp_mag(fp_int *a, fp_int *b)
{
 8025b46:	b480      	push	{r7}
 8025b48:	b085      	sub	sp, #20
 8025b4a:	af00      	add	r7, sp, #0
 8025b4c:	6078      	str	r0, [r7, #4]
 8025b4e:	6039      	str	r1, [r7, #0]
   int x;

   if (a->used > b->used) {
 8025b50:	687b      	ldr	r3, [r7, #4]
 8025b52:	681a      	ldr	r2, [r3, #0]
 8025b54:	683b      	ldr	r3, [r7, #0]
 8025b56:	681b      	ldr	r3, [r3, #0]
 8025b58:	429a      	cmp	r2, r3
 8025b5a:	dd01      	ble.n	8025b60 <fp_cmp_mag+0x1a>
      return FP_GT;
 8025b5c:	2301      	movs	r3, #1
 8025b5e:	e035      	b.n	8025bcc <fp_cmp_mag+0x86>
   } else if (a->used < b->used) {
 8025b60:	687b      	ldr	r3, [r7, #4]
 8025b62:	681a      	ldr	r2, [r3, #0]
 8025b64:	683b      	ldr	r3, [r7, #0]
 8025b66:	681b      	ldr	r3, [r3, #0]
 8025b68:	429a      	cmp	r2, r3
 8025b6a:	da02      	bge.n	8025b72 <fp_cmp_mag+0x2c>
      return FP_LT;
 8025b6c:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8025b70:	e02c      	b.n	8025bcc <fp_cmp_mag+0x86>
   } else {
      for (x = a->used - 1; x >= 0; x--) {
 8025b72:	687b      	ldr	r3, [r7, #4]
 8025b74:	681b      	ldr	r3, [r3, #0]
 8025b76:	3b01      	subs	r3, #1
 8025b78:	60fb      	str	r3, [r7, #12]
 8025b7a:	e023      	b.n	8025bc4 <fp_cmp_mag+0x7e>
          if (a->dp[x] > b->dp[x]) {
 8025b7c:	687a      	ldr	r2, [r7, #4]
 8025b7e:	68fb      	ldr	r3, [r7, #12]
 8025b80:	3302      	adds	r3, #2
 8025b82:	009b      	lsls	r3, r3, #2
 8025b84:	4413      	add	r3, r2
 8025b86:	685a      	ldr	r2, [r3, #4]
 8025b88:	6839      	ldr	r1, [r7, #0]
 8025b8a:	68fb      	ldr	r3, [r7, #12]
 8025b8c:	3302      	adds	r3, #2
 8025b8e:	009b      	lsls	r3, r3, #2
 8025b90:	440b      	add	r3, r1
 8025b92:	685b      	ldr	r3, [r3, #4]
 8025b94:	429a      	cmp	r2, r3
 8025b96:	d901      	bls.n	8025b9c <fp_cmp_mag+0x56>
             return FP_GT;
 8025b98:	2301      	movs	r3, #1
 8025b9a:	e017      	b.n	8025bcc <fp_cmp_mag+0x86>
          } else if (a->dp[x] < b->dp[x]) {
 8025b9c:	687a      	ldr	r2, [r7, #4]
 8025b9e:	68fb      	ldr	r3, [r7, #12]
 8025ba0:	3302      	adds	r3, #2
 8025ba2:	009b      	lsls	r3, r3, #2
 8025ba4:	4413      	add	r3, r2
 8025ba6:	685a      	ldr	r2, [r3, #4]
 8025ba8:	6839      	ldr	r1, [r7, #0]
 8025baa:	68fb      	ldr	r3, [r7, #12]
 8025bac:	3302      	adds	r3, #2
 8025bae:	009b      	lsls	r3, r3, #2
 8025bb0:	440b      	add	r3, r1
 8025bb2:	685b      	ldr	r3, [r3, #4]
 8025bb4:	429a      	cmp	r2, r3
 8025bb6:	d202      	bcs.n	8025bbe <fp_cmp_mag+0x78>
             return FP_LT;
 8025bb8:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8025bbc:	e006      	b.n	8025bcc <fp_cmp_mag+0x86>
      for (x = a->used - 1; x >= 0; x--) {
 8025bbe:	68fb      	ldr	r3, [r7, #12]
 8025bc0:	3b01      	subs	r3, #1
 8025bc2:	60fb      	str	r3, [r7, #12]
 8025bc4:	68fb      	ldr	r3, [r7, #12]
 8025bc6:	2b00      	cmp	r3, #0
 8025bc8:	dad8      	bge.n	8025b7c <fp_cmp_mag+0x36>
          }
      }
   }
   return FP_EQ;
 8025bca:	2300      	movs	r3, #0
}
 8025bcc:	4618      	mov	r0, r3
 8025bce:	3714      	adds	r7, #20
 8025bd0:	46bd      	mov	sp, r7
 8025bd2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025bd6:	4770      	bx	lr

08025bd8 <fp_montgomery_setup>:


/* sets up the montgomery reduction */
int fp_montgomery_setup(fp_int *a, fp_digit *rho)
{
 8025bd8:	b480      	push	{r7}
 8025bda:	b085      	sub	sp, #20
 8025bdc:	af00      	add	r7, sp, #0
 8025bde:	6078      	str	r0, [r7, #4]
 8025be0:	6039      	str	r1, [r7, #0]
 *
 * XA = 1 (mod 2**n)  =>  (X(2-XA)) A = 1 (mod 2**2n)
 *                    =>  2*X*A - X*X*A*A = 1
 *                    =>  2*(1) - (1)     = 1
 */
  b = a->dp[0];
 8025be2:	687b      	ldr	r3, [r7, #4]
 8025be4:	68db      	ldr	r3, [r3, #12]
 8025be6:	60fb      	str	r3, [r7, #12]

  if ((b & 1) == 0) {
 8025be8:	68fb      	ldr	r3, [r7, #12]
 8025bea:	f003 0301 	and.w	r3, r3, #1
 8025bee:	2b00      	cmp	r3, #0
 8025bf0:	d102      	bne.n	8025bf8 <fp_montgomery_setup+0x20>
    return FP_VAL;
 8025bf2:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8025bf6:	e02a      	b.n	8025c4e <fp_montgomery_setup+0x76>
  }

  x = (((b + 2) & 4) << 1) + b; /* here x*a==1 mod 2**4 */
 8025bf8:	68fb      	ldr	r3, [r7, #12]
 8025bfa:	3302      	adds	r3, #2
 8025bfc:	005b      	lsls	r3, r3, #1
 8025bfe:	f003 0308 	and.w	r3, r3, #8
 8025c02:	68fa      	ldr	r2, [r7, #12]
 8025c04:	4413      	add	r3, r2
 8025c06:	60bb      	str	r3, [r7, #8]
  x *= 2 - b * x;               /* here x*a==1 mod 2**8 */
 8025c08:	68fb      	ldr	r3, [r7, #12]
 8025c0a:	68ba      	ldr	r2, [r7, #8]
 8025c0c:	fb02 f303 	mul.w	r3, r2, r3
 8025c10:	f1c3 0202 	rsb	r2, r3, #2
 8025c14:	68bb      	ldr	r3, [r7, #8]
 8025c16:	fb02 f303 	mul.w	r3, r2, r3
 8025c1a:	60bb      	str	r3, [r7, #8]
  x *= 2 - b * x;               /* here x*a==1 mod 2**16 */
 8025c1c:	68fb      	ldr	r3, [r7, #12]
 8025c1e:	68ba      	ldr	r2, [r7, #8]
 8025c20:	fb02 f303 	mul.w	r3, r2, r3
 8025c24:	f1c3 0202 	rsb	r2, r3, #2
 8025c28:	68bb      	ldr	r3, [r7, #8]
 8025c2a:	fb02 f303 	mul.w	r3, r2, r3
 8025c2e:	60bb      	str	r3, [r7, #8]
  x *= 2 - b * x;               /* here x*a==1 mod 2**32 */
 8025c30:	68fb      	ldr	r3, [r7, #12]
 8025c32:	68ba      	ldr	r2, [r7, #8]
 8025c34:	fb02 f303 	mul.w	r3, r2, r3
 8025c38:	f1c3 0202 	rsb	r2, r3, #2
 8025c3c:	68bb      	ldr	r3, [r7, #8]
 8025c3e:	fb02 f303 	mul.w	r3, r2, r3
 8025c42:	60bb      	str	r3, [r7, #8]
#ifdef FP_64BIT
  x *= 2 - b * x;               /* here x*a==1 mod 2**64 */
#endif

  /* rho = -1/m mod b */
  *rho = (fp_digit) (((fp_word) 1 << ((fp_word) DIGIT_BIT)) - ((fp_word)x));
 8025c44:	68bb      	ldr	r3, [r7, #8]
 8025c46:	425a      	negs	r2, r3
 8025c48:	683b      	ldr	r3, [r7, #0]
 8025c4a:	601a      	str	r2, [r3, #0]

  return FP_OKAY;
 8025c4c:	2300      	movs	r3, #0
}
 8025c4e:	4618      	mov	r0, r3
 8025c50:	3714      	adds	r7, #20
 8025c52:	46bd      	mov	sp, r7
 8025c54:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025c58:	4770      	bx	lr

08025c5a <fp_montgomery_calc_normalization>:

/* computes a = B**n mod b without division or multiplication useful for
 * normalizing numbers in a Montgomery system.
 */
int fp_montgomery_calc_normalization(fp_int *a, fp_int *b)
{
 8025c5a:	b580      	push	{r7, lr}
 8025c5c:	b086      	sub	sp, #24
 8025c5e:	af00      	add	r7, sp, #0
 8025c60:	6078      	str	r0, [r7, #4]
 8025c62:	6039      	str	r1, [r7, #0]
  int     x, bits;

  /* how many bits of last digit does b use */
  bits = fp_count_bits (b) % DIGIT_BIT;
 8025c64:	6838      	ldr	r0, [r7, #0]
 8025c66:	f000 fb37 	bl	80262d8 <fp_count_bits>
 8025c6a:	4603      	mov	r3, r0
 8025c6c:	425a      	negs	r2, r3
 8025c6e:	f003 031f 	and.w	r3, r3, #31
 8025c72:	f002 021f 	and.w	r2, r2, #31
 8025c76:	bf58      	it	pl
 8025c78:	4253      	negpl	r3, r2
 8025c7a:	613b      	str	r3, [r7, #16]
  if (!bits) bits = DIGIT_BIT;
 8025c7c:	693b      	ldr	r3, [r7, #16]
 8025c7e:	2b00      	cmp	r3, #0
 8025c80:	d101      	bne.n	8025c86 <fp_montgomery_calc_normalization+0x2c>
 8025c82:	2320      	movs	r3, #32
 8025c84:	613b      	str	r3, [r7, #16]

  /* compute A = B^(n-1) * 2^(bits-1) */
  if (b->used > 1) {
 8025c86:	683b      	ldr	r3, [r7, #0]
 8025c88:	681b      	ldr	r3, [r3, #0]
 8025c8a:	2b01      	cmp	r3, #1
 8025c8c:	dd0b      	ble.n	8025ca6 <fp_montgomery_calc_normalization+0x4c>
     fp_2expt (a, (b->used - 1) * DIGIT_BIT + bits - 1);
 8025c8e:	683b      	ldr	r3, [r7, #0]
 8025c90:	681b      	ldr	r3, [r3, #0]
 8025c92:	3b01      	subs	r3, #1
 8025c94:	015a      	lsls	r2, r3, #5
 8025c96:	693b      	ldr	r3, [r7, #16]
 8025c98:	4413      	add	r3, r2
 8025c9a:	3b01      	subs	r3, #1
 8025c9c:	4619      	mov	r1, r3
 8025c9e:	6878      	ldr	r0, [r7, #4]
 8025ca0:	f7ff fc7b 	bl	802559a <fp_2expt>
 8025ca4:	e005      	b.n	8025cb2 <fp_montgomery_calc_normalization+0x58>
  } else {
     fp_set(a, 1);
 8025ca6:	2101      	movs	r1, #1
 8025ca8:	6878      	ldr	r0, [r7, #4]
 8025caa:	f000 fad2 	bl	8026252 <fp_set>
     bits = 1;
 8025cae:	2301      	movs	r3, #1
 8025cb0:	613b      	str	r3, [r7, #16]
  }

  /* now compute C = A * B mod b */
  for (x = bits - 1; x < (int)DIGIT_BIT; x++) {
 8025cb2:	693b      	ldr	r3, [r7, #16]
 8025cb4:	3b01      	subs	r3, #1
 8025cb6:	617b      	str	r3, [r7, #20]
 8025cb8:	e019      	b.n	8025cee <fp_montgomery_calc_normalization+0x94>
    int err = fp_mul_2 (a, a);
 8025cba:	6879      	ldr	r1, [r7, #4]
 8025cbc:	6878      	ldr	r0, [r7, #4]
 8025cbe:	f7fc fd32 	bl	8022726 <fp_mul_2>
 8025cc2:	60f8      	str	r0, [r7, #12]
    if (err != FP_OKAY) {
 8025cc4:	68fb      	ldr	r3, [r7, #12]
 8025cc6:	2b00      	cmp	r3, #0
 8025cc8:	d001      	beq.n	8025cce <fp_montgomery_calc_normalization+0x74>
      return err;
 8025cca:	68fb      	ldr	r3, [r7, #12]
 8025ccc:	e013      	b.n	8025cf6 <fp_montgomery_calc_normalization+0x9c>
    }
    if (fp_cmp_mag (a, b) != FP_LT) {
 8025cce:	6839      	ldr	r1, [r7, #0]
 8025cd0:	6878      	ldr	r0, [r7, #4]
 8025cd2:	f7ff ff38 	bl	8025b46 <fp_cmp_mag>
 8025cd6:	4603      	mov	r3, r0
 8025cd8:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8025cdc:	d004      	beq.n	8025ce8 <fp_montgomery_calc_normalization+0x8e>
      s_fp_sub (a, b, a);
 8025cde:	687a      	ldr	r2, [r7, #4]
 8025ce0:	6839      	ldr	r1, [r7, #0]
 8025ce2:	6878      	ldr	r0, [r7, #4]
 8025ce4:	f7fc fc17 	bl	8022516 <s_fp_sub>
  for (x = bits - 1; x < (int)DIGIT_BIT; x++) {
 8025ce8:	697b      	ldr	r3, [r7, #20]
 8025cea:	3301      	adds	r3, #1
 8025cec:	617b      	str	r3, [r7, #20]
 8025cee:	697b      	ldr	r3, [r7, #20]
 8025cf0:	2b1f      	cmp	r3, #31
 8025cf2:	dde2      	ble.n	8025cba <fp_montgomery_calc_normalization+0x60>
    }
  }
  return FP_OKAY;
 8025cf4:	2300      	movs	r3, #0
}
 8025cf6:	4618      	mov	r0, r3
 8025cf8:	3718      	adds	r7, #24
 8025cfa:	46bd      	mov	sp, r7
 8025cfc:	bd80      	pop	{r7, pc}

08025cfe <fp_montgomery_reduce_ex>:
}
#endif

/* computes x/R == x (mod N) via Montgomery Reduction */
int fp_montgomery_reduce_ex(fp_int *a, fp_int *m, fp_digit mp, int ct)
{
 8025cfe:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8025d02:	b09a      	sub	sp, #104	@ 0x68
 8025d04:	af00      	add	r7, sp, #0
 8025d06:	62f8      	str	r0, [r7, #44]	@ 0x2c
 8025d08:	62b9      	str	r1, [r7, #40]	@ 0x28
 8025d0a:	627a      	str	r2, [r7, #36]	@ 0x24
 8025d0c:	623b      	str	r3, [r7, #32]
#ifndef WOLFSSL_SMALL_STACK
   fp_digit c[FP_SIZE+1];
#else
   fp_digit *c;
#endif
   fp_digit *_c, *tmpm, mu = 0;
 8025d0e:	2300      	movs	r3, #0
 8025d10:	64fb      	str	r3, [r7, #76]	@ 0x4c
   int      oldused, x, y, pa, err = 0;
 8025d12:	2300      	movs	r3, #0
 8025d14:	64bb      	str	r3, [r7, #72]	@ 0x48

   IF_HAVE_INTEL_MULX(err=fp_montgomery_reduce_mulx(a, m, mp, ct), return err) ;
   (void)err;

   /* bail if too large */
   if (m->used > (FP_SIZE/2)) {
 8025d16:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8025d18:	681b      	ldr	r3, [r3, #0]
 8025d1a:	2b44      	cmp	r3, #68	@ 0x44
 8025d1c:	dd02      	ble.n	8025d24 <fp_montgomery_reduce_ex+0x26>
      (void)mu;                     /* shut up compiler */
      return FP_VAL;
 8025d1e:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8025d22:	e11b      	b.n	8025f5c <fp_montgomery_reduce_ex+0x25e>
   }
#endif

#ifdef WOLFSSL_SMALL_STACK
   /* only allocate space for what's needed for window plus res */
   c = (fp_digit*)XMALLOC(sizeof(fp_digit)*(FP_SIZE + 1), NULL, DYNAMIC_TYPE_BIGINT);
 8025d24:	f44f 7009 	mov.w	r0, #548	@ 0x224
 8025d28:	f7f8 feae 	bl	801ea88 <wolfSSL_Malloc>
 8025d2c:	6478      	str	r0, [r7, #68]	@ 0x44
   if (c == NULL) {
 8025d2e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8025d30:	2b00      	cmp	r3, #0
 8025d32:	d102      	bne.n	8025d3a <fp_montgomery_reduce_ex+0x3c>
      return FP_MEM;
 8025d34:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 8025d38:	e110      	b.n	8025f5c <fp_montgomery_reduce_ex+0x25e>
   }
#endif

   /* now zero the buff */
   XMEMSET(c, 0, sizeof(fp_digit)*(FP_SIZE + 1));
 8025d3a:	f44f 7209 	mov.w	r2, #548	@ 0x224
 8025d3e:	2100      	movs	r1, #0
 8025d40:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 8025d42:	f002 fbc1 	bl	80284c8 <memset>
   pa = m->used;
 8025d46:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8025d48:	681b      	ldr	r3, [r3, #0]
 8025d4a:	643b      	str	r3, [r7, #64]	@ 0x40

   /* copy the input */
#ifdef TFM_TIMING_RESISTANT
   if (a->used <= m->used) {
 8025d4c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8025d4e:	681a      	ldr	r2, [r3, #0]
 8025d50:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8025d52:	681b      	ldr	r3, [r3, #0]
 8025d54:	429a      	cmp	r2, r3
 8025d56:	dc03      	bgt.n	8025d60 <fp_montgomery_reduce_ex+0x62>
      oldused = m->used;
 8025d58:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8025d5a:	681b      	ldr	r3, [r3, #0]
 8025d5c:	65fb      	str	r3, [r7, #92]	@ 0x5c
 8025d5e:	e003      	b.n	8025d68 <fp_montgomery_reduce_ex+0x6a>
   }
   else {
      oldused = m->used * 2;
 8025d60:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8025d62:	681b      	ldr	r3, [r3, #0]
 8025d64:	005b      	lsls	r3, r3, #1
 8025d66:	65fb      	str	r3, [r7, #92]	@ 0x5c
   }
#else
   oldused = a->used;
#endif
   for (x = 0; x < oldused; x++) {
 8025d68:	2300      	movs	r3, #0
 8025d6a:	65bb      	str	r3, [r7, #88]	@ 0x58
 8025d6c:	e00d      	b.n	8025d8a <fp_montgomery_reduce_ex+0x8c>
       c[x] = a->dp[x];
 8025d6e:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8025d70:	009a      	lsls	r2, r3, #2
 8025d72:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8025d74:	1899      	adds	r1, r3, r2
 8025d76:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8025d78:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8025d7a:	3302      	adds	r3, #2
 8025d7c:	009b      	lsls	r3, r3, #2
 8025d7e:	4413      	add	r3, r2
 8025d80:	685b      	ldr	r3, [r3, #4]
 8025d82:	600b      	str	r3, [r1, #0]
   for (x = 0; x < oldused; x++) {
 8025d84:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8025d86:	3301      	adds	r3, #1
 8025d88:	65bb      	str	r3, [r7, #88]	@ 0x58
 8025d8a:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8025d8c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8025d8e:	429a      	cmp	r2, r3
 8025d90:	dbed      	blt.n	8025d6e <fp_montgomery_reduce_ex+0x70>
   }
   MONT_START;

   for (x = 0; x < pa; x++) {
 8025d92:	2300      	movs	r3, #0
 8025d94:	65bb      	str	r3, [r7, #88]	@ 0x58
 8025d96:	e07d      	b.n	8025e94 <fp_montgomery_reduce_ex+0x196>
       fp_digit cy = 0;
 8025d98:	2300      	movs	r3, #0
 8025d9a:	653b      	str	r3, [r7, #80]	@ 0x50
       /* get Mu for this round */
       LOOP_START;
 8025d9c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8025d9e:	009a      	lsls	r2, r3, #2
 8025da0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8025da2:	4413      	add	r3, r2
 8025da4:	681a      	ldr	r2, [r3, #0]
 8025da6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8025da8:	fb02 f303 	mul.w	r3, r2, r3
 8025dac:	64fb      	str	r3, [r7, #76]	@ 0x4c
       _c   = c + x;
 8025dae:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8025db0:	009a      	lsls	r2, r3, #2
 8025db2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8025db4:	4413      	add	r3, r2
 8025db6:	667b      	str	r3, [r7, #100]	@ 0x64
       tmpm = m->dp;
 8025db8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8025dba:	330c      	adds	r3, #12
 8025dbc:	663b      	str	r3, [r7, #96]	@ 0x60
       y = 0;
 8025dbe:	2300      	movs	r3, #0
 8025dc0:	657b      	str	r3, [r7, #84]	@ 0x54
              INNERMUL8 ;
              _c   += 8;
              tmpm += 8;
           }
#endif
       for (; y < pa; y++) {
 8025dc2:	e048      	b.n	8025e56 <fp_montgomery_reduce_ex+0x158>
          INNERMUL;
 8025dc4:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8025dc6:	681b      	ldr	r3, [r3, #0]
 8025dc8:	2200      	movs	r2, #0
 8025dca:	61bb      	str	r3, [r7, #24]
 8025dcc:	61fa      	str	r2, [r7, #28]
 8025dce:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8025dd0:	2200      	movs	r2, #0
 8025dd2:	613b      	str	r3, [r7, #16]
 8025dd4:	617a      	str	r2, [r7, #20]
 8025dd6:	69bb      	ldr	r3, [r7, #24]
 8025dd8:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8025ddc:	4602      	mov	r2, r0
 8025dde:	eb13 0802 	adds.w	r8, r3, r2
 8025de2:	69fb      	ldr	r3, [r7, #28]
 8025de4:	460a      	mov	r2, r1
 8025de6:	eb43 0902 	adc.w	r9, r3, r2
 8025dea:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8025dec:	2200      	movs	r2, #0
 8025dee:	469a      	mov	sl, r3
 8025df0:	4693      	mov	fp, r2
 8025df2:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8025df4:	1d13      	adds	r3, r2, #4
 8025df6:	663b      	str	r3, [r7, #96]	@ 0x60
 8025df8:	6813      	ldr	r3, [r2, #0]
 8025dfa:	2200      	movs	r2, #0
 8025dfc:	60bb      	str	r3, [r7, #8]
 8025dfe:	60fa      	str	r2, [r7, #12]
 8025e00:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 8025e04:	4603      	mov	r3, r0
 8025e06:	fb03 f20b 	mul.w	r2, r3, fp
 8025e0a:	460b      	mov	r3, r1
 8025e0c:	fb0a f303 	mul.w	r3, sl, r3
 8025e10:	4413      	add	r3, r2
 8025e12:	4602      	mov	r2, r0
 8025e14:	fbaa 4502 	umull	r4, r5, sl, r2
 8025e18:	442b      	add	r3, r5
 8025e1a:	461d      	mov	r5, r3
 8025e1c:	eb18 0304 	adds.w	r3, r8, r4
 8025e20:	603b      	str	r3, [r7, #0]
 8025e22:	eb49 0305 	adc.w	r3, r9, r5
 8025e26:	607b      	str	r3, [r7, #4]
 8025e28:	e9d7 2300 	ldrd	r2, r3, [r7]
 8025e2c:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
 8025e30:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8025e32:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8025e34:	601a      	str	r2, [r3, #0]
 8025e36:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	@ 0x30
 8025e3a:	f04f 0000 	mov.w	r0, #0
 8025e3e:	f04f 0100 	mov.w	r1, #0
 8025e42:	0018      	movs	r0, r3
 8025e44:	2100      	movs	r1, #0
 8025e46:	4603      	mov	r3, r0
 8025e48:	653b      	str	r3, [r7, #80]	@ 0x50
          ++_c;
 8025e4a:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8025e4c:	3304      	adds	r3, #4
 8025e4e:	667b      	str	r3, [r7, #100]	@ 0x64
       for (; y < pa; y++) {
 8025e50:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8025e52:	3301      	adds	r3, #1
 8025e54:	657b      	str	r3, [r7, #84]	@ 0x54
 8025e56:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8025e58:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8025e5a:	429a      	cmp	r2, r3
 8025e5c:	dbb2      	blt.n	8025dc4 <fp_montgomery_reduce_ex+0xc6>
       }
       LOOP_END;
       while (cy) { /* //NOLINT(bugprone-infinite-loop) */ /* PROPCARRY is an asm macro */
 8025e5e:	e013      	b.n	8025e88 <fp_montgomery_reduce_ex+0x18a>
           PROPCARRY;
 8025e60:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8025e62:	681a      	ldr	r2, [r3, #0]
 8025e64:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8025e66:	441a      	add	r2, r3
 8025e68:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8025e6a:	601a      	str	r2, [r3, #0]
 8025e6c:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8025e6e:	681b      	ldr	r3, [r3, #0]
 8025e70:	63bb      	str	r3, [r7, #56]	@ 0x38
 8025e72:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8025e74:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8025e76:	429a      	cmp	r2, r3
 8025e78:	bf34      	ite	cc
 8025e7a:	2301      	movcc	r3, #1
 8025e7c:	2300      	movcs	r3, #0
 8025e7e:	b2db      	uxtb	r3, r3
 8025e80:	653b      	str	r3, [r7, #80]	@ 0x50
           ++_c;
 8025e82:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8025e84:	3304      	adds	r3, #4
 8025e86:	667b      	str	r3, [r7, #100]	@ 0x64
       while (cy) { /* //NOLINT(bugprone-infinite-loop) */ /* PROPCARRY is an asm macro */
 8025e88:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8025e8a:	2b00      	cmp	r3, #0
 8025e8c:	d1e8      	bne.n	8025e60 <fp_montgomery_reduce_ex+0x162>
   for (x = 0; x < pa; x++) {
 8025e8e:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8025e90:	3301      	adds	r3, #1
 8025e92:	65bb      	str	r3, [r7, #88]	@ 0x58
 8025e94:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8025e96:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8025e98:	429a      	cmp	r2, r3
 8025e9a:	f6ff af7d 	blt.w	8025d98 <fp_montgomery_reduce_ex+0x9a>
       }
  }

  /* now copy out */
  _c   = c + pa;
 8025e9e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8025ea0:	009b      	lsls	r3, r3, #2
 8025ea2:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8025ea4:	4413      	add	r3, r2
 8025ea6:	667b      	str	r3, [r7, #100]	@ 0x64
  tmpm = a->dp;
 8025ea8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8025eaa:	330c      	adds	r3, #12
 8025eac:	663b      	str	r3, [r7, #96]	@ 0x60
  for (x = 0; x < pa+1; x++) {
 8025eae:	2300      	movs	r3, #0
 8025eb0:	65bb      	str	r3, [r7, #88]	@ 0x58
 8025eb2:	e00a      	b.n	8025eca <fp_montgomery_reduce_ex+0x1cc>
     *tmpm++ = *_c++;
 8025eb4:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 8025eb6:	1d13      	adds	r3, r2, #4
 8025eb8:	667b      	str	r3, [r7, #100]	@ 0x64
 8025eba:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8025ebc:	1d19      	adds	r1, r3, #4
 8025ebe:	6639      	str	r1, [r7, #96]	@ 0x60
 8025ec0:	6812      	ldr	r2, [r2, #0]
 8025ec2:	601a      	str	r2, [r3, #0]
  for (x = 0; x < pa+1; x++) {
 8025ec4:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8025ec6:	3301      	adds	r3, #1
 8025ec8:	65bb      	str	r3, [r7, #88]	@ 0x58
 8025eca:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8025ecc:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8025ece:	429a      	cmp	r2, r3
 8025ed0:	daf0      	bge.n	8025eb4 <fp_montgomery_reduce_ex+0x1b6>
  }

  /* zero any excess digits on the destination that we didn't write to */
  for (; x < oldused; x++) {
 8025ed2:	e007      	b.n	8025ee4 <fp_montgomery_reduce_ex+0x1e6>
     *tmpm++ = 0;
 8025ed4:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8025ed6:	1d1a      	adds	r2, r3, #4
 8025ed8:	663a      	str	r2, [r7, #96]	@ 0x60
 8025eda:	2200      	movs	r2, #0
 8025edc:	601a      	str	r2, [r3, #0]
  for (; x < oldused; x++) {
 8025ede:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8025ee0:	3301      	adds	r3, #1
 8025ee2:	65bb      	str	r3, [r7, #88]	@ 0x58
 8025ee4:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8025ee6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8025ee8:	429a      	cmp	r2, r3
 8025eea:	dbf3      	blt.n	8025ed4 <fp_montgomery_reduce_ex+0x1d6>
  }

  MONT_FINI;

  a->used = pa+1;
 8025eec:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8025eee:	1c5a      	adds	r2, r3, #1
 8025ef0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8025ef2:	601a      	str	r2, [r3, #0]
  fp_clamp(a);
 8025ef4:	e004      	b.n	8025f00 <fp_montgomery_reduce_ex+0x202>
 8025ef6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8025ef8:	681b      	ldr	r3, [r3, #0]
 8025efa:	1e5a      	subs	r2, r3, #1
 8025efc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8025efe:	601a      	str	r2, [r3, #0]
 8025f00:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8025f02:	681b      	ldr	r3, [r3, #0]
 8025f04:	2b00      	cmp	r3, #0
 8025f06:	d009      	beq.n	8025f1c <fp_montgomery_reduce_ex+0x21e>
 8025f08:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8025f0a:	681b      	ldr	r3, [r3, #0]
 8025f0c:	3b01      	subs	r3, #1
 8025f0e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8025f10:	3302      	adds	r3, #2
 8025f12:	009b      	lsls	r3, r3, #2
 8025f14:	4413      	add	r3, r2
 8025f16:	685b      	ldr	r3, [r3, #4]
 8025f18:	2b00      	cmp	r3, #0
 8025f1a:	d0ec      	beq.n	8025ef6 <fp_montgomery_reduce_ex+0x1f8>
 8025f1c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8025f1e:	681b      	ldr	r3, [r3, #0]
 8025f20:	2b00      	cmp	r3, #0
 8025f22:	d002      	beq.n	8025f2a <fp_montgomery_reduce_ex+0x22c>
 8025f24:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8025f26:	685b      	ldr	r3, [r3, #4]
 8025f28:	e000      	b.n	8025f2c <fp_montgomery_reduce_ex+0x22e>
 8025f2a:	2300      	movs	r3, #0
 8025f2c:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8025f2e:	6053      	str	r3, [r2, #4]

#ifndef WOLFSSL_MONT_RED_CT
  /* if A >= m then A = A - m */
  if (fp_cmp_mag (a, m) != FP_LT) {
 8025f30:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 8025f32:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8025f34:	f7ff fe07 	bl	8025b46 <fp_cmp_mag>
 8025f38:	4603      	mov	r3, r0
 8025f3a:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8025f3e:	d004      	beq.n	8025f4a <fp_montgomery_reduce_ex+0x24c>
    s_fp_sub (a, m, a);
 8025f40:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8025f42:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 8025f44:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8025f46:	f7fc fae6 	bl	8022516 <s_fp_sub>
    s_fp_sub (a, m, a);
  }
#endif

#ifdef WOLFSSL_SMALL_STACK
  XFREE(c, NULL, DYNAMIC_TYPE_BIGINT);
 8025f4a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8025f4c:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8025f4e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8025f50:	2b00      	cmp	r3, #0
 8025f52:	d002      	beq.n	8025f5a <fp_montgomery_reduce_ex+0x25c>
 8025f54:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8025f56:	f7f8 fdb3 	bl	801eac0 <wolfSSL_Free>
#endif
  return FP_OKAY;
 8025f5a:	2300      	movs	r3, #0
}
 8025f5c:	4618      	mov	r0, r3
 8025f5e:	3768      	adds	r7, #104	@ 0x68
 8025f60:	46bd      	mov	sp, r7
 8025f62:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

08025f66 <fp_montgomery_reduce>:

int fp_montgomery_reduce(fp_int *a, fp_int *m, fp_digit mp)
{
 8025f66:	b580      	push	{r7, lr}
 8025f68:	b084      	sub	sp, #16
 8025f6a:	af00      	add	r7, sp, #0
 8025f6c:	60f8      	str	r0, [r7, #12]
 8025f6e:	60b9      	str	r1, [r7, #8]
 8025f70:	607a      	str	r2, [r7, #4]
  return fp_montgomery_reduce_ex(a, m, mp, 1);
 8025f72:	2301      	movs	r3, #1
 8025f74:	687a      	ldr	r2, [r7, #4]
 8025f76:	68b9      	ldr	r1, [r7, #8]
 8025f78:	68f8      	ldr	r0, [r7, #12]
 8025f7a:	f7ff fec0 	bl	8025cfe <fp_montgomery_reduce_ex>
 8025f7e:	4603      	mov	r3, r0
}
 8025f80:	4618      	mov	r0, r3
 8025f82:	3710      	adds	r7, #16
 8025f84:	46bd      	mov	sp, r7
 8025f86:	bd80      	pop	{r7, pc}

08025f88 <fp_read_unsigned_bin>:

int fp_read_unsigned_bin(fp_int *a, const unsigned char *b, int c)
{
 8025f88:	b580      	push	{r7, lr}
 8025f8a:	b088      	sub	sp, #32
 8025f8c:	af00      	add	r7, sp, #0
 8025f8e:	60f8      	str	r0, [r7, #12]
 8025f90:	60b9      	str	r1, [r7, #8]
 8025f92:	607a      	str	r2, [r7, #4]
#if defined(ALT_ECC_SIZE) || defined(HAVE_WOLF_BIGINT)
  const word32 maxC = (a->size * sizeof(fp_digit));
 8025f94:	68fb      	ldr	r3, [r7, #12]
 8025f96:	689b      	ldr	r3, [r3, #8]
 8025f98:	009b      	lsls	r3, r3, #2
 8025f9a:	61fb      	str	r3, [r7, #28]
#else
  const word32 maxC = (FP_SIZE * sizeof(fp_digit));
#endif

  /* zero the int */
  fp_zero (a);
 8025f9c:	68f8      	ldr	r0, [r7, #12]
 8025f9e:	f000 fb95 	bl	80266cc <fp_zero>

  if (c < 0) {
 8025fa2:	687b      	ldr	r3, [r7, #4]
 8025fa4:	2b00      	cmp	r3, #0
 8025fa6:	da02      	bge.n	8025fae <fp_read_unsigned_bin+0x26>
      return FP_VAL;
 8025fa8:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8025fac:	e04e      	b.n	802604c <fp_read_unsigned_bin+0xc4>
  }

  if (c == 0) {
 8025fae:	687b      	ldr	r3, [r7, #4]
 8025fb0:	2b00      	cmp	r3, #0
 8025fb2:	d101      	bne.n	8025fb8 <fp_read_unsigned_bin+0x30>
      return FP_OKAY;
 8025fb4:	2300      	movs	r3, #0
 8025fb6:	e049      	b.n	802604c <fp_read_unsigned_bin+0xc4>
  }

  /* if input b excess max, then truncate */
  if ((word32)c > maxC) {
 8025fb8:	687b      	ldr	r3, [r7, #4]
 8025fba:	69fa      	ldr	r2, [r7, #28]
 8025fbc:	429a      	cmp	r2, r3
 8025fbe:	d20b      	bcs.n	8025fd8 <fp_read_unsigned_bin+0x50>
     int excess = (c - maxC);
 8025fc0:	687a      	ldr	r2, [r7, #4]
 8025fc2:	69fb      	ldr	r3, [r7, #28]
 8025fc4:	1ad3      	subs	r3, r2, r3
 8025fc6:	61bb      	str	r3, [r7, #24]
     c -= excess;
 8025fc8:	687a      	ldr	r2, [r7, #4]
 8025fca:	69bb      	ldr	r3, [r7, #24]
 8025fcc:	1ad3      	subs	r3, r2, r3
 8025fce:	607b      	str	r3, [r7, #4]
     b += excess;
 8025fd0:	69bb      	ldr	r3, [r7, #24]
 8025fd2:	68ba      	ldr	r2, [r7, #8]
 8025fd4:	4413      	add	r3, r2
 8025fd6:	60bb      	str	r3, [r7, #8]
    (defined(FP_32BIT) || defined(FP_64BIT))
#ifdef FP_32BIT
  /* If we know the endianness of this architecture, and we're using
     32-bit fp_digits, we can optimize this */
  {
     unsigned char *pd = (unsigned char *)a->dp;
 8025fd8:	68fb      	ldr	r3, [r7, #12]
 8025fda:	330c      	adds	r3, #12
 8025fdc:	617b      	str	r3, [r7, #20]

     a->used = (c + sizeof(fp_digit) - 1)/sizeof(fp_digit);
 8025fde:	687b      	ldr	r3, [r7, #4]
 8025fe0:	3303      	adds	r3, #3
 8025fe2:	089b      	lsrs	r3, r3, #2
 8025fe4:	461a      	mov	r2, r3
 8025fe6:	68fb      	ldr	r3, [r7, #12]
 8025fe8:	601a      	str	r2, [r3, #0]
                 } while ((c -= 4) > 0);
       }
     }
#else
     /* read the bytes in one at a time. */
     for (c -= 1; c >= 0; c -= 1) {
 8025fea:	687b      	ldr	r3, [r7, #4]
 8025fec:	3b01      	subs	r3, #1
 8025fee:	607b      	str	r3, [r7, #4]
 8025ff0:	e00a      	b.n	8026008 <fp_read_unsigned_bin+0x80>
       pd[c] = *b++;
 8025ff2:	68bb      	ldr	r3, [r7, #8]
 8025ff4:	1c5a      	adds	r2, r3, #1
 8025ff6:	60ba      	str	r2, [r7, #8]
 8025ff8:	687a      	ldr	r2, [r7, #4]
 8025ffa:	6979      	ldr	r1, [r7, #20]
 8025ffc:	440a      	add	r2, r1
 8025ffe:	781b      	ldrb	r3, [r3, #0]
 8026000:	7013      	strb	r3, [r2, #0]
     for (c -= 1; c >= 0; c -= 1) {
 8026002:	687b      	ldr	r3, [r7, #4]
 8026004:	3b01      	subs	r3, #1
 8026006:	607b      	str	r3, [r7, #4]
 8026008:	687b      	ldr	r3, [r7, #4]
 802600a:	2b00      	cmp	r3, #0
 802600c:	daf1      	bge.n	8025ff2 <fp_read_unsigned_bin+0x6a>
     if (a->used == 0) {
         a->used = 1;
     }
  }
#endif
  fp_clamp (a);
 802600e:	e004      	b.n	802601a <fp_read_unsigned_bin+0x92>
 8026010:	68fb      	ldr	r3, [r7, #12]
 8026012:	681b      	ldr	r3, [r3, #0]
 8026014:	1e5a      	subs	r2, r3, #1
 8026016:	68fb      	ldr	r3, [r7, #12]
 8026018:	601a      	str	r2, [r3, #0]
 802601a:	68fb      	ldr	r3, [r7, #12]
 802601c:	681b      	ldr	r3, [r3, #0]
 802601e:	2b00      	cmp	r3, #0
 8026020:	d009      	beq.n	8026036 <fp_read_unsigned_bin+0xae>
 8026022:	68fb      	ldr	r3, [r7, #12]
 8026024:	681b      	ldr	r3, [r3, #0]
 8026026:	3b01      	subs	r3, #1
 8026028:	68fa      	ldr	r2, [r7, #12]
 802602a:	3302      	adds	r3, #2
 802602c:	009b      	lsls	r3, r3, #2
 802602e:	4413      	add	r3, r2
 8026030:	685b      	ldr	r3, [r3, #4]
 8026032:	2b00      	cmp	r3, #0
 8026034:	d0ec      	beq.n	8026010 <fp_read_unsigned_bin+0x88>
 8026036:	68fb      	ldr	r3, [r7, #12]
 8026038:	681b      	ldr	r3, [r3, #0]
 802603a:	2b00      	cmp	r3, #0
 802603c:	d002      	beq.n	8026044 <fp_read_unsigned_bin+0xbc>
 802603e:	68fb      	ldr	r3, [r7, #12]
 8026040:	685b      	ldr	r3, [r3, #4]
 8026042:	e000      	b.n	8026046 <fp_read_unsigned_bin+0xbe>
 8026044:	2300      	movs	r3, #0
 8026046:	68fa      	ldr	r2, [r7, #12]
 8026048:	6053      	str	r3, [r2, #4]

  return FP_OKAY;
 802604a:	2300      	movs	r3, #0
}
 802604c:	4618      	mov	r0, r3
 802604e:	3720      	adds	r7, #32
 8026050:	46bd      	mov	sp, r7
 8026052:	bd80      	pop	{r7, pc}

08026054 <fp_to_unsigned_bin_at_pos>:

int fp_to_unsigned_bin_at_pos(int x, fp_int *t, unsigned char *b)
{
 8026054:	b480      	push	{r7}
 8026056:	b089      	sub	sp, #36	@ 0x24
 8026058:	af00      	add	r7, sp, #0
 802605a:	60f8      	str	r0, [r7, #12]
 802605c:	60b9      	str	r1, [r7, #8]
 802605e:	607a      	str	r2, [r7, #4]
#if DIGIT_BIT == 64 || DIGIT_BIT == 32
   int i;
   int j = 0;
 8026060:	2300      	movs	r3, #0
 8026062:	61bb      	str	r3, [r7, #24]
   fp_digit n;

   for (i = 0; i < t->used-1; ) {
 8026064:	2300      	movs	r3, #0
 8026066:	61fb      	str	r3, [r7, #28]
 8026068:	e021      	b.n	80260ae <fp_to_unsigned_bin_at_pos+0x5a>
       b[x++] = (unsigned char)(t->dp[i] >> j);
 802606a:	68ba      	ldr	r2, [r7, #8]
 802606c:	69fb      	ldr	r3, [r7, #28]
 802606e:	3302      	adds	r3, #2
 8026070:	009b      	lsls	r3, r3, #2
 8026072:	4413      	add	r3, r2
 8026074:	685a      	ldr	r2, [r3, #4]
 8026076:	69bb      	ldr	r3, [r7, #24]
 8026078:	fa22 f103 	lsr.w	r1, r2, r3
 802607c:	68fb      	ldr	r3, [r7, #12]
 802607e:	1c5a      	adds	r2, r3, #1
 8026080:	60fa      	str	r2, [r7, #12]
 8026082:	461a      	mov	r2, r3
 8026084:	687b      	ldr	r3, [r7, #4]
 8026086:	4413      	add	r3, r2
 8026088:	b2ca      	uxtb	r2, r1
 802608a:	701a      	strb	r2, [r3, #0]
       j += 8;
 802608c:	69bb      	ldr	r3, [r7, #24]
 802608e:	3308      	adds	r3, #8
 8026090:	61bb      	str	r3, [r7, #24]
       i += j == DIGIT_BIT;
 8026092:	69bb      	ldr	r3, [r7, #24]
 8026094:	2b20      	cmp	r3, #32
 8026096:	bf0c      	ite	eq
 8026098:	2301      	moveq	r3, #1
 802609a:	2300      	movne	r3, #0
 802609c:	b2db      	uxtb	r3, r3
 802609e:	461a      	mov	r2, r3
 80260a0:	69fb      	ldr	r3, [r7, #28]
 80260a2:	4413      	add	r3, r2
 80260a4:	61fb      	str	r3, [r7, #28]
       j &= DIGIT_BIT - 1;
 80260a6:	69bb      	ldr	r3, [r7, #24]
 80260a8:	f003 031f 	and.w	r3, r3, #31
 80260ac:	61bb      	str	r3, [r7, #24]
   for (i = 0; i < t->used-1; ) {
 80260ae:	68bb      	ldr	r3, [r7, #8]
 80260b0:	681b      	ldr	r3, [r3, #0]
 80260b2:	3b01      	subs	r3, #1
 80260b4:	69fa      	ldr	r2, [r7, #28]
 80260b6:	429a      	cmp	r2, r3
 80260b8:	dbd7      	blt.n	802606a <fp_to_unsigned_bin_at_pos+0x16>
   }
   n = t->dp[i];
 80260ba:	68ba      	ldr	r2, [r7, #8]
 80260bc:	69fb      	ldr	r3, [r7, #28]
 80260be:	3302      	adds	r3, #2
 80260c0:	009b      	lsls	r3, r3, #2
 80260c2:	4413      	add	r3, r2
 80260c4:	685b      	ldr	r3, [r3, #4]
 80260c6:	617b      	str	r3, [r7, #20]
   while (n != 0) {
 80260c8:	e00b      	b.n	80260e2 <fp_to_unsigned_bin_at_pos+0x8e>
       b[x++] = (unsigned char)n;
 80260ca:	68fb      	ldr	r3, [r7, #12]
 80260cc:	1c5a      	adds	r2, r3, #1
 80260ce:	60fa      	str	r2, [r7, #12]
 80260d0:	461a      	mov	r2, r3
 80260d2:	687b      	ldr	r3, [r7, #4]
 80260d4:	4413      	add	r3, r2
 80260d6:	697a      	ldr	r2, [r7, #20]
 80260d8:	b2d2      	uxtb	r2, r2
 80260da:	701a      	strb	r2, [r3, #0]
       n >>= 8;
 80260dc:	697b      	ldr	r3, [r7, #20]
 80260de:	0a1b      	lsrs	r3, r3, #8
 80260e0:	617b      	str	r3, [r7, #20]
   while (n != 0) {
 80260e2:	697b      	ldr	r3, [r7, #20]
 80260e4:	2b00      	cmp	r3, #0
 80260e6:	d1f0      	bne.n	80260ca <fp_to_unsigned_bin_at_pos+0x76>
   }
   return x;
 80260e8:	68fb      	ldr	r3, [r7, #12]
      b[x++] = (unsigned char) (t->dp[0] & 255);
      fp_div_2d (t, 8, t, NULL);
  }
  return x;
#endif
}
 80260ea:	4618      	mov	r0, r3
 80260ec:	3724      	adds	r7, #36	@ 0x24
 80260ee:	46bd      	mov	sp, r7
 80260f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80260f4:	4770      	bx	lr

080260f6 <fp_to_unsigned_bin>:

int fp_to_unsigned_bin(fp_int *a, unsigned char *b)
{
 80260f6:	b580      	push	{r7, lr}
 80260f8:	b086      	sub	sp, #24
 80260fa:	af00      	add	r7, sp, #0
 80260fc:	6078      	str	r0, [r7, #4]
 80260fe:	6039      	str	r1, [r7, #0]
#else
   fp_int *t;
#endif

#ifdef WOLFSSL_SMALL_STACK
   t = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
 8026100:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 8026104:	f7f8 fcc0 	bl	801ea88 <wolfSSL_Malloc>
 8026108:	6178      	str	r0, [r7, #20]
   if (t == NULL)
 802610a:	697b      	ldr	r3, [r7, #20]
 802610c:	2b00      	cmp	r3, #0
 802610e:	d102      	bne.n	8026116 <fp_to_unsigned_bin+0x20>
       return FP_MEM;
 8026110:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 8026114:	e016      	b.n	8026144 <fp_to_unsigned_bin+0x4e>
#endif

  fp_init_copy(t, a);
 8026116:	6879      	ldr	r1, [r7, #4]
 8026118:	6978      	ldr	r0, [r7, #20]
 802611a:	f000 fcf2 	bl	8026b02 <fp_init_copy>

  x = fp_to_unsigned_bin_at_pos(0, t, b);
 802611e:	683a      	ldr	r2, [r7, #0]
 8026120:	6979      	ldr	r1, [r7, #20]
 8026122:	2000      	movs	r0, #0
 8026124:	f7ff ff96 	bl	8026054 <fp_to_unsigned_bin_at_pos>
 8026128:	6138      	str	r0, [r7, #16]
  mp_reverse (b, x);
 802612a:	6939      	ldr	r1, [r7, #16]
 802612c:	6838      	ldr	r0, [r7, #0]
 802612e:	f001 f983 	bl	8027438 <mp_reverse>

#ifdef WOLFSSL_SMALL_STACK
  XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
 8026132:	697b      	ldr	r3, [r7, #20]
 8026134:	60fb      	str	r3, [r7, #12]
 8026136:	68fb      	ldr	r3, [r7, #12]
 8026138:	2b00      	cmp	r3, #0
 802613a:	d002      	beq.n	8026142 <fp_to_unsigned_bin+0x4c>
 802613c:	68f8      	ldr	r0, [r7, #12]
 802613e:	f7f8 fcbf 	bl	801eac0 <wolfSSL_Free>
#endif
  return FP_OKAY;
 8026142:	2300      	movs	r3, #0
}
 8026144:	4618      	mov	r0, r3
 8026146:	3718      	adds	r7, #24
 8026148:	46bd      	mov	sp, r7
 802614a:	bd80      	pop	{r7, pc}

0802614c <fp_to_unsigned_bin_len>:

int fp_to_unsigned_bin_len(fp_int *a, unsigned char *b, int c)
{
 802614c:	b480      	push	{r7}
 802614e:	b089      	sub	sp, #36	@ 0x24
 8026150:	af00      	add	r7, sp, #0
 8026152:	60f8      	str	r0, [r7, #12]
 8026154:	60b9      	str	r1, [r7, #8]
 8026156:	607a      	str	r2, [r7, #4]
#if DIGIT_BIT == 64 || DIGIT_BIT == 32 || DIGIT_BIT == 16
  int i = 0;
 8026158:	2300      	movs	r3, #0
 802615a:	61fb      	str	r3, [r7, #28]
  int j = 0;
 802615c:	2300      	movs	r3, #0
 802615e:	61bb      	str	r3, [r7, #24]
  int x;

  for (x=c-1; x >= 0 && i < a->used; x--) {
 8026160:	687b      	ldr	r3, [r7, #4]
 8026162:	3b01      	subs	r3, #1
 8026164:	617b      	str	r3, [r7, #20]
 8026166:	e021      	b.n	80261ac <fp_to_unsigned_bin_len+0x60>
     b[x] = (unsigned char)(a->dp[i] >> j);
 8026168:	68fa      	ldr	r2, [r7, #12]
 802616a:	69fb      	ldr	r3, [r7, #28]
 802616c:	3302      	adds	r3, #2
 802616e:	009b      	lsls	r3, r3, #2
 8026170:	4413      	add	r3, r2
 8026172:	685a      	ldr	r2, [r3, #4]
 8026174:	69bb      	ldr	r3, [r7, #24]
 8026176:	fa22 f103 	lsr.w	r1, r2, r3
 802617a:	697b      	ldr	r3, [r7, #20]
 802617c:	68ba      	ldr	r2, [r7, #8]
 802617e:	4413      	add	r3, r2
 8026180:	b2ca      	uxtb	r2, r1
 8026182:	701a      	strb	r2, [r3, #0]
     j += 8;
 8026184:	69bb      	ldr	r3, [r7, #24]
 8026186:	3308      	adds	r3, #8
 8026188:	61bb      	str	r3, [r7, #24]
     i += j == DIGIT_BIT;
 802618a:	69bb      	ldr	r3, [r7, #24]
 802618c:	2b20      	cmp	r3, #32
 802618e:	bf0c      	ite	eq
 8026190:	2301      	moveq	r3, #1
 8026192:	2300      	movne	r3, #0
 8026194:	b2db      	uxtb	r3, r3
 8026196:	461a      	mov	r2, r3
 8026198:	69fb      	ldr	r3, [r7, #28]
 802619a:	4413      	add	r3, r2
 802619c:	61fb      	str	r3, [r7, #28]
     j &= DIGIT_BIT - 1;
 802619e:	69bb      	ldr	r3, [r7, #24]
 80261a0:	f003 031f 	and.w	r3, r3, #31
 80261a4:	61bb      	str	r3, [r7, #24]
  for (x=c-1; x >= 0 && i < a->used; x--) {
 80261a6:	697b      	ldr	r3, [r7, #20]
 80261a8:	3b01      	subs	r3, #1
 80261aa:	617b      	str	r3, [r7, #20]
 80261ac:	697b      	ldr	r3, [r7, #20]
 80261ae:	2b00      	cmp	r3, #0
 80261b0:	db0d      	blt.n	80261ce <fp_to_unsigned_bin_len+0x82>
 80261b2:	68fb      	ldr	r3, [r7, #12]
 80261b4:	681b      	ldr	r3, [r3, #0]
 80261b6:	69fa      	ldr	r2, [r7, #28]
 80261b8:	429a      	cmp	r2, r3
 80261ba:	dbd5      	blt.n	8026168 <fp_to_unsigned_bin_len+0x1c>
  }
  for (; x >= 0; x--) {
 80261bc:	e007      	b.n	80261ce <fp_to_unsigned_bin_len+0x82>
     b[x] = 0;
 80261be:	697b      	ldr	r3, [r7, #20]
 80261c0:	68ba      	ldr	r2, [r7, #8]
 80261c2:	4413      	add	r3, r2
 80261c4:	2200      	movs	r2, #0
 80261c6:	701a      	strb	r2, [r3, #0]
  for (; x >= 0; x--) {
 80261c8:	697b      	ldr	r3, [r7, #20]
 80261ca:	3b01      	subs	r3, #1
 80261cc:	617b      	str	r3, [r7, #20]
 80261ce:	697b      	ldr	r3, [r7, #20]
 80261d0:	2b00      	cmp	r3, #0
 80261d2:	daf4      	bge.n	80261be <fp_to_unsigned_bin_len+0x72>
  }
  if (i < a->used - 1) {
 80261d4:	68fb      	ldr	r3, [r7, #12]
 80261d6:	681b      	ldr	r3, [r3, #0]
 80261d8:	3b01      	subs	r3, #1
 80261da:	69fa      	ldr	r2, [r7, #28]
 80261dc:	429a      	cmp	r2, r3
 80261de:	da02      	bge.n	80261e6 <fp_to_unsigned_bin_len+0x9a>
      return FP_VAL;
 80261e0:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 80261e4:	e014      	b.n	8026210 <fp_to_unsigned_bin_len+0xc4>
  }
  if ((i == a->used - 1) && ((a->dp[i] >> j) != 0)) {
 80261e6:	68fb      	ldr	r3, [r7, #12]
 80261e8:	681b      	ldr	r3, [r3, #0]
 80261ea:	3b01      	subs	r3, #1
 80261ec:	69fa      	ldr	r2, [r7, #28]
 80261ee:	429a      	cmp	r2, r3
 80261f0:	d10d      	bne.n	802620e <fp_to_unsigned_bin_len+0xc2>
 80261f2:	68fa      	ldr	r2, [r7, #12]
 80261f4:	69fb      	ldr	r3, [r7, #28]
 80261f6:	3302      	adds	r3, #2
 80261f8:	009b      	lsls	r3, r3, #2
 80261fa:	4413      	add	r3, r2
 80261fc:	685a      	ldr	r2, [r3, #4]
 80261fe:	69bb      	ldr	r3, [r7, #24]
 8026200:	fa22 f303 	lsr.w	r3, r2, r3
 8026204:	2b00      	cmp	r3, #0
 8026206:	d002      	beq.n	802620e <fp_to_unsigned_bin_len+0xc2>
      return FP_VAL;
 8026208:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 802620c:	e000      	b.n	8026210 <fp_to_unsigned_bin_len+0xc4>
  }

  return FP_OKAY;
 802620e:	2300      	movs	r3, #0
  if (!fp_iszero(t)) {
      return FP_VAL;
  }
  return FP_OKAY;
#endif
}
 8026210:	4618      	mov	r0, r3
 8026212:	3724      	adds	r7, #36	@ 0x24
 8026214:	46bd      	mov	sp, r7
 8026216:	f85d 7b04 	ldr.w	r7, [sp], #4
 802621a:	4770      	bx	lr

0802621c <fp_unsigned_bin_size>:

int fp_unsigned_bin_size(const fp_int *a)
{
 802621c:	b580      	push	{r7, lr}
 802621e:	b084      	sub	sp, #16
 8026220:	af00      	add	r7, sp, #0
 8026222:	6078      	str	r0, [r7, #4]
  int     size = fp_count_bits (a);
 8026224:	6878      	ldr	r0, [r7, #4]
 8026226:	f000 f857 	bl	80262d8 <fp_count_bits>
 802622a:	60f8      	str	r0, [r7, #12]
  return (size / 8 + ((size & 7) != 0 ? 1 : 0));
 802622c:	68fb      	ldr	r3, [r7, #12]
 802622e:	2b00      	cmp	r3, #0
 8026230:	da00      	bge.n	8026234 <fp_unsigned_bin_size+0x18>
 8026232:	3307      	adds	r3, #7
 8026234:	10db      	asrs	r3, r3, #3
 8026236:	461a      	mov	r2, r3
 8026238:	68fb      	ldr	r3, [r7, #12]
 802623a:	f003 0307 	and.w	r3, r3, #7
 802623e:	2b00      	cmp	r3, #0
 8026240:	bf14      	ite	ne
 8026242:	2301      	movne	r3, #1
 8026244:	2300      	moveq	r3, #0
 8026246:	b2db      	uxtb	r3, r3
 8026248:	4413      	add	r3, r2
}
 802624a:	4618      	mov	r0, r3
 802624c:	3710      	adds	r7, #16
 802624e:	46bd      	mov	sp, r7
 8026250:	bd80      	pop	{r7, pc}

08026252 <fp_set>:

void fp_set(fp_int *a, fp_digit b)
{
 8026252:	b580      	push	{r7, lr}
 8026254:	b082      	sub	sp, #8
 8026256:	af00      	add	r7, sp, #0
 8026258:	6078      	str	r0, [r7, #4]
 802625a:	6039      	str	r1, [r7, #0]
   fp_zero(a);
 802625c:	6878      	ldr	r0, [r7, #4]
 802625e:	f000 fa35 	bl	80266cc <fp_zero>
   a->dp[0] = b;
 8026262:	687b      	ldr	r3, [r7, #4]
 8026264:	683a      	ldr	r2, [r7, #0]
 8026266:	60da      	str	r2, [r3, #12]
   a->used  = a->dp[0] ? 1 : 0;
 8026268:	687b      	ldr	r3, [r7, #4]
 802626a:	68db      	ldr	r3, [r3, #12]
 802626c:	2b00      	cmp	r3, #0
 802626e:	bf14      	ite	ne
 8026270:	2301      	movne	r3, #1
 8026272:	2300      	moveq	r3, #0
 8026274:	b2db      	uxtb	r3, r3
 8026276:	461a      	mov	r2, r3
 8026278:	687b      	ldr	r3, [r7, #4]
 802627a:	601a      	str	r2, [r3, #0]
}
 802627c:	bf00      	nop
 802627e:	3708      	adds	r7, #8
 8026280:	46bd      	mov	sp, r7
 8026282:	bd80      	pop	{r7, pc}

08026284 <fp_is_bit_set>:
  return FP_OKAY;
}

/* check if a bit is set */
int fp_is_bit_set (fp_int *a, fp_digit b)
{
 8026284:	b480      	push	{r7}
 8026286:	b085      	sub	sp, #20
 8026288:	af00      	add	r7, sp, #0
 802628a:	6078      	str	r0, [r7, #4]
 802628c:	6039      	str	r1, [r7, #0]
    fp_digit i;

    if (b > FP_MAX_BITS)
 802628e:	683b      	ldr	r3, [r7, #0]
 8026290:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8026294:	d902      	bls.n	802629c <fp_is_bit_set+0x18>
        return FP_VAL;
 8026296:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 802629a:	e017      	b.n	80262cc <fp_is_bit_set+0x48>

    i = b/DIGIT_BIT;
 802629c:	683b      	ldr	r3, [r7, #0]
 802629e:	095b      	lsrs	r3, r3, #5
 80262a0:	60fb      	str	r3, [r7, #12]

    if ((fp_digit)a->used < i)
 80262a2:	687b      	ldr	r3, [r7, #4]
 80262a4:	681b      	ldr	r3, [r3, #0]
 80262a6:	461a      	mov	r2, r3
 80262a8:	68fb      	ldr	r3, [r7, #12]
 80262aa:	4293      	cmp	r3, r2
 80262ac:	d901      	bls.n	80262b2 <fp_is_bit_set+0x2e>
        return 0;
 80262ae:	2300      	movs	r3, #0
 80262b0:	e00c      	b.n	80262cc <fp_is_bit_set+0x48>

    return (int)((a->dp[i] >> b%DIGIT_BIT) & (fp_digit)1);
 80262b2:	687a      	ldr	r2, [r7, #4]
 80262b4:	68fb      	ldr	r3, [r7, #12]
 80262b6:	3302      	adds	r3, #2
 80262b8:	009b      	lsls	r3, r3, #2
 80262ba:	4413      	add	r3, r2
 80262bc:	685a      	ldr	r2, [r3, #4]
 80262be:	683b      	ldr	r3, [r7, #0]
 80262c0:	f003 031f 	and.w	r3, r3, #31
 80262c4:	fa22 f303 	lsr.w	r3, r2, r3
 80262c8:	f003 0301 	and.w	r3, r3, #1
}
 80262cc:	4618      	mov	r0, r3
 80262ce:	3714      	adds	r7, #20
 80262d0:	46bd      	mov	sp, r7
 80262d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80262d6:	4770      	bx	lr

080262d8 <fp_count_bits>:

    return MP_OKAY;
}

int fp_count_bits (const fp_int * a)
{
 80262d8:	b480      	push	{r7}
 80262da:	b085      	sub	sp, #20
 80262dc:	af00      	add	r7, sp, #0
 80262de:	6078      	str	r0, [r7, #4]
  int     r;
  fp_digit q;

  /* shortcut */
  if (a->used == 0) {
 80262e0:	687b      	ldr	r3, [r7, #4]
 80262e2:	681b      	ldr	r3, [r3, #0]
 80262e4:	2b00      	cmp	r3, #0
 80262e6:	d101      	bne.n	80262ec <fp_count_bits+0x14>
    return 0;
 80262e8:	2300      	movs	r3, #0
 80262ea:	e018      	b.n	802631e <fp_count_bits+0x46>
  }

  /* get number of digits and add that */
  r = (a->used - 1) * DIGIT_BIT;
 80262ec:	687b      	ldr	r3, [r7, #4]
 80262ee:	681b      	ldr	r3, [r3, #0]
 80262f0:	3b01      	subs	r3, #1
 80262f2:	015b      	lsls	r3, r3, #5
 80262f4:	60fb      	str	r3, [r7, #12]

  /* take the last digit and count the bits in it */
  q = a->dp[a->used - 1];
 80262f6:	687b      	ldr	r3, [r7, #4]
 80262f8:	681b      	ldr	r3, [r3, #0]
 80262fa:	3b01      	subs	r3, #1
 80262fc:	687a      	ldr	r2, [r7, #4]
 80262fe:	3302      	adds	r3, #2
 8026300:	009b      	lsls	r3, r3, #2
 8026302:	4413      	add	r3, r2
 8026304:	685b      	ldr	r3, [r3, #4]
 8026306:	60bb      	str	r3, [r7, #8]
  while (q > ((fp_digit) 0)) {
 8026308:	e005      	b.n	8026316 <fp_count_bits+0x3e>
    ++r;
 802630a:	68fb      	ldr	r3, [r7, #12]
 802630c:	3301      	adds	r3, #1
 802630e:	60fb      	str	r3, [r7, #12]
    q >>= ((fp_digit) 1);
 8026310:	68bb      	ldr	r3, [r7, #8]
 8026312:	085b      	lsrs	r3, r3, #1
 8026314:	60bb      	str	r3, [r7, #8]
  while (q > ((fp_digit) 0)) {
 8026316:	68bb      	ldr	r3, [r7, #8]
 8026318:	2b00      	cmp	r3, #0
 802631a:	d1f6      	bne.n	802630a <fp_count_bits+0x32>
  }

  return r;
 802631c:	68fb      	ldr	r3, [r7, #12]
}
 802631e:	4618      	mov	r0, r3
 8026320:	3714      	adds	r7, #20
 8026322:	46bd      	mov	sp, r7
 8026324:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026328:	4770      	bx	lr

0802632a <fp_leading_bit>:

int fp_leading_bit(fp_int *a)
{
 802632a:	b480      	push	{r7}
 802632c:	b087      	sub	sp, #28
 802632e:	af00      	add	r7, sp, #0
 8026330:	6078      	str	r0, [r7, #4]
    int bit = 0;
 8026332:	2300      	movs	r3, #0
 8026334:	617b      	str	r3, [r7, #20]

    if (a->used != 0) {
 8026336:	687b      	ldr	r3, [r7, #4]
 8026338:	681b      	ldr	r3, [r3, #0]
 802633a:	2b00      	cmp	r3, #0
 802633c:	d021      	beq.n	8026382 <fp_leading_bit+0x58>
        fp_digit q = a->dp[a->used - 1];
 802633e:	687b      	ldr	r3, [r7, #4]
 8026340:	681b      	ldr	r3, [r3, #0]
 8026342:	3b01      	subs	r3, #1
 8026344:	687a      	ldr	r2, [r7, #4]
 8026346:	3302      	adds	r3, #2
 8026348:	009b      	lsls	r3, r3, #2
 802634a:	4413      	add	r3, r2
 802634c:	685b      	ldr	r3, [r3, #4]
 802634e:	613b      	str	r3, [r7, #16]
        int qSz = sizeof(fp_digit);
 8026350:	2304      	movs	r3, #4
 8026352:	60fb      	str	r3, [r7, #12]

        while (qSz > 0) {
 8026354:	e012      	b.n	802637c <fp_leading_bit+0x52>
            if ((unsigned char)q != 0)
 8026356:	693b      	ldr	r3, [r7, #16]
 8026358:	b2db      	uxtb	r3, r3
 802635a:	2b00      	cmp	r3, #0
 802635c:	d008      	beq.n	8026370 <fp_leading_bit+0x46>
                bit = (q & 0x80) != 0;
 802635e:	693b      	ldr	r3, [r7, #16]
 8026360:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8026364:	2b00      	cmp	r3, #0
 8026366:	bf14      	ite	ne
 8026368:	2301      	movne	r3, #1
 802636a:	2300      	moveq	r3, #0
 802636c:	b2db      	uxtb	r3, r3
 802636e:	617b      	str	r3, [r7, #20]
            q >>= 8;
 8026370:	693b      	ldr	r3, [r7, #16]
 8026372:	0a1b      	lsrs	r3, r3, #8
 8026374:	613b      	str	r3, [r7, #16]
            qSz--;
 8026376:	68fb      	ldr	r3, [r7, #12]
 8026378:	3b01      	subs	r3, #1
 802637a:	60fb      	str	r3, [r7, #12]
        while (qSz > 0) {
 802637c:	68fb      	ldr	r3, [r7, #12]
 802637e:	2b00      	cmp	r3, #0
 8026380:	dce9      	bgt.n	8026356 <fp_leading_bit+0x2c>
        }
    }

    return bit;
 8026382:	697b      	ldr	r3, [r7, #20]
}
 8026384:	4618      	mov	r0, r3
 8026386:	371c      	adds	r7, #28
 8026388:	46bd      	mov	sp, r7
 802638a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802638e:	4770      	bx	lr

08026390 <fp_lshd>:

int fp_lshd(fp_int *a, int x)
{
 8026390:	b480      	push	{r7}
 8026392:	b085      	sub	sp, #20
 8026394:	af00      	add	r7, sp, #0
 8026396:	6078      	str	r0, [r7, #4]
 8026398:	6039      	str	r1, [r7, #0]
    int y;

    if (a->used + x > FP_SIZE) return FP_VAL;
 802639a:	687b      	ldr	r3, [r7, #4]
 802639c:	681a      	ldr	r2, [r3, #0]
 802639e:	683b      	ldr	r3, [r7, #0]
 80263a0:	4413      	add	r3, r2
 80263a2:	2b88      	cmp	r3, #136	@ 0x88
 80263a4:	dd02      	ble.n	80263ac <fp_lshd+0x1c>
 80263a6:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 80263aa:	e04c      	b.n	8026446 <fp_lshd+0xb6>

    y = a->used + x - 1;
 80263ac:	687b      	ldr	r3, [r7, #4]
 80263ae:	681a      	ldr	r2, [r3, #0]
 80263b0:	683b      	ldr	r3, [r7, #0]
 80263b2:	4413      	add	r3, r2
 80263b4:	3b01      	subs	r3, #1
 80263b6:	60fb      	str	r3, [r7, #12]

    /* store new size */
    a->used = y + 1;
 80263b8:	68fb      	ldr	r3, [r7, #12]
 80263ba:	1c5a      	adds	r2, r3, #1
 80263bc:	687b      	ldr	r3, [r7, #4]
 80263be:	601a      	str	r2, [r3, #0]

    /* move digits */
    for (; y >= x; y--) {
 80263c0:	e010      	b.n	80263e4 <fp_lshd+0x54>
        a->dp[y] = a->dp[y-x];
 80263c2:	68fa      	ldr	r2, [r7, #12]
 80263c4:	683b      	ldr	r3, [r7, #0]
 80263c6:	1ad3      	subs	r3, r2, r3
 80263c8:	687a      	ldr	r2, [r7, #4]
 80263ca:	3302      	adds	r3, #2
 80263cc:	009b      	lsls	r3, r3, #2
 80263ce:	4413      	add	r3, r2
 80263d0:	685a      	ldr	r2, [r3, #4]
 80263d2:	6879      	ldr	r1, [r7, #4]
 80263d4:	68fb      	ldr	r3, [r7, #12]
 80263d6:	3302      	adds	r3, #2
 80263d8:	009b      	lsls	r3, r3, #2
 80263da:	440b      	add	r3, r1
 80263dc:	605a      	str	r2, [r3, #4]
    for (; y >= x; y--) {
 80263de:	68fb      	ldr	r3, [r7, #12]
 80263e0:	3b01      	subs	r3, #1
 80263e2:	60fb      	str	r3, [r7, #12]
 80263e4:	68fa      	ldr	r2, [r7, #12]
 80263e6:	683b      	ldr	r3, [r7, #0]
 80263e8:	429a      	cmp	r2, r3
 80263ea:	daea      	bge.n	80263c2 <fp_lshd+0x32>
    }

    /* zero lower digits */
    for (; y >= 0; y--) {
 80263ec:	e009      	b.n	8026402 <fp_lshd+0x72>
        a->dp[y] = 0;
 80263ee:	687a      	ldr	r2, [r7, #4]
 80263f0:	68fb      	ldr	r3, [r7, #12]
 80263f2:	3302      	adds	r3, #2
 80263f4:	009b      	lsls	r3, r3, #2
 80263f6:	4413      	add	r3, r2
 80263f8:	2200      	movs	r2, #0
 80263fa:	605a      	str	r2, [r3, #4]
    for (; y >= 0; y--) {
 80263fc:	68fb      	ldr	r3, [r7, #12]
 80263fe:	3b01      	subs	r3, #1
 8026400:	60fb      	str	r3, [r7, #12]
 8026402:	68fb      	ldr	r3, [r7, #12]
 8026404:	2b00      	cmp	r3, #0
 8026406:	daf2      	bge.n	80263ee <fp_lshd+0x5e>
    }

    /* clamp digits */
    fp_clamp(a);
 8026408:	e004      	b.n	8026414 <fp_lshd+0x84>
 802640a:	687b      	ldr	r3, [r7, #4]
 802640c:	681b      	ldr	r3, [r3, #0]
 802640e:	1e5a      	subs	r2, r3, #1
 8026410:	687b      	ldr	r3, [r7, #4]
 8026412:	601a      	str	r2, [r3, #0]
 8026414:	687b      	ldr	r3, [r7, #4]
 8026416:	681b      	ldr	r3, [r3, #0]
 8026418:	2b00      	cmp	r3, #0
 802641a:	d009      	beq.n	8026430 <fp_lshd+0xa0>
 802641c:	687b      	ldr	r3, [r7, #4]
 802641e:	681b      	ldr	r3, [r3, #0]
 8026420:	3b01      	subs	r3, #1
 8026422:	687a      	ldr	r2, [r7, #4]
 8026424:	3302      	adds	r3, #2
 8026426:	009b      	lsls	r3, r3, #2
 8026428:	4413      	add	r3, r2
 802642a:	685b      	ldr	r3, [r3, #4]
 802642c:	2b00      	cmp	r3, #0
 802642e:	d0ec      	beq.n	802640a <fp_lshd+0x7a>
 8026430:	687b      	ldr	r3, [r7, #4]
 8026432:	681b      	ldr	r3, [r3, #0]
 8026434:	2b00      	cmp	r3, #0
 8026436:	d002      	beq.n	802643e <fp_lshd+0xae>
 8026438:	687b      	ldr	r3, [r7, #4]
 802643a:	685b      	ldr	r3, [r3, #4]
 802643c:	e000      	b.n	8026440 <fp_lshd+0xb0>
 802643e:	2300      	movs	r3, #0
 8026440:	687a      	ldr	r2, [r7, #4]
 8026442:	6053      	str	r3, [r2, #4]
    return FP_OKAY;
 8026444:	2300      	movs	r3, #0
}
 8026446:	4618      	mov	r0, r3
 8026448:	3714      	adds	r7, #20
 802644a:	46bd      	mov	sp, r7
 802644c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026450:	4770      	bx	lr

08026452 <fp_rshb>:


/* right shift by bit count */
void fp_rshb(fp_int *c, int x)
{
 8026452:	b580      	push	{r7, lr}
 8026454:	b088      	sub	sp, #32
 8026456:	af00      	add	r7, sp, #0
 8026458:	6078      	str	r0, [r7, #4]
 802645a:	6039      	str	r1, [r7, #0]
    fp_digit *tmpc, mask, shift;
    fp_digit r, rr;
    fp_digit D = x;
 802645c:	683b      	ldr	r3, [r7, #0]
 802645e:	617b      	str	r3, [r7, #20]

    /* shifting by a negative number not supported, and shifting by
     * zero changes nothing.
     */
    if (x <= 0) return;
 8026460:	683b      	ldr	r3, [r7, #0]
 8026462:	2b00      	cmp	r3, #0
 8026464:	dd71      	ble.n	802654a <fp_rshb+0xf8>

    /* shift digits first if needed */
    if (x >= DIGIT_BIT) {
 8026466:	683b      	ldr	r3, [r7, #0]
 8026468:	2b1f      	cmp	r3, #31
 802646a:	dd14      	ble.n	8026496 <fp_rshb+0x44>
        fp_rshd(c, x / DIGIT_BIT);
 802646c:	683b      	ldr	r3, [r7, #0]
 802646e:	2b00      	cmp	r3, #0
 8026470:	da00      	bge.n	8026474 <fp_rshb+0x22>
 8026472:	331f      	adds	r3, #31
 8026474:	115b      	asrs	r3, r3, #5
 8026476:	4619      	mov	r1, r3
 8026478:	6878      	ldr	r0, [r7, #4]
 802647a:	f000 f86e 	bl	802655a <fp_rshd>
        /* recalculate number of bits to shift */
        D = x % DIGIT_BIT;
 802647e:	683b      	ldr	r3, [r7, #0]
 8026480:	425a      	negs	r2, r3
 8026482:	f003 031f 	and.w	r3, r3, #31
 8026486:	f002 021f 	and.w	r2, r2, #31
 802648a:	bf58      	it	pl
 802648c:	4253      	negpl	r3, r2
 802648e:	617b      	str	r3, [r7, #20]
        /* check if any more shifting needed */
        if (D == 0) return;
 8026490:	697b      	ldr	r3, [r7, #20]
 8026492:	2b00      	cmp	r3, #0
 8026494:	d05b      	beq.n	802654e <fp_rshb+0xfc>

    }

    /* zero shifted is always zero */
    if (fp_iszero(c)) return;
 8026496:	687b      	ldr	r3, [r7, #4]
 8026498:	681b      	ldr	r3, [r3, #0]
 802649a:	2b00      	cmp	r3, #0
 802649c:	d059      	beq.n	8026552 <fp_rshb+0x100>

    /* mask */
    mask = (((fp_digit)1) << D) - 1;
 802649e:	2201      	movs	r2, #1
 80264a0:	697b      	ldr	r3, [r7, #20]
 80264a2:	fa02 f303 	lsl.w	r3, r2, r3
 80264a6:	3b01      	subs	r3, #1
 80264a8:	613b      	str	r3, [r7, #16]

    /* shift for lsb */
    shift = DIGIT_BIT - D;
 80264aa:	697b      	ldr	r3, [r7, #20]
 80264ac:	f1c3 0320 	rsb	r3, r3, #32
 80264b0:	60fb      	str	r3, [r7, #12]

    /* alias */
    tmpc = c->dp + (c->used - 1);
 80264b2:	687b      	ldr	r3, [r7, #4]
 80264b4:	f103 020c 	add.w	r2, r3, #12
 80264b8:	687b      	ldr	r3, [r7, #4]
 80264ba:	681b      	ldr	r3, [r3, #0]
 80264bc:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 80264c0:	3b01      	subs	r3, #1
 80264c2:	009b      	lsls	r3, r3, #2
 80264c4:	4413      	add	r3, r2
 80264c6:	61fb      	str	r3, [r7, #28]

    /* carry */
    r = 0;
 80264c8:	2300      	movs	r3, #0
 80264ca:	61bb      	str	r3, [r7, #24]
    for (x = c->used - 1; x >= 0; x--) {
 80264cc:	687b      	ldr	r3, [r7, #4]
 80264ce:	681b      	ldr	r3, [r3, #0]
 80264d0:	3b01      	subs	r3, #1
 80264d2:	603b      	str	r3, [r7, #0]
 80264d4:	e017      	b.n	8026506 <fp_rshb+0xb4>
      /* get the lower  bits of this word in a temp */
      rr = *tmpc & mask;
 80264d6:	69fb      	ldr	r3, [r7, #28]
 80264d8:	681b      	ldr	r3, [r3, #0]
 80264da:	693a      	ldr	r2, [r7, #16]
 80264dc:	4013      	ands	r3, r2
 80264de:	60bb      	str	r3, [r7, #8]

      /* shift the current word and mix in the carry bits from previous word */
      *tmpc = (*tmpc >> D) | (r << shift);
 80264e0:	69fb      	ldr	r3, [r7, #28]
 80264e2:	681a      	ldr	r2, [r3, #0]
 80264e4:	697b      	ldr	r3, [r7, #20]
 80264e6:	40da      	lsrs	r2, r3
 80264e8:	69b9      	ldr	r1, [r7, #24]
 80264ea:	68fb      	ldr	r3, [r7, #12]
 80264ec:	fa01 f303 	lsl.w	r3, r1, r3
 80264f0:	431a      	orrs	r2, r3
 80264f2:	69fb      	ldr	r3, [r7, #28]
 80264f4:	601a      	str	r2, [r3, #0]
      --tmpc;
 80264f6:	69fb      	ldr	r3, [r7, #28]
 80264f8:	3b04      	subs	r3, #4
 80264fa:	61fb      	str	r3, [r7, #28]

      /* set the carry to the carry bits of the current word found above */
      r = rr;
 80264fc:	68bb      	ldr	r3, [r7, #8]
 80264fe:	61bb      	str	r3, [r7, #24]
    for (x = c->used - 1; x >= 0; x--) {
 8026500:	683b      	ldr	r3, [r7, #0]
 8026502:	3b01      	subs	r3, #1
 8026504:	603b      	str	r3, [r7, #0]
 8026506:	683b      	ldr	r3, [r7, #0]
 8026508:	2b00      	cmp	r3, #0
 802650a:	dae4      	bge.n	80264d6 <fp_rshb+0x84>
    }

    /* clamp digits */
    fp_clamp(c);
 802650c:	e004      	b.n	8026518 <fp_rshb+0xc6>
 802650e:	687b      	ldr	r3, [r7, #4]
 8026510:	681b      	ldr	r3, [r3, #0]
 8026512:	1e5a      	subs	r2, r3, #1
 8026514:	687b      	ldr	r3, [r7, #4]
 8026516:	601a      	str	r2, [r3, #0]
 8026518:	687b      	ldr	r3, [r7, #4]
 802651a:	681b      	ldr	r3, [r3, #0]
 802651c:	2b00      	cmp	r3, #0
 802651e:	d009      	beq.n	8026534 <fp_rshb+0xe2>
 8026520:	687b      	ldr	r3, [r7, #4]
 8026522:	681b      	ldr	r3, [r3, #0]
 8026524:	3b01      	subs	r3, #1
 8026526:	687a      	ldr	r2, [r7, #4]
 8026528:	3302      	adds	r3, #2
 802652a:	009b      	lsls	r3, r3, #2
 802652c:	4413      	add	r3, r2
 802652e:	685b      	ldr	r3, [r3, #4]
 8026530:	2b00      	cmp	r3, #0
 8026532:	d0ec      	beq.n	802650e <fp_rshb+0xbc>
 8026534:	687b      	ldr	r3, [r7, #4]
 8026536:	681b      	ldr	r3, [r3, #0]
 8026538:	2b00      	cmp	r3, #0
 802653a:	d002      	beq.n	8026542 <fp_rshb+0xf0>
 802653c:	687b      	ldr	r3, [r7, #4]
 802653e:	685b      	ldr	r3, [r3, #4]
 8026540:	e000      	b.n	8026544 <fp_rshb+0xf2>
 8026542:	2300      	movs	r3, #0
 8026544:	687a      	ldr	r2, [r7, #4]
 8026546:	6053      	str	r3, [r2, #4]
 8026548:	e004      	b.n	8026554 <fp_rshb+0x102>
    if (x <= 0) return;
 802654a:	bf00      	nop
 802654c:	e002      	b.n	8026554 <fp_rshb+0x102>
        if (D == 0) return;
 802654e:	bf00      	nop
 8026550:	e000      	b.n	8026554 <fp_rshb+0x102>
    if (fp_iszero(c)) return;
 8026552:	bf00      	nop
}
 8026554:	3720      	adds	r7, #32
 8026556:	46bd      	mov	sp, r7
 8026558:	bd80      	pop	{r7, pc}

0802655a <fp_rshd>:


void fp_rshd(fp_int *a, int x)
{
 802655a:	b580      	push	{r7, lr}
 802655c:	b084      	sub	sp, #16
 802655e:	af00      	add	r7, sp, #0
 8026560:	6078      	str	r0, [r7, #4]
 8026562:	6039      	str	r1, [r7, #0]
  int y;

  /* too many digits just zero and return */
  if (x >= a->used) {
 8026564:	687b      	ldr	r3, [r7, #4]
 8026566:	681b      	ldr	r3, [r3, #0]
 8026568:	683a      	ldr	r2, [r7, #0]
 802656a:	429a      	cmp	r2, r3
 802656c:	db03      	blt.n	8026576 <fp_rshd+0x1c>
     fp_zero(a);
 802656e:	6878      	ldr	r0, [r7, #4]
 8026570:	f000 f8ac 	bl	80266cc <fp_zero>
     return;
 8026574:	e04e      	b.n	8026614 <fp_rshd+0xba>
  }

   /* shift */
   for (y = 0; y < a->used - x; y++) {
 8026576:	2300      	movs	r3, #0
 8026578:	60fb      	str	r3, [r7, #12]
 802657a:	e010      	b.n	802659e <fp_rshd+0x44>
      a->dp[y] = a->dp[y+x];
 802657c:	68fa      	ldr	r2, [r7, #12]
 802657e:	683b      	ldr	r3, [r7, #0]
 8026580:	4413      	add	r3, r2
 8026582:	687a      	ldr	r2, [r7, #4]
 8026584:	3302      	adds	r3, #2
 8026586:	009b      	lsls	r3, r3, #2
 8026588:	4413      	add	r3, r2
 802658a:	685a      	ldr	r2, [r3, #4]
 802658c:	6879      	ldr	r1, [r7, #4]
 802658e:	68fb      	ldr	r3, [r7, #12]
 8026590:	3302      	adds	r3, #2
 8026592:	009b      	lsls	r3, r3, #2
 8026594:	440b      	add	r3, r1
 8026596:	605a      	str	r2, [r3, #4]
   for (y = 0; y < a->used - x; y++) {
 8026598:	68fb      	ldr	r3, [r7, #12]
 802659a:	3301      	adds	r3, #1
 802659c:	60fb      	str	r3, [r7, #12]
 802659e:	687b      	ldr	r3, [r7, #4]
 80265a0:	681a      	ldr	r2, [r3, #0]
 80265a2:	683b      	ldr	r3, [r7, #0]
 80265a4:	1ad3      	subs	r3, r2, r3
 80265a6:	68fa      	ldr	r2, [r7, #12]
 80265a8:	429a      	cmp	r2, r3
 80265aa:	dbe7      	blt.n	802657c <fp_rshd+0x22>
   }

   /* zero rest */
   for (; y < a->used; y++) {
 80265ac:	e009      	b.n	80265c2 <fp_rshd+0x68>
      a->dp[y] = 0;
 80265ae:	687a      	ldr	r2, [r7, #4]
 80265b0:	68fb      	ldr	r3, [r7, #12]
 80265b2:	3302      	adds	r3, #2
 80265b4:	009b      	lsls	r3, r3, #2
 80265b6:	4413      	add	r3, r2
 80265b8:	2200      	movs	r2, #0
 80265ba:	605a      	str	r2, [r3, #4]
   for (; y < a->used; y++) {
 80265bc:	68fb      	ldr	r3, [r7, #12]
 80265be:	3301      	adds	r3, #1
 80265c0:	60fb      	str	r3, [r7, #12]
 80265c2:	687b      	ldr	r3, [r7, #4]
 80265c4:	681b      	ldr	r3, [r3, #0]
 80265c6:	68fa      	ldr	r2, [r7, #12]
 80265c8:	429a      	cmp	r2, r3
 80265ca:	dbf0      	blt.n	80265ae <fp_rshd+0x54>
   }

   /* decrement count */
   a->used -= x;
 80265cc:	687b      	ldr	r3, [r7, #4]
 80265ce:	681a      	ldr	r2, [r3, #0]
 80265d0:	683b      	ldr	r3, [r7, #0]
 80265d2:	1ad2      	subs	r2, r2, r3
 80265d4:	687b      	ldr	r3, [r7, #4]
 80265d6:	601a      	str	r2, [r3, #0]
   fp_clamp(a);
 80265d8:	e004      	b.n	80265e4 <fp_rshd+0x8a>
 80265da:	687b      	ldr	r3, [r7, #4]
 80265dc:	681b      	ldr	r3, [r3, #0]
 80265de:	1e5a      	subs	r2, r3, #1
 80265e0:	687b      	ldr	r3, [r7, #4]
 80265e2:	601a      	str	r2, [r3, #0]
 80265e4:	687b      	ldr	r3, [r7, #4]
 80265e6:	681b      	ldr	r3, [r3, #0]
 80265e8:	2b00      	cmp	r3, #0
 80265ea:	d009      	beq.n	8026600 <fp_rshd+0xa6>
 80265ec:	687b      	ldr	r3, [r7, #4]
 80265ee:	681b      	ldr	r3, [r3, #0]
 80265f0:	3b01      	subs	r3, #1
 80265f2:	687a      	ldr	r2, [r7, #4]
 80265f4:	3302      	adds	r3, #2
 80265f6:	009b      	lsls	r3, r3, #2
 80265f8:	4413      	add	r3, r2
 80265fa:	685b      	ldr	r3, [r3, #4]
 80265fc:	2b00      	cmp	r3, #0
 80265fe:	d0ec      	beq.n	80265da <fp_rshd+0x80>
 8026600:	687b      	ldr	r3, [r7, #4]
 8026602:	681b      	ldr	r3, [r3, #0]
 8026604:	2b00      	cmp	r3, #0
 8026606:	d002      	beq.n	802660e <fp_rshd+0xb4>
 8026608:	687b      	ldr	r3, [r7, #4]
 802660a:	685b      	ldr	r3, [r3, #4]
 802660c:	e000      	b.n	8026610 <fp_rshd+0xb6>
 802660e:	2300      	movs	r3, #0
 8026610:	687a      	ldr	r2, [r7, #4]
 8026612:	6053      	str	r3, [r2, #4]
}
 8026614:	3710      	adds	r7, #16
 8026616:	46bd      	mov	sp, r7
 8026618:	bd80      	pop	{r7, pc}

0802661a <fp_sub_d>:


/* c = a - b */
int fp_sub_d(fp_int *a, fp_digit b, fp_int *c)
{
 802661a:	b580      	push	{r7, lr}
 802661c:	b088      	sub	sp, #32
 802661e:	af00      	add	r7, sp, #0
 8026620:	60f8      	str	r0, [r7, #12]
 8026622:	60b9      	str	r1, [r7, #8]
 8026624:	607a      	str	r2, [r7, #4]
#ifndef WOLFSSL_SMALL_STACK
   fp_int    tmp[1];
#else
   fp_int    *tmp;
#endif
   int       err = FP_OKAY;
 8026626:	2300      	movs	r3, #0
 8026628:	61fb      	str	r3, [r7, #28]

#ifdef WOLFSSL_SMALL_STACK
   tmp = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
 802662a:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 802662e:	f7f8 fa2b 	bl	801ea88 <wolfSSL_Malloc>
 8026632:	61b8      	str	r0, [r7, #24]
   if (tmp == NULL)
 8026634:	69bb      	ldr	r3, [r7, #24]
 8026636:	2b00      	cmp	r3, #0
 8026638:	d102      	bne.n	8026640 <fp_sub_d+0x26>
       return FP_MEM;
 802663a:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 802663e:	e024      	b.n	802668a <fp_sub_d+0x70>
#endif

   fp_init(tmp);
 8026640:	69b8      	ldr	r0, [r7, #24]
 8026642:	f000 f835 	bl	80266b0 <fp_init>
   fp_set(tmp, b);
 8026646:	68b9      	ldr	r1, [r7, #8]
 8026648:	69b8      	ldr	r0, [r7, #24]
 802664a:	f7ff fe02 	bl	8026252 <fp_set>
#if defined(ALT_ECC_SIZE) || defined(HAVE_WOLF_BIGINT)
   if (c->size < FP_SIZE) {
 802664e:	687b      	ldr	r3, [r7, #4]
 8026650:	689b      	ldr	r3, [r3, #8]
 8026652:	2b87      	cmp	r3, #135	@ 0x87
 8026654:	dc0a      	bgt.n	802666c <fp_sub_d+0x52>
     err = fp_sub(a, tmp, tmp);
 8026656:	69ba      	ldr	r2, [r7, #24]
 8026658:	69b9      	ldr	r1, [r7, #24]
 802665a:	68f8      	ldr	r0, [r7, #12]
 802665c:	f7fb ff1b 	bl	8022496 <fp_sub>
 8026660:	61f8      	str	r0, [r7, #28]
     fp_copy(tmp, c);
 8026662:	6879      	ldr	r1, [r7, #4]
 8026664:	69b8      	ldr	r0, [r7, #24]
 8026666:	f000 fa0d 	bl	8026a84 <fp_copy>
 802666a:	e005      	b.n	8026678 <fp_sub_d+0x5e>
   }
   else
#endif
   {
     err = fp_sub(a, tmp, c);
 802666c:	687a      	ldr	r2, [r7, #4]
 802666e:	69b9      	ldr	r1, [r7, #24]
 8026670:	68f8      	ldr	r0, [r7, #12]
 8026672:	f7fb ff10 	bl	8022496 <fp_sub>
 8026676:	61f8      	str	r0, [r7, #28]
   }

#ifdef WOLFSSL_SMALL_STACK
   XFREE(tmp, NULL, DYNAMIC_TYPE_BIGINT);
 8026678:	69bb      	ldr	r3, [r7, #24]
 802667a:	617b      	str	r3, [r7, #20]
 802667c:	697b      	ldr	r3, [r7, #20]
 802667e:	2b00      	cmp	r3, #0
 8026680:	d002      	beq.n	8026688 <fp_sub_d+0x6e>
 8026682:	6978      	ldr	r0, [r7, #20]
 8026684:	f7f8 fa1c 	bl	801eac0 <wolfSSL_Free>
#endif
   return err;
 8026688:	69fb      	ldr	r3, [r7, #28]
}
 802668a:	4618      	mov	r0, r3
 802668c:	3720      	adds	r7, #32
 802668e:	46bd      	mov	sp, r7
 8026690:	bd80      	pop	{r7, pc}

08026692 <mp_init>:

/* wolfSSL callers from normal lib */

/* init a new mp_int */
int mp_init (mp_int * a)
{
 8026692:	b580      	push	{r7, lr}
 8026694:	b082      	sub	sp, #8
 8026696:	af00      	add	r7, sp, #0
 8026698:	6078      	str	r0, [r7, #4]
  if (a)
 802669a:	687b      	ldr	r3, [r7, #4]
 802669c:	2b00      	cmp	r3, #0
 802669e:	d002      	beq.n	80266a6 <mp_init+0x14>
    fp_init(a);
 80266a0:	6878      	ldr	r0, [r7, #4]
 80266a2:	f000 f805 	bl	80266b0 <fp_init>
  return MP_OKAY;
 80266a6:	2300      	movs	r3, #0
}
 80266a8:	4618      	mov	r0, r3
 80266aa:	3708      	adds	r7, #8
 80266ac:	46bd      	mov	sp, r7
 80266ae:	bd80      	pop	{r7, pc}

080266b0 <fp_init>:

void fp_init(fp_int *a)
{
 80266b0:	b580      	push	{r7, lr}
 80266b2:	b082      	sub	sp, #8
 80266b4:	af00      	add	r7, sp, #0
 80266b6:	6078      	str	r0, [r7, #4]
#if defined(ALT_ECC_SIZE) || defined(HAVE_WOLF_BIGINT)
    a->size = FP_SIZE;
 80266b8:	687b      	ldr	r3, [r7, #4]
 80266ba:	2288      	movs	r2, #136	@ 0x88
 80266bc:	609a      	str	r2, [r3, #8]
#endif
#ifdef HAVE_WOLF_BIGINT
    wc_bigint_init(&a->raw);
#endif
    fp_zero(a);
 80266be:	6878      	ldr	r0, [r7, #4]
 80266c0:	f000 f804 	bl	80266cc <fp_zero>
}
 80266c4:	bf00      	nop
 80266c6:	3708      	adds	r7, #8
 80266c8:	46bd      	mov	sp, r7
 80266ca:	bd80      	pop	{r7, pc}

080266cc <fp_zero>:

void fp_zero(fp_int *a)
{
 80266cc:	b580      	push	{r7, lr}
 80266ce:	b084      	sub	sp, #16
 80266d0:	af00      	add	r7, sp, #0
 80266d2:	6078      	str	r0, [r7, #4]
    int size;
    a->used = 0;
 80266d4:	687b      	ldr	r3, [r7, #4]
 80266d6:	2200      	movs	r2, #0
 80266d8:	601a      	str	r2, [r3, #0]
    a->sign = FP_ZPOS;
 80266da:	687b      	ldr	r3, [r7, #4]
 80266dc:	2200      	movs	r2, #0
 80266de:	605a      	str	r2, [r3, #4]
#if defined(ALT_ECC_SIZE) || defined(HAVE_WOLF_BIGINT)
    size = a->size;
 80266e0:	687b      	ldr	r3, [r7, #4]
 80266e2:	689b      	ldr	r3, [r3, #8]
 80266e4:	60fb      	str	r3, [r7, #12]
#else
    size = FP_SIZE;
#endif
    XMEMSET(a->dp, 0, size * sizeof(fp_digit));
 80266e6:	687b      	ldr	r3, [r7, #4]
 80266e8:	f103 000c 	add.w	r0, r3, #12
 80266ec:	68fb      	ldr	r3, [r7, #12]
 80266ee:	009b      	lsls	r3, r3, #2
 80266f0:	461a      	mov	r2, r3
 80266f2:	2100      	movs	r1, #0
 80266f4:	f001 fee8 	bl	80284c8 <memset>
}
 80266f8:	bf00      	nop
 80266fa:	3710      	adds	r7, #16
 80266fc:	46bd      	mov	sp, r7
 80266fe:	bd80      	pop	{r7, pc}

08026700 <fp_clear>:

void fp_clear(fp_int *a)
{
 8026700:	b580      	push	{r7, lr}
 8026702:	b084      	sub	sp, #16
 8026704:	af00      	add	r7, sp, #0
 8026706:	6078      	str	r0, [r7, #4]
    int size;
    a->used = 0;
 8026708:	687b      	ldr	r3, [r7, #4]
 802670a:	2200      	movs	r2, #0
 802670c:	601a      	str	r2, [r3, #0]
    a->sign = FP_ZPOS;
 802670e:	687b      	ldr	r3, [r7, #4]
 8026710:	2200      	movs	r2, #0
 8026712:	605a      	str	r2, [r3, #4]
#if defined(ALT_ECC_SIZE) || defined(HAVE_WOLF_BIGINT)
    size = a->size;
 8026714:	687b      	ldr	r3, [r7, #4]
 8026716:	689b      	ldr	r3, [r3, #8]
 8026718:	60fb      	str	r3, [r7, #12]
#else
    size = FP_SIZE;
#endif
    XMEMSET(a->dp, 0, size * sizeof(fp_digit));
 802671a:	687b      	ldr	r3, [r7, #4]
 802671c:	f103 000c 	add.w	r0, r3, #12
 8026720:	68fb      	ldr	r3, [r7, #12]
 8026722:	009b      	lsls	r3, r3, #2
 8026724:	461a      	mov	r2, r3
 8026726:	2100      	movs	r1, #0
 8026728:	f001 fece 	bl	80284c8 <memset>
    fp_free(a);
 802672c:	6878      	ldr	r0, [r7, #4]
 802672e:	f000 f830 	bl	8026792 <fp_free>
}
 8026732:	bf00      	nop
 8026734:	3710      	adds	r7, #16
 8026736:	46bd      	mov	sp, r7
 8026738:	bd80      	pop	{r7, pc}

0802673a <fp_forcezero>:

void fp_forcezero (mp_int * a)
{
 802673a:	b580      	push	{r7, lr}
 802673c:	b084      	sub	sp, #16
 802673e:	af00      	add	r7, sp, #0
 8026740:	6078      	str	r0, [r7, #4]
    int size;

    if (a == NULL)
 8026742:	687b      	ldr	r3, [r7, #4]
 8026744:	2b00      	cmp	r3, #0
 8026746:	d015      	beq.n	8026774 <fp_forcezero+0x3a>
      return;

    a->used = 0;
 8026748:	687b      	ldr	r3, [r7, #4]
 802674a:	2200      	movs	r2, #0
 802674c:	601a      	str	r2, [r3, #0]
    a->sign = FP_ZPOS;
 802674e:	687b      	ldr	r3, [r7, #4]
 8026750:	2200      	movs	r2, #0
 8026752:	605a      	str	r2, [r3, #4]
#if defined(ALT_ECC_SIZE) || defined(HAVE_WOLF_BIGINT)
    size = a->size;
 8026754:	687b      	ldr	r3, [r7, #4]
 8026756:	689b      	ldr	r3, [r3, #8]
 8026758:	60fb      	str	r3, [r7, #12]
#else
    size = FP_SIZE;
#endif
    ForceZero(a->dp, size * sizeof(fp_digit));
 802675a:	687b      	ldr	r3, [r7, #4]
 802675c:	f103 020c 	add.w	r2, r3, #12
 8026760:	68fb      	ldr	r3, [r7, #12]
 8026762:	009b      	lsls	r3, r3, #2
 8026764:	4619      	mov	r1, r3
 8026766:	4610      	mov	r0, r2
 8026768:	f7fb fd4c 	bl	8022204 <ForceZero>
#ifdef HAVE_WOLF_BIGINT
    wc_bigint_zero(&a->raw);
#endif
    fp_free(a);
 802676c:	6878      	ldr	r0, [r7, #4]
 802676e:	f000 f810 	bl	8026792 <fp_free>
 8026772:	e000      	b.n	8026776 <fp_forcezero+0x3c>
      return;
 8026774:	bf00      	nop
}
 8026776:	3710      	adds	r7, #16
 8026778:	46bd      	mov	sp, r7
 802677a:	bd80      	pop	{r7, pc}

0802677c <mp_forcezero>:

void mp_forcezero (mp_int * a)
{
 802677c:	b580      	push	{r7, lr}
 802677e:	b082      	sub	sp, #8
 8026780:	af00      	add	r7, sp, #0
 8026782:	6078      	str	r0, [r7, #4]
    fp_forcezero(a);
 8026784:	6878      	ldr	r0, [r7, #4]
 8026786:	f7ff ffd8 	bl	802673a <fp_forcezero>
}
 802678a:	bf00      	nop
 802678c:	3708      	adds	r7, #8
 802678e:	46bd      	mov	sp, r7
 8026790:	bd80      	pop	{r7, pc}

08026792 <fp_free>:

void fp_free(fp_int* a)
{
 8026792:	b480      	push	{r7}
 8026794:	b083      	sub	sp, #12
 8026796:	af00      	add	r7, sp, #0
 8026798:	6078      	str	r0, [r7, #4]
#ifdef HAVE_WOLF_BIGINT
    wc_bigint_free(&a->raw);
#else
    (void)a;
#endif
}
 802679a:	bf00      	nop
 802679c:	370c      	adds	r7, #12
 802679e:	46bd      	mov	sp, r7
 80267a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80267a4:	4770      	bx	lr

080267a6 <mp_clear>:


/* clear one (frees)  */
void mp_clear (mp_int * a)
{
 80267a6:	b580      	push	{r7, lr}
 80267a8:	b082      	sub	sp, #8
 80267aa:	af00      	add	r7, sp, #0
 80267ac:	6078      	str	r0, [r7, #4]
    if (a == NULL)
 80267ae:	687b      	ldr	r3, [r7, #4]
 80267b0:	2b00      	cmp	r3, #0
 80267b2:	d003      	beq.n	80267bc <mp_clear+0x16>
        return;
    fp_clear(a);
 80267b4:	6878      	ldr	r0, [r7, #4]
 80267b6:	f7ff ffa3 	bl	8026700 <fp_clear>
 80267ba:	e000      	b.n	80267be <mp_clear+0x18>
        return;
 80267bc:	bf00      	nop
}
 80267be:	3708      	adds	r7, #8
 80267c0:	46bd      	mov	sp, r7
 80267c2:	bd80      	pop	{r7, pc}

080267c4 <mp_free>:

void mp_free(mp_int* a)
{
 80267c4:	b580      	push	{r7, lr}
 80267c6:	b082      	sub	sp, #8
 80267c8:	af00      	add	r7, sp, #0
 80267ca:	6078      	str	r0, [r7, #4]
    fp_free(a);
 80267cc:	6878      	ldr	r0, [r7, #4]
 80267ce:	f7ff ffe0 	bl	8026792 <fp_free>
}
 80267d2:	bf00      	nop
 80267d4:	3708      	adds	r7, #8
 80267d6:	46bd      	mov	sp, r7
 80267d8:	bd80      	pop	{r7, pc}

080267da <mp_init_multi>:

/* handle up to 6 inits */
int mp_init_multi(mp_int* a, mp_int* b, mp_int* c, mp_int* d,
                  mp_int* e, mp_int* f)
{
 80267da:	b580      	push	{r7, lr}
 80267dc:	b084      	sub	sp, #16
 80267de:	af00      	add	r7, sp, #0
 80267e0:	60f8      	str	r0, [r7, #12]
 80267e2:	60b9      	str	r1, [r7, #8]
 80267e4:	607a      	str	r2, [r7, #4]
 80267e6:	603b      	str	r3, [r7, #0]
    if (a)
 80267e8:	68fb      	ldr	r3, [r7, #12]
 80267ea:	2b00      	cmp	r3, #0
 80267ec:	d002      	beq.n	80267f4 <mp_init_multi+0x1a>
        fp_init(a);
 80267ee:	68f8      	ldr	r0, [r7, #12]
 80267f0:	f7ff ff5e 	bl	80266b0 <fp_init>
    if (b)
 80267f4:	68bb      	ldr	r3, [r7, #8]
 80267f6:	2b00      	cmp	r3, #0
 80267f8:	d002      	beq.n	8026800 <mp_init_multi+0x26>
        fp_init(b);
 80267fa:	68b8      	ldr	r0, [r7, #8]
 80267fc:	f7ff ff58 	bl	80266b0 <fp_init>
    if (c)
 8026800:	687b      	ldr	r3, [r7, #4]
 8026802:	2b00      	cmp	r3, #0
 8026804:	d002      	beq.n	802680c <mp_init_multi+0x32>
        fp_init(c);
 8026806:	6878      	ldr	r0, [r7, #4]
 8026808:	f7ff ff52 	bl	80266b0 <fp_init>
    if (d)
 802680c:	683b      	ldr	r3, [r7, #0]
 802680e:	2b00      	cmp	r3, #0
 8026810:	d002      	beq.n	8026818 <mp_init_multi+0x3e>
        fp_init(d);
 8026812:	6838      	ldr	r0, [r7, #0]
 8026814:	f7ff ff4c 	bl	80266b0 <fp_init>
    if (e)
 8026818:	69bb      	ldr	r3, [r7, #24]
 802681a:	2b00      	cmp	r3, #0
 802681c:	d002      	beq.n	8026824 <mp_init_multi+0x4a>
        fp_init(e);
 802681e:	69b8      	ldr	r0, [r7, #24]
 8026820:	f7ff ff46 	bl	80266b0 <fp_init>
    if (f)
 8026824:	69fb      	ldr	r3, [r7, #28]
 8026826:	2b00      	cmp	r3, #0
 8026828:	d002      	beq.n	8026830 <mp_init_multi+0x56>
        fp_init(f);
 802682a:	69f8      	ldr	r0, [r7, #28]
 802682c:	f7ff ff40 	bl	80266b0 <fp_init>

    return MP_OKAY;
 8026830:	2300      	movs	r3, #0
}
 8026832:	4618      	mov	r0, r3
 8026834:	3710      	adds	r7, #16
 8026836:	46bd      	mov	sp, r7
 8026838:	bd80      	pop	{r7, pc}

0802683a <mp_add>:

/* high level addition (handles signs) */
int mp_add (mp_int * a, mp_int * b, mp_int * c)
{
 802683a:	b580      	push	{r7, lr}
 802683c:	b084      	sub	sp, #16
 802683e:	af00      	add	r7, sp, #0
 8026840:	60f8      	str	r0, [r7, #12]
 8026842:	60b9      	str	r1, [r7, #8]
 8026844:	607a      	str	r2, [r7, #4]
  return fp_add(a, b, c);
 8026846:	687a      	ldr	r2, [r7, #4]
 8026848:	68b9      	ldr	r1, [r7, #8]
 802684a:	68f8      	ldr	r0, [r7, #12]
 802684c:	f7fb fd41 	bl	80222d2 <fp_add>
 8026850:	4603      	mov	r3, r0
}
 8026852:	4618      	mov	r0, r3
 8026854:	3710      	adds	r7, #16
 8026856:	46bd      	mov	sp, r7
 8026858:	bd80      	pop	{r7, pc}

0802685a <mp_sub>:

/* high level subtraction (handles signs) */
int mp_sub (mp_int * a, mp_int * b, mp_int * c)
{
 802685a:	b580      	push	{r7, lr}
 802685c:	b084      	sub	sp, #16
 802685e:	af00      	add	r7, sp, #0
 8026860:	60f8      	str	r0, [r7, #12]
 8026862:	60b9      	str	r1, [r7, #8]
 8026864:	607a      	str	r2, [r7, #4]
  return fp_sub(a, b, c);
 8026866:	687a      	ldr	r2, [r7, #4]
 8026868:	68b9      	ldr	r1, [r7, #8]
 802686a:	68f8      	ldr	r0, [r7, #12]
 802686c:	f7fb fe13 	bl	8022496 <fp_sub>
 8026870:	4603      	mov	r3, r0
}
 8026872:	4618      	mov	r0, r3
 8026874:	3710      	adds	r7, #16
 8026876:	46bd      	mov	sp, r7
 8026878:	bd80      	pop	{r7, pc}

0802687a <mp_mul>:
#if defined(FREESCALE_LTC_TFM)
int wolfcrypt_mp_mul(mp_int * a, mp_int * b, mp_int * c)
#else
int mp_mul (mp_int * a, mp_int * b, mp_int * c)
#endif
{
 802687a:	b580      	push	{r7, lr}
 802687c:	b084      	sub	sp, #16
 802687e:	af00      	add	r7, sp, #0
 8026880:	60f8      	str	r0, [r7, #12]
 8026882:	60b9      	str	r1, [r7, #8]
 8026884:	607a      	str	r2, [r7, #4]
  return fp_mul(a, b, c);
 8026886:	687a      	ldr	r2, [r7, #4]
 8026888:	68b9      	ldr	r1, [r7, #8]
 802688a:	68f8      	ldr	r0, [r7, #12]
 802688c:	f7fb ff07 	bl	802269e <fp_mul>
 8026890:	4603      	mov	r3, r0
}
 8026892:	4618      	mov	r0, r3
 8026894:	3710      	adds	r7, #16
 8026896:	46bd      	mov	sp, r7
 8026898:	bd80      	pop	{r7, pc}

0802689a <mp_mulmod>:
#if defined(FREESCALE_LTC_TFM)
int wolfcrypt_mp_mulmod (mp_int * a, mp_int * b, mp_int * c, mp_int * d)
#else
int mp_mulmod (mp_int * a, mp_int * b, mp_int * c, mp_int * d)
#endif
{
 802689a:	b580      	push	{r7, lr}
 802689c:	b086      	sub	sp, #24
 802689e:	af00      	add	r7, sp, #0
 80268a0:	60f8      	str	r0, [r7, #12]
 80268a2:	60b9      	str	r1, [r7, #8]
 80268a4:	607a      	str	r2, [r7, #4]
 80268a6:	603b      	str	r3, [r7, #0]
   int ret = MP_OKAY;
 80268a8:	2300      	movs	r3, #0
 80268aa:	617b      	str	r3, [r7, #20]
          * Future implementation may consider saving operands,
          * but hard errors should never actually occur. */
         break;
   }
#else /* no HW */
   ret = fp_mulmod(a, b, c, d);
 80268ac:	683b      	ldr	r3, [r7, #0]
 80268ae:	687a      	ldr	r2, [r7, #4]
 80268b0:	68b9      	ldr	r1, [r7, #8]
 80268b2:	68f8      	ldr	r0, [r7, #12]
 80268b4:	f7fd fce9 	bl	802428a <fp_mulmod>
 80268b8:	6178      	str	r0, [r7, #20]
#endif /* WOLFSSL_ESP32_CRYPT_RSA_PRI_MULMOD */
   return ret;
 80268ba:	697b      	ldr	r3, [r7, #20]
}
 80268bc:	4618      	mov	r0, r3
 80268be:	3718      	adds	r7, #24
 80268c0:	46bd      	mov	sp, r7
 80268c2:	bd80      	pop	{r7, pc}

080268c4 <mp_submod_ct>:
  return fp_addmod(a, b, c, d);
}

/* d = a - b (mod c) - constant time (a < c and b < c) */
int mp_submod_ct(mp_int *a, mp_int *b, mp_int *c, mp_int *d)
{
 80268c4:	b580      	push	{r7, lr}
 80268c6:	b084      	sub	sp, #16
 80268c8:	af00      	add	r7, sp, #0
 80268ca:	60f8      	str	r0, [r7, #12]
 80268cc:	60b9      	str	r1, [r7, #8]
 80268ce:	607a      	str	r2, [r7, #4]
 80268d0:	603b      	str	r3, [r7, #0]
  return fp_submod_ct(a, b, c, d);
 80268d2:	683b      	ldr	r3, [r7, #0]
 80268d4:	687a      	ldr	r2, [r7, #4]
 80268d6:	68b9      	ldr	r1, [r7, #8]
 80268d8:	68f8      	ldr	r0, [r7, #12]
 80268da:	f7fd fd16 	bl	802430a <fp_submod_ct>
 80268de:	4603      	mov	r3, r0
}
 80268e0:	4618      	mov	r0, r3
 80268e2:	3710      	adds	r7, #16
 80268e4:	46bd      	mov	sp, r7
 80268e6:	bd80      	pop	{r7, pc}

080268e8 <mp_addmod_ct>:

/* d = a + b (mod c) - constant time (a < c and b < c) */
int mp_addmod_ct(mp_int *a, mp_int *b, mp_int *c, mp_int *d)
{
 80268e8:	b580      	push	{r7, lr}
 80268ea:	b084      	sub	sp, #16
 80268ec:	af00      	add	r7, sp, #0
 80268ee:	60f8      	str	r0, [r7, #12]
 80268f0:	60b9      	str	r1, [r7, #8]
 80268f2:	607a      	str	r2, [r7, #4]
 80268f4:	603b      	str	r3, [r7, #0]
  return fp_addmod_ct(a, b, c, d);
 80268f6:	683b      	ldr	r3, [r7, #0]
 80268f8:	687a      	ldr	r2, [r7, #4]
 80268fa:	68b9      	ldr	r1, [r7, #8]
 80268fc:	68f8      	ldr	r0, [r7, #12]
 80268fe:	f7fd fe20 	bl	8024542 <fp_addmod_ct>
 8026902:	4603      	mov	r3, r0
}
 8026904:	4618      	mov	r0, r3
 8026906:	3710      	adds	r7, #16
 8026908:	46bd      	mov	sp, r7
 802690a:	bd80      	pop	{r7, pc}

0802690c <mp_mod>:
#if defined(FREESCALE_LTC_TFM)
int wolfcrypt_mp_mod (mp_int * a, mp_int * b, mp_int * c)
#else
int mp_mod (mp_int * a, mp_int * b, mp_int * c)
#endif
{
 802690c:	b580      	push	{r7, lr}
 802690e:	b084      	sub	sp, #16
 8026910:	af00      	add	r7, sp, #0
 8026912:	60f8      	str	r0, [r7, #12]
 8026914:	60b9      	str	r1, [r7, #8]
 8026916:	607a      	str	r2, [r7, #4]
  return fp_mod (a, b, c);
 8026918:	687a      	ldr	r2, [r7, #4]
 802691a:	68b9      	ldr	r1, [r7, #8]
 802691c:	68f8      	ldr	r0, [r7, #12]
 802691e:	f7fc fe57 	bl	80235d0 <fp_mod>
 8026922:	4603      	mov	r3, r0
}
 8026924:	4618      	mov	r0, r3
 8026926:	3710      	adds	r7, #16
 8026928:	46bd      	mov	sp, r7
 802692a:	bd80      	pop	{r7, pc}

0802692c <mp_invmod>:
#if defined(FREESCALE_LTC_TFM)
int wolfcrypt_mp_invmod (mp_int * a, mp_int * b, mp_int * c)
#else
int mp_invmod (mp_int * a, mp_int * b, mp_int * c)
#endif
{
 802692c:	b580      	push	{r7, lr}
 802692e:	b084      	sub	sp, #16
 8026930:	af00      	add	r7, sp, #0
 8026932:	60f8      	str	r0, [r7, #12]
 8026934:	60b9      	str	r1, [r7, #8]
 8026936:	607a      	str	r2, [r7, #4]
  return fp_invmod(a, b, c);
 8026938:	687a      	ldr	r2, [r7, #4]
 802693a:	68b9      	ldr	r1, [r7, #8]
 802693c:	68f8      	ldr	r0, [r7, #12]
 802693e:	f7fd f99e 	bl	8023c7e <fp_invmod>
 8026942:	4603      	mov	r3, r0
}
 8026944:	4618      	mov	r0, r3
 8026946:	3710      	adds	r7, #16
 8026948:	46bd      	mov	sp, r7
 802694a:	bd80      	pop	{r7, pc}

0802694c <mp_invmod_mont_ct>:

/* hac 14.61, pp608 */
int mp_invmod_mont_ct (mp_int * a, mp_int * b, mp_int * c, mp_digit mp)
{
 802694c:	b580      	push	{r7, lr}
 802694e:	b084      	sub	sp, #16
 8026950:	af00      	add	r7, sp, #0
 8026952:	60f8      	str	r0, [r7, #12]
 8026954:	60b9      	str	r1, [r7, #8]
 8026956:	607a      	str	r2, [r7, #4]
 8026958:	603b      	str	r3, [r7, #0]
  return fp_invmod_mont_ct(a, b, c, mp);
 802695a:	683b      	ldr	r3, [r7, #0]
 802695c:	687a      	ldr	r2, [r7, #4]
 802695e:	68b9      	ldr	r1, [r7, #8]
 8026960:	68f8      	ldr	r0, [r7, #12]
 8026962:	f7fd fb4f 	bl	8024004 <fp_invmod_mont_ct>
 8026966:	4603      	mov	r3, r0
}
 8026968:	4618      	mov	r0, r3
 802696a:	3710      	adds	r7, #16
 802696c:	46bd      	mov	sp, r7
 802696e:	bd80      	pop	{r7, pc}

08026970 <mp_exptmod>:
#if defined(FREESCALE_LTC_TFM)
int wolfcrypt_mp_exptmod (mp_int * G, mp_int * X, mp_int * P, mp_int * Y)
#else
int mp_exptmod (mp_int * G, mp_int * X, mp_int * P, mp_int * Y)
#endif
{
 8026970:	b580      	push	{r7, lr}
 8026972:	b084      	sub	sp, #16
 8026974:	af00      	add	r7, sp, #0
 8026976:	60f8      	str	r0, [r7, #12]
 8026978:	60b9      	str	r1, [r7, #8]
 802697a:	607a      	str	r2, [r7, #4]
 802697c:	603b      	str	r3, [r7, #0]
  return fp_exptmod(G, X, P, Y);
 802697e:	683b      	ldr	r3, [r7, #0]
 8026980:	687a      	ldr	r2, [r7, #4]
 8026982:	68b9      	ldr	r1, [r7, #8]
 8026984:	68f8      	ldr	r0, [r7, #12]
 8026986:	f7fe fcbf 	bl	8025308 <fp_exptmod>
 802698a:	4603      	mov	r3, r0
}
 802698c:	4618      	mov	r0, r3
 802698e:	3710      	adds	r7, #16
 8026990:	46bd      	mov	sp, r7
 8026992:	bd80      	pop	{r7, pc}

08026994 <mp_exptmod_nct>:
#if defined(FREESCALE_LTC_TFM)
int wolfcrypt_mp_exptmod_nct (mp_int * G, mp_int * X, mp_int * P, mp_int * Y)
#else
int mp_exptmod_nct (mp_int * G, mp_int * X, mp_int * P, mp_int * Y)
#endif
{
 8026994:	b580      	push	{r7, lr}
 8026996:	b084      	sub	sp, #16
 8026998:	af00      	add	r7, sp, #0
 802699a:	60f8      	str	r0, [r7, #12]
 802699c:	60b9      	str	r1, [r7, #8]
 802699e:	607a      	str	r2, [r7, #4]
 80269a0:	603b      	str	r3, [r7, #0]
  return fp_exptmod_nct(G, X, P, Y);
 80269a2:	683b      	ldr	r3, [r7, #0]
 80269a4:	687a      	ldr	r2, [r7, #4]
 80269a6:	68b9      	ldr	r1, [r7, #8]
 80269a8:	68f8      	ldr	r0, [r7, #12]
 80269aa:	f7fe fd60 	bl	802546e <fp_exptmod_nct>
 80269ae:	4603      	mov	r3, r0
}
 80269b0:	4618      	mov	r0, r3
 80269b2:	3710      	adds	r7, #16
 80269b4:	46bd      	mov	sp, r7
 80269b6:	bd80      	pop	{r7, pc}

080269b8 <mp_cmp>:


/* compare two ints (signed)*/
int mp_cmp (mp_int * a, mp_int * b)
{
 80269b8:	b580      	push	{r7, lr}
 80269ba:	b082      	sub	sp, #8
 80269bc:	af00      	add	r7, sp, #0
 80269be:	6078      	str	r0, [r7, #4]
 80269c0:	6039      	str	r1, [r7, #0]
  return fp_cmp(a, b);
 80269c2:	6839      	ldr	r1, [r7, #0]
 80269c4:	6878      	ldr	r0, [r7, #4]
 80269c6:	f7ff f859 	bl	8025a7c <fp_cmp>
 80269ca:	4603      	mov	r3, r0
}
 80269cc:	4618      	mov	r0, r3
 80269ce:	3708      	adds	r7, #8
 80269d0:	46bd      	mov	sp, r7
 80269d2:	bd80      	pop	{r7, pc}

080269d4 <mp_cmp_d>:

/* compare a digit */
int mp_cmp_d(mp_int * a, mp_digit b)
{
 80269d4:	b580      	push	{r7, lr}
 80269d6:	b082      	sub	sp, #8
 80269d8:	af00      	add	r7, sp, #0
 80269da:	6078      	str	r0, [r7, #4]
 80269dc:	6039      	str	r1, [r7, #0]
  return fp_cmp_d(a, b);
 80269de:	6839      	ldr	r1, [r7, #0]
 80269e0:	6878      	ldr	r0, [r7, #4]
 80269e2:	f7ff f878 	bl	8025ad6 <fp_cmp_d>
 80269e6:	4603      	mov	r3, r0
}
 80269e8:	4618      	mov	r0, r3
 80269ea:	3708      	adds	r7, #8
 80269ec:	46bd      	mov	sp, r7
 80269ee:	bd80      	pop	{r7, pc}

080269f0 <mp_unsigned_bin_size>:

/* get the size for an unsigned equivalent */
int mp_unsigned_bin_size (const mp_int * a)
{
 80269f0:	b580      	push	{r7, lr}
 80269f2:	b082      	sub	sp, #8
 80269f4:	af00      	add	r7, sp, #0
 80269f6:	6078      	str	r0, [r7, #4]
  return fp_unsigned_bin_size(a);
 80269f8:	6878      	ldr	r0, [r7, #4]
 80269fa:	f7ff fc0f 	bl	802621c <fp_unsigned_bin_size>
 80269fe:	4603      	mov	r3, r0
}
 8026a00:	4618      	mov	r0, r3
 8026a02:	3708      	adds	r7, #8
 8026a04:	46bd      	mov	sp, r7
 8026a06:	bd80      	pop	{r7, pc}

08026a08 <mp_to_unsigned_bin>:
  return fp_to_unsigned_bin_at_pos(x, t, b);
}

/* store in unsigned [big endian] format */
int mp_to_unsigned_bin (mp_int * a, unsigned char *b)
{
 8026a08:	b580      	push	{r7, lr}
 8026a0a:	b082      	sub	sp, #8
 8026a0c:	af00      	add	r7, sp, #0
 8026a0e:	6078      	str	r0, [r7, #4]
 8026a10:	6039      	str	r1, [r7, #0]
  return fp_to_unsigned_bin(a,b);
 8026a12:	6839      	ldr	r1, [r7, #0]
 8026a14:	6878      	ldr	r0, [r7, #4]
 8026a16:	f7ff fb6e 	bl	80260f6 <fp_to_unsigned_bin>
 8026a1a:	4603      	mov	r3, r0
}
 8026a1c:	4618      	mov	r0, r3
 8026a1e:	3708      	adds	r7, #8
 8026a20:	46bd      	mov	sp, r7
 8026a22:	bd80      	pop	{r7, pc}

08026a24 <mp_to_unsigned_bin_len>:

int mp_to_unsigned_bin_len(mp_int * a, unsigned char *b, int c)
{
 8026a24:	b580      	push	{r7, lr}
 8026a26:	b084      	sub	sp, #16
 8026a28:	af00      	add	r7, sp, #0
 8026a2a:	60f8      	str	r0, [r7, #12]
 8026a2c:	60b9      	str	r1, [r7, #8]
 8026a2e:	607a      	str	r2, [r7, #4]
  return fp_to_unsigned_bin_len(a, b, c);
 8026a30:	687a      	ldr	r2, [r7, #4]
 8026a32:	68b9      	ldr	r1, [r7, #8]
 8026a34:	68f8      	ldr	r0, [r7, #12]
 8026a36:	f7ff fb89 	bl	802614c <fp_to_unsigned_bin_len>
 8026a3a:	4603      	mov	r3, r0
}
 8026a3c:	4618      	mov	r0, r3
 8026a3e:	3710      	adds	r7, #16
 8026a40:	46bd      	mov	sp, r7
 8026a42:	bd80      	pop	{r7, pc}

08026a44 <mp_read_unsigned_bin>:
/* reads a unsigned char array, assumes the msb is stored first [big endian] */
int mp_read_unsigned_bin (mp_int * a, const unsigned char *b, int c)
{
 8026a44:	b580      	push	{r7, lr}
 8026a46:	b084      	sub	sp, #16
 8026a48:	af00      	add	r7, sp, #0
 8026a4a:	60f8      	str	r0, [r7, #12]
 8026a4c:	60b9      	str	r1, [r7, #8]
 8026a4e:	607a      	str	r2, [r7, #4]
  return fp_read_unsigned_bin(a, b, c);
 8026a50:	687a      	ldr	r2, [r7, #4]
 8026a52:	68b9      	ldr	r1, [r7, #8]
 8026a54:	68f8      	ldr	r0, [r7, #12]
 8026a56:	f7ff fa97 	bl	8025f88 <fp_read_unsigned_bin>
 8026a5a:	4603      	mov	r3, r0
}
 8026a5c:	4618      	mov	r0, r3
 8026a5e:	3710      	adds	r7, #16
 8026a60:	46bd      	mov	sp, r7
 8026a62:	bd80      	pop	{r7, pc}

08026a64 <mp_sub_d>:


int mp_sub_d(fp_int *a, fp_digit b, fp_int *c)
{
 8026a64:	b580      	push	{r7, lr}
 8026a66:	b084      	sub	sp, #16
 8026a68:	af00      	add	r7, sp, #0
 8026a6a:	60f8      	str	r0, [r7, #12]
 8026a6c:	60b9      	str	r1, [r7, #8]
 8026a6e:	607a      	str	r2, [r7, #4]
  return fp_sub_d(a, b, c);
 8026a70:	687a      	ldr	r2, [r7, #4]
 8026a72:	68b9      	ldr	r1, [r7, #8]
 8026a74:	68f8      	ldr	r0, [r7, #12]
 8026a76:	f7ff fdd0 	bl	802661a <fp_sub_d>
 8026a7a:	4603      	mov	r3, r0
}
 8026a7c:	4618      	mov	r0, r3
 8026a7e:	3710      	adds	r7, #16
 8026a80:	46bd      	mov	sp, r7
 8026a82:	bd80      	pop	{r7, pc}

08026a84 <fp_copy>:
  return MP_OKAY;
}

/* copy (src = a) to (dst = b) */
void fp_copy(const fp_int *a, fp_int *b)
{
 8026a84:	b580      	push	{r7, lr}
 8026a86:	b084      	sub	sp, #16
 8026a88:	af00      	add	r7, sp, #0
 8026a8a:	6078      	str	r0, [r7, #4]
 8026a8c:	6039      	str	r1, [r7, #0]
    /* if source and destination are different */
    if (a != b) {
 8026a8e:	687a      	ldr	r2, [r7, #4]
 8026a90:	683b      	ldr	r3, [r7, #0]
 8026a92:	429a      	cmp	r2, r3
 8026a94:	d031      	beq.n	8026afa <fp_copy+0x76>
#if defined(ALT_ECC_SIZE) || defined(HAVE_WOLF_BIGINT)
        /* verify a will fit in b */
        if (b->size >= a->used) {
 8026a96:	683b      	ldr	r3, [r7, #0]
 8026a98:	689a      	ldr	r2, [r3, #8]
 8026a9a:	687b      	ldr	r3, [r7, #4]
 8026a9c:	681b      	ldr	r3, [r3, #0]
 8026a9e:	429a      	cmp	r2, r3
 8026aa0:	db2b      	blt.n	8026afa <fp_copy+0x76>
            int x, oldused;
            oldused = b->used;
 8026aa2:	683b      	ldr	r3, [r7, #0]
 8026aa4:	681b      	ldr	r3, [r3, #0]
 8026aa6:	60bb      	str	r3, [r7, #8]
            b->used = a->used;
 8026aa8:	687b      	ldr	r3, [r7, #4]
 8026aaa:	681a      	ldr	r2, [r3, #0]
 8026aac:	683b      	ldr	r3, [r7, #0]
 8026aae:	601a      	str	r2, [r3, #0]
            b->sign = a->sign;
 8026ab0:	687b      	ldr	r3, [r7, #4]
 8026ab2:	685a      	ldr	r2, [r3, #4]
 8026ab4:	683b      	ldr	r3, [r7, #0]
 8026ab6:	605a      	str	r2, [r3, #4]

            XMEMCPY(b->dp, a->dp, a->used * sizeof(fp_digit));
 8026ab8:	683b      	ldr	r3, [r7, #0]
 8026aba:	f103 000c 	add.w	r0, r3, #12
 8026abe:	687b      	ldr	r3, [r7, #4]
 8026ac0:	f103 010c 	add.w	r1, r3, #12
 8026ac4:	687b      	ldr	r3, [r7, #4]
 8026ac6:	681b      	ldr	r3, [r3, #0]
 8026ac8:	009b      	lsls	r3, r3, #2
 8026aca:	461a      	mov	r2, r3
 8026acc:	f001 fd66 	bl	802859c <memcpy>

            /* zero any excess digits on the destination that we didn't write to */
            for (x = b->used; x >= 0 && x < oldused; x++) {
 8026ad0:	683b      	ldr	r3, [r7, #0]
 8026ad2:	681b      	ldr	r3, [r3, #0]
 8026ad4:	60fb      	str	r3, [r7, #12]
 8026ad6:	e009      	b.n	8026aec <fp_copy+0x68>
                b->dp[x] = 0;
 8026ad8:	683a      	ldr	r2, [r7, #0]
 8026ada:	68fb      	ldr	r3, [r7, #12]
 8026adc:	3302      	adds	r3, #2
 8026ade:	009b      	lsls	r3, r3, #2
 8026ae0:	4413      	add	r3, r2
 8026ae2:	2200      	movs	r2, #0
 8026ae4:	605a      	str	r2, [r3, #4]
            for (x = b->used; x >= 0 && x < oldused; x++) {
 8026ae6:	68fb      	ldr	r3, [r7, #12]
 8026ae8:	3301      	adds	r3, #1
 8026aea:	60fb      	str	r3, [r7, #12]
 8026aec:	68fb      	ldr	r3, [r7, #12]
 8026aee:	2b00      	cmp	r3, #0
 8026af0:	db03      	blt.n	8026afa <fp_copy+0x76>
 8026af2:	68fa      	ldr	r2, [r7, #12]
 8026af4:	68bb      	ldr	r3, [r7, #8]
 8026af6:	429a      	cmp	r2, r3
 8026af8:	dbee      	blt.n	8026ad8 <fp_copy+0x54>
        b->used = a->used;
        b->sign = a->sign;
        XMEMCPY(b->dp, a->dp, FP_SIZE * sizeof(fp_digit));
#endif
    }
}
 8026afa:	bf00      	nop
 8026afc:	3710      	adds	r7, #16
 8026afe:	46bd      	mov	sp, r7
 8026b00:	bd80      	pop	{r7, pc}

08026b02 <fp_init_copy>:
    return MP_OKAY;
}

/* Copy (dst = a) from (src = b) */
void fp_init_copy(fp_int *a, fp_int* b)
{
 8026b02:	b580      	push	{r7, lr}
 8026b04:	b082      	sub	sp, #8
 8026b06:	af00      	add	r7, sp, #0
 8026b08:	6078      	str	r0, [r7, #4]
 8026b0a:	6039      	str	r1, [r7, #0]
    if (a != b) {
 8026b0c:	687a      	ldr	r2, [r7, #4]
 8026b0e:	683b      	ldr	r3, [r7, #0]
 8026b10:	429a      	cmp	r2, r3
 8026b12:	d006      	beq.n	8026b22 <fp_init_copy+0x20>
        fp_init(a);
 8026b14:	6878      	ldr	r0, [r7, #4]
 8026b16:	f7ff fdcb 	bl	80266b0 <fp_init>
        /* Note reversed parameter order! */
        fp_copy(b, a); /* copy (src = b) to (dst = a) */
 8026b1a:	6879      	ldr	r1, [r7, #4]
 8026b1c:	6838      	ldr	r0, [r7, #0]
 8026b1e:	f7ff ffb1 	bl	8026a84 <fp_copy>
    }
}
 8026b22:	bf00      	nop
 8026b24:	3708      	adds	r7, #8
 8026b26:	46bd      	mov	sp, r7
 8026b28:	bd80      	pop	{r7, pc}

08026b2a <mp_copy>:

/* fast math wrappers */
int mp_copy(const fp_int* a, fp_int* b)
{
 8026b2a:	b580      	push	{r7, lr}
 8026b2c:	b082      	sub	sp, #8
 8026b2e:	af00      	add	r7, sp, #0
 8026b30:	6078      	str	r0, [r7, #4]
 8026b32:	6039      	str	r1, [r7, #0]
    fp_copy(a, b);
 8026b34:	6839      	ldr	r1, [r7, #0]
 8026b36:	6878      	ldr	r0, [r7, #4]
 8026b38:	f7ff ffa4 	bl	8026a84 <fp_copy>
    return MP_OKAY;
 8026b3c:	2300      	movs	r3, #0
}
 8026b3e:	4618      	mov	r0, r3
 8026b40:	3708      	adds	r7, #8
 8026b42:	46bd      	mov	sp, r7
 8026b44:	bd80      	pop	{r7, pc}

08026b46 <mp_iszero>:
{
    return fp_isodd(a);
}

int mp_iszero(const mp_int* a)
{
 8026b46:	b480      	push	{r7}
 8026b48:	b083      	sub	sp, #12
 8026b4a:	af00      	add	r7, sp, #0
 8026b4c:	6078      	str	r0, [r7, #4]
    return fp_iszero(a);
 8026b4e:	687b      	ldr	r3, [r7, #4]
 8026b50:	681b      	ldr	r3, [r3, #0]
 8026b52:	2b00      	cmp	r3, #0
 8026b54:	bf0c      	ite	eq
 8026b56:	2301      	moveq	r3, #1
 8026b58:	2300      	movne	r3, #0
 8026b5a:	b2db      	uxtb	r3, r3
}
 8026b5c:	4618      	mov	r0, r3
 8026b5e:	370c      	adds	r7, #12
 8026b60:	46bd      	mov	sp, r7
 8026b62:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026b66:	4770      	bx	lr

08026b68 <mp_count_bits>:

int mp_count_bits (const mp_int* a)
{
 8026b68:	b580      	push	{r7, lr}
 8026b6a:	b082      	sub	sp, #8
 8026b6c:	af00      	add	r7, sp, #0
 8026b6e:	6078      	str	r0, [r7, #4]
    return fp_count_bits(a);
 8026b70:	6878      	ldr	r0, [r7, #4]
 8026b72:	f7ff fbb1 	bl	80262d8 <fp_count_bits>
 8026b76:	4603      	mov	r3, r0
}
 8026b78:	4618      	mov	r0, r3
 8026b7a:	3708      	adds	r7, #8
 8026b7c:	46bd      	mov	sp, r7
 8026b7e:	bd80      	pop	{r7, pc}

08026b80 <mp_leading_bit>:

int mp_leading_bit (mp_int* a)
{
 8026b80:	b580      	push	{r7, lr}
 8026b82:	b082      	sub	sp, #8
 8026b84:	af00      	add	r7, sp, #0
 8026b86:	6078      	str	r0, [r7, #4]
    return fp_leading_bit(a);
 8026b88:	6878      	ldr	r0, [r7, #4]
 8026b8a:	f7ff fbce 	bl	802632a <fp_leading_bit>
 8026b8e:	4603      	mov	r3, r0
}
 8026b90:	4618      	mov	r0, r3
 8026b92:	3708      	adds	r7, #8
 8026b94:	46bd      	mov	sp, r7
 8026b96:	bd80      	pop	{r7, pc}

08026b98 <mp_rshb>:

void mp_rshb (mp_int* a, int x)
{
 8026b98:	b580      	push	{r7, lr}
 8026b9a:	b082      	sub	sp, #8
 8026b9c:	af00      	add	r7, sp, #0
 8026b9e:	6078      	str	r0, [r7, #4]
 8026ba0:	6039      	str	r1, [r7, #0]
    fp_rshb(a, x);
 8026ba2:	6839      	ldr	r1, [r7, #0]
 8026ba4:	6878      	ldr	r0, [r7, #4]
 8026ba6:	f7ff fc54 	bl	8026452 <fp_rshb>
}
 8026baa:	bf00      	nop
 8026bac:	3708      	adds	r7, #8
 8026bae:	46bd      	mov	sp, r7
 8026bb0:	bd80      	pop	{r7, pc}

08026bb2 <mp_montgomery_calc_normalization>:
    return fp_sqrmod(a, b, c);
}

/* fast math conversion */
int mp_montgomery_calc_normalization(mp_int *a, mp_int *b)
{
 8026bb2:	b580      	push	{r7, lr}
 8026bb4:	b082      	sub	sp, #8
 8026bb6:	af00      	add	r7, sp, #0
 8026bb8:	6078      	str	r0, [r7, #4]
 8026bba:	6039      	str	r1, [r7, #0]
    return fp_montgomery_calc_normalization(a, b);
 8026bbc:	6839      	ldr	r1, [r7, #0]
 8026bbe:	6878      	ldr	r0, [r7, #4]
 8026bc0:	f7ff f84b 	bl	8025c5a <fp_montgomery_calc_normalization>
 8026bc4:	4603      	mov	r3, r0
}
 8026bc6:	4618      	mov	r0, r3
 8026bc8:	3708      	adds	r7, #8
 8026bca:	46bd      	mov	sp, r7
 8026bcc:	bd80      	pop	{r7, pc}

08026bce <fp_cond_swap_ct_ex>:

#endif /* WOLFSSL_KEY_GEN || HAVE_ECC */

static int fp_cond_swap_ct_ex(mp_int* a, mp_int* b, int c, int m, mp_int* t)
{
 8026bce:	b480      	push	{r7}
 8026bd0:	b087      	sub	sp, #28
 8026bd2:	af00      	add	r7, sp, #0
 8026bd4:	60f8      	str	r0, [r7, #12]
 8026bd6:	60b9      	str	r1, [r7, #8]
 8026bd8:	607a      	str	r2, [r7, #4]
 8026bda:	603b      	str	r3, [r7, #0]
    int i;
    mp_digit mask = (mp_digit)0 - m;
 8026bdc:	683b      	ldr	r3, [r7, #0]
 8026bde:	425b      	negs	r3, r3
 8026be0:	613b      	str	r3, [r7, #16]

    t->used = (a->used ^ b->used) & mask;
 8026be2:	68fb      	ldr	r3, [r7, #12]
 8026be4:	681a      	ldr	r2, [r3, #0]
 8026be6:	68bb      	ldr	r3, [r7, #8]
 8026be8:	681b      	ldr	r3, [r3, #0]
 8026bea:	4053      	eors	r3, r2
 8026bec:	461a      	mov	r2, r3
 8026bee:	693b      	ldr	r3, [r7, #16]
 8026bf0:	4013      	ands	r3, r2
 8026bf2:	461a      	mov	r2, r3
 8026bf4:	6a3b      	ldr	r3, [r7, #32]
 8026bf6:	601a      	str	r2, [r3, #0]
    for (i = 0; i < c; i++) {
 8026bf8:	2300      	movs	r3, #0
 8026bfa:	617b      	str	r3, [r7, #20]
 8026bfc:	e017      	b.n	8026c2e <fp_cond_swap_ct_ex+0x60>
        t->dp[i] = (a->dp[i] ^ b->dp[i]) & mask;
 8026bfe:	68fa      	ldr	r2, [r7, #12]
 8026c00:	697b      	ldr	r3, [r7, #20]
 8026c02:	3302      	adds	r3, #2
 8026c04:	009b      	lsls	r3, r3, #2
 8026c06:	4413      	add	r3, r2
 8026c08:	685a      	ldr	r2, [r3, #4]
 8026c0a:	68b9      	ldr	r1, [r7, #8]
 8026c0c:	697b      	ldr	r3, [r7, #20]
 8026c0e:	3302      	adds	r3, #2
 8026c10:	009b      	lsls	r3, r3, #2
 8026c12:	440b      	add	r3, r1
 8026c14:	685b      	ldr	r3, [r3, #4]
 8026c16:	405a      	eors	r2, r3
 8026c18:	693b      	ldr	r3, [r7, #16]
 8026c1a:	401a      	ands	r2, r3
 8026c1c:	6a39      	ldr	r1, [r7, #32]
 8026c1e:	697b      	ldr	r3, [r7, #20]
 8026c20:	3302      	adds	r3, #2
 8026c22:	009b      	lsls	r3, r3, #2
 8026c24:	440b      	add	r3, r1
 8026c26:	605a      	str	r2, [r3, #4]
    for (i = 0; i < c; i++) {
 8026c28:	697b      	ldr	r3, [r7, #20]
 8026c2a:	3301      	adds	r3, #1
 8026c2c:	617b      	str	r3, [r7, #20]
 8026c2e:	697a      	ldr	r2, [r7, #20]
 8026c30:	687b      	ldr	r3, [r7, #4]
 8026c32:	429a      	cmp	r2, r3
 8026c34:	dbe3      	blt.n	8026bfe <fp_cond_swap_ct_ex+0x30>
    }
    a->used ^= t->used;
 8026c36:	68fb      	ldr	r3, [r7, #12]
 8026c38:	681a      	ldr	r2, [r3, #0]
 8026c3a:	6a3b      	ldr	r3, [r7, #32]
 8026c3c:	681b      	ldr	r3, [r3, #0]
 8026c3e:	405a      	eors	r2, r3
 8026c40:	68fb      	ldr	r3, [r7, #12]
 8026c42:	601a      	str	r2, [r3, #0]
    for (i = 0; i < c; i++) {
 8026c44:	2300      	movs	r3, #0
 8026c46:	617b      	str	r3, [r7, #20]
 8026c48:	e015      	b.n	8026c76 <fp_cond_swap_ct_ex+0xa8>
        a->dp[i] ^= t->dp[i];
 8026c4a:	68fa      	ldr	r2, [r7, #12]
 8026c4c:	697b      	ldr	r3, [r7, #20]
 8026c4e:	3302      	adds	r3, #2
 8026c50:	009b      	lsls	r3, r3, #2
 8026c52:	4413      	add	r3, r2
 8026c54:	685a      	ldr	r2, [r3, #4]
 8026c56:	6a39      	ldr	r1, [r7, #32]
 8026c58:	697b      	ldr	r3, [r7, #20]
 8026c5a:	3302      	adds	r3, #2
 8026c5c:	009b      	lsls	r3, r3, #2
 8026c5e:	440b      	add	r3, r1
 8026c60:	685b      	ldr	r3, [r3, #4]
 8026c62:	405a      	eors	r2, r3
 8026c64:	68f9      	ldr	r1, [r7, #12]
 8026c66:	697b      	ldr	r3, [r7, #20]
 8026c68:	3302      	adds	r3, #2
 8026c6a:	009b      	lsls	r3, r3, #2
 8026c6c:	440b      	add	r3, r1
 8026c6e:	605a      	str	r2, [r3, #4]
    for (i = 0; i < c; i++) {
 8026c70:	697b      	ldr	r3, [r7, #20]
 8026c72:	3301      	adds	r3, #1
 8026c74:	617b      	str	r3, [r7, #20]
 8026c76:	697a      	ldr	r2, [r7, #20]
 8026c78:	687b      	ldr	r3, [r7, #4]
 8026c7a:	429a      	cmp	r2, r3
 8026c7c:	dbe5      	blt.n	8026c4a <fp_cond_swap_ct_ex+0x7c>
    }
    b->used ^= t->used;
 8026c7e:	68bb      	ldr	r3, [r7, #8]
 8026c80:	681a      	ldr	r2, [r3, #0]
 8026c82:	6a3b      	ldr	r3, [r7, #32]
 8026c84:	681b      	ldr	r3, [r3, #0]
 8026c86:	405a      	eors	r2, r3
 8026c88:	68bb      	ldr	r3, [r7, #8]
 8026c8a:	601a      	str	r2, [r3, #0]
    for (i = 0; i < c; i++) {
 8026c8c:	2300      	movs	r3, #0
 8026c8e:	617b      	str	r3, [r7, #20]
 8026c90:	e015      	b.n	8026cbe <fp_cond_swap_ct_ex+0xf0>
        b->dp[i] ^= t->dp[i];
 8026c92:	68ba      	ldr	r2, [r7, #8]
 8026c94:	697b      	ldr	r3, [r7, #20]
 8026c96:	3302      	adds	r3, #2
 8026c98:	009b      	lsls	r3, r3, #2
 8026c9a:	4413      	add	r3, r2
 8026c9c:	685a      	ldr	r2, [r3, #4]
 8026c9e:	6a39      	ldr	r1, [r7, #32]
 8026ca0:	697b      	ldr	r3, [r7, #20]
 8026ca2:	3302      	adds	r3, #2
 8026ca4:	009b      	lsls	r3, r3, #2
 8026ca6:	440b      	add	r3, r1
 8026ca8:	685b      	ldr	r3, [r3, #4]
 8026caa:	405a      	eors	r2, r3
 8026cac:	68b9      	ldr	r1, [r7, #8]
 8026cae:	697b      	ldr	r3, [r7, #20]
 8026cb0:	3302      	adds	r3, #2
 8026cb2:	009b      	lsls	r3, r3, #2
 8026cb4:	440b      	add	r3, r1
 8026cb6:	605a      	str	r2, [r3, #4]
    for (i = 0; i < c; i++) {
 8026cb8:	697b      	ldr	r3, [r7, #20]
 8026cba:	3301      	adds	r3, #1
 8026cbc:	617b      	str	r3, [r7, #20]
 8026cbe:	697a      	ldr	r2, [r7, #20]
 8026cc0:	687b      	ldr	r3, [r7, #4]
 8026cc2:	429a      	cmp	r2, r3
 8026cc4:	dbe5      	blt.n	8026c92 <fp_cond_swap_ct_ex+0xc4>
    }

    return FP_OKAY;
 8026cc6:	2300      	movs	r3, #0
}
 8026cc8:	4618      	mov	r0, r3
 8026cca:	371c      	adds	r7, #28
 8026ccc:	46bd      	mov	sp, r7
 8026cce:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026cd2:	4770      	bx	lr

08026cd4 <mp_cond_swap_ct_ex>:
}
#endif /* !NO_RSA || !NO_DSA || !NO_DH || WOLFSSL_KEY_GEN */


int mp_cond_swap_ct_ex(mp_int* a, mp_int* b, int c, int m, mp_int* t)
{
 8026cd4:	b580      	push	{r7, lr}
 8026cd6:	b086      	sub	sp, #24
 8026cd8:	af02      	add	r7, sp, #8
 8026cda:	60f8      	str	r0, [r7, #12]
 8026cdc:	60b9      	str	r1, [r7, #8]
 8026cde:	607a      	str	r2, [r7, #4]
 8026ce0:	603b      	str	r3, [r7, #0]
    return fp_cond_swap_ct_ex(a, b, c, m, t);
 8026ce2:	69bb      	ldr	r3, [r7, #24]
 8026ce4:	9300      	str	r3, [sp, #0]
 8026ce6:	683b      	ldr	r3, [r7, #0]
 8026ce8:	687a      	ldr	r2, [r7, #4]
 8026cea:	68b9      	ldr	r1, [r7, #8]
 8026cec:	68f8      	ldr	r0, [r7, #12]
 8026cee:	f7ff ff6e 	bl	8026bce <fp_cond_swap_ct_ex>
 8026cf2:	4603      	mov	r3, r0
}
 8026cf4:	4618      	mov	r0, r3
 8026cf6:	3710      	adds	r7, #16
 8026cf8:	46bd      	mov	sp, r7
 8026cfa:	bd80      	pop	{r7, pc}

08026cfc <fp_add_d>:
#if defined(HAVE_ECC) || !defined(NO_PWDBASED) || defined(OPENSSL_EXTRA) || \
    defined(WC_RSA_BLINDING) || !defined(NO_DSA) || \
    (!defined(NO_RSA) && !defined(NO_RSA_BOUNDS_CHECK))
/* c = a + b */
int fp_add_d(fp_int *a, fp_digit b, fp_int *c)
{
 8026cfc:	b580      	push	{r7, lr}
 8026cfe:	b088      	sub	sp, #32
 8026d00:	af00      	add	r7, sp, #0
 8026d02:	60f8      	str	r0, [r7, #12]
 8026d04:	60b9      	str	r1, [r7, #8]
 8026d06:	607a      	str	r2, [r7, #4]
   fp_int* tmp;
#endif
   int     err;

#ifdef WOLFSSL_SMALL_STACK
   tmp = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
 8026d08:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 8026d0c:	f7f7 febc 	bl	801ea88 <wolfSSL_Malloc>
 8026d10:	61f8      	str	r0, [r7, #28]
   if (tmp == NULL)
 8026d12:	69fb      	ldr	r3, [r7, #28]
 8026d14:	2b00      	cmp	r3, #0
 8026d16:	d102      	bne.n	8026d1e <fp_add_d+0x22>
       return FP_MEM;
 8026d18:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 8026d1c:	e015      	b.n	8026d4a <fp_add_d+0x4e>
#endif

   fp_init(tmp);
 8026d1e:	69f8      	ldr	r0, [r7, #28]
 8026d20:	f7ff fcc6 	bl	80266b0 <fp_init>
   fp_set(tmp, b);
 8026d24:	68b9      	ldr	r1, [r7, #8]
 8026d26:	69f8      	ldr	r0, [r7, #28]
 8026d28:	f7ff fa93 	bl	8026252 <fp_set>
   err = fp_add(a, tmp, c);
 8026d2c:	687a      	ldr	r2, [r7, #4]
 8026d2e:	69f9      	ldr	r1, [r7, #28]
 8026d30:	68f8      	ldr	r0, [r7, #12]
 8026d32:	f7fb face 	bl	80222d2 <fp_add>
 8026d36:	61b8      	str	r0, [r7, #24]

#ifdef WOLFSSL_SMALL_STACK
   XFREE(tmp, NULL, DYNAMIC_TYPE_BIGINT);
 8026d38:	69fb      	ldr	r3, [r7, #28]
 8026d3a:	617b      	str	r3, [r7, #20]
 8026d3c:	697b      	ldr	r3, [r7, #20]
 8026d3e:	2b00      	cmp	r3, #0
 8026d40:	d002      	beq.n	8026d48 <fp_add_d+0x4c>
 8026d42:	6978      	ldr	r0, [r7, #20]
 8026d44:	f7f7 febc 	bl	801eac0 <wolfSSL_Free>
#endif
   return err;
 8026d48:	69bb      	ldr	r3, [r7, #24]
}
 8026d4a:	4618      	mov	r0, r3
 8026d4c:	3720      	adds	r7, #32
 8026d4e:	46bd      	mov	sp, r7
 8026d50:	bd80      	pop	{r7, pc}

08026d52 <mp_add_d>:

/* external compatibility */
int mp_add_d(fp_int *a, fp_digit b, fp_int *c)
{
 8026d52:	b580      	push	{r7, lr}
 8026d54:	b084      	sub	sp, #16
 8026d56:	af00      	add	r7, sp, #0
 8026d58:	60f8      	str	r0, [r7, #12]
 8026d5a:	60b9      	str	r1, [r7, #8]
 8026d5c:	607a      	str	r2, [r7, #4]
    return fp_add_d(a, b, c);
 8026d5e:	687a      	ldr	r2, [r7, #4]
 8026d60:	68b9      	ldr	r1, [r7, #8]
 8026d62:	68f8      	ldr	r0, [r7, #12]
 8026d64:	f7ff ffca 	bl	8026cfc <fp_add_d>
 8026d68:	4603      	mov	r3, r0
}
 8026d6a:	4618      	mov	r0, r3
 8026d6c:	3710      	adds	r7, #16
 8026d6e:	46bd      	mov	sp, r7
 8026d70:	bd80      	pop	{r7, pc}

08026d72 <fp_read_radix_16>:
#endif

#if defined(OPENSSL_EXTRA) || !defined(NO_DSA) || defined(HAVE_ECC)
#if DIGIT_BIT == 64 || DIGIT_BIT == 32
static int fp_read_radix_16(fp_int *a, const char *str)
{
 8026d72:	b580      	push	{r7, lr}
 8026d74:	b088      	sub	sp, #32
 8026d76:	af00      	add	r7, sp, #0
 8026d78:	6078      	str	r0, [r7, #4]
 8026d7a:	6039      	str	r1, [r7, #0]
  int     i, j, k, neg;
  int     ch;
  /* Skip whitespace at end of line */
  int     eol_done = 0;
 8026d7c:	2300      	movs	r3, #0
 8026d7e:	60fb      	str	r3, [r7, #12]

  /* if the leading digit is a
   * minus set the sign to negative.
   */
  if (*str == '-') {
 8026d80:	683b      	ldr	r3, [r7, #0]
 8026d82:	781b      	ldrb	r3, [r3, #0]
 8026d84:	2b2d      	cmp	r3, #45	@ 0x2d
 8026d86:	d105      	bne.n	8026d94 <fp_read_radix_16+0x22>
    ++str;
 8026d88:	683b      	ldr	r3, [r7, #0]
 8026d8a:	3301      	adds	r3, #1
 8026d8c:	603b      	str	r3, [r7, #0]
    neg = FP_NEG;
 8026d8e:	2301      	movs	r3, #1
 8026d90:	613b      	str	r3, [r7, #16]
 8026d92:	e001      	b.n	8026d98 <fp_read_radix_16+0x26>
  } else {
    neg = FP_ZPOS;
 8026d94:	2300      	movs	r3, #0
 8026d96:	613b      	str	r3, [r7, #16]
  }

  j = 0;
 8026d98:	2300      	movs	r3, #0
 8026d9a:	61bb      	str	r3, [r7, #24]
  k = 0;
 8026d9c:	2300      	movs	r3, #0
 8026d9e:	617b      	str	r3, [r7, #20]
  for (i = (int)(XSTRLEN(str) - 1); i >= 0; i--) {
 8026da0:	6838      	ldr	r0, [r7, #0]
 8026da2:	f7d9 fa1f 	bl	80001e4 <strlen>
 8026da6:	4603      	mov	r3, r0
 8026da8:	3b01      	subs	r3, #1
 8026daa:	61fb      	str	r3, [r7, #28]
 8026dac:	e04a      	b.n	8026e44 <fp_read_radix_16+0xd2>
      ch = (int)HexCharToByte(str[i]);
 8026dae:	69fb      	ldr	r3, [r7, #28]
 8026db0:	683a      	ldr	r2, [r7, #0]
 8026db2:	4413      	add	r3, r2
 8026db4:	781b      	ldrb	r3, [r3, #0]
 8026db6:	4618      	mov	r0, r3
 8026db8:	f7fb fa3d 	bl	8022236 <HexCharToByte>
 8026dbc:	4603      	mov	r3, r0
 8026dbe:	60bb      	str	r3, [r7, #8]
      if (ch < 0) {
 8026dc0:	68bb      	ldr	r3, [r7, #8]
 8026dc2:	2b00      	cmp	r3, #0
 8026dc4:	da0f      	bge.n	8026de6 <fp_read_radix_16+0x74>
        if (!eol_done && CharIsWhiteSpace(str[i]))
 8026dc6:	68fb      	ldr	r3, [r7, #12]
 8026dc8:	2b00      	cmp	r3, #0
 8026dca:	d109      	bne.n	8026de0 <fp_read_radix_16+0x6e>
 8026dcc:	69fb      	ldr	r3, [r7, #28]
 8026dce:	683a      	ldr	r2, [r7, #0]
 8026dd0:	4413      	add	r3, r2
 8026dd2:	781b      	ldrb	r3, [r3, #0]
 8026dd4:	4618      	mov	r0, r3
 8026dd6:	f7fb fa66 	bl	80222a6 <CharIsWhiteSpace>
 8026dda:	4603      	mov	r3, r0
 8026ddc:	2b00      	cmp	r3, #0
 8026dde:	d12d      	bne.n	8026e3c <fp_read_radix_16+0xca>
          continue;
        return FP_VAL;
 8026de0:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8026de4:	e05b      	b.n	8026e9e <fp_read_radix_16+0x12c>
      }
      eol_done = 1;
 8026de6:	2301      	movs	r3, #1
 8026de8:	60fb      	str	r3, [r7, #12]

      k += j == DIGIT_BIT;
 8026dea:	69bb      	ldr	r3, [r7, #24]
 8026dec:	2b20      	cmp	r3, #32
 8026dee:	bf0c      	ite	eq
 8026df0:	2301      	moveq	r3, #1
 8026df2:	2300      	movne	r3, #0
 8026df4:	b2db      	uxtb	r3, r3
 8026df6:	461a      	mov	r2, r3
 8026df8:	697b      	ldr	r3, [r7, #20]
 8026dfa:	4413      	add	r3, r2
 8026dfc:	617b      	str	r3, [r7, #20]
      j &= DIGIT_BIT - 1;
 8026dfe:	69bb      	ldr	r3, [r7, #24]
 8026e00:	f003 031f 	and.w	r3, r3, #31
 8026e04:	61bb      	str	r3, [r7, #24]
      if (k >= FP_SIZE)
 8026e06:	697b      	ldr	r3, [r7, #20]
 8026e08:	2b87      	cmp	r3, #135	@ 0x87
 8026e0a:	dd02      	ble.n	8026e12 <fp_read_radix_16+0xa0>
          return FP_VAL;
 8026e0c:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8026e10:	e045      	b.n	8026e9e <fp_read_radix_16+0x12c>

      a->dp[k] |= ((fp_digit)ch) << j;
 8026e12:	687a      	ldr	r2, [r7, #4]
 8026e14:	697b      	ldr	r3, [r7, #20]
 8026e16:	3302      	adds	r3, #2
 8026e18:	009b      	lsls	r3, r3, #2
 8026e1a:	4413      	add	r3, r2
 8026e1c:	685a      	ldr	r2, [r3, #4]
 8026e1e:	68b9      	ldr	r1, [r7, #8]
 8026e20:	69bb      	ldr	r3, [r7, #24]
 8026e22:	fa01 f303 	lsl.w	r3, r1, r3
 8026e26:	431a      	orrs	r2, r3
 8026e28:	6879      	ldr	r1, [r7, #4]
 8026e2a:	697b      	ldr	r3, [r7, #20]
 8026e2c:	3302      	adds	r3, #2
 8026e2e:	009b      	lsls	r3, r3, #2
 8026e30:	440b      	add	r3, r1
 8026e32:	605a      	str	r2, [r3, #4]
      j += 4;
 8026e34:	69bb      	ldr	r3, [r7, #24]
 8026e36:	3304      	adds	r3, #4
 8026e38:	61bb      	str	r3, [r7, #24]
 8026e3a:	e000      	b.n	8026e3e <fp_read_radix_16+0xcc>
          continue;
 8026e3c:	bf00      	nop
  for (i = (int)(XSTRLEN(str) - 1); i >= 0; i--) {
 8026e3e:	69fb      	ldr	r3, [r7, #28]
 8026e40:	3b01      	subs	r3, #1
 8026e42:	61fb      	str	r3, [r7, #28]
 8026e44:	69fb      	ldr	r3, [r7, #28]
 8026e46:	2b00      	cmp	r3, #0
 8026e48:	dab1      	bge.n	8026dae <fp_read_radix_16+0x3c>
  }

  a->used = k + 1;
 8026e4a:	697b      	ldr	r3, [r7, #20]
 8026e4c:	1c5a      	adds	r2, r3, #1
 8026e4e:	687b      	ldr	r3, [r7, #4]
 8026e50:	601a      	str	r2, [r3, #0]
  fp_clamp(a);
 8026e52:	e004      	b.n	8026e5e <fp_read_radix_16+0xec>
 8026e54:	687b      	ldr	r3, [r7, #4]
 8026e56:	681b      	ldr	r3, [r3, #0]
 8026e58:	1e5a      	subs	r2, r3, #1
 8026e5a:	687b      	ldr	r3, [r7, #4]
 8026e5c:	601a      	str	r2, [r3, #0]
 8026e5e:	687b      	ldr	r3, [r7, #4]
 8026e60:	681b      	ldr	r3, [r3, #0]
 8026e62:	2b00      	cmp	r3, #0
 8026e64:	d009      	beq.n	8026e7a <fp_read_radix_16+0x108>
 8026e66:	687b      	ldr	r3, [r7, #4]
 8026e68:	681b      	ldr	r3, [r3, #0]
 8026e6a:	3b01      	subs	r3, #1
 8026e6c:	687a      	ldr	r2, [r7, #4]
 8026e6e:	3302      	adds	r3, #2
 8026e70:	009b      	lsls	r3, r3, #2
 8026e72:	4413      	add	r3, r2
 8026e74:	685b      	ldr	r3, [r3, #4]
 8026e76:	2b00      	cmp	r3, #0
 8026e78:	d0ec      	beq.n	8026e54 <fp_read_radix_16+0xe2>
 8026e7a:	687b      	ldr	r3, [r7, #4]
 8026e7c:	681b      	ldr	r3, [r3, #0]
 8026e7e:	2b00      	cmp	r3, #0
 8026e80:	d002      	beq.n	8026e88 <fp_read_radix_16+0x116>
 8026e82:	687b      	ldr	r3, [r7, #4]
 8026e84:	685b      	ldr	r3, [r3, #4]
 8026e86:	e000      	b.n	8026e8a <fp_read_radix_16+0x118>
 8026e88:	2300      	movs	r3, #0
 8026e8a:	687a      	ldr	r2, [r7, #4]
 8026e8c:	6053      	str	r3, [r2, #4]
  /* set the sign only if a != 0 */
  if (fp_iszero(a) != FP_YES) {
 8026e8e:	687b      	ldr	r3, [r7, #4]
 8026e90:	681b      	ldr	r3, [r3, #0]
 8026e92:	2b00      	cmp	r3, #0
 8026e94:	d002      	beq.n	8026e9c <fp_read_radix_16+0x12a>
     a->sign = neg;
 8026e96:	687b      	ldr	r3, [r7, #4]
 8026e98:	693a      	ldr	r2, [r7, #16]
 8026e9a:	605a      	str	r2, [r3, #4]
  }
  return FP_OKAY;
 8026e9c:	2300      	movs	r3, #0
}
 8026e9e:	4618      	mov	r0, r3
 8026ea0:	3720      	adds	r7, #32
 8026ea2:	46bd      	mov	sp, r7
 8026ea4:	bd80      	pop	{r7, pc}
	...

08026ea8 <fp_read_radix>:
#endif

static int fp_read_radix(fp_int *a, const char *str, int radix)
{
 8026ea8:	b580      	push	{r7, lr}
 8026eaa:	b088      	sub	sp, #32
 8026eac:	af00      	add	r7, sp, #0
 8026eae:	60f8      	str	r0, [r7, #12]
 8026eb0:	60b9      	str	r1, [r7, #8]
 8026eb2:	607a      	str	r2, [r7, #4]
  int     y, neg;
  char    ch;

  /* set the integer to the default of zero */
  fp_zero (a);
 8026eb4:	68f8      	ldr	r0, [r7, #12]
 8026eb6:	f7ff fc09 	bl	80266cc <fp_zero>

#if DIGIT_BIT == 64 || DIGIT_BIT == 32
  if (radix == 16)
 8026eba:	687b      	ldr	r3, [r7, #4]
 8026ebc:	2b10      	cmp	r3, #16
 8026ebe:	d105      	bne.n	8026ecc <fp_read_radix+0x24>
      return fp_read_radix_16(a, str);
 8026ec0:	68b9      	ldr	r1, [r7, #8]
 8026ec2:	68f8      	ldr	r0, [r7, #12]
 8026ec4:	f7ff ff55 	bl	8026d72 <fp_read_radix_16>
 8026ec8:	4603      	mov	r3, r0
 8026eca:	e085      	b.n	8026fd8 <fp_read_radix+0x130>
#endif

  /* make sure the radix is ok */
  if (radix < 2 || radix > 64) {
 8026ecc:	687b      	ldr	r3, [r7, #4]
 8026ece:	2b01      	cmp	r3, #1
 8026ed0:	dd02      	ble.n	8026ed8 <fp_read_radix+0x30>
 8026ed2:	687b      	ldr	r3, [r7, #4]
 8026ed4:	2b40      	cmp	r3, #64	@ 0x40
 8026ed6:	dd02      	ble.n	8026ede <fp_read_radix+0x36>
    return FP_VAL;
 8026ed8:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8026edc:	e07c      	b.n	8026fd8 <fp_read_radix+0x130>
  }

  /* if the leading digit is a
   * minus set the sign to negative.
   */
  if (*str == '-') {
 8026ede:	68bb      	ldr	r3, [r7, #8]
 8026ee0:	781b      	ldrb	r3, [r3, #0]
 8026ee2:	2b2d      	cmp	r3, #45	@ 0x2d
 8026ee4:	d105      	bne.n	8026ef2 <fp_read_radix+0x4a>
    ++str;
 8026ee6:	68bb      	ldr	r3, [r7, #8]
 8026ee8:	3301      	adds	r3, #1
 8026eea:	60bb      	str	r3, [r7, #8]
    neg = FP_NEG;
 8026eec:	2301      	movs	r3, #1
 8026eee:	61bb      	str	r3, [r7, #24]
 8026ef0:	e062      	b.n	8026fb8 <fp_read_radix+0x110>
  } else {
    neg = FP_ZPOS;
 8026ef2:	2300      	movs	r3, #0
 8026ef4:	61bb      	str	r3, [r7, #24]
  }

  /* process each digit of the string */
  while (*str) {
 8026ef6:	e05f      	b.n	8026fb8 <fp_read_radix+0x110>
    /* if the radix <= 36 the conversion is case insensitive
     * this allows numbers like 1AB and 1ab to represent the same  value
     * [e.g. in hex]
     */
    ch = (char)((radix <= 36) ? XTOUPPER((unsigned char)*str) : *str);
 8026ef8:	687b      	ldr	r3, [r7, #4]
 8026efa:	2b24      	cmp	r3, #36	@ 0x24
 8026efc:	dc11      	bgt.n	8026f22 <fp_read_radix+0x7a>
 8026efe:	68bb      	ldr	r3, [r7, #8]
 8026f00:	781b      	ldrb	r3, [r3, #0]
 8026f02:	75fb      	strb	r3, [r7, #23]
 8026f04:	7dfb      	ldrb	r3, [r7, #23]
 8026f06:	3301      	adds	r3, #1
 8026f08:	4a35      	ldr	r2, [pc, #212]	@ (8026fe0 <fp_read_radix+0x138>)
 8026f0a:	4413      	add	r3, r2
 8026f0c:	781b      	ldrb	r3, [r3, #0]
 8026f0e:	f003 0303 	and.w	r3, r3, #3
 8026f12:	2b02      	cmp	r3, #2
 8026f14:	d102      	bne.n	8026f1c <fp_read_radix+0x74>
 8026f16:	7dfb      	ldrb	r3, [r7, #23]
 8026f18:	3b20      	subs	r3, #32
 8026f1a:	e000      	b.n	8026f1e <fp_read_radix+0x76>
 8026f1c:	7dfb      	ldrb	r3, [r7, #23]
 8026f1e:	b2db      	uxtb	r3, r3
 8026f20:	e001      	b.n	8026f26 <fp_read_radix+0x7e>
 8026f22:	68bb      	ldr	r3, [r7, #8]
 8026f24:	781b      	ldrb	r3, [r3, #0]
 8026f26:	75bb      	strb	r3, [r7, #22]
    for (y = 0; y < 64; y++) {
 8026f28:	2300      	movs	r3, #0
 8026f2a:	61fb      	str	r3, [r7, #28]
 8026f2c:	e009      	b.n	8026f42 <fp_read_radix+0x9a>
      if (ch == fp_s_rmap[y]) {
 8026f2e:	4a2d      	ldr	r2, [pc, #180]	@ (8026fe4 <fp_read_radix+0x13c>)
 8026f30:	69fb      	ldr	r3, [r7, #28]
 8026f32:	4413      	add	r3, r2
 8026f34:	781b      	ldrb	r3, [r3, #0]
 8026f36:	7dba      	ldrb	r2, [r7, #22]
 8026f38:	429a      	cmp	r2, r3
 8026f3a:	d006      	beq.n	8026f4a <fp_read_radix+0xa2>
    for (y = 0; y < 64; y++) {
 8026f3c:	69fb      	ldr	r3, [r7, #28]
 8026f3e:	3301      	adds	r3, #1
 8026f40:	61fb      	str	r3, [r7, #28]
 8026f42:	69fb      	ldr	r3, [r7, #28]
 8026f44:	2b3f      	cmp	r3, #63	@ 0x3f
 8026f46:	ddf2      	ble.n	8026f2e <fp_read_radix+0x86>
 8026f48:	e000      	b.n	8026f4c <fp_read_radix+0xa4>
         break;
 8026f4a:	bf00      	nop
      }
    }
    if (y >= radix) {
 8026f4c:	69fa      	ldr	r2, [r7, #28]
 8026f4e:	687b      	ldr	r3, [r7, #4]
 8026f50:	429a      	cmp	r2, r3
 8026f52:	db12      	blt.n	8026f7a <fp_read_radix+0xd2>
      /* Check if whitespace at end of line */
      while (CharIsWhiteSpace(*str))
 8026f54:	e002      	b.n	8026f5c <fp_read_radix+0xb4>
        ++str;
 8026f56:	68bb      	ldr	r3, [r7, #8]
 8026f58:	3301      	adds	r3, #1
 8026f5a:	60bb      	str	r3, [r7, #8]
      while (CharIsWhiteSpace(*str))
 8026f5c:	68bb      	ldr	r3, [r7, #8]
 8026f5e:	781b      	ldrb	r3, [r3, #0]
 8026f60:	4618      	mov	r0, r3
 8026f62:	f7fb f9a0 	bl	80222a6 <CharIsWhiteSpace>
 8026f66:	4603      	mov	r3, r0
 8026f68:	2b00      	cmp	r3, #0
 8026f6a:	d1f4      	bne.n	8026f56 <fp_read_radix+0xae>
      if (*str)
 8026f6c:	68bb      	ldr	r3, [r7, #8]
 8026f6e:	781b      	ldrb	r3, [r3, #0]
 8026f70:	2b00      	cmp	r3, #0
 8026f72:	d026      	beq.n	8026fc2 <fp_read_radix+0x11a>
        return FP_VAL;
 8026f74:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8026f78:	e02e      	b.n	8026fd8 <fp_read_radix+0x130>

    /* if the char was found in the map
     * and is less than the given radix add it
     * to the number, otherwise exit the loop.
     */
    if (y < radix) {
 8026f7a:	69fa      	ldr	r2, [r7, #28]
 8026f7c:	687b      	ldr	r3, [r7, #4]
 8026f7e:	429a      	cmp	r2, r3
 8026f80:	da21      	bge.n	8026fc6 <fp_read_radix+0x11e>
      int ret = fp_mul_d (a, (fp_digit) radix, a);
 8026f82:	687b      	ldr	r3, [r7, #4]
 8026f84:	68fa      	ldr	r2, [r7, #12]
 8026f86:	4619      	mov	r1, r3
 8026f88:	68f8      	ldr	r0, [r7, #12]
 8026f8a:	f7fb fc3a 	bl	8022802 <fp_mul_d>
 8026f8e:	6138      	str	r0, [r7, #16]
      if (ret != FP_OKAY)
 8026f90:	693b      	ldr	r3, [r7, #16]
 8026f92:	2b00      	cmp	r3, #0
 8026f94:	d001      	beq.n	8026f9a <fp_read_radix+0xf2>
        return ret;
 8026f96:	693b      	ldr	r3, [r7, #16]
 8026f98:	e01e      	b.n	8026fd8 <fp_read_radix+0x130>
      ret = fp_add_d (a, (fp_digit) y, a);
 8026f9a:	69fb      	ldr	r3, [r7, #28]
 8026f9c:	68fa      	ldr	r2, [r7, #12]
 8026f9e:	4619      	mov	r1, r3
 8026fa0:	68f8      	ldr	r0, [r7, #12]
 8026fa2:	f7ff feab 	bl	8026cfc <fp_add_d>
 8026fa6:	6138      	str	r0, [r7, #16]
      if (ret != FP_OKAY)
 8026fa8:	693b      	ldr	r3, [r7, #16]
 8026faa:	2b00      	cmp	r3, #0
 8026fac:	d001      	beq.n	8026fb2 <fp_read_radix+0x10a>
        return ret;
 8026fae:	693b      	ldr	r3, [r7, #16]
 8026fb0:	e012      	b.n	8026fd8 <fp_read_radix+0x130>
    } else {
      break;
    }
    ++str;
 8026fb2:	68bb      	ldr	r3, [r7, #8]
 8026fb4:	3301      	adds	r3, #1
 8026fb6:	60bb      	str	r3, [r7, #8]
  while (*str) {
 8026fb8:	68bb      	ldr	r3, [r7, #8]
 8026fba:	781b      	ldrb	r3, [r3, #0]
 8026fbc:	2b00      	cmp	r3, #0
 8026fbe:	d19b      	bne.n	8026ef8 <fp_read_radix+0x50>
 8026fc0:	e002      	b.n	8026fc8 <fp_read_radix+0x120>
        break;
 8026fc2:	bf00      	nop
 8026fc4:	e000      	b.n	8026fc8 <fp_read_radix+0x120>
      break;
 8026fc6:	bf00      	nop
  }

  /* set the sign only if a != 0 */
  if (fp_iszero(a) != FP_YES) {
 8026fc8:	68fb      	ldr	r3, [r7, #12]
 8026fca:	681b      	ldr	r3, [r3, #0]
 8026fcc:	2b00      	cmp	r3, #0
 8026fce:	d002      	beq.n	8026fd6 <fp_read_radix+0x12e>
     a->sign = neg;
 8026fd0:	68fb      	ldr	r3, [r7, #12]
 8026fd2:	69ba      	ldr	r2, [r7, #24]
 8026fd4:	605a      	str	r2, [r3, #4]
  }
  return FP_OKAY;
 8026fd6:	2300      	movs	r3, #0
}
 8026fd8:	4618      	mov	r0, r3
 8026fda:	3720      	adds	r7, #32
 8026fdc:	46bd      	mov	sp, r7
 8026fde:	bd80      	pop	{r7, pc}
 8026fe0:	08033e08 	.word	0x08033e08
 8026fe4:	0802ff0c 	.word	0x0802ff0c

08026fe8 <mp_read_radix>:

/* fast math conversion */
int mp_read_radix(mp_int *a, const char *str, int radix)
{
 8026fe8:	b580      	push	{r7, lr}
 8026fea:	b084      	sub	sp, #16
 8026fec:	af00      	add	r7, sp, #0
 8026fee:	60f8      	str	r0, [r7, #12]
 8026ff0:	60b9      	str	r1, [r7, #8]
 8026ff2:	607a      	str	r2, [r7, #4]
    return fp_read_radix(a, str, radix);
 8026ff4:	687a      	ldr	r2, [r7, #4]
 8026ff6:	68b9      	ldr	r1, [r7, #8]
 8026ff8:	68f8      	ldr	r0, [r7, #12]
 8026ffa:	f7ff ff55 	bl	8026ea8 <fp_read_radix>
 8026ffe:	4603      	mov	r3, r0
}
 8027000:	4618      	mov	r0, r3
 8027002:	3710      	adds	r7, #16
 8027004:	46bd      	mov	sp, r7
 8027006:	bd80      	pop	{r7, pc}

08027008 <mp_montgomery_reduce>:
#endif /* !defined(NO_DSA) || defined(HAVE_ECC) */

#if defined(HAVE_ECC) || (!defined(NO_RSA) && defined(WC_RSA_BLINDING))

int mp_montgomery_reduce(fp_int *a, fp_int *m, fp_digit mp)
{
 8027008:	b580      	push	{r7, lr}
 802700a:	b084      	sub	sp, #16
 802700c:	af00      	add	r7, sp, #0
 802700e:	60f8      	str	r0, [r7, #12]
 8027010:	60b9      	str	r1, [r7, #8]
 8027012:	607a      	str	r2, [r7, #4]
    return fp_montgomery_reduce(a, m, mp);
 8027014:	687a      	ldr	r2, [r7, #4]
 8027016:	68b9      	ldr	r1, [r7, #8]
 8027018:	68f8      	ldr	r0, [r7, #12]
 802701a:	f7fe ffa4 	bl	8025f66 <fp_montgomery_reduce>
 802701e:	4603      	mov	r3, r0
}
 8027020:	4618      	mov	r0, r3
 8027022:	3710      	adds	r7, #16
 8027024:	46bd      	mov	sp, r7
 8027026:	bd80      	pop	{r7, pc}

08027028 <mp_montgomery_reduce_ex>:

int mp_montgomery_reduce_ex(fp_int *a, fp_int *m, fp_digit mp, int ct)
{
 8027028:	b580      	push	{r7, lr}
 802702a:	b084      	sub	sp, #16
 802702c:	af00      	add	r7, sp, #0
 802702e:	60f8      	str	r0, [r7, #12]
 8027030:	60b9      	str	r1, [r7, #8]
 8027032:	607a      	str	r2, [r7, #4]
 8027034:	603b      	str	r3, [r7, #0]
    return fp_montgomery_reduce_ex(a, m, mp, ct);
 8027036:	683b      	ldr	r3, [r7, #0]
 8027038:	687a      	ldr	r2, [r7, #4]
 802703a:	68b9      	ldr	r1, [r7, #8]
 802703c:	68f8      	ldr	r0, [r7, #12]
 802703e:	f7fe fe5e 	bl	8025cfe <fp_montgomery_reduce_ex>
 8027042:	4603      	mov	r3, r0
}
 8027044:	4618      	mov	r0, r3
 8027046:	3710      	adds	r7, #16
 8027048:	46bd      	mov	sp, r7
 802704a:	bd80      	pop	{r7, pc}

0802704c <mp_montgomery_setup>:


/* fast math conversion */
int mp_montgomery_setup(fp_int *a, fp_digit *rho)
{
 802704c:	b580      	push	{r7, lr}
 802704e:	b082      	sub	sp, #8
 8027050:	af00      	add	r7, sp, #0
 8027052:	6078      	str	r0, [r7, #4]
 8027054:	6039      	str	r1, [r7, #0]
    return fp_montgomery_setup(a, rho);
 8027056:	6839      	ldr	r1, [r7, #0]
 8027058:	6878      	ldr	r0, [r7, #4]
 802705a:	f7fe fdbd 	bl	8025bd8 <fp_montgomery_setup>
 802705e:	4603      	mov	r3, r0
}
 8027060:	4618      	mov	r0, r3
 8027062:	3708      	adds	r7, #8
 8027064:	46bd      	mov	sp, r7
 8027066:	bd80      	pop	{r7, pc}

08027068 <mp_sqr>:

#endif /* HAVE_ECC || (!NO_RSA && WC_RSA_BLINDING) */

/* fast math conversion */
int mp_sqr(fp_int *A, fp_int *B)
{
 8027068:	b580      	push	{r7, lr}
 802706a:	b082      	sub	sp, #8
 802706c:	af00      	add	r7, sp, #0
 802706e:	6078      	str	r0, [r7, #4]
 8027070:	6039      	str	r1, [r7, #0]
    return fp_sqr(A, B);
 8027072:	6839      	ldr	r1, [r7, #0]
 8027074:	6878      	ldr	r0, [r7, #4]
 8027076:	f7fe faba 	bl	80255ee <fp_sqr>
 802707a:	4603      	mov	r3, r0
}
 802707c:	4618      	mov	r0, r3
 802707e:	3708      	adds	r7, #8
 8027080:	46bd      	mov	sp, r7
 8027082:	bd80      	pop	{r7, pc}

08027084 <mp_div_2_mod_ct>:
    return MP_OKAY;
}

/* c = a / 2 (mod b) - constant time (a < b and positive) */
int mp_div_2_mod_ct(mp_int *a, mp_int *b, mp_int *c)
{
 8027084:	b580      	push	{r7, lr}
 8027086:	b084      	sub	sp, #16
 8027088:	af00      	add	r7, sp, #0
 802708a:	60f8      	str	r0, [r7, #12]
 802708c:	60b9      	str	r1, [r7, #8]
 802708e:	607a      	str	r2, [r7, #4]
  return fp_div_2_mod_ct(a, b, c);
 8027090:	687a      	ldr	r2, [r7, #4]
 8027092:	68b9      	ldr	r1, [r7, #8]
 8027094:	68f8      	ldr	r0, [r7, #12]
 8027096:	f7fc f96a 	bl	802336e <fp_div_2_mod_ct>
 802709a:	4603      	mov	r3, r0
}
 802709c:	4618      	mov	r0, r3
 802709e:	3710      	adds	r7, #16
 80270a0:	46bd      	mov	sp, r7
 80270a2:	bd80      	pop	{r7, pc}

080270a4 <mp_set>:

#if defined(HAVE_ECC) || !defined(NO_RSA) || !defined(NO_DSA) || \
    defined(WOLFSSL_KEY_GEN)
/* fast math conversion */
int mp_set(fp_int *a, fp_digit b)
{
 80270a4:	b580      	push	{r7, lr}
 80270a6:	b082      	sub	sp, #8
 80270a8:	af00      	add	r7, sp, #0
 80270aa:	6078      	str	r0, [r7, #4]
 80270ac:	6039      	str	r1, [r7, #0]
    fp_set(a,b);
 80270ae:	6839      	ldr	r1, [r7, #0]
 80270b0:	6878      	ldr	r0, [r7, #4]
 80270b2:	f7ff f8ce 	bl	8026252 <fp_set>
    return MP_OKAY;
 80270b6:	2300      	movs	r3, #0
}
 80270b8:	4618      	mov	r0, r3
 80270ba:	3708      	adds	r7, #8
 80270bc:	46bd      	mov	sp, r7
 80270be:	bd80      	pop	{r7, pc}

080270c0 <ForceZero>:
{
 80270c0:	b480      	push	{r7}
 80270c2:	b085      	sub	sp, #20
 80270c4:	af00      	add	r7, sp, #0
 80270c6:	6078      	str	r0, [r7, #4]
 80270c8:	6039      	str	r1, [r7, #0]
    volatile byte* z = (volatile byte*)mem;
 80270ca:	687b      	ldr	r3, [r7, #4]
 80270cc:	60fb      	str	r3, [r7, #12]
    while (len--) *z++ = 0;
 80270ce:	e004      	b.n	80270da <ForceZero+0x1a>
 80270d0:	68fb      	ldr	r3, [r7, #12]
 80270d2:	1c5a      	adds	r2, r3, #1
 80270d4:	60fa      	str	r2, [r7, #12]
 80270d6:	2200      	movs	r2, #0
 80270d8:	701a      	strb	r2, [r3, #0]
 80270da:	683b      	ldr	r3, [r7, #0]
 80270dc:	1e5a      	subs	r2, r3, #1
 80270de:	603a      	str	r2, [r7, #0]
 80270e0:	2b00      	cmp	r3, #0
 80270e2:	d1f5      	bne.n	80270d0 <ForceZero+0x10>
}
 80270e4:	bf00      	nop
 80270e6:	bf00      	nop
 80270e8:	3714      	adds	r7, #20
 80270ea:	46bd      	mov	sp, r7
 80270ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 80270f0:	4770      	bx	lr

080270f2 <wc_AesCbcDecryptWithKey>:

#if !defined(NO_AES) && defined(HAVE_AES_CBC)
#ifdef HAVE_AES_DECRYPT
int wc_AesCbcDecryptWithKey(byte* out, const byte* in, word32 inSz,
                                  const byte* key, word32 keySz, const byte* iv)
{
 80270f2:	b580      	push	{r7, lr}
 80270f4:	b08a      	sub	sp, #40	@ 0x28
 80270f6:	af02      	add	r7, sp, #8
 80270f8:	60f8      	str	r0, [r7, #12]
 80270fa:	60b9      	str	r1, [r7, #8]
 80270fc:	607a      	str	r2, [r7, #4]
 80270fe:	603b      	str	r3, [r7, #0]
    int  ret = 0;
 8027100:	2300      	movs	r3, #0
 8027102:	61fb      	str	r3, [r7, #28]
#ifdef WOLFSSL_SMALL_STACK
    Aes* aes = NULL;
 8027104:	2300      	movs	r3, #0
 8027106:	61bb      	str	r3, [r7, #24]
#else
    Aes  aes[1];
#endif

    if (out == NULL || in == NULL || key == NULL || iv == NULL) {
 8027108:	68fb      	ldr	r3, [r7, #12]
 802710a:	2b00      	cmp	r3, #0
 802710c:	d008      	beq.n	8027120 <wc_AesCbcDecryptWithKey+0x2e>
 802710e:	68bb      	ldr	r3, [r7, #8]
 8027110:	2b00      	cmp	r3, #0
 8027112:	d005      	beq.n	8027120 <wc_AesCbcDecryptWithKey+0x2e>
 8027114:	683b      	ldr	r3, [r7, #0]
 8027116:	2b00      	cmp	r3, #0
 8027118:	d002      	beq.n	8027120 <wc_AesCbcDecryptWithKey+0x2e>
 802711a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802711c:	2b00      	cmp	r3, #0
 802711e:	d102      	bne.n	8027126 <wc_AesCbcDecryptWithKey+0x34>
        return BAD_FUNC_ARG;
 8027120:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8027124:	e033      	b.n	802718e <wc_AesCbcDecryptWithKey+0x9c>
    }

#ifdef WOLFSSL_SMALL_STACK
    aes = (Aes*)XMALLOC(sizeof(Aes), NULL, DYNAMIC_TYPE_TMP_BUFFER);
 8027126:	f44f 70a6 	mov.w	r0, #332	@ 0x14c
 802712a:	f7f7 fcad 	bl	801ea88 <wolfSSL_Malloc>
 802712e:	61b8      	str	r0, [r7, #24]
    if (aes == NULL)
 8027130:	69bb      	ldr	r3, [r7, #24]
 8027132:	2b00      	cmp	r3, #0
 8027134:	d102      	bne.n	802713c <wc_AesCbcDecryptWithKey+0x4a>
        return MEMORY_E;
 8027136:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 802713a:	e028      	b.n	802718e <wc_AesCbcDecryptWithKey+0x9c>
#endif

    ret = wc_AesInit(aes, NULL, INVALID_DEVID);
 802713c:	f06f 0201 	mvn.w	r2, #1
 8027140:	2100      	movs	r1, #0
 8027142:	69b8      	ldr	r0, [r7, #24]
 8027144:	f7eb fa77 	bl	8012636 <wc_AesInit>
 8027148:	61f8      	str	r0, [r7, #28]
    if (ret == 0) {
 802714a:	69fb      	ldr	r3, [r7, #28]
 802714c:	2b00      	cmp	r3, #0
 802714e:	d115      	bne.n	802717c <wc_AesCbcDecryptWithKey+0x8a>
        ret = wc_AesSetKey(aes, key, keySz, iv, AES_DECRYPTION);
 8027150:	2301      	movs	r3, #1
 8027152:	9300      	str	r3, [sp, #0]
 8027154:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8027156:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8027158:	6839      	ldr	r1, [r7, #0]
 802715a:	69b8      	ldr	r0, [r7, #24]
 802715c:	f7eb f982 	bl	8012464 <wc_AesSetKey>
 8027160:	61f8      	str	r0, [r7, #28]
        if (ret == 0)
 8027162:	69fb      	ldr	r3, [r7, #28]
 8027164:	2b00      	cmp	r3, #0
 8027166:	d106      	bne.n	8027176 <wc_AesCbcDecryptWithKey+0x84>
            ret = wc_AesCbcDecrypt(aes, out, in, inSz);
 8027168:	687b      	ldr	r3, [r7, #4]
 802716a:	68ba      	ldr	r2, [r7, #8]
 802716c:	68f9      	ldr	r1, [r7, #12]
 802716e:	69b8      	ldr	r0, [r7, #24]
 8027170:	f7eb fa07 	bl	8012582 <wc_AesCbcDecrypt>
 8027174:	61f8      	str	r0, [r7, #28]

        wc_AesFree(aes);
 8027176:	69b8      	ldr	r0, [r7, #24]
 8027178:	f7eb fa7a 	bl	8012670 <wc_AesFree>
    }

#ifdef WOLFSSL_SMALL_STACK
    XFREE(aes, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 802717c:	69bb      	ldr	r3, [r7, #24]
 802717e:	617b      	str	r3, [r7, #20]
 8027180:	697b      	ldr	r3, [r7, #20]
 8027182:	2b00      	cmp	r3, #0
 8027184:	d002      	beq.n	802718c <wc_AesCbcDecryptWithKey+0x9a>
 8027186:	6978      	ldr	r0, [r7, #20]
 8027188:	f7f7 fc9a 	bl	801eac0 <wolfSSL_Free>
#endif

    return ret;
 802718c:	69fb      	ldr	r3, [r7, #28]
}
 802718e:	4618      	mov	r0, r3
 8027190:	3720      	adds	r7, #32
 8027192:	46bd      	mov	sp, r7
 8027194:	bd80      	pop	{r7, pc}

08027196 <wc_BufferKeyDecrypt>:

#if !defined(NO_ASN) && defined(WOLFSSL_ENCRYPTED_KEYS)

int wc_BufferKeyDecrypt(EncryptedInfo* info, byte* der, word32 derSz,
    const byte* password, int passwordSz, int hashType)
{
 8027196:	b580      	push	{r7, lr}
 8027198:	b08a      	sub	sp, #40	@ 0x28
 802719a:	af02      	add	r7, sp, #8
 802719c:	60f8      	str	r0, [r7, #12]
 802719e:	60b9      	str	r1, [r7, #8]
 80271a0:	607a      	str	r2, [r7, #4]
 80271a2:	603b      	str	r3, [r7, #0]
    int ret = WC_NO_ERR_TRACE(NOT_COMPILED_IN);
 80271a4:	f06f 03ad 	mvn.w	r3, #173	@ 0xad
 80271a8:	61fb      	str	r3, [r7, #28]
#ifdef WOLFSSL_SMALL_STACK
    byte* key      = NULL;
 80271aa:	2300      	movs	r3, #0
 80271ac:	61bb      	str	r3, [r7, #24]

    (void)derSz;
    (void)passwordSz;
    (void)hashType;

    if (der == NULL || password == NULL || info == NULL || info->keySz == 0) {
 80271ae:	68bb      	ldr	r3, [r7, #8]
 80271b0:	2b00      	cmp	r3, #0
 80271b2:	d009      	beq.n	80271c8 <wc_BufferKeyDecrypt+0x32>
 80271b4:	683b      	ldr	r3, [r7, #0]
 80271b6:	2b00      	cmp	r3, #0
 80271b8:	d006      	beq.n	80271c8 <wc_BufferKeyDecrypt+0x32>
 80271ba:	68fb      	ldr	r3, [r7, #12]
 80271bc:	2b00      	cmp	r3, #0
 80271be:	d003      	beq.n	80271c8 <wc_BufferKeyDecrypt+0x32>
 80271c0:	68fb      	ldr	r3, [r7, #12]
 80271c2:	691b      	ldr	r3, [r3, #16]
 80271c4:	2b00      	cmp	r3, #0
 80271c6:	d102      	bne.n	80271ce <wc_BufferKeyDecrypt+0x38>
        return BAD_FUNC_ARG;
 80271c8:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80271cc:	e045      	b.n	802725a <wc_BufferKeyDecrypt+0xc4>
    }

    /* use file's salt for key derivation, hex decode first */
    if (Base16_Decode(info->iv, info->ivSz, info->iv, &info->ivSz) != 0) {
 80271ce:	68fb      	ldr	r3, [r7, #12]
 80271d0:	f103 0068 	add.w	r0, r3, #104	@ 0x68
 80271d4:	68fb      	ldr	r3, [r7, #12]
 80271d6:	6959      	ldr	r1, [r3, #20]
 80271d8:	68fb      	ldr	r3, [r7, #12]
 80271da:	f103 0268 	add.w	r2, r3, #104	@ 0x68
 80271de:	68fb      	ldr	r3, [r7, #12]
 80271e0:	3314      	adds	r3, #20
 80271e2:	f7f3 fa0b 	bl	801a5fc <Base16_Decode>
 80271e6:	4603      	mov	r3, r0
 80271e8:	2b00      	cmp	r3, #0
 80271ea:	d002      	beq.n	80271f2 <wc_BufferKeyDecrypt+0x5c>
        WOLFSSL_ERROR_VERBOSE(BUFFER_E);
        return BUFFER_E;
 80271ec:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 80271f0:	e033      	b.n	802725a <wc_BufferKeyDecrypt+0xc4>
    }
    if (info->ivSz < PKCS5_SALT_SZ) {
 80271f2:	68fb      	ldr	r3, [r7, #12]
 80271f4:	695b      	ldr	r3, [r3, #20]
 80271f6:	2b07      	cmp	r3, #7
 80271f8:	d802      	bhi.n	8027200 <wc_BufferKeyDecrypt+0x6a>
        WOLFSSL_ERROR_VERBOSE(BUFFER_E);
        return BUFFER_E;
 80271fa:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 80271fe:	e02c      	b.n	802725a <wc_BufferKeyDecrypt+0xc4>
    }

#ifdef WOLFSSL_SMALL_STACK
    key = (byte*)XMALLOC(WC_MAX_SYM_KEY_SIZE, NULL, DYNAMIC_TYPE_SYMMETRIC_KEY);
 8027200:	2020      	movs	r0, #32
 8027202:	f7f7 fc41 	bl	801ea88 <wolfSSL_Malloc>
 8027206:	61b8      	str	r0, [r7, #24]
    if (key == NULL) {
 8027208:	69bb      	ldr	r3, [r7, #24]
 802720a:	2b00      	cmp	r3, #0
 802720c:	d102      	bne.n	8027214 <wc_BufferKeyDecrypt+0x7e>
        return MEMORY_E;
 802720e:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8027212:	e022      	b.n	802725a <wc_BufferKeyDecrypt+0xc4>
#endif
#ifdef WOLFSSL_CHECK_MEM_ZERO
    wc_MemZero_Add("wc_BufferKeyDecrypt key", key, WC_MAX_SYM_KEY_SIZE);
#endif

    (void)XMEMSET(key, 0, WC_MAX_SYM_KEY_SIZE);
 8027214:	2220      	movs	r2, #32
 8027216:	2100      	movs	r1, #0
 8027218:	69b8      	ldr	r0, [r7, #24]
 802721a:	f001 f955 	bl	80284c8 <memset>
        ret = wc_Des_CbcDecryptWithKey(der, der, derSz, key, info->iv);
    if (info->cipherType == WC_CIPHER_DES3)
        ret = wc_Des3_CbcDecryptWithKey(der, der, derSz, key, info->iv);
#endif /* NO_DES3 */
#if !defined(NO_AES) && defined(HAVE_AES_CBC) && defined(HAVE_AES_DECRYPT)
    if (info->cipherType == WC_CIPHER_AES_CBC)
 802721e:	68fb      	ldr	r3, [r7, #12]
 8027220:	68db      	ldr	r3, [r3, #12]
 8027222:	2b02      	cmp	r3, #2
 8027224:	d10c      	bne.n	8027240 <wc_BufferKeyDecrypt+0xaa>
        ret = wc_AesCbcDecryptWithKey(der, der, derSz, key, info->keySz,
 8027226:	68fb      	ldr	r3, [r7, #12]
 8027228:	691b      	ldr	r3, [r3, #16]
            info->iv);
 802722a:	68fa      	ldr	r2, [r7, #12]
 802722c:	3268      	adds	r2, #104	@ 0x68
        ret = wc_AesCbcDecryptWithKey(der, der, derSz, key, info->keySz,
 802722e:	9201      	str	r2, [sp, #4]
 8027230:	9300      	str	r3, [sp, #0]
 8027232:	69bb      	ldr	r3, [r7, #24]
 8027234:	687a      	ldr	r2, [r7, #4]
 8027236:	68b9      	ldr	r1, [r7, #8]
 8027238:	68b8      	ldr	r0, [r7, #8]
 802723a:	f7ff ff5a 	bl	80270f2 <wc_AesCbcDecryptWithKey>
 802723e:	61f8      	str	r0, [r7, #28]
#endif /* !NO_AES && HAVE_AES_CBC && HAVE_AES_DECRYPT */

    ForceZero(key, WC_MAX_SYM_KEY_SIZE);
 8027240:	2120      	movs	r1, #32
 8027242:	69b8      	ldr	r0, [r7, #24]
 8027244:	f7ff ff3c 	bl	80270c0 <ForceZero>
#ifdef WOLFSSL_SMALL_STACK
    XFREE(key, NULL, DYNAMIC_TYPE_SYMMETRIC_KEY);
 8027248:	69bb      	ldr	r3, [r7, #24]
 802724a:	617b      	str	r3, [r7, #20]
 802724c:	697b      	ldr	r3, [r7, #20]
 802724e:	2b00      	cmp	r3, #0
 8027250:	d002      	beq.n	8027258 <wc_BufferKeyDecrypt+0xc2>
 8027252:	6978      	ldr	r0, [r7, #20]
 8027254:	f7f7 fc34 	bl	801eac0 <wolfSSL_Free>
#elif defined(WOLFSSL_CHECK_MEM_ZERO)
    wc_MemZero_Check(key, WC_MAX_SYM_KEY_SIZE);
#endif

    return ret;
 8027258:	69fb      	ldr	r3, [r7, #28]
}
 802725a:	4618      	mov	r0, r3
 802725c:	3720      	adds	r7, #32
 802725e:	46bd      	mov	sp, r7
 8027260:	bd80      	pop	{r7, pc}
	...

08027264 <wolfCrypt_Init>:
/* Used to initialize state for wolfcrypt
   return 0 on success
 */
WOLFSSL_ABI
int wolfCrypt_Init(void)
{
 8027264:	b580      	push	{r7, lr}
 8027266:	b082      	sub	sp, #8
 8027268:	af00      	add	r7, sp, #0
    int ret = 0;
 802726a:	2300      	movs	r3, #0
 802726c:	607b      	str	r3, [r7, #4]
    if (initRefCount == 0) {
 802726e:	4b10      	ldr	r3, [pc, #64]	@ (80272b0 <wolfCrypt_Init+0x4c>)
 8027270:	681b      	ldr	r3, [r3, #0]
 8027272:	2b00      	cmp	r3, #0
 8027274:	d111      	bne.n	802729a <wolfCrypt_Init+0x36>
        }
    #endif

    #if WOLFSSL_CRYPT_HW_MUTEX
        /* If crypto hardware mutex protection is enabled, then initialize it */
        ret = wolfSSL_CryptHwMutexInit();
 8027276:	f000 f83d 	bl	80272f4 <wolfSSL_CryptHwMutexInit>
 802727a:	6078      	str	r0, [r7, #4]
        if (ret != 0) {
 802727c:	687b      	ldr	r3, [r7, #4]
 802727e:	2b00      	cmp	r3, #0
 8027280:	d001      	beq.n	8027286 <wolfCrypt_Init+0x22>
            WOLFSSL_MSG("Hw crypt mutex init failed");
            return ret;
 8027282:	687b      	ldr	r3, [r7, #4]
 8027284:	e00f      	b.n	80272a6 <wolfCrypt_Init+0x42>
    #ifdef WOLFSSL_AFALG
        WOLFSSL_MSG("Using AF_ALG for crypto acceleration");
    #endif

    #if !defined(WOLFCRYPT_ONLY) && defined(OPENSSL_EXTRA)
        wolfSSL_EVP_init();
 8027286:	f7e4 f81b 	bl	800b2c0 <wolfSSL_EVP_init>
    #endif

    #if defined(OPENSSL_EXTRA) || defined(DEBUG_WOLFSSL_VERBOSE)
        if ((ret = wc_LoggingInit()) != 0) {
 802728a:	f7f7 f9a3 	bl	801e5d4 <wc_LoggingInit>
 802728e:	6078      	str	r0, [r7, #4]
 8027290:	687b      	ldr	r3, [r7, #4]
 8027292:	2b00      	cmp	r3, #0
 8027294:	d001      	beq.n	802729a <wolfCrypt_Init+0x36>
            WOLFSSL_MSG("Error creating logging mutex");
            return ret;
 8027296:	687b      	ldr	r3, [r7, #4]
 8027298:	e005      	b.n	80272a6 <wolfCrypt_Init+0x42>
        if ((ret = wolfSSL_liboqsInit()) != 0) {
            return ret;
        }
#endif
    }
    initRefCount++;
 802729a:	4b05      	ldr	r3, [pc, #20]	@ (80272b0 <wolfCrypt_Init+0x4c>)
 802729c:	681b      	ldr	r3, [r3, #0]
 802729e:	3301      	adds	r3, #1
 80272a0:	4a03      	ldr	r2, [pc, #12]	@ (80272b0 <wolfCrypt_Init+0x4c>)
 80272a2:	6013      	str	r3, [r2, #0]

    return ret;
 80272a4:	687b      	ldr	r3, [r7, #4]
}
 80272a6:	4618      	mov	r0, r3
 80272a8:	3708      	adds	r7, #8
 80272aa:	46bd      	mov	sp, r7
 80272ac:	bd80      	pop	{r7, pc}
 80272ae:	bf00      	nop
 80272b0:	20002904 	.word	0x20002904

080272b4 <wolfCrypt_Cleanup>:
#endif

/* return success value is the same as wolfCrypt_Init */
WOLFSSL_ABI
int wolfCrypt_Cleanup(void)
{
 80272b4:	b580      	push	{r7, lr}
 80272b6:	b082      	sub	sp, #8
 80272b8:	af00      	add	r7, sp, #0
    int ret = 0;
 80272ba:	2300      	movs	r3, #0
 80272bc:	607b      	str	r3, [r7, #4]

    initRefCount--;
 80272be:	4b0c      	ldr	r3, [pc, #48]	@ (80272f0 <wolfCrypt_Cleanup+0x3c>)
 80272c0:	681b      	ldr	r3, [r3, #0]
 80272c2:	3b01      	subs	r3, #1
 80272c4:	4a0a      	ldr	r2, [pc, #40]	@ (80272f0 <wolfCrypt_Cleanup+0x3c>)
 80272c6:	6013      	str	r3, [r2, #0]
    if (initRefCount < 0)
 80272c8:	4b09      	ldr	r3, [pc, #36]	@ (80272f0 <wolfCrypt_Cleanup+0x3c>)
 80272ca:	681b      	ldr	r3, [r3, #0]
 80272cc:	2b00      	cmp	r3, #0
 80272ce:	da02      	bge.n	80272d6 <wolfCrypt_Cleanup+0x22>
        initRefCount = 0;
 80272d0:	4b07      	ldr	r3, [pc, #28]	@ (80272f0 <wolfCrypt_Cleanup+0x3c>)
 80272d2:	2200      	movs	r2, #0
 80272d4:	601a      	str	r2, [r3, #0]

    if (initRefCount == 0) {
 80272d6:	4b06      	ldr	r3, [pc, #24]	@ (80272f0 <wolfCrypt_Cleanup+0x3c>)
 80272d8:	681b      	ldr	r3, [r3, #0]
 80272da:	2b00      	cmp	r3, #0
 80272dc:	d102      	bne.n	80272e4 <wolfCrypt_Cleanup+0x30>
        wc_ecc_oid_cache_free();
    #endif
#endif /* HAVE_ECC */

    #if defined(OPENSSL_EXTRA) || defined(DEBUG_WOLFSSL_VERBOSE)
        ret = wc_LoggingCleanup();
 80272de:	f7f7 f99d 	bl	801e61c <wc_LoggingCleanup>
 80272e2:	6078      	str	r0, [r7, #4]

#if defined(HAVE_LIBOQS)
    wolfSSL_liboqsClose();
#endif

    return ret;
 80272e4:	687b      	ldr	r3, [r7, #4]
}
 80272e6:	4618      	mov	r0, r3
 80272e8:	3708      	adds	r7, #8
 80272ea:	46bd      	mov	sp, r7
 80272ec:	bd80      	pop	{r7, pc}
 80272ee:	bf00      	nop
 80272f0:	20002904 	.word	0x20002904

080272f4 <wolfSSL_CryptHwMutexInit>:
#ifndef WOLFSSL_MUTEX_INITIALIZER
static int wcCryptHwMutexInit = 0;
#endif

int wolfSSL_CryptHwMutexInit(void)
{
 80272f4:	b580      	push	{r7, lr}
 80272f6:	b082      	sub	sp, #8
 80272f8:	af00      	add	r7, sp, #0
    int ret = 0;
 80272fa:	2300      	movs	r3, #0
 80272fc:	607b      	str	r3, [r7, #4]
#ifndef WOLFSSL_MUTEX_INITIALIZER
    if (wcCryptHwMutexInit == 0) {
 80272fe:	4b09      	ldr	r3, [pc, #36]	@ (8027324 <wolfSSL_CryptHwMutexInit+0x30>)
 8027300:	681b      	ldr	r3, [r3, #0]
 8027302:	2b00      	cmp	r3, #0
 8027304:	d109      	bne.n	802731a <wolfSSL_CryptHwMutexInit+0x26>
        ret = wc_InitMutex(&wcCryptHwMutex);
 8027306:	4808      	ldr	r0, [pc, #32]	@ (8027328 <wolfSSL_CryptHwMutexInit+0x34>)
 8027308:	f000 f838 	bl	802737c <wc_InitMutex>
 802730c:	6078      	str	r0, [r7, #4]
        if (ret == 0) {
 802730e:	687b      	ldr	r3, [r7, #4]
 8027310:	2b00      	cmp	r3, #0
 8027312:	d102      	bne.n	802731a <wolfSSL_CryptHwMutexInit+0x26>
            wcCryptHwMutexInit = 1;
 8027314:	4b03      	ldr	r3, [pc, #12]	@ (8027324 <wolfSSL_CryptHwMutexInit+0x30>)
 8027316:	2201      	movs	r2, #1
 8027318:	601a      	str	r2, [r3, #0]
        }
    }
#endif
    return ret;
 802731a:	687b      	ldr	r3, [r7, #4]
}
 802731c:	4618      	mov	r0, r3
 802731e:	3708      	adds	r7, #8
 8027320:	46bd      	mov	sp, r7
 8027322:	bd80      	pop	{r7, pc}
 8027324:	2000290c 	.word	0x2000290c
 8027328:	20002908 	.word	0x20002908

0802732c <wolfSSL_CryptHwMutexLock>:
int wolfSSL_CryptHwMutexLock(void)
{
 802732c:	b580      	push	{r7, lr}
 802732e:	b082      	sub	sp, #8
 8027330:	af00      	add	r7, sp, #0
    /* Make sure HW Mutex has been initialized */
    int ret = wolfSSL_CryptHwMutexInit();
 8027332:	f7ff ffdf 	bl	80272f4 <wolfSSL_CryptHwMutexInit>
 8027336:	6078      	str	r0, [r7, #4]
    if (ret == 0) {
 8027338:	687b      	ldr	r3, [r7, #4]
 802733a:	2b00      	cmp	r3, #0
 802733c:	d103      	bne.n	8027346 <wolfSSL_CryptHwMutexLock+0x1a>
        ret = wc_LockMutex(&wcCryptHwMutex);
 802733e:	4804      	ldr	r0, [pc, #16]	@ (8027350 <wolfSSL_CryptHwMutexLock+0x24>)
 8027340:	f000 f832 	bl	80273a8 <wc_LockMutex>
 8027344:	6078      	str	r0, [r7, #4]
    }
    return ret;
 8027346:	687b      	ldr	r3, [r7, #4]
}
 8027348:	4618      	mov	r0, r3
 802734a:	3708      	adds	r7, #8
 802734c:	46bd      	mov	sp, r7
 802734e:	bd80      	pop	{r7, pc}
 8027350:	20002908 	.word	0x20002908

08027354 <wolfSSL_CryptHwMutexUnLock>:
int wolfSSL_CryptHwMutexUnLock(void)
{
 8027354:	b580      	push	{r7, lr}
 8027356:	af00      	add	r7, sp, #0
    if (wcCryptHwMutexInit) {
 8027358:	4b06      	ldr	r3, [pc, #24]	@ (8027374 <wolfSSL_CryptHwMutexUnLock+0x20>)
 802735a:	681b      	ldr	r3, [r3, #0]
 802735c:	2b00      	cmp	r3, #0
 802735e:	d004      	beq.n	802736a <wolfSSL_CryptHwMutexUnLock+0x16>
        return wc_UnLockMutex(&wcCryptHwMutex);
 8027360:	4805      	ldr	r0, [pc, #20]	@ (8027378 <wolfSSL_CryptHwMutexUnLock+0x24>)
 8027362:	f000 f82c 	bl	80273be <wc_UnLockMutex>
 8027366:	4603      	mov	r3, r0
 8027368:	e001      	b.n	802736e <wolfSSL_CryptHwMutexUnLock+0x1a>
    }
    else {
        return BAD_MUTEX_E;
 802736a:	f06f 0369 	mvn.w	r3, #105	@ 0x69
    }
}
 802736e:	4618      	mov	r0, r3
 8027370:	bd80      	pop	{r7, pc}
 8027372:	bf00      	nop
 8027374:	2000290c 	.word	0x2000290c
 8027378:	20002908 	.word	0x20002908

0802737c <wc_InitMutex>:
    }
#endif /* defined(OPENSSL_EXTRA) || defined(HAVE_WEBSERVER) */
#ifdef SINGLE_THREADED

    int wc_InitMutex(wolfSSL_Mutex* m)
    {
 802737c:	b480      	push	{r7}
 802737e:	b083      	sub	sp, #12
 8027380:	af00      	add	r7, sp, #0
 8027382:	6078      	str	r0, [r7, #4]
        (void)m;
        return 0;
 8027384:	2300      	movs	r3, #0
    }
 8027386:	4618      	mov	r0, r3
 8027388:	370c      	adds	r7, #12
 802738a:	46bd      	mov	sp, r7
 802738c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027390:	4770      	bx	lr

08027392 <wc_FreeMutex>:

    int wc_FreeMutex(wolfSSL_Mutex *m)
    {
 8027392:	b480      	push	{r7}
 8027394:	b083      	sub	sp, #12
 8027396:	af00      	add	r7, sp, #0
 8027398:	6078      	str	r0, [r7, #4]
        (void)m;
        return 0;
 802739a:	2300      	movs	r3, #0
    }
 802739c:	4618      	mov	r0, r3
 802739e:	370c      	adds	r7, #12
 80273a0:	46bd      	mov	sp, r7
 80273a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80273a6:	4770      	bx	lr

080273a8 <wc_LockMutex>:


    int wc_LockMutex(wolfSSL_Mutex *m)
    {
 80273a8:	b480      	push	{r7}
 80273aa:	b083      	sub	sp, #12
 80273ac:	af00      	add	r7, sp, #0
 80273ae:	6078      	str	r0, [r7, #4]
        (void)m;
        return 0;
 80273b0:	2300      	movs	r3, #0
    }
 80273b2:	4618      	mov	r0, r3
 80273b4:	370c      	adds	r7, #12
 80273b6:	46bd      	mov	sp, r7
 80273b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80273bc:	4770      	bx	lr

080273be <wc_UnLockMutex>:


    int wc_UnLockMutex(wolfSSL_Mutex *m)
    {
 80273be:	b480      	push	{r7}
 80273c0:	b083      	sub	sp, #12
 80273c2:	af00      	add	r7, sp, #0
 80273c4:	6078      	str	r0, [r7, #4]
        (void)m;
        return 0;
 80273c6:	2300      	movs	r3, #0
    }
 80273c8:	4618      	mov	r0, r3
 80273ca:	370c      	adds	r7, #12
 80273cc:	46bd      	mov	sp, r7
 80273ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 80273d2:	4770      	bx	lr

080273d4 <mystrnstr>:
#endif /* !NO_ASN_TIME */

#if (!defined(WOLFSSL_LEANPSK) && !defined(STRING_USER)) || \
    defined(USE_WOLF_STRNSTR)
char* mystrnstr(const char* s1, const char* s2, unsigned int n)
{
 80273d4:	b580      	push	{r7, lr}
 80273d6:	b086      	sub	sp, #24
 80273d8:	af00      	add	r7, sp, #0
 80273da:	60f8      	str	r0, [r7, #12]
 80273dc:	60b9      	str	r1, [r7, #8]
 80273de:	607a      	str	r2, [r7, #4]
    unsigned int s2_len = (unsigned int)XSTRLEN(s2);
 80273e0:	68b8      	ldr	r0, [r7, #8]
 80273e2:	f7d8 feff 	bl	80001e4 <strlen>
 80273e6:	6178      	str	r0, [r7, #20]

    if (s2_len == 0)
 80273e8:	697b      	ldr	r3, [r7, #20]
 80273ea:	2b00      	cmp	r3, #0
 80273ec:	d117      	bne.n	802741e <mystrnstr+0x4a>
        return (char*)s1;
 80273ee:	68fb      	ldr	r3, [r7, #12]
 80273f0:	e01e      	b.n	8027430 <mystrnstr+0x5c>

    while (n >= s2_len && s1[0]) {
        if (s1[0] == s2[0])
 80273f2:	68fb      	ldr	r3, [r7, #12]
 80273f4:	781a      	ldrb	r2, [r3, #0]
 80273f6:	68bb      	ldr	r3, [r7, #8]
 80273f8:	781b      	ldrb	r3, [r3, #0]
 80273fa:	429a      	cmp	r2, r3
 80273fc:	d109      	bne.n	8027412 <mystrnstr+0x3e>
            if (XMEMCMP(s1, s2, s2_len) == 0)
 80273fe:	697a      	ldr	r2, [r7, #20]
 8027400:	68b9      	ldr	r1, [r7, #8]
 8027402:	68f8      	ldr	r0, [r7, #12]
 8027404:	f001 f836 	bl	8028474 <memcmp>
 8027408:	4603      	mov	r3, r0
 802740a:	2b00      	cmp	r3, #0
 802740c:	d101      	bne.n	8027412 <mystrnstr+0x3e>
                return (char*)s1;
 802740e:	68fb      	ldr	r3, [r7, #12]
 8027410:	e00e      	b.n	8027430 <mystrnstr+0x5c>
        s1++;
 8027412:	68fb      	ldr	r3, [r7, #12]
 8027414:	3301      	adds	r3, #1
 8027416:	60fb      	str	r3, [r7, #12]
        n--;
 8027418:	687b      	ldr	r3, [r7, #4]
 802741a:	3b01      	subs	r3, #1
 802741c:	607b      	str	r3, [r7, #4]
    while (n >= s2_len && s1[0]) {
 802741e:	687a      	ldr	r2, [r7, #4]
 8027420:	697b      	ldr	r3, [r7, #20]
 8027422:	429a      	cmp	r2, r3
 8027424:	d303      	bcc.n	802742e <mystrnstr+0x5a>
 8027426:	68fb      	ldr	r3, [r7, #12]
 8027428:	781b      	ldrb	r3, [r3, #0]
 802742a:	2b00      	cmp	r3, #0
 802742c:	d1e1      	bne.n	80273f2 <mystrnstr+0x1e>
    }

    return NULL;
 802742e:	2300      	movs	r3, #0
}
 8027430:	4618      	mov	r0, r3
 8027432:	3718      	adds	r7, #24
 8027434:	46bd      	mov	sp, r7
 8027436:	bd80      	pop	{r7, pc}

08027438 <mp_reverse>:
#endif


/* reverse an array, used for radix code */
void mp_reverse(unsigned char *s, int len)
{
 8027438:	b480      	push	{r7}
 802743a:	b087      	sub	sp, #28
 802743c:	af00      	add	r7, sp, #0
 802743e:	6078      	str	r0, [r7, #4]
 8027440:	6039      	str	r1, [r7, #0]
    int ix, iy;

    if (s == NULL)
 8027442:	687b      	ldr	r3, [r7, #4]
 8027444:	2b00      	cmp	r3, #0
 8027446:	d022      	beq.n	802748e <mp_reverse+0x56>
        return;

    ix = 0;
 8027448:	2300      	movs	r3, #0
 802744a:	617b      	str	r3, [r7, #20]
    iy = len - 1;
 802744c:	683b      	ldr	r3, [r7, #0]
 802744e:	3b01      	subs	r3, #1
 8027450:	613b      	str	r3, [r7, #16]
    while (ix < iy) {
 8027452:	e017      	b.n	8027484 <mp_reverse+0x4c>
        unsigned char t = s[ix];
 8027454:	697b      	ldr	r3, [r7, #20]
 8027456:	687a      	ldr	r2, [r7, #4]
 8027458:	4413      	add	r3, r2
 802745a:	781b      	ldrb	r3, [r3, #0]
 802745c:	73fb      	strb	r3, [r7, #15]
        s[ix] = s[iy];
 802745e:	693b      	ldr	r3, [r7, #16]
 8027460:	687a      	ldr	r2, [r7, #4]
 8027462:	441a      	add	r2, r3
 8027464:	697b      	ldr	r3, [r7, #20]
 8027466:	6879      	ldr	r1, [r7, #4]
 8027468:	440b      	add	r3, r1
 802746a:	7812      	ldrb	r2, [r2, #0]
 802746c:	701a      	strb	r2, [r3, #0]
        s[iy] = t;
 802746e:	693b      	ldr	r3, [r7, #16]
 8027470:	687a      	ldr	r2, [r7, #4]
 8027472:	4413      	add	r3, r2
 8027474:	7bfa      	ldrb	r2, [r7, #15]
 8027476:	701a      	strb	r2, [r3, #0]
        ++ix;
 8027478:	697b      	ldr	r3, [r7, #20]
 802747a:	3301      	adds	r3, #1
 802747c:	617b      	str	r3, [r7, #20]
        --iy;
 802747e:	693b      	ldr	r3, [r7, #16]
 8027480:	3b01      	subs	r3, #1
 8027482:	613b      	str	r3, [r7, #16]
    while (ix < iy) {
 8027484:	697a      	ldr	r2, [r7, #20]
 8027486:	693b      	ldr	r3, [r7, #16]
 8027488:	429a      	cmp	r2, r3
 802748a:	dbe3      	blt.n	8027454 <mp_reverse+0x1c>
 802748c:	e000      	b.n	8027490 <mp_reverse+0x58>
        return;
 802748e:	bf00      	nop
    }
}
 8027490:	371c      	adds	r7, #28
 8027492:	46bd      	mov	sp, r7
 8027494:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027498:	4770      	bx	lr

0802749a <get_digit_count>:

int get_digit_count(const mp_int* a)
{
 802749a:	b480      	push	{r7}
 802749c:	b083      	sub	sp, #12
 802749e:	af00      	add	r7, sp, #0
 80274a0:	6078      	str	r0, [r7, #4]
    if (a == NULL)
 80274a2:	687b      	ldr	r3, [r7, #4]
 80274a4:	2b00      	cmp	r3, #0
 80274a6:	d101      	bne.n	80274ac <get_digit_count+0x12>
        return 0;
 80274a8:	2300      	movs	r3, #0
 80274aa:	e001      	b.n	80274b0 <get_digit_count+0x16>

    return (int)a->used;
 80274ac:	687b      	ldr	r3, [r7, #4]
 80274ae:	681b      	ldr	r3, [r3, #0]
}
 80274b0:	4618      	mov	r0, r3
 80274b2:	370c      	adds	r7, #12
 80274b4:	46bd      	mov	sp, r7
 80274b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80274ba:	4770      	bx	lr

080274bc <get_digit>:

mp_digit get_digit(const mp_int* a, int n)
{
 80274bc:	b480      	push	{r7}
 80274be:	b083      	sub	sp, #12
 80274c0:	af00      	add	r7, sp, #0
 80274c2:	6078      	str	r0, [r7, #4]
 80274c4:	6039      	str	r1, [r7, #0]
    if (a == NULL)
 80274c6:	687b      	ldr	r3, [r7, #4]
 80274c8:	2b00      	cmp	r3, #0
 80274ca:	d101      	bne.n	80274d0 <get_digit+0x14>
        return 0;
 80274cc:	2300      	movs	r3, #0
 80274ce:	e010      	b.n	80274f2 <get_digit+0x36>

    return (n < 0 || (unsigned int)n >= (unsigned int)a->used) ? 0 : a->dp[n];
 80274d0:	683b      	ldr	r3, [r7, #0]
 80274d2:	2b00      	cmp	r3, #0
 80274d4:	db0c      	blt.n	80274f0 <get_digit+0x34>
 80274d6:	687b      	ldr	r3, [r7, #4]
 80274d8:	681b      	ldr	r3, [r3, #0]
 80274da:	461a      	mov	r2, r3
 80274dc:	683b      	ldr	r3, [r7, #0]
 80274de:	429a      	cmp	r2, r3
 80274e0:	d906      	bls.n	80274f0 <get_digit+0x34>
 80274e2:	687a      	ldr	r2, [r7, #4]
 80274e4:	683b      	ldr	r3, [r7, #0]
 80274e6:	3302      	adds	r3, #2
 80274e8:	009b      	lsls	r3, r3, #2
 80274ea:	4413      	add	r3, r2
 80274ec:	685b      	ldr	r3, [r3, #4]
 80274ee:	e000      	b.n	80274f2 <get_digit+0x36>
 80274f0:	2300      	movs	r3, #0
}
 80274f2:	4618      	mov	r0, r3
 80274f4:	370c      	adds	r7, #12
 80274f6:	46bd      	mov	sp, r7
 80274f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80274fc:	4770      	bx	lr

080274fe <mp_cond_copy>:
 * b     MP integer to copy into.
 * returns BAD_FUNC_ARG when a or b is NULL, MEMORY_E when growing b fails and
 *         MP_OKAY otherwise.
 */
int mp_cond_copy(mp_int* a, int copy, mp_int* b)
{
 80274fe:	b590      	push	{r4, r7, lr}
 8027500:	b089      	sub	sp, #36	@ 0x24
 8027502:	af00      	add	r7, sp, #0
 8027504:	60f8      	str	r0, [r7, #12]
 8027506:	60b9      	str	r1, [r7, #8]
 8027508:	607a      	str	r2, [r7, #4]
    int err = MP_OKAY;
 802750a:	2300      	movs	r3, #0
 802750c:	61fb      	str	r3, [r7, #28]
#if defined(SP_WORD_SIZE) && SP_WORD_SIZE == 8
    unsigned int mask = (unsigned int)0 - copy;
#else
    mp_digit mask = (mp_digit)0 - (mp_digit)copy;
 802750e:	68bb      	ldr	r3, [r7, #8]
 8027510:	425b      	negs	r3, r3
 8027512:	617b      	str	r3, [r7, #20]
#endif

    if (a == NULL || b == NULL)
 8027514:	68fb      	ldr	r3, [r7, #12]
 8027516:	2b00      	cmp	r3, #0
 8027518:	d002      	beq.n	8027520 <mp_cond_copy+0x22>
 802751a:	687b      	ldr	r3, [r7, #4]
 802751c:	2b00      	cmp	r3, #0
 802751e:	d102      	bne.n	8027526 <mp_cond_copy+0x28>
        err = BAD_FUNC_ARG;
 8027520:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8027524:	61fb      	str	r3, [r7, #28]

    /* Ensure b has enough space to copy a into */
    if (err == MP_OKAY)
 8027526:	69fb      	ldr	r3, [r7, #28]
 8027528:	2b00      	cmp	r3, #0
 802752a:	d101      	bne.n	8027530 <mp_cond_copy+0x32>
        err = mp_grow(b, (int)a->used + 1);
 802752c:	2300      	movs	r3, #0
 802752e:	61fb      	str	r3, [r7, #28]
    if (err == MP_OKAY) {
 8027530:	69fb      	ldr	r3, [r7, #28]
 8027532:	2b00      	cmp	r3, #0
 8027534:	d161      	bne.n	80275fa <mp_cond_copy+0xfc>
         * When mask all set, b ^ b ^ a = a
         */
        /* Conditionally copy all digits and then number of used digits.
         * get_digit() returns 0 when index greater than available digit.
         */
        for (i = 0; i < a->used; i++) {
 8027536:	2300      	movs	r3, #0
 8027538:	61bb      	str	r3, [r7, #24]
 802753a:	e01d      	b.n	8027578 <mp_cond_copy+0x7a>
            b->dp[i] ^= (get_digit(a, (int)i) ^ get_digit(b, (int)i)) & mask;
 802753c:	69b9      	ldr	r1, [r7, #24]
 802753e:	68f8      	ldr	r0, [r7, #12]
 8027540:	f7ff ffbc 	bl	80274bc <get_digit>
 8027544:	4604      	mov	r4, r0
 8027546:	69b9      	ldr	r1, [r7, #24]
 8027548:	6878      	ldr	r0, [r7, #4]
 802754a:	f7ff ffb7 	bl	80274bc <get_digit>
 802754e:	4603      	mov	r3, r0
 8027550:	ea84 0203 	eor.w	r2, r4, r3
 8027554:	697b      	ldr	r3, [r7, #20]
 8027556:	401a      	ands	r2, r3
 8027558:	6879      	ldr	r1, [r7, #4]
 802755a:	69bb      	ldr	r3, [r7, #24]
 802755c:	3302      	adds	r3, #2
 802755e:	009b      	lsls	r3, r3, #2
 8027560:	440b      	add	r3, r1
 8027562:	685b      	ldr	r3, [r3, #4]
 8027564:	405a      	eors	r2, r3
 8027566:	6879      	ldr	r1, [r7, #4]
 8027568:	69bb      	ldr	r3, [r7, #24]
 802756a:	3302      	adds	r3, #2
 802756c:	009b      	lsls	r3, r3, #2
 802756e:	440b      	add	r3, r1
 8027570:	605a      	str	r2, [r3, #4]
        for (i = 0; i < a->used; i++) {
 8027572:	69bb      	ldr	r3, [r7, #24]
 8027574:	3301      	adds	r3, #1
 8027576:	61bb      	str	r3, [r7, #24]
 8027578:	68fb      	ldr	r3, [r7, #12]
 802757a:	681b      	ldr	r3, [r3, #0]
 802757c:	69ba      	ldr	r2, [r7, #24]
 802757e:	429a      	cmp	r2, r3
 8027580:	dbdc      	blt.n	802753c <mp_cond_copy+0x3e>
        }
        for (; i < b->used; i++) {
 8027582:	e01d      	b.n	80275c0 <mp_cond_copy+0xc2>
            b->dp[i] ^= (get_digit(a, (int)i) ^ get_digit(b, (int)i)) & mask;
 8027584:	69b9      	ldr	r1, [r7, #24]
 8027586:	68f8      	ldr	r0, [r7, #12]
 8027588:	f7ff ff98 	bl	80274bc <get_digit>
 802758c:	4604      	mov	r4, r0
 802758e:	69b9      	ldr	r1, [r7, #24]
 8027590:	6878      	ldr	r0, [r7, #4]
 8027592:	f7ff ff93 	bl	80274bc <get_digit>
 8027596:	4603      	mov	r3, r0
 8027598:	ea84 0203 	eor.w	r2, r4, r3
 802759c:	697b      	ldr	r3, [r7, #20]
 802759e:	401a      	ands	r2, r3
 80275a0:	6879      	ldr	r1, [r7, #4]
 80275a2:	69bb      	ldr	r3, [r7, #24]
 80275a4:	3302      	adds	r3, #2
 80275a6:	009b      	lsls	r3, r3, #2
 80275a8:	440b      	add	r3, r1
 80275aa:	685b      	ldr	r3, [r3, #4]
 80275ac:	405a      	eors	r2, r3
 80275ae:	6879      	ldr	r1, [r7, #4]
 80275b0:	69bb      	ldr	r3, [r7, #24]
 80275b2:	3302      	adds	r3, #2
 80275b4:	009b      	lsls	r3, r3, #2
 80275b6:	440b      	add	r3, r1
 80275b8:	605a      	str	r2, [r3, #4]
        for (; i < b->used; i++) {
 80275ba:	69bb      	ldr	r3, [r7, #24]
 80275bc:	3301      	adds	r3, #1
 80275be:	61bb      	str	r3, [r7, #24]
 80275c0:	687b      	ldr	r3, [r7, #4]
 80275c2:	681b      	ldr	r3, [r3, #0]
 80275c4:	69ba      	ldr	r2, [r7, #24]
 80275c6:	429a      	cmp	r2, r3
 80275c8:	dbdc      	blt.n	8027584 <mp_cond_copy+0x86>
        }
        b->used ^= (a->used ^ b->used) & (wc_mp_size_t)mask;
 80275ca:	687b      	ldr	r3, [r7, #4]
 80275cc:	681a      	ldr	r2, [r3, #0]
 80275ce:	68fb      	ldr	r3, [r7, #12]
 80275d0:	6819      	ldr	r1, [r3, #0]
 80275d2:	687b      	ldr	r3, [r7, #4]
 80275d4:	681b      	ldr	r3, [r3, #0]
 80275d6:	4059      	eors	r1, r3
 80275d8:	697b      	ldr	r3, [r7, #20]
 80275da:	400b      	ands	r3, r1
 80275dc:	405a      	eors	r2, r3
 80275de:	687b      	ldr	r3, [r7, #4]
 80275e0:	601a      	str	r2, [r3, #0]
#if (!defined(WOLFSSL_SP_MATH) && !defined(WOLFSSL_SP_MATH_ALL)) || \
    defined(WOLFSSL_SP_INT_NEGATIVE)
        b->sign ^= (wc_mp_sign_t)(a->sign ^ b->sign) & (wc_mp_sign_t)mask;
 80275e2:	687b      	ldr	r3, [r7, #4]
 80275e4:	685a      	ldr	r2, [r3, #4]
 80275e6:	68fb      	ldr	r3, [r7, #12]
 80275e8:	6859      	ldr	r1, [r3, #4]
 80275ea:	687b      	ldr	r3, [r7, #4]
 80275ec:	685b      	ldr	r3, [r3, #4]
 80275ee:	4059      	eors	r1, r3
 80275f0:	697b      	ldr	r3, [r7, #20]
 80275f2:	400b      	ands	r3, r1
 80275f4:	405a      	eors	r2, r3
 80275f6:	687b      	ldr	r3, [r7, #4]
 80275f8:	605a      	str	r2, [r3, #4]
#endif
    }

    return err;
 80275fa:	69fb      	ldr	r3, [r7, #28]
}
 80275fc:	4618      	mov	r0, r3
 80275fe:	3724      	adds	r7, #36	@ 0x24
 8027600:	46bd      	mov	sp, r7
 8027602:	bd90      	pop	{r4, r7, pc}

08027604 <get_rand_digit>:
#endif /* HAVE_ECC || WOLFSSL_MP_COND_COPY */


#ifndef WC_NO_RNG
int get_rand_digit(WC_RNG* rng, mp_digit* d)
{
 8027604:	b580      	push	{r7, lr}
 8027606:	b082      	sub	sp, #8
 8027608:	af00      	add	r7, sp, #0
 802760a:	6078      	str	r0, [r7, #4]
 802760c:	6039      	str	r1, [r7, #0]
    return wc_RNG_GenerateBlock(rng, (byte*)d, sizeof(mp_digit));
 802760e:	2204      	movs	r2, #4
 8027610:	6839      	ldr	r1, [r7, #0]
 8027612:	6878      	ldr	r0, [r7, #4]
 8027614:	f7f7 ffbf 	bl	801f596 <wc_RNG_GenerateBlock>
 8027618:	4603      	mov	r3, r0
}
 802761a:	4618      	mov	r0, r3
 802761c:	3708      	adds	r7, #8
 802761e:	46bd      	mov	sp, r7
 8027620:	bd80      	pop	{r7, pc}

08027622 <mp_rand>:

int mp_rand(mp_int* a, int digits, WC_RNG* rng)
{
 8027622:	b580      	push	{r7, lr}
 8027624:	b086      	sub	sp, #24
 8027626:	af00      	add	r7, sp, #0
 8027628:	60f8      	str	r0, [r7, #12]
 802762a:	60b9      	str	r1, [r7, #8]
 802762c:	607a      	str	r2, [r7, #4]
    int ret = 0;
 802762e:	2300      	movs	r3, #0
 8027630:	617b      	str	r3, [r7, #20]
    int cnt = digits * (int)sizeof(mp_digit);
 8027632:	68bb      	ldr	r3, [r7, #8]
 8027634:	009b      	lsls	r3, r3, #2
 8027636:	613b      	str	r3, [r7, #16]

    if (rng == NULL) {
 8027638:	687b      	ldr	r3, [r7, #4]
 802763a:	2b00      	cmp	r3, #0
 802763c:	d103      	bne.n	8027646 <mp_rand+0x24>
        ret = MISSING_RNG_E;
 802763e:	f06f 03eb 	mvn.w	r3, #235	@ 0xeb
 8027642:	617b      	str	r3, [r7, #20]
 8027644:	e008      	b.n	8027658 <mp_rand+0x36>
    }
    else if (a == NULL || digits <= 0) {
 8027646:	68fb      	ldr	r3, [r7, #12]
 8027648:	2b00      	cmp	r3, #0
 802764a:	d002      	beq.n	8027652 <mp_rand+0x30>
 802764c:	68bb      	ldr	r3, [r7, #8]
 802764e:	2b00      	cmp	r3, #0
 8027650:	dc02      	bgt.n	8027658 <mp_rand+0x36>
        ret = BAD_FUNC_ARG;
 8027652:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8027656:	617b      	str	r3, [r7, #20]
    }
#else
#if defined(WOLFSSL_SP_MATH) || defined(WOLFSSL_SP_MATH_ALL)
    if ((ret == MP_OKAY) && ((unsigned int)digits > a->size))
#else
    if ((ret == MP_OKAY) && (digits > FP_SIZE))
 8027658:	697b      	ldr	r3, [r7, #20]
 802765a:	2b00      	cmp	r3, #0
 802765c:	d105      	bne.n	802766a <mp_rand+0x48>
 802765e:	68bb      	ldr	r3, [r7, #8]
 8027660:	2b88      	cmp	r3, #136	@ 0x88
 8027662:	dd02      	ble.n	802766a <mp_rand+0x48>
#endif
    {
        ret = BAD_FUNC_ARG;
 8027664:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8027668:	617b      	str	r3, [r7, #20]
    }
    if (ret == MP_OKAY) {
 802766a:	697b      	ldr	r3, [r7, #20]
 802766c:	2b00      	cmp	r3, #0
 802766e:	d102      	bne.n	8027676 <mp_rand+0x54>
        a->used = (wc_mp_size_t)digits;
 8027670:	68fb      	ldr	r3, [r7, #12]
 8027672:	68ba      	ldr	r2, [r7, #8]
 8027674:	601a      	str	r2, [r3, #0]
    }
#endif
    /* fill the data with random bytes */
    if (ret == MP_OKAY) {
 8027676:	697b      	ldr	r3, [r7, #20]
 8027678:	2b00      	cmp	r3, #0
 802767a:	d107      	bne.n	802768c <mp_rand+0x6a>
        ret = wc_RNG_GenerateBlock(rng, (byte*)a->dp, (word32)cnt);
 802767c:	68fb      	ldr	r3, [r7, #12]
 802767e:	330c      	adds	r3, #12
 8027680:	693a      	ldr	r2, [r7, #16]
 8027682:	4619      	mov	r1, r3
 8027684:	6878      	ldr	r0, [r7, #4]
 8027686:	f7f7 ff86 	bl	801f596 <wc_RNG_GenerateBlock>
 802768a:	6178      	str	r0, [r7, #20]
    }
    if (ret == MP_OKAY) {
 802768c:	697b      	ldr	r3, [r7, #20]
 802768e:	2b00      	cmp	r3, #0
 8027690:	d11a      	bne.n	80276c8 <mp_rand+0xa6>
        for (i = 0; i < a->used; i++) {
            a->dp[i] &= MP_MASK;
        }
#endif
        /* ensure top digit is not zero */
        while ((ret == MP_OKAY) && (a->dp[a->used - 1] == 0)) {
 8027692:	e00c      	b.n	80276ae <mp_rand+0x8c>
            ret = get_rand_digit(rng, &a->dp[a->used - 1]);
 8027694:	68fb      	ldr	r3, [r7, #12]
 8027696:	681b      	ldr	r3, [r3, #0]
 8027698:	3b01      	subs	r3, #1
 802769a:	3302      	adds	r3, #2
 802769c:	009b      	lsls	r3, r3, #2
 802769e:	68fa      	ldr	r2, [r7, #12]
 80276a0:	4413      	add	r3, r2
 80276a2:	3304      	adds	r3, #4
 80276a4:	4619      	mov	r1, r3
 80276a6:	6878      	ldr	r0, [r7, #4]
 80276a8:	f7ff ffac 	bl	8027604 <get_rand_digit>
 80276ac:	6178      	str	r0, [r7, #20]
        while ((ret == MP_OKAY) && (a->dp[a->used - 1] == 0)) {
 80276ae:	697b      	ldr	r3, [r7, #20]
 80276b0:	2b00      	cmp	r3, #0
 80276b2:	d109      	bne.n	80276c8 <mp_rand+0xa6>
 80276b4:	68fb      	ldr	r3, [r7, #12]
 80276b6:	681b      	ldr	r3, [r3, #0]
 80276b8:	3b01      	subs	r3, #1
 80276ba:	68fa      	ldr	r2, [r7, #12]
 80276bc:	3302      	adds	r3, #2
 80276be:	009b      	lsls	r3, r3, #2
 80276c0:	4413      	add	r3, r2
 80276c2:	685b      	ldr	r3, [r3, #4]
 80276c4:	2b00      	cmp	r3, #0
 80276c6:	d0e5      	beq.n	8027694 <mp_rand+0x72>
            a->dp[a->used - 1] &= MP_MASK;
#endif
        }
    }

    return ret;
 80276c8:	697b      	ldr	r3, [r7, #20]
}
 80276ca:	4618      	mov	r0, r3
 80276cc:	3718      	adds	r7, #24
 80276ce:	46bd      	mov	sp, r7
 80276d0:	bd80      	pop	{r7, pc}
	...

080276d4 <MX_USB_DEVICE_Init>:
/**
  * Init USB device Library, add supported class and start the library
  * @retval None
  */
void MX_USB_DEVICE_Init(void)
{
 80276d4:	b580      	push	{r7, lr}
 80276d6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN USB_DEVICE_Init_PreTreatment */

  /* USER CODE END USB_DEVICE_Init_PreTreatment */

  /* Init Device Library, add supported class and start the library. */
  if (USBD_Init(&hUsbDeviceFS, &FS_Desc, DEVICE_FS) != USBD_OK)
 80276d8:	2200      	movs	r2, #0
 80276da:	4912      	ldr	r1, [pc, #72]	@ (8027724 <MX_USB_DEVICE_Init+0x50>)
 80276dc:	4812      	ldr	r0, [pc, #72]	@ (8027728 <MX_USB_DEVICE_Init+0x54>)
 80276de:	f7df fdd5 	bl	800728c <USBD_Init>
 80276e2:	4603      	mov	r3, r0
 80276e4:	2b00      	cmp	r3, #0
 80276e6:	d001      	beq.n	80276ec <MX_USB_DEVICE_Init+0x18>
  {
    Error_Handler();
 80276e8:	f7da f88a 	bl	8001800 <Error_Handler>
  }
  if (USBD_RegisterClass(&hUsbDeviceFS, &USBD_CDC) != USBD_OK)
 80276ec:	490f      	ldr	r1, [pc, #60]	@ (802772c <MX_USB_DEVICE_Init+0x58>)
 80276ee:	480e      	ldr	r0, [pc, #56]	@ (8027728 <MX_USB_DEVICE_Init+0x54>)
 80276f0:	f7df fdfc 	bl	80072ec <USBD_RegisterClass>
 80276f4:	4603      	mov	r3, r0
 80276f6:	2b00      	cmp	r3, #0
 80276f8:	d001      	beq.n	80276fe <MX_USB_DEVICE_Init+0x2a>
  {
    Error_Handler();
 80276fa:	f7da f881 	bl	8001800 <Error_Handler>
  }
  if (USBD_CDC_RegisterInterface(&hUsbDeviceFS, &USBD_Interface_fops_FS) != USBD_OK)
 80276fe:	490c      	ldr	r1, [pc, #48]	@ (8027730 <MX_USB_DEVICE_Init+0x5c>)
 8027700:	4809      	ldr	r0, [pc, #36]	@ (8027728 <MX_USB_DEVICE_Init+0x54>)
 8027702:	f7df fcf3 	bl	80070ec <USBD_CDC_RegisterInterface>
 8027706:	4603      	mov	r3, r0
 8027708:	2b00      	cmp	r3, #0
 802770a:	d001      	beq.n	8027710 <MX_USB_DEVICE_Init+0x3c>
  {
    Error_Handler();
 802770c:	f7da f878 	bl	8001800 <Error_Handler>
  }
  if (USBD_Start(&hUsbDeviceFS) != USBD_OK)
 8027710:	4805      	ldr	r0, [pc, #20]	@ (8027728 <MX_USB_DEVICE_Init+0x54>)
 8027712:	f7df fe21 	bl	8007358 <USBD_Start>
 8027716:	4603      	mov	r3, r0
 8027718:	2b00      	cmp	r3, #0
 802771a:	d001      	beq.n	8027720 <MX_USB_DEVICE_Init+0x4c>
  {
    Error_Handler();
 802771c:	f7da f870 	bl	8001800 <Error_Handler>
  }

  /* USER CODE BEGIN USB_DEVICE_Init_PostTreatment */

  /* USER CODE END USB_DEVICE_Init_PostTreatment */
}
 8027720:	bf00      	nop
 8027722:	bd80      	pop	{r7, pc}
 8027724:	200000e4 	.word	0x200000e4
 8027728:	20002910 	.word	0x20002910
 802772c:	20000030 	.word	0x20000030
 8027730:	200000d0 	.word	0x200000d0

08027734 <CDC_Init_FS>:
/**
  * @brief  Initializes the CDC media low layer over the FS USB IP
  * @retval USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Init_FS(void)
{
 8027734:	b580      	push	{r7, lr}
 8027736:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN 3 */
  /* Set Application Buffers */
  USBD_CDC_SetTxBuffer(&hUsbDeviceFS, UserTxBufferFS, 0);
 8027738:	2200      	movs	r2, #0
 802773a:	4905      	ldr	r1, [pc, #20]	@ (8027750 <CDC_Init_FS+0x1c>)
 802773c:	4805      	ldr	r0, [pc, #20]	@ (8027754 <CDC_Init_FS+0x20>)
 802773e:	f7df fcef 	bl	8007120 <USBD_CDC_SetTxBuffer>
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, UserRxBufferFS);
 8027742:	4905      	ldr	r1, [pc, #20]	@ (8027758 <CDC_Init_FS+0x24>)
 8027744:	4803      	ldr	r0, [pc, #12]	@ (8027754 <CDC_Init_FS+0x20>)
 8027746:	f7df fd0d 	bl	8007164 <USBD_CDC_SetRxBuffer>
  return (USBD_OK);
 802774a:	2300      	movs	r3, #0
  /* USER CODE END 3 */
}
 802774c:	4618      	mov	r0, r3
 802774e:	bd80      	pop	{r7, pc}
 8027750:	200033ec 	.word	0x200033ec
 8027754:	20002910 	.word	0x20002910
 8027758:	20002bec 	.word	0x20002bec

0802775c <CDC_DeInit_FS>:
/**
  * @brief  DeInitializes the CDC media low layer
  * @retval USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_DeInit_FS(void)
{
 802775c:	b480      	push	{r7}
 802775e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN 4 */
  return (USBD_OK);
 8027760:	2300      	movs	r3, #0
  /* USER CODE END 4 */
}
 8027762:	4618      	mov	r0, r3
 8027764:	46bd      	mov	sp, r7
 8027766:	f85d 7b04 	ldr.w	r7, [sp], #4
 802776a:	4770      	bx	lr

0802776c <CDC_Control_FS>:
  * @param  pbuf: Buffer containing command data (request parameters)
  * @param  length: Number of data to be sent (in bytes)
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Control_FS(uint8_t cmd, uint8_t* pbuf, uint16_t length)
{
 802776c:	b480      	push	{r7}
 802776e:	b083      	sub	sp, #12
 8027770:	af00      	add	r7, sp, #0
 8027772:	4603      	mov	r3, r0
 8027774:	6039      	str	r1, [r7, #0]
 8027776:	71fb      	strb	r3, [r7, #7]
 8027778:	4613      	mov	r3, r2
 802777a:	80bb      	strh	r3, [r7, #4]
  /* USER CODE BEGIN 5 */
  switch(cmd)
 802777c:	79fb      	ldrb	r3, [r7, #7]
 802777e:	2b23      	cmp	r3, #35	@ 0x23
 8027780:	f200 808c 	bhi.w	802789c <CDC_Control_FS+0x130>
 8027784:	a201      	add	r2, pc, #4	@ (adr r2, 802778c <CDC_Control_FS+0x20>)
 8027786:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 802778a:	bf00      	nop
 802778c:	0802789d 	.word	0x0802789d
 8027790:	0802789d 	.word	0x0802789d
 8027794:	0802789d 	.word	0x0802789d
 8027798:	0802789d 	.word	0x0802789d
 802779c:	0802789d 	.word	0x0802789d
 80277a0:	0802789d 	.word	0x0802789d
 80277a4:	0802789d 	.word	0x0802789d
 80277a8:	0802789d 	.word	0x0802789d
 80277ac:	0802789d 	.word	0x0802789d
 80277b0:	0802789d 	.word	0x0802789d
 80277b4:	0802789d 	.word	0x0802789d
 80277b8:	0802789d 	.word	0x0802789d
 80277bc:	0802789d 	.word	0x0802789d
 80277c0:	0802789d 	.word	0x0802789d
 80277c4:	0802789d 	.word	0x0802789d
 80277c8:	0802789d 	.word	0x0802789d
 80277cc:	0802789d 	.word	0x0802789d
 80277d0:	0802789d 	.word	0x0802789d
 80277d4:	0802789d 	.word	0x0802789d
 80277d8:	0802789d 	.word	0x0802789d
 80277dc:	0802789d 	.word	0x0802789d
 80277e0:	0802789d 	.word	0x0802789d
 80277e4:	0802789d 	.word	0x0802789d
 80277e8:	0802789d 	.word	0x0802789d
 80277ec:	0802789d 	.word	0x0802789d
 80277f0:	0802789d 	.word	0x0802789d
 80277f4:	0802789d 	.word	0x0802789d
 80277f8:	0802789d 	.word	0x0802789d
 80277fc:	0802789d 	.word	0x0802789d
 8027800:	0802789d 	.word	0x0802789d
 8027804:	0802789d 	.word	0x0802789d
 8027808:	0802789d 	.word	0x0802789d
 802780c:	0802781d 	.word	0x0802781d
 8027810:	08027857 	.word	0x08027857
 8027814:	0802789d 	.word	0x0802789d
 8027818:	0802789d 	.word	0x0802789d
  /*                                        3 - Mark                             */
  /*                                        4 - Space                            */
  /* 6      | bDataBits  |   1   | Number Data bits (5, 6, 7, 8 or 16).          */
  /*******************************************************************************/
    case CDC_SET_LINE_CODING:
    	temp[0] = pbuf[0];
 802781c:	683b      	ldr	r3, [r7, #0]
 802781e:	781a      	ldrb	r2, [r3, #0]
 8027820:	4b22      	ldr	r3, [pc, #136]	@ (80278ac <CDC_Control_FS+0x140>)
 8027822:	701a      	strb	r2, [r3, #0]
    	temp[1] = pbuf[1];
 8027824:	683b      	ldr	r3, [r7, #0]
 8027826:	785a      	ldrb	r2, [r3, #1]
 8027828:	4b20      	ldr	r3, [pc, #128]	@ (80278ac <CDC_Control_FS+0x140>)
 802782a:	705a      	strb	r2, [r3, #1]
    	temp[2] = pbuf[2];
 802782c:	683b      	ldr	r3, [r7, #0]
 802782e:	789a      	ldrb	r2, [r3, #2]
 8027830:	4b1e      	ldr	r3, [pc, #120]	@ (80278ac <CDC_Control_FS+0x140>)
 8027832:	709a      	strb	r2, [r3, #2]
    	temp[3] = pbuf[3];
 8027834:	683b      	ldr	r3, [r7, #0]
 8027836:	78da      	ldrb	r2, [r3, #3]
 8027838:	4b1c      	ldr	r3, [pc, #112]	@ (80278ac <CDC_Control_FS+0x140>)
 802783a:	70da      	strb	r2, [r3, #3]
    	temp[4] = pbuf[4];
 802783c:	683b      	ldr	r3, [r7, #0]
 802783e:	791a      	ldrb	r2, [r3, #4]
 8027840:	4b1a      	ldr	r3, [pc, #104]	@ (80278ac <CDC_Control_FS+0x140>)
 8027842:	711a      	strb	r2, [r3, #4]
    	temp[5] = pbuf[5];
 8027844:	683b      	ldr	r3, [r7, #0]
 8027846:	795a      	ldrb	r2, [r3, #5]
 8027848:	4b18      	ldr	r3, [pc, #96]	@ (80278ac <CDC_Control_FS+0x140>)
 802784a:	715a      	strb	r2, [r3, #5]
    	temp[6] = pbuf[6];
 802784c:	683b      	ldr	r3, [r7, #0]
 802784e:	799a      	ldrb	r2, [r3, #6]
 8027850:	4b16      	ldr	r3, [pc, #88]	@ (80278ac <CDC_Control_FS+0x140>)
 8027852:	719a      	strb	r2, [r3, #6]
    break;
 8027854:	e023      	b.n	802789e <CDC_Control_FS+0x132>

    case CDC_GET_LINE_CODING:
    	pbuf[0] = temp[0];
 8027856:	4b15      	ldr	r3, [pc, #84]	@ (80278ac <CDC_Control_FS+0x140>)
 8027858:	781a      	ldrb	r2, [r3, #0]
 802785a:	683b      	ldr	r3, [r7, #0]
 802785c:	701a      	strb	r2, [r3, #0]
    	pbuf[1] = temp[1];
 802785e:	683b      	ldr	r3, [r7, #0]
 8027860:	3301      	adds	r3, #1
 8027862:	4a12      	ldr	r2, [pc, #72]	@ (80278ac <CDC_Control_FS+0x140>)
 8027864:	7852      	ldrb	r2, [r2, #1]
 8027866:	701a      	strb	r2, [r3, #0]
    	pbuf[2] = temp[2];
 8027868:	683b      	ldr	r3, [r7, #0]
 802786a:	3302      	adds	r3, #2
 802786c:	4a0f      	ldr	r2, [pc, #60]	@ (80278ac <CDC_Control_FS+0x140>)
 802786e:	7892      	ldrb	r2, [r2, #2]
 8027870:	701a      	strb	r2, [r3, #0]
    	pbuf[3] = temp[3];
 8027872:	683b      	ldr	r3, [r7, #0]
 8027874:	3303      	adds	r3, #3
 8027876:	4a0d      	ldr	r2, [pc, #52]	@ (80278ac <CDC_Control_FS+0x140>)
 8027878:	78d2      	ldrb	r2, [r2, #3]
 802787a:	701a      	strb	r2, [r3, #0]
    	pbuf[4] = temp[4];
 802787c:	683b      	ldr	r3, [r7, #0]
 802787e:	3304      	adds	r3, #4
 8027880:	4a0a      	ldr	r2, [pc, #40]	@ (80278ac <CDC_Control_FS+0x140>)
 8027882:	7912      	ldrb	r2, [r2, #4]
 8027884:	701a      	strb	r2, [r3, #0]
    	pbuf[5] = temp[5];
 8027886:	683b      	ldr	r3, [r7, #0]
 8027888:	3305      	adds	r3, #5
 802788a:	4a08      	ldr	r2, [pc, #32]	@ (80278ac <CDC_Control_FS+0x140>)
 802788c:	7952      	ldrb	r2, [r2, #5]
 802788e:	701a      	strb	r2, [r3, #0]
    	pbuf[6] = temp[6];
 8027890:	683b      	ldr	r3, [r7, #0]
 8027892:	3306      	adds	r3, #6
 8027894:	4a05      	ldr	r2, [pc, #20]	@ (80278ac <CDC_Control_FS+0x140>)
 8027896:	7992      	ldrb	r2, [r2, #6]
 8027898:	701a      	strb	r2, [r3, #0]
    break;
 802789a:	e000      	b.n	802789e <CDC_Control_FS+0x132>
    case CDC_SEND_BREAK:

    break;

  default:
    break;
 802789c:	bf00      	nop
  }

  return (USBD_OK);
 802789e:	2300      	movs	r3, #0
  /* USER CODE END 5 */
}
 80278a0:	4618      	mov	r0, r3
 80278a2:	370c      	adds	r7, #12
 80278a4:	46bd      	mov	sp, r7
 80278a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80278aa:	4770      	bx	lr
 80278ac:	20003bec 	.word	0x20003bec

080278b0 <CDC_Receive_FS>:
  * @param  Buf: Buffer of data to be received
  * @param  Len: Number of data received (in bytes)
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Receive_FS(uint8_t* Buf, uint32_t *Len)
{
 80278b0:	b580      	push	{r7, lr}
 80278b2:	b082      	sub	sp, #8
 80278b4:	af00      	add	r7, sp, #0
 80278b6:	6078      	str	r0, [r7, #4]
 80278b8:	6039      	str	r1, [r7, #0]
  /* USER CODE BEGIN 6 */
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, &Buf[0]);
 80278ba:	6879      	ldr	r1, [r7, #4]
 80278bc:	4823      	ldr	r0, [pc, #140]	@ (802794c <CDC_Receive_FS+0x9c>)
 80278be:	f7df fc51 	bl	8007164 <USBD_CDC_SetRxBuffer>
  USBD_CDC_ReceivePacket(&hUsbDeviceFS);
 80278c2:	4822      	ldr	r0, [pc, #136]	@ (802794c <CDC_Receive_FS+0x9c>)
 80278c4:	f7df fcac 	bl	8007220 <USBD_CDC_ReceivePacket>
  if (*Len == 0 || Buf == NULL) return USBD_OK;
 80278c8:	683b      	ldr	r3, [r7, #0]
 80278ca:	681b      	ldr	r3, [r3, #0]
 80278cc:	2b00      	cmp	r3, #0
 80278ce:	d002      	beq.n	80278d6 <CDC_Receive_FS+0x26>
 80278d0:	687b      	ldr	r3, [r7, #4]
 80278d2:	2b00      	cmp	r3, #0
 80278d4:	d101      	bne.n	80278da <CDC_Receive_FS+0x2a>
 80278d6:	2300      	movs	r3, #0
 80278d8:	e033      	b.n	8027942 <CDC_Receive_FS+0x92>
  // spravy sa prijimaju po 64 bytovych kuskoch - paketoch.
  // po odoslani celej spravy posielam dalsiu, ktora sa sklada iba zo znaku '\r', teda dlzka je 1.
  // teoreticky moze nastat edge case kedy povodna sprava sa tak rozkuskuje,
  // ze posledny byte spravy pride sam a sklada sa iba z '\r' co vtedy by nastal problem, ale pre zatial sa to neoplati riesit.
  // uz len to ze som mal pripad ze prijaty paket sa zacina prave na '\r' je celkom uletene.
  if (Buf[0] == '\r' && *Len == 1) {
 80278da:	687b      	ldr	r3, [r7, #4]
 80278dc:	781b      	ldrb	r3, [r3, #0]
 80278de:	2b0d      	cmp	r3, #13
 80278e0:	d108      	bne.n	80278f4 <CDC_Receive_FS+0x44>
 80278e2:	683b      	ldr	r3, [r7, #0]
 80278e4:	681b      	ldr	r3, [r3, #0]
 80278e6:	2b01      	cmp	r3, #1
 80278e8:	d104      	bne.n	80278f4 <CDC_Receive_FS+0x44>
      dataReceivedFlag = 1;
 80278ea:	4b19      	ldr	r3, [pc, #100]	@ (8027950 <CDC_Receive_FS+0xa0>)
 80278ec:	2201      	movs	r2, #1
 80278ee:	701a      	strb	r2, [r3, #0]
      return USBD_OK;
 80278f0:	2300      	movs	r3, #0
 80278f2:	e026      	b.n	8027942 <CDC_Receive_FS+0x92>
  }
  // receiveBuffer ma velkost 2500, nie je to dobre ze je to takto hardcoded.
  // ale iba 3. sprava sa k tomu velkostne blizi.
  if ((receiveCounter + *Len) < 2500) {
 80278f4:	4b17      	ldr	r3, [pc, #92]	@ (8027954 <CDC_Receive_FS+0xa4>)
 80278f6:	881b      	ldrh	r3, [r3, #0]
 80278f8:	461a      	mov	r2, r3
 80278fa:	683b      	ldr	r3, [r7, #0]
 80278fc:	681b      	ldr	r3, [r3, #0]
 80278fe:	4413      	add	r3, r2
 8027900:	f640 12c3 	movw	r2, #2499	@ 0x9c3
 8027904:	4293      	cmp	r3, r2
 8027906:	d815      	bhi.n	8027934 <CDC_Receive_FS+0x84>
      memcpy(&receiveBuffer[receiveCounter], Buf, *Len);
 8027908:	4b12      	ldr	r3, [pc, #72]	@ (8027954 <CDC_Receive_FS+0xa4>)
 802790a:	881b      	ldrh	r3, [r3, #0]
 802790c:	461a      	mov	r2, r3
 802790e:	4b12      	ldr	r3, [pc, #72]	@ (8027958 <CDC_Receive_FS+0xa8>)
 8027910:	18d0      	adds	r0, r2, r3
 8027912:	683b      	ldr	r3, [r7, #0]
 8027914:	681b      	ldr	r3, [r3, #0]
 8027916:	461a      	mov	r2, r3
 8027918:	6879      	ldr	r1, [r7, #4]
 802791a:	f000 fe3f 	bl	802859c <memcpy>
      receiveCounter += *Len;
 802791e:	683b      	ldr	r3, [r7, #0]
 8027920:	681b      	ldr	r3, [r3, #0]
 8027922:	b29a      	uxth	r2, r3
 8027924:	4b0b      	ldr	r3, [pc, #44]	@ (8027954 <CDC_Receive_FS+0xa4>)
 8027926:	881b      	ldrh	r3, [r3, #0]
 8027928:	4413      	add	r3, r2
 802792a:	b29a      	uxth	r2, r3
 802792c:	4b09      	ldr	r3, [pc, #36]	@ (8027954 <CDC_Receive_FS+0xa4>)
 802792e:	801a      	strh	r2, [r3, #0]
      // Buffer overflow handler, to je asi nieco do buducna.
      receiveCounter = 0;
      dataReceivedFlag = 0;
      return USBD_FAIL;
  }
  return USBD_OK;
 8027930:	2300      	movs	r3, #0
 8027932:	e006      	b.n	8027942 <CDC_Receive_FS+0x92>
      receiveCounter = 0;
 8027934:	4b07      	ldr	r3, [pc, #28]	@ (8027954 <CDC_Receive_FS+0xa4>)
 8027936:	2200      	movs	r2, #0
 8027938:	801a      	strh	r2, [r3, #0]
      dataReceivedFlag = 0;
 802793a:	4b05      	ldr	r3, [pc, #20]	@ (8027950 <CDC_Receive_FS+0xa0>)
 802793c:	2200      	movs	r2, #0
 802793e:	701a      	strb	r2, [r3, #0]
      return USBD_FAIL;
 8027940:	2303      	movs	r3, #3
  /* USER CODE END 6 */
}
 8027942:	4618      	mov	r0, r3
 8027944:	3708      	adds	r7, #8
 8027946:	46bd      	mov	sp, r7
 8027948:	bd80      	pop	{r7, pc}
 802794a:	bf00      	nop
 802794c:	20002910 	.word	0x20002910
 8027950:	20001508 	.word	0x20001508
 8027954:	20001ed0 	.word	0x20001ed0
 8027958:	2000150c 	.word	0x2000150c

0802795c <CDC_Transmit_FS>:
  * @param  Buf: Buffer of data to be sent
  * @param  Len: Number of data to be sent (in bytes)
  * @retval USBD_OK if all operations are OK else USBD_FAIL or USBD_BUSY
  */
uint8_t CDC_Transmit_FS(uint8_t* Buf, uint16_t Len)
{
 802795c:	b580      	push	{r7, lr}
 802795e:	b084      	sub	sp, #16
 8027960:	af00      	add	r7, sp, #0
 8027962:	6078      	str	r0, [r7, #4]
 8027964:	460b      	mov	r3, r1
 8027966:	807b      	strh	r3, [r7, #2]
  uint8_t result = USBD_OK;
 8027968:	2300      	movs	r3, #0
 802796a:	73fb      	strb	r3, [r7, #15]
  /* USER CODE BEGIN 7 */
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef*)hUsbDeviceFS.pClassData;
 802796c:	4b0d      	ldr	r3, [pc, #52]	@ (80279a4 <CDC_Transmit_FS+0x48>)
 802796e:	f8d3 32bc 	ldr.w	r3, [r3, #700]	@ 0x2bc
 8027972:	60bb      	str	r3, [r7, #8]
  if (hcdc->TxState != 0){
 8027974:	68bb      	ldr	r3, [r7, #8]
 8027976:	f8d3 3214 	ldr.w	r3, [r3, #532]	@ 0x214
 802797a:	2b00      	cmp	r3, #0
 802797c:	d001      	beq.n	8027982 <CDC_Transmit_FS+0x26>
    return USBD_BUSY;
 802797e:	2301      	movs	r3, #1
 8027980:	e00b      	b.n	802799a <CDC_Transmit_FS+0x3e>
  }
  USBD_CDC_SetTxBuffer(&hUsbDeviceFS, Buf, Len);
 8027982:	887b      	ldrh	r3, [r7, #2]
 8027984:	461a      	mov	r2, r3
 8027986:	6879      	ldr	r1, [r7, #4]
 8027988:	4806      	ldr	r0, [pc, #24]	@ (80279a4 <CDC_Transmit_FS+0x48>)
 802798a:	f7df fbc9 	bl	8007120 <USBD_CDC_SetTxBuffer>
  result = USBD_CDC_TransmitPacket(&hUsbDeviceFS);
 802798e:	4805      	ldr	r0, [pc, #20]	@ (80279a4 <CDC_Transmit_FS+0x48>)
 8027990:	f7df fc06 	bl	80071a0 <USBD_CDC_TransmitPacket>
 8027994:	4603      	mov	r3, r0
 8027996:	73fb      	strb	r3, [r7, #15]
  /* USER CODE END 7 */
  return result;
 8027998:	7bfb      	ldrb	r3, [r7, #15]
}
 802799a:	4618      	mov	r0, r3
 802799c:	3710      	adds	r7, #16
 802799e:	46bd      	mov	sp, r7
 80279a0:	bd80      	pop	{r7, pc}
 80279a2:	bf00      	nop
 80279a4:	20002910 	.word	0x20002910

080279a8 <CDC_TransmitCplt_FS>:
  * @param  Buf: Buffer of data to be received
  * @param  Len: Number of data received (in bytes)
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_TransmitCplt_FS(uint8_t *Buf, uint32_t *Len, uint8_t epnum)
{
 80279a8:	b480      	push	{r7}
 80279aa:	b087      	sub	sp, #28
 80279ac:	af00      	add	r7, sp, #0
 80279ae:	60f8      	str	r0, [r7, #12]
 80279b0:	60b9      	str	r1, [r7, #8]
 80279b2:	4613      	mov	r3, r2
 80279b4:	71fb      	strb	r3, [r7, #7]
  uint8_t result = USBD_OK;
 80279b6:	2300      	movs	r3, #0
 80279b8:	75fb      	strb	r3, [r7, #23]
  /* USER CODE BEGIN 13 */
  UNUSED(Buf);
  UNUSED(Len);
  UNUSED(epnum);
  /* USER CODE END 13 */
  return result;
 80279ba:	f997 3017 	ldrsb.w	r3, [r7, #23]
}
 80279be:	4618      	mov	r0, r3
 80279c0:	371c      	adds	r7, #28
 80279c2:	46bd      	mov	sp, r7
 80279c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80279c8:	4770      	bx	lr
	...

080279cc <USBD_FS_DeviceDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_DeviceDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 80279cc:	b480      	push	{r7}
 80279ce:	b083      	sub	sp, #12
 80279d0:	af00      	add	r7, sp, #0
 80279d2:	4603      	mov	r3, r0
 80279d4:	6039      	str	r1, [r7, #0]
 80279d6:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  *length = sizeof(USBD_FS_DeviceDesc);
 80279d8:	683b      	ldr	r3, [r7, #0]
 80279da:	2212      	movs	r2, #18
 80279dc:	801a      	strh	r2, [r3, #0]
  return USBD_FS_DeviceDesc;
 80279de:	4b03      	ldr	r3, [pc, #12]	@ (80279ec <USBD_FS_DeviceDescriptor+0x20>)
}
 80279e0:	4618      	mov	r0, r3
 80279e2:	370c      	adds	r7, #12
 80279e4:	46bd      	mov	sp, r7
 80279e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80279ea:	4770      	bx	lr
 80279ec:	20000100 	.word	0x20000100

080279f0 <USBD_FS_LangIDStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_LangIDStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 80279f0:	b480      	push	{r7}
 80279f2:	b083      	sub	sp, #12
 80279f4:	af00      	add	r7, sp, #0
 80279f6:	4603      	mov	r3, r0
 80279f8:	6039      	str	r1, [r7, #0]
 80279fa:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  *length = sizeof(USBD_LangIDDesc);
 80279fc:	683b      	ldr	r3, [r7, #0]
 80279fe:	2204      	movs	r2, #4
 8027a00:	801a      	strh	r2, [r3, #0]
  return USBD_LangIDDesc;
 8027a02:	4b03      	ldr	r3, [pc, #12]	@ (8027a10 <USBD_FS_LangIDStrDescriptor+0x20>)
}
 8027a04:	4618      	mov	r0, r3
 8027a06:	370c      	adds	r7, #12
 8027a08:	46bd      	mov	sp, r7
 8027a0a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027a0e:	4770      	bx	lr
 8027a10:	20000114 	.word	0x20000114

08027a14 <USBD_FS_ProductStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_ProductStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8027a14:	b580      	push	{r7, lr}
 8027a16:	b082      	sub	sp, #8
 8027a18:	af00      	add	r7, sp, #0
 8027a1a:	4603      	mov	r3, r0
 8027a1c:	6039      	str	r1, [r7, #0]
 8027a1e:	71fb      	strb	r3, [r7, #7]
  if(speed == 0)
 8027a20:	79fb      	ldrb	r3, [r7, #7]
 8027a22:	2b00      	cmp	r3, #0
 8027a24:	d105      	bne.n	8027a32 <USBD_FS_ProductStrDescriptor+0x1e>
  {
    USBD_GetString((uint8_t *)USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 8027a26:	683a      	ldr	r2, [r7, #0]
 8027a28:	4907      	ldr	r1, [pc, #28]	@ (8027a48 <USBD_FS_ProductStrDescriptor+0x34>)
 8027a2a:	4808      	ldr	r0, [pc, #32]	@ (8027a4c <USBD_FS_ProductStrDescriptor+0x38>)
 8027a2c:	f7e0 fe44 	bl	80086b8 <USBD_GetString>
 8027a30:	e004      	b.n	8027a3c <USBD_FS_ProductStrDescriptor+0x28>
  }
  else
  {
    USBD_GetString((uint8_t *)USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 8027a32:	683a      	ldr	r2, [r7, #0]
 8027a34:	4904      	ldr	r1, [pc, #16]	@ (8027a48 <USBD_FS_ProductStrDescriptor+0x34>)
 8027a36:	4805      	ldr	r0, [pc, #20]	@ (8027a4c <USBD_FS_ProductStrDescriptor+0x38>)
 8027a38:	f7e0 fe3e 	bl	80086b8 <USBD_GetString>
  }
  return USBD_StrDesc;
 8027a3c:	4b02      	ldr	r3, [pc, #8]	@ (8027a48 <USBD_FS_ProductStrDescriptor+0x34>)
}
 8027a3e:	4618      	mov	r0, r3
 8027a40:	3708      	adds	r7, #8
 8027a42:	46bd      	mov	sp, r7
 8027a44:	bd80      	pop	{r7, pc}
 8027a46:	bf00      	nop
 8027a48:	20003bf4 	.word	0x20003bf4
 8027a4c:	0802ff50 	.word	0x0802ff50

08027a50 <USBD_FS_ManufacturerStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_ManufacturerStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8027a50:	b580      	push	{r7, lr}
 8027a52:	b082      	sub	sp, #8
 8027a54:	af00      	add	r7, sp, #0
 8027a56:	4603      	mov	r3, r0
 8027a58:	6039      	str	r1, [r7, #0]
 8027a5a:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  USBD_GetString((uint8_t *)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 8027a5c:	683a      	ldr	r2, [r7, #0]
 8027a5e:	4904      	ldr	r1, [pc, #16]	@ (8027a70 <USBD_FS_ManufacturerStrDescriptor+0x20>)
 8027a60:	4804      	ldr	r0, [pc, #16]	@ (8027a74 <USBD_FS_ManufacturerStrDescriptor+0x24>)
 8027a62:	f7e0 fe29 	bl	80086b8 <USBD_GetString>
  return USBD_StrDesc;
 8027a66:	4b02      	ldr	r3, [pc, #8]	@ (8027a70 <USBD_FS_ManufacturerStrDescriptor+0x20>)
}
 8027a68:	4618      	mov	r0, r3
 8027a6a:	3708      	adds	r7, #8
 8027a6c:	46bd      	mov	sp, r7
 8027a6e:	bd80      	pop	{r7, pc}
 8027a70:	20003bf4 	.word	0x20003bf4
 8027a74:	0802ff68 	.word	0x0802ff68

08027a78 <USBD_FS_SerialStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_SerialStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8027a78:	b580      	push	{r7, lr}
 8027a7a:	b082      	sub	sp, #8
 8027a7c:	af00      	add	r7, sp, #0
 8027a7e:	4603      	mov	r3, r0
 8027a80:	6039      	str	r1, [r7, #0]
 8027a82:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  *length = USB_SIZ_STRING_SERIAL;
 8027a84:	683b      	ldr	r3, [r7, #0]
 8027a86:	221a      	movs	r2, #26
 8027a88:	801a      	strh	r2, [r3, #0]

  /* Update the serial number string descriptor with the data from the unique
   * ID */
  Get_SerialNum();
 8027a8a:	f000 f843 	bl	8027b14 <Get_SerialNum>
  /* USER CODE BEGIN USBD_FS_SerialStrDescriptor */

  /* USER CODE END USBD_FS_SerialStrDescriptor */
  return (uint8_t *) USBD_StringSerial;
 8027a8e:	4b02      	ldr	r3, [pc, #8]	@ (8027a98 <USBD_FS_SerialStrDescriptor+0x20>)
}
 8027a90:	4618      	mov	r0, r3
 8027a92:	3708      	adds	r7, #8
 8027a94:	46bd      	mov	sp, r7
 8027a96:	bd80      	pop	{r7, pc}
 8027a98:	20000118 	.word	0x20000118

08027a9c <USBD_FS_ConfigStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_ConfigStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8027a9c:	b580      	push	{r7, lr}
 8027a9e:	b082      	sub	sp, #8
 8027aa0:	af00      	add	r7, sp, #0
 8027aa2:	4603      	mov	r3, r0
 8027aa4:	6039      	str	r1, [r7, #0]
 8027aa6:	71fb      	strb	r3, [r7, #7]
  if(speed == USBD_SPEED_HIGH)
 8027aa8:	79fb      	ldrb	r3, [r7, #7]
 8027aaa:	2b00      	cmp	r3, #0
 8027aac:	d105      	bne.n	8027aba <USBD_FS_ConfigStrDescriptor+0x1e>
  {
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 8027aae:	683a      	ldr	r2, [r7, #0]
 8027ab0:	4907      	ldr	r1, [pc, #28]	@ (8027ad0 <USBD_FS_ConfigStrDescriptor+0x34>)
 8027ab2:	4808      	ldr	r0, [pc, #32]	@ (8027ad4 <USBD_FS_ConfigStrDescriptor+0x38>)
 8027ab4:	f7e0 fe00 	bl	80086b8 <USBD_GetString>
 8027ab8:	e004      	b.n	8027ac4 <USBD_FS_ConfigStrDescriptor+0x28>
  }
  else
  {
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 8027aba:	683a      	ldr	r2, [r7, #0]
 8027abc:	4904      	ldr	r1, [pc, #16]	@ (8027ad0 <USBD_FS_ConfigStrDescriptor+0x34>)
 8027abe:	4805      	ldr	r0, [pc, #20]	@ (8027ad4 <USBD_FS_ConfigStrDescriptor+0x38>)
 8027ac0:	f7e0 fdfa 	bl	80086b8 <USBD_GetString>
  }
  return USBD_StrDesc;
 8027ac4:	4b02      	ldr	r3, [pc, #8]	@ (8027ad0 <USBD_FS_ConfigStrDescriptor+0x34>)
}
 8027ac6:	4618      	mov	r0, r3
 8027ac8:	3708      	adds	r7, #8
 8027aca:	46bd      	mov	sp, r7
 8027acc:	bd80      	pop	{r7, pc}
 8027ace:	bf00      	nop
 8027ad0:	20003bf4 	.word	0x20003bf4
 8027ad4:	0802ff7c 	.word	0x0802ff7c

08027ad8 <USBD_FS_InterfaceStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_InterfaceStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8027ad8:	b580      	push	{r7, lr}
 8027ada:	b082      	sub	sp, #8
 8027adc:	af00      	add	r7, sp, #0
 8027ade:	4603      	mov	r3, r0
 8027ae0:	6039      	str	r1, [r7, #0]
 8027ae2:	71fb      	strb	r3, [r7, #7]
  if(speed == 0)
 8027ae4:	79fb      	ldrb	r3, [r7, #7]
 8027ae6:	2b00      	cmp	r3, #0
 8027ae8:	d105      	bne.n	8027af6 <USBD_FS_InterfaceStrDescriptor+0x1e>
  {
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 8027aea:	683a      	ldr	r2, [r7, #0]
 8027aec:	4907      	ldr	r1, [pc, #28]	@ (8027b0c <USBD_FS_InterfaceStrDescriptor+0x34>)
 8027aee:	4808      	ldr	r0, [pc, #32]	@ (8027b10 <USBD_FS_InterfaceStrDescriptor+0x38>)
 8027af0:	f7e0 fde2 	bl	80086b8 <USBD_GetString>
 8027af4:	e004      	b.n	8027b00 <USBD_FS_InterfaceStrDescriptor+0x28>
  }
  else
  {
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 8027af6:	683a      	ldr	r2, [r7, #0]
 8027af8:	4904      	ldr	r1, [pc, #16]	@ (8027b0c <USBD_FS_InterfaceStrDescriptor+0x34>)
 8027afa:	4805      	ldr	r0, [pc, #20]	@ (8027b10 <USBD_FS_InterfaceStrDescriptor+0x38>)
 8027afc:	f7e0 fddc 	bl	80086b8 <USBD_GetString>
  }
  return USBD_StrDesc;
 8027b00:	4b02      	ldr	r3, [pc, #8]	@ (8027b0c <USBD_FS_InterfaceStrDescriptor+0x34>)
}
 8027b02:	4618      	mov	r0, r3
 8027b04:	3708      	adds	r7, #8
 8027b06:	46bd      	mov	sp, r7
 8027b08:	bd80      	pop	{r7, pc}
 8027b0a:	bf00      	nop
 8027b0c:	20003bf4 	.word	0x20003bf4
 8027b10:	0802ff88 	.word	0x0802ff88

08027b14 <Get_SerialNum>:
  * @brief  Create the serial number string descriptor
  * @param  None
  * @retval None
  */
static void Get_SerialNum(void)
{
 8027b14:	b580      	push	{r7, lr}
 8027b16:	b084      	sub	sp, #16
 8027b18:	af00      	add	r7, sp, #0
  uint32_t deviceserial0;
  uint32_t deviceserial1;
  uint32_t deviceserial2;

  deviceserial0 = *(uint32_t *) DEVICE_ID1;
 8027b1a:	4b0f      	ldr	r3, [pc, #60]	@ (8027b58 <Get_SerialNum+0x44>)
 8027b1c:	681b      	ldr	r3, [r3, #0]
 8027b1e:	60fb      	str	r3, [r7, #12]
  deviceserial1 = *(uint32_t *) DEVICE_ID2;
 8027b20:	4b0e      	ldr	r3, [pc, #56]	@ (8027b5c <Get_SerialNum+0x48>)
 8027b22:	681b      	ldr	r3, [r3, #0]
 8027b24:	60bb      	str	r3, [r7, #8]
  deviceserial2 = *(uint32_t *) DEVICE_ID3;
 8027b26:	4b0e      	ldr	r3, [pc, #56]	@ (8027b60 <Get_SerialNum+0x4c>)
 8027b28:	681b      	ldr	r3, [r3, #0]
 8027b2a:	607b      	str	r3, [r7, #4]

  deviceserial0 += deviceserial2;
 8027b2c:	68fa      	ldr	r2, [r7, #12]
 8027b2e:	687b      	ldr	r3, [r7, #4]
 8027b30:	4413      	add	r3, r2
 8027b32:	60fb      	str	r3, [r7, #12]

  if (deviceserial0 != 0)
 8027b34:	68fb      	ldr	r3, [r7, #12]
 8027b36:	2b00      	cmp	r3, #0
 8027b38:	d009      	beq.n	8027b4e <Get_SerialNum+0x3a>
  {
    IntToUnicode(deviceserial0, &USBD_StringSerial[2], 8);
 8027b3a:	2208      	movs	r2, #8
 8027b3c:	4909      	ldr	r1, [pc, #36]	@ (8027b64 <Get_SerialNum+0x50>)
 8027b3e:	68f8      	ldr	r0, [r7, #12]
 8027b40:	f000 f814 	bl	8027b6c <IntToUnicode>
    IntToUnicode(deviceserial1, &USBD_StringSerial[18], 4);
 8027b44:	2204      	movs	r2, #4
 8027b46:	4908      	ldr	r1, [pc, #32]	@ (8027b68 <Get_SerialNum+0x54>)
 8027b48:	68b8      	ldr	r0, [r7, #8]
 8027b4a:	f000 f80f 	bl	8027b6c <IntToUnicode>
  }
}
 8027b4e:	bf00      	nop
 8027b50:	3710      	adds	r7, #16
 8027b52:	46bd      	mov	sp, r7
 8027b54:	bd80      	pop	{r7, pc}
 8027b56:	bf00      	nop
 8027b58:	1fff7a10 	.word	0x1fff7a10
 8027b5c:	1fff7a14 	.word	0x1fff7a14
 8027b60:	1fff7a18 	.word	0x1fff7a18
 8027b64:	2000011a 	.word	0x2000011a
 8027b68:	2000012a 	.word	0x2000012a

08027b6c <IntToUnicode>:
  * @param  pbuf: pointer to the buffer
  * @param  len: buffer length
  * @retval None
  */
static void IntToUnicode(uint32_t value, uint8_t * pbuf, uint8_t len)
{
 8027b6c:	b480      	push	{r7}
 8027b6e:	b087      	sub	sp, #28
 8027b70:	af00      	add	r7, sp, #0
 8027b72:	60f8      	str	r0, [r7, #12]
 8027b74:	60b9      	str	r1, [r7, #8]
 8027b76:	4613      	mov	r3, r2
 8027b78:	71fb      	strb	r3, [r7, #7]
  uint8_t idx = 0;
 8027b7a:	2300      	movs	r3, #0
 8027b7c:	75fb      	strb	r3, [r7, #23]

  for (idx = 0; idx < len; idx++)
 8027b7e:	2300      	movs	r3, #0
 8027b80:	75fb      	strb	r3, [r7, #23]
 8027b82:	e027      	b.n	8027bd4 <IntToUnicode+0x68>
  {
    if (((value >> 28)) < 0xA)
 8027b84:	68fb      	ldr	r3, [r7, #12]
 8027b86:	0f1b      	lsrs	r3, r3, #28
 8027b88:	2b09      	cmp	r3, #9
 8027b8a:	d80b      	bhi.n	8027ba4 <IntToUnicode+0x38>
    {
      pbuf[2 * idx] = (value >> 28) + '0';
 8027b8c:	68fb      	ldr	r3, [r7, #12]
 8027b8e:	0f1b      	lsrs	r3, r3, #28
 8027b90:	b2da      	uxtb	r2, r3
 8027b92:	7dfb      	ldrb	r3, [r7, #23]
 8027b94:	005b      	lsls	r3, r3, #1
 8027b96:	4619      	mov	r1, r3
 8027b98:	68bb      	ldr	r3, [r7, #8]
 8027b9a:	440b      	add	r3, r1
 8027b9c:	3230      	adds	r2, #48	@ 0x30
 8027b9e:	b2d2      	uxtb	r2, r2
 8027ba0:	701a      	strb	r2, [r3, #0]
 8027ba2:	e00a      	b.n	8027bba <IntToUnicode+0x4e>
    }
    else
    {
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8027ba4:	68fb      	ldr	r3, [r7, #12]
 8027ba6:	0f1b      	lsrs	r3, r3, #28
 8027ba8:	b2da      	uxtb	r2, r3
 8027baa:	7dfb      	ldrb	r3, [r7, #23]
 8027bac:	005b      	lsls	r3, r3, #1
 8027bae:	4619      	mov	r1, r3
 8027bb0:	68bb      	ldr	r3, [r7, #8]
 8027bb2:	440b      	add	r3, r1
 8027bb4:	3237      	adds	r2, #55	@ 0x37
 8027bb6:	b2d2      	uxtb	r2, r2
 8027bb8:	701a      	strb	r2, [r3, #0]
    }

    value = value << 4;
 8027bba:	68fb      	ldr	r3, [r7, #12]
 8027bbc:	011b      	lsls	r3, r3, #4
 8027bbe:	60fb      	str	r3, [r7, #12]

    pbuf[2 * idx + 1] = 0;
 8027bc0:	7dfb      	ldrb	r3, [r7, #23]
 8027bc2:	005b      	lsls	r3, r3, #1
 8027bc4:	3301      	adds	r3, #1
 8027bc6:	68ba      	ldr	r2, [r7, #8]
 8027bc8:	4413      	add	r3, r2
 8027bca:	2200      	movs	r2, #0
 8027bcc:	701a      	strb	r2, [r3, #0]
  for (idx = 0; idx < len; idx++)
 8027bce:	7dfb      	ldrb	r3, [r7, #23]
 8027bd0:	3301      	adds	r3, #1
 8027bd2:	75fb      	strb	r3, [r7, #23]
 8027bd4:	7dfa      	ldrb	r2, [r7, #23]
 8027bd6:	79fb      	ldrb	r3, [r7, #7]
 8027bd8:	429a      	cmp	r2, r3
 8027bda:	d3d3      	bcc.n	8027b84 <IntToUnicode+0x18>
  }
}
 8027bdc:	bf00      	nop
 8027bde:	bf00      	nop
 8027be0:	371c      	adds	r7, #28
 8027be2:	46bd      	mov	sp, r7
 8027be4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027be8:	4770      	bx	lr
	...

08027bec <HAL_PCD_MspInit>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
 8027bec:	b580      	push	{r7, lr}
 8027bee:	b08a      	sub	sp, #40	@ 0x28
 8027bf0:	af00      	add	r7, sp, #0
 8027bf2:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8027bf4:	f107 0314 	add.w	r3, r7, #20
 8027bf8:	2200      	movs	r2, #0
 8027bfa:	601a      	str	r2, [r3, #0]
 8027bfc:	605a      	str	r2, [r3, #4]
 8027bfe:	609a      	str	r2, [r3, #8]
 8027c00:	60da      	str	r2, [r3, #12]
 8027c02:	611a      	str	r2, [r3, #16]
  if(pcdHandle->Instance==USB_OTG_FS)
 8027c04:	687b      	ldr	r3, [r7, #4]
 8027c06:	681b      	ldr	r3, [r3, #0]
 8027c08:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 8027c0c:	d147      	bne.n	8027c9e <HAL_PCD_MspInit+0xb2>
  {
  /* USER CODE BEGIN USB_OTG_FS_MspInit 0 */

  /* USER CODE END USB_OTG_FS_MspInit 0 */

    __HAL_RCC_GPIOA_CLK_ENABLE();
 8027c0e:	2300      	movs	r3, #0
 8027c10:	613b      	str	r3, [r7, #16]
 8027c12:	4b25      	ldr	r3, [pc, #148]	@ (8027ca8 <HAL_PCD_MspInit+0xbc>)
 8027c14:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8027c16:	4a24      	ldr	r2, [pc, #144]	@ (8027ca8 <HAL_PCD_MspInit+0xbc>)
 8027c18:	f043 0301 	orr.w	r3, r3, #1
 8027c1c:	6313      	str	r3, [r2, #48]	@ 0x30
 8027c1e:	4b22      	ldr	r3, [pc, #136]	@ (8027ca8 <HAL_PCD_MspInit+0xbc>)
 8027c20:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8027c22:	f003 0301 	and.w	r3, r3, #1
 8027c26:	613b      	str	r3, [r7, #16]
 8027c28:	693b      	ldr	r3, [r7, #16]
    PA9     ------> USB_OTG_FS_VBUS
    PA10     ------> USB_OTG_FS_ID
    PA11     ------> USB_OTG_FS_DM
    PA12     ------> USB_OTG_FS_DP
    */
    GPIO_InitStruct.Pin = VBUS_FS_Pin;
 8027c2a:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8027c2e:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8027c30:	2300      	movs	r3, #0
 8027c32:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8027c34:	2300      	movs	r3, #0
 8027c36:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(VBUS_FS_GPIO_Port, &GPIO_InitStruct);
 8027c38:	f107 0314 	add.w	r3, r7, #20
 8027c3c:	4619      	mov	r1, r3
 8027c3e:	481b      	ldr	r0, [pc, #108]	@ (8027cac <HAL_PCD_MspInit+0xc0>)
 8027c40:	f7da fa0e 	bl	8002060 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = OTG_FS_ID_Pin|OTG_FS_DM_Pin|OTG_FS_DP_Pin;
 8027c44:	f44f 53e0 	mov.w	r3, #7168	@ 0x1c00
 8027c48:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8027c4a:	2302      	movs	r3, #2
 8027c4c:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8027c4e:	2300      	movs	r3, #0
 8027c50:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8027c52:	2300      	movs	r3, #0
 8027c54:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 8027c56:	230a      	movs	r3, #10
 8027c58:	627b      	str	r3, [r7, #36]	@ 0x24
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8027c5a:	f107 0314 	add.w	r3, r7, #20
 8027c5e:	4619      	mov	r1, r3
 8027c60:	4812      	ldr	r0, [pc, #72]	@ (8027cac <HAL_PCD_MspInit+0xc0>)
 8027c62:	f7da f9fd 	bl	8002060 <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 8027c66:	4b10      	ldr	r3, [pc, #64]	@ (8027ca8 <HAL_PCD_MspInit+0xbc>)
 8027c68:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8027c6a:	4a0f      	ldr	r2, [pc, #60]	@ (8027ca8 <HAL_PCD_MspInit+0xbc>)
 8027c6c:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8027c70:	6353      	str	r3, [r2, #52]	@ 0x34
 8027c72:	2300      	movs	r3, #0
 8027c74:	60fb      	str	r3, [r7, #12]
 8027c76:	4b0c      	ldr	r3, [pc, #48]	@ (8027ca8 <HAL_PCD_MspInit+0xbc>)
 8027c78:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8027c7a:	4a0b      	ldr	r2, [pc, #44]	@ (8027ca8 <HAL_PCD_MspInit+0xbc>)
 8027c7c:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 8027c80:	6453      	str	r3, [r2, #68]	@ 0x44
 8027c82:	4b09      	ldr	r3, [pc, #36]	@ (8027ca8 <HAL_PCD_MspInit+0xbc>)
 8027c84:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8027c86:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 8027c8a:	60fb      	str	r3, [r7, #12]
 8027c8c:	68fb      	ldr	r3, [r7, #12]

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 0, 0);
 8027c8e:	2200      	movs	r2, #0
 8027c90:	2100      	movs	r1, #0
 8027c92:	2043      	movs	r0, #67	@ 0x43
 8027c94:	f7da f991 	bl	8001fba <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
 8027c98:	2043      	movs	r0, #67	@ 0x43
 8027c9a:	f7da f9aa 	bl	8001ff2 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USB_OTG_FS_MspInit 1 */

  /* USER CODE END USB_OTG_FS_MspInit 1 */
  }
}
 8027c9e:	bf00      	nop
 8027ca0:	3728      	adds	r7, #40	@ 0x28
 8027ca2:	46bd      	mov	sp, r7
 8027ca4:	bd80      	pop	{r7, pc}
 8027ca6:	bf00      	nop
 8027ca8:	40023800 	.word	0x40023800
 8027cac:	40020000 	.word	0x40020000

08027cb0 <HAL_PCD_SetupStageCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8027cb0:	b580      	push	{r7, lr}
 8027cb2:	b082      	sub	sp, #8
 8027cb4:	af00      	add	r7, sp, #0
 8027cb6:	6078      	str	r0, [r7, #4]
  USBD_LL_SetupStage((USBD_HandleTypeDef*)hpcd->pData, (uint8_t *)hpcd->Setup);
 8027cb8:	687b      	ldr	r3, [r7, #4]
 8027cba:	f8d3 24e0 	ldr.w	r2, [r3, #1248]	@ 0x4e0
 8027cbe:	687b      	ldr	r3, [r7, #4]
 8027cc0:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 8027cc4:	4619      	mov	r1, r3
 8027cc6:	4610      	mov	r0, r2
 8027cc8:	f7df fb93 	bl	80073f2 <USBD_LL_SetupStage>
}
 8027ccc:	bf00      	nop
 8027cce:	3708      	adds	r7, #8
 8027cd0:	46bd      	mov	sp, r7
 8027cd2:	bd80      	pop	{r7, pc}

08027cd4 <HAL_PCD_DataOutStageCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8027cd4:	b580      	push	{r7, lr}
 8027cd6:	b082      	sub	sp, #8
 8027cd8:	af00      	add	r7, sp, #0
 8027cda:	6078      	str	r0, [r7, #4]
 8027cdc:	460b      	mov	r3, r1
 8027cde:	70fb      	strb	r3, [r7, #3]
  USBD_LL_DataOutStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 8027ce0:	687b      	ldr	r3, [r7, #4]
 8027ce2:	f8d3 04e0 	ldr.w	r0, [r3, #1248]	@ 0x4e0
 8027ce6:	78fa      	ldrb	r2, [r7, #3]
 8027ce8:	6879      	ldr	r1, [r7, #4]
 8027cea:	4613      	mov	r3, r2
 8027cec:	00db      	lsls	r3, r3, #3
 8027cee:	4413      	add	r3, r2
 8027cf0:	009b      	lsls	r3, r3, #2
 8027cf2:	440b      	add	r3, r1
 8027cf4:	f503 7318 	add.w	r3, r3, #608	@ 0x260
 8027cf8:	681a      	ldr	r2, [r3, #0]
 8027cfa:	78fb      	ldrb	r3, [r7, #3]
 8027cfc:	4619      	mov	r1, r3
 8027cfe:	f7df fbcd 	bl	800749c <USBD_LL_DataOutStage>
}
 8027d02:	bf00      	nop
 8027d04:	3708      	adds	r7, #8
 8027d06:	46bd      	mov	sp, r7
 8027d08:	bd80      	pop	{r7, pc}

08027d0a <HAL_PCD_DataInStageCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8027d0a:	b580      	push	{r7, lr}
 8027d0c:	b082      	sub	sp, #8
 8027d0e:	af00      	add	r7, sp, #0
 8027d10:	6078      	str	r0, [r7, #4]
 8027d12:	460b      	mov	r3, r1
 8027d14:	70fb      	strb	r3, [r7, #3]
  USBD_LL_DataInStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 8027d16:	687b      	ldr	r3, [r7, #4]
 8027d18:	f8d3 04e0 	ldr.w	r0, [r3, #1248]	@ 0x4e0
 8027d1c:	78fa      	ldrb	r2, [r7, #3]
 8027d1e:	6879      	ldr	r1, [r7, #4]
 8027d20:	4613      	mov	r3, r2
 8027d22:	00db      	lsls	r3, r3, #3
 8027d24:	4413      	add	r3, r2
 8027d26:	009b      	lsls	r3, r3, #2
 8027d28:	440b      	add	r3, r1
 8027d2a:	3320      	adds	r3, #32
 8027d2c:	681a      	ldr	r2, [r3, #0]
 8027d2e:	78fb      	ldrb	r3, [r7, #3]
 8027d30:	4619      	mov	r1, r3
 8027d32:	f7df fc66 	bl	8007602 <USBD_LL_DataInStage>
}
 8027d36:	bf00      	nop
 8027d38:	3708      	adds	r7, #8
 8027d3a:	46bd      	mov	sp, r7
 8027d3c:	bd80      	pop	{r7, pc}

08027d3e <HAL_PCD_SOFCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8027d3e:	b580      	push	{r7, lr}
 8027d40:	b082      	sub	sp, #8
 8027d42:	af00      	add	r7, sp, #0
 8027d44:	6078      	str	r0, [r7, #4]
  USBD_LL_SOF((USBD_HandleTypeDef*)hpcd->pData);
 8027d46:	687b      	ldr	r3, [r7, #4]
 8027d48:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 8027d4c:	4618      	mov	r0, r3
 8027d4e:	f7df fda0 	bl	8007892 <USBD_LL_SOF>
}
 8027d52:	bf00      	nop
 8027d54:	3708      	adds	r7, #8
 8027d56:	46bd      	mov	sp, r7
 8027d58:	bd80      	pop	{r7, pc}

08027d5a <HAL_PCD_ResetCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8027d5a:	b580      	push	{r7, lr}
 8027d5c:	b084      	sub	sp, #16
 8027d5e:	af00      	add	r7, sp, #0
 8027d60:	6078      	str	r0, [r7, #4]
  USBD_SpeedTypeDef speed = USBD_SPEED_FULL;
 8027d62:	2301      	movs	r3, #1
 8027d64:	73fb      	strb	r3, [r7, #15]

  if ( hpcd->Init.speed == PCD_SPEED_HIGH)
 8027d66:	687b      	ldr	r3, [r7, #4]
 8027d68:	79db      	ldrb	r3, [r3, #7]
 8027d6a:	2b00      	cmp	r3, #0
 8027d6c:	d102      	bne.n	8027d74 <HAL_PCD_ResetCallback+0x1a>
  {
    speed = USBD_SPEED_HIGH;
 8027d6e:	2300      	movs	r3, #0
 8027d70:	73fb      	strb	r3, [r7, #15]
 8027d72:	e008      	b.n	8027d86 <HAL_PCD_ResetCallback+0x2c>
  }
  else if ( hpcd->Init.speed == PCD_SPEED_FULL)
 8027d74:	687b      	ldr	r3, [r7, #4]
 8027d76:	79db      	ldrb	r3, [r3, #7]
 8027d78:	2b02      	cmp	r3, #2
 8027d7a:	d102      	bne.n	8027d82 <HAL_PCD_ResetCallback+0x28>
  {
    speed = USBD_SPEED_FULL;
 8027d7c:	2301      	movs	r3, #1
 8027d7e:	73fb      	strb	r3, [r7, #15]
 8027d80:	e001      	b.n	8027d86 <HAL_PCD_ResetCallback+0x2c>
  }
  else
  {
    Error_Handler();
 8027d82:	f7d9 fd3d 	bl	8001800 <Error_Handler>
  }
    /* Set Speed. */
  USBD_LL_SetSpeed((USBD_HandleTypeDef*)hpcd->pData, speed);
 8027d86:	687b      	ldr	r3, [r7, #4]
 8027d88:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 8027d8c:	7bfa      	ldrb	r2, [r7, #15]
 8027d8e:	4611      	mov	r1, r2
 8027d90:	4618      	mov	r0, r3
 8027d92:	f7df fd3a 	bl	800780a <USBD_LL_SetSpeed>

  /* Reset Device. */
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
 8027d96:	687b      	ldr	r3, [r7, #4]
 8027d98:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 8027d9c:	4618      	mov	r0, r3
 8027d9e:	f7df fce2 	bl	8007766 <USBD_LL_Reset>
}
 8027da2:	bf00      	nop
 8027da4:	3710      	adds	r7, #16
 8027da6:	46bd      	mov	sp, r7
 8027da8:	bd80      	pop	{r7, pc}
	...

08027dac <HAL_PCD_SuspendCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8027dac:	b580      	push	{r7, lr}
 8027dae:	b082      	sub	sp, #8
 8027db0:	af00      	add	r7, sp, #0
 8027db2:	6078      	str	r0, [r7, #4]
  /* Inform USB library that core enters in suspend Mode. */
  USBD_LL_Suspend((USBD_HandleTypeDef*)hpcd->pData);
 8027db4:	687b      	ldr	r3, [r7, #4]
 8027db6:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 8027dba:	4618      	mov	r0, r3
 8027dbc:	f7df fd35 	bl	800782a <USBD_LL_Suspend>
  __HAL_PCD_GATE_PHYCLOCK(hpcd);
 8027dc0:	687b      	ldr	r3, [r7, #4]
 8027dc2:	681b      	ldr	r3, [r3, #0]
 8027dc4:	f503 6360 	add.w	r3, r3, #3584	@ 0xe00
 8027dc8:	681b      	ldr	r3, [r3, #0]
 8027dca:	687a      	ldr	r2, [r7, #4]
 8027dcc:	6812      	ldr	r2, [r2, #0]
 8027dce:	f502 6260 	add.w	r2, r2, #3584	@ 0xe00
 8027dd2:	f043 0301 	orr.w	r3, r3, #1
 8027dd6:	6013      	str	r3, [r2, #0]
  /* Enter in STOP mode. */
  /* USER CODE BEGIN 2 */
  if (hpcd->Init.low_power_enable)
 8027dd8:	687b      	ldr	r3, [r7, #4]
 8027dda:	7adb      	ldrb	r3, [r3, #11]
 8027ddc:	2b00      	cmp	r3, #0
 8027dde:	d005      	beq.n	8027dec <HAL_PCD_SuspendCallback+0x40>
  {
    /* Set SLEEPDEEP bit and SleepOnExit of Cortex System Control Register. */
    SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 8027de0:	4b04      	ldr	r3, [pc, #16]	@ (8027df4 <HAL_PCD_SuspendCallback+0x48>)
 8027de2:	691b      	ldr	r3, [r3, #16]
 8027de4:	4a03      	ldr	r2, [pc, #12]	@ (8027df4 <HAL_PCD_SuspendCallback+0x48>)
 8027de6:	f043 0306 	orr.w	r3, r3, #6
 8027dea:	6113      	str	r3, [r2, #16]
  }
  /* USER CODE END 2 */
}
 8027dec:	bf00      	nop
 8027dee:	3708      	adds	r7, #8
 8027df0:	46bd      	mov	sp, r7
 8027df2:	bd80      	pop	{r7, pc}
 8027df4:	e000ed00 	.word	0xe000ed00

08027df8 <HAL_PCD_ResumeCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8027df8:	b580      	push	{r7, lr}
 8027dfa:	b082      	sub	sp, #8
 8027dfc:	af00      	add	r7, sp, #0
 8027dfe:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN 3 */

  /* USER CODE END 3 */
  USBD_LL_Resume((USBD_HandleTypeDef*)hpcd->pData);
 8027e00:	687b      	ldr	r3, [r7, #4]
 8027e02:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 8027e06:	4618      	mov	r0, r3
 8027e08:	f7df fd2b 	bl	8007862 <USBD_LL_Resume>
}
 8027e0c:	bf00      	nop
 8027e0e:	3708      	adds	r7, #8
 8027e10:	46bd      	mov	sp, r7
 8027e12:	bd80      	pop	{r7, pc}

08027e14 <HAL_PCD_ISOOUTIncompleteCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8027e14:	b580      	push	{r7, lr}
 8027e16:	b082      	sub	sp, #8
 8027e18:	af00      	add	r7, sp, #0
 8027e1a:	6078      	str	r0, [r7, #4]
 8027e1c:	460b      	mov	r3, r1
 8027e1e:	70fb      	strb	r3, [r7, #3]
  USBD_LL_IsoOUTIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
 8027e20:	687b      	ldr	r3, [r7, #4]
 8027e22:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 8027e26:	78fa      	ldrb	r2, [r7, #3]
 8027e28:	4611      	mov	r1, r2
 8027e2a:	4618      	mov	r0, r3
 8027e2c:	f7df fd83 	bl	8007936 <USBD_LL_IsoOUTIncomplete>
}
 8027e30:	bf00      	nop
 8027e32:	3708      	adds	r7, #8
 8027e34:	46bd      	mov	sp, r7
 8027e36:	bd80      	pop	{r7, pc}

08027e38 <HAL_PCD_ISOINIncompleteCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8027e38:	b580      	push	{r7, lr}
 8027e3a:	b082      	sub	sp, #8
 8027e3c:	af00      	add	r7, sp, #0
 8027e3e:	6078      	str	r0, [r7, #4]
 8027e40:	460b      	mov	r3, r1
 8027e42:	70fb      	strb	r3, [r7, #3]
  USBD_LL_IsoINIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
 8027e44:	687b      	ldr	r3, [r7, #4]
 8027e46:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 8027e4a:	78fa      	ldrb	r2, [r7, #3]
 8027e4c:	4611      	mov	r1, r2
 8027e4e:	4618      	mov	r0, r3
 8027e50:	f7df fd3f 	bl	80078d2 <USBD_LL_IsoINIncomplete>
}
 8027e54:	bf00      	nop
 8027e56:	3708      	adds	r7, #8
 8027e58:	46bd      	mov	sp, r7
 8027e5a:	bd80      	pop	{r7, pc}

08027e5c <HAL_PCD_ConnectCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8027e5c:	b580      	push	{r7, lr}
 8027e5e:	b082      	sub	sp, #8
 8027e60:	af00      	add	r7, sp, #0
 8027e62:	6078      	str	r0, [r7, #4]
  USBD_LL_DevConnected((USBD_HandleTypeDef*)hpcd->pData);
 8027e64:	687b      	ldr	r3, [r7, #4]
 8027e66:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 8027e6a:	4618      	mov	r0, r3
 8027e6c:	f7df fd95 	bl	800799a <USBD_LL_DevConnected>
}
 8027e70:	bf00      	nop
 8027e72:	3708      	adds	r7, #8
 8027e74:	46bd      	mov	sp, r7
 8027e76:	bd80      	pop	{r7, pc}

08027e78 <HAL_PCD_DisconnectCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8027e78:	b580      	push	{r7, lr}
 8027e7a:	b082      	sub	sp, #8
 8027e7c:	af00      	add	r7, sp, #0
 8027e7e:	6078      	str	r0, [r7, #4]
  USBD_LL_DevDisconnected((USBD_HandleTypeDef*)hpcd->pData);
 8027e80:	687b      	ldr	r3, [r7, #4]
 8027e82:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 8027e86:	4618      	mov	r0, r3
 8027e88:	f7df fd92 	bl	80079b0 <USBD_LL_DevDisconnected>
}
 8027e8c:	bf00      	nop
 8027e8e:	3708      	adds	r7, #8
 8027e90:	46bd      	mov	sp, r7
 8027e92:	bd80      	pop	{r7, pc}

08027e94 <USBD_LL_Init>:
  * @brief  Initializes the low level portion of the device driver.
  * @param  pdev: Device handle
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Init(USBD_HandleTypeDef *pdev)
{
 8027e94:	b580      	push	{r7, lr}
 8027e96:	b082      	sub	sp, #8
 8027e98:	af00      	add	r7, sp, #0
 8027e9a:	6078      	str	r0, [r7, #4]
  /* Init USB Ip. */
  if (pdev->id == DEVICE_FS) {
 8027e9c:	687b      	ldr	r3, [r7, #4]
 8027e9e:	781b      	ldrb	r3, [r3, #0]
 8027ea0:	2b00      	cmp	r3, #0
 8027ea2:	d13c      	bne.n	8027f1e <USBD_LL_Init+0x8a>
  /* Link the driver to the stack. */
  hpcd_USB_OTG_FS.pData = pdev;
 8027ea4:	4a20      	ldr	r2, [pc, #128]	@ (8027f28 <USBD_LL_Init+0x94>)
 8027ea6:	687b      	ldr	r3, [r7, #4]
 8027ea8:	f8c2 34e0 	str.w	r3, [r2, #1248]	@ 0x4e0
  pdev->pData = &hpcd_USB_OTG_FS;
 8027eac:	687b      	ldr	r3, [r7, #4]
 8027eae:	4a1e      	ldr	r2, [pc, #120]	@ (8027f28 <USBD_LL_Init+0x94>)
 8027eb0:	f8c3 22c8 	str.w	r2, [r3, #712]	@ 0x2c8

  hpcd_USB_OTG_FS.Instance = USB_OTG_FS;
 8027eb4:	4b1c      	ldr	r3, [pc, #112]	@ (8027f28 <USBD_LL_Init+0x94>)
 8027eb6:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
 8027eba:	601a      	str	r2, [r3, #0]
  hpcd_USB_OTG_FS.Init.dev_endpoints = 4;
 8027ebc:	4b1a      	ldr	r3, [pc, #104]	@ (8027f28 <USBD_LL_Init+0x94>)
 8027ebe:	2204      	movs	r2, #4
 8027ec0:	711a      	strb	r2, [r3, #4]
  hpcd_USB_OTG_FS.Init.speed = PCD_SPEED_FULL;
 8027ec2:	4b19      	ldr	r3, [pc, #100]	@ (8027f28 <USBD_LL_Init+0x94>)
 8027ec4:	2202      	movs	r2, #2
 8027ec6:	71da      	strb	r2, [r3, #7]
  hpcd_USB_OTG_FS.Init.dma_enable = DISABLE;
 8027ec8:	4b17      	ldr	r3, [pc, #92]	@ (8027f28 <USBD_LL_Init+0x94>)
 8027eca:	2200      	movs	r2, #0
 8027ecc:	719a      	strb	r2, [r3, #6]
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 8027ece:	4b16      	ldr	r3, [pc, #88]	@ (8027f28 <USBD_LL_Init+0x94>)
 8027ed0:	2202      	movs	r2, #2
 8027ed2:	725a      	strb	r2, [r3, #9]
  hpcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
 8027ed4:	4b14      	ldr	r3, [pc, #80]	@ (8027f28 <USBD_LL_Init+0x94>)
 8027ed6:	2200      	movs	r2, #0
 8027ed8:	729a      	strb	r2, [r3, #10]
  hpcd_USB_OTG_FS.Init.low_power_enable = DISABLE;
 8027eda:	4b13      	ldr	r3, [pc, #76]	@ (8027f28 <USBD_LL_Init+0x94>)
 8027edc:	2200      	movs	r2, #0
 8027ede:	72da      	strb	r2, [r3, #11]
  hpcd_USB_OTG_FS.Init.lpm_enable = DISABLE;
 8027ee0:	4b11      	ldr	r3, [pc, #68]	@ (8027f28 <USBD_LL_Init+0x94>)
 8027ee2:	2200      	movs	r2, #0
 8027ee4:	731a      	strb	r2, [r3, #12]
  hpcd_USB_OTG_FS.Init.vbus_sensing_enable = ENABLE;
 8027ee6:	4b10      	ldr	r3, [pc, #64]	@ (8027f28 <USBD_LL_Init+0x94>)
 8027ee8:	2201      	movs	r2, #1
 8027eea:	739a      	strb	r2, [r3, #14]
  hpcd_USB_OTG_FS.Init.use_dedicated_ep1 = DISABLE;
 8027eec:	4b0e      	ldr	r3, [pc, #56]	@ (8027f28 <USBD_LL_Init+0x94>)
 8027eee:	2200      	movs	r2, #0
 8027ef0:	73da      	strb	r2, [r3, #15]
  if (HAL_PCD_Init(&hpcd_USB_OTG_FS) != HAL_OK)
 8027ef2:	480d      	ldr	r0, [pc, #52]	@ (8027f28 <USBD_LL_Init+0x94>)
 8027ef4:	f7db f866 	bl	8002fc4 <HAL_PCD_Init>
 8027ef8:	4603      	mov	r3, r0
 8027efa:	2b00      	cmp	r3, #0
 8027efc:	d001      	beq.n	8027f02 <USBD_LL_Init+0x6e>
  {
    Error_Handler( );
 8027efe:	f7d9 fc7f 	bl	8001800 <Error_Handler>
  HAL_PCD_RegisterDataOutStageCallback(&hpcd_USB_OTG_FS, PCD_DataOutStageCallback);
  HAL_PCD_RegisterDataInStageCallback(&hpcd_USB_OTG_FS, PCD_DataInStageCallback);
  HAL_PCD_RegisterIsoOutIncpltCallback(&hpcd_USB_OTG_FS, PCD_ISOOUTIncompleteCallback);
  HAL_PCD_RegisterIsoInIncpltCallback(&hpcd_USB_OTG_FS, PCD_ISOINIncompleteCallback);
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
  HAL_PCDEx_SetRxFiFo(&hpcd_USB_OTG_FS, 0x80);
 8027f02:	2180      	movs	r1, #128	@ 0x80
 8027f04:	4808      	ldr	r0, [pc, #32]	@ (8027f28 <USBD_LL_Init+0x94>)
 8027f06:	f7dc fa92 	bl	800442e <HAL_PCDEx_SetRxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 0, 0x40);
 8027f0a:	2240      	movs	r2, #64	@ 0x40
 8027f0c:	2100      	movs	r1, #0
 8027f0e:	4806      	ldr	r0, [pc, #24]	@ (8027f28 <USBD_LL_Init+0x94>)
 8027f10:	f7dc fa46 	bl	80043a0 <HAL_PCDEx_SetTxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 1, 0x80);
 8027f14:	2280      	movs	r2, #128	@ 0x80
 8027f16:	2101      	movs	r1, #1
 8027f18:	4803      	ldr	r0, [pc, #12]	@ (8027f28 <USBD_LL_Init+0x94>)
 8027f1a:	f7dc fa41 	bl	80043a0 <HAL_PCDEx_SetTxFiFo>
  }
  return USBD_OK;
 8027f1e:	2300      	movs	r3, #0
}
 8027f20:	4618      	mov	r0, r3
 8027f22:	3708      	adds	r7, #8
 8027f24:	46bd      	mov	sp, r7
 8027f26:	bd80      	pop	{r7, pc}
 8027f28:	20003df4 	.word	0x20003df4

08027f2c <USBD_LL_Start>:
  * @brief  Starts the low level portion of the device driver.
  * @param  pdev: Device handle
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Start(USBD_HandleTypeDef *pdev)
{
 8027f2c:	b580      	push	{r7, lr}
 8027f2e:	b084      	sub	sp, #16
 8027f30:	af00      	add	r7, sp, #0
 8027f32:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8027f34:	2300      	movs	r3, #0
 8027f36:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8027f38:	2300      	movs	r3, #0
 8027f3a:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_Start(pdev->pData);
 8027f3c:	687b      	ldr	r3, [r7, #4]
 8027f3e:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 8027f42:	4618      	mov	r0, r3
 8027f44:	f7db f94d 	bl	80031e2 <HAL_PCD_Start>
 8027f48:	4603      	mov	r3, r0
 8027f4a:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8027f4c:	7bfb      	ldrb	r3, [r7, #15]
 8027f4e:	4618      	mov	r0, r3
 8027f50:	f000 f942 	bl	80281d8 <USBD_Get_USB_Status>
 8027f54:	4603      	mov	r3, r0
 8027f56:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 8027f58:	7bbb      	ldrb	r3, [r7, #14]
}
 8027f5a:	4618      	mov	r0, r3
 8027f5c:	3710      	adds	r7, #16
 8027f5e:	46bd      	mov	sp, r7
 8027f60:	bd80      	pop	{r7, pc}

08027f62 <USBD_LL_OpenEP>:
  * @param  ep_type: Endpoint type
  * @param  ep_mps: Endpoint max packet size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_OpenEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t ep_type, uint16_t ep_mps)
{
 8027f62:	b580      	push	{r7, lr}
 8027f64:	b084      	sub	sp, #16
 8027f66:	af00      	add	r7, sp, #0
 8027f68:	6078      	str	r0, [r7, #4]
 8027f6a:	4608      	mov	r0, r1
 8027f6c:	4611      	mov	r1, r2
 8027f6e:	461a      	mov	r2, r3
 8027f70:	4603      	mov	r3, r0
 8027f72:	70fb      	strb	r3, [r7, #3]
 8027f74:	460b      	mov	r3, r1
 8027f76:	70bb      	strb	r3, [r7, #2]
 8027f78:	4613      	mov	r3, r2
 8027f7a:	803b      	strh	r3, [r7, #0]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8027f7c:	2300      	movs	r3, #0
 8027f7e:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8027f80:	2300      	movs	r3, #0
 8027f82:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
 8027f84:	687b      	ldr	r3, [r7, #4]
 8027f86:	f8d3 02c8 	ldr.w	r0, [r3, #712]	@ 0x2c8
 8027f8a:	78bb      	ldrb	r3, [r7, #2]
 8027f8c:	883a      	ldrh	r2, [r7, #0]
 8027f8e:	78f9      	ldrb	r1, [r7, #3]
 8027f90:	f7db fe21 	bl	8003bd6 <HAL_PCD_EP_Open>
 8027f94:	4603      	mov	r3, r0
 8027f96:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8027f98:	7bfb      	ldrb	r3, [r7, #15]
 8027f9a:	4618      	mov	r0, r3
 8027f9c:	f000 f91c 	bl	80281d8 <USBD_Get_USB_Status>
 8027fa0:	4603      	mov	r3, r0
 8027fa2:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 8027fa4:	7bbb      	ldrb	r3, [r7, #14]
}
 8027fa6:	4618      	mov	r0, r3
 8027fa8:	3710      	adds	r7, #16
 8027faa:	46bd      	mov	sp, r7
 8027fac:	bd80      	pop	{r7, pc}

08027fae <USBD_LL_CloseEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_CloseEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8027fae:	b580      	push	{r7, lr}
 8027fb0:	b084      	sub	sp, #16
 8027fb2:	af00      	add	r7, sp, #0
 8027fb4:	6078      	str	r0, [r7, #4]
 8027fb6:	460b      	mov	r3, r1
 8027fb8:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8027fba:	2300      	movs	r3, #0
 8027fbc:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8027fbe:	2300      	movs	r3, #0
 8027fc0:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_Close(pdev->pData, ep_addr);
 8027fc2:	687b      	ldr	r3, [r7, #4]
 8027fc4:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 8027fc8:	78fa      	ldrb	r2, [r7, #3]
 8027fca:	4611      	mov	r1, r2
 8027fcc:	4618      	mov	r0, r3
 8027fce:	f7db fe6c 	bl	8003caa <HAL_PCD_EP_Close>
 8027fd2:	4603      	mov	r3, r0
 8027fd4:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8027fd6:	7bfb      	ldrb	r3, [r7, #15]
 8027fd8:	4618      	mov	r0, r3
 8027fda:	f000 f8fd 	bl	80281d8 <USBD_Get_USB_Status>
 8027fde:	4603      	mov	r3, r0
 8027fe0:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 8027fe2:	7bbb      	ldrb	r3, [r7, #14]
}
 8027fe4:	4618      	mov	r0, r3
 8027fe6:	3710      	adds	r7, #16
 8027fe8:	46bd      	mov	sp, r7
 8027fea:	bd80      	pop	{r7, pc}

08027fec <USBD_LL_StallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_StallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8027fec:	b580      	push	{r7, lr}
 8027fee:	b084      	sub	sp, #16
 8027ff0:	af00      	add	r7, sp, #0
 8027ff2:	6078      	str	r0, [r7, #4]
 8027ff4:	460b      	mov	r3, r1
 8027ff6:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8027ff8:	2300      	movs	r3, #0
 8027ffa:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8027ffc:	2300      	movs	r3, #0
 8027ffe:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 8028000:	687b      	ldr	r3, [r7, #4]
 8028002:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 8028006:	78fa      	ldrb	r2, [r7, #3]
 8028008:	4611      	mov	r1, r2
 802800a:	4618      	mov	r0, r3
 802800c:	f7db ff24 	bl	8003e58 <HAL_PCD_EP_SetStall>
 8028010:	4603      	mov	r3, r0
 8028012:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8028014:	7bfb      	ldrb	r3, [r7, #15]
 8028016:	4618      	mov	r0, r3
 8028018:	f000 f8de 	bl	80281d8 <USBD_Get_USB_Status>
 802801c:	4603      	mov	r3, r0
 802801e:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 8028020:	7bbb      	ldrb	r3, [r7, #14]
}
 8028022:	4618      	mov	r0, r3
 8028024:	3710      	adds	r7, #16
 8028026:	46bd      	mov	sp, r7
 8028028:	bd80      	pop	{r7, pc}

0802802a <USBD_LL_ClearStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_ClearStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 802802a:	b580      	push	{r7, lr}
 802802c:	b084      	sub	sp, #16
 802802e:	af00      	add	r7, sp, #0
 8028030:	6078      	str	r0, [r7, #4]
 8028032:	460b      	mov	r3, r1
 8028034:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8028036:	2300      	movs	r3, #0
 8028038:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 802803a:	2300      	movs	r3, #0
 802803c:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);
 802803e:	687b      	ldr	r3, [r7, #4]
 8028040:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 8028044:	78fa      	ldrb	r2, [r7, #3]
 8028046:	4611      	mov	r1, r2
 8028048:	4618      	mov	r0, r3
 802804a:	f7db ff68 	bl	8003f1e <HAL_PCD_EP_ClrStall>
 802804e:	4603      	mov	r3, r0
 8028050:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8028052:	7bfb      	ldrb	r3, [r7, #15]
 8028054:	4618      	mov	r0, r3
 8028056:	f000 f8bf 	bl	80281d8 <USBD_Get_USB_Status>
 802805a:	4603      	mov	r3, r0
 802805c:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 802805e:	7bbb      	ldrb	r3, [r7, #14]
}
 8028060:	4618      	mov	r0, r3
 8028062:	3710      	adds	r7, #16
 8028064:	46bd      	mov	sp, r7
 8028066:	bd80      	pop	{r7, pc}

08028068 <USBD_LL_IsStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval Stall (1: Yes, 0: No)
  */
uint8_t USBD_LL_IsStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8028068:	b480      	push	{r7}
 802806a:	b085      	sub	sp, #20
 802806c:	af00      	add	r7, sp, #0
 802806e:	6078      	str	r0, [r7, #4]
 8028070:	460b      	mov	r3, r1
 8028072:	70fb      	strb	r3, [r7, #3]
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*) pdev->pData;
 8028074:	687b      	ldr	r3, [r7, #4]
 8028076:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 802807a:	60fb      	str	r3, [r7, #12]

  if((ep_addr & 0x80) == 0x80)
 802807c:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8028080:	2b00      	cmp	r3, #0
 8028082:	da0b      	bge.n	802809c <USBD_LL_IsStallEP+0x34>
  {
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall;
 8028084:	78fb      	ldrb	r3, [r7, #3]
 8028086:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 802808a:	68f9      	ldr	r1, [r7, #12]
 802808c:	4613      	mov	r3, r2
 802808e:	00db      	lsls	r3, r3, #3
 8028090:	4413      	add	r3, r2
 8028092:	009b      	lsls	r3, r3, #2
 8028094:	440b      	add	r3, r1
 8028096:	3316      	adds	r3, #22
 8028098:	781b      	ldrb	r3, [r3, #0]
 802809a:	e00b      	b.n	80280b4 <USBD_LL_IsStallEP+0x4c>
  }
  else
  {
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall;
 802809c:	78fb      	ldrb	r3, [r7, #3]
 802809e:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 80280a2:	68f9      	ldr	r1, [r7, #12]
 80280a4:	4613      	mov	r3, r2
 80280a6:	00db      	lsls	r3, r3, #3
 80280a8:	4413      	add	r3, r2
 80280aa:	009b      	lsls	r3, r3, #2
 80280ac:	440b      	add	r3, r1
 80280ae:	f203 2356 	addw	r3, r3, #598	@ 0x256
 80280b2:	781b      	ldrb	r3, [r3, #0]
  }
}
 80280b4:	4618      	mov	r0, r3
 80280b6:	3714      	adds	r7, #20
 80280b8:	46bd      	mov	sp, r7
 80280ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 80280be:	4770      	bx	lr

080280c0 <USBD_LL_SetUSBAddress>:
  * @param  pdev: Device handle
  * @param  dev_addr: Device address
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_SetUSBAddress(USBD_HandleTypeDef *pdev, uint8_t dev_addr)
{
 80280c0:	b580      	push	{r7, lr}
 80280c2:	b084      	sub	sp, #16
 80280c4:	af00      	add	r7, sp, #0
 80280c6:	6078      	str	r0, [r7, #4]
 80280c8:	460b      	mov	r3, r1
 80280ca:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 80280cc:	2300      	movs	r3, #0
 80280ce:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 80280d0:	2300      	movs	r3, #0
 80280d2:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_SetAddress(pdev->pData, dev_addr);
 80280d4:	687b      	ldr	r3, [r7, #4]
 80280d6:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 80280da:	78fa      	ldrb	r2, [r7, #3]
 80280dc:	4611      	mov	r1, r2
 80280de:	4618      	mov	r0, r3
 80280e0:	f7db fd55 	bl	8003b8e <HAL_PCD_SetAddress>
 80280e4:	4603      	mov	r3, r0
 80280e6:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 80280e8:	7bfb      	ldrb	r3, [r7, #15]
 80280ea:	4618      	mov	r0, r3
 80280ec:	f000 f874 	bl	80281d8 <USBD_Get_USB_Status>
 80280f0:	4603      	mov	r3, r0
 80280f2:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 80280f4:	7bbb      	ldrb	r3, [r7, #14]
}
 80280f6:	4618      	mov	r0, r3
 80280f8:	3710      	adds	r7, #16
 80280fa:	46bd      	mov	sp, r7
 80280fc:	bd80      	pop	{r7, pc}

080280fe <USBD_LL_Transmit>:
  * @param  pbuf: Pointer to data to be sent
  * @param  size: Data size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Transmit(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t *pbuf, uint32_t size)
{
 80280fe:	b580      	push	{r7, lr}
 8028100:	b086      	sub	sp, #24
 8028102:	af00      	add	r7, sp, #0
 8028104:	60f8      	str	r0, [r7, #12]
 8028106:	607a      	str	r2, [r7, #4]
 8028108:	603b      	str	r3, [r7, #0]
 802810a:	460b      	mov	r3, r1
 802810c:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef hal_status = HAL_OK;
 802810e:	2300      	movs	r3, #0
 8028110:	75fb      	strb	r3, [r7, #23]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8028112:	2300      	movs	r3, #0
 8028114:	75bb      	strb	r3, [r7, #22]

  hal_status = HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 8028116:	68fb      	ldr	r3, [r7, #12]
 8028118:	f8d3 02c8 	ldr.w	r0, [r3, #712]	@ 0x2c8
 802811c:	7af9      	ldrb	r1, [r7, #11]
 802811e:	683b      	ldr	r3, [r7, #0]
 8028120:	687a      	ldr	r2, [r7, #4]
 8028122:	f7db fe5f 	bl	8003de4 <HAL_PCD_EP_Transmit>
 8028126:	4603      	mov	r3, r0
 8028128:	75fb      	strb	r3, [r7, #23]

  usb_status =  USBD_Get_USB_Status(hal_status);
 802812a:	7dfb      	ldrb	r3, [r7, #23]
 802812c:	4618      	mov	r0, r3
 802812e:	f000 f853 	bl	80281d8 <USBD_Get_USB_Status>
 8028132:	4603      	mov	r3, r0
 8028134:	75bb      	strb	r3, [r7, #22]

  return usb_status;
 8028136:	7dbb      	ldrb	r3, [r7, #22]
}
 8028138:	4618      	mov	r0, r3
 802813a:	3718      	adds	r7, #24
 802813c:	46bd      	mov	sp, r7
 802813e:	bd80      	pop	{r7, pc}

08028140 <USBD_LL_PrepareReceive>:
  * @param  pbuf: Pointer to data to be received
  * @param  size: Data size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_PrepareReceive(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t *pbuf, uint32_t size)
{
 8028140:	b580      	push	{r7, lr}
 8028142:	b086      	sub	sp, #24
 8028144:	af00      	add	r7, sp, #0
 8028146:	60f8      	str	r0, [r7, #12]
 8028148:	607a      	str	r2, [r7, #4]
 802814a:	603b      	str	r3, [r7, #0]
 802814c:	460b      	mov	r3, r1
 802814e:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8028150:	2300      	movs	r3, #0
 8028152:	75fb      	strb	r3, [r7, #23]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8028154:	2300      	movs	r3, #0
 8028156:	75bb      	strb	r3, [r7, #22]

  hal_status = HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 8028158:	68fb      	ldr	r3, [r7, #12]
 802815a:	f8d3 02c8 	ldr.w	r0, [r3, #712]	@ 0x2c8
 802815e:	7af9      	ldrb	r1, [r7, #11]
 8028160:	683b      	ldr	r3, [r7, #0]
 8028162:	687a      	ldr	r2, [r7, #4]
 8028164:	f7db fdeb 	bl	8003d3e <HAL_PCD_EP_Receive>
 8028168:	4603      	mov	r3, r0
 802816a:	75fb      	strb	r3, [r7, #23]

  usb_status =  USBD_Get_USB_Status(hal_status);
 802816c:	7dfb      	ldrb	r3, [r7, #23]
 802816e:	4618      	mov	r0, r3
 8028170:	f000 f832 	bl	80281d8 <USBD_Get_USB_Status>
 8028174:	4603      	mov	r3, r0
 8028176:	75bb      	strb	r3, [r7, #22]

  return usb_status;
 8028178:	7dbb      	ldrb	r3, [r7, #22]
}
 802817a:	4618      	mov	r0, r3
 802817c:	3718      	adds	r7, #24
 802817e:	46bd      	mov	sp, r7
 8028180:	bd80      	pop	{r7, pc}

08028182 <USBD_LL_GetRxDataSize>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval Received Data Size
  */
uint32_t USBD_LL_GetRxDataSize(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8028182:	b580      	push	{r7, lr}
 8028184:	b082      	sub	sp, #8
 8028186:	af00      	add	r7, sp, #0
 8028188:	6078      	str	r0, [r7, #4]
 802818a:	460b      	mov	r3, r1
 802818c:	70fb      	strb	r3, [r7, #3]
  return HAL_PCD_EP_GetRxCount((PCD_HandleTypeDef*) pdev->pData, ep_addr);
 802818e:	687b      	ldr	r3, [r7, #4]
 8028190:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 8028194:	78fa      	ldrb	r2, [r7, #3]
 8028196:	4611      	mov	r1, r2
 8028198:	4618      	mov	r0, r3
 802819a:	f7db fe0b 	bl	8003db4 <HAL_PCD_EP_GetRxCount>
 802819e:	4603      	mov	r3, r0
}
 80281a0:	4618      	mov	r0, r3
 80281a2:	3708      	adds	r7, #8
 80281a4:	46bd      	mov	sp, r7
 80281a6:	bd80      	pop	{r7, pc}

080281a8 <USBD_static_malloc>:
  * @brief  Static single allocation.
  * @param  size: Size of allocated memory
  * @retval None
  */
void *USBD_static_malloc(uint32_t size)
{
 80281a8:	b480      	push	{r7}
 80281aa:	b083      	sub	sp, #12
 80281ac:	af00      	add	r7, sp, #0
 80281ae:	6078      	str	r0, [r7, #4]
  static uint32_t mem[(sizeof(USBD_CDC_HandleTypeDef)/4)+1];/* On 32-bit boundary */
  return mem;
 80281b0:	4b03      	ldr	r3, [pc, #12]	@ (80281c0 <USBD_static_malloc+0x18>)
}
 80281b2:	4618      	mov	r0, r3
 80281b4:	370c      	adds	r7, #12
 80281b6:	46bd      	mov	sp, r7
 80281b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80281bc:	4770      	bx	lr
 80281be:	bf00      	nop
 80281c0:	200042d8 	.word	0x200042d8

080281c4 <USBD_static_free>:
  * @brief  Dummy memory free
  * @param  p: Pointer to allocated  memory address
  * @retval None
  */
void USBD_static_free(void *p)
{
 80281c4:	b480      	push	{r7}
 80281c6:	b083      	sub	sp, #12
 80281c8:	af00      	add	r7, sp, #0
 80281ca:	6078      	str	r0, [r7, #4]

}
 80281cc:	bf00      	nop
 80281ce:	370c      	adds	r7, #12
 80281d0:	46bd      	mov	sp, r7
 80281d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80281d6:	4770      	bx	lr

080281d8 <USBD_Get_USB_Status>:
  * @brief  Returns the USB status depending on the HAL status:
  * @param  hal_status: HAL status
  * @retval USB status
  */
USBD_StatusTypeDef USBD_Get_USB_Status(HAL_StatusTypeDef hal_status)
{
 80281d8:	b480      	push	{r7}
 80281da:	b085      	sub	sp, #20
 80281dc:	af00      	add	r7, sp, #0
 80281de:	4603      	mov	r3, r0
 80281e0:	71fb      	strb	r3, [r7, #7]
  USBD_StatusTypeDef usb_status = USBD_OK;
 80281e2:	2300      	movs	r3, #0
 80281e4:	73fb      	strb	r3, [r7, #15]

  switch (hal_status)
 80281e6:	79fb      	ldrb	r3, [r7, #7]
 80281e8:	2b03      	cmp	r3, #3
 80281ea:	d817      	bhi.n	802821c <USBD_Get_USB_Status+0x44>
 80281ec:	a201      	add	r2, pc, #4	@ (adr r2, 80281f4 <USBD_Get_USB_Status+0x1c>)
 80281ee:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80281f2:	bf00      	nop
 80281f4:	08028205 	.word	0x08028205
 80281f8:	0802820b 	.word	0x0802820b
 80281fc:	08028211 	.word	0x08028211
 8028200:	08028217 	.word	0x08028217
  {
    case HAL_OK :
      usb_status = USBD_OK;
 8028204:	2300      	movs	r3, #0
 8028206:	73fb      	strb	r3, [r7, #15]
    break;
 8028208:	e00b      	b.n	8028222 <USBD_Get_USB_Status+0x4a>
    case HAL_ERROR :
      usb_status = USBD_FAIL;
 802820a:	2303      	movs	r3, #3
 802820c:	73fb      	strb	r3, [r7, #15]
    break;
 802820e:	e008      	b.n	8028222 <USBD_Get_USB_Status+0x4a>
    case HAL_BUSY :
      usb_status = USBD_BUSY;
 8028210:	2301      	movs	r3, #1
 8028212:	73fb      	strb	r3, [r7, #15]
    break;
 8028214:	e005      	b.n	8028222 <USBD_Get_USB_Status+0x4a>
    case HAL_TIMEOUT :
      usb_status = USBD_FAIL;
 8028216:	2303      	movs	r3, #3
 8028218:	73fb      	strb	r3, [r7, #15]
    break;
 802821a:	e002      	b.n	8028222 <USBD_Get_USB_Status+0x4a>
    default :
      usb_status = USBD_FAIL;
 802821c:	2303      	movs	r3, #3
 802821e:	73fb      	strb	r3, [r7, #15]
    break;
 8028220:	bf00      	nop
  }
  return usb_status;
 8028222:	7bfb      	ldrb	r3, [r7, #15]
}
 8028224:	4618      	mov	r0, r3
 8028226:	3714      	adds	r7, #20
 8028228:	46bd      	mov	sp, r7
 802822a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802822e:	4770      	bx	lr

08028230 <malloc>:
 8028230:	4b02      	ldr	r3, [pc, #8]	@ (802823c <malloc+0xc>)
 8028232:	4601      	mov	r1, r0
 8028234:	6818      	ldr	r0, [r3, #0]
 8028236:	f000 b82d 	b.w	8028294 <_malloc_r>
 802823a:	bf00      	nop
 802823c:	20000134 	.word	0x20000134

08028240 <free>:
 8028240:	4b02      	ldr	r3, [pc, #8]	@ (802824c <free+0xc>)
 8028242:	4601      	mov	r1, r0
 8028244:	6818      	ldr	r0, [r3, #0]
 8028246:	f000 b9b7 	b.w	80285b8 <_free_r>
 802824a:	bf00      	nop
 802824c:	20000134 	.word	0x20000134

08028250 <sbrk_aligned>:
 8028250:	b570      	push	{r4, r5, r6, lr}
 8028252:	4e0f      	ldr	r6, [pc, #60]	@ (8028290 <sbrk_aligned+0x40>)
 8028254:	460c      	mov	r4, r1
 8028256:	6831      	ldr	r1, [r6, #0]
 8028258:	4605      	mov	r5, r0
 802825a:	b911      	cbnz	r1, 8028262 <sbrk_aligned+0x12>
 802825c:	f000 f962 	bl	8028524 <_sbrk_r>
 8028260:	6030      	str	r0, [r6, #0]
 8028262:	4621      	mov	r1, r4
 8028264:	4628      	mov	r0, r5
 8028266:	f000 f95d 	bl	8028524 <_sbrk_r>
 802826a:	1c43      	adds	r3, r0, #1
 802826c:	d103      	bne.n	8028276 <sbrk_aligned+0x26>
 802826e:	f04f 34ff 	mov.w	r4, #4294967295	@ 0xffffffff
 8028272:	4620      	mov	r0, r4
 8028274:	bd70      	pop	{r4, r5, r6, pc}
 8028276:	1cc4      	adds	r4, r0, #3
 8028278:	f024 0403 	bic.w	r4, r4, #3
 802827c:	42a0      	cmp	r0, r4
 802827e:	d0f8      	beq.n	8028272 <sbrk_aligned+0x22>
 8028280:	1a21      	subs	r1, r4, r0
 8028282:	4628      	mov	r0, r5
 8028284:	f000 f94e 	bl	8028524 <_sbrk_r>
 8028288:	3001      	adds	r0, #1
 802828a:	d1f2      	bne.n	8028272 <sbrk_aligned+0x22>
 802828c:	e7ef      	b.n	802826e <sbrk_aligned+0x1e>
 802828e:	bf00      	nop
 8028290:	200044f8 	.word	0x200044f8

08028294 <_malloc_r>:
 8028294:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8028298:	1ccd      	adds	r5, r1, #3
 802829a:	f025 0503 	bic.w	r5, r5, #3
 802829e:	3508      	adds	r5, #8
 80282a0:	2d0c      	cmp	r5, #12
 80282a2:	bf38      	it	cc
 80282a4:	250c      	movcc	r5, #12
 80282a6:	2d00      	cmp	r5, #0
 80282a8:	4606      	mov	r6, r0
 80282aa:	db01      	blt.n	80282b0 <_malloc_r+0x1c>
 80282ac:	42a9      	cmp	r1, r5
 80282ae:	d904      	bls.n	80282ba <_malloc_r+0x26>
 80282b0:	230c      	movs	r3, #12
 80282b2:	6033      	str	r3, [r6, #0]
 80282b4:	2000      	movs	r0, #0
 80282b6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80282ba:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ 8028390 <_malloc_r+0xfc>
 80282be:	f000 f869 	bl	8028394 <__malloc_lock>
 80282c2:	f8d8 3000 	ldr.w	r3, [r8]
 80282c6:	461c      	mov	r4, r3
 80282c8:	bb44      	cbnz	r4, 802831c <_malloc_r+0x88>
 80282ca:	4629      	mov	r1, r5
 80282cc:	4630      	mov	r0, r6
 80282ce:	f7ff ffbf 	bl	8028250 <sbrk_aligned>
 80282d2:	1c43      	adds	r3, r0, #1
 80282d4:	4604      	mov	r4, r0
 80282d6:	d158      	bne.n	802838a <_malloc_r+0xf6>
 80282d8:	f8d8 4000 	ldr.w	r4, [r8]
 80282dc:	4627      	mov	r7, r4
 80282de:	2f00      	cmp	r7, #0
 80282e0:	d143      	bne.n	802836a <_malloc_r+0xd6>
 80282e2:	2c00      	cmp	r4, #0
 80282e4:	d04b      	beq.n	802837e <_malloc_r+0xea>
 80282e6:	6823      	ldr	r3, [r4, #0]
 80282e8:	4639      	mov	r1, r7
 80282ea:	4630      	mov	r0, r6
 80282ec:	eb04 0903 	add.w	r9, r4, r3
 80282f0:	f000 f918 	bl	8028524 <_sbrk_r>
 80282f4:	4581      	cmp	r9, r0
 80282f6:	d142      	bne.n	802837e <_malloc_r+0xea>
 80282f8:	6821      	ldr	r1, [r4, #0]
 80282fa:	1a6d      	subs	r5, r5, r1
 80282fc:	4629      	mov	r1, r5
 80282fe:	4630      	mov	r0, r6
 8028300:	f7ff ffa6 	bl	8028250 <sbrk_aligned>
 8028304:	3001      	adds	r0, #1
 8028306:	d03a      	beq.n	802837e <_malloc_r+0xea>
 8028308:	6823      	ldr	r3, [r4, #0]
 802830a:	442b      	add	r3, r5
 802830c:	6023      	str	r3, [r4, #0]
 802830e:	f8d8 3000 	ldr.w	r3, [r8]
 8028312:	685a      	ldr	r2, [r3, #4]
 8028314:	bb62      	cbnz	r2, 8028370 <_malloc_r+0xdc>
 8028316:	f8c8 7000 	str.w	r7, [r8]
 802831a:	e00f      	b.n	802833c <_malloc_r+0xa8>
 802831c:	6822      	ldr	r2, [r4, #0]
 802831e:	1b52      	subs	r2, r2, r5
 8028320:	d420      	bmi.n	8028364 <_malloc_r+0xd0>
 8028322:	2a0b      	cmp	r2, #11
 8028324:	d917      	bls.n	8028356 <_malloc_r+0xc2>
 8028326:	1961      	adds	r1, r4, r5
 8028328:	42a3      	cmp	r3, r4
 802832a:	6025      	str	r5, [r4, #0]
 802832c:	bf18      	it	ne
 802832e:	6059      	strne	r1, [r3, #4]
 8028330:	6863      	ldr	r3, [r4, #4]
 8028332:	bf08      	it	eq
 8028334:	f8c8 1000 	streq.w	r1, [r8]
 8028338:	5162      	str	r2, [r4, r5]
 802833a:	604b      	str	r3, [r1, #4]
 802833c:	4630      	mov	r0, r6
 802833e:	f000 f82f 	bl	80283a0 <__malloc_unlock>
 8028342:	f104 000b 	add.w	r0, r4, #11
 8028346:	1d23      	adds	r3, r4, #4
 8028348:	f020 0007 	bic.w	r0, r0, #7
 802834c:	1ac2      	subs	r2, r0, r3
 802834e:	bf1c      	itt	ne
 8028350:	1a1b      	subne	r3, r3, r0
 8028352:	50a3      	strne	r3, [r4, r2]
 8028354:	e7af      	b.n	80282b6 <_malloc_r+0x22>
 8028356:	6862      	ldr	r2, [r4, #4]
 8028358:	42a3      	cmp	r3, r4
 802835a:	bf0c      	ite	eq
 802835c:	f8c8 2000 	streq.w	r2, [r8]
 8028360:	605a      	strne	r2, [r3, #4]
 8028362:	e7eb      	b.n	802833c <_malloc_r+0xa8>
 8028364:	4623      	mov	r3, r4
 8028366:	6864      	ldr	r4, [r4, #4]
 8028368:	e7ae      	b.n	80282c8 <_malloc_r+0x34>
 802836a:	463c      	mov	r4, r7
 802836c:	687f      	ldr	r7, [r7, #4]
 802836e:	e7b6      	b.n	80282de <_malloc_r+0x4a>
 8028370:	461a      	mov	r2, r3
 8028372:	685b      	ldr	r3, [r3, #4]
 8028374:	42a3      	cmp	r3, r4
 8028376:	d1fb      	bne.n	8028370 <_malloc_r+0xdc>
 8028378:	2300      	movs	r3, #0
 802837a:	6053      	str	r3, [r2, #4]
 802837c:	e7de      	b.n	802833c <_malloc_r+0xa8>
 802837e:	230c      	movs	r3, #12
 8028380:	6033      	str	r3, [r6, #0]
 8028382:	4630      	mov	r0, r6
 8028384:	f000 f80c 	bl	80283a0 <__malloc_unlock>
 8028388:	e794      	b.n	80282b4 <_malloc_r+0x20>
 802838a:	6005      	str	r5, [r0, #0]
 802838c:	e7d6      	b.n	802833c <_malloc_r+0xa8>
 802838e:	bf00      	nop
 8028390:	200044fc 	.word	0x200044fc

08028394 <__malloc_lock>:
 8028394:	4801      	ldr	r0, [pc, #4]	@ (802839c <__malloc_lock+0x8>)
 8028396:	f000 b8ff 	b.w	8028598 <__retarget_lock_acquire_recursive>
 802839a:	bf00      	nop
 802839c:	2000463c 	.word	0x2000463c

080283a0 <__malloc_unlock>:
 80283a0:	4801      	ldr	r0, [pc, #4]	@ (80283a8 <__malloc_unlock+0x8>)
 80283a2:	f000 b8fa 	b.w	802859a <__retarget_lock_release_recursive>
 80283a6:	bf00      	nop
 80283a8:	2000463c 	.word	0x2000463c

080283ac <_realloc_r>:
 80283ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80283b0:	4607      	mov	r7, r0
 80283b2:	4614      	mov	r4, r2
 80283b4:	460d      	mov	r5, r1
 80283b6:	b921      	cbnz	r1, 80283c2 <_realloc_r+0x16>
 80283b8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80283bc:	4611      	mov	r1, r2
 80283be:	f7ff bf69 	b.w	8028294 <_malloc_r>
 80283c2:	b92a      	cbnz	r2, 80283d0 <_realloc_r+0x24>
 80283c4:	f000 f8f8 	bl	80285b8 <_free_r>
 80283c8:	4625      	mov	r5, r4
 80283ca:	4628      	mov	r0, r5
 80283cc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80283d0:	f000 f93c 	bl	802864c <_malloc_usable_size_r>
 80283d4:	4284      	cmp	r4, r0
 80283d6:	4606      	mov	r6, r0
 80283d8:	d802      	bhi.n	80283e0 <_realloc_r+0x34>
 80283da:	ebb4 0f50 	cmp.w	r4, r0, lsr #1
 80283de:	d8f4      	bhi.n	80283ca <_realloc_r+0x1e>
 80283e0:	4621      	mov	r1, r4
 80283e2:	4638      	mov	r0, r7
 80283e4:	f7ff ff56 	bl	8028294 <_malloc_r>
 80283e8:	4680      	mov	r8, r0
 80283ea:	b908      	cbnz	r0, 80283f0 <_realloc_r+0x44>
 80283ec:	4645      	mov	r5, r8
 80283ee:	e7ec      	b.n	80283ca <_realloc_r+0x1e>
 80283f0:	42b4      	cmp	r4, r6
 80283f2:	4622      	mov	r2, r4
 80283f4:	4629      	mov	r1, r5
 80283f6:	bf28      	it	cs
 80283f8:	4632      	movcs	r2, r6
 80283fa:	f000 f8cf 	bl	802859c <memcpy>
 80283fe:	4629      	mov	r1, r5
 8028400:	4638      	mov	r0, r7
 8028402:	f000 f8d9 	bl	80285b8 <_free_r>
 8028406:	e7f1      	b.n	80283ec <_realloc_r+0x40>

08028408 <sniprintf>:
 8028408:	b40c      	push	{r2, r3}
 802840a:	b530      	push	{r4, r5, lr}
 802840c:	4b18      	ldr	r3, [pc, #96]	@ (8028470 <sniprintf+0x68>)
 802840e:	1e0c      	subs	r4, r1, #0
 8028410:	681d      	ldr	r5, [r3, #0]
 8028412:	b09d      	sub	sp, #116	@ 0x74
 8028414:	da08      	bge.n	8028428 <sniprintf+0x20>
 8028416:	238b      	movs	r3, #139	@ 0x8b
 8028418:	602b      	str	r3, [r5, #0]
 802841a:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 802841e:	b01d      	add	sp, #116	@ 0x74
 8028420:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 8028424:	b002      	add	sp, #8
 8028426:	4770      	bx	lr
 8028428:	f44f 7302 	mov.w	r3, #520	@ 0x208
 802842c:	f8ad 3014 	strh.w	r3, [sp, #20]
 8028430:	f04f 0300 	mov.w	r3, #0
 8028434:	931b      	str	r3, [sp, #108]	@ 0x6c
 8028436:	bf14      	ite	ne
 8028438:	f104 33ff 	addne.w	r3, r4, #4294967295	@ 0xffffffff
 802843c:	4623      	moveq	r3, r4
 802843e:	9304      	str	r3, [sp, #16]
 8028440:	9307      	str	r3, [sp, #28]
 8028442:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 8028446:	9002      	str	r0, [sp, #8]
 8028448:	9006      	str	r0, [sp, #24]
 802844a:	f8ad 3016 	strh.w	r3, [sp, #22]
 802844e:	9a20      	ldr	r2, [sp, #128]	@ 0x80
 8028450:	ab21      	add	r3, sp, #132	@ 0x84
 8028452:	a902      	add	r1, sp, #8
 8028454:	4628      	mov	r0, r5
 8028456:	9301      	str	r3, [sp, #4]
 8028458:	f000 f95c 	bl	8028714 <_svfiprintf_r>
 802845c:	1c43      	adds	r3, r0, #1
 802845e:	bfbc      	itt	lt
 8028460:	238b      	movlt	r3, #139	@ 0x8b
 8028462:	602b      	strlt	r3, [r5, #0]
 8028464:	2c00      	cmp	r4, #0
 8028466:	d0da      	beq.n	802841e <sniprintf+0x16>
 8028468:	9b02      	ldr	r3, [sp, #8]
 802846a:	2200      	movs	r2, #0
 802846c:	701a      	strb	r2, [r3, #0]
 802846e:	e7d6      	b.n	802841e <sniprintf+0x16>
 8028470:	20000134 	.word	0x20000134

08028474 <memcmp>:
 8028474:	b510      	push	{r4, lr}
 8028476:	3901      	subs	r1, #1
 8028478:	4402      	add	r2, r0
 802847a:	4290      	cmp	r0, r2
 802847c:	d101      	bne.n	8028482 <memcmp+0xe>
 802847e:	2000      	movs	r0, #0
 8028480:	e005      	b.n	802848e <memcmp+0x1a>
 8028482:	7803      	ldrb	r3, [r0, #0]
 8028484:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8028488:	42a3      	cmp	r3, r4
 802848a:	d001      	beq.n	8028490 <memcmp+0x1c>
 802848c:	1b18      	subs	r0, r3, r4
 802848e:	bd10      	pop	{r4, pc}
 8028490:	3001      	adds	r0, #1
 8028492:	e7f2      	b.n	802847a <memcmp+0x6>

08028494 <memmove>:
 8028494:	4288      	cmp	r0, r1
 8028496:	b510      	push	{r4, lr}
 8028498:	eb01 0402 	add.w	r4, r1, r2
 802849c:	d902      	bls.n	80284a4 <memmove+0x10>
 802849e:	4284      	cmp	r4, r0
 80284a0:	4623      	mov	r3, r4
 80284a2:	d807      	bhi.n	80284b4 <memmove+0x20>
 80284a4:	1e43      	subs	r3, r0, #1
 80284a6:	42a1      	cmp	r1, r4
 80284a8:	d008      	beq.n	80284bc <memmove+0x28>
 80284aa:	f811 2b01 	ldrb.w	r2, [r1], #1
 80284ae:	f803 2f01 	strb.w	r2, [r3, #1]!
 80284b2:	e7f8      	b.n	80284a6 <memmove+0x12>
 80284b4:	4402      	add	r2, r0
 80284b6:	4601      	mov	r1, r0
 80284b8:	428a      	cmp	r2, r1
 80284ba:	d100      	bne.n	80284be <memmove+0x2a>
 80284bc:	bd10      	pop	{r4, pc}
 80284be:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 80284c2:	f802 4d01 	strb.w	r4, [r2, #-1]!
 80284c6:	e7f7      	b.n	80284b8 <memmove+0x24>

080284c8 <memset>:
 80284c8:	4402      	add	r2, r0
 80284ca:	4603      	mov	r3, r0
 80284cc:	4293      	cmp	r3, r2
 80284ce:	d100      	bne.n	80284d2 <memset+0xa>
 80284d0:	4770      	bx	lr
 80284d2:	f803 1b01 	strb.w	r1, [r3], #1
 80284d6:	e7f9      	b.n	80284cc <memset+0x4>

080284d8 <strncmp>:
 80284d8:	b510      	push	{r4, lr}
 80284da:	b16a      	cbz	r2, 80284f8 <strncmp+0x20>
 80284dc:	3901      	subs	r1, #1
 80284de:	1884      	adds	r4, r0, r2
 80284e0:	f810 2b01 	ldrb.w	r2, [r0], #1
 80284e4:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 80284e8:	429a      	cmp	r2, r3
 80284ea:	d103      	bne.n	80284f4 <strncmp+0x1c>
 80284ec:	42a0      	cmp	r0, r4
 80284ee:	d001      	beq.n	80284f4 <strncmp+0x1c>
 80284f0:	2a00      	cmp	r2, #0
 80284f2:	d1f5      	bne.n	80284e0 <strncmp+0x8>
 80284f4:	1ad0      	subs	r0, r2, r3
 80284f6:	bd10      	pop	{r4, pc}
 80284f8:	4610      	mov	r0, r2
 80284fa:	e7fc      	b.n	80284f6 <strncmp+0x1e>

080284fc <strncpy>:
 80284fc:	b510      	push	{r4, lr}
 80284fe:	3901      	subs	r1, #1
 8028500:	4603      	mov	r3, r0
 8028502:	b132      	cbz	r2, 8028512 <strncpy+0x16>
 8028504:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8028508:	f803 4b01 	strb.w	r4, [r3], #1
 802850c:	3a01      	subs	r2, #1
 802850e:	2c00      	cmp	r4, #0
 8028510:	d1f7      	bne.n	8028502 <strncpy+0x6>
 8028512:	441a      	add	r2, r3
 8028514:	2100      	movs	r1, #0
 8028516:	4293      	cmp	r3, r2
 8028518:	d100      	bne.n	802851c <strncpy+0x20>
 802851a:	bd10      	pop	{r4, pc}
 802851c:	f803 1b01 	strb.w	r1, [r3], #1
 8028520:	e7f9      	b.n	8028516 <strncpy+0x1a>
	...

08028524 <_sbrk_r>:
 8028524:	b538      	push	{r3, r4, r5, lr}
 8028526:	4d06      	ldr	r5, [pc, #24]	@ (8028540 <_sbrk_r+0x1c>)
 8028528:	2300      	movs	r3, #0
 802852a:	4604      	mov	r4, r0
 802852c:	4608      	mov	r0, r1
 802852e:	602b      	str	r3, [r5, #0]
 8028530:	f7d9 fb3c 	bl	8001bac <_sbrk>
 8028534:	1c43      	adds	r3, r0, #1
 8028536:	d102      	bne.n	802853e <_sbrk_r+0x1a>
 8028538:	682b      	ldr	r3, [r5, #0]
 802853a:	b103      	cbz	r3, 802853e <_sbrk_r+0x1a>
 802853c:	6023      	str	r3, [r4, #0]
 802853e:	bd38      	pop	{r3, r4, r5, pc}
 8028540:	20004638 	.word	0x20004638

08028544 <__errno>:
 8028544:	4b01      	ldr	r3, [pc, #4]	@ (802854c <__errno+0x8>)
 8028546:	6818      	ldr	r0, [r3, #0]
 8028548:	4770      	bx	lr
 802854a:	bf00      	nop
 802854c:	20000134 	.word	0x20000134

08028550 <__libc_init_array>:
 8028550:	b570      	push	{r4, r5, r6, lr}
 8028552:	4d0d      	ldr	r5, [pc, #52]	@ (8028588 <__libc_init_array+0x38>)
 8028554:	4c0d      	ldr	r4, [pc, #52]	@ (802858c <__libc_init_array+0x3c>)
 8028556:	1b64      	subs	r4, r4, r5
 8028558:	10a4      	asrs	r4, r4, #2
 802855a:	2600      	movs	r6, #0
 802855c:	42a6      	cmp	r6, r4
 802855e:	d109      	bne.n	8028574 <__libc_init_array+0x24>
 8028560:	4d0b      	ldr	r5, [pc, #44]	@ (8028590 <__libc_init_array+0x40>)
 8028562:	4c0c      	ldr	r4, [pc, #48]	@ (8028594 <__libc_init_array+0x44>)
 8028564:	f000 fb5e 	bl	8028c24 <_init>
 8028568:	1b64      	subs	r4, r4, r5
 802856a:	10a4      	asrs	r4, r4, #2
 802856c:	2600      	movs	r6, #0
 802856e:	42a6      	cmp	r6, r4
 8028570:	d105      	bne.n	802857e <__libc_init_array+0x2e>
 8028572:	bd70      	pop	{r4, r5, r6, pc}
 8028574:	f855 3b04 	ldr.w	r3, [r5], #4
 8028578:	4798      	blx	r3
 802857a:	3601      	adds	r6, #1
 802857c:	e7ee      	b.n	802855c <__libc_init_array+0xc>
 802857e:	f855 3b04 	ldr.w	r3, [r5], #4
 8028582:	4798      	blx	r3
 8028584:	3601      	adds	r6, #1
 8028586:	e7f2      	b.n	802856e <__libc_init_array+0x1e>
 8028588:	08033f44 	.word	0x08033f44
 802858c:	08033f44 	.word	0x08033f44
 8028590:	08033f44 	.word	0x08033f44
 8028594:	08033f48 	.word	0x08033f48

08028598 <__retarget_lock_acquire_recursive>:
 8028598:	4770      	bx	lr

0802859a <__retarget_lock_release_recursive>:
 802859a:	4770      	bx	lr

0802859c <memcpy>:
 802859c:	440a      	add	r2, r1
 802859e:	4291      	cmp	r1, r2
 80285a0:	f100 33ff 	add.w	r3, r0, #4294967295	@ 0xffffffff
 80285a4:	d100      	bne.n	80285a8 <memcpy+0xc>
 80285a6:	4770      	bx	lr
 80285a8:	b510      	push	{r4, lr}
 80285aa:	f811 4b01 	ldrb.w	r4, [r1], #1
 80285ae:	f803 4f01 	strb.w	r4, [r3, #1]!
 80285b2:	4291      	cmp	r1, r2
 80285b4:	d1f9      	bne.n	80285aa <memcpy+0xe>
 80285b6:	bd10      	pop	{r4, pc}

080285b8 <_free_r>:
 80285b8:	b538      	push	{r3, r4, r5, lr}
 80285ba:	4605      	mov	r5, r0
 80285bc:	2900      	cmp	r1, #0
 80285be:	d041      	beq.n	8028644 <_free_r+0x8c>
 80285c0:	f851 3c04 	ldr.w	r3, [r1, #-4]
 80285c4:	1f0c      	subs	r4, r1, #4
 80285c6:	2b00      	cmp	r3, #0
 80285c8:	bfb8      	it	lt
 80285ca:	18e4      	addlt	r4, r4, r3
 80285cc:	f7ff fee2 	bl	8028394 <__malloc_lock>
 80285d0:	4a1d      	ldr	r2, [pc, #116]	@ (8028648 <_free_r+0x90>)
 80285d2:	6813      	ldr	r3, [r2, #0]
 80285d4:	b933      	cbnz	r3, 80285e4 <_free_r+0x2c>
 80285d6:	6063      	str	r3, [r4, #4]
 80285d8:	6014      	str	r4, [r2, #0]
 80285da:	4628      	mov	r0, r5
 80285dc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80285e0:	f7ff bede 	b.w	80283a0 <__malloc_unlock>
 80285e4:	42a3      	cmp	r3, r4
 80285e6:	d908      	bls.n	80285fa <_free_r+0x42>
 80285e8:	6820      	ldr	r0, [r4, #0]
 80285ea:	1821      	adds	r1, r4, r0
 80285ec:	428b      	cmp	r3, r1
 80285ee:	bf01      	itttt	eq
 80285f0:	6819      	ldreq	r1, [r3, #0]
 80285f2:	685b      	ldreq	r3, [r3, #4]
 80285f4:	1809      	addeq	r1, r1, r0
 80285f6:	6021      	streq	r1, [r4, #0]
 80285f8:	e7ed      	b.n	80285d6 <_free_r+0x1e>
 80285fa:	461a      	mov	r2, r3
 80285fc:	685b      	ldr	r3, [r3, #4]
 80285fe:	b10b      	cbz	r3, 8028604 <_free_r+0x4c>
 8028600:	42a3      	cmp	r3, r4
 8028602:	d9fa      	bls.n	80285fa <_free_r+0x42>
 8028604:	6811      	ldr	r1, [r2, #0]
 8028606:	1850      	adds	r0, r2, r1
 8028608:	42a0      	cmp	r0, r4
 802860a:	d10b      	bne.n	8028624 <_free_r+0x6c>
 802860c:	6820      	ldr	r0, [r4, #0]
 802860e:	4401      	add	r1, r0
 8028610:	1850      	adds	r0, r2, r1
 8028612:	4283      	cmp	r3, r0
 8028614:	6011      	str	r1, [r2, #0]
 8028616:	d1e0      	bne.n	80285da <_free_r+0x22>
 8028618:	6818      	ldr	r0, [r3, #0]
 802861a:	685b      	ldr	r3, [r3, #4]
 802861c:	6053      	str	r3, [r2, #4]
 802861e:	4408      	add	r0, r1
 8028620:	6010      	str	r0, [r2, #0]
 8028622:	e7da      	b.n	80285da <_free_r+0x22>
 8028624:	d902      	bls.n	802862c <_free_r+0x74>
 8028626:	230c      	movs	r3, #12
 8028628:	602b      	str	r3, [r5, #0]
 802862a:	e7d6      	b.n	80285da <_free_r+0x22>
 802862c:	6820      	ldr	r0, [r4, #0]
 802862e:	1821      	adds	r1, r4, r0
 8028630:	428b      	cmp	r3, r1
 8028632:	bf04      	itt	eq
 8028634:	6819      	ldreq	r1, [r3, #0]
 8028636:	685b      	ldreq	r3, [r3, #4]
 8028638:	6063      	str	r3, [r4, #4]
 802863a:	bf04      	itt	eq
 802863c:	1809      	addeq	r1, r1, r0
 802863e:	6021      	streq	r1, [r4, #0]
 8028640:	6054      	str	r4, [r2, #4]
 8028642:	e7ca      	b.n	80285da <_free_r+0x22>
 8028644:	bd38      	pop	{r3, r4, r5, pc}
 8028646:	bf00      	nop
 8028648:	200044fc 	.word	0x200044fc

0802864c <_malloc_usable_size_r>:
 802864c:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8028650:	1f18      	subs	r0, r3, #4
 8028652:	2b00      	cmp	r3, #0
 8028654:	bfbc      	itt	lt
 8028656:	580b      	ldrlt	r3, [r1, r0]
 8028658:	18c0      	addlt	r0, r0, r3
 802865a:	4770      	bx	lr

0802865c <__ssputs_r>:
 802865c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8028660:	688e      	ldr	r6, [r1, #8]
 8028662:	461f      	mov	r7, r3
 8028664:	42be      	cmp	r6, r7
 8028666:	680b      	ldr	r3, [r1, #0]
 8028668:	4682      	mov	sl, r0
 802866a:	460c      	mov	r4, r1
 802866c:	4690      	mov	r8, r2
 802866e:	d82d      	bhi.n	80286cc <__ssputs_r+0x70>
 8028670:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 8028674:	f412 6f90 	tst.w	r2, #1152	@ 0x480
 8028678:	d026      	beq.n	80286c8 <__ssputs_r+0x6c>
 802867a:	6965      	ldr	r5, [r4, #20]
 802867c:	6909      	ldr	r1, [r1, #16]
 802867e:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 8028682:	eba3 0901 	sub.w	r9, r3, r1
 8028686:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 802868a:	1c7b      	adds	r3, r7, #1
 802868c:	444b      	add	r3, r9
 802868e:	106d      	asrs	r5, r5, #1
 8028690:	429d      	cmp	r5, r3
 8028692:	bf38      	it	cc
 8028694:	461d      	movcc	r5, r3
 8028696:	0553      	lsls	r3, r2, #21
 8028698:	d527      	bpl.n	80286ea <__ssputs_r+0x8e>
 802869a:	4629      	mov	r1, r5
 802869c:	f7ff fdfa 	bl	8028294 <_malloc_r>
 80286a0:	4606      	mov	r6, r0
 80286a2:	b360      	cbz	r0, 80286fe <__ssputs_r+0xa2>
 80286a4:	6921      	ldr	r1, [r4, #16]
 80286a6:	464a      	mov	r2, r9
 80286a8:	f7ff ff78 	bl	802859c <memcpy>
 80286ac:	89a3      	ldrh	r3, [r4, #12]
 80286ae:	f423 6390 	bic.w	r3, r3, #1152	@ 0x480
 80286b2:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 80286b6:	81a3      	strh	r3, [r4, #12]
 80286b8:	6126      	str	r6, [r4, #16]
 80286ba:	6165      	str	r5, [r4, #20]
 80286bc:	444e      	add	r6, r9
 80286be:	eba5 0509 	sub.w	r5, r5, r9
 80286c2:	6026      	str	r6, [r4, #0]
 80286c4:	60a5      	str	r5, [r4, #8]
 80286c6:	463e      	mov	r6, r7
 80286c8:	42be      	cmp	r6, r7
 80286ca:	d900      	bls.n	80286ce <__ssputs_r+0x72>
 80286cc:	463e      	mov	r6, r7
 80286ce:	6820      	ldr	r0, [r4, #0]
 80286d0:	4632      	mov	r2, r6
 80286d2:	4641      	mov	r1, r8
 80286d4:	f7ff fede 	bl	8028494 <memmove>
 80286d8:	68a3      	ldr	r3, [r4, #8]
 80286da:	1b9b      	subs	r3, r3, r6
 80286dc:	60a3      	str	r3, [r4, #8]
 80286de:	6823      	ldr	r3, [r4, #0]
 80286e0:	4433      	add	r3, r6
 80286e2:	6023      	str	r3, [r4, #0]
 80286e4:	2000      	movs	r0, #0
 80286e6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80286ea:	462a      	mov	r2, r5
 80286ec:	f7ff fe5e 	bl	80283ac <_realloc_r>
 80286f0:	4606      	mov	r6, r0
 80286f2:	2800      	cmp	r0, #0
 80286f4:	d1e0      	bne.n	80286b8 <__ssputs_r+0x5c>
 80286f6:	6921      	ldr	r1, [r4, #16]
 80286f8:	4650      	mov	r0, sl
 80286fa:	f7ff ff5d 	bl	80285b8 <_free_r>
 80286fe:	230c      	movs	r3, #12
 8028700:	f8ca 3000 	str.w	r3, [sl]
 8028704:	89a3      	ldrh	r3, [r4, #12]
 8028706:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 802870a:	81a3      	strh	r3, [r4, #12]
 802870c:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8028710:	e7e9      	b.n	80286e6 <__ssputs_r+0x8a>
	...

08028714 <_svfiprintf_r>:
 8028714:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8028718:	4698      	mov	r8, r3
 802871a:	898b      	ldrh	r3, [r1, #12]
 802871c:	061b      	lsls	r3, r3, #24
 802871e:	b09d      	sub	sp, #116	@ 0x74
 8028720:	4607      	mov	r7, r0
 8028722:	460d      	mov	r5, r1
 8028724:	4614      	mov	r4, r2
 8028726:	d510      	bpl.n	802874a <_svfiprintf_r+0x36>
 8028728:	690b      	ldr	r3, [r1, #16]
 802872a:	b973      	cbnz	r3, 802874a <_svfiprintf_r+0x36>
 802872c:	2140      	movs	r1, #64	@ 0x40
 802872e:	f7ff fdb1 	bl	8028294 <_malloc_r>
 8028732:	6028      	str	r0, [r5, #0]
 8028734:	6128      	str	r0, [r5, #16]
 8028736:	b930      	cbnz	r0, 8028746 <_svfiprintf_r+0x32>
 8028738:	230c      	movs	r3, #12
 802873a:	603b      	str	r3, [r7, #0]
 802873c:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8028740:	b01d      	add	sp, #116	@ 0x74
 8028742:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8028746:	2340      	movs	r3, #64	@ 0x40
 8028748:	616b      	str	r3, [r5, #20]
 802874a:	2300      	movs	r3, #0
 802874c:	9309      	str	r3, [sp, #36]	@ 0x24
 802874e:	2320      	movs	r3, #32
 8028750:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
 8028754:	f8cd 800c 	str.w	r8, [sp, #12]
 8028758:	2330      	movs	r3, #48	@ 0x30
 802875a:	f8df 819c 	ldr.w	r8, [pc, #412]	@ 80288f8 <_svfiprintf_r+0x1e4>
 802875e:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
 8028762:	f04f 0901 	mov.w	r9, #1
 8028766:	4623      	mov	r3, r4
 8028768:	469a      	mov	sl, r3
 802876a:	f813 2b01 	ldrb.w	r2, [r3], #1
 802876e:	b10a      	cbz	r2, 8028774 <_svfiprintf_r+0x60>
 8028770:	2a25      	cmp	r2, #37	@ 0x25
 8028772:	d1f9      	bne.n	8028768 <_svfiprintf_r+0x54>
 8028774:	ebba 0b04 	subs.w	fp, sl, r4
 8028778:	d00b      	beq.n	8028792 <_svfiprintf_r+0x7e>
 802877a:	465b      	mov	r3, fp
 802877c:	4622      	mov	r2, r4
 802877e:	4629      	mov	r1, r5
 8028780:	4638      	mov	r0, r7
 8028782:	f7ff ff6b 	bl	802865c <__ssputs_r>
 8028786:	3001      	adds	r0, #1
 8028788:	f000 80a7 	beq.w	80288da <_svfiprintf_r+0x1c6>
 802878c:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 802878e:	445a      	add	r2, fp
 8028790:	9209      	str	r2, [sp, #36]	@ 0x24
 8028792:	f89a 3000 	ldrb.w	r3, [sl]
 8028796:	2b00      	cmp	r3, #0
 8028798:	f000 809f 	beq.w	80288da <_svfiprintf_r+0x1c6>
 802879c:	2300      	movs	r3, #0
 802879e:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 80287a2:	e9cd 2305 	strd	r2, r3, [sp, #20]
 80287a6:	f10a 0a01 	add.w	sl, sl, #1
 80287aa:	9304      	str	r3, [sp, #16]
 80287ac:	9307      	str	r3, [sp, #28]
 80287ae:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
 80287b2:	931a      	str	r3, [sp, #104]	@ 0x68
 80287b4:	4654      	mov	r4, sl
 80287b6:	2205      	movs	r2, #5
 80287b8:	f814 1b01 	ldrb.w	r1, [r4], #1
 80287bc:	484e      	ldr	r0, [pc, #312]	@ (80288f8 <_svfiprintf_r+0x1e4>)
 80287be:	f7d7 fd1f 	bl	8000200 <memchr>
 80287c2:	9a04      	ldr	r2, [sp, #16]
 80287c4:	b9d8      	cbnz	r0, 80287fe <_svfiprintf_r+0xea>
 80287c6:	06d0      	lsls	r0, r2, #27
 80287c8:	bf44      	itt	mi
 80287ca:	2320      	movmi	r3, #32
 80287cc:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 80287d0:	0711      	lsls	r1, r2, #28
 80287d2:	bf44      	itt	mi
 80287d4:	232b      	movmi	r3, #43	@ 0x2b
 80287d6:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 80287da:	f89a 3000 	ldrb.w	r3, [sl]
 80287de:	2b2a      	cmp	r3, #42	@ 0x2a
 80287e0:	d015      	beq.n	802880e <_svfiprintf_r+0xfa>
 80287e2:	9a07      	ldr	r2, [sp, #28]
 80287e4:	4654      	mov	r4, sl
 80287e6:	2000      	movs	r0, #0
 80287e8:	f04f 0c0a 	mov.w	ip, #10
 80287ec:	4621      	mov	r1, r4
 80287ee:	f811 3b01 	ldrb.w	r3, [r1], #1
 80287f2:	3b30      	subs	r3, #48	@ 0x30
 80287f4:	2b09      	cmp	r3, #9
 80287f6:	d94b      	bls.n	8028890 <_svfiprintf_r+0x17c>
 80287f8:	b1b0      	cbz	r0, 8028828 <_svfiprintf_r+0x114>
 80287fa:	9207      	str	r2, [sp, #28]
 80287fc:	e014      	b.n	8028828 <_svfiprintf_r+0x114>
 80287fe:	eba0 0308 	sub.w	r3, r0, r8
 8028802:	fa09 f303 	lsl.w	r3, r9, r3
 8028806:	4313      	orrs	r3, r2
 8028808:	9304      	str	r3, [sp, #16]
 802880a:	46a2      	mov	sl, r4
 802880c:	e7d2      	b.n	80287b4 <_svfiprintf_r+0xa0>
 802880e:	9b03      	ldr	r3, [sp, #12]
 8028810:	1d19      	adds	r1, r3, #4
 8028812:	681b      	ldr	r3, [r3, #0]
 8028814:	9103      	str	r1, [sp, #12]
 8028816:	2b00      	cmp	r3, #0
 8028818:	bfbb      	ittet	lt
 802881a:	425b      	neglt	r3, r3
 802881c:	f042 0202 	orrlt.w	r2, r2, #2
 8028820:	9307      	strge	r3, [sp, #28]
 8028822:	9307      	strlt	r3, [sp, #28]
 8028824:	bfb8      	it	lt
 8028826:	9204      	strlt	r2, [sp, #16]
 8028828:	7823      	ldrb	r3, [r4, #0]
 802882a:	2b2e      	cmp	r3, #46	@ 0x2e
 802882c:	d10a      	bne.n	8028844 <_svfiprintf_r+0x130>
 802882e:	7863      	ldrb	r3, [r4, #1]
 8028830:	2b2a      	cmp	r3, #42	@ 0x2a
 8028832:	d132      	bne.n	802889a <_svfiprintf_r+0x186>
 8028834:	9b03      	ldr	r3, [sp, #12]
 8028836:	1d1a      	adds	r2, r3, #4
 8028838:	681b      	ldr	r3, [r3, #0]
 802883a:	9203      	str	r2, [sp, #12]
 802883c:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 8028840:	3402      	adds	r4, #2
 8028842:	9305      	str	r3, [sp, #20]
 8028844:	f8df a0c0 	ldr.w	sl, [pc, #192]	@ 8028908 <_svfiprintf_r+0x1f4>
 8028848:	7821      	ldrb	r1, [r4, #0]
 802884a:	2203      	movs	r2, #3
 802884c:	4650      	mov	r0, sl
 802884e:	f7d7 fcd7 	bl	8000200 <memchr>
 8028852:	b138      	cbz	r0, 8028864 <_svfiprintf_r+0x150>
 8028854:	9b04      	ldr	r3, [sp, #16]
 8028856:	eba0 000a 	sub.w	r0, r0, sl
 802885a:	2240      	movs	r2, #64	@ 0x40
 802885c:	4082      	lsls	r2, r0
 802885e:	4313      	orrs	r3, r2
 8028860:	3401      	adds	r4, #1
 8028862:	9304      	str	r3, [sp, #16]
 8028864:	f814 1b01 	ldrb.w	r1, [r4], #1
 8028868:	4824      	ldr	r0, [pc, #144]	@ (80288fc <_svfiprintf_r+0x1e8>)
 802886a:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
 802886e:	2206      	movs	r2, #6
 8028870:	f7d7 fcc6 	bl	8000200 <memchr>
 8028874:	2800      	cmp	r0, #0
 8028876:	d036      	beq.n	80288e6 <_svfiprintf_r+0x1d2>
 8028878:	4b21      	ldr	r3, [pc, #132]	@ (8028900 <_svfiprintf_r+0x1ec>)
 802887a:	bb1b      	cbnz	r3, 80288c4 <_svfiprintf_r+0x1b0>
 802887c:	9b03      	ldr	r3, [sp, #12]
 802887e:	3307      	adds	r3, #7
 8028880:	f023 0307 	bic.w	r3, r3, #7
 8028884:	3308      	adds	r3, #8
 8028886:	9303      	str	r3, [sp, #12]
 8028888:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 802888a:	4433      	add	r3, r6
 802888c:	9309      	str	r3, [sp, #36]	@ 0x24
 802888e:	e76a      	b.n	8028766 <_svfiprintf_r+0x52>
 8028890:	fb0c 3202 	mla	r2, ip, r2, r3
 8028894:	460c      	mov	r4, r1
 8028896:	2001      	movs	r0, #1
 8028898:	e7a8      	b.n	80287ec <_svfiprintf_r+0xd8>
 802889a:	2300      	movs	r3, #0
 802889c:	3401      	adds	r4, #1
 802889e:	9305      	str	r3, [sp, #20]
 80288a0:	4619      	mov	r1, r3
 80288a2:	f04f 0c0a 	mov.w	ip, #10
 80288a6:	4620      	mov	r0, r4
 80288a8:	f810 2b01 	ldrb.w	r2, [r0], #1
 80288ac:	3a30      	subs	r2, #48	@ 0x30
 80288ae:	2a09      	cmp	r2, #9
 80288b0:	d903      	bls.n	80288ba <_svfiprintf_r+0x1a6>
 80288b2:	2b00      	cmp	r3, #0
 80288b4:	d0c6      	beq.n	8028844 <_svfiprintf_r+0x130>
 80288b6:	9105      	str	r1, [sp, #20]
 80288b8:	e7c4      	b.n	8028844 <_svfiprintf_r+0x130>
 80288ba:	fb0c 2101 	mla	r1, ip, r1, r2
 80288be:	4604      	mov	r4, r0
 80288c0:	2301      	movs	r3, #1
 80288c2:	e7f0      	b.n	80288a6 <_svfiprintf_r+0x192>
 80288c4:	ab03      	add	r3, sp, #12
 80288c6:	9300      	str	r3, [sp, #0]
 80288c8:	462a      	mov	r2, r5
 80288ca:	4b0e      	ldr	r3, [pc, #56]	@ (8028904 <_svfiprintf_r+0x1f0>)
 80288cc:	a904      	add	r1, sp, #16
 80288ce:	4638      	mov	r0, r7
 80288d0:	f3af 8000 	nop.w
 80288d4:	1c42      	adds	r2, r0, #1
 80288d6:	4606      	mov	r6, r0
 80288d8:	d1d6      	bne.n	8028888 <_svfiprintf_r+0x174>
 80288da:	89ab      	ldrh	r3, [r5, #12]
 80288dc:	065b      	lsls	r3, r3, #25
 80288de:	f53f af2d 	bmi.w	802873c <_svfiprintf_r+0x28>
 80288e2:	9809      	ldr	r0, [sp, #36]	@ 0x24
 80288e4:	e72c      	b.n	8028740 <_svfiprintf_r+0x2c>
 80288e6:	ab03      	add	r3, sp, #12
 80288e8:	9300      	str	r3, [sp, #0]
 80288ea:	462a      	mov	r2, r5
 80288ec:	4b05      	ldr	r3, [pc, #20]	@ (8028904 <_svfiprintf_r+0x1f0>)
 80288ee:	a904      	add	r1, sp, #16
 80288f0:	4638      	mov	r0, r7
 80288f2:	f000 f879 	bl	80289e8 <_printf_i>
 80288f6:	e7ed      	b.n	80288d4 <_svfiprintf_r+0x1c0>
 80288f8:	08033f09 	.word	0x08033f09
 80288fc:	08033f13 	.word	0x08033f13
 8028900:	00000000 	.word	0x00000000
 8028904:	0802865d 	.word	0x0802865d
 8028908:	08033f0f 	.word	0x08033f0f

0802890c <_printf_common>:
 802890c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8028910:	4616      	mov	r6, r2
 8028912:	4698      	mov	r8, r3
 8028914:	688a      	ldr	r2, [r1, #8]
 8028916:	690b      	ldr	r3, [r1, #16]
 8028918:	f8dd 9020 	ldr.w	r9, [sp, #32]
 802891c:	4293      	cmp	r3, r2
 802891e:	bfb8      	it	lt
 8028920:	4613      	movlt	r3, r2
 8028922:	6033      	str	r3, [r6, #0]
 8028924:	f891 2043 	ldrb.w	r2, [r1, #67]	@ 0x43
 8028928:	4607      	mov	r7, r0
 802892a:	460c      	mov	r4, r1
 802892c:	b10a      	cbz	r2, 8028932 <_printf_common+0x26>
 802892e:	3301      	adds	r3, #1
 8028930:	6033      	str	r3, [r6, #0]
 8028932:	6823      	ldr	r3, [r4, #0]
 8028934:	0699      	lsls	r1, r3, #26
 8028936:	bf42      	ittt	mi
 8028938:	6833      	ldrmi	r3, [r6, #0]
 802893a:	3302      	addmi	r3, #2
 802893c:	6033      	strmi	r3, [r6, #0]
 802893e:	6825      	ldr	r5, [r4, #0]
 8028940:	f015 0506 	ands.w	r5, r5, #6
 8028944:	d106      	bne.n	8028954 <_printf_common+0x48>
 8028946:	f104 0a19 	add.w	sl, r4, #25
 802894a:	68e3      	ldr	r3, [r4, #12]
 802894c:	6832      	ldr	r2, [r6, #0]
 802894e:	1a9b      	subs	r3, r3, r2
 8028950:	42ab      	cmp	r3, r5
 8028952:	dc26      	bgt.n	80289a2 <_printf_common+0x96>
 8028954:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
 8028958:	6822      	ldr	r2, [r4, #0]
 802895a:	3b00      	subs	r3, #0
 802895c:	bf18      	it	ne
 802895e:	2301      	movne	r3, #1
 8028960:	0692      	lsls	r2, r2, #26
 8028962:	d42b      	bmi.n	80289bc <_printf_common+0xb0>
 8028964:	f104 0243 	add.w	r2, r4, #67	@ 0x43
 8028968:	4641      	mov	r1, r8
 802896a:	4638      	mov	r0, r7
 802896c:	47c8      	blx	r9
 802896e:	3001      	adds	r0, #1
 8028970:	d01e      	beq.n	80289b0 <_printf_common+0xa4>
 8028972:	6823      	ldr	r3, [r4, #0]
 8028974:	6922      	ldr	r2, [r4, #16]
 8028976:	f003 0306 	and.w	r3, r3, #6
 802897a:	2b04      	cmp	r3, #4
 802897c:	bf02      	ittt	eq
 802897e:	68e5      	ldreq	r5, [r4, #12]
 8028980:	6833      	ldreq	r3, [r6, #0]
 8028982:	1aed      	subeq	r5, r5, r3
 8028984:	68a3      	ldr	r3, [r4, #8]
 8028986:	bf0c      	ite	eq
 8028988:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 802898c:	2500      	movne	r5, #0
 802898e:	4293      	cmp	r3, r2
 8028990:	bfc4      	itt	gt
 8028992:	1a9b      	subgt	r3, r3, r2
 8028994:	18ed      	addgt	r5, r5, r3
 8028996:	2600      	movs	r6, #0
 8028998:	341a      	adds	r4, #26
 802899a:	42b5      	cmp	r5, r6
 802899c:	d11a      	bne.n	80289d4 <_printf_common+0xc8>
 802899e:	2000      	movs	r0, #0
 80289a0:	e008      	b.n	80289b4 <_printf_common+0xa8>
 80289a2:	2301      	movs	r3, #1
 80289a4:	4652      	mov	r2, sl
 80289a6:	4641      	mov	r1, r8
 80289a8:	4638      	mov	r0, r7
 80289aa:	47c8      	blx	r9
 80289ac:	3001      	adds	r0, #1
 80289ae:	d103      	bne.n	80289b8 <_printf_common+0xac>
 80289b0:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 80289b4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80289b8:	3501      	adds	r5, #1
 80289ba:	e7c6      	b.n	802894a <_printf_common+0x3e>
 80289bc:	18e1      	adds	r1, r4, r3
 80289be:	1c5a      	adds	r2, r3, #1
 80289c0:	2030      	movs	r0, #48	@ 0x30
 80289c2:	f881 0043 	strb.w	r0, [r1, #67]	@ 0x43
 80289c6:	4422      	add	r2, r4
 80289c8:	f894 1045 	ldrb.w	r1, [r4, #69]	@ 0x45
 80289cc:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
 80289d0:	3302      	adds	r3, #2
 80289d2:	e7c7      	b.n	8028964 <_printf_common+0x58>
 80289d4:	2301      	movs	r3, #1
 80289d6:	4622      	mov	r2, r4
 80289d8:	4641      	mov	r1, r8
 80289da:	4638      	mov	r0, r7
 80289dc:	47c8      	blx	r9
 80289de:	3001      	adds	r0, #1
 80289e0:	d0e6      	beq.n	80289b0 <_printf_common+0xa4>
 80289e2:	3601      	adds	r6, #1
 80289e4:	e7d9      	b.n	802899a <_printf_common+0x8e>
	...

080289e8 <_printf_i>:
 80289e8:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 80289ec:	7e0f      	ldrb	r7, [r1, #24]
 80289ee:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
 80289f0:	2f78      	cmp	r7, #120	@ 0x78
 80289f2:	4691      	mov	r9, r2
 80289f4:	4680      	mov	r8, r0
 80289f6:	460c      	mov	r4, r1
 80289f8:	469a      	mov	sl, r3
 80289fa:	f101 0243 	add.w	r2, r1, #67	@ 0x43
 80289fe:	d807      	bhi.n	8028a10 <_printf_i+0x28>
 8028a00:	2f62      	cmp	r7, #98	@ 0x62
 8028a02:	d80a      	bhi.n	8028a1a <_printf_i+0x32>
 8028a04:	2f00      	cmp	r7, #0
 8028a06:	f000 80d1 	beq.w	8028bac <_printf_i+0x1c4>
 8028a0a:	2f58      	cmp	r7, #88	@ 0x58
 8028a0c:	f000 80b8 	beq.w	8028b80 <_printf_i+0x198>
 8028a10:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 8028a14:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
 8028a18:	e03a      	b.n	8028a90 <_printf_i+0xa8>
 8028a1a:	f1a7 0363 	sub.w	r3, r7, #99	@ 0x63
 8028a1e:	2b15      	cmp	r3, #21
 8028a20:	d8f6      	bhi.n	8028a10 <_printf_i+0x28>
 8028a22:	a101      	add	r1, pc, #4	@ (adr r1, 8028a28 <_printf_i+0x40>)
 8028a24:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 8028a28:	08028a81 	.word	0x08028a81
 8028a2c:	08028a95 	.word	0x08028a95
 8028a30:	08028a11 	.word	0x08028a11
 8028a34:	08028a11 	.word	0x08028a11
 8028a38:	08028a11 	.word	0x08028a11
 8028a3c:	08028a11 	.word	0x08028a11
 8028a40:	08028a95 	.word	0x08028a95
 8028a44:	08028a11 	.word	0x08028a11
 8028a48:	08028a11 	.word	0x08028a11
 8028a4c:	08028a11 	.word	0x08028a11
 8028a50:	08028a11 	.word	0x08028a11
 8028a54:	08028b93 	.word	0x08028b93
 8028a58:	08028abf 	.word	0x08028abf
 8028a5c:	08028b4d 	.word	0x08028b4d
 8028a60:	08028a11 	.word	0x08028a11
 8028a64:	08028a11 	.word	0x08028a11
 8028a68:	08028bb5 	.word	0x08028bb5
 8028a6c:	08028a11 	.word	0x08028a11
 8028a70:	08028abf 	.word	0x08028abf
 8028a74:	08028a11 	.word	0x08028a11
 8028a78:	08028a11 	.word	0x08028a11
 8028a7c:	08028b55 	.word	0x08028b55
 8028a80:	6833      	ldr	r3, [r6, #0]
 8028a82:	1d1a      	adds	r2, r3, #4
 8028a84:	681b      	ldr	r3, [r3, #0]
 8028a86:	6032      	str	r2, [r6, #0]
 8028a88:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 8028a8c:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
 8028a90:	2301      	movs	r3, #1
 8028a92:	e09c      	b.n	8028bce <_printf_i+0x1e6>
 8028a94:	6833      	ldr	r3, [r6, #0]
 8028a96:	6820      	ldr	r0, [r4, #0]
 8028a98:	1d19      	adds	r1, r3, #4
 8028a9a:	6031      	str	r1, [r6, #0]
 8028a9c:	0606      	lsls	r6, r0, #24
 8028a9e:	d501      	bpl.n	8028aa4 <_printf_i+0xbc>
 8028aa0:	681d      	ldr	r5, [r3, #0]
 8028aa2:	e003      	b.n	8028aac <_printf_i+0xc4>
 8028aa4:	0645      	lsls	r5, r0, #25
 8028aa6:	d5fb      	bpl.n	8028aa0 <_printf_i+0xb8>
 8028aa8:	f9b3 5000 	ldrsh.w	r5, [r3]
 8028aac:	2d00      	cmp	r5, #0
 8028aae:	da03      	bge.n	8028ab8 <_printf_i+0xd0>
 8028ab0:	232d      	movs	r3, #45	@ 0x2d
 8028ab2:	426d      	negs	r5, r5
 8028ab4:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 8028ab8:	4858      	ldr	r0, [pc, #352]	@ (8028c1c <_printf_i+0x234>)
 8028aba:	230a      	movs	r3, #10
 8028abc:	e011      	b.n	8028ae2 <_printf_i+0xfa>
 8028abe:	6821      	ldr	r1, [r4, #0]
 8028ac0:	6833      	ldr	r3, [r6, #0]
 8028ac2:	0608      	lsls	r0, r1, #24
 8028ac4:	f853 5b04 	ldr.w	r5, [r3], #4
 8028ac8:	d402      	bmi.n	8028ad0 <_printf_i+0xe8>
 8028aca:	0649      	lsls	r1, r1, #25
 8028acc:	bf48      	it	mi
 8028ace:	b2ad      	uxthmi	r5, r5
 8028ad0:	2f6f      	cmp	r7, #111	@ 0x6f
 8028ad2:	4852      	ldr	r0, [pc, #328]	@ (8028c1c <_printf_i+0x234>)
 8028ad4:	6033      	str	r3, [r6, #0]
 8028ad6:	bf14      	ite	ne
 8028ad8:	230a      	movne	r3, #10
 8028ada:	2308      	moveq	r3, #8
 8028adc:	2100      	movs	r1, #0
 8028ade:	f884 1043 	strb.w	r1, [r4, #67]	@ 0x43
 8028ae2:	6866      	ldr	r6, [r4, #4]
 8028ae4:	60a6      	str	r6, [r4, #8]
 8028ae6:	2e00      	cmp	r6, #0
 8028ae8:	db05      	blt.n	8028af6 <_printf_i+0x10e>
 8028aea:	6821      	ldr	r1, [r4, #0]
 8028aec:	432e      	orrs	r6, r5
 8028aee:	f021 0104 	bic.w	r1, r1, #4
 8028af2:	6021      	str	r1, [r4, #0]
 8028af4:	d04b      	beq.n	8028b8e <_printf_i+0x1a6>
 8028af6:	4616      	mov	r6, r2
 8028af8:	fbb5 f1f3 	udiv	r1, r5, r3
 8028afc:	fb03 5711 	mls	r7, r3, r1, r5
 8028b00:	5dc7      	ldrb	r7, [r0, r7]
 8028b02:	f806 7d01 	strb.w	r7, [r6, #-1]!
 8028b06:	462f      	mov	r7, r5
 8028b08:	42bb      	cmp	r3, r7
 8028b0a:	460d      	mov	r5, r1
 8028b0c:	d9f4      	bls.n	8028af8 <_printf_i+0x110>
 8028b0e:	2b08      	cmp	r3, #8
 8028b10:	d10b      	bne.n	8028b2a <_printf_i+0x142>
 8028b12:	6823      	ldr	r3, [r4, #0]
 8028b14:	07df      	lsls	r7, r3, #31
 8028b16:	d508      	bpl.n	8028b2a <_printf_i+0x142>
 8028b18:	6923      	ldr	r3, [r4, #16]
 8028b1a:	6861      	ldr	r1, [r4, #4]
 8028b1c:	4299      	cmp	r1, r3
 8028b1e:	bfde      	ittt	le
 8028b20:	2330      	movle	r3, #48	@ 0x30
 8028b22:	f806 3c01 	strble.w	r3, [r6, #-1]
 8028b26:	f106 36ff 	addle.w	r6, r6, #4294967295	@ 0xffffffff
 8028b2a:	1b92      	subs	r2, r2, r6
 8028b2c:	6122      	str	r2, [r4, #16]
 8028b2e:	f8cd a000 	str.w	sl, [sp]
 8028b32:	464b      	mov	r3, r9
 8028b34:	aa03      	add	r2, sp, #12
 8028b36:	4621      	mov	r1, r4
 8028b38:	4640      	mov	r0, r8
 8028b3a:	f7ff fee7 	bl	802890c <_printf_common>
 8028b3e:	3001      	adds	r0, #1
 8028b40:	d14a      	bne.n	8028bd8 <_printf_i+0x1f0>
 8028b42:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8028b46:	b004      	add	sp, #16
 8028b48:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8028b4c:	6823      	ldr	r3, [r4, #0]
 8028b4e:	f043 0320 	orr.w	r3, r3, #32
 8028b52:	6023      	str	r3, [r4, #0]
 8028b54:	4832      	ldr	r0, [pc, #200]	@ (8028c20 <_printf_i+0x238>)
 8028b56:	2778      	movs	r7, #120	@ 0x78
 8028b58:	f884 7045 	strb.w	r7, [r4, #69]	@ 0x45
 8028b5c:	6823      	ldr	r3, [r4, #0]
 8028b5e:	6831      	ldr	r1, [r6, #0]
 8028b60:	061f      	lsls	r7, r3, #24
 8028b62:	f851 5b04 	ldr.w	r5, [r1], #4
 8028b66:	d402      	bmi.n	8028b6e <_printf_i+0x186>
 8028b68:	065f      	lsls	r7, r3, #25
 8028b6a:	bf48      	it	mi
 8028b6c:	b2ad      	uxthmi	r5, r5
 8028b6e:	6031      	str	r1, [r6, #0]
 8028b70:	07d9      	lsls	r1, r3, #31
 8028b72:	bf44      	itt	mi
 8028b74:	f043 0320 	orrmi.w	r3, r3, #32
 8028b78:	6023      	strmi	r3, [r4, #0]
 8028b7a:	b11d      	cbz	r5, 8028b84 <_printf_i+0x19c>
 8028b7c:	2310      	movs	r3, #16
 8028b7e:	e7ad      	b.n	8028adc <_printf_i+0xf4>
 8028b80:	4826      	ldr	r0, [pc, #152]	@ (8028c1c <_printf_i+0x234>)
 8028b82:	e7e9      	b.n	8028b58 <_printf_i+0x170>
 8028b84:	6823      	ldr	r3, [r4, #0]
 8028b86:	f023 0320 	bic.w	r3, r3, #32
 8028b8a:	6023      	str	r3, [r4, #0]
 8028b8c:	e7f6      	b.n	8028b7c <_printf_i+0x194>
 8028b8e:	4616      	mov	r6, r2
 8028b90:	e7bd      	b.n	8028b0e <_printf_i+0x126>
 8028b92:	6833      	ldr	r3, [r6, #0]
 8028b94:	6825      	ldr	r5, [r4, #0]
 8028b96:	6961      	ldr	r1, [r4, #20]
 8028b98:	1d18      	adds	r0, r3, #4
 8028b9a:	6030      	str	r0, [r6, #0]
 8028b9c:	062e      	lsls	r6, r5, #24
 8028b9e:	681b      	ldr	r3, [r3, #0]
 8028ba0:	d501      	bpl.n	8028ba6 <_printf_i+0x1be>
 8028ba2:	6019      	str	r1, [r3, #0]
 8028ba4:	e002      	b.n	8028bac <_printf_i+0x1c4>
 8028ba6:	0668      	lsls	r0, r5, #25
 8028ba8:	d5fb      	bpl.n	8028ba2 <_printf_i+0x1ba>
 8028baa:	8019      	strh	r1, [r3, #0]
 8028bac:	2300      	movs	r3, #0
 8028bae:	6123      	str	r3, [r4, #16]
 8028bb0:	4616      	mov	r6, r2
 8028bb2:	e7bc      	b.n	8028b2e <_printf_i+0x146>
 8028bb4:	6833      	ldr	r3, [r6, #0]
 8028bb6:	1d1a      	adds	r2, r3, #4
 8028bb8:	6032      	str	r2, [r6, #0]
 8028bba:	681e      	ldr	r6, [r3, #0]
 8028bbc:	6862      	ldr	r2, [r4, #4]
 8028bbe:	2100      	movs	r1, #0
 8028bc0:	4630      	mov	r0, r6
 8028bc2:	f7d7 fb1d 	bl	8000200 <memchr>
 8028bc6:	b108      	cbz	r0, 8028bcc <_printf_i+0x1e4>
 8028bc8:	1b80      	subs	r0, r0, r6
 8028bca:	6060      	str	r0, [r4, #4]
 8028bcc:	6863      	ldr	r3, [r4, #4]
 8028bce:	6123      	str	r3, [r4, #16]
 8028bd0:	2300      	movs	r3, #0
 8028bd2:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 8028bd6:	e7aa      	b.n	8028b2e <_printf_i+0x146>
 8028bd8:	6923      	ldr	r3, [r4, #16]
 8028bda:	4632      	mov	r2, r6
 8028bdc:	4649      	mov	r1, r9
 8028bde:	4640      	mov	r0, r8
 8028be0:	47d0      	blx	sl
 8028be2:	3001      	adds	r0, #1
 8028be4:	d0ad      	beq.n	8028b42 <_printf_i+0x15a>
 8028be6:	6823      	ldr	r3, [r4, #0]
 8028be8:	079b      	lsls	r3, r3, #30
 8028bea:	d413      	bmi.n	8028c14 <_printf_i+0x22c>
 8028bec:	68e0      	ldr	r0, [r4, #12]
 8028bee:	9b03      	ldr	r3, [sp, #12]
 8028bf0:	4298      	cmp	r0, r3
 8028bf2:	bfb8      	it	lt
 8028bf4:	4618      	movlt	r0, r3
 8028bf6:	e7a6      	b.n	8028b46 <_printf_i+0x15e>
 8028bf8:	2301      	movs	r3, #1
 8028bfa:	4632      	mov	r2, r6
 8028bfc:	4649      	mov	r1, r9
 8028bfe:	4640      	mov	r0, r8
 8028c00:	47d0      	blx	sl
 8028c02:	3001      	adds	r0, #1
 8028c04:	d09d      	beq.n	8028b42 <_printf_i+0x15a>
 8028c06:	3501      	adds	r5, #1
 8028c08:	68e3      	ldr	r3, [r4, #12]
 8028c0a:	9903      	ldr	r1, [sp, #12]
 8028c0c:	1a5b      	subs	r3, r3, r1
 8028c0e:	42ab      	cmp	r3, r5
 8028c10:	dcf2      	bgt.n	8028bf8 <_printf_i+0x210>
 8028c12:	e7eb      	b.n	8028bec <_printf_i+0x204>
 8028c14:	2500      	movs	r5, #0
 8028c16:	f104 0619 	add.w	r6, r4, #25
 8028c1a:	e7f5      	b.n	8028c08 <_printf_i+0x220>
 8028c1c:	08033f1a 	.word	0x08033f1a
 8028c20:	08033f2b 	.word	0x08033f2b

08028c24 <_init>:
 8028c24:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8028c26:	bf00      	nop
 8028c28:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8028c2a:	bc08      	pop	{r3}
 8028c2c:	469e      	mov	lr, r3
 8028c2e:	4770      	bx	lr

08028c30 <_fini>:
 8028c30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8028c32:	bf00      	nop
 8028c34:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8028c36:	bc08      	pop	{r3}
 8028c38:	469e      	mov	lr, r3
 8028c3a:	4770      	bx	lr
