#include <stdio.h>
#include <stdlib.h>
#include <tss2/tss2_esys.h>
#include <fcntl.h>
#include <string.h>
#include "openssl/x509.h"
#include "openssl/x509_vfy.h"
#include "openssl/pem.h"
#include "openssl/err.h"
#include "openssl/evp.h"
#include "openssl/rand.h"

const unsigned char deviceCert[] = {
    0x30,0x82,0x04,0x49,0x30,0x82,0x03,0x31,0xa0,0x03,0x02,0x01,0x02,0x02,0x14,0x1b,
0x22,0x0f,0xeb,0x84,0xd6,0x25,0xa5,0x12,0x4a,0x50,0x18,0x59,0xac,0x66,0xdc,0x10,
0xdb,0x9d,0x63,0x30,0x0d,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x01,0x0b,
0x05,0x00,0x30,0x5d,0x31,0x0b,0x30,0x09,0x06,0x03,0x55,0x04,0x06,0x13,0x02,0x53,
0x4b,0x31,0x12,0x30,0x10,0x06,0x03,0x55,0x04,0x08,0x0c,0x09,0x53,0x6c,0x6f,0x76,
0x65,0x6e,0x73,0x6b,0x6f,0x31,0x0f,0x30,0x0d,0x06,0x03,0x55,0x04,0x07,0x0c,0x06,
0x4b,0x6f,0x73,0x69,0x63,0x65,0x31,0x0d,0x30,0x0b,0x06,0x03,0x55,0x04,0x0a,0x0c,
0x04,0x55,0x50,0x4a,0x53,0x31,0x0d,0x30,0x0b,0x06,0x03,0x55,0x04,0x0b,0x0c,0x04,
0x55,0x49,0x4e,0x46,0x31,0x0b,0x30,0x09,0x06,0x03,0x55,0x04,0x03,0x0c,0x02,0x43,
0x41,0x30,0x1e,0x17,0x0d,0x32,0x35,0x30,0x36,0x31,0x39,0x31,0x38,0x34,0x33,0x33,
0x38,0x5a,0x17,0x0d,0x32,0x37,0x30,0x36,0x31,0x39,0x31,0x38,0x34,0x33,0x33,0x38,
0x5a,0x30,0x61,0x31,0x0b,0x30,0x09,0x06,0x03,0x55,0x04,0x06,0x13,0x02,0x53,0x4b,
0x31,0x12,0x30,0x10,0x06,0x03,0x55,0x04,0x08,0x0c,0x09,0x53,0x6c,0x6f,0x76,0x65,
0x6e,0x73,0x6b,0x6f,0x31,0x0f,0x30,0x0d,0x06,0x03,0x55,0x04,0x07,0x0c,0x06,0x4b,
0x6f,0x73,0x69,0x63,0x65,0x31,0x0d,0x30,0x0b,0x06,0x03,0x55,0x04,0x0a,0x0c,0x04,
0x55,0x50,0x4a,0x53,0x31,0x0d,0x30,0x0b,0x06,0x03,0x55,0x04,0x0b,0x0c,0x04,0x55,
0x49,0x4e,0x46,0x31,0x0f,0x30,0x0d,0x06,0x03,0x55,0x04,0x03,0x0c,0x06,0x64,0x65,
0x76,0x69,0x63,0x65,0x30,0x82,0x01,0x22,0x30,0x0d,0x06,0x09,0x2a,0x86,0x48,0x86,
0xf7,0x0d,0x01,0x01,0x01,0x05,0x00,0x03,0x82,0x01,0x0f,0x00,0x30,0x82,0x01,0x0a,
0x02,0x82,0x01,0x01,0x00,0xa6,0x09,0x56,0x22,0xc2,0xd6,0xff,0xa4,0x50,0xfd,0x48,
0xce,0x3a,0x83,0x72,0x5d,0x22,0x04,0x12,0xd3,0x2a,0xf0,0x29,0x8e,0x76,0xf5,0x7e,
0xa9,0xd5,0xa3,0x8a,0x8c,0x6c,0x27,0x44,0x72,0xa3,0xec,0x4e,0x0d,0x4b,0xb8,0x0a,
0x27,0x8a,0xdd,0x60,0xb3,0xe1,0x1a,0xdd,0xb6,0xc4,0xfc,0x62,0x64,0xb6,0xd1,0x78,
0xa8,0x96,0x72,0xbb,0x17,0x4a,0xe3,0xd3,0xa2,0xff,0x5f,0x0b,0xfb,0xbd,0xca,0xed,
0x7e,0xca,0x9e,0x84,0x6e,0xe5,0xc6,0x65,0xa2,0xba,0x3b,0x82,0x0b,0x9a,0xb3,0x82,
0x40,0x14,0xaa,0x60,0xdb,0xaa,0x51,0x46,0x46,0xb9,0xc7,0x75,0x34,0x09,0x66,0x21,
0x42,0x72,0x77,0xd1,0x33,0xd5,0x1d,0x03,0x5e,0xfc,0x13,0xbd,0xe6,0xe3,0x2b,0x20,
0xaf,0x1f,0x0a,0xf6,0x8b,0xb7,0x8f,0x4b,0xe2,0x99,0x75,0x12,0x51,0x66,0xcd,0xc1,
0x54,0x1f,0xe2,0x1e,0x0f,0xf6,0x9c,0xea,0xb2,0xd7,0x1a,0x9a,0xeb,0x92,0xef,0xc8,
0x86,0xeb,0xe3,0xfb,0x7b,0xbc,0xfc,0xcd,0x7e,0x17,0x07,0xcb,0x48,0x85,0x1c,0xca,
0x80,0x79,0xa7,0x80,0x30,0x09,0x1f,0x25,0xc2,0x6b,0xb6,0xf3,0xb5,0xb3,0x6e,0x5c,
0x5c,0xdb,0x86,0x2c,0x13,0x15,0x3f,0x64,0x88,0xdc,0xcd,0xd7,0x7e,0x0d,0x02,0xd6,
0x32,0x4f,0x2e,0x01,0xa5,0x27,0x6c,0xb6,0xe3,0x10,0xc5,0x4e,0x45,0xcf,0x3d,0x81,
0xc0,0x43,0xfd,0x15,0xa9,0x70,0xfa,0xb3,0x3e,0xcd,0xce,0x31,0x9e,0xab,0x5c,0x3f,
0x2d,0x59,0xdf,0xb6,0x92,0x96,0x4d,0x0e,0xe0,0x64,0xc3,0x5f,0xdd,0xc9,0x40,0xa7,
0x0e,0x65,0x29,0x68,0x6f,0x02,0x03,0x01,0x00,0x01,0xa3,0x81,0xfc,0x30,0x81,0xf9,
0x30,0x0e,0x06,0x03,0x55,0x1d,0x0f,0x01,0x01,0xff,0x04,0x04,0x03,0x02,0x05,0xa0,
0x30,0x1d,0x06,0x03,0x55,0x1d,0x25,0x04,0x16,0x30,0x14,0x06,0x08,0x2b,0x06,0x01,
0x05,0x05,0x07,0x03,0x01,0x06,0x08,0x2b,0x06,0x01,0x05,0x05,0x07,0x03,0x02,0x30,
0x0c,0x06,0x03,0x55,0x1d,0x13,0x01,0x01,0xff,0x04,0x02,0x30,0x00,0x30,0x1d,0x06,
0x03,0x55,0x1d,0x0e,0x04,0x16,0x04,0x14,0x06,0xef,0x04,0xda,0x38,0x4c,0x29,0xb3,
0x33,0x7c,0x4a,0x6d,0x41,0x9d,0x20,0x05,0xc4,0x2b,0x83,0x85,0x30,0x81,0x9a,0x06,
0x03,0x55,0x1d,0x23,0x04,0x81,0x92,0x30,0x81,0x8f,0x80,0x14,0xe0,0x4f,0x89,0x1a,
0xef,0x12,0xb4,0x8f,0x91,0xbe,0x42,0x00,0x6a,0x1c,0x51,0x63,0x73,0x9f,0xee,0x74,
0xa1,0x61,0xa4,0x5f,0x30,0x5d,0x31,0x0b,0x30,0x09,0x06,0x03,0x55,0x04,0x06,0x13,
0x02,0x53,0x4b,0x31,0x12,0x30,0x10,0x06,0x03,0x55,0x04,0x08,0x0c,0x09,0x53,0x6c,
0x6f,0x76,0x65,0x6e,0x73,0x6b,0x6f,0x31,0x0f,0x30,0x0d,0x06,0x03,0x55,0x04,0x07,
0x0c,0x06,0x4b,0x6f,0x73,0x69,0x63,0x65,0x31,0x0d,0x30,0x0b,0x06,0x03,0x55,0x04,
0x0a,0x0c,0x04,0x55,0x50,0x4a,0x53,0x31,0x0d,0x30,0x0b,0x06,0x03,0x55,0x04,0x0b,
0x0c,0x04,0x55,0x49,0x4e,0x46,0x31,0x0b,0x30,0x09,0x06,0x03,0x55,0x04,0x03,0x0c,
0x02,0x43,0x41,0x82,0x14,0x07,0xe0,0xee,0x90,0xed,0x34,0x4f,0x72,0x6b,0xec,0xd5,
0x9d,0x9a,0xb7,0x25,0x07,0x14,0x92,0xcb,0x1b,0x30,0x0d,0x06,0x09,0x2a,0x86,0x48,
0x86,0xf7,0x0d,0x01,0x01,0x0b,0x05,0x00,0x03,0x82,0x01,0x01,0x00,0x19,0xca,0xef,
0xda,0x84,0x9f,0xd9,0x1f,0x4b,0x5e,0x6e,0x30,0x78,0xfd,0x5f,0x1e,0x9d,0x1d,0x58,
0x94,0x75,0x4a,0xa1,0xb2,0xdc,0xb2,0x24,0x28,0x89,0x6a,0x78,0x92,0x2d,0x10,0xa0,
0x78,0xeb,0x4d,0xac,0xd8,0xeb,0xae,0xd2,0x3c,0xa7,0x59,0x15,0x89,0x0a,0xd2,0x82,
0x34,0x32,0xfe,0x35,0x4a,0xf3,0x1c,0x5f,0x04,0x2b,0x37,0x7d,0x47,0x26,0x63,0x2a,
0xf0,0xe6,0x67,0x61,0xa5,0xdd,0x31,0xbd,0x67,0xfe,0xfb,0x03,0xdc,0x61,0xa6,0x01,
0x4d,0x53,0x1b,0x77,0x46,0xf2,0x1d,0xb1,0xe1,0x10,0x99,0x6e,0x75,0x63,0x39,0x89,
0x69,0x76,0x6d,0x4e,0xbf,0xef,0x37,0x68,0xbc,0x4d,0x54,0x68,0x92,0x15,0xf4,0x10,
0xff,0x9c,0xe6,0x1c,0x0f,0xdd,0x97,0xe3,0x94,0xdb,0x38,0xad,0x38,0x28,0x45,0x83,
0x0e,0xe2,0x7d,0x1d,0x87,0x54,0x5a,0x20,0x24,0x6f,0xa5,0x58,0xa3,0x03,0x1d,0xb7,
0x74,0x16,0x13,0x24,0x89,0x2f,0x66,0x56,0x8c,0x01,0x19,0xf3,0x7a,0x0c,0x62,0xbe,
0x70,0x26,0x6d,0xca,0x1d,0xda,0x76,0xf4,0x32,0xdf,0x0c,0xeb,0xb4,0xe7,0x5f,0x17,
0xbd,0x48,0x24,0xdb,0x01,0xbf,0x28,0xa0,0x62,0xf8,0xb5,0xbb,0xfb,0xc1,0x44,0x98,
0x9c,0x4d,0xc2,0x75,0xad,0xbb,0xd5,0x66,0x2c,0xba,0xbf,0xf2,0x8f,0xe4,0x1c,0xb4,
0x95,0x40,0x74,0xe8,0x2c,0xab,0xba,0x7c,0x54,0xbd,0x5f,0x0d,0x27,0xa5,0x94,0xdb,
0xa8,0x14,0xb5,0xc1,0x89,0xd6,0xff,0x95,0xa0,0xe1,0x42,0x8c,0x51,0xae,0x05,0x7b,
0xc2,0xbe,0x74,0x6c,0x58,0x56,0xa8,0xde,0x93,0xdb,0x66,0x64,0x33
};
const uint16_t deviceCertLen = sizeof(deviceCert);

int urandom_random_bytes(uint8_t array[16]) {
    int fd = open("/dev/urandom", O_RDONLY);
    if (fd < 0) {
        perror("Error opening /dev/urandom");
        return -1;
    }

    ssize_t bytes_read = read(fd, array, 16);
    close(fd);

    if (bytes_read != 16) {
        perror("Error reading from /dev/urandom");
        return -1;
    }

    return 0;
}

int verify_cert(const unsigned char *der, size_t der_len, const char *ca_pem_path)
{
    const unsigned char *p = der;
    X509 *cert = d2i_X509(NULL, &p, der_len);
    if(!cert) {
        fprintf(stderr, "Nepodarilo sa parsnut certifikat");
        return 0;
    }

    FILE *ca_file = fopen(ca_pem_path, "r");
    if(!ca_file) {
        fprintf(stderr, "Nepodarilo sa nacitat CA subor");
        X509_free(cert);
        return 0;
    }

    X509 *ca_cert = PEM_read_X509(ca_file, NULL, NULL, NULL);
    fclose(ca_file);
    if(!ca_cert) {
        fprintf(stderr, "Nepodarilo sa parsnut CA certifikat");
        X509_free(cert);
        return 0;
    }

    X509_STORE *store = X509_STORE_new();
    X509_STORE_add_cert(store, ca_cert);

    X509_STORE_CTX *ctx = X509_STORE_CTX_new();
    X509_STORE_CTX_init(ctx, store, cert, NULL);

    int ret = X509_verify_cert(ctx);
    if (ret != 1)
    {
        int err = X509_STORE_CTX_get_error(ctx);
        printf("Neuspesna verifikacia: %s\n", X509_verify_cert_error_string(err));
    }
    
    X509_free(cert);
    X509_free(ca_cert);
    X509_STORE_CTX_free(ctx);
    X509_STORE_free(store);

    return ret == 1;
}

EVP_PKEY* extract_pubkey(const unsigned char *der, size_t der_len){
    const unsigned char *p = der;
    X509 *cert = d2i_X509(NULL, &p, der_len);
    if(!cert) {
        fprintf(stderr, "Nepodarilo sa parsnut certifikat");
        return 0;
    }

    EVP_PKEY *pubkey = X509_get_pubkey(cert);
    if (!pubkey) {
        fprintf(stderr, "Nepodarilo sa extrahovat public key\n");
        ERR_print_errors_fp(stderr);
    }

    X509_free(cert);
    return pubkey;
}

int aes_encrypt(const unsigned char *plaintext, int plaintext_len,
                const unsigned char *key, const unsigned char *iv,
                unsigned char *ciphertext, int *ciphertext_len) {
    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
    if (!ctx) {
        return 0;
    }
    if (!EVP_EncryptInit_ex(ctx, EVP_aes_128_cbc(), NULL, key, iv)) {
        return 0;
    }
    // sprava je uz vyplnena nulami tak vypneme padding
    EVP_CIPHER_CTX_set_padding(ctx, 0);
    int len;
    *ciphertext_len = 0;

    if (!EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, plaintext_len)) {
        return 0;
    }
    *ciphertext_len += len;

    EVP_CIPHER_CTX_free(ctx);
    return 1;
}

int encrypt_with_pubkey(EVP_PKEY *pubkey, const unsigned char *plaintext, size_t plaintext_len,
                        unsigned char *ciphertext, size_t *ciphertext_len) {
    EVP_PKEY_CTX *ctx = EVP_PKEY_CTX_new(pubkey, NULL);
    if (!ctx) return 0;

    if (EVP_PKEY_encrypt_init(ctx) <= 0) return 0;

    if (EVP_PKEY_encrypt(ctx, ciphertext, ciphertext_len, plaintext, plaintext_len) <= 0) return 0;

    EVP_PKEY_CTX_free(ctx);
    return 1;
}

int aes_decrypt(const unsigned char *ciphertext, int ciphertext_len,
                const unsigned char *key, const unsigned char *iv,
                unsigned char *plaintext, int *plaintext_len) {
    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
    if (!ctx)
        return 0;

    if (!EVP_DecryptInit_ex(ctx, EVP_aes_128_cbc(), NULL, key, iv)) {
        EVP_CIPHER_CTX_free(ctx);
        return 0;
    }

    int len = 0;
    *plaintext_len = 0;

    if (!EVP_DecryptUpdate(ctx, plaintext, &len, ciphertext, ciphertext_len)) {
        EVP_CIPHER_CTX_free(ctx);
        return 0;
    }
    *plaintext_len = len;

    if (!EVP_DecryptFinal_ex(ctx, plaintext + len, &len)) {
        EVP_CIPHER_CTX_free(ctx);
        return 0;
    }
    *plaintext_len += len;

    EVP_CIPHER_CTX_free(ctx);
    return 1;
}
/*
char* nvread() {
    TSS2_RC rc;
    ESYS_CONTEXT *ectx;

    rc = Esys_Initialize(&ectx, NULL, NULL);
    if (rc != TSS2_RC_SUCCESS) {
        fprintf(stderr, "Esys inicializacia zlyhala: 0x%x\n", rc);
        return 1;
    }

    ESYS_TR authHandle = ESYS_TR_RH_OWNER;
    ESYS_TR nvHandle;

    rc = Esys_TR_FromTPMPublic(ectx, 0x1410010, ESYS_TR_NONE, ESYS_TR_NONE, ESYS_TR_NONE, &nvHandle);
    if (rc != TSS2_RC_SUCCESS) {
        fprintf(stderr, "Esys TR_FromTPMPublic zlyhal: 0x%x\n", rc);
        Esys_Finalize(&ectx);
        return 1;
    }

    TPM2B_MAX_NV_BUFFER *nvData;
    rc = Esys_NV_Read(ectx, authHandle, nvHandle, ESYS_TR_PASSWORD, ESYS_TR_NONE, ESYS_TR_NONE, 64, 0, &nvData);
    if (rc != TSS2_RC_SUCCESS) {
        fprintf(stderr, "Esys NV_Read zlyhal: 0x%x\n", rc);
        Esys_Finalize(&ectx);
        return 1;
    }
    char *nvString = malloc(nvData->size + 1);
    if (!nvString) {
        fprintf(stderr, "malloc pre string zlyhal\n");
        Esys_Free(nvData);
        Esys_Finalize(&ectx);
        return 1;
    }
    memcpy(nvString, nvData->buffer, nvData->size);
    nvString[nvData->size] = '\0'; // null zakoncenie

    Esys_Free(nvData);
    Esys_Finalize(&ectx);
    return nvString;
}
*/
int sign_sha256_hash(uint8_t hash[SHA256_DIGEST_LENGTH], EVP_PKEY *pkey,
                     uint8_t **signature, size_t *sig_len) {
    RSA *rsa = EVP_PKEY_get1_RSA(pkey);
    if (!rsa) return 0;

    *signature = malloc(RSA_size(rsa));
    if (!*signature) {
        RSA_free(rsa);
        return 0;
    }

    unsigned int sig_len_tmp = 0;
    int success = RSA_sign(NID_sha256, hash, SHA256_DIGEST_LENGTH,
                           *signature, &sig_len_tmp, rsa);

    RSA_free(rsa);

    if (!success) {
        free(*signature);
        *signature = NULL;
        return 0;
    }

    *sig_len = sig_len_tmp;
    return 1;
}