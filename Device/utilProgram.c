#include <stdio.h>
#include <stdlib.h>
#include <tss2/tss2_esys.h>
#include <fcntl.h>
#include <string.h>
#include "openssl/x509.h"
#include "openssl/x509_vfy.h"
#include "openssl/pem.h"
#include "openssl/err.h"
#include "openssl/evp.h"
#include "openssl/rand.h"

const unsigned char deviceCert[] = {
    0x30,0x82,0x03,0x35,0x30,0x82,0x02,0x1d,0x02,0x14,0x55,0xef,0x11,0xd2,0xb4,0xdf,
0xcb,0x4f,0x4d,0x7d,0x48,0xcb,0x69,0xb5,0x08,0xc5,0x3b,0xdf,0x7a,0x2e,0x30,0x0d,
0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x01,0x0b,0x05,0x00,0x30,0x5e,0x31,
0x0b,0x30,0x09,0x06,0x03,0x55,0x04,0x06,0x13,0x02,0x53,0x4b,0x31,0x0f,0x30,0x0d,
0x06,0x03,0x55,0x04,0x08,0x0c,0x06,0x4b,0x6f,0x73,0x69,0x63,0x65,0x31,0x0f,0x30,
0x0d,0x06,0x03,0x55,0x04,0x07,0x0c,0x06,0x4b,0x6f,0x73,0x69,0x63,0x65,0x31,0x0d,
0x30,0x0b,0x06,0x03,0x55,0x04,0x0a,0x0c,0x04,0x55,0x50,0x4a,0x53,0x31,0x11,0x30,
0x0f,0x06,0x03,0x55,0x04,0x0b,0x0c,0x08,0x64,0x69,0x70,0x6c,0x6f,0x6d,0x6b,0x61,
0x31,0x0b,0x30,0x09,0x06,0x03,0x55,0x04,0x03,0x0c,0x02,0x43,0x41,0x30,0x1e,0x17,
0x0d,0x32,0x35,0x30,0x38,0x31,0x39,0x31,0x36,0x34,0x36,0x35,0x35,0x5a,0x17,0x0d,
0x32,0x37,0x31,0x31,0x32,0x32,0x31,0x36,0x34,0x36,0x35,0x35,0x5a,0x30,0x50,0x31,
0x0b,0x30,0x09,0x06,0x03,0x55,0x04,0x06,0x13,0x02,0x53,0x4b,0x31,0x0f,0x30,0x0d,
0x06,0x03,0x55,0x04,0x08,0x0c,0x06,0x4b,0x6f,0x73,0x69,0x63,0x65,0x31,0x10,0x30,
0x0e,0x06,0x03,0x55,0x04,0x07,0x0c,0x07,0x4b,0x6f,0x73,0x69,0x63,0x65,0x65,0x31,
0x0d,0x30,0x0b,0x06,0x03,0x55,0x04,0x0a,0x0c,0x04,0x55,0x50,0x4a,0x53,0x31,0x0f,
0x30,0x0d,0x06,0x03,0x55,0x04,0x03,0x0c,0x06,0x64,0x65,0x76,0x69,0x63,0x65,0x30,
0x82,0x01,0x22,0x30,0x0d,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x01,0x01,
0x05,0x00,0x03,0x82,0x01,0x0f,0x00,0x30,0x82,0x01,0x0a,0x02,0x82,0x01,0x01,0x00,
0xaa,0xa8,0x3d,0xb7,0x7e,0x0c,0xe4,0x92,0x94,0xa5,0x02,0x30,0x4a,0x56,0x71,0xd0,
0xf2,0x7b,0xa8,0xad,0x98,0x81,0xf8,0xdd,0xee,0xb6,0xc3,0xac,0xc2,0x60,0x72,0x97,
0x58,0x61,0xd5,0x44,0xa0,0xe7,0xf5,0x3e,0x12,0xc1,0xf7,0xc9,0xd9,0x80,0xdc,0x10,
0xc7,0x00,0xaa,0x36,0xe9,0x63,0xd6,0x98,0xde,0xde,0x68,0x4b,0x52,0x7a,0x9a,0x4c,
0x0b,0xa0,0x85,0x58,0xcd,0x11,0x00,0xe2,0x4a,0x08,0x47,0xaa,0x74,0x51,0x62,0x65,
0x3e,0xe1,0x85,0xf7,0x17,0x42,0xb0,0xfa,0x00,0xb3,0xfb,0xde,0xc5,0x29,0xf4,0xbb,
0x91,0x43,0x88,0x46,0xb2,0x10,0x14,0xb8,0xc5,0xfd,0xe5,0x3e,0x2b,0x49,0x72,0x09,
0xd2,0xb6,0xfd,0x40,0x8e,0x77,0x2d,0x6d,0x1e,0xe9,0x92,0xad,0xb1,0x55,0x11,0xed,
0x36,0x47,0x28,0x74,0xa0,0x44,0xb1,0x1d,0xb8,0x9d,0xfb,0x77,0xe2,0x47,0xe5,0x52,
0xc8,0x12,0x94,0x79,0x18,0x99,0xc8,0xe6,0xd6,0xf7,0x15,0x6d,0x2d,0x3c,0xed,0xea,
0x3c,0x0e,0x34,0x03,0x2b,0x21,0xdd,0xc8,0x44,0x9b,0x7f,0xc3,0x73,0x78,0x42,0x70,
0xa7,0x5c,0x69,0xf8,0x36,0x0a,0x87,0xe8,0xb6,0xaf,0x40,0xbd,0xd1,0x4e,0x81,0x63,
0x20,0x05,0x80,0x11,0xfc,0x44,0x6e,0x97,0x6e,0xb9,0xa8,0xcd,0x65,0x8e,0x91,0x84,
0x16,0xe9,0x40,0x17,0x0a,0xe7,0xad,0x21,0x7c,0xae,0xee,0xb3,0x29,0xae,0x22,0xcf,
0xe7,0x92,0xbf,0x10,0xc2,0xce,0x40,0x47,0x7f,0xa2,0xd8,0xc5,0x9c,0xeb,0xa8,0xc7,
0xef,0xc9,0x09,0xae,0xf4,0x07,0x0d,0xa9,0xe3,0x5b,0x18,0x8c,0x22,0x69,0x3b,0x6b,
0x02,0x03,0x01,0x00,0x01,0x30,0x0d,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,
0x01,0x0b,0x05,0x00,0x03,0x82,0x01,0x01,0x00,0x40,0xc6,0xb5,0x03,0x9b,0x75,0xf1,
0xc1,0x97,0x5b,0xd6,0xc1,0x37,0xe1,0xda,0x53,0x9e,0x9e,0x9b,0x10,0xb8,0xb3,0x3b,
0xf2,0xab,0xf6,0x18,0x0f,0xcc,0x08,0x5e,0xde,0x3a,0x86,0x3f,0x1d,0x28,0xe9,0x68,
0xff,0x9e,0x05,0x2e,0x64,0x59,0x06,0xc8,0x4b,0x42,0xf8,0x6b,0x15,0x5c,0x11,0x82,
0x8d,0xc1,0x0a,0xe0,0xda,0x15,0x59,0xed,0x61,0xf3,0x7f,0xcb,0xdb,0xe0,0x27,0xa1,
0xca,0x21,0x1f,0xc3,0x37,0x1b,0x9f,0xef,0x9e,0x96,0x92,0xaf,0xcf,0x5d,0x43,0xdd,
0x0d,0xb3,0x1a,0x29,0xdc,0x73,0x23,0xad,0x02,0xc6,0x67,0xca,0x4f,0x9b,0x86,0xee,
0x65,0xf8,0x73,0x84,0x17,0xd1,0xc7,0x3a,0x18,0x63,0x3b,0x27,0xfe,0x41,0x7a,0x3f,
0x85,0x12,0x07,0x2a,0xd6,0xa5,0x89,0xb4,0x68,0xed,0x05,0x65,0x79,0xea,0x20,0xb2,
0x94,0x62,0xb1,0xb5,0x31,0xfe,0x1d,0x3f,0xe6,0xdb,0x6f,0x50,0x3b,0x3c,0x73,0xef,
0x50,0xd0,0xcd,0x58,0x7f,0xe9,0xfa,0xf5,0x12,0x12,0x6c,0x56,0xb5,0x85,0x5f,0x6f,
0xe2,0x7d,0x09,0xf3,0x2e,0x69,0x20,0xc2,0xf5,0x57,0x49,0x74,0x0b,0xb6,0x00,0x80,
0xc8,0xa3,0xb1,0x59,0x6c,0x7b,0x91,0x14,0x80,0x63,0x24,0xa2,0xd0,0x2e,0x55,0xbe,
0x24,0x8d,0xf6,0x84,0xc0,0xdb,0x0e,0x76,0xe4,0x66,0x41,0xfb,0x07,0x57,0x2e,0xf1,
0x5f,0x39,0x9f,0x65,0x25,0x90,0x7e,0x79,0xdb,0xdf,0xa2,0x45,0xf5,0x0e,0x5c,0x79,
0xff,0xb1,0x87,0xc6,0x61,0x43,0x1a,0x58,0x67,0x1c,0x1f,0xb5,0x87,0x5e,0xd4,0x5a,
0x56,0x4b,0x89,0x82,0xf1,0x84,0x0f,0x70,0x05
};
const uint16_t deviceCertLen = sizeof(deviceCert);

int urandom_random_bytes(uint8_t array[16]) {
    int fd = open("/dev/urandom", O_RDONLY);
    if (fd < 0) {
        perror("Error opening /dev/urandom");
        return -1;
    }

    ssize_t bytes_read = read(fd, array, 16);
    close(fd);

    if (bytes_read != 16) {
        perror("Error reading from /dev/urandom");
        return -1;
    }

    return 0;
}

int verify_cert(const unsigned char *der, size_t der_len, const char *ca_pem_path)
{
    const unsigned char *p = der;
    X509 *cert = d2i_X509(NULL, &p, der_len);
    if(!cert) {
        fprintf(stderr, "Nepodarilo sa parsnut certifikat");
        return 0;
    }

    FILE *ca_file = fopen(ca_pem_path, "r");
    if(!ca_file) {
        fprintf(stderr, "Nepodarilo sa nacitat CA subor");
        X509_free(cert);
        return 0;
    }

    X509 *ca_cert = PEM_read_X509(ca_file, NULL, NULL, NULL);
    fclose(ca_file);
    if(!ca_cert) {
        fprintf(stderr, "Nepodarilo sa parsnut CA certifikat");
        X509_free(cert);
        return 0;
    }

    X509_STORE *store = X509_STORE_new();
    X509_STORE_add_cert(store, ca_cert);

    X509_STORE_CTX *ctx = X509_STORE_CTX_new();
    X509_STORE_CTX_init(ctx, store, cert, NULL);

    int ret = X509_verify_cert(ctx);
    if (ret != 1)
    {
        int err = X509_STORE_CTX_get_error(ctx);
        printf("Neuspesna verifikacia: %s\n", X509_verify_cert_error_string(err));
    }
    
    X509_free(cert);
    X509_free(ca_cert);
    X509_STORE_CTX_free(ctx);
    X509_STORE_free(store);

    return ret == 1;
}

EVP_PKEY* extract_pubkey(const unsigned char *der, size_t der_len){
    const unsigned char *p = der;
    X509 *cert = d2i_X509(NULL, &p, der_len);
    if(!cert) {
        fprintf(stderr, "Nepodarilo sa parsnut certifikat");
        return 0;
    }

    EVP_PKEY *pubkey = X509_get_pubkey(cert);
    if (!pubkey) {
        fprintf(stderr, "Nepodarilo sa extrahovat public key\n");
        ERR_print_errors_fp(stderr);
    }

    X509_free(cert);
    return pubkey;
}

int aes_encrypt(const unsigned char *plaintext, int plaintext_len,
                const unsigned char *key, const unsigned char *iv,
                unsigned char *ciphertext, int *ciphertext_len) {
    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
    if (!ctx) {
        return 0;
    }
    if (!EVP_EncryptInit_ex(ctx, EVP_aes_128_cbc(), NULL, key, iv)) {
        return 0;
    }
    // sprava je uz vyplnena nulami tak vypneme padding
    EVP_CIPHER_CTX_set_padding(ctx, 0);
    int len;
    *ciphertext_len = 0;

    if (!EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, plaintext_len)) {
        return 0;
    }
    *ciphertext_len += len;

    EVP_CIPHER_CTX_free(ctx);
    return 1;
}

int encrypt_with_pubkey(EVP_PKEY *pubkey, const unsigned char *plaintext, size_t plaintext_len,
                        unsigned char *ciphertext, size_t *ciphertext_len) {
    EVP_PKEY_CTX *ctx = EVP_PKEY_CTX_new(pubkey, NULL);
    if (!ctx) return 0;

    if (EVP_PKEY_encrypt_init(ctx) <= 0) return 0;

    if (EVP_PKEY_encrypt(ctx, ciphertext, ciphertext_len, plaintext, plaintext_len) <= 0) return 0;

    EVP_PKEY_CTX_free(ctx);
    return 1;
}

int aes_decrypt(const unsigned char *ciphertext, int ciphertext_len,
                const unsigned char *key, const unsigned char *iv,
                unsigned char *plaintext, int *plaintext_len) {
    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
    if (!ctx)
        return 0;

    if (!EVP_DecryptInit_ex(ctx, EVP_aes_128_cbc(), NULL, key, iv)) {
        EVP_CIPHER_CTX_free(ctx);
        return 0;
    }

    int len = 0;
    *plaintext_len = 0;

    if (!EVP_DecryptUpdate(ctx, plaintext, &len, ciphertext, ciphertext_len)) {
        EVP_CIPHER_CTX_free(ctx);
        return 0;
    }
    *plaintext_len = len;

    if (!EVP_DecryptFinal_ex(ctx, plaintext + len, &len)) {
        EVP_CIPHER_CTX_free(ctx);
        return 0;
    }
    *plaintext_len += len;

    EVP_CIPHER_CTX_free(ctx);
    return 1;
}

char* nvread() {
    TSS2_RC rc;
    ESYS_CONTEXT *ectx;

    rc = Esys_Initialize(&ectx, NULL, NULL);
    if (rc != TSS2_RC_SUCCESS) {
        fprintf(stderr, "Esys inicializacia zlyhala: 0x%x\n", rc);
        return 1;
    }

    ESYS_TR authHandle = ESYS_TR_RH_OWNER;
    ESYS_TR nvHandle;

    rc = Esys_TR_FromTPMPublic(ectx, 0x1410010, ESYS_TR_NONE, ESYS_TR_NONE, ESYS_TR_NONE, &nvHandle);
    if (rc != TSS2_RC_SUCCESS) {
        fprintf(stderr, "Esys TR_FromTPMPublic zlyhal: 0x%x\n", rc);
        Esys_Finalize(&ectx);
        return 1;
    }

    TPM2B_MAX_NV_BUFFER *nvData;
    rc = Esys_NV_Read(ectx, authHandle, nvHandle, ESYS_TR_PASSWORD, ESYS_TR_NONE, ESYS_TR_NONE, 32, 0, &nvData);
    if (rc != TSS2_RC_SUCCESS) {
        fprintf(stderr, "Esys NV_Read zlyhal: 0x%x\n", rc);
        Esys_Finalize(&ectx);
        return 1;
    }
    char *nvString = malloc(nvData->size + 1);
    if (!nvString) {
        fprintf(stderr, "malloc pre string zlyhal\n");
        Esys_Free(nvData);
        Esys_Finalize(&ectx);
        return 1;
    }
    memcpy(nvString, nvData->buffer, nvData->size);
    nvString[nvData->size] = '\0'; // null zakoncenie

    Esys_Free(nvData);
    Esys_Finalize(&ectx);
    return nvString;
}

int sign_sha256_hash(uint8_t hash[SHA256_DIGEST_LENGTH], EVP_PKEY *pkey,
                     uint8_t **signature, size_t *sig_len) {
    RSA *rsa = EVP_PKEY_get1_RSA(pkey);
    if (!rsa) return 0;

    int rsa_size = RSA_size(rsa);
    *signature = malloc(rsa_size);
    if (!*signature) {
        RSA_free(rsa);
        return 0;
    }

    // PKCS#1 v1.5 sifrovanie hashu sukromnym klucom zariadenia
    int ret = RSA_private_encrypt(
        32,                 // dlzka vstupu, teda dlzka SHA256 hashu
        hash,               // vstup, teda hash spravy c. 5
        *signature,         // vystup buffer
        rsa,                // RSA kluc
        RSA_PKCS1_PADDING   // PKCS#1 v1.5 padding
    );

    RSA_free(rsa);

    if (ret <= 0) {
        free(*signature);
        *signature = NULL;
        return 0;
    }

    *sig_len = (size_t)ret;
    return 1;
}